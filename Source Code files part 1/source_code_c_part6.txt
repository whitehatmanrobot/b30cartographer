unsigned short count);
extern  int error_handler(unsigned short count);
extern  int ocrm_handler(unsigned short count);
extern  int gen_ioctl_handler(unsigned short count);
extern void print_modes(int in_memory);
extern void prepare_drive_size(int device_index, char *size_buff);
extern int drive_info_handler(word count);
extern void drive_mappings(int in_memory);
/* File main.c */ 
extern void make_printer_map(void);
extern void pascal show_status(int status);
extern void _fastcall show_dp_status(int status);
extern  void setup_auxiliary_devices(void );
extern  void make_scan_portal(void);
extern  void cdecl main(int argc,char * *argv);
extern  void pascal reset_all_serial_ports(void);
extern  void setup_block_devices(void);
/* File quit.c */ 
extern  void cdecl quit(void );
extern  int push_exit_routine(void (pascal *func)(void ));
extern  void (pascal *pop_exit_routine(void ))(void );
/* File screenio.c */ 
extern  void cdecl warn_printf(char *fmt,...);
extern  void cdecl inform_printf(char *fmt,...);
extern  void cdecl fatal_printf(char *fmt,...);
extern  void _fastcall fatal_error(int num);
extern  void set_expansion_box_colors(void );
extern  int cdecl verify_printf(char *header, char *fmt, ...);
extern void show_drive_mappings(byte *map_table, int show_master);
extern void generate_drive_mappings(byte *map_table, int num_master_units, byte *desired_map);
extern void draw_screen(char *string, int extra_lines, int color);
extern void _cdecl do_init_screen(void);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\clone.c ===
#include <bios.h>
#include <dos.h>
#include <string.h>
#include <direct.h>
#include <stdio.h>
#include <io.h>
#include <stdlib.h>
#include <fcntl.h>
#include <memory.h>
#include <string.h>
#include <conio.h>
#include <stdarg.h>
#include <errno.h>
#include "fastlynx.h"
#include "server.h"
#include "dc.h"

#define CTRL_C	    0x003
#define ESC	        0x01B

int _fastcall percent(long current, long total);
void _fastcall getargs(char near *cmdline);
void _fastcall getprog(char near *progname);
void near pascal set_critical_error(void);
void _fastcall long_to_ascii(long value, char near *buff);
unsigned int _fastcall pstrlen(char near *str);
int _fastcall isdigit(byte value);
unsigned pascal paragon_bios_keybrd(unsigned service);
void add_all_bios_serial(void);
void add_all_bios_parallel(void);

#include "str.h"

#pragma intrinsic(memset, _enable, _disable, memcmp)

extern byte check_abort_flag;

static char dl_name[]  = "interlnk.exe";

static int top_row;
static int left_col;
static int box_height;
static int box_width;
static int remote_port;
static int screen_height;
static int screen_width;
static int status_col;
static int percent_col;
static int scan_port_col;
static int left_margin;

char *server_name = "intersvr.exe";

extern struct FxBiosInfo Bios;
extern char *final_msg;

char double_percent_s[] = "%s%s";

static byte exit_called = FALSE;
static byte remote_found = FALSE;       // Set TRUE when remote computer found

void draw_screen(char *string, int extra_lines, int color)
{
    char *ptr = string;
    int width;
    char *lines[20];
    int  widths[20];
    int  i;

    fill_attr(coord(1, 0), boxsize(scr_rows - 2, 80), ' ', TITLE_COLOR);
    screen_height = 0;
    screen_width = 0;
    while (*ptr) {
        lines[screen_height] = ptr;
        width = 0;
        while (*ptr && *ptr != '\n') {
            width++;
            ptr++;
        }
        if (width > screen_width)
            screen_width = width;
        widths[screen_height] = width;
        screen_height++;
        if (*ptr == '\n') ptr++;
    }
    box_height = (screen_height + 4 + extra_lines);
    box_width  = screen_width + 6;
    top_row = (scr_rows - 2 - box_height) / 2 + 1;
    left_col = (80 - (screen_width + 6)) / 2;
    draw_box(coord(top_row, left_col),  boxsize(box_height, box_width),
            SINGLE, color);
    for (i = 0; i < screen_height; i++) {
        if (widths[i])
            dispmem_attr(coord(top_row + 2 + i, left_col + 3),
                lines[i], widths[i], color);
    }
}

static void call_clone_exit(void)
{
    static byte clone_exit_cmd = CLONE_EXIT_CMD;

    if (remote_found && !exit_called) {
        exit_called = TRUE;
        if (fx_baud == BAUD_38400)
            FxSendSerialBlock(&clone_exit_cmd, sizeof(clone_exit_cmd));
        FxCloneExit();
    }
}

static void cdecl error_printf(char *fmt, ...)
{
    va_list arg_ptr;
    char msg_buff[512];

    va_start(arg_ptr, fmt);
    vsprintf(msg_buff, fmt, arg_ptr);
    strcat(msg_buff, press_enter_to_return);
    call_clone_exit();
    draw_screen(msg_buff, 0, ERROR_COLOR);
    for (;;) {
        if ( read_key() == '\r' )
            break;
    }
}

void near _fastcall update_progress(int percentage)
{
    char buff[5];

    sprintf(buff, "%3d%%", percentage);
    dispstr_attr(coord(scr_rows - 1, percent_col), buff, STATUS_COLOR);
}

static int near pascal get_upload_options()
{
    int key;
    word start_ticks = bios_ticks();
    int option_row;
    int last_remote_port;
    char screen2[1024];

    justify_str(coord(scr_rows - 1, 0), 80, STATUS_COLOR, install_status_line1, -1);
    draw_screen(install_signon, 5, LIST_NORMAL);
    option_row = top_row + 4 + screen_height;
    draw_box(coord(option_row - 1, 35), boxsize(4, 10), SINGLE, LIST_NORMAL);
    last_remote_port = -1;
    remote_port = 0;
    do
    {
        if (remote_port != last_remote_port) {
            last_remote_port = remote_port;
            justify_str(coord(option_row, 36), 8,
                        remote_port == 0 ? LIST_REVERSE : LIST_NORMAL,
                        "COM1", 0);
            justify_str(coord(option_row + 1, 36), 8,
                        remote_port == 0 ? LIST_NORMAL : LIST_REVERSE,
                        "COM2", 0);
        }
        if ( check_key() ) {
            key = read_key();
            switch (key) {
            case CTRL_C:
            case ALT_F4:
                key = F3;
                break;
            case '1':
                remote_port = 0;
                break;
            case '2':
                remote_port = 1;
                break;
            case UP:
                if (remote_port)
                    remote_port = 0;
                break;
            case DOWN:
                if (remote_port == 0)
                    remote_port++;
                break;
            }
        }
    } while (key != '1' && key != '2' && key != F3 && key != '\r');
    if (key == F3) return FALSE;

    strtcpy(screen2, upload_remote_prompt, sizeof(screen2));
    strrepc(screen2, '#', remote_port + '1');
    draw_screen(screen2, 0, LIST_NORMAL);
    justify_str(coord(scr_rows - 1, 0), 80, STATUS_COLOR, install_status_line2, -1);
    status_col = strchr(install_status_line2, '') - install_status_line2;
    while (install_status_line2[status_col + 1] == ' ')
        status_col++;
    scan_port_col = strchr(install_status_line2, '#') - install_status_line2;
    return TRUE;
}

static int _near _fastcall send_file(byte *file_name)
{
    struct find_t find_buff;
    int fd;
    FILESIZE bytes_sent;
    struct clone_cmd clone;
    char buff[80];

    if ( _dos_findfirst(file_name, _A_NORMAL, &find_buff) != 0 ) {  /* File or dir */
        error_printf("%s: not found.\n", file_name);
        return TRUE;
    }
    clone.command = CLONE_CREATE_CMD;
    clone.dir     = *((struct dir_entry *)&find_buff.attrib);
    sprintf(buff, "%s %s (%ld) ", sending_prefix, file_name, clone.dir.size);
    justify_str(coord(scr_rows - 1, status_col), 80 - status_col,
                STATUS_COLOR, buff, -1);
    percent_col = status_col + pstrlen(buff);
    if ( _dos_open(file_name, O_RDONLY, &fd) != 0 )
        fd = -1;
    if (fd < 0) {
        error_printf(open_error_msg, file_name);
        goto err_return;
    }
    sprintf(clone.ok_msg, "%s %s (%ld)   0%%",
            receiving_prefix, clone.dir.name, clone.dir.size);
    sprintf(clone.error_msg, clone_create_error, clone.dir.name);
    if ( !FxSendSerialBlock(&clone, (byte *)&clone.cnt - (byte *)&clone) )
        goto err_return;
    bytes_sent = 0;
    update_progress(0);
    while (fd >= 0) {
        if ( _dos_read(fd, clone.data, MAX_CLONE_DATA, &clone.cnt) != 0 ) {
            error_printf(read_error_msg, file_name);
            goto err_return;
        }
        bytes_sent += clone.cnt;
        update_progress( percent(bytes_sent, clone.dir.size) );
        sprintf(clone.error_msg, clone_write_error, clone.dir.name);
        if (clone.cnt) {
            clone.command = CLONE_WRITE_CMD;
            sprintf(clone.ok_msg, "\b\b\b\b%3d%%",
                percent(bytes_sent, clone.dir.size));
            if ( !FxSendSerialBlock(&clone, (clone.data - (byte *)&clone) + clone.cnt) )
                goto err_return;
        }
        if (clone.cnt != MAX_CLONE_DATA) {          /* Assume end of file */
            if (bytes_sent != clone.dir.size) {
                error_printf(allocation_error, file_name);
                goto err_return;
            }
            _dos_close(fd);
            fd = -1;
            clone.command = CLONE_CLOSE_CMD;
            strcpy(clone.ok_msg, "\n");
            // Leave the write error message in error_msg
            if ( !FxSendSerialBlock(&clone, ((byte *)&clone.cnt - (byte *)&clone)) )
                goto err_return;
        }
    }
    return TRUE;

err_return:
    if (fd != -1) {
        _dos_close(fd);
    }
    if (!exit_called) {
        if (check_abort_flag)
            error_printf(upload_cancelled);
        else
            error_printf(upload_transfer_error);
    }
    return FALSE;
}

static int _far _cdecl CloneCheckAbort(void)
{
    int key;

    while (check_key()) {
        key = read_key();
        if (key == F3 || key == ALT_F4 || key == CTRL_C) {
            check_abort_flag = TRUE;
            return -1;
        }
    }
    return 0;
}

static void do_clone(void)
{
#define MAX_ATTEMPTS    3
    char interlink_path[MAX_DOS_PATH];
    char path_prefix[MAX_DOS_PATH];
    char *path_tail;
    int port_index = 0;
    int request;
    int result;
    int bootstrap_size;
    int bootstrap_sent;
    int no_send_error;
    char copying_msg[512];

    path_tail = strrchr(server_name, '\\');
    if (path_tail) {
        memcpy(path_prefix, server_name, path_tail + 1 - server_name);
        path_prefix[path_tail + 1 - server_name] = '\0';
    }
    else
        path_prefix[0] = '\0';
    sprintf(interlink_path, double_percent_s, path_prefix, dl_name);
    if ( !get_upload_options() ) {
        return;
    }
    port_index = 0;
    for (;;) {
        if (port_index >= (int) Bios.num_serial) port_index = 0;
        set_attribute(STATUS_COLOR);
        dispchar(coord(scr_rows - 1, scan_port_col), port_index + '1');
        result = FxCloneInit(port_index, remote_port, loading_bootstrap_msg, CloneCheckAbort);
        if (result == 0) {
            break;
        }
        if (result == -1 || result > 3) {
            goto report_error;
        }
        port_index++;
    }
    remote_found = TRUE;
    left_margin = left_col + 3;
    strlwr(server_name);
    strlwr(interlink_path);
    sprintf(copying_msg, upload_copying_msg, server_name, interlink_path);
    draw_screen(copying_msg, 0, LIST_NORMAL);
    justify_str(coord(scr_rows - 1, status_col), 80 - status_col,
                STATUS_COLOR, sending_bootstrap, -1);
    percent_col = status_col + pstrlen(sending_bootstrap) + 1;
    update_progress(0);
    bootstrap_size = FxBootstrapInit();
    bootstrap_sent = 0;
    while (bootstrap_sent < bootstrap_size) {
        request = min(128, bootstrap_size - bootstrap_sent);
        result = FxSendBootstrap(request);
        if (result != 0)
            goto report_error;
        bootstrap_sent += request;
        update_progress( percent( (long)bootstrap_sent, (long)bootstrap_size) );
    }
    result = FxBootstrapVerify();
    if (result != 0) {
        goto report_error;
    }
    result = FxStartBootstrap();
    if (result != 0) {
        error_printf(connection_lost, result);
    }
    else {
        no_send_error = send_file(server_name);
        if (no_send_error) {
            no_send_error = send_file(interlink_path);
        }
    }
    call_clone_exit();
    return;

report_error:
    if (check_abort_flag)
        error_printf(upload_cancelled);
    else if (result == 88)
        error_printf(upload_share_problem);
    else if (result != -1)
        error_printf(upload_unable_to_communicate, result);
}

char *clone(char *argp)
{
    char prog_name[80];

    if (fx_num_ports == 0) {
        add_all_bios_serial();
        if (fx_num_ports == 0) {
            fatal_printf(no_serial_ports_available_error);
        }
    }
    do_init_screen();
    set_critical_error();               // Send critical errors to criterr()
    setcbrk();                          // Ignore Cntl-C/Cntl-Break
    FxInit();
    check_abort_flag = FALSE;
    do_init_screen();
    hook_int2f();
    atexit(quit);

    if (_osmajor >= 3)
    {
        getprog(prog_name);
        server_name = prog_name;
    }
    fill_attr(coord(0, 0), boxsize(scr_rows, 80), ' ', SCROLL_COLOR);
    dispstr_attr(coord(0, (80 - strlen(clone_title)) / 2),
                clone_title, TITLE_COLOR);
    do_clone();
    exit(0);
    return 0;                           // Doesn't really get executed
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\cwfunc.h ===
extern void pascal Bell(void);
extern	void _far pascal GetDosCountryInfo(void *);
extern	void _fastcall FormatDateString(char *buffer, struct dosdate_t *dateptr);
extern	void FormatTimeString(char *buffer, struct dostime_t *time);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\getprog.asm ===
;***
;* $Workfile:   getenv.asm  $
;* $Revision:   1.0  $
;*   $Author:   Dave Sewell  $
;*     $Date:   13 Oct 1989 11:28:00  $
;*
;*****************************************************************************

%               .MODEL memmodel

                .DATA
                EXTRN   C _psp:WORD

                .CODE

;extern void _fastcall getprog(char near *progname);
;
; BX = progname

@getprog        PROC
                PUBLIC  @getprog

                push    di
                mov     es, _psp
                mov     es, es:[2CH]     ;Get segment of environment
                xor     di, di
                xor     ax, ax
                mov     cx, 8000H

scan_end: repne scasb
                scasb
                jne     scan_end

                inc     di
                inc     di

copy_prog:      mov     al, es:[di]
                inc     di
                mov     [bx], al
                inc     bx
                or      al, al
                jnz     copy_prog

                pop     di
                ret

@getprog        ENDP

            END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\cwuser.h ===
/***
* $Workfile:   cwuser.h  $
* $Revision:   1.5  $
*   $Author:   Dave Sewell  $
*     $Date:   28 Sep 1990  9:54:46  $
***/

#ifndef BYTE
#define BYTE  unsigned char
#endif
#ifndef WORD
#define WORD  unsigned short
#endif
#ifndef O_RAW
#define O_RAW O_BINARY
#endif
#ifndef NULL
#if defined(M_I86LM) || defined(M_I86CM) || defined(M_I86HM)
#define NULL 0L
#else
#define NULL 0
#endif
#endif

#ifndef NOPROC
#define NOPROC ((int (*)())0)
#endif

#ifndef TRUE
#include    "osdep.h"
#endif

/**** The following are a core of functions common to most applications ****/

#include "bioskybd.h"
#include "screen.h"

/*** fatal error numbers ***/
#define CREATE_PORTAL_FATAL_ERROR   1
#define DISPLAYTEXTINPORTAL_FATAL_1 2
#define DISPLAYTEXTINPORTAL_FATAL_2 3
#define HELP_STACK_FULL_FATAL_ERROR 5
#define HELP_MALLOC_FATAL_ERROR     7
#define LIST_STACK_FULL_FATAL_ERROR 8
#define LIST_STACK_EMPTY_FATAL_ERR  9
#define OUT_OF_NEAR_HEAP_FATAL_ERROR	10
#define PORTAL_TABLE_FULL_FATAL_ERROR	11
#define LIST_SEARCH_ERROR		12

/*** color definitions ***/

#define INIT_NORMAL	(color(CYAN,BLUE))
#define INIT_REVERSE	(color(BLUE,CYAN) | MONO_REVERSE)
#define INIT_RBLINK	(color(BLUE,CYAN) | MONO_REVERSE | BLINKING)
#define INIT_INTENSE	(color(CYAN,BLUE) | INTENSE)
#define INIT_IBLINK	(color(CYAN,BLUE) | INTENSE | BLINKING)

#define LIST_NORMAL	(color(WHITE,BLUE) | INTENSE | MONO_BOLD)
#define LIST_DIM	(color(WHITE,BLUE) | MONO_NORMAL)
#define LIST_REVERSE	(color(BLUE,WHITE) | MONO_REVERSE)
#define LIST_RBLINK	(color(BLUE,WHITE) | MONO_REVERSE | BLINKING)
#define LIST_INTENSE	(color(YELLOW,BLUE) | MONO_BOLD)
#define LIST_IBLINK	(color(YELLOW,BLUE) | BLINKING)

#define ALERT_REVERSE	(color(WHITE, MAGENTA) | INTENSE | MONO_REVERSE)

#define NO_CLEAR    0x80

struct portal
{
    BYTE frameLine;	     /* Topmost line of frame on physical screen */
    BYTE frameColumn;	     /* Leftmost column of frame on physical screen */
    BYTE frameHeight;	     /* Height of frame on physical screen */
    BYTE frameWidth;	     /* Width of frame on physical screen */
    BYTE saveFlag;	     /* TRUE = save old screen (may have NO_CLEAR) */
    BYTE borderType;	     /* Type of border to use */
    int  borderAttribute;    /* Attribute to use with border */
    int  borderDeselect;     /* Border attribute when deselected.	*/
    int  normal_attribute;   /* Normal attribute for portal body.	*/
    char *headerText;	     /* Pointer to header text */
};

typedef struct pcb
{
    struct portal p;
    byte headerLen;	     /* Max length of header, including null	*/
    char *saveScreen;	     /* Address of save screen */
    BYTE portalLine;	     /* Topmost line of portal on physical screen */
    BYTE portalColumn;	     /* Rightmost column of portal on physical screen */
    BYTE portalHeight;	     /* Height of portal */
    BYTE portalWidth;	     /* Width of portal */
} PCB;

#define NO_MESSAGE ((char *) 0)
#define NOHEADER   ((char *)NULL) /* no header with the portal */
#define NOBORDER   ((BYTE)0)	  /* no border around portal */
#define SINGLE	   ((BYTE)1)	  /* single line forms border */
#define DOUBLE	   ((BYTE)2)	  /* double line forms border */

#define SAVE	   ((BYTE)1)	  /* save old screen under portal */
#define NOSAVE	   ((BYTE)0)	  /* don't save screen under portal */

#define CURSOR_ON  ((BYTE)1)	  /* turn the cursor on in the portal */
#define CURSOR_OFF ((BYTE)0)	  /* turn the cursor off in the portal */

#define DIRECT	   ((BYTE)1)	  /* no virtual space for portal */
#define VIRTUAL    ((BYTE)0)	  /* create virtual space for portal */

/**** valid key flags for SelectFromList ****/
#define M_ESC	    0x0001
#define M_ESCAPE    0x0001
#define M_INSERT    0x0002
#define M_DELETE    0x0004
#define M_MODIFY    0x0008
#define M_SELECT    0x0010
#define M_MDELETE   0x0020
#define M_CYCLE     0x0040
#define M_MMODIFY   0x0080
#define M_MSELECT   0x0100
	    /* these are both only used in split screen mode, so the
	    *  verification checks should work fine.  M_MARKALL is
	    *  only used for verification, and the value is never
	    *  returned to the caller of SelectFromList, so it
	    *  we can identify this return value as a MKDIR.
	    */
#define M_MARKALL   0x0200
#define M_MKDIR     0x0200
#define M_VIEW	    0x0400
#define M_RENAME    0x0800
#define M_MARKPLUS  0x1000
#define M_LEFT	    0x2000
#define M_RIGHT     0x4000

#define TEXT_OFFSET 9

/**** definition of list marking primitives ****/
/* The following bit in the 1st byte of the record is used for the mark bit. */
#define MARK_BIT    0x40

#define Mark(element)	   (*((char far *)element) |=  MARK_BIT)
#define Unmark(element)    (*((char far *)element) &= ~MARK_BIT)
#define IsMarked(element)  (*((char far *)element) &   MARK_BIT)

/**** definition of list structure ****/
/* NOTE: The 'text' field is declared as an array of 1 character.  However,
 * the list manipulation procedures will allocate a memory buffer longer than
 * the minimum size of the LIST structure.  The 'text' field is treated as a
 * null-terminated string occupying the memory left over from that used by the
 * other fields.
 */
typedef struct LIST_STRUCT
{
    BYTE marked;		     /* whether or not element is marked */
    struct LIST_STRUCT far *prev;    /* previous element in list */
    struct LIST_STRUCT far *next;    /* next element in list */
    char far *otherInfo;	     /* pointer to auxiliary data */
    char text[1];		     /* text (primary data) for element */
} LIST;

typedef struct listptr
{
    LIST far *head;
    LIST far *tail;
    int (pascal *sortProc)();
} LISTPTR;

struct options {
    char *text; 	    /* Description of option.			    */
    int  value; 	    /* Value to associate with the option.	    */
};

struct menu {
    byte center_line;		/* Line (row) to center vertically on.	    */
    byte center_column; 	/* Column to center horizontally on.	    */
    char *header;		/* Header (title) for menu.		    */
    int  help_screen;		/* Help screen number.			    */
    int  (*action)(int);	/* Action routine.			    */
    struct options *options;	/* Pointer to list of options.		    */
};


/* Form definitions */

struct edtstr { 		/* Edit string type data structure	    */
    byte center_line;		/* Line (row) where edit portal is centered */
    byte center_column; 	/* Column where edit portal is centered     */
    byte portal_height; 	/* Edit portal height			    */
    byte portal_width;		/* Edit portal width			    */
    char *header;		/* Header message for edit portal	    */
};

struct fields {
    void *data; 		    /* Pointer to data for field	    */
    int  bufsize;		    /* size allocated for *data 	    */

    byte line;			    /* Line (in portal) of field	    */
    byte column;		    /* Column (in portal) of field	    */
    byte width; 		    /* Width (in portal) of field	    */

    byte type;			    /* Type of field			    */
    int flags;			    /* Control Flags			    */

    int help_screen;		    /* Help screen for field		    */
    char *prompt;		    /* Prompt for field 		    */
    void *info; 		    /* Pointer field specific data	    */
};

struct form {
    byte center_line;		/* Line (row) to center vertically on.	    */
    byte center_column; 	/* Column to center horizontally on.	    */
    byte form_height;
    byte form_width;
    char *header;		/* Header (title) for menu.		    */
    int  help_screen;		/* Help screen number.			    */
    int  exit_help_screen;	/* Help screen number.			    */
    struct fields *fields;	/* Pointer to list of fields.		    */
};

struct form_control {
    int (near _fastcall *input)(struct fields *, int, int *);
    void (near _fastcall *output)(struct fields *);
    int (near _fastcall *verify)(struct fields *);
};

/* Standard form field types */

#define MENU_TYPE      0
#define TIME_TYPE      1
#define DATE_TYPE      2
#define STRING_TYPE    3
#define EDTSTR_TYPE    4
#define PROMPT_TYPE    5
#define NULL_TYPE      6

/**** Field select key types ****/
#define S_NONFUNC 0x00		/* Non function key cause selection */
#define S_SELECT  0x01		/* K_SELECT key caused selection */
#define S_MODIFY  0x02		/* K_MODIFY key caused selection */
#define S_INSERT  0x04		/* K_INSERT key caused selection */
#define S_DELETE  0x08		/* K_DELETE key caused selection */


/**** fieldFlags Type masks ****/
#define NORMAL_FIELD	    0x00	/* normal editable field */
#define LOCKED_FIELD	    0x01	/* non accessable */
#define REQUIRED_FIELD	    0x02	/* verify field on form exit */
#define PROMPT_FIELD	    0x04 | LOCKED_FIELD

#define RIGHT_FORMAT	    0x40	/* right justification format */
#define LEFT_FORMAT	    0x80	/* left justification format */
#define CENTER_FORMAT	    0xC0	/* centering format */

#define LONGEST_MONTH_NAME 9

/**** Definition of edit return codes ****/
#define E_CHANGE     0x01    /* Whether buffer was changed */
#define E_ESCAPE     0x02    /* Whether buffer edit was canceled */
#define E_SELECT     0x04    /* Whether changes confirmed */
#define E_EMPTY      0x08    /* Whether buffer has anything in it */

/* Video Scroll Directions */
#define V_UP	 ((BYTE)6)
#define V_DOWN	 ((BYTE)7)

#define FATAL		      1
#define WARNING 	      2
#define INFORM		      3

#define J_NONE		      0
#define J_LEFT		      1
#define J_RIGHT 	      2

#define HEADER_NONE	      -1
#define HEADER_NORMAL	      0

#define NO_HELP_CONTEXT       -1


extern int (* edit_portal_string_key_handler)(int);

extern int currentPortal;		// Index of current portal.
extern PCB *portal[];         // Table of active portals.

extern unsigned list_rec_size;
extern unsigned list_num_recs;

/*** Macros for doing writes within a portal. ***/

extern unsigned origin;

#define p_fill_attr(ul, size, c, att) fill_attr((ul)+origin, size, c, att)
#define p_dispstr_attr(pos, buf, att) dispstr_attr((pos)+origin, buf, att)
#define p_dispmem_attr(pos,buf,cnt,att) dispmem_attr((pos)+origin,buf,cnt,att)
#define p_dispstr(pos,buf) dispstr((pos)+origin, buf)
#define p_dispchar(pos,c) dispchar((pos)+origin, c)
#define p_locate(row_col) locate((row_col)+origin)
#define p_dispmem(pos, buff, cnt) dispmem((pos)+origin, buff, cnt)
#define p_clear(ulpos, lrpos) clear((ulpos)+origin, (lrpos)+origin)
#define p_scroll_up(ul,lr,att,cnt) scroll((ul)+origin,(lr)+origin,att,cnt,0)
#define p_scroll_down(ul,lr,att,cnt) scroll((ul)+origin,(lr)+origin,att,cnt,1)
#define p_fill(ulpos, size, c) fill((ulpos)+origin, size, c)
#define p_shade(ulpos, height_width) shade((ulpos)+origin, height_width)
#define p_save_zone(ulpos, size, buff) save_zone((ulpos)+origin, size, buff)
#define p_restore_zone(ulpos,size,buff) restore_zone((ulpos)+origin,size,buff)

/* date and time format controls */
#define NORMAL_DATE	       0x00
#define USE_ALPHA_MONTH        0x01
#define INCLUDE_DAY_OF_WEEK    0x02

/* box_printf flags */

#define BOX_HORIZ_FLAGS     0x03
#define HORIZ_CENTER        0x00
#define HORIZ_LEFT          0x02
#define HORIZ_RIGHT         0x01
#define BOX_VERT_FLAGS      0x0C
#define VERT_CENTER         0x00
#define VERT_TOP            0x08
#define VERT_BOTTOM         0x04
#define BOX_DOUBLE          0x00
#define BOX_SINGLE          0x10
#define BOX_SAVE            0x00
#define BOX_NOSAVE          0x20
#define BOX_BELL            0x40

#include <stdarg.h>

#ifndef CWFUNC
#define CWFUNC	1
#include    "cwfunc.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\int2f.asm ===
;***
;* $Workfile:   percent.asm  $
;* $Revision:   1.0  $
;*   $Author:   Dave Sewell  $
;*     $Date:   13 Oct 1989 11:28:00  $
;*
;*****************************************************************************

%               .MODEL memmodel

INTERLNK_MULTIPLEX_ID   EQU     056H

                .CODE

;extern int _fastcall is_il_drive(unsigned drive_num);
;

@is_il_drive    PROC
                PUBLIC  @is_il_drive

                push    cx
                mov     bh, al                      ; Driver number to BH
                mov     al, 1                       ; drive check
                push    di
                push    si
                push    bp
                push    ds
                push    es
                mov     ah, INTERLNK_MULTIPLEX_ID
                mov     bl, 0
                mov     dx, 0FFFFH
                int     2FH
                cmp     al, 0FFH
                mov     ax, 1
                je      done

                xor     ax, ax

done:           pop     es
                pop     ds
                pop     bp
                pop     si
                pop     di
                pop     cx
                ret

@is_il_drive    ENDP

            END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\devinfo.c ===
/***
* $Workfile:   devinfo.c  $
* $Revision:   1.4  $
*   $Author:   Dave Sewell  $
*     $Date:   04 May 1990  9:12:38  $
***/

/*  devinfo.c : Alan Butt : December 21, 1988 : Expansion Box Project

    This module is responsible for getting all needed information about
    device drivers the individual logical devices.
*/

#include <stdlib.h>
#include <bios.h>
#include <string.h>
#include <stdio.h>
#include <conio.h>

#include "dc.h"

static struct device_header far *device_driver_chain = 0;
static union dpb far *disk_block_chain = 0;

extern int drdos;


/*  get_dos_info, gets the pointer to the first disk parameter block and
    the pointer to the first device driver.  This information is retrieved
    from undocumented DOS call INT 21H Subfunction 52H.
*/
static void get_dos_info(void)
{
    union REGS regs;
    struct SREGS sregs;
    union dpb far * far * pdpb;
    word *pnt;

    regs.h.ah = 0x52;
    intdosx(&regs, &regs, &sregs);

    pnt = (word *) &device_driver_chain;   // ES:BX + 22H (or 17H) == Start of NUL driver
    *pnt++ = regs.x.bx + (_osmajor > 2 ? 0x22 : 0x17);
    *pnt = sregs.es;

    pnt = (word *) &pdpb;                   // *(ES:BX) is first disk block
    *pnt++ = regs.x.bx;
    *pnt = sregs.es;

    disk_block_chain = *pdpb;
}

/*  get_device_chain() returns the pointer to the first device driver
    on the system.
*/
static struct device_header far * near get_device_chain(void)
{
    if (!device_driver_chain) get_dos_info();
    return device_driver_chain;
}

/*  get_first_dpb() returns pointer to the first disk parameter block.
    This information is retrieved from the undocumented DOS call 52H.

    This routine also sets the global variable device_driver_chain!
*/
static union dpb far * near get_first_dpb(void)
{
    if (!disk_block_chain) get_dos_info();
    return disk_block_chain;
}


void _pascal read_volume_label(int dev)
{
    char path[10];
    struct find_t find;
    struct media_id_buffer mib;
    int i, j;
    struct gen_ioctl_req gir;

    devices[dev].volume_label[0] = '\0';
    devices[dev].serial_number   = 0L;
    if (_osmajor >= 3) {
        sprintf(path, "%c:\\*.*", dev + 'A');
        if ( _dos_findfirst(path, _A_VOLID, &find) == 0 ) {
            for (i = 0, j = 0; i < 12 && find.name[i]; i++) {
                if (find.name[i] == '.') {
                    while (j < 8)
                        devices[dev].volume_label[j++] = ' ';
                }
                else
                    devices[dev].volume_label[j++] = find.name[i];
            }
            devices[dev].volume_label[j] = '\0';
        }
        if (_osmajor >= 4 && (devices[dev].header->attribute & ATT_GEN_IOCTL)) {
            gir.s.rhp_length  = sizeof(struct gen_ioctl_req);
            gir.s.rhp_unit    = devices[dev].unit;
            gir.s.rhp_command = GENERIC_IOCTL;
            gir.gen_category  = 8;
            gir.gen_function  = 0x66;
            gir.gen_data      = &mib;
            call_driver((void far *) &gir, devices[dev].header);
            if ( (gir.s.rhp_status & STATUS_ERROR) == 0) {
                devices[dev].serial_number = mib.serial_number;
            }
        }
    }
}

/*  get_device_information gets all the information about the device drivers
    and the associated logical device information.
*/
void load_device_information()
{
    #define FLOPPY(x)   ( (x == 0 || x == 1) && num_server_floppies >= 1 ) 

   char pathx [] = "X:\\*.*";
   struct find_t xfind;
    union dpb far *dpb;
    byte media_descriptor;
    unsigned num_clusters;
    unsigned sectors_per_cluster;
    unsigned bytes_per_sector;
    byte number_of_fats;
    union _bios_equipment_list {
        word w;
        struct {
            unsigned diskette_installed : 1;
            unsigned math_coprocessor   : 1;
            unsigned pointing_device    : 1;
            unsigned                    : 1;
            unsigned video_mode         : 2;
            unsigned diskette_drives    : 2;
            unsigned                    : 1;
            unsigned num_rs232          : 3;
            unsigned game_adapter       : 1;
            unsigned internal_modem     : 1;
            unsigned num_printers       : 2;
        } b;
    } equipment_list;


    lpt_drivers[0] = find_char_device("LPT1    ");
    lpt_drivers[1] = find_char_device("LPT2    ");
    lpt_drivers[2] = find_char_device("LPT3    ");
    equipment_list.w = _bios_equiplist();
    num_server_floppies = (equipment_list.w & 1) ?
                          ( (equipment_list.w & 0xC0) >> 6) + 1 :
                          0;

    dpb = get_first_dpb();
    slave_block_devices = 0;
    while (FP_OFF(dpb) != 0xffff && slave_block_devices < MAX_SLAVE_DEVICES) {
        // Loop through all DPBs getting device information
        devices[slave_block_devices].dpb = (void far *) dpb;

   // Now, if we're running on DOS 3 or later, we'll determine whether
   //  this drive is non-removable, and if so, touch it to make sure the
   //  DPB variables are current.  A side effect of this code is to
   //  set/reset the .non_removable flag as appropriate.

        devices[slave_block_devices].non_removable   = FALSE;

        if (_osmajor >= 3 && !is_il_drive(slave_block_devices) ) {
            union REGS regs;

            regs.h.ah = 0x44;
            regs.h.al = 0x08;
            regs.h.bl = (byte) slave_block_devices + (byte) 1;
            intdos(&regs, &regs);
            if ( !regs.x.cflag && regs.x.ax == 1 ) {    // Not removable!
                devices[slave_block_devices].non_removable = TRUE;

//   Touch the drive with a find first on the volume label.  This code
//   was removed from get_volume_label.  Unfortunately, it can't be called
//   from there because that function requires some of the other variables
//   which we haven't initialized yet.


            pathx [0] = (char)(slave_block_devices + (int)'A');
            _dos_findfirst(pathx, _A_VOLID, &xfind);
            }
        }

                // DRDOS bug:  puts a default value into the floppy
                // media_id byte, which may result in an incorrect
                // floppy size if the floppy has not been read yet.
                // To get around this, put a 0 in media_id, just
                // like MSDOS does for floppies that have not
                // been accessed yet.

        devices[slave_block_devices].is_floppy = (byte) FLOPPY(slave_block_devices);
        media_descriptor = 0;
        if (_osmajor == 2) {
            devices[slave_block_devices].header           = dpb->dos2.device_driver;
            devices[slave_block_devices].attribute        = dpb->dos2.device_driver->attribute;
            devices[slave_block_devices].unit             = dpb->dos2.unit;
            devices[slave_block_devices].drive            = dpb->dos2.drive;
            devices[slave_block_devices].bytes_per_sector = dpb->dos2.bytes_per_sector;
            if (!drdos || !FLOPPY(slave_block_devices))
                media_descriptor = dpb->dos2.media_id;
            num_clusters        = dpb->dos2.max_number - 1;
            sectors_per_cluster = dpb->dos2.max_cluster + 1;
            bytes_per_sector    = dpb->dos2.bytes_per_sector;
            number_of_fats      = dpb->dos2.number_of_fats;
        }
        else if (_osmajor == 3) {
            devices[slave_block_devices].header           = dpb->dos3.device_driver;
            devices[slave_block_devices].attribute        = dpb->dos3.device_driver->attribute;
            devices[slave_block_devices].unit             = dpb->dos3.unit;
            devices[slave_block_devices].drive            = dpb->dos3.drive;
            devices[slave_block_devices].bytes_per_sector = dpb->dos3.bytes_per_sector;
            if (!drdos || !FLOPPY(slave_block_devices))
                media_descriptor = dpb->dos3.media_id;
            num_clusters        = dpb->dos3.max_number - 1;
            sectors_per_cluster = dpb->dos3.max_cluster + 1;
            bytes_per_sector    = dpb->dos3.bytes_per_sector;
            number_of_fats      = dpb->dos3.number_of_fats;
        }
        else {
            devices[slave_block_devices].header           = dpb->dos4.device_driver;
            devices[slave_block_devices].attribute        = dpb->dos4.device_driver->attribute;
            devices[slave_block_devices].unit             = dpb->dos4.unit;
            devices[slave_block_devices].drive            = dpb->dos4.drive;
            devices[slave_block_devices].bytes_per_sector = dpb->dos4.bytes_per_sector;
            if (!drdos || !FLOPPY(slave_block_devices))
                media_descriptor = dpb->dos4.media_id;
            num_clusters        = dpb->dos4.max_number - 1;
            sectors_per_cluster = dpb->dos4.max_cluster + 1;
            bytes_per_sector    = dpb->dos4.bytes_per_sector;
            number_of_fats      = dpb->dos4.number_of_fats;
        }
        devices[slave_block_devices].sectors_per_cluster = (byte) sectors_per_cluster;
        devices[slave_block_devices].number_of_fats = number_of_fats;
        devices[slave_block_devices].media_descriptor = media_descriptor;
        if (media_descriptor) {
            devices[slave_block_devices].data_size =
                    (unsigned long) num_clusters *
                    (unsigned long) sectors_per_cluster *
                    (unsigned long) bytes_per_sector;
        }


        devices[slave_block_devices].volume_label[0] = '\0';
        devices[slave_block_devices].serial_number   = 0L;

        // If DOS 3.0 and non-removable media, get volume label.
        if (devices[slave_block_devices].non_removable == TRUE)
          read_volume_label(slave_block_devices);
        slave_block_devices++;
        dpb = _osmajor == 2 ? (union dpb far *) dpb->dos2.next_block :
              _osmajor == 3 ? (union dpb far *) dpb->dos3.next_block :
                              (union dpb far *) dpb->dos4.next_block;
    }
}


/*  find_char_device() looks for the first character device with the passed in
    name.  If found, a pointer to the device header is returned.  If not found,
    a NULL pointer is returned.
*/
struct device_header far *find_char_device(char *name)
{
    struct device_header far *header = get_device_chain();

    while (FP_OFF(header) != 0xffff) {
        if (!fmemcmpf(header->name_num, (char far *) name, DEVICE_NAME_SIZE))
            return header;
        header = header->next_header;
    }
    return (struct device_header far *) 0;
}




/* Below is code specific to finding open files -- This is all DOS version
    dependant code.
*/


struct open_file_entry_dos2 {
    byte    open_flag;              // non-zero if file is open
    word    reserved;
    byte    unit_number;            // Unit number (0=char dev,1=A,2=B,...)
    char    file_name[11];          // File name
    byte    reserved2[25];
};

struct open_file_entry_dos3 {
    word    handle_count;           // # of handles that refer to this entry
    byte    reserved[5];
    void far *driver_dpb;           // Pointer to device driver or DPB
    byte    reserved2[21];
    char    file_name[11];          // File name
    byte    reserved3[10];
};

struct open_file_entry_dos4 {
    word    handle_count;           // # of handles that refer to this entry
    byte    reserved[5];
    void far *driver_dpb;           // Pointer to device driver or DPB
    byte    reserved2[21];
    char    file_name[11];          // File name
    byte    reserved3[16];
};

struct open_file_list {
    struct  open_file_list far *next;   // Pointer to next open file list
    word    count;                      // # of open file entries following
    char    table[1];                   // Beginning of open file entry table
};

              
static struct open_file_list far *find_open_file_chain(void)
{
    union REGS regs;
    struct SREGS sregs;

    struct open_file_list far *pnt;
    word far *src;
    word *dst;

    regs.h.ah = 0x52;
    intdosx(&regs, &regs, &sregs);

    dst = (word *) &src;
    *dst++ = regs.x.bx + 4;
    *dst = sregs.es;

    dst = (word *) &pnt;
    *dst++ = *src++;
    *dst++ = *src++;

    return pnt;
}

/*  open_file -- Returns the name of the first open file on a given device

    Inputs:
        dev         Unit number to check (0 = 'A', 1 = B, ...).
        devices[]   Must have the dpb field set (load_device_information() must
                    have been executed).
        filename    Buffer for open file name

    Outputs:
        retval      TRUE if an open file was found on the device,
                    otherwise FALSE
        filename    Name of the file that was open (If one exists).  The
                    name will be in directory entry format without a
                    terminating '\0'.
*/

int open_file(int dev, char *filename)
{
    struct open_file_list far *pnt = find_open_file_chain();
    struct open_file_entry_dos2 far *dos2;
    struct open_file_entry_dos3 far *dos3;
    struct open_file_entry_dos4 far *dos4;
    unsigned int i;

    while (FP_OFF(pnt) != 0xffff) {
        if (_osmajor == 3) {
            dos3 = (struct open_file_entry_dos3 far *) pnt->table;
            for (i = 0; i < pnt->count; i++) {
                if ((dos3 + i)->handle_count &&
                    devices[dev].dpb == (dos3 + i)->driver_dpb) {
                    memcpyf(filename, (dos3 + i)->file_name, 11);
                    return TRUE;
                }
            }
        }
        else if (_osmajor == 4) {
            dos4 = (struct open_file_entry_dos4 far *) pnt->table;
            for (i = 0; i < pnt->count; i++) {
                if ((dos4 + i)->handle_count &&
                    devices[dev].dpb == (dos4 + i)->driver_dpb) {
                    memcpyf(filename, (dos4 + i)->file_name, 11);
                    return TRUE;
                }
            }
        }
        else {  // DOS 2.0
            dos2 = (struct open_file_entry_dos2 far *) pnt->table;
            for (i = 0; i < pnt->count; i++) {
                if ((dos2 + i)->unit_number == (byte) (dev + 1) &&
                    (dos2 + i)->open_flag) {
                    memcpyf(filename, (dos2 + i)->file_name, 11);
                    return TRUE;
                }
            }
        }
        pnt = pnt->next;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\dc.h ===
/***
* $Workfile:   dc.h  $
* $Revision:   1.8  $
*   $Author:   Dave Sewell  $
*     $Date:   22 Oct 1990 14:59:36  $
***/

/*  ebox.h : Alan Butt : December 19, 1988 : Expansion Box Project
 
    This file contains macros/constants/definitions for the slave program.
*/

#include "osdep.h"                      // Include Paragon Library files
#include "umfunc.h"

#include "drivers.h"                    // Include ebox files
#include "packets.h"
#include "boxfunc.h"

#include "cwuser.h"                     // Include C-Worthy Library files
#include "userform.h"
#include "str.h"

/*  DOS_VERSION() takes two arguments.  The first is placed into the high byte
    of an integer and the second into the low byte.  It is used to build
    numbers to be compared with master_dos_version and slave_dos_version.
*/
#define DOS_VERSION(x, y) (((x) << 8) | (y))


#define MAX_SLAVE_DEVICES   26          // Max number of logical block devices
                                        // on the slave system

#define SCROLL_COLOR    (color(WHITE,BLACK) | MONO_NORMAL)
#define WARNING_COLOR	(color(WHITE, MAGENTA) | INTENSE | MONO_REVERSE)
#define ERROR_COLOR	   (color(WHITE, RED) | INTENSE | MONO_REVERSE)


typedef void (pascal *PVF)(void);       // Pointer to Void Function type.
typedef int  (*PIF)(void);              // Pointer to Integer Function type.
typedef int  (*PIFW)(word);             // Pointer to Int Function/word argument

struct device {
    struct device_header far *header;   // Pointer to device driver header
    void far *dpb;                      // Pointer to units DPB
    word attribute;                     // Device driver attribute word
    word bytes_per_sector;              // Bytes per sector on device
    byte drive;                         // Drive # (0 = A, 1 = B, ...)
    byte unit;                          // Unit number within driver
    byte invalid;                       // Media invalid flag
    byte media_descriptor;              // Media descriptor byte (0 if unknown)
    unsigned long data_size;            // Size of data area in bytes.
    byte number_of_fats;                // Number of FAT table copies.
    byte sectors_per_cluster;           // Number of sectors per cluster.
    byte non_removable;                 // TRUE if known to be non-removable
    char volume_label[12];              // Volume label.
    unsigned long serial_number;        // Volume serial number (0 if unknown)
    byte is_floppy;                     // TRUE if A: or B: floppy disk
};

struct char_device {                    // Auxiliary device driver names
    char master_name[DEVICE_NAME_SIZE]; // Name of device on master system
    char slave_name[DEVICE_NAME_SIZE];  // Name of device on slave system
};                                      // *master_name[] <= ' ' means invalid

/*** The following bit is OR'ed into the baud rate if 7-wire mode is OK ***/

#define PORT_LIST_SIZE  30

struct config {
    enum    baud baud;                  // Baud rate for serial communication
    char    port_list[PORT_LIST_SIZE];  // Serial/Parallel ports to use

    // Block driver init inforation

    word    master_dos_version;         // DOS version of master (WORD format)
    word    master_code;                // ID code of master driver
    byte    master_max_devices;         // Max number of ebox devices on master
    byte    master_first_unit;          // First drive number in master driver

};




enum connection_state { No_connection, Serial_connection, Parallel_connection,
                        No_connection_repaint };

extern char cdecl version[];            // Version number string

/*  If EXTERN is not defined, the following declarations will be defined
    as external.  If EXTERN is defined, they will be the real declarations.
    EXTERN should only be defined in one module that includes this file.
*/

#ifdef EXTERN
    #undef EXTERN
    #define EXTERN                      /* Insure EXTERN is "" */
    #define __INITIALIZERS
#else
    #define EXTERN extern
#endif

#ifdef __INITIALIZERS
    byte actual_prn_map[3] = { UNASSIGNED, UNASSIGNED, UNASSIGNED };
#else
    EXTERN byte actual_prn_map[3];
#endif


EXTERN int num_server_floppies;         // Number of floppy drives on server.

EXTERN int slave_block_devices;         // Count of block devices on slave
EXTERN struct device devices[MAX_SLAVE_DEVICES];
EXTERN struct device_header far *lpt_drivers[3];   // Points to LPT1, LPT2, LPT3

EXTERN word slave_dos_version;          // DOS version of slave (WORD format)
                                        // The bytes in _osversion are backwords

EXTERN byte drive_priority[26];
EXTERN int num_drives;

/* Buffer for packet information */

EXTERN union {
    byte                    packet_type;
    struct init_packet_r    init_packet_r;
    struct init_packet_a    init_packet_a;
    struct media_check_r    media_check_r;
    struct media_check_a    media_check_a;
    struct build_bpb_r      build_bpb_r;
    struct build_bpb_a      build_bpb_a;
    struct io_r             io_r;
    struct io_a             io_a;
    struct error_r          error_r;
    struct ocrm_r           ocrm_r;
    struct ocrm_a           ocrm_a;
    struct bios_r           bios_r;
    struct bios_a           bios_a;
    struct drive_info_r     drive_info_r;
    struct gen_ioctl_r      gen_ioctl_r;
    struct gen_ioctl_a      gen_ioctl_a;
    struct lpt_o_r          lpt_o_r;
    struct lpt_o_a          lpt_o_a;
    struct lpt_cmd_r        lpt_cmd_r;
    struct lpt_cmd_a        lpt_cmd_a;
    // Note: drive_info_a packet might be too big to put in here.
} packet;

/* Device driver request header packets */

EXTERN union {
    struct static_rhp       s;
    struct init_req         init_req;
    struct init_ans         init_ans;
    struct media_check_req  media_check_req;
    struct media_check_ans  media_check_ans;
    struct build_bpb_req    build_bpb_req;
    struct build_bpb_ans    build_bpb_ans;
    struct io_req           io_req;
    struct io_ans           io_ans;
    struct nd_read_ans      nd_read_ans;
    struct gen_ioctl_req    gen_ioctl_req;
} rhp;


/* Configuration Structure */

#ifdef __INITIALIZERS
    struct config config = {
        BAUD_38400,                         // Default starting baud rate
        "LPT*,COM*\0bcdefghijklmnopqrst",

        // Below is block device configuration information

        DOS_VERSION(1, 0),                  // master DOS version
        0,                                  // Master ID code
        MAX_DEVICES,                        // Masters Max # of block devices
        3                                   // First drive #
    };
#else
    EXTERN struct config config;
#endif

#ifdef __INITIALIZERS
    byte max_baud_server = 0xFF;
#else
    EXTERN byte max_baud_server;
#endif

/* Global Strings */

#ifdef __INITIALIZERS
char block_fingerprint[] = "INTERLNK";
#else
extern char block_fingerprint[];
#endif

EXTERN char far buffer[65536];          // A large buffer for I/O

struct printer {
    word address;
    byte exported;
    byte enabled;
};

EXTERN struct printer printers[3];
EXTERN int num_lpt;

#ifdef __INITIALIZERS
    #undef __INITIALIZERS
#endif


#define S_SCANNING   0
#define S_WAITING    1
#define S_SENDING    2
#define S_RECEIVING  3

#define SDP_INACTIVE    0
#define SDP_READING     1
#define SDP_WRITING     2
#define SDP_PRINTING    3

#define TITLE_COLOR    ( color(WHITE,BLACK)| INTENSE | MONO_BOLD)
#define STATUS_COLOR   ( color(WHITE,CYAN) | INTENSE | MONO_REVERSE)

#define ALT_F4      0x16b
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\handler.c ===
/***
* $Workfile:   handler.c  $
* $Revision:   1.5  $
*   $Author:   Dave Sewell  $
*     $Date:   04 May 1990  9:12:48  $
***/

/*  handler.c : Alan Butt : February 1, 1989 : Expansion Box Project

    This routine contains the main slave loop.

*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "fastlynx.h"
#include "server.h"
#include "dc.h"

byte dos5_switcher = FALSE;                 // Set in switcher.asm

static long server_id;
static long last_client_id;

void make_server_id(void)                   // Called once at system init time
{
    long id_value;                          // Start with random stack value
    long _far *bios_data = (long _far *) 0x00400000L;
    int i;

    for (i = 0; i < 64; i++) {
        id_value ^= *bios_data++;
    }
    *((unsigned *)&id_value) ^= fread_ticks();
    *((unsigned *)&id_value + 1) ^= fread_ticks();
    if (id_value == 0L)
        id_value++;
    server_id = id_value;
}

int server_info_handler(word count)
{
    struct server_info_req request;
    struct server_info_ans answer;

    if ( !FxReceive(&request, sizeof(request)) )
        return FALSE;
    memset(&answer, '\0', sizeof(answer));      // Unused fields must be zero
    answer.os_type   = OS_MSDOS;
    answer.developer = DEV_SEWELL;
    answer.product   = PRODUCT_DOSLINK;
    answer.version   = PRODUCT_VERSION;
    answer.device_server = TRUE;                // Device server supported
    answer.agreed_caps.checksum = FALSE;        // Can't support checksum
    answer.agreed_caps.crc      = TRUE;         // Must use CRC
    fx_max_serial_block = min(request.client_caps.max_serial_block, FxSettings.max_serial_block);
    answer.agreed_caps.max_serial_block = fx_max_serial_block;
    answer.last_client_id = last_client_id;
    answer.server_id = server_id;
    // If new master ID code, then master system must have rebooted.
    // Save the new ID code and clear all auxiliary driver information

    if (request.client_id != last_client_id ||
        request.last_server_id != server_id) {
        last_client_id = request.client_id;
        reset_disk();
        setup_block_devices();
    }
    return FxSend(&answer, sizeof(answer) -
        (request.want_packets_supported ? 0 : sizeof(answer.packets_supported)) );
}

int unknown_handler(word count)
{
    return FALSE;
}

/*  An init packet request sends information about the block devices on this
    system.
*/
int init_handler(word count)
{
    register int i;
    byte sp;
    byte mp;
    byte desired_prn_map[3];
    byte desired_mapping[MAX_DEVICES];
    byte avail_lpt[3];
    extern byte win386_enh_mode;

    config.master_dos_version  = packet.init_packet_r.ipr_dos_version;
    config.master_max_devices  = packet.init_packet_r.ipr_max_devices;
    config.master_first_unit   = packet.init_packet_r.ipr_first_unit;
    memcpy(desired_prn_map, packet.init_packet_r.ipr_prn_map, 3);
    memcpy(desired_mapping, packet.init_packet_r.ipr_mapping, MAX_DEVICES);



    // Build initial response packet

    packet.init_packet_a.ipa_devices = (byte) slave_block_devices;
    packet.init_packet_a.ipa_major_version = MAJOR_VERSION;
    packet.init_packet_a.ipa_minor_version = MINOR_VERSION;
    packet.init_packet_a.ipa_multitasker = win386_enh_mode | desqview | dos5_switcher;
    packet.init_packet_a.ipa_dos_version = slave_dos_version;
    make_printer_map();
    memset(actual_prn_map, UNASSIGNED, 3);
    memset(avail_lpt, FALSE, 3);
    for (sp = 0; sp < (byte) num_lpt; sp++) {
        if (printers[sp].enabled)
            avail_lpt[sp] = TRUE;
    }
    for (mp = 0; mp < 3; mp++) {      // First do hard-coded assignments
        sp = desired_prn_map[mp];
        if (sp < 3 && avail_lpt[sp]) {
            actual_prn_map[mp] = sp;
            avail_lpt[sp] = FALSE;
        }
    }
    for (mp = 0; mp < 3; mp++) {        // Then pick up the DON'T CAREs
        if (desired_prn_map[mp] == DONT_CARE) {
            for (sp = 0; sp < (byte) num_lpt; sp++) {
                if (avail_lpt[sp]) {
                    actual_prn_map[mp] = sp;
                    avail_lpt[sp] = FALSE;
                    break;
                }
            }
        }
    }
    memcpy(packet.init_packet_a.ipa_prn_map, actual_prn_map, 3);
    generate_drive_mappings(packet.init_packet_a.ipa_mapping,
                            config.master_max_devices, desired_mapping);

    for (i = 0; i < slave_block_devices; i++) {
        packet.init_packet_a.ipa_attributes[i] = devices[i].attribute;
    }

    if ( !FxSend(&packet, sizeof(struct init_packet_a)) ) {
        return FALSE;
    }

    show_drive_mappings(packet.init_packet_a.ipa_mapping, TRUE);
    return TRUE;
}

/*  Media Check Handler.  This routine handles a media check for a given
    drive.

    If this is DOS 3.0+, the driver has the OCRM bit set in its attribute word,
    and the media has changed, then the driver will (should) return the volume
    label.  This volume label will be send on to the master.
*/
int media_check_handler(word count)
{
    int device;
    int volume_copied = FALSE;

    memset(&rhp, '\0', sizeof(rhp));                // Start with clean RHP
    device = (int) packet.media_check_r.mcr_unit;
    if (device >= slave_block_devices) {
        rhp.media_check_ans.media_changed = MEDIA_DONT_KNOW;
        rhp.s.rhp_status = STATUS_ERROR | STATUS_DONE | ERR_UNK_UNIT;
    }
    else {
        rhp.media_check_req.s.rhp_length = 15;
        rhp.media_check_req.s.rhp_unit = devices[device].unit;
        rhp.media_check_req.s.rhp_command = MEDIA_CHECK;
        rhp.media_check_req.media_id = packet.media_check_r.mcr_media_id;
        call_driver((void far *) &rhp, devices[device].header);
        if ((rhp.media_check_ans.media_changed == MEDIA_CHANGED) && _osmajor >= 3) {
            volume_copied = TRUE;
            memcpyf(packet.media_check_a.mca_volume, rhp.media_check_ans.media_label, MAX_VOLUME);
        }
    }

    // Build response packet
    if (!volume_copied) {
        memcpyf(packet.media_check_a.mca_volume,
            devices[device].volume_label, MAX_VOLUME + 4);
    }
    packet.media_check_a.mca_status  = rhp.s.rhp_status;
    packet.media_check_a.mca_changed = rhp.media_check_ans.media_changed;

    // Send response packet

    return FxSend(&packet, sizeof(struct media_check_a));
}

static void server_change_fail(void)
{
    rhp.s.rhp_status = STATUS_ERROR | STATUS_DONE | ERR_FAILURE;
}


static int read_first_fat_sector(int device, byte media_id)
{
    word sector;

    if (device >= slave_block_devices) {
        rhp.s.rhp_status = STATUS_ERROR | STATUS_DONE | ERR_UNK_UNIT;
        rhp.io_ans.io_transfered = 0;
        return FALSE;
    }

    rhp.io_req.s.rhp_length = sizeof(struct io_req);
    rhp.io_req.s.rhp_unit = devices[device].unit;
    rhp.io_req.s.rhp_command = READ;
    rhp.io_req.media_id = media_id;
    rhp.io_req.io_data = buffer;
    rhp.io_req.io_requested = 1;        // Read one sector
    sector = 1;                         // Read sector one
    if (slave_dos_version < DOS_VERSION(3, 31) ||
            (devices[device].attribute & ATT_HUGE) == 0)
        rhp.io_req.io_start = sector;
    else if (slave_dos_version == DOS_VERSION(3, 31)) {
        rhp.io_req.s.rhp_length =
            (byte) ((byte *) &rhp.io_req.reserved - (byte *) &rhp);
        *((dword *) &rhp.io_req.io_start) = (dword) sector;
    }
    else {                              // Else huge and > DOS 3.31
        rhp.io_req.io_start = 0xFFFF;
        rhp.io_req.io_huge_start = (dword) sector;
    }

    call_driver((void far *) &rhp, devices[device].header);
    return rhp.s.rhp_status & STATUS_ERROR ? FALSE : TRUE;
}

/*  Build BPB hander.  This routine handles a build bpb request for a given
    driver and drive.

    Note: We need to save the sector size of the device.
*/
int build_bpb_handler(word count)
{
    word length;
    int device;

    count;

    device = (int) packet.build_bpb_r.bbr_unit;

    if (device >= slave_block_devices) {
        rhp.s.rhp_status = STATUS_ERROR | STATUS_DONE | ERR_UNK_UNIT;
    }
    else {
        if ( (devices[device].attribute & ATT_NON_IBM) ||
             read_first_fat_sector(device, packet.build_bpb_r.bbr_media_id) )
        {                  // not ibm format or no error reading fat
            // Note: Length needs to be 22 (length of answer).
            rhp.build_bpb_req.s.rhp_length = sizeof(struct build_bpb_ans);
            rhp.build_bpb_req.s.rhp_unit = devices[device].unit;
            rhp.build_bpb_req.s.rhp_command = BUILD_BPB;
            rhp.build_bpb_req.media_id = packet.build_bpb_r.bbr_media_id;
            rhp.build_bpb_req.bpb_fat = buffer;

            call_driver((void far *) &rhp, devices[device].header);
        }
    }

    // Build response packet
    packet.build_bpb_a.bba_status = rhp.s.rhp_status;
    if ( !(rhp.s.rhp_status & STATUS_ERROR) ) {     // No error building BPB
        packet.build_bpb_a.bba_bpb = *rhp.build_bpb_ans.bpb_bpb;
        devices[device].bytes_per_sector =
            rhp.build_bpb_ans.bpb_bpb->bytes_per_sector;
        length = sizeof(struct build_bpb_a);
        // If media is removeable, read the volume label
        if (devices[device].non_removable == FALSE) {
            reset_disk();
            read_volume_label(device);
        }
    }
    else {                              // Else error getting BPB
        length = (char *) &packet.build_bpb_a.bba_bpb  - (char *) &packet;
    }

    // Send Response Packet

    if ( !FxSend(&packet, length) ) {
        return FALSE;
    }

    devices[device].invalid = FALSE;    // Clear invalid flag after we've
                                        // successfully build a BPB
    return TRUE;
}


/*  Read request Handler.  This routine handles a read request for a given
    device driver and drive.

    If this is DOS 3.0+ and error ERR_DISK_CHANGE (0FH) is returned, the driver
    will (should) return the volume label.
*/
int read_handler(word count)
{
    word volume_length;
    int device;

    count;

    device = (int) packet.io_r.ior_unit;
    if (device >= slave_block_devices) {
        rhp.s.rhp_status = STATUS_ERROR | STATUS_DONE | ERR_UNK_UNIT;
    }
    else {
        rhp.io_req.s.rhp_length = 22;
        rhp.io_req.s.rhp_unit = devices[device].unit;
        rhp.io_req.s.rhp_command = READ;
        rhp.io_req.media_id = packet.io_r.ior_media_id;
        rhp.io_req.io_data = buffer;
        rhp.io_req.io_requested = packet.io_r.ior_requested;
        if (slave_dos_version != DOS_VERSION(3, 31)) {
            rhp.io_req.io_start = packet.io_r.ior_start;
            rhp.io_req.io_huge_start = packet.io_r.ior_huge_start;
        }
        else {  // else MS-DOS 3.31
            rhp.io_req.s.rhp_length =
                (byte) ((byte *) &rhp.io_req.reserved - (byte *) &rhp);
            *((dword *) &rhp.io_req.io_start) = packet.io_r.ior_huge_start;
        }

        call_driver((void far *) &rhp, devices[device].header);
    }

    // build response packet

    packet.io_a.ioa_status = rhp.s.rhp_status;
    if (rhp.s.rhp_status & STATUS_ERROR)
        packet.io_a.ioa_transfered = 0;
    else
        packet.io_a.ioa_transfered = rhp.io_ans.io_transfered;
    packet.io_a.ioa_volume[0] = '\0';
    packet.io_a.ioa_serial_number = 0;
    volume_length = 0;
    if ((rhp.s.rhp_status & 0xff) == ERR_DISK_CHANGE && _osmajor >= 3) {
        memcpyf(packet.io_a.ioa_volume, rhp.io_ans.io_label, MAX_VOLUME);
        volume_length = MAX_VOLUME + 4;
    }

    // send response packet

    if ( !FxSend(&packet, (packet.io_a.ioa_volume
        - (char *) &packet) + volume_length) ) {
        return FALSE;
    }

    // send data

    if (rhp.io_ans.io_transfered) {
        if ( !FxSend(buffer, rhp.io_ans.io_transfered *
            devices[device].bytes_per_sector) ) {
            return FALSE;
        }
    }

    return TRUE;
}


/*  Write request Handler.  This routine handles a write request for a given
    device driver and drive.

    If this is DOS 3.0+ and error ERR_DISK_CHANGE (0FH) is returned, the driver
    will (should) return the volume label.
*/
int write_handler(word count)
{
    int device;
    word bufsiz;
    word volume_length;
    byte command;

    count;

    if (packet.packet_type == WRITE_REQ) {
        command = WRITE;
    }
    else {
        command = WRITE_VERIFY;
    }


    // get data to be written

    bufsiz = FxReceive(buffer, (word) sizeof(buffer));
    if (fx_errno) { // NOTE: have to check fx_errno because bufsize can be zero
        return FALSE;
    }

    device = (int) packet.io_r.ior_unit;

    if (device >= slave_block_devices) {
        rhp.s.rhp_status = STATUS_ERROR | STATUS_DONE | ERR_UNK_UNIT;
        rhp.io_ans.io_transfered = 0;
    }
    else if (bufsiz != packet.io_r.ior_requested *
        devices[device].bytes_per_sector) {
        rhp.s.rhp_status = STATUS_ERROR | STATUS_DONE | ERR_WRITE_FAULT;
        rhp.io_ans.io_transfered = 0;
    }
    else {
        rhp.io_req.s.rhp_length = 22;
        rhp.io_req.s.rhp_unit = devices[device].unit;
        rhp.io_req.s.rhp_command = command;
        rhp.io_req.media_id = packet.io_r.ior_media_id;
        rhp.io_req.io_data = buffer;
        rhp.io_req.io_requested = packet.io_r.ior_requested;
        rhp.io_req.io_start = packet.io_r.ior_start;
        rhp.io_req.io_huge_start = packet.io_r.ior_huge_start;
        if (slave_dos_version == DOS_VERSION(3, 31)) {
            rhp.io_req.s.rhp_length =
                (byte) ((byte *) &rhp.io_req.reserved - (byte *) &rhp);
            *((dword *) &rhp.io_req.io_start) = packet.io_r.ior_huge_start;
        }

        call_driver((void far *) &rhp, devices[device].header);
    }

    // build response packet 

    packet.io_a.ioa_status = rhp.s.rhp_status;
    packet.io_a.ioa_transfered = rhp.io_ans.io_transfered;
    packet.io_a.ioa_volume[0] = '\0';
    packet.io_a.ioa_serial_number = 0;
    volume_length = 0;
    if ((rhp.s.rhp_status & 0xff) == ERR_DISK_CHANGE && _osmajor >= 3) {
        memcpyf(packet.io_a.ioa_volume, rhp.io_ans.io_label, MAX_VOLUME);
        volume_length = MAX_VOLUME + 4;
    }

    return FxSend(&packet, (packet.io_a.ioa_volume
                 - (char *) &packet) + volume_length);
}


/*  Error Handler.  No longer used. */
int error_handler(word count)
{
    return TRUE;
}

int ocrm_handler(word count)
{
    int device;
    byte command;

    count;

    if (packet.packet_type == DEV_OPEN_REQ) {
        command = DEVICE_OPEN;
    }
    else {
        command = DEVICE_CLOSE;
    }

    device = (int) packet.ocrm_r.ocr_unit;

    if (device >= slave_block_devices) {
        rhp.s.rhp_status = STATUS_ERROR | STATUS_DONE | ERR_UNK_UNIT;
    }
    else {
        rhp.s.rhp_length  = sizeof(struct static_rhp);
        rhp.s.rhp_unit    = (byte) device;
        rhp.s.rhp_command = command;

        call_driver((void far *) &rhp, devices[device].header);
    }

    // build response packet

    packet.ocrm_a.oca_status = rhp.s.rhp_status;

    // 4) send response packet

    return FxSend(&packet, sizeof(struct ocrm_a));
}

int gen_ioctl_handler(word count)
{
    int device;
    struct media_id_buffer media_id_buffer;
    byte function = 0;

    device = (int) packet.gen_ioctl_r.gir_unit;
    if (device >= slave_block_devices) {
        rhp.s.rhp_status = STATUS_ERROR | STATUS_DONE | ERR_UNK_UNIT;
    }
    else {
        function = packet.gen_ioctl_r.gir_function;
        if (function == 0x46) {
            if ( !FxReceive(&media_id_buffer, sizeof(media_id_buffer)) ) {
                return FALSE;
            }
        }
        rhp.s.rhp_length  = sizeof(struct gen_ioctl_req);
        rhp.s.rhp_unit    = (byte) device;
        rhp.s.rhp_command = GENERIC_IOCTL;
        rhp.gen_ioctl_req.gen_category = packet.gen_ioctl_r.gir_category;
        rhp.gen_ioctl_req.gen_function = packet.gen_ioctl_r.gir_function;
        rhp.gen_ioctl_req.gen_data = &media_id_buffer;

        call_driver((void far *) &rhp, devices[device].header);
    }

    // build response packet

    packet.gen_ioctl_a.gia_status = rhp.s.rhp_status;

    // 4) send response packet

    if ( !FxSend(&packet, sizeof(struct gen_ioctl_a)) ) {
        return FALSE;
    }
    if ( (rhp.s.rhp_status & STATUS_ERROR) == 0 ) {
        if (function == 0x66)
            return FxSend(&media_id_buffer, sizeof(media_id_buffer));
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\drivinfo.c ===
/***
* $Workfile:   drivinfo.c  $
* $Revision:   1.8  $
*   $Author:   Dave Sewell  $
*     $Date:   22 Oct 1990 14:58:10  $
***/

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "fastlynx.h"
#include "dc.h"
/* BEGIN IPG -  define added to allow translation of "Mb" and "Kb"*/
#include "IPG.h"
/* END IPG -	  for MBSTRING and KBSTRING	*/
void prepare_drive_size(int device_index, char *size_buff)
{
    if (devices[device_index].data_size == 0L ||
        devices[device_index].is_floppy       ||
        (_osmajor >= 3 && devices[device_index].non_removable == FALSE) )
        size_buff[0] = '\0';
    else if (devices[device_index].data_size < 2000000L)
	sprintf(size_buff, KBSTRING,
            (int) (devices[device_index].data_size / 1000L) );
    else
	sprintf(size_buff, MBSTRING,
            (int) (devices[device_index].data_size / (1000L * 1000L) ) );
}

int drive_info_handler(word count)
{
    static char handler[] = "drive_info";
    struct drive_info_a far *drive_info_a = (struct drive_info_a far *) buffer;
    int i;
    char size_buff[15];

    count;

    i = packet.drive_info_r.server_drive_num;
    prepare_drive_size(i, size_buff);
    fstrcpy(drive_info_a->size, size_buff);
    fstrcpy(drive_info_a->volume_label, devices[i].volume_label);
    if ( !FxSend(drive_info_a, sizeof(struct drive_info_a)) ) {
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\drivers.h ===
/***
* $Workfile:   drivers.h  $
* $Revision:   1.3  $
*   $Author:   Dave Sewell  $
*     $Date:   08 Aug 1989 16:43:52  $
***/

/*  drivers.h : Alan Butt : December 19, 1988 : Expansion Box Project
 
    This file contains definitions for device driver structures.
*/

#pragma pack(1)

#define INIT                 0
#define MEDIA_CHECK          1
#define BUILD_BPB            2
#define IOCTL_READ           3
#define READ                 4
#define ND_READ              5
#define INPUT_STATUS         6
#define FLUSH_INPUT          7
#define WRITE                8
#define WRITE_VERIFY         9
#define OUTPUT_STATUS       10
#define FLUSH_OUTPUT        11
#define IOCTL_WRITE         12
#define DEVICE_OPEN         13
#define DEVICE_CLOSE        14
#define REMOVABLE_MEDIA     15
#define OUTPUT_UNTIL_BUSY   16
#define GENERIC_IOCTL       19
#define GET_LOGICAL_DEVICE  23
#define SET_LOGICAL_DEVICE  24

#define MAX_VOLUME          12          // Maximum volume label length

/*  For details on the bpb structure see MS-DOS Encyclopedia page 1349, and
    the section on device drivers.
*/

struct bios_parameter_block {
    word    bytes_per_sector;   // Bytes per sector
    byte    sectors_per_unit;   // Sectors per allocation unit (power of 2)
    word    reserved_sectors;   // # reserved sectors (starting at sector 0)
    byte    number_of_fats;     // Number of file allocation tables
    word    root_dir_entries;   // Maximum number of root directory entries
    word    total_sectors;      // Total number of sectors in medium
    byte    media_id_byte;      // Media ID byte
    word    sectors_per_fat;    // # of sectors occupied by a single FAT
    word    sectors_per_track;  // Sectors per track (MS-DOS 3.0+)
    word    number_of_heads;    // Number of heads (MS-DOS 3.0+)
    word    hidden_sectors;     // Number of hidden sectors (MS-DOS 3.0+)
    word    high_hidden;        // MSW hidden sectors (MS-DOS 3.2+)
    dword   long_total_sectors; // If total_sectors == 0, Total number of
                                // sectors in medium (MS-DOS 3.2+)
    byte    reserved[6];
};

#define DEVICE_NAME_SIZE 8

struct device_header {                      // Device header structure
    struct  device_header far *next_header; // Link to next driver
    word    attribute;                      // Device driver attribute word
    word    strategy;                       // Offset to strategy entry point
    word    inter;                          // Offset to interrupt entry point
    byte    name_num[DEVICE_NAME_SIZE];     // Device name or number of units
};


/*  The disk paramenter structure is used by undocumented DOS calls 0x32, 0x52,
    and 0x53.  This structure is defined for MS-DOS 2.0 - MS-DOS 4.0.
*/

struct dpb_dos2 {
    byte drive;                     // Drive # (0 = A, 1 = B, ...)
    byte unit;                      // Unit number within device driver
    word bytes_per_sector;          // Number of bytes per sector
    byte max_cluster;               // Largest sector number in cluster
                                    //  add one for number of sectors/cluster
    byte log2_cluster;              // Log base two of the cluster size
    word reserved_sectors;          // Number of reserved (boot) sectors
    byte number_of_fats;            // Number of copies of the FAT
    word root_dir_entries;          // Number of root directory entries
    word first_data;                // First sector of data on medium
    word max_number;                // Largest possible cluster number
                                    //  subtract one for number of clusters
    byte sectors_per_fat;           // Number of sectors in one FAT copy
    word first_root;                // First sector of root directory
    struct device_header far *device_driver;
                                    // Corresponding device driver address
    byte media_id;                  // Media descriptor byte
    byte valid;                     // 0FF indicates block must be rebuild
    struct dpb_dos2 far *next_block;
                                    // address of next device block in list
    word dir_start;                 // Starting cluster of current directory
                                    //  zero indicates the root directory
    char path_name[64];             // ASCIIZ current directory path string
};

struct dpb_dos3 {
    byte drive;                     // Drive # (0 = A, 1 = B, ...)
    byte unit;                      // Unit number within device driver
    word bytes_per_sector;          // Number of bytes per sector
    byte max_cluster;               // Largest sector number in cluster
                                    //  add one for number of sectors/cluster
    byte log2_cluster;              // Log base two of the cluster size
    word reserved_sectors;          // Number of reserved (boot) sectors
    byte number_of_fats;            // Number of copies of the FAT
    word root_dir_entries;          // Number of root directory entries
    word first_data;                // First sector of data on medium
    word max_number;                // Largest possible cluster number
                                    //  subtract one for number of clusters
    byte sectors_per_fat;           // Number of sectors in one FAT copy
    word first_root;                // First sector of root directory
    struct device_header far *device_driver;
                                    // Corresponding device driver address
    byte media_id;                  // Media descriptor byte
    byte valid;                     // 0FF indicates block must be rebuild
    struct dpb_dos3 far *next_block;
                                    // address of next device block in list
    word unknown_zero;              // Unknown value (usually zero?)
    word unknown_ffff;              // Unknown value (usually ffff?)
};


struct dpb_dos4 {
    byte drive;                     // Drive # (0 = A, 1 = B, ...)
    byte unit;                      // Unit number within device driver
    word bytes_per_sector;          // Number of bytes per sector
    byte max_cluster;               // Largest sector number in cluster
                                    //  add one for number of sectors/cluster
    byte log2_cluster;              // Log base two of the cluster size
    word reserved_sectors;          // Number of reserved (boot) sectors
    byte number_of_fats;            // Number of copies of the FAT
    word root_dir_entries;          // Number of root directory entries
    word first_data;                // First sector of data on medium
    word max_number;                // Largest possible cluster number
                                    //  subtract one for number of clusters
    byte sectors_per_fat;           // Number of sectors in one FAT copy
    byte unknown_byte;              // Unknown byte
    word first_root;                // First sector of root directory
    struct device_header far *device_driver;
                                    // Corresponding device driver address
    byte media_id;                  // Media descriptor byte
    byte valid;                     // 0FF indicates block must be rebuild
    struct dpb_dos4 far *next_block;
                                    // address of next device block in list
    word unknown_zero;              // Unknown value (usually zero?)
    word unknown_ffff;              // Unknown value (usually ffff?)
};

union dpb {
    struct dpb_dos2 dos2;           // Disk parameter block for DOS 2.0+
    struct dpb_dos3 dos3;           // Disk parameter block for DOS 3.0+
    struct dpb_dos4 dos4;           // Disk parameter block for DOS 4.0+
};

/*  Device attribute codes:  ATT_* define the various bits to be used in the
    device driver attribute word of the device header.
*/

#define ATT_CHARACTER   0x8000          // Character device
#define ATT_BLOCK       0x0000          // Block device
#define ATT_IOCTL       0x4000          // IOCTL read and write supported
#define ATT_NON_IBM     0x2000          // Non-IBM format (block)
#define ATT_OUTBUSY     0x2000          // Output Until Busy supported (Char)
#define ATT_OCRM        0x0800          // Open/Close/Removeable media supported*
#define ATT_GEN_IOCTL   0x0040          // Generic IOCTL & Get/Set log dev**
#define ATT_INT29       0x0010          // accepts special interupt 29h
#define ATT_CLOCK       0x0008          // this is the CLOCK device
#define ATT_NUL         0x0004          // Current NUL device
#define ATT_HUGE        0x0002          // 32-bit sector addressing (block)
#define ATT_STDOUT      0x0002          // Current standard output
#define ATT_STDIN       0x0001          // Current standard input
                                        // *  MS-DOS 3.0+
                                        // ** MS-DOS 3.2+

#define STATUS_ERROR    0x8000          // error status
#define STATUS_BUSY     0x0200          // busy status
#define STATUS_DONE     0x0100          // Done

#define ERR_WRITE_PROT  0x00            // write-protect error
#define ERR_UNK_UNIT    0x01            // Unknown unit
#define ERR_NOT_READY   0x02            // Drive not ready
#define ERR_UNK_COMMAND 0x03            // Unknown command
#define ERR_CRC         0x04            // CRC error
#define ERR_BAD_LENGTH  0x05            // Bad drive request structure length
#define ERR_SEEK        0x06            // Seek error
#define ERR_UNK_MEDIA   0x07            // Unknown media
#define ERR_NOT_FOUND   0x08            // Sector not found
#define ERR_PAPER_OUT   0x09            // Printer out of paper
#define ERR_WRITE_FAULT 0x0a            // Write fault
#define ERR_READ_FAULT  0x0b            // Read fault
#define ERR_FAILURE     0x0c            // General Failure
#define ERR_DISK_CHANGE 0x0f            // Invalid disk change


#define MEDIA_CHANGED      -1           // Media changed code
#define MEDIA_DONT_KNOW     0           // Don't know if media has changed
#define MEDIA_NOT_CHANGED   1           // Media has not changed code

#define MEDIA_5_25_DS_15    0xF9        // 5.25" double sided, 15 sector
#define MEDIA_5_25_SS_9     0xFC        // 5.25" single sided, 9 sector
#define MEDIA_5_25_DS_9     0xFD        // 5.25" double sided, 9 sector
#define MEDIA_5_25_SS_8     0xFE        // 5.25" single sided, 8 sector
#define MEDIA_5_25_DS_8     0xFF        // 5.25" double sided, 8 sector
#define MEDIA_3_5_DS_9      0xF9        // 3.5"  double sided, 9 sector
#define MEDIA_FIXED_DISK    0xF8        // Fixed disk
#define MEDIA_3_5_DS_18     0xF0        // 3.5"  double sided, 18 sector

struct static_rhp {                     // Static RHP definition
    byte    rhp_length;                 // Request header length
    byte    rhp_unit;                   // Block-device unit number
    byte    rhp_command;                // Command code (driver subfunction)
    word    rhp_status;                 // Driver return status
    byte    reserved[0x0d - 0x05];
};


struct init_req {                       // initialize request
    struct  static_rhp s;
    byte    reserved[5];
    char far *init_cmd;                 // Segment:Offset of line loading driver
    byte    init_first;                 // First unit number
};


struct  init_ans {                      // Initialization answer
    struct  static_rhp s;
    byte    init_units;                 // Units supported
    void far *init_end;                 // Segment:offset free mem above driver
    void far *init_bpb;                 // Segment:Offset BPB pointer array
};



struct media_check_req {                // Media Check request
    struct  static_rhp s;
    byte    media_id;                   // Media ID byte
};

struct media_check_ans {                // Media check answer
    struct  static_rhp s;
    byte    reserved;
    byte    media_changed;              // Media changed code
    char far *media_label;              // Segment:Offset of volume label
};



struct build_bpb_req {                  // Build BPB request
    struct  static_rhp s;
    byte    media_id;                   // Media ID byte
    char far *bpb_fat;                  // Segment:Offset of FAT buffer
};

struct build_bpb_ans {                  // Build BPB answer
    struct  static_rhp s;
    byte    reserved[5];
    struct bios_parameter_block far *bpb_bpb;
                                        // Segment:Offset of BPB
};



struct io_req {     // Read/Write/Write-Verify/IOCTL-Read/IOCTL-Write request
    struct  static_rhp s;
    byte    media_id;                   // Media ID byte
    char far *io_data;                  // Segment:Offset of data
    word    io_requested;               // Bytes/Sectors Requested
    word    io_start;                   // Starting sector number (LSW)
    word    io_start_high;              // Starting sector number (MSW) (MS-DOS 3.31)
    word    reserved;
    dword   io_huge_start;              // 32-bit sector number (MS-DOS 4.0+)
};

struct io_ans {     // Read/Write/Write-Verify/IOCTL-Read/IOCTL-Write answer
    struct  static_rhp s;
    byte    reserved[5];
    word    io_transfered;              // Bytes/Sectors transfered
    word    reserved2;
    char far *io_label;                 // Segment:Offset of volume label
};


struct nd_read_ans {                    // Non-Destructive read answer
    struct  static_rhp s;
    byte    nd_read_char;               // Character read
};


struct gen_ioctl_req {                  // Generic IOCTL request
    struct  static_rhp s;
    byte    gen_category;               // Category (major) code
    byte    gen_function;               // Function (minor) code
    word    gen_si;                     // SI register contents
    word    gen_di;                     // DI register contents
    void far *gen_data;                 // Segment:Offset of data package
};

struct media_id_buffer {
    word  info_level;
    dword serial_number;
    byte  volume_label[11];
    byte  file_sys_type[8];
};

struct device_params {
   byte   dpSpecFunc;                   // special functions
   byte   dpDevType;                    // device type
   word   dpDevAttr;                    // device attributes
   word   dpCylinders;                  // number of cylinders
   byte   dpMediaType;                  // media type
   struct bios_parameter_block bpb;     // BPB
};

#define MAX_DEVICES         26          // Maximum number of units for the block
                                        // device drivers.

#define MAX_CHAR_DEVICES    20          // Max # of character devices
#define MAX_RHP             32          // Maximum size of an RHP
#define PRODUCT_DOSLINK     0           // Product code
#define PRODUCT_VERSION     (((MAJOR_VERSION << 8) | MINOR_VERSION))
#define STACK_SIZE          256         // Device driver stack size (in bytes)
#define MAX_PRINTERS        3           // Max printers that can be redirected
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\percent.asm ===
;***
;* $Workfile:   percent.asm  $
;* $Revision:   1.0  $
;*   $Author:   Dave Sewell  $
;*     $Date:   13 Oct 1989 11:28:00  $
;*
;*****************************************************************************

%               .MODEL memmodel

	IF	@CodeSize
X	EQU	6
	ELSE
X	EQU	4
	ENDIF
                .CODE

;extern int _fastcall percent(long current, long total);
;

@percent        PROC
                PUBLIC  @percent

                push    bp
                mov     bp, sp
                mov     bx, [BP + X]        ;Low order word of total
                mov     cx, [BP + X + 2]    ;High order word of total

;Now DX:AX has current, CX:BX has total

                cmp     dx, cx
                ja      one_hundred

scale_loop:     or      cx, cx
                jz      calculate

                shr     dx, 1
                rcr     ax, 1
                shr     cx, 1
                rcr     bx, 1
                jmp     scale_loop

calculate:      cmp     ax, bx
                jae     one_hundred

                mov     dx, 100
                mul     dx              ;Now DX:AX = scaled current * 100
                cmp     bx, dx
                jbe     zero

                div     bx
                jmp     short percent_done

zero:           xor     ax, ax
                jmp     short percent_done

one_hundred:    mov     ax, 100

percent_done:   pop     bp
                ret     4               ;Pop off the stack arguments!!!

@percent        ENDP

            END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\print.c ===
/***
* $Workfile:   bioshndl.c  $
* $Revision:   1.1  $
*   $Author:   Dave Sewell  $
*     $Date:   27 Jun 1989 14:54:46  $
***/

/*  bioshndl.c : Alan Butt : May 18, 1989 : Expansion Box Project

    This routine contains contains the handlers for BIOS printing packets.
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <bios.h>
#include "fastlynx.h"
#include "dc.h"

#define TIMEOUT         0x01            // Timeout bit
#define ERROR           0x08            // Error bit
#define SELECTED        0x10            // Selected bit
#define OUT_OF_PAPER    0x20            // Out of paper bit
#define ACKNOWLEDGE     0x40            // Acknowledge bit
#define NOT_BUSY        0x80            // Not busy bit

int prn_write_handler(word count)
{
    byte lpt_id;
    word bufsiz;
    char far *buf;

    if (packet.lpt_o_r.print_count > 1) {
        bufsiz = FxReceive(buffer, (word) sizeof(buffer));
        if (!bufsiz) {
            return FALSE;
        }
        buf = buffer;
    }
    else {
        bufsiz = packet.lpt_o_r.print_count;
        buf = (char far *) &packet.lpt_o_r.print_data;
    }
    lpt_id = packet.lpt_o_r.lpt_id;
    if (lpt_id > 2 || !lpt_drivers[lpt_id]) {
        rhp.io_ans.s.rhp_status = STATUS_ERROR | STATUS_DONE | ERR_UNK_UNIT;
        rhp.io_ans.io_transfered = 0;
    }
    else if (bufsiz != packet.lpt_o_r.print_count) {
        rhp.io_ans.s.rhp_status = STATUS_ERROR | STATUS_DONE | ERR_WRITE_FAULT;
        rhp.io_ans.io_transfered = 0;
    }
    else {
        rhp.io_req.s.rhp_length = sizeof(struct io_req);
        rhp.io_req.s.rhp_command = WRITE;
        rhp.io_req.io_data = buf;
        rhp.io_req.io_requested = packet.lpt_o_r.print_count;
        call_driver((void far *) &rhp, lpt_drivers[lpt_id]);
    }
    packet.lpt_o_a.lpt_status = rhp.io_ans.s.rhp_status;
    packet.lpt_o_a.lpt_transferred = rhp.io_ans.io_transfered;
    return FxSend(&packet, sizeof(struct lpt_o_a));
}

int prn_cmd_handler(word count)
{
    byte lpt_id;
    byte command;
    static char lpt_name[] = "LPT?";
    static int lpt_handles[3] = { -1, -1, -1 };

    if (packet.packet_type == OUTPUT_STATUS_REQ)
        command = OUTPUT_STATUS;
    else if (packet.packet_type == FLUSH_OUTPUT_REQ)
        command = FLUSH_OUTPUT;
    else if (packet.packet_type == AUX_DEV_OPEN_REQ)
        command = DEVICE_OPEN;
    else
        command = DEVICE_CLOSE;
    lpt_id = packet.lpt_cmd_r.lpt_id;
    if (lpt_id > 2 || !lpt_drivers[lpt_id]) {
        rhp.s.rhp_status = STATUS_ERROR | STATUS_DONE | ERR_UNK_UNIT;
    }
    else {
        rhp.s.rhp_length = sizeof(struct static_rhp);
        rhp.s.rhp_command = command;
        if ( (lpt_drivers[lpt_id]->attribute & ATT_OCRM) ||
             (command == OUTPUT_STATUS) || (command == FLUSH_OUTPUT) )
            call_driver((void far *) &rhp, lpt_drivers[lpt_id]);
        else {      // Device open or device close not supported - use INT 21H
            if (command == DEVICE_OPEN) {
                if (lpt_handles[lpt_id] < 0) {
                    lpt_name[3] = (char) lpt_id + (char) '1';
                    if ( _dos_open(lpt_name, 1, &lpt_handles[lpt_id]) != 0 )
                        lpt_handles[lpt_id] = -1;
                }
            }
            else if (command == DEVICE_CLOSE) {
                if (lpt_handles[lpt_id] >= 0) {
                    _dos_close(lpt_handles[lpt_id]);
                    lpt_handles[lpt_id] = -1;
                }
            }
            rhp.s.rhp_status = STATUS_DONE;     // Fake it.
        }
    }
    packet.lpt_cmd_a.lca_status = rhp.s.rhp_status;
    return FxSend(&packet, sizeof(struct lpt_cmd_a));
}

int bios_handler(word count)
{
    int command;
    word status, port;

    port = packet.bios_r.bsr_bios_port;
    command = packet.packet_type - BIOS_PRINT_REQ;
    if (port < (word) num_lpt && printers[port].enabled) {
        status = _bios_printer(command, port, packet.bios_r.bsr_char);
    }
    else
        status = SELECTED | ERROR | TIMEOUT;
    packet.bios_a.bsa_status = (byte) status;

    // send response packet

    if ( !FxSend(&packet, sizeof(struct bios_a)) ) {
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\main.c ===
/***
* $Workfile:   main.c  $
* $Revision:   1.13  $
*   $Author:   Dave Sewell  $
*     $Date:   22 Oct 1990 14:57:46  $
***/

/*  main.c : Alan Butt : February 1, 1988 : Expansion Box Project

    This module contains main() and the packet dispatcher

*/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <time.h>
#include <bios.h>
#define  FX_MAIN    1
#include "fastlynx.h"
#include <conio.h>

#define EXTERN                          // Make declarations real!
#include "dc.h"

#define DIVIDER_ROW 10
#define BOX_TOP     4
#define MSG_LINES   3

#define REPAINT_KEY -2

extern byte dos5_switcher;

char *clone(char *argp);

PIFW packet_handler[] = {
    server_info_handler,                // Server Info Request handler
    init_handler,                       // Initialize Request
    media_check_handler,                // Media Check Request
    build_bpb_handler,                  // Build BPB Request
    read_handler,                       // Read Request
    write_handler,                      // Write Request
    write_handler,                      // Write-Verify Request
    error_handler,                      // Error packet
    unknown_handler,                    // Aux device Init Request
    unknown_handler,                    // Aux device Read Request
    prn_write_handler,                  // Aux device write Request
    prn_write_handler,                  // Aux device Write-Verify Request
    unknown_handler,                    // Non-destructive read request
    unknown_handler,                    // Input status request
    prn_cmd_handler,                    // Output status request
    unknown_handler,                    // Flush Input request
    prn_cmd_handler,                    // Flush Output request
    prn_cmd_handler,                    // Auxiliary Device Open request
    prn_cmd_handler,                    // Auxiliary Device Close request
    unknown_handler,                    // Auxiliary IOCTL Read request
    prn_write_handler,                  // Auxiliary IOCTL Write request
    prn_write_handler,                  // Output until busy request
    ocrm_handler,                       // Device Open request
    ocrm_handler,                       // Device Close request
    ocrm_handler,                       // Removable Media request
    bios_handler,                       // BIOS INT 17H Print handler
    bios_handler,                       // BIOS INT 17H Init handler
    bios_handler,                       // BIOS INT 17H Status handler
    drive_info_handler,                 // Drive info request handler.
    gen_ioctl_handler,                  // Generic IOCTL handler
};

// WARNING: The array below MUST correspond to packet_handler[] above.

static byte packet_types[] = {
    SDP_INACTIVE,                   // Unknown Packet type handler
    SDP_INACTIVE,                   // Initialize Request
    SDP_READING,                    // Media Check Request
    SDP_READING,                    // Build BPB Request
    SDP_READING,                    // Read Request
    SDP_WRITING,                    // Write Request
    SDP_WRITING,                    // Write-Verify Request
    SDP_INACTIVE,                   // Error packet
    SDP_INACTIVE,                   // Aux device Init Request
    SDP_INACTIVE,                   // Aux device Read Request
    SDP_PRINTING,                   // Aux device write Request
    SDP_PRINTING,                   // Aux device Write-Verify Request
    SDP_INACTIVE,                   // Non-destructive read request
    SDP_INACTIVE,                   // Input status request
    SDP_INACTIVE,                   // Output status request
    SDP_INACTIVE,                   // Flush Input request
    SDP_INACTIVE,                   // Flush Output request
    SDP_INACTIVE,                   // Auxiliary Device Open request
    SDP_INACTIVE,                   // Auxiliary Device Close request
    SDP_INACTIVE,                   // Auxiliary IOCTL Read request
    SDP_INACTIVE,                   // Auxiliary IOCTL Write request
    SDP_PRINTING,                   // Output until busy request
    SDP_READING,                    // Device Open request
    SDP_READING,                    // Device Close request
    SDP_READING,                    // Removable Media request
    SDP_PRINTING,                   // BIOS INT 17H Print handler
    SDP_PRINTING,                   // BIOS INT 17H Init handler
    SDP_PRINTING,                   // BIOS INT 17H Status handler
    SDP_INACTIVE,                   // Install info request handler.
    SDP_INACTIVE                    // Generic IOCTL handler
};

struct FxBiosInfo Bios;

char *final_msg = 0;

int drdos = FALSE;

byte win386_enh_mode = FALSE;       // Used in communication routines also
static byte int_2f_ok = FALSE;

int status_width;

byte check_abort_flag = FALSE;

#define LOC_WIDTH   12
#define EQ_WIDTH     7
#define REM_WIDTH   14

static int pascal auto_serial(void);

static byte included_drives[26];
static byte excluded_drives[26];
static int num_includes;

static int last_port = -1;              // Keeps track of last used port
static int current_serial_port;
static byte excluding = FALSE;

#define LEFT_MARGIN     4

static byte display_left_col = 20 + LEFT_MARGIN;      // Default to non-split-screen value
static byte display_right_col = 40 + LEFT_MARGIN;
static byte display_rows;
static byte split_screen = FALSE;
static int  top_row;

static byte port_column;
static byte status_column;
static byte speed_column;
static int  speed_size;

static int current_drive = -1;
static int current_printer = -1;

static char reading_arrow[] = "";
static char writing_arrow[] = "";
static char spaces[]        = "    ";

static byte screen_initialized = FALSE;

#if 0
void _far _cdecl dprintf(char *fmt, ...)
{
    va_list arg_ptr;
    char msg_buff[512];
    unsigned n;
    static char press_any[] = "\r\nPress any key\r\n";

    va_start(arg_ptr, fmt);
    vsprintf(msg_buff, fmt, arg_ptr);
    _dos_write(1, (void _far *) msg_buff, strlen(msg_buff), &n);
    _dos_write(1, (void _far *) press_any, strlen(press_any), &n);
    read_key();
}
#endif

void cdecl warn_printf(char *fmt, ...)
{
    va_list arg_ptr;
    char msg_buff[512];
    int c;

    do_init_screen();
    va_start(arg_ptr, fmt);
    vsprintf(msg_buff, fmt, arg_ptr);
    strcat(msg_buff, press_enter_to_continue);
    draw_screen(msg_buff, 0, WARNING_COLOR);
    for (;;) {
        c = read_key();
        if (c == F3 || c == ALT_F4 || c == CTRL_C)
            exit(2);
        else if (c == '\r') {
            fill_attr(coord(1, 0), boxsize(scr_rows - 2, 80), ' ', SCROLL_COLOR);
            return;
        }
    }
}

char *port_name(int port_index)
{
    static char port_buff[11];

    if (FxPortInfo[port_index].type == PARALLEL_PORT) {
        if (FxPortInfo[port_index].biosnum)
            sprintf(port_buff, "LPT%d", FxPortInfo[port_index].biosnum);
        else
            sprintf(port_buff, "LPT(%X)", FxPortInfo[port_index].address);
    }
    else {
        if (FxPortInfo[port_index].biosnum)
            sprintf(port_buff, "COM%d", FxPortInfo[port_index].biosnum);
        else
            sprintf(port_buff, "COM(%X)", FxPortInfo[port_index].address);
    }
    return port_buff;
}

static void near check_drdos(void)
{
    char *env;

    if ((env = getenv("OS")) && strcmpi(env, "DRDOS") == 0)
        drdos = TRUE;   // must be running DRDOS
    else
        drdos = FALSE;
}

static int port_coord(void)
{
    return ( coord(scr_rows - 1, port_column) );
}

static int status_coord(void)
{
    return ( coord(scr_rows - 1, status_column) );
}

static int speed_coord(void)
{
    return ( coord(scr_rows - 1, speed_column) );
}

static int drive_coord(int drive_num, int is_client)
{
    int col = display_left_col;
    int row = drive_num;

    if ((byte) drive_num >= display_rows) {
        col = display_right_col;
        row -= display_rows;
    }
    return ( coord(top_row + 4 + row, col) + (is_client ? 20 : 0) );
}

static int printer_coord(int printer_num, int is_client)
{
    return drive_coord(num_drives + printer_num, is_client);
}

static void _far _pascal show_speed(void)
{
    if (fx_port == -1) {
        fill_attr(speed_coord(), boxsize(1, speed_size), ' ', STATUS_COLOR);
    }
    else {
        if (FxPortInfo[fx_port].type == SERIAL_PORT) {
            justify_str( speed_coord(), speed_size, STATUS_COLOR,
                (fx_send_variable || fx_recv_variable) ?
                variable_serial_speed : baud_table[fx_baud], -1);
        }
        else {
            justify_str( speed_coord(), speed_size, STATUS_COLOR,
                fx_parallel_speed == PARALLEL_NORMAL ?
                parallel_normal : parallel_turbo, -1);
        }
    }
}

static void show_port(void)
{
    char buff[40];

    if (fx_port != last_port) {
        sprintf(buff, fx_port == -1 ? "" : "%s:", port_name(fx_port) );
        justify_str( port_coord(), 10, STATUS_COLOR, buff, -1);
        last_port = fx_port;
    }
    show_speed();
}

static void show_drive_state(int status)
{
    if (current_drive != -1) {
        set_attribute(LIST_NORMAL);
        dispchar(drive_coord(current_drive, FALSE) - 2,
            (status == SDP_READING || status == SDP_WRITING) ? '*' : ' ');
    }
}

static void _fastcall show_prn_state(int status)
{
    if (current_printer != -1) {
        set_attribute(LIST_NORMAL);
        dispchar(printer_coord(current_printer, FALSE) - 2,
            status == SDP_PRINTING  ? '*' : ' ');
    }
}

static int _fastcall drive_slot(byte slave_device)
{
    byte *ptr = memchr(drive_priority, slave_device, num_drives);

    if (ptr)
        return ptr - drive_priority;
    else
        return -1;          // Error!
}

void _fastcall show_dp_status(int status)
{
    static int last_paint = SDP_INACTIVE;
    static char *msgs[] = { idle, reading, writing, printing };

    show_drive_state(status);
    show_prn_state(status);
    if (status == last_paint)              // no need to re-paint
        return;
    justify_str(status_coord(), status_width, STATUS_COLOR, msgs[status], -1);
    last_paint = status;
}

#pragma optimize("sleazrg", off)

static void desqview_api(void)
{
    _asm {
        push di 
		mov	ax, 101AH
		int	15H
		mov	ax, bx
		int	15H
		mov	ax, 1025H
		int	15H
        pop di
    }
}

static void enter_critical(void)
{
    _asm {
        mov     ax, 352FH
        int     21H
        mov     ax, es
        or      ax, bx
        jz      enter_done

        inc     int_2f_ok       ; OK to use INT 2FH since vector is not zero
        mov     ax, 1600H
        int     2FH
        test    al, 7FH
        jz      enter_done

        cmp     al, 1
        je      enter_done

        cmp     al, -1
        je      enter_done

        inc     win386_enh_mode
        xor     di, di
        mov     es, di
        mov     bx, 0015H       ; Device ID of DOSMGR device
        mov     ax, 1684H       ; Get API entry point
        int     2FH
        mov     ax, es
        or      ax, di
        jz      crit

        push    cs              ; Push return segment
        mov     ax, OFFSET crit
        push    ax              ; Push return offset
        push    es
        push    di              ; API far call address
        mov     ax, 1           ; SetFocus function number
        retf

crit:   mov     ax, 1681H       ; Enter critical section
        int     2FH
    }
enter_done:;
}

static void _cdecl leave_critical(void)
{
    if (win386_enh_mode) {
        _asm {
                mov     ax, 1682H
                int     2FH
        }
    }
}

static void release_time_slice(void)
{
    if (int_2f_ok) {
        _asm {
                mov     ax, 1680H
                int     2FH
        }
    }
}

static void stop_desqview_multitasking(void)
{
    _asm {
        push di
        mov  bx, 101BH
        call desqview_api           ; Begin critical section
        mov  bx, 1C0DH              ; <Enter>
        mov  ax, 1110H
        int  15H
        mov  bx, 314EH              ; 'N'    
        mov  ax, 1110H
        int  15H
        mov  bx, 1454H              ; 'T'    
        mov  ax, 1110H
        int  15H
        mov  bx, 1352H              ; 'R'    
        mov  ax, 1110H
        int  15H
        mov  bx, 0FC00H             ; Special "Alt" code
        mov  ax, 1110H
        int  15H
        mov  bx, 101CH
        call desqview_api           ; End critical section
        pop  di
    }
}

#pragma optimize("sleazrg", on)

static void attempt_transaction(void)
{
    word count;
    int ptype;
    int request_type;
    int result;
    static byte connected = FALSE;

    if (!connected) {
        if ( FxListen() == 1 ) {
            connected = TRUE;
            show_port();
            FxShowBaud(show_speed);
        }
        else {
            release_time_slice();
            return;
        }
    }
#if 0
    // Special debug code to test midnight wrap around.
    // If time is later than 12:01 am, reset to 11:59 pm.
    {
        union REGS regs;

        regs.h.ah = 0x2C;
        intdos(&regs, &regs);
        if (regs.h.ch != 23 || regs.h.cl < 59) {
            regs.h.ah = 0x2D;
            regs.h.ch = 23;
            regs.h.cl = 59;
            regs.h.dh = 0;
            regs.h.dl = 0;
            intdos(&regs,&regs);
        }
    }
#endif
    count = FxReceive(&packet, sizeof(packet));
    if (count == 0) {
        connected = FALSE;
        show_port();
        return;
    }

    memset(&rhp, '\0', sizeof(rhp));    // Insure RHP all clear

    ptype =  packet.packet_type;
    current_drive = -1;
    current_printer = -1;
    if (ptype >= 0 && ptype < PACKET_TYPES) {
        request_type = packet_types[ptype];
        if (request_type == SDP_READING || request_type == SDP_WRITING)
            current_drive = drive_slot(packet.io_r.ior_unit);
        else if (request_type == SDP_PRINTING)
            current_printer = (int) packet.lpt_o_r.lpt_id;
        show_dp_status(request_type);
        result = (*packet_handler[ptype])(count);
    }
    else
        result = FALSE;
    if (!result) {
        connected = FALSE;
        show_port();
    }
    show_dp_status(SDP_INACTIVE);
}

void generate_drive_mappings(byte *map_table, int num_master_units, byte *desired_map)
{
    int master_unit;
    int i;
    byte slave_devices_used[MAX_DEVICES];

    memcpy(map_table, desired_map, MAX_DEVICES);
    memset(slave_devices_used, '\0', MAX_DEVICES);
    for (i = 0; i < MAX_DEVICES; i++) {
        // First check validity of all fixed assignments.
        if (map_table[i] < MAX_DEVICES) {
            if (map_table[i] >= (byte) slave_block_devices ||
                !memchr(drive_priority, map_table[i], num_drives) )
                map_table[i] = UNASSIGNED;
            else
                slave_devices_used[map_table[i]] = 1;
        }
    }
    master_unit = 0;
    for (i = 0; i < num_drives; i++) {
        while (master_unit < num_master_units &&
               map_table[master_unit] != DONT_CARE) {
            if ( !memchr(drive_priority, map_table[master_unit], num_drives) )
                map_table[master_unit] = UNASSIGNED;
            master_unit++;
        }
        if (master_unit >= num_master_units)
            break;
        while (i < num_drives && slave_devices_used[drive_priority[i]])
            i++;
        if (i >= num_drives)
            break;
        map_table[master_unit] = drive_priority[i];
    }
}

void make_printer_map(void)
{
    int i;

    for (i = 0; i < num_lpt; i++) {
        if ( (fx_port == -1) || FxPortInfo[fx_port].address != printers[i].address) {
            printers[i].enabled = TRUE;
        }
        else
            printers[i].enabled = FALSE;
    }
}

void show_drive_mappings(byte *map_table, int show_master)
{
    int i = 0;
    char buff[20];
#define STATUS_LEFT     41
    byte slave_mapping[MAX_DEVICES];
    int parallel_connection;
    byte di;
    byte *mptr;
    char size_buff[10];

    memset(slave_mapping, 0xFF, sizeof(slave_mapping));
    for (i = 0; i < MAX_DEVICES; i++) {
        if (map_table[i] < MAX_DEVICES)
            slave_mapping[map_table[i]] = (byte) i;
    }

    for (i = 0; i < num_drives; i++) {
        di = drive_priority[i];
        if (slave_mapping[di] != 0xFF)
            set_attribute(LIST_NORMAL);
        else
            set_attribute(LIST_DIM);
        sprintf(buff, "%c:", devices[di].drive + 'A');
        justify_str(drive_coord(i, FALSE), LOC_WIDTH, LIST_NORMAL, buff, -1);
        if (show_master) {
            if (config.master_first_unit + slave_mapping[di] < MAX_DEVICES) {
                sprintf(buff, "%c:",
                    config.master_first_unit + slave_mapping[di] + 'A');
            }
            else
                strcpy(buff, not_connected);
        }
        else {
            buff[0] = '\0';
        }
        justify_str(drive_coord(i, TRUE), REM_WIDTH, LIST_NORMAL, buff, -1);
        if (buff[0])
            justify_str(drive_coord(i, FALSE) + LOC_WIDTH, EQ_WIDTH, LIST_NORMAL,
                    equals_msg, 0);
        prepare_drive_size(di, size_buff);
        justify_str(drive_coord(i, FALSE) + 3, 7, LIST_NORMAL, size_buff, -1);
    }

    parallel_connection = -1;
    make_printer_map();
    for (i = 0; i < num_lpt; i++) {
        sprintf(buff, "LPT%d:", i + 1);
        justify_str(printer_coord(i, FALSE), LOC_WIDTH,
            printers[i].enabled ? LIST_NORMAL : LIST_DIM, buff, -1);
        if (printers[i].enabled) {
            mptr = memchr(actual_prn_map, i, 3);
            if (show_master) {
                if (mptr) {
                    sprintf(buff, "LPT%d:", mptr + 1 - actual_prn_map);
                    justify_str(printer_coord(i, TRUE),
                        REM_WIDTH, LIST_NORMAL, buff, -1);
                }
                else {
                    justify_str(printer_coord(i, TRUE),
                        REM_WIDTH, LIST_NORMAL, not_connected, -1);
                }
                justify_str(printer_coord(i, FALSE) + LOC_WIDTH, EQ_WIDTH,
                            LIST_NORMAL, equals_msg, 0);
            }
        }
        else 
            justify_str(printer_coord(i, TRUE), REM_WIDTH, LIST_NORMAL, "", -1);
    }
}

static void draw_status_box(byte left_col)
{
    byte width   = 40;

    draw_box(coord(top_row, left_col),  boxsize(display_rows + 5, width), SINGLE, LIST_NORMAL);
    justify_str(coord(top_row + 1, left_col + 1), width - 2, LIST_NORMAL, box_header1, 0);
    justify_str(coord(top_row + 2, left_col + 1), width - 2, LIST_NORMAL, box_header2, 0);
    dispchar(coord(top_row + 3, left_col), F_RT1);
    fill(coord(top_row + 3, left_col + 1), boxsize(1, width - 2), F_H1);
    dispchar(coord(top_row + 3, left_col + width - 1), F_LT1);
}

static void near paint_main_screen(void)
{
    char *speed_equal;
    char *speed_ptr;

    if (split_screen) {
        draw_status_box(0);
        draw_status_box(40);
    }
    else {
        draw_status_box(20);
    }
    justify_str(coord(scr_rows - 1, 0), 80, STATUS_COLOR, status_line, -1);
    port_column   = (byte)((strchr(status_line, '=') - status_line) + 1);
    status_column = (byte)((strchr(status_line, ':') - status_line) + 2);
    status_width  = (int)(strchr(status_line, '') - strchr(status_line, ':')) - 2;
    speed_equal   = strchr(status_line+port_column, '=');
    speed_column  = (byte)(speed_equal + 1 - status_line);
    speed_ptr     = speed_equal + 1;
    while (*(speed_ptr) != '')
        speed_ptr++;
    speed_size    = speed_ptr - (speed_equal + 1);
}

static void _near show_devices(void)
{
    byte dummy_mapping[MAX_DEVICES];
    byte dummy_desired[MAX_DEVICES];

    memset(dummy_desired, DONT_CARE, MAX_DEVICES);
    generate_drive_mappings(dummy_mapping, MAX_DEVICES, dummy_desired);
    show_drive_mappings(dummy_mapping, FALSE);
}

/*  setup_block_devices() sets the invalid flag for all block devices.  This
    forces media check to send back a media changed state the first time
    through--thus forcing the master systems DOS to ignore any cached data
*/
void setup_block_devices(void)
{
    register int i;

    for (i = 0; i < MAX_SLAVE_DEVICES; i++)
        devices[i].invalid = TRUE;
}

static void pascal reset_cntl_break(void)      // resetcbrk() with correct calling
{                                       // conventions
    resetcbrk();
}

static void get_slave_dos_version(void)
{
    slave_dos_version = DOS_VERSION(_osmajor, _osminor);

    if (slave_dos_version == DOS_VERSION(3, 30)) { // Check for Zenith DOS 3.30+
        union REGS regs;

        regs.x.ax = 0x3000;
        intdos(&regs, &regs);
        if (regs.h.bh == 5) slave_dos_version = DOS_VERSION(3, 31);
                                        // Pretend Zenith DOS 3.30+ is DOS 3.31
                                        // Zeniths OEM number is 5
    }
}

static void _cdecl do_restore_screen(void)
{
    static byte screen_restored = FALSE;

    if (screen_initialized && !screen_restored) {
        screen_restored = TRUE;
        restore_screen();
        if (final_msg)
            printf("\n%s", final_msg);
    }
}

void _cdecl do_init_screen(void)
{
    int len;
    char name_buff[70];

    if (!screen_initialized) {
        screen_initialized = TRUE;
        init_screen();
        cursor_off();
        fill_attr(coord(0, 0), boxsize(scr_rows, 80), ' ', SCROLL_COLOR);
        len = sprintf(name_buff, "%s %s", program_name, version);
        dispstr_attr(coord(0, (80 - len) / 2), name_buff, TITLE_COLOR);
        atexit(do_restore_screen);
    }
}

void add_serial(word address, byte bios_num)
{
    char port_name[20];
    int i;

    if (address < 0x200 || address >= 0x8000 || (address & 7)) {
        if (bios_num)
            sprintf(port_name, "(COM%d)", bios_num);
        else
            port_name[0] = '\0';
        warn_printf(invalid_serial_address, port_name, address);
        return;

    }
    for (i = 0; i < fx_num_ports; i++) {
        if (FxPortInfo[i].address == address)
            return;                         // This port already in table
    }
    if (fx_num_ports < MAX_PORTS) {
        FxPortInfo[fx_num_ports].type    = SERIAL_PORT;
        FxPortInfo[fx_num_ports].biosnum = bios_num;
        FxPortInfo[fx_num_ports].address = address;
        fx_num_ports++;
    }
}

void add_parallel(word address, byte bios_num)
{
    char port_name[20];
    int i;

    if (address < 0x200 || address >= 0x8000 || (address & 3)) {
        if (bios_num)
            sprintf(port_name, "(LPT%d)", bios_num);
        else
            port_name[0] = '\0';
        if (address > 3)            // Don't grouse about LAN redirector
            warn_printf(invalid_parallel_address, port_name, address);
        return;

    }
    for (i = 0; i < fx_num_ports; i++) {
        if (FxPortInfo[i].address == address)
            return;                         // This port already in table
    }
    if (fx_num_ports < MAX_PORTS) {
        FxPortInfo[fx_num_ports].type    = PARALLEL_PORT;
        FxPortInfo[fx_num_ports].biosnum = bios_num;
        FxPortInfo[fx_num_ports].address = address;
        fx_num_ports++;
    }
}

void add_bios_parallel(byte bios_num)
{
    word address = Bios.parallel_address[bios_num - 1];

    if (address) {
        add_parallel(address, bios_num);
    }
}

void add_bios_serial(byte bios_num)
{
    word address = Bios.serial_address[bios_num - 1];

    if (address) {
        if (address == 0x3F8)
            bios_num = 1;
        else if (address == 0x2F8)
            bios_num = 2;
/***
        else if (address == 0x3E8)
            bios_num = 3;
        else if (address == 0x2E8)
            bios_num = 4;
**/
        add_serial(address, bios_num);
    }
}

void add_all_bios_serial(void)
{
    byte port;

    for (port = 0; port < Bios.num_serial; port++) {
        add_bios_serial( (byte) (port + 1) );
    }
}

void add_all_bios_parallel(void)
{
    byte port;

    for (port = 0; port < Bios.num_parallel; port++) {
        add_bios_parallel( (byte) (port + 1) );
    }
}

void cdecl fatal_printf(char *fmt, ...)
{
    va_list arg_ptr;
    static char msg_buff[256];

    va_start(arg_ptr, fmt);
    if (screen_initialized) {
        vsprintf(msg_buff, fmt, arg_ptr);
        final_msg = msg_buff;
    }
    else
        vprintf(fmt, arg_ptr);
    exit(1);
}

static void remove_server_drive(byte drive_index)
{
    byte *ptr;

    if (included_drives[drive_index]) {
        ptr = memchr(drive_priority, drive_index, num_drives);
        if (!ptr)
            fatal_printf("Fatal error #9\n");
        memmove(ptr, ptr + 1, drive_priority + sizeof(drive_priority) - 1 - ptr);
        num_drives--;
    }
}

static char *set_exclude(char *argp)
{
    excluding = TRUE;
    return argp;
}

static char *set_com(char *argp)
{
    int port_address;

    if (*argp == ':') argp++;
    if (*argp == '*') argp++;
    port_address = htoi(argp);
    if (port_address >= 1 && port_address <= 4)
        add_bios_serial( (byte) port_address);
    else if (*argp <= ' ')
        add_all_bios_serial();
    else
        add_serial(port_address, 0);
    while ( isxdigit(*argp) ) argp++;
    return argp;
}

static char *set_lpt(char *argp)
{
    int port_address;

    if (*argp == ':') argp++;
    if (*argp == '*') argp++;
    port_address = htoi(argp);
    if (port_address >= 1 && port_address <= 4)
        add_bios_parallel( (byte) port_address);
    else if (*argp <= ' ')
        add_all_bios_parallel();
    else
        add_parallel(port_address, 0);
    while ( isxdigit(*argp) ) argp++;
    return argp;
}

static char *set_baud(char *argp)
{
    long baud_value;

    if (*argp == ':') argp++;
    baud_value = atol(argp);
    if (baud_value == 115200L)
        FxSettings.max_serial_baud = BAUD_115200;
    else if (baud_value <= 57600L) {
        switch ( (unsigned) baud_value ) {
        case 57600:
            FxSettings.max_serial_baud = BAUD_57600;
            break;
        case 38400:
            FxSettings.max_serial_baud = BAUD_38400;
            break;
        case 19200:
            FxSettings.max_serial_baud = BAUD_19200;
            break;
        case 9600:
            FxSettings.max_serial_baud = BAUD_9600;
            break;
        default:
            fatal_printf(invalid_baud, baud_value);
            break;
        }
    }
    else
        fatal_printf(invalid_baud, baud_value);
    while ( isdigit(*argp) ) argp++;
    return argp;
}

static char *set_maxblock(char *argp)
{
    long maxblock_value;

    if (*argp == ':') argp++;
    maxblock_value = atol(argp);
    if (maxblock_value < 1L || maxblock_value > 0x8000L)
        fatal_printf(invalid_maxblock, maxblock_value);
    FxSettings.max_serial_block = (word) maxblock_value;
    fx_max_serial_block = (word) maxblock_value;
    while ( isdigit(*argp) ) argp++;
    return argp;
}

static char *set_mono(char *argp)
{
    force_mono = TRUE;
    return argp;
}

static char *set_variable(char *argp)
{
    fx_force_variable = TRUE;
    return argp;
}

void process_args(char *argp)
{
    byte drive_index;
    static struct {
        char *param;
        char * (*func)(char *);
    } arg_table[] = {
        { "X",          set_exclude },
        { "COM",        set_com     },
        { "LPT",        set_lpt     },
        { "BAUD",       set_baud    },
        { "RCOPY",      clone       },
        { "MAXBLOCK",   set_maxblock},
        { "B",          set_mono    },
        { "V",          set_variable},
        { 0,            0           }
    };
    int i;
    int len;
    char buff[256];
    char value;

    if ( strchr(argp, '?') ) {
        printf("%s", usage_str);
        exit(1);
    }
    while (*argp) {
        while (*argp && *argp != '/') {
            value = (byte) toupper(*argp);
            if ( value >= 'A' && value <= 'Z') {
                drive_index = (byte) (value - 'A');
                if (excluding) {
                    remove_server_drive(drive_index);
                    excluded_drives[drive_index] = 1;
                    included_drives[drive_index] = 0;
                }
                else {
                    if (!included_drives[drive_index]) {
                        drive_priority[num_drives] = drive_index;
                        num_drives++;
                        num_includes++;
                    }
                    excluded_drives[drive_index] = 0;
                    included_drives[drive_index] = 1;
                }
            }
            else if (value > ' ' && value != ':' && (value != '=' || !excluding) )
                fatal_printf(invalid_server_drive, value);
            argp++;
        }
        if (*argp == '\0')
            break;
        argp++;
        excluding = FALSE;
        for (i = 0; arg_table[i].param; i++) {
            len = pstrlen(arg_table[i].param);
            if ( (memicmp(argp, arg_table[i].param, len) == 0) &&
                  !isalpha(*(argp + len)) ) {
                argp = arg_table[i].func(argp + len);
                break;
            }
        }
        if (!arg_table[i].param) {
            len = sprintf(buff, unrecognized_option);
            while ( isalpha(*argp) ) {
                len += sprintf(buff + len, "%c", *argp);
                argp++;
            }
            strcpy(buff + len, "\n");
            fatal_printf("%s", buff);
        }
    }
}

void cdecl quit(void)
{
    /***
    * IMPORTANT NOTE:  This routine can be called from within the critical
    * error handler if the user requests an abort.  Therefore any routines
    * called here should limit themselves to the appropriate DOS calls
    * and not use very much stack space.
    ***/
    unhook_int2f();
    reset_cntl_break();
    FxExit();
}

int default_drive_ok(int drv)
{

    if ( is_il_drive(drv) )
        return FALSE;
    if ( slave_dos_version >= DOS_VERSION(3, 20) ) {
        union REGS regs;

        // Check for logical (phantom) drive assignments.
        regs.x.ax = 0x440E;                     // Get logical drive map
        regs.h.bl = (byte) drv + (byte) 1;      // Check this drive
        intdos(&regs, &regs);
        if (!regs.x.cflag) {
            if (regs.h.al != 0) {               // It has aliases
                // Show only the last driver letter used on the aliased drive
                return (byte) (drv + 1) == regs.h.al ? TRUE : FALSE;
            }
        }
    }
    else {
        if ( drv == 0 && num_server_floppies < 1 ||         // missing floppy
            drv == 1 && num_server_floppies < 2 ) {
            switch (devices[drv].media_descriptor) {
            case 0xF8:                      // Fixed Disk
            case 0xF0:                      // 3.5"  double sided, 18 sector
            case 0xF9:                      // 5.25" double sided, 15 sector
                                            // 3.5"  double sided   9 sector
            case 0xFC:                      // 5.25" single sided,  9 sector
            case 0xFD:                      // 5.25" double sided,  9 sector
            case 0xFE:                      // 5.25" single sided,  8 sector
            case 0xFF:                      // 5.25" double sided,  8 sector
                                            // RAM disk or floppy disk
                break;
            default:
                return FALSE;               // Missing floppy
            }
        }
    }
    return TRUE;
}

void _cdecl reset_disk(void)
{
    union REGS regs;

    regs.h.ah = 0x0d;                   // reset disk
    intdos(&regs, &regs);               // Write all DOS internal buffers.
}

static int _far _fastcall check_abort(word elapsed_ticks, byte status)
{
    int key;

    while ( check_key() ) {
        key = read_key();
        if (key == ALT_F4) {
            exit(0);
        }
    }
    return 0;
}

int _far _fastcall CheckAbort(word elapsed_ticks, byte status)
{
    int key;

    while (check_key()) {
        key = read_key();
        if (key == F3 || key == ALT_F4) {
            check_abort_flag = TRUE;
            return -1;
        }
    }
    return 0;
}

void cdecl main(int argc, char *argv[])
{
    int main_option = 1;
    int i;
    char *ptr;
    char arg_buff[256];
    int num_good_ports;
    extern byte scroll_messages;

    enter_critical();                   // Enter Windows 386 Enh Mode critical section
    atexit(leave_critical);
    make_server_id();
    FxQueryBios(&Bios);
    num_lpt  = Bios.num_parallel;
    for (i = 0; i < num_lpt; i++) {
        printers[i].address = Bios.parallel_address[i];
        printers[i].exported = TRUE;
        printers[i].enabled  = TRUE;
    }
    config.master_code = 0;             // Always force this to zero on startup
    if (ptr = getenv("INTERSVR"))
        strtcpy(arg_buff, ptr, sizeof(arg_buff));
    else
        arg_buff[0] = '\0';
    for (i = 1; i < argc; i++) {
        strcat(arg_buff, " ");
        strcat(arg_buff, argv[i]);
    }
                // will not return if invoked with ?

    check_drdos();
    get_slave_dos_version();            // Get dos version in WORD format

    FxSetCheckAbort(CheckAbort);
    process_args(arg_buff);
    if (fx_num_ports == 0) {
        add_all_bios_serial();
        add_all_bios_parallel();
        if (fx_num_ports == 0) {
            fatal_printf(no_ports_available_error);
        }
    }
    load_device_information();          // Get all the information about
                                        // the devices on this system
    (void) flushall();                  // Flush all I/O streams
    reset_disk();
    setup_block_devices();
    for (i = 0; i < num_drives; i++) {
        if (drive_priority[i] >= (byte) slave_block_devices)
            remove_server_drive(drive_priority[i]);
    }
    for (i = 0; i < 26; i++) {
        if ( i >= slave_block_devices &&
             (included_drives[i] || excluded_drives[i]) ) {
                    fatal_printf(invalid_server_drive, i + 'A');
        }
    }
    if (num_includes == 0) {    // No included drives, so use default & exclude
        for (i = 0; i < slave_block_devices; i++) {
            if ( !excluded_drives[i] && default_drive_ok(i) ) {
                drive_priority[num_drives] = (byte) i;
                num_drives++;
            }
        }
    }
    set_critical_error();               // Send critical errors to criterr()
    setcbrk();                          // Ignore Cntl-C/Cntl-Break
    FxInit();
    do_init_screen();                   //##################################
    hook_int2f();
    atexit(quit);
    atexit(reset_disk);
    num_good_ports = 0;
    for (i = 0; i < fx_num_ports; i++) {
        if (FxPortInfo[i].type == SERIAL_PORT && (FxPortInfo[i].flags & PF_BAD_PORT)) {
            warn_printf(port_init_error, port_name(i), FxPortInfo[i].address);
        }
        else
            num_good_ports++;
    }
    if (num_good_ports == 0)
        fatal_printf(no_ports_available_error);
    do_init_screen();
    if ( num_drives + num_lpt > scr_rows - 7) {
        display_left_col  = LEFT_MARGIN;
        display_rows = (byte) ((num_drives + num_lpt + 1) / 2);
        split_screen = TRUE;
    }
    else {
        display_rows = (byte)num_drives + (byte) num_lpt;
    }
    top_row = (scr_rows - (display_rows + 6)) / 2 + 1;
    if (win386_enh_mode || dos5_switcher || desqview)
        warn_printf(desqview ? desqview_msg : multitasking_msg);
    paint_main_screen();
    show_devices();
    FxSyncTimeout(2 * SYNC_ONE_SECOND);
    FxSetCheckAbort(check_abort);
    if (desqview)
        stop_desqview_multitasking();
    for (;;) {
        check_abort(0, 0);
        attempt_transaction();
    }
    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\longtoa.asm ===
;***
;* $Workfile:   find.asm  $
;* $Revision:   1.2  $
;*   $Author:   Dave Sewell  $
;*     $Date:   02 May 1990  8:45:38  $
;*
;* Routine to read a directory and place the resulting directory entries in
;* a buffer.
;*****************************************************************************

%               .MODEL memmodel, language

                .CODE

@long_to_ascii  PROC    USES DI SI
                PUBLIC  @long_to_ascii

; extern void _fastcall long_to_ascii(long value, char near *buff);
;
; _fastcall: DX:AX = value, BX = buff

                push    ds
                pop     es
                mov     di, bx      ;Point ES:DI to buffer
            	mov     bx, ax      ;DX:BX = value
            	mov     si, di      ;Save start of buffer
                mov     cx, 10      ;Get radix to CX

next_digit:     xchg    ax,dx       ;Divide hi
	            xor     dx,dx
	            div     cx          ;DX = rem, AX = hi div
                xchg    ax,bx       ;AX = lo,  BX = hi div
	            div     cx          ;DX = rem, BX:AX = div
	            xchg    ax,dx       ;AX = rem, BX:DX = div
	            xchg    dx,bx       ;AX = rem, DX:BX = div
	            add     al,'0'
	            stosb
	            mov     ax,dx
	            or      ax,bx
	            jnz     next_digit

            	mov     [di],al     ;Store trailing null

;       reverse digits

revloop:        dec     di          ; point back to last char
	            lodsb               ; exchange bytes
	            xchg    [di],al
	            mov     [si-1],al
; The following is equivalent to "cmp si,(di-1)"
; but avoids segment wrap in case DI == 0
	            lea	ax,[si+1]
	            cmp     ax,di       ; are we halfway?
	            jb	revloop         ;   no

                ret

@long_to_ascii  ENDP


            	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\setcerr.asm ===
;***
;* $Workfile:   setcerr.asm  $
;* $Revision:   1.1  $
;*   $Author:   Dave Sewell  $
;*     $Date:   27 Jun 1989 14:55:10  $
;***

PAGE 65, 132
;***
;* File:   setcerr.asm
;* Author: Dave Sewell
;*
;* Routine to set INT 24 critical error handler.
;***

%               .MODEL memmodel, language

                EXTRN    pascal criterr:PROC

                .CODE

critical_error  PROC    FAR

                push    bx              ;Save registers
                push    cx
                push    dx
                push    si
                push    di
                push    bp
                push    ds
                push    es

                push    ax              ;Preserve AH

                mov     bx, DGROUP
                mov     ds, bx

                push    ax              ;Push Device number & allowed action
                                        ;code
                mov     bx, di
                xor     bh, bh
                push    bx              ;Push error code

                push    bp              ;Push driver header segment
                push    si              ;Push driver header offset

                call    criterr         ;Returns Abort/Ignore/Fail code in AL

                pop     bx              ;restore AH
                mov     bh, ah

                pop     es              ;restore other registers
                pop     ds
                pop     bp
                pop     di
                pop     si
                pop     dx
                pop     cx
                pop     bx

                iret

critical_error  ENDP

;*
;* Calling sequence: set_critical_error();
;*      extern void set_critical_error(void);

set_critical_error  PROC    USES DS DI SI

                mov     dx, OFFSET critical_error
                push    cs
                pop     ds
                mov     ax, 2524H       ;Set INT 24 vector
                int     21H

                ret

set_critical_error  ENDP

                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\packets.h ===
/***
* $Workfile:   packets.h  $
* $Revision:   1.2  $
*   $Author:   Dave Sewell  $
*     $Date:   04 May 1990  9:18:30  $
***/

/*  packets.h : January 4, 1989 : Alan Butt

    This file contains the structure definitions for the packets used
    in the expansion box device drivers
*/

#define TEST_PACKET_REQ     0           // Data transfer test request
#define INIT_PACKET_REQ     1           // Initialization Information Request
#define MEDIA_CHECK_REQ     2           // Media Check Request
#define BUILD_BPB_REQ       3           // Build BPB Request
#define READ_REQ            4           // Read request
#define WRITE_REQ           5           // Write Request
#define WRITE_VER_REQ       6           // Write-Verify Request
#define ERROR_REQ           7           // Error packet type
#define AUX_INIT_REQ        8
#define AUX_READ_REQ        9           // Auxiliary driver read request
#define AUX_WRITE_REQ       10          // Auxiliary driver write request
#define AUX_WRITE_VER_REQ   11          // Auxiliary driver write verify request
#define ND_READ_REQ         12          // Non-Destructive read request
#define INPUT_STATUS_REQ    13          // Input status request
#define OUTPUT_STATUS_REQ   14          // Output status request
#define FLUSH_INPUT_REQ     15          // Flush Input request
#define FLUSH_OUTPUT_REQ    16          // Flush Output request
#define AUX_DEV_OPEN_REQ    17          // Auxiliary device open request
#define AUX_DEV_CLOSE_REQ   18          // Auxiliary device close request
#define AUX_IOCTL_READ_REQ  19          // Auxiliary device IOCTL READ request
#define AUX_IOCTL_WRITE_REQ 20          // Auxiliary device IOCTL WRITE request
#define OUTPUT_TIL_BUSY_REQ 21          // Output until busy request
#define DEV_OPEN_REQ        22          // Device Open request
#define DEV_CLOSE_REQ       23          // Device Close requset
#define REMOVABLE_MEDIA_REQ 24          // Removable media request

// NOTE: The BIOS print command code should be in the same numerical
// order as the INT 17H BIOS codes for easy conversion.

#define BIOS_PRINT_REQ      25          // Auxiliary BIOS print character
#define BIOS_INIT_REQ       26          // Auxiliary BIOS init printer
#define BIOS_STATUS_REQ     27          // Auxiliary BIOS get printer status
#define DRIVE_INFO_REQ      28          // Get drive info.
#define GEN_IOCTL_REQ       29          // Generic IOCTL
#define PACKET_TYPES        30          // Number of packet types

#define UNASSIGNED          0xFF
#define DONT_CARE           0xFE


struct init_packet_r {                  // Init packet request
    byte    packet_type;                // Packet type
    byte    ipr_major_version;          // Client program major version number
    byte    ipr_minor_version;          // Client program minor version number
    word    ipr_dos_version;            // Client DOS version number
    byte    ipr_max_devices;            // Maximum devices master can accept
    byte    ipr_first_unit;             // First drive letter on master
    // IMPORTANT NOTE: ipr_prn_map must immediately precede ipr_mapping because
    // a block move is used to load up the values.
    byte    ipr_prn_map[3];             // Requested printer mapping
    byte    ipr_mapping[MAX_DEVICES];   // Master's desired mappings
};

struct init_packet_a {                  // Init packet answer
    byte    ipa_major_version;          // Server program version
    byte    ipa_minor_version;          // Server program version
    word    ipa_dos_version;            // Server DOS version
    byte    ipa_devices;                // Number of logical devices on system
    // IMPORTANT NOTE: ipa_prn_map must immediately precede ipa_mapping because
    // a block move is used to copy the values.
    byte    ipa_prn_map[3];             // Actual mapping of printer ports
    byte    ipa_mapping[MAX_DEVICES];   // Mapping for driver mapping table
    word    ipa_attributes[MAX_DEVICES];// Attributes for block device drivers
    byte    ipa_multitasker;
};



struct media_check_r {                  // Media check request
    byte    packet_type;                // Packet type
    byte    mcr_unit;                   // Unit number with device driver
    byte    mcr_media_id;               // MS-DOSs notion of media id byte
};

struct media_check_a {                  // Media check answer
    word    mca_status;                 // Driver status word
    byte    mca_changed;                // Media Changed code
    byte    mca_volume[MAX_VOLUME];
    unsigned long mca_serial_number;
};



struct build_bpb_r {                    // Build BPB request
    byte    packet_type;                // Packet type
    byte    bbr_unit;                   // Unit Number within device driver;
    byte    bbr_media_id;               // MS-DOSs notion of the media id byte
};

struct build_bpb_a {                    // Build BPB answer
    word    bba_status;                 // Device driver status word
    struct  bios_parameter_block bba_bpb;
};


struct io_r {       // Read/Write/Write-Verify/IOCTL-Read/IOCTL-Write request
    byte    packet_type;                // Packet type
    byte    ior_unit;                   // Unit number within device driver
    byte    ior_media_id;               // MS-DOSs notion of the media ID Byte
    word    ior_requested;              // Bytes/Sectors requested
    word    ior_start;                  // Starting sector number
    dword   ior_huge_start;             // 32-bit starting sector number
};

struct io_a {       // Read/Write/Write-Verify/IOCTL-Read/IOCTL-Write answer
    word    ioa_status;                 // Device driver status word
    word    ioa_transfered;             // Bytes/Sectors transferred
    byte    ioa_volume[MAX_VOLUME];
    unsigned long ioa_serial_number;
};

struct error_r {                        // Error packet
    byte    packet_type;                // Packet type
    byte    err_block_dvr;              // True if block driver
    byte    err_unit;                   // Unit number or Id code
    byte    err_code;                   // Error code
    byte    err_data;                   // Additional information byte
};
                                  
struct ocrm_r {                         // Open/Close/Removable media requests
    byte    packet_type;                // Packet type
    byte    ocr_unit;                   // Unit number
};

struct ocrm_a {                         // Open/Close/removable media answers
    word    oca_status;                 // Device driver status word
};

struct gen_ioctl_r {
    byte    packet_type;
    byte    gir_unit;
    byte    gir_category;
    byte    gir_function;
};

struct gen_ioctl_a {
    word    gia_status;
};



struct bios_r {                         // Auxiliary BIOS request (INT 17H) requests
    byte    packet_type;                // Packet type
    byte    bsr_bios_port;              // Bios Port num + (first_printer << 4)
    byte    bsr_char;                   // Character to print
};

struct bios_a {                         // Auxiliary BIOS request (INT 17H) answers
    byte    bsa_status;                 // Return status
};

struct drive_info_r {
    byte    packet_type;                // Packet type
    byte    server_drive_num;           // 0 = A, 1 = B, etc.
};


struct drive_info_a {
    char    size[10];
    char    volume_label[12];
    byte    write_protected;
};

struct lpt_o_r {  // LPT driver Write/Write-Verify/IOCTL-Write request
    byte    packet_type;                // Packet type
    byte    lpt_id;                     // 0 = LPT1, 1 = LPT2, 2 = LPT3
    word    print_count;                // Number of bytes to print
    byte    print_data;                 // Data byte if print_count == 1
};

struct lpt_o_a {  // LPT driver Write/Write-Verify/IOCTL-Write answer
    word    lpt_status;                 // Device driver status word
    word    lpt_transferred;            // Number of bytes transferred
};

struct lpt_cmd_r {    // Output status/Output flush requests
    byte    packet_type;                // Packet type
    byte    lpt_id;                     // 0 = LPT1, 1 = LPT2, 2 = LPT3
};

struct lpt_cmd_a {    // Output status/Output flush answer
    word    lca_status;                 // Device driver status word
};

// Below are the definitions of the error codes for ERROR_REQ

#define ER_BAD_MEDIA    0               // Unusable media error
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\switcher.asm ===
;***
;* $Workfile:   switcher.asm  $
;* $Revision:   1.1  $
;*   $Author:   Dave Sewell  $
;*     $Date:   27 Jun 1989 14:55:26  $
;***


%               .MODEL  memmodel, language

                .DATA
                EXTRN   C dos5_switcher:BYTE
                EXTRN   _display_segment:WORD

savepwr_flag    db      0               ; Set non-zero if SAVEPWR.EXE installed
savepwr_status  db      0               ; Original SAVEPWR.EXE status

                .CODE


call_back_info  LABEL   BYTE

SCBI_Next       dd      0
SCBI_Entry_Pt   dd      client_call_out
SCBI_Reserved   dd      0
SCBI_API_Ptr    dd      0

ts_callout      dd      0

old_int2f       dd      ?

client_call_out PROC    FAR

                retf

client_call_out ENDP

int2f_handler   PROC    FAR

                cmp     ax, 4B01H
                jne     pass_thru

                pushf
                call    dword ptr cs:old_int2f
                mov     word ptr cs:SCBI_Next, bx
                mov     word ptr cs:SCBI_Next + 2, es
                mov     bx, OFFSET call_back_info
                push    cs
                pop     es

int2f_iret::    iret

pass_thru:      jmp     dword ptr cs:old_int2f


int2f_handler   ENDP

hook_int2f      PROC    

                push    ds
                push    di
                push    si
                push    bp

;--- Save the old INT 2FH handler address

                mov     ax, 352FH
                int     21H
                mov     ax, es
                or      ax, bx
                jnz     save_old_int2f

                mov     bx, OFFSET int2f_iret
                push    cs
                pop     es

save_old_int2f: mov     WORD PTR cs:old_int2f, bx
                mov     WORD PTR cs:old_int2f + 2, es

;--- Insert our handler into the chain

                mov     ax, 252FH
                mov     dx, OFFSET int2f_handler
                push    cs
                pop     ds
                int     21H

; --- Use the Detect Switcher call to see if a task switcher is running

                mov     ax, 4B02H
                xor     bx, bx
                xor     di, di
                mov     es, di
                int     2FH
                mov     ax, es
                or      ax, di
                jz      hook_done       ; No task switcher loaded

                push    ds
                mov     ax, DGROUP
                mov     ds, ax
                mov     dos5_switcher, 1
                pop     ds
                mov     word ptr cs:ts_callout, di
                mov     word ptr cs:ts_callout + 2, es
                push    cs              ; Push return segment
                mov     ax, OFFSET hook_done
                push    ax              ; Push return offset
                push    es
                push    di
                mov     ax, 4
                mov     di, OFFSET call_back_info
                push    cs
                pop     es
                retf                    ; Simulate far call

hook_done:      mov     ax, DGROUP
                mov     ds, ax          ; Restore DS

; --- Now check for presence of SAVEPWR.EXE device driver ---

                mov     ax, 5400H
                xor     bx, bx
                int     2FH
                cmp     bx, "PM"
                jne     hook_ret

                inc     savepwr_flag
                mov     ax, 5401H
                mov     bx, 0100H
                int     2FH
                mov     savepwr_status, bh

hook_ret:       pop     bp
                pop     si
                pop     di
                pop     ds
                ret

hook_int2f      ENDP

unhook_int2f    PROC    NEAR


                push    ds
                push    di
                push    si
                push    bp
                cmp     savepwr_flag, 0
                je      @F

                mov     ax, 5401H
                mov     bh, 1
                mov     bl, savepwr_status
                int     2FH

@@:             mov     ax, word ptr cs:ts_callout
                or      ax, word ptr cs:ts_callout + 2
                jz      restore_int2f

                mov     ax, 5           ; Unhook call-out
                mov     di, OFFSET call_back_info
                push    cs
                pop     es
                call    dword ptr cs:ts_callout

restore_int2f:  mov     ax, 252FH
                lds     dx, cs:old_int2f
                int     21H
                pop     bp
                pop     si
                pop     di
                pop     ds
                ret

unhook_int2f    ENDP

                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\str.h ===
extern char parallel_turbo[];
extern char parallel_normal[];
extern char press_enter_to_return[];
extern char sending_bootstrap[];
extern char open_error_msg[];
extern char read_error_msg[];
extern char sending_prefix[];
extern char install_status_line1[];
extern char install_status_line2[];
extern char null_str[];
extern char connection_lost[];
extern char unrecoverable_errors[];
extern char new_line_str[];
extern char insufficient_space[];
extern char upload_transfer_error[];
extern char upload_share_problem[];
extern char upload_write_error[];
extern char dir_full[];
extern char error_counts[];
extern char waiting_message[];
extern char install_signon[];
extern char transfer_cancelled_warning[];
extern char connection_termination_error[];
extern char upload_full[];
extern char upload_unable_to_communicate[];
extern char upload_cancelled[];
extern char allocation_error[];
extern char bad_port_list[];
extern char no_serial_ports[];
extern char copyright[];
extern int const copyright_len;
extern char upload_remote_prompt[];
extern char product_signon[];
extern char receiving_prefix[];
extern char clone_write_error[];
extern char clone_create_error[];

extern char invalid_server_drive[];
extern char status_line[];
extern char invalid_serial_address[];
extern char invalid_parallel_address[];
extern char port_init_error[];
extern char invalid_baud[];
extern char invalid_maxblock[];
extern char unrecognized_option[];
extern char box_header1[];
extern char box_header2[];
extern char not_connected[];
extern char bad_image_of_FAT[];
extern char write_protect_error[];
extern char unknown_unit_error[];
extern char drive_not_ready_error[];
extern char unknown_command_error[];
extern char data_error[];
extern char bad_request_struct[];
extern char seek_error[];
extern char unknown_media_type[];
extern char sector_not_found[];
extern char printer_out_of_paper[];
extern char write_fault[];
extern char read_fault[];
extern char general_failure[];
extern char invalid_disk_change[];
extern char writing_to_drive[];
extern char reading_from_drive[];
extern char warn_different_version_nums[];
extern char cannot_run_under_desqview[];
extern char reading[];
extern char writing[];
extern char printing[];
extern char idle[];
extern char unknown_error[];
extern char clone_title[];
extern char no_ports_available_error[];
extern char no_serial_ports_available_error[];
extern char abort_or_retry[];
extern char program_name[];
extern char write_length_error[];
extern char usage_str[];
extern char upload_copying_msg[];
extern char press_enter_to_continue[];
extern char variable_serial_speed[];
extern char multitasking_msg[];
extern char loading_bootstrap_msg[];
extern char desqview_msg[];
extern char equals_msg[];
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\userform.h ===
/***
* $Workfile:   userform.h  $
* $Revision:   1.0  $
*   $Author:   Dave Sewell  $
*     $Date:   28 Apr 1989 17:37:22  $
***/

/* external declaration of forms character table */
extern char _formChars[];

/* Forms Character Macros */
#define F_H1	 0xC4
#define F_H2	 0xCD
#define F_V1	 0xB3
#define F_V2	 0xBA

#define F_UL1	 0xDA
#define F_UR1	 0xBF
#define F_LL1	 0xC0
#define F_LR1	 0xD9

#define F_UL2	 0xC9
#define F_UR2	 0xBB
#define F_LL2	 0xC8
#define F_LR2	 0xBC

#define F_UT1	 0xC1
#define F_DT1	 0xC2
#define F_LT1	 0xB4
#define F_RT1	 0xC3

#define F_UT12	 0xD0
#define F_DT12	 0xD2
#define F_LT12	 0xB5
#define F_RT12	 0xC6

#define F_UT21	 0xCF
#define F_DT21	 0xD1
#define F_LT21	 0xB6
#define F_RT21	 0xC7

#define F_UT2	 0xCA
#define F_DT2	 0xCB
#define F_LT2	 0xB9
#define F_RT2	 0xCC

#define F_UL12	 0xD6
#define F_UR12	 0xB7
#define F_LL12	 0xD3
#define F_LR12	 0xBD

#define F_UL21	 0xD5
#define F_UR21	 0xB8
#define F_LL21	 0xD4
#define F_LR21	 0xBE

#define F_X1	 0xC5
#define F_X12	 0xD7
#define F_X21	 0xD8
#define F_X2	 0xCE

#define F_UP	 0x1E
#define F_DOWN	 0x1F
#define F_LEFT	 0x11
#define F_RIGHT  0x10

#define F_BG	 0xB0
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\driver\core.asm ===
;***
;* $Workfile:   core.asm  $
;* $Revision:   1.5  $
;*   $Author:   Dave Sewell  $
;*     $Date:   08 Aug 1989 16:44:52  $
;***

                INCLUDE drivers.mac
                INCLUDE packets.mac
                INCLUDE debug.mac

DRIVER_ATTRIB   = ATT_BLOCK     ; Device driver type
LPT_ATTRIB      = ATT_CHARACTER OR ATT_OCRM

PARALLEL        SEGMENT WORD PUBLIC 'CODE'
                EXTRN   send_pack_parallel:NEAR
                EXTRN   recv_pack_parallel:NEAR
                EXTRN   send_sync_parallel:NEAR
                EXTRN   save_parallel:NEAR
                EXTRN   restore_parallel:NEAR
                EXTRN   timer_passthru_par:FAR
                EXTRN   ss_timeout:NEAR
                EXTRN   ssp1:NEAR
                EXTRN   ssp2:NEAR
                EXTRN   ssp3:NEAR
                EXTRN   sw_timeout:NEAR
                EXTRN   swp1:NEAR
                EXTRN   swp2:NEAR
                EXTRN   sp_timeout:NEAR
                EXTRN   spp2:NEAR
                EXTRN   spp3:NEAR
                EXTRN   spp4:NEAR
                EXTRN   spn_timeout:NEAR
                EXTRN   spn2:NEAR
                EXTRN   spn3:NEAR
                EXTRN   spn4:NEAR
                EXTRN   rw_timeout:NEAR
                EXTRN   rwp1:NEAR
                EXTRN   rwp2:NEAR
                EXTRN   rp_timeout:NEAR
                EXTRN   rpp1:NEAR
                EXTRN   rpp2:NEAR
                EXTRN   rpp3:NEAR
                EXTRN   rpn_timeout:NEAR
                EXTRN   rpn1:NEAR
                EXTRN   rpn2:NEAR
                EXTRN   rpn3:NEAR
                EXTRN   wsa1:NEAR
                EXTRN   wsa_timeout:NEAR
PARALLEL        ENDS

SERIAL          SEGMENT WORD PUBLIC 'CODE'
                EXTRN   send_pack_serial:NEAR
                EXTRN   recv_pack_serial:NEAR
                EXTRN   send_sync_serial:NEAR
                EXTRN   init_port_serial:NEAR
                EXTRN   reset_port_serial:NEAR
SERIAL          ENDS

BLOCK           SEGMENT WORD PUBLIC 'CODE'
                EXTRN   intr:FAR
                EXTRN   unmapped_unit:WORD
                EXTRN   units:BYTE
BLOCK           ENDS

CORE            SEGMENT WORD PUBLIC 'CODE'
                PUBLIC  start_packet
                PUBLIC  end_packet
                PUBLIC  header
                PUBLIC  lpt3_header
                PUBLIC  lpt2_header
                PUBLIC  lpt1_header
                PUBLIC  finger_print
                PUBLIC  major_version
                PUBLIC  minor_version
                PUBLIC  strat_seg
                PUBLIC  intr1_seg
                PUBLIC  intr2_seg
                PUBLIC  intr3_off
                PUBLIC  intr3_seg
                PUBLIC  intr0_seg
                PUBLIC  intr_error
                PUBLIC  device_id
                PUBLIC  header_seg
                PUBLIC  driver_id
                PUBLIC  end_low_stub
                PUBLIC  end_core_data
                PUBLIC  driver_call
                PUBLIC  send_pack
                PUBLIC  recv_pack
                PUBLIC  send_sync
                PUBLIC  get_remote_info
        IFDEF DEBUG
                PUBLIC  debug_msg
                PUBLIC  hex_out
        ENDIF
                PUBLIC  client_id
                PUBLIC  crc_errors
                PUBLIC  seq_num
                PUBLIC  busy_semaphore
                PUBLIC  idle_semaphore
                PUBLIC  port_address
                PUBLIC  port_index
                PUBLIC  bios_port_num
                PUBLIC  max_baud
                PUBLIC  client_max_baud
                PUBLIC  max_serial_block
                PUBLIC  is_serial
                PUBLIC  int2f_ok
                PUBLIC  old_int2f_vec
                PUBLIC  old_int25_vec
                PUBLIC  old_int26_vec
                PUBLIC  C int2f_handler
                PUBLIC  C int25_handler
                PUBLIC  C int26_handler
                PUBLIC  win386_enh_mode
                PUBLIC  win386_std_mode
                PUBLIC  Virt_Dev_File
                PUBLIC  Win386_Startup_Info
                PUBLIC  win_386_api_ok
                PUBLIC  win_386_api
                PUBLIC  crctab
                PUBLIC  rhptr
                PUBLIC  dos_version
                PUBLIC  dos_major
                PUBLIC  dos_minor
                PUBLIC  slave_dos_version
                PUBLIC  slave_dos_minor
                PUBLIC  slave_dos_major
                PUBLIC  server_major
                PUBLIC  server_minor
                PUBLIC  packet_buf
                PUBLIC  num_ports
                PUBLIC  num_ser_ports
                PUBLIC  num_par_ports
                PUBLIC  serial_ports
                PUBLIC  parallel_ports
                PUBLIC  default_units
                PUBLIC  first_unit
                PUBLIC  printer_loaded
                PUBLIC  actual_prn_map
                PUBLIC  slave_units
                PUBLIC  initialized
                PUBLIC  drive_mapping
                PUBLIC  default_mapping
                PUBLIC  invalid
                PUBLIC  dd_attributes
                PUBLIC  save_area
                PUBLIC  timeout
                PUBLIC  code_list_ptr
                PUBLIC  code_save
                PUBLIC  ticks_remaining
                PUBLIC  set_alarm_time
                PUBLIC  alarm_vector
                PUBLIC  par_timer_save
                PUBLIC  send_sync_list
                PUBLIC  send_word_list
                PUBLIC  send_pack_list2
                PUBLIC  sp_normal_list
                PUBLIC  recv_word_list
                PUBLIC  recv_pack_list
                PUBLIC  rp_normal_list
                PUBLIC  wait_send_list
                PUBLIC  timer_jmp
                PUBLIC  par_fixup_start
                PUBLIC  par_fixup_end
                PUBLIC  request        
                PUBLIC  port           
                PUBLIC  old_int17
                PUBLIC  device_high
                PUBLIC  init_size
                PUBLIC  low_memory
                PUBLIC  driver_size
                PUBLIC  num_lpt
                PUBLIC  num_com
                PUBLIC  display_scan
                PUBLIC  fx_force_variable

                ORG     0       ; The First device header must be at loc 0!

lpt3_header     device_header <DVR:lpt2_header, -1, LPT_ATTRIB, DVR:strat_jmp, DVR:intr3_jmp, 'LPT3    '>
lpt2_header     device_header <DVR:lpt1_header, -1, LPT_ATTRIB, DVR:strat_jmp, DVR:intr2_jmp, 'LPT2    '>
lpt1_header     device_header <DVR:header,      -1, LPT_ATTRIB, DVR:strat_jmp, DVR:intr1_jmp, 'LPT1    '>
header          device_header <-1, -1, DRIVER_ATTRIB, DVR:strat_jmp, DVR:intr0_jmp, 'C'>
                                        ; Device header

finger_print    db      'INTERLNK'
major_version   db      MAJOR_VER
minor_version   db      MINOR_VER

strat_jmp       LABEL   NEAR

                jmp     far ptr strat

strat_seg       EQU     WORD PTR strat_jmp + 3

intr1_jmp       LABEL   NEAR

                push    ax
                mov     al, 1
                jmp     far ptr intr

intr1_seg       EQU     WORD PTR $ - 2

intr2_jmp       LABEL   NEAR

                push    ax
                mov     al, 2
                jmp     far ptr intr

intr2_seg       EQU     WORD PTR $ - 2

intr3_jmp       LABEL   NEAR

                push    ax
                mov     al, 3
                jmp     far ptr intr

intr3_off       EQU     WORD PTR $ - 4
intr3_seg       EQU     WORD PTR $ - 2

intr0_jmp       LABEL   NEAR

                push    ax
                mov     al, 0
                jmp     far ptr intr

intr0_seg       EQU     WORD PTR $ - 2

end_low_stub    LABEL   NEAR

                EVEN

;NOTE: port_address gets set to zero if send_pack or recv_pack fails.
;This indicates that the connection has been lost and that send_sync must
;be called again to re-establish the connection before calling send_pack
;or recv_pack again.

port_address    dw      0       ; Set to address of serial or parallel port

; initialized   This value is non-zero if the init_packet sequence has been
;               successfully completed (get_remote_info).
;
initialized     db      0                   ; Driver currently Initialized flag

device_id       db      0                   ; 0 = block, 1 - 3 = LPT1 - LPT3
header_seg      dw      0

driver_id       db      1                   ; Logical Interlnk driver number

is_serial       db      0
send_pack       DW      DVR:error_proc
recv_pack       DW      DVR:error_proc

driver_call     DW      DVR:far_call
                DW      ?                   ; Must be updated with correct CS

send_sync       DW      DVR:send_sync_proc
get_remote_info DW      DVR:gri_proc
start_packet    DW      DVR:start_vxd
end_packet      DW      DVR:end_vxd

IFDEF DEBUG
debug_msg       DW      DVR:debug_msg_proc
hex_out         DW      DVR:hex_out_proc
ENDIF

;NOTE: the two DWORDs below must be in this order so that they can be moved
;into the SERVER_INFO_REQ packet with a block move, and compared against the
;SERVER_INFO_ANS packet with a block compare.

client_id       dd      0
last_server_id  dd      0

; crc_errors    This is the number of CRC errors that have been detected
;               since the driver was installed.  This value is maintained
;               by the protocol routines and is for informational purposes
;               only.
;
crc_errors      dw  0                   ; Number of CRC errors recieved

; busy_semaphore    This byte is non-zero if communications are currently in
;                   progress.  All auxiliary drivers, TSRs as well as the main
;                   driver update this byte when they start and end a com-
;                   munication session.  If the semaphore is set, then somebody
;                   else is using the port.  It is mandatory that this byte be
;                   checked and updated in a non-interruptable manner (either
;                   by using sti/cli or xchg/test).
;
busy_semaphore  db      0

idle_semaphore  db      0       ; Set non-zero if background idling is OK

port_index      dw      0       ; Indexes into serial_ports or parallel_ports

bios_port_num   db      0       ; 0 if not BIOS, 1 - 4 for COM1 - 4, LPT1 - 4

max_baud        db      BAUD_115200     ; Maximum actual baud rate
client_max_baud db      BAUD_115200     ; Maximum desired baud rate
max_serial_block    dw  MAX_SERIAL_BLOCK

win386_enh_mode db      0
win386_std_mode db      0
int2f_ok        db      0
old_int2f_vec   dd      0
old_int25_vec   dd      0
old_int26_vec   dd      0
win_386_api_ok  db      0
win_386_api     dd      ?

Virt_Dev_File   db      67 DUP (0)

Win386_Startup_Info Win386_Startup_Info_Struc <>

; default_units Number of units to be installed
;
default_units   db  3                   ; Default max number of devices

; first_unit    This is the actual drive number (0=A:, 1=B:, etc.) of the first
;               drive supported by this driver.
;
first_unit      db  ?                   ; First drive number

printer_loaded  db  1                   ; 0 if printer code not loaded

; slave_units   This is the number of logical block devices available on the
;               slave system.
;
slave_units     db      ?               ; Number of Block devices on slave


;-----------------------------------------------------------------------------
;--- IMPORTANT NOTE: actual_prn_map must immediately precede drive_mapping,
;--- because a block move is used to copy values in and out of the init packet
actual_prn_map  db  3 dup (DONT_CARE)
; drive_mapping This array is the drive mapping translation table.  This array
;               is addressed by the unit number in the RHP.  The contents of
;               the location is the actual unit number on the slave device.
;               The most significant bit of the value is the write protect bit.
;               If the bit is set, write operations are not allowed.  If it is
;               clear, write operations are allowed.  The lower 7 bits are the
;               actual unit number on the slave devices.
;
drive_mapping   LABEL   BYTE            ; Drive mapping translation table
        db      MAX_DEVICES DUP(DONT_CARE)

default_mapping db      MAX_DEVICES DUP(DONT_CARE)
;-----------------------------------------------------------------------------

; invalid   This array (like the drive_mapping array) is addressed by the unit
;           number in the RHP.  In general if invalid[unit] is non-zero,    
;           the BPB for the unit must be updated.
;               In media_check, if invalid[unit] is set, the media_check
;           will be forced to return MEDIA_CHANGED.  The on-line drive mapping
;           sets this value.  This forces DOS to rebuild the BPB for the device
;           the next time it is accessed.
;
invalid         db  MAX_DEVICES DUP (0FFH)  ; Rebuild-BPB flags

                db      90H                 ;$$$

; dd_attributes are the device driver attributes for each logical device on
; the slave system.  This array is addressed by the mapped unit number (the
; device number on the slave system)--NOT the unit number in the RHP
;
dd_attributes   dw      MAX_DEVICES DUP (0)


crctab  DW 00000H, 01021H, 02042H, 03063H, 04084H, 050a5H, 060c6H, 070e7H
        DW 08108H, 09129H, 0a14aH, 0b16bH, 0c18cH, 0d1adH, 0e1ceH, 0f1efH
        DW 01231H, 00210H, 03273H, 02252H, 052b5H, 04294H, 072f7H, 062d6H
        DW 09339H, 08318H, 0b37bH, 0a35aH, 0d3bdH, 0c39cH, 0f3ffH, 0e3deH
        DW 02462H, 03443H, 00420H, 01401H, 064e6H, 074c7H, 044a4H, 05485H
        DW 0a56aH, 0b54bH, 08528H, 09509H, 0e5eeH, 0f5cfH, 0c5acH, 0d58dH
        DW 03653H, 02672H, 01611H, 00630H, 076d7H, 066f6H, 05695H, 046b4H
        DW 0b75bH, 0a77aH, 09719H, 08738H, 0f7dfH, 0e7feH, 0d79dH, 0c7bcH
        DW 048c4H, 058e5H, 06886H, 078a7H, 00840H, 01861H, 02802H, 03823H
        DW 0c9ccH, 0d9edH, 0e98eH, 0f9afH, 08948H, 09969H, 0a90aH, 0b92bH
        DW 05af5H, 04ad4H, 07ab7H, 06a96H, 01a71H, 00a50H, 03a33H, 02a12H
        DW 0dbfdH, 0cbdcH, 0fbbfH, 0eb9eH, 09b79H, 08b58H, 0bb3bH, 0ab1aH
        DW 06ca6H, 07c87H, 04ce4H, 05cc5H, 02c22H, 03c03H, 00c60H, 01c41H
        DW 0edaeH, 0fd8fH, 0cdecH, 0ddcdH, 0ad2aH, 0bd0bH, 08d68H, 09d49H
        DW 07e97H, 06eb6H, 05ed5H, 04ef4H, 03e13H, 02e32H, 01e51H, 00e70H
        DW 0ff9fH, 0efbeH, 0dfddH, 0cffcH, 0bf1bH, 0af3aH, 09f59H, 08f78H
        DW 09188H, 081a9H, 0b1caH, 0a1ebH, 0d10cH, 0c12dH, 0f14eH, 0e16fH
        DW 01080H, 000a1H, 030c2H, 020e3H, 05004H, 04025H, 07046H, 06067H
        DW 083b9H, 09398H, 0a3fbH, 0b3daH, 0c33dH, 0d31cH, 0e37fH, 0f35eH
        DW 002b1H, 01290H, 022f3H, 032d2H, 04235H, 05214H, 06277H, 07256H
        DW 0b5eaH, 0a5cbH, 095a8H, 08589H, 0f56eH, 0e54fH, 0d52cH, 0c50dH
        DW 034e2H, 024c3H, 014a0H, 00481H, 07466H, 06447H, 05424H, 04405H
        DW 0a7dbH, 0b7faH, 08799H, 097b8H, 0e75fH, 0f77eH, 0c71dH, 0d73cH
        DW 026d3H, 036f2H, 00691H, 016b0H, 06657H, 07676H, 04615H, 05634H
        DW 0d94cH, 0c96dH, 0f90eH, 0e92fH, 099c8H, 089e9H, 0b98aH, 0a9abH
        DW 05844H, 04865H, 07806H, 06827H, 018c0H, 008e1H, 03882H, 028a3H
        DW 0cb7dH, 0db5cH, 0eb3fH, 0fb1eH, 08bf9H, 09bd8H, 0abbbH, 0bb9aH
        DW 04a75H, 05a54H, 06a37H, 07a16H, 00af1H, 01ad0H, 02ab3H, 03a92H
        DW 0fd2eH, 0ed0fH, 0dd6cH, 0cd4dH, 0bdaaH, 0ad8bH, 09de8H, 08dc9H
        DW 07c26H, 06c07H, 05c64H, 04c45H, 03ca2H, 02c83H, 01ce0H, 00cc1H
        DW 0ef1fH, 0ff3eH, 0cf5dH, 0df7cH, 0af9bH, 0bfbaH, 08fd9H, 09ff8H
        DW 06e17H, 07e36H, 04e55H, 05e74H, 02e93H, 03eb2H, 00ed1H, 01ef0H

rhptr           dd      ?               ; Pointer to request header, passed
                                        ; by MS-DOS kernal to Strategy routine

dos_version     LABEL   WORD            ; DOS's version number in WORD format
dos_minor       db      ?               ; DOS's minor version number
dos_major       db      ?               ; DOS's major version number

slave_dos_version   LABEL   WORD        ; DOS version of slave in WORD format
slave_dos_minor db      ?               ; DOS minor number of slave
slave_dos_major db      ?               ; DOS major number of slave

server_major    db      ?               ; Server major version number
server_minor    db      ?               ; Server minor version number

server_multitasker  db  ?

seq_num         db      ?
num_ports       db      0
num_ser_ports   db      0
num_par_ports   db      0

serial_ports    db      TYPE SERIAL_PORT_DEF * MAX_SERIAL_PORTS DUP (?)
parallel_ports  db      TYPE PARALLEL_PORT_DEF * MAX_PARALLEL_PORTS DUP (?)

save_area       db      5 DUP (?)       ; Save area for port state info

timeout         db      0
code_list_ptr   dw      ?
code_save       dw      (2 + MAX_FIXUPS) dup (?)
ticks_remaining dw      ?               ; Number of ticks until timeout occurs
alarm_vector    dw      ?
set_alarm_time  dw      ?
bios_tab_ptr    dw      ?
bios_port_save  dw      ?

                EVEN

par_timer_save  dd      0               ; Old timer vector


;--- The serial_id byte must immediately precede the serial jump vectors ---

                db      ?
serial_id       db      1               ; Gets copied into is_serial

;========================= Offsets into serial segment ====================
;=================== Must be fixed up if serial code moved ================

send_pack_svec      DW      DVR:send_pack_serial
recv_pack_svec      DW      DVR:recv_pack_serial

;--- The parallel_id byte must immediately precede the parallel jump vectors ---

                db      ?
parallel_id     db      0               ; Gets copied into is_serial

par_fixup_start     LABEL   WORD
;========================= Offsets into parallel segment ====================
;=================== Must be fixed up if parallel code moved ================

send_pack_pvec      DW      DVR:send_pack_parallel
recv_pack_pvec      DW      DVR:recv_pack_parallel
send_sync_pvec      DW      DVR:send_sync_parallel

save_par_vec    DW      DVR:save_parallel
restore_par_vec DW      DVR:restore_parallel

;******************************************************************************
;* IMPORTANT NOTE:  There must not be more than MAX_FIXUPS entries in any of
;* the lists below (not counting the initial fail address and trailing null).
;*
;* Also, each jump must be within short jump distance (128 bytes) of the fail
;* address, or of the the next jump that follows it.
;******************************************************************************
send_sync_list  dw      DVR:ss_timeout, DVR:ssp1, DVR:ssp2, DVR:ssp3, 0
send_word_list  dw      DVR:sw_timeout, DVR:swp1, DVR:swp2, 0
send_pack_list2 dw      DVR:sp_timeout, DVR:spp2, DVR:spp3, DVR:spp4, 0
sp_normal_list  dw      DVR:spn_timeout, DVR:spn2, DVR:spn3, DVR:spn4, 0
recv_word_list  dw      DVR:rw_timeout, DVR:rwp1, DVR:rwp2, 0
recv_pack_list  dw      DVR:rp_timeout, DVR:rpp1, DVR:rpp2, DVR:rpp3, 0
rp_normal_list  dw      DVR:rpn_timeout, DVR:rpn1, DVR:rpn2, DVR:rpn3, 0
wait_send_list  dw      DVR:wsa_timeout, DVR:wsa1, 0

par_fixup_end       LABEL   WORD

timer_jmp       dw      ?
;----------------------------------------------------------------------------

;--- Data for printer code -------------------------------------------------

request         dw      ?               ; request (save area for al)
port            db      ?               ; port number

old_int17       dd      ?               ; Old interrupt 17H vector
;----------------------------------------------------------------------------

device_high     db      0               ; Set to 1 if DEVICEHIGH was used
init_size       dw      ?               ; Size to tell INIT
low_memory      db      1               ; TRUE if loaded in low memory
driver_size     dw      ?               ; Device driver size in bytes
num_com         db      ?
num_lpt         db      ?
display_scan    db      0
fx_force_variable   db  0

packet_buf      db      MAX_PACKET DUP (?)  ; buffer for packets

end_core_data   LABEL   BYTE

                PUBLIC  strat
strat           PROC    FAR             ; device driver "Strategy" routine
                                        ; called from MS-DOS driver with
                                        ; ES:BX = address of request header
                mov     WORD PTR cs:rhptr, bx
                mov     WORD PTR cs:rhptr + 2, es
                ret                     ; Save pointer and return to MS-DOS

strat           ENDP

intr_error      PROC    FAR

                push    es
                push    bx
                les     bx, cs:rhptr
                mov     es:[bx].static_rhp.rhp_status, STATUS_ERROR OR STATUS_DONE OR \
                                            ERR_UNK_COMMAND
                pop     bx
                pop     es
                ret

intr_error      ENDP

far_call        PROC    FAR

                call    ax
                ret

far_call        ENDP

port_num        db      90H

error_proc      LABEL   NEAR

                stc                     ; Indicate error

null_proc       LABEL   NEAR

                ret

show_dot        PROC    NEAR

                cmp     display_scan, 0
                je      show_dot_ret

                push    ax
                push    dx
                mov     dl, '.'
                mov     ah, 2
                int     21H
                pop     dx
                pop     ax

show_dot_ret:   ret

show_dot        ENDP

start_vxd       PROC    NEAR

                pushf
                cmp     win_386_api_ok, 0
                je      start_done

                push    ax
                mov     ax, SET_VMSTAT_HIGH_PRI_BACK
                call    dword ptr win_386_api
                pop     ax

start_done:     popf
                ret

start_vxd       ENDP

end_vxd         PROC    NEAR

                pushf
                cmp     win_386_api_ok, 0
                je      done

                push    ax
                mov     ax, RESET_VMSTAT_HIGH_PRI_BACK
                call    dword ptr win_386_api
                pop     ax

done:           popf
                ret

end_vxd         ENDP

zero_bios_table PROC    NEAR

                mov     bios_tab_ptr, 0FFFFH
                cmp     port_address, 0
                je      zero_done

                cld
                mov     ax, 40H
                mov     es, ax
                mov     ax, port_address
                mov     bios_port_save, ax
                mov     cx, 4
                xor     di, di
                cmp     is_serial, 0
                jne     scan_table

                mov     cx, 3
                mov     di, 8

scan_table:     repne   scasw
                jne     zero_done

                sub     di, 2
                mov     bios_tab_ptr, di
                mov     word ptr es:[di], 0

zero_done:      ret

zero_bios_table ENDP


;************************************************************************
;* Interlnk 2FH interface:
;*
;* Input:
;*      AH = 56H (for all functions)
;*      AL = function number
;*           (0 = install check, 1 = drive check, 2 = port address check)
;*      BL = logical Interlnk driver number (0 = any, 1 = 1st, 2 = 2nd, etc.)
;*      BH = drive number (subfunction 1 only, 0 = drive A, 1 = B, etc.)
;*      CX = port address (used only for subfunction 2)
;*      DX = FFFF
;* Return values:
;*      AL = FF on success, 0 on failure (or unchanged if no responding driver)
;*      BL = logical Interlnk driver number of responding driver
;*      CL = major version number of responding Interlnk driver
;*      CH = minor version number of responding Interlnk driver
;*      DX = segment address of responding Interlnk driver
;************************************************************************

int2f_handler   PROC    FAR

                cmp     ah, INTERLNK_MULTIPLEX_ID
                jne     check_win

                cmp     dx, 0FFFFH
                jne     int2f_done

                cmp     bl, 0
                je      check_function

                cmp     bl, cs:driver_id
                jne     int2f_done

check_function: cmp     al, 0
                je      ok

                cmp     al, 1              ; Check drive letter
                je      check_drive

                cmp     al, 2
                jne     int2f_done

                cmp     cx, cs:port_address
                jne     fail

                jmp     ok

check_drive:    cmp     bh, 25
                ja      int2f_done          ; Pass on if bad drive number

                cmp     bh, cs:first_unit
                jb      fail

                push    ax
                mov     ah, cs:first_unit
                add     ah, cs:units
                cmp     bh, ah
                pop     ax
                jae     fail

                jmp     short ok

fail:           or      bl, bl              ; If any driver, pass it on
                jz      int2f_done

                mov     al, 0
                jmp     short answer

ok:             mov     al, 0FFH            ; Return AL = 0FFH for installed

answer:         mov     bl, cs:driver_id    ; Return BL = logical driver number
                mov     cx, WORD PTR cs:major_version   ; CL = major, CH = minor version #
                mov     dx, cs              ; Return DX = segment of driver
                iret                    

check_win:      cmp     ah, 16h
                jne     int2f_done          ; Not windows API interrupt

                cmp     al, 5
                je      windows_init

                cmp     al, 6
                je      windows_exit

                cmp     al, 8
                je      win_init_done

                cmp     al, 9
                je      win_begin_exit

                jmp     int2f_done

windows_init:   test    dl, 1
                jnz     win_std_init        ; Non-zero = standard mode init


.386
                pusha
                push    ds
                push    es
                mov     ax, cs
                mov     ds, ax
                mov     win386_enh_mode, 1
                call    zero_bios_table
                pop     es
                pop     ds
                popa
.8086
                pushf
                call    dword ptr cs:old_int2f_vec
                mov     word ptr cs:Win386_Startup_Info.SIS_Next_Dev_Ptr, bx
                mov     word ptr cs:Win386_Startup_Info.SIS_Next_Dev_Ptr[2], es
                push    cs
                pop     es
                mov     bx, DVR:Win386_Startup_Info
                jmp     short int2f_ret

win_std_init:   mov     cs:win386_std_mode, 1
                jmp     short int2f_done

windows_exit:   test    dl, 1
                jnz     win_std_exit        ; Non-zero = standard mode exit

                mov     cs:win386_enh_mode, 0
                jmp     short int2f_done

win_std_exit:   mov     cs:win386_std_mode, 0
                jmp     short int2f_done

win_init_done:  push    ax
                push    bx
                push    di
                push    es

;--- Restore the port we zeroed in the BIOS table (if there was one).

                cmp     cs:bios_tab_ptr, 0FFFFH
                je      restore_done

                mov     ax, 40H
                mov     es, ax
                mov     ax, cs:bios_port_save
                mov     di, cs:bios_tab_ptr
                mov     word ptr es:[di], ax

restore_done:   xor     di, di
                mov     es, di                          ; Zero ES:DI
                mov     ax, 1684h
                mov     bx, VFXD_Device_ID
                int     2Fh

                mov     word ptr cs:win_386_api, di
                mov     ax, es
                mov     word ptr cs:win_386_api[2], ax
                or      ax, di
                pop     es
                pop     di
                pop     bx
                pop     ax
                jz      no_api


                push    ax
                push    ds
                push    di

                mov     di, cs
                mov     ds, di
                lea     di, win_386_api_ok
                mov     al, -1 
                call    dword ptr win_386_api

                pop     di
                pop     ds
                pop     ax
                        
no_api:         jmp     short int2f_done

win_begin_exit: mov     cs:win_386_api_ok, 0
;###            jmp     short int2f_done

;--- Pass on the INT 2F to the previous handler

int2f_done:     cmp     cs:int2f_ok, 0
                jne     pass_int2f

int2f_ret:      iret

pass_int2f:     jmp     dword ptr cs:old_int2f_vec


int2f_handler   ENDP

int25_handler   PROC    FAR

                cmp     al, cs:first_unit
                jb      int25_pass

                push    ax
                mov     ah, cs:first_unit
                add     ah, cs:units
                cmp     al, ah
                pop     ax
                jae     int25_pass

IFDEF DEBUG
                push    ds
                push    cs
                pop     ds
                DBG     '<'
                DBG     'I'
                DBG     'N'
                DBG     'T'
                DBG     '2'
                DBG     '5'
                DBG     '>'
                pop     ds
ENDIF

                mov     ax, 0102H
                stc
                retf

int25_pass:     jmp     dword ptr cs:old_int25_vec

int25_handler   ENDP

int26_handler   PROC    FAR

                cmp     al, cs:first_unit
                jb      int26_pass

                push    ax
                mov     ah, cs:first_unit
                add     ah, cs:units
                cmp     al, ah
                pop     ax
                jae     int26_pass

IFDEF DEBUG
                push    ds
                push    cs
                pop     ds
                DBG     '<'
                DBG     'I'
                DBG     'N'
                DBG     'T'
                DBG     '2'
                DBG     '6'
                DBG     '>'
                pop     ds
ENDIF

                mov     ax, 0102H
                stc
                retf

int26_pass:     jmp     dword ptr cs:old_int26_vec

int26_handler   ENDP

send_sync_proc  PROC    NEAR
                PUBLIC  send_sync_proc

                mov     idle_semaphore, 0   ; Insure idler off during sync
                cmp     port_address, 0
                jne     sync_ok             ; Skip sync if connected already

                xor     bx, bx
                mov     port_num, bl

parallel_loop:  mov     al, port_num
                cmp     al, num_par_ports
                jae     scan_serial

                mov     ax, parallel_ports[bx].PARALLEL_PORT_DEF.pp_address
                mov     port_address, ax
                call    save_par_vec
                call    show_dot
                call    send_sync_pvec
                jc      par_reset

                mov     is_serial, 0
                mov     ax, send_pack_pvec
                mov     send_pack, ax
                mov     ax, recv_pack_pvec
                mov     recv_pack, ax
                jmp     short save_index

par_reset:      call    restore_par_vec
                inc     port_num
                add     bx, TYPE PARALLEL_PORT_DEF
                jmp     parallel_loop

scan_serial:    xor     bx, bx
                mov     port_num, bl

serial_loop:    mov     al, port_num
                cmp     al, num_ser_ports
                jae     scan_fail

                mov     ax, serial_ports[bx].SERIAL_PORT_DEF.sp_address
                mov     port_address, ax
                call    init_port_serial
                call    show_dot
                call    send_sync_serial
                jc      ser_reset

                mov     is_serial, 1
                mov     send_pack, DVR:send_pack_serial
                mov     recv_pack, DVR:recv_pack_serial

save_index:     mov     port_index, bx          ; Save index into port array
                mov     idle_semaphore, MINIMUM_TICKS + 1

sync_ok:        clc
                jmp     short send_sync_ret
                
ser_reset:      call    reset_port_serial
                inc     port_num
                add     bx, TYPE SERIAL_PORT_DEF
                jmp     serial_loop

scan_fail:      mov     port_address, 0
                stc

send_sync_ret:  ret

send_sync_proc  ENDP

reset_drives    PROC    NEAR

                push    ds
                pop     es
                mov     di, DVR:drive_mapping
                mov     si, DVR:default_mapping
                mov     cx, MAX_DEVICES
            rep movsb
                ret

reset_drives    ENDP

reset_printers  PROC    NEAR

                push    ds
                pop     es
                mov     al, UNASSIGNED
                mov     di, DVR:actual_prn_map
                xor     ch, ch
                cmp     printer_loaded, 0
                mov     cl, 3
                je      @F

                mov     cl, num_lpt
            rep stosb
                mov     cl, 3
                sub     cl, num_lpt
                mov     al, DONT_CARE

@@:         rep stosb

                ret

reset_printers  ENDP

; get_remote_info sends an INIT_PACKET to the remote.  The remote should
; respond with an array of BPBs for all devices on the remote system.
;
; Inputs:
;   max_devices         Maximum number of devices driver can support
;   dos_version         The word format of the dos versin number
;   max_secsize         Maximum sector size this DOS version can support
;   first_unit          Device number of the first unit in this driver
;
; Outputs:
;   CF                  Set if successful initialization transaction
;                       Clear if some error occured
;
;   dd_attributes       Attribute word array (one word/device)
;   slave_dos_version   DOS version in WORD format of slave system
;   server_major Server program version number
;   initialized         Set if successful communication
;
;   If a communication error occures, the above variables will not be modified.
;
; All registers are destroyed.
;
gri_proc        PROC    NEAR
                PUBLIC  gri_proc

;--- Send server info request (a zero word) ---
                mov     word ptr packet_buf.common_packet.packet_type, 0
                push    ds
                pop     es
                mov     si, DVR:packet_buf
                mov     cx, 2
                call    send_pack
                jc      gr_fail

                mov     di, DVR:packet_buf
                mov     cx, ((TYPE server_info_r + 1) SHR 1)
                xor     ax, ax
        rep     stosw                       ; Zero unused fields
                mov     packet_buf.server_info_r.sir_os_type, OS_MSDOS
                mov     packet_buf.server_info_r.sir_developer, DEV_SEWELL
                mov     packet_buf.server_info_r.sir_product, PRODUCT_DOSLINK
                mov     packet_buf.server_info_r.sir_version, PRODUCT_VERSION
                mov     packet_buf.server_info_r.sir_device_driver, 1
                mov     packet_buf.server_info_r.sir_want_supported, 0
                mov     packet_buf.server_info_r.sir_checksum, 0
                mov     packet_buf.server_info_r.sir_crc, 1
                mov     packet_buf.server_info_r.sir_max_ser_block, MAX_SERIAL_BLOCK
                mov     si, DVR:client_id
                mov     di, DVR:packet_buf.server_info_r.sir_client_id
                mov     cx, 4
        rep     movsw
                mov     si, DVR:packet_buf
                mov     cx, TYPE server_info_r
                call    send_pack
                jc      gr_fail

                mov     di, DVR:packet_buf
                mov     cx, MAX_PACKET
                call    recv_pack
                jc      gr_fail

                mov     ax, packet_buf.server_info_a.sia_max_ser_block
                mov     max_serial_block, ax
                mov     di, DVR:client_id
                mov     si, DVR:packet_buf.server_info_a.sia_last_client_id
                mov     cx, 4
        repe    cmpsw
                je      check_support

                mov     initialized, 0
                call    reset_drives
                mov     si, DVR:packet_buf.server_info_a.sia_server_id
                mov     di, DVR:last_server_id
                movsw               ; Update last_server_id
                movsw

check_support:  cmp     packet_buf.server_info_a.sia_device_server, 0
                je      gr_fail

                cmp     initialized, 0
                jnz     gr_success

                call    reset_printers
                mov     packet_buf.common_packet.packet_type, INIT_PACKET_REQ
                mov     al, default_units   ; Send default units for max dev.
                mov     packet_buf.init_packet_r.ipr_max_devices, al
                mov     ax, dos_version
                mov     packet_buf.init_packet_r.ipr_dos_version, ax
                mov     WORD PTR packet_buf.init_packet_r.ipr_major_version, (MAJOR_VER OR (MINOR_VER SHL 8))
                mov     al, first_unit
                mov     packet_buf.init_packet_r.ipr_first_unit, al
                mov     si, DVR:actual_prn_map
                mov     di, DVR:packet_buf.init_packet_r.ipr_prn_map
                push    ds
                pop     es
                mov     cx, 3 + MAX_DEVICES
            rep movsb

                mov     cx, TYPE init_packet_r
                mov     si, DVR:packet_buf
                push    ds
                pop     es

                call    send_pack       ; Send init packet
                jc      gr_fail

                push    ds
                pop     es
                mov     di, DVR:packet_buf
                mov     cx, MAX_PACKET  ; es:di, cx -> receive buffer

                call    recv_pack       ; get init response
                jc      gr_fail

                mov     ax, packet_buf.init_packet_a.ipa_dos_version  ; Save version numbers
                mov     slave_dos_version, ax
                mov     ax, WORD PTR packet_buf.init_packet_a.ipa_major_version
                mov     WORD PTR server_major, ax
                mov     al, packet_buf.init_packet_a.ipa_multitasker
                mov     server_multitasker, al

                mov     cx, 3 + MAX_DEVICES
                mov     si, DVR:packet_buf.init_packet_a.ipa_prn_map
                mov     di, DVR:actual_prn_map
                push    ds
                pop     es
            rep movsb

                mov     cl, packet_buf.init_packet_a.ipa_devices
                xor     ch, ch          ; cx = number of devices
                mov     slave_units, cl ; Save slave units
                mov     si, DVR:packet_buf.init_packet_a.ipa_attributes
                mov     di, DVR:dd_attributes
            rep movsw                   ; Copy device driver attributes

                mov     al, 0FFH
                mov     initialized, al ; Set initialized flag
                mov     cx, MAX_DEVICES ; Set media invalid flag for all drives
                mov     di, DVR:invalid ; NOTE: ES and AL set up above
            rep stosb

gr_success:     clc                     ; Return success flag
                ret

gr_fail:        stc                     ; Return fail flag
                ret

gri_proc        ENDP


IFDEF DEBUG
MIN_OFFSET      EQU     3 * 2 * 80
MAX_OFFSET      EQU     20 * 2 * 80
screen_offset   dw      (MIN_OFFSET + MAX_OFFSET) / 2
screen_seg      dw      0B800H

debug_init      PROC    NEAR
                PUBLIC  debug_init

                mov     ah, 15
                int     10H
                cmp     al, 7
                jne     color_seg

                mov     screen_seg, 0B000H
                jmp     short init_done

color_seg:      mov     screen_seg, 0B800H

init_done:      ret

debug_init      ENDP

debug_ret       dw      ?

debug_msg_proc  PROC    NEAR

; AX has been pushed on the stack before calling this routine
; Output the character in AL
;   ALL REGISTERS AND FLAGS PRESERVED

                pop     debug_ret
                pushf
                push    es
                push    di
                mov     di, cs:screen_seg
                mov     es, di
                mov     ah, 70H
                mov     di, cs:screen_offset
                stosw
                cmp     di, MAX_OFFSET
                jb      @F

                mov     di, MIN_OFFSET

@@:             mov     ax, 720H
                mov     es:[di], ax
                mov     cs:screen_offset, di
                pop     di
                pop     es
                popf
                pop     ax
                jmp     debug_ret

debug_msg_proc  ENDP

hex_nibble      PROC    NEAR

                and     al, 0FH
                add     al, '0'
                cmp     al, '9'
                jbe     @F

                add     al, 7

@@:             ret

hex_nibble      ENDP


hex_out_proc    PROC    NEAR

; Output value in AL as hex digits
;   ALL REGISTERS AND FLAGS PRESERVED

                pushf
                push    ax
                mov     ah, al
                shr     al, 1
                shr     al, 1
                shr     al, 1
                shr     al, 1
                call    hex_nibble          ; Prepare original high nibble
                call    debug_msg_proc
                push    ax
                call    hex_nibble          ; Prepare original low nibble
                call    debug_msg_proc
                popf
                ret

hex_out_proc    ENDP
ENDIF

CORE            ENDS

                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\version.c ===
/***
* $Workfile:   version.c  $
* $Revision:   1.1  $
*   $Author:   Dave Sewell  $
*     $Date:   27 Jun 1989 14:54:44  $
***/

/*** Variables configurable at program build time. ***/

char cdecl version[] = VERSION;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\driver\parallel.asm ===
;***
;* $Workfile:   parallel.asm  $
;* $Revision:   1.3  $
;*   $Author:   Dave Sewell  $
;*     $Date:   04 May 1990  9:12:18  $
;***

                TITLE   Parallel communications subroutines
                PAGE    66, 132


;### PREVENT_TIMEOUT EQU     1

                INCLUDE drivers.mac
                INCLUDE debug.mac

                SUBTTL  Definitions
                PAGE

TIMER_INTERRUPT equ 1CH                 ; User timer interrupt vector

SEND_OPERATION   EQU     0
RECV_OPERATION   EQU     1

PARALLEL_NORMAL         EQU     0
PARALLEL_TURBO          EQU     1

DIRECTION_BIT   EQU     00100000B

; Read and Write ACK/NAK values:
; The read values are the same as the write values execpt that they are shifted
; three to the left and the most significant bit is complemented.

WACK            equ     00000110B       ; WACK = 06H    NOT WACK = F9H
WNAK            equ     00000011B       ; WNAK = 03H    NOT WNAK = FCH
WIDLE           equ     00001010B

RACK            equ     ((WACK SHL 3) AND 7FH) OR ((NOT (WACK SHL 3)) AND 80H)
                                        ; RACK = B0H    NOT RACK = 4FH
RNAK            equ     ((WNAK SHL 3) AND 7FH) OR ((NOT (WNAK SHL 3)) AND 80H)
                                        ; RNAK = 98H    NOT RNAK = 67H

WSYNC           equ     00010101B       ; WSYNC = 15H   NOT WSYNC = EAH
RSYNC           equ     ((WSYNC SHL 3) AND 7FH) OR ((NOT (WSYNC SHL 3)) AND 80H)
                                        ; RSYNC = A8H   NOT RSYNC = 57H

INITIAL_CRC     equ     0FFFFH          ; Initial CRC accumulator
MAGIC_CRC       equ     1D0FH           ; Magic CRC number

                PUBLIC  send_pack_parallel
                PUBLIC  recv_pack_parallel
                PUBLIC  send_sync_parallel
                PUBLIC  save_parallel
                PUBLIC  restore_parallel
                PUBLIC  ss_timeout
                PUBLIC  ssp1
                PUBLIC  ssp2
                PUBLIC  ssp3
                PUBLIC  sw_timeout
                PUBLIC  swp1
                PUBLIC  swp2
                PUBLIC  sp_timeout
                PUBLIC  spp2
                PUBLIC  spp3
                PUBLIC  spp4
                PUBLIC  spn_timeout
                PUBLIC  spn2
                PUBLIC  spn3
                PUBLIC  spn4
                PUBLIC  rw_timeout
                PUBLIC  rwp1
                PUBLIC  rwp2
                PUBLIC  rp_timeout
                PUBLIC  rpp1
                PUBLIC  rpp2
                PUBLIC  rpp3
                PUBLIC  rpn_timeout
                PUBLIC  rpn1
                PUBLIC  rpn2
                PUBLIC  rpn3
                PUBLIC  wsa1
                PUBLIC  wsa_timeout
                PUBLIC  par_fixup1
                PUBLIC  par_fixup2
                PUBLIC  par_fixup3
                PUBLIC  par_fixup4
                PUBLIC  timer_passthru_par


CORE            SEGMENT WORD PUBLIC 'CODE'
                EXTRN   win386_enh_mode:BYTE
                EXTRN   win_386_api:DWORD
                EXTRN   win_386_api_ok:BYTE
                EXTRN   last_operation:BYTE
                EXTRN   num_par_ports:BYTE
                EXTRN   crctab:WORD
                EXTRN   crc_errors:WORD
                EXTRN   seq_num:BYTE
                EXTRN   port_address:WORD
                EXTRN   save_area:BYTE
                EXTRN   timeout:BYTE
                EXTRN   code_list_ptr:WORD
                EXTRN   code_save:WORD
                EXTRN   ticks_remaining:WORD
                EXTRN   set_alarm_time:WORD
                EXTRN   alarm_vector:WORD
                EXTRN   par_timer_save:DWORD
                EXTRN   send_sync_list:WORD
                EXTRN   send_word_list:WORD
                EXTRN   sp_normal_list:WORD
                EXTRN   send_pack_list2:WORD
                EXTRN   recv_word_list:WORD
                EXTRN   recv_pack_list:WORD
                EXTRN   rp_normal_list:WORD
                EXTRN   wait_send_list:WORD
                EXTRN   timer_jmp:WORD
                EXTRN   is_serial:BYTE
                EXTRN   busy_semaphore:BYTE
                EXTRN   idle_semaphore:BYTE
                EXTRN   start_packet:WORD
                EXTRN   end_packet:WORD
        IFDEF DEBUG
                EXTRN   debug_msg:WORD
        ENDIF

idle_ack        db      WIDLE
idle_recv_wait  db      0

last_nib_sent       db  ?
last_nib_received   db  ?

recv_ptr            dw  ?               ; Save area for buffer pointer
send_ptr            dw  ?               ; Save area for send buffer pointer
send_count          dw  ?               ; Save area for send count

fx_parallel_speed   db  ?

last_ticks      dw      0
current_ticks   dw      0

CORE            ENDS


PARALLEL            SEGMENT WORD PUBLIC 'CODE'
                    PUBLIC  parallel_start

                    ORG     0

parallel_start      LABEL   BYTE

driver_timer_handler    LABEL   FAR

                jmp     cs:timer_jmp

; timer_handler_par -- Interrupt handler for timing while alarm is running
;
;   timer_handler_par is the interrupt handler which counts down the ticks in a
;   running alarm.  When the remaining ticks reaches zero, the interrupt return
;   will be modified to return to the timeout address.
;
;   In all cases, this routine appropriately chains to the previous interrupt
;   handler.
;
timer_handler_par   PROC    FAR

                push    ax
                push    bx
                call    GetTicks
                mov     bx, ax
                sub     ax, cs:set_alarm_time
                mov     cs:set_alarm_time, bx       ; Update set_alarm_time
                sub     cs:ticks_remaining, ax
                pop     bx
                pop     ax
                jc      timed_out

                jnz     timer_passthru_par

timed_out:      cmp     cs:timeout, 1
                je      timer_passthru_par

                push    ax              ; Preserve used registers
                push    bx
                push    di
                push    si

                mov     cs:timeout, 1   ; Flag occurrence of timeout
                mov     di, cs:code_list_ptr
                xor     bx, bx

save_code_loop: mov     si, cs:[di + bx + 2]
                or      si, si
                jz      fixup_return

                mov     ax, cs:[di]     ; Get vector to fail address
                sub     ax, si          ; Get forward jump delta to AX
                sub     ax, 2           ; Adjust size of short jump
                cmp     ax, 127
                jbe     in_range

                mov     ax, cs:[di + bx + 4]    ; Grab following jump address
                sub     ax, si
                sub     ax, 2

in_range:       mov     ah, al
                mov     al, 0EBH        ; Jump short directly to fail location.
                xchg    ax, cs:[si]
                mov     cs:code_save[bx], ax
                add     bx, 2
                jmp     save_code_loop

fixup_return:   pop     si
                pop     di
                pop     bx
                pop     ax
                jmp     cs:par_timer_save   ; chain through old timer vector

timer_passthru_par  LABEL   FAR         ; Interrupt handler while alarm not on!

                cmp     cs:busy_semaphore, 0
                jne     pass_it

                cmp     cs:port_address, 0
                je      pass_it

                cmp     cs:is_serial, 0
                jne     pass_it

                cmp     cs:idle_semaphore, 0
                je      pass_it

                cmp     cs:idle_semaphore, 1
                je      do_idle

                dec     cs:idle_semaphore
                mov     cs:idle_recv_wait, 0
                jmp     short pass_it

do_idle:        push    ax
                call    GetTicks
                cmp     ax, cs:set_alarm_time
                mov     cs:set_alarm_time, ax       ; Update set_alarm_time
                pop     ax
                je      pass_it

                call    idle_handler

pass_it:        jmp     cs:par_timer_save   ; chain through old timer vector

timer_handler_par   ENDP

GetTicks        PROC    NEAR

;* Enter with:
;* Uses:
;*      AX = logical tick count returned

                push    es
                push    bx
                mov     ax, 040H
                mov     es, ax
                mov     ax, es:[06CH]
                mov     bx, ax
                sub     ax, cs:last_ticks
                mov     cs:last_ticks, bx
                cmp     ax, 2 * 18
                jb      @F

;*** NOTE: Elapsed time greater than or equal to 2 seconds means either:
;***
;***    1)  Clock rolled over at midnight, so we adjust by only 1 tick.
;***    2)  User is starting a new timing sequence, so it doesn't matter.

                mov     ax, 1

@@:             add     cs:current_ticks, ax
                mov     ax, cs:current_ticks
                pop     bx
                pop     es
                ret

GetTicks        ENDP


made_connection PROC    NEAR

                mov     fx_parallel_speed, PARALLEL_TURBO
                ret

made_connection ENDP

lost_connection PROC    NEAR

                mov     port_address, 0     ; Connection lost
                mov     idle_semaphore, 0
                ret

lost_connection ENDP

delay           PROC    NEAR

                push    ax
                push    bx
                push    cx
                mov     bx, ax

                call    GetTicks
                mov     cx, ax

delay_loop:     call    GetTicks
                sub     ax, cx
                cmp     ax, bx
                jb      delay_loop

                pop     cx
                pop     bx
                pop     ax
                ret

delay           ENDP

idle_handler    PROC    NEAR

                push    ax
                push    bx
                push    dx
                push    ds
                push    cs
                pop     ds              ; Load DS with our segment
                mov     last_operation, SEND_OPERATION
                mov     dx, port_address
                cmp     win_386_api_ok, 0
                jne     send_by_vfxd

                mov     al, idle_ack
                out     dx, al
                inc     dx
                in      al, dx          ; See if we got what we were expecting
                jmp     short check_response

send_by_vfxd:   mov     ax, PARALLEL_IDLER
                mov     bl, idle_ack
                call    dword ptr win_386_api

check_response: xor     al, 80H
                shr     al, 1
                shr     al, 1
                shr     al, 1
                cmp     al, idle_ack
                jne     no_recv

                not     idle_ack
                and     idle_ack, 0FH       ; Complement idle ack
                mov     idle_recv_wait, 0   ; and reset timeout
                jmp     short idle_ret

no_recv:        inc     idle_recv_wait
                cmp     idle_recv_wait, 2 * MINIMUM_TICKS
                jbe     idle_ret

                call    lost_connection

idle_ret:       pop     ds
                pop     dx
                pop     bx
                pop     ax
                ret

idle_handler    ENDP

; set_alarm_par -- Starts the alarm counting down ticks.
;
; Destroys registers: None
;
; set_alarm_par changes the timer interrupt vector from timer_passthru_par to
; timer_handler_par.  Before calling this routine ticks_remaining should be set
; to the number of ticks before a timeout trap should occur and code_list_ptr
; should be set to point to the list of code locations to change to NOPs.
; Since the granularity of the alarm is  tick,
; ticks_remaining should always be set to 2 or more (if set to 1, a timeout
; could occur immediately after the return from this routine).
;
set_alarm_par   PROC    NEAR

                mov     timeout, 0
                push    ax
                call    GetTicks
                mov     set_alarm_time, ax
                pop     ax
    IFDEF   PREVENT_TIMEOUT
                mov     timer_jmp, DVR:timer_passthru_par
    ELSE
                mov     timer_jmp, DVR:timer_handler_par
    ENDIF
par_fixup1      EQU     $ - 2
                ret

set_alarm_par   ENDP


; clear_alarm_par -- Reset the timer interrupt handler to timer_passthru_par
;
; Destroys registers: None
;
; Outputs:
;   CF set if OK.  Clear if timeout occurred.
;
clear_alarm_par PROC    NEAR

                mov     timer_jmp, DVR:timer_passthru_par
par_fixup2      EQU     $ - 2
                cmp     timeout, 0
                je      no_timeout

                push    ax
                push    bx
                push    di
                push    si
                mov     di, code_list_ptr
                xor     bx, bx

restore_code:   mov     si, [di + bx + 2]
                or      si, si
                jz      restore_done

                mov     ax, code_save[bx]
                mov     [si], ax
                add     bx, 2
                jmp     restore_code

restore_done:   pop     si
                pop     di
                pop     bx
                pop     ax
                stc                     ; Carry for timeout failure
                ret

no_timeout:     clc                     ; No carry if no timeout
                ret

clear_alarm_par ENDP

readStatus      PROC    NEAR

;* Performs:    Reads a byte from the status port four times, and determines
;*              if the defined bits are equal all four times.
;* Enter with:
;*      DX  = port base address
;* Returns:
;*      C   - Bytes were NOT equal
;*      NC  - Bytes were all equal, in which case sign bit is set as follows:
;*            S  : High bit of AL is set
;*            NS : High bit of AL is not set
;* Uses:
;*      AX

                inc     dx
                in      al, dx
                mov     ah, al
                and     ah, 0F8H

        REPT    4
                in      al, dx
                and     al, 0F8H
                cmp     al, ah
                jne     read_fail
        ENDM

                dec     dx              ; Restore DX
                or      al, al
                clc
                ret

read_fail:      dec     dx              ; Restore DX
                stc

read_ret:       ret

readStatus      ENDP


; send_sync -- Send synchonization byte
;
;   Inputs: None
;
;   Outputs:
;       CF  Set if synchronization was OK.  Clear otherwise.
;
;   Registers used: ALL
;
;   The complement of this routine is recv_sync.
;
;   Note: The send_sync_par and recv_sync_par subroutines rely on all other
;   I/O routines leaving something on the port other than the sync nibble.
;       If the sync nibble is on the port, the send_sync_par routine could
;   interpret that as the response from the other system.  But the other system
;   might never see the first sync nibble--thus the sync routines would time
;   out (the problem being described here is analogous to the problem on the
;   Toshiba laptops in Fastwire II).
;       If send_sync_par succeeds, the output line will be set to NOT WSYNC.
;   If it fails, output will be set to WNAK.
;
;   extern int send_sync_par(void);
;
send_sync_parallel      PROC    NEAR

                push    bx              ; Insure BX preserved
                mov     dx, port_address
                mov     al, NOT WNAK
                out     dx, al
                mov     ticks_remaining, CONNECT_TICKS
                mov     code_list_ptr, DVR:send_sync_list
                call    set_alarm_par   ; Start timing the sync

@@:             call    readStatus
ssp1::          jc      @B

                cmp     al, (NOT RSYNC) AND 0F8H
                jne     @B

                mov     al, WSYNC       ; Write out first sync nibble
                out     dx, al

@@:             call    readStatus
ssp2::          jc      @B

                cmp     al, RSYNC
                jne     @B
            
                mov     al, NOT WSYNC   ; Write out second sync nibble
                out     dx, al

@@:             call    readStatus
ssp3::          jc      @B

                cmp     al, RNAK
                jne     @B

                mov     seq_num, 0      ; reset sequence number
                call    made_connection
                jmp     SHORT ss_exit

ss_timeout::    mov     al, WNAK        ; Insure known state on output
                out     dx, al          ; dx is pointing to data register!

ss_exit:        call    clear_alarm_par
                pop     bx
                mov     last_operation, SEND_OPERATION
                ret

send_sync_parallel      ENDP


update_crc      PROC    NEAR    ; Update CRC in CX based on value in BL

                push    bx
                xchg    ch, cl
                xor     cl, bl
                xor     bx, bx
                xchg    bl, cl
                shl     bx, 1
                xor     cx, crctab[bx]
                pop     bx
                ret

update_crc      ENDP

; send_byte
;   The complement of this routine is recv_byte (and recv_byte_noack).
;
;   Inputs:
;       AL          Ticks to wait
;       BL          Byte to be sent
;       DX          Port base address
;
;   Outputs:
;       NC          Carry clear if byte successfully sent
;       C           Carry set if error in send
;       AL          If no error, final acknowledgment value
;                   Otherwise, unknown
;       DX          If no error occured, port base address--otherwise unknown
;
;   Registers destroyed: AX, BL
;
send_byte       PROC    NEAR

                mov     ticks_remaining, ax
                call    update_crc
                mov     code_list_ptr, DVR:send_word_list
                call    set_alarm_par   ; And we're off . . .
                mov     al, bl          ; Send low byte first

sw_loop:        or      al, 10H         ; Set transition bit
                out     dx, al          ; Send lower nibble
                shr     bl, 1           ; Prepare high nibble
                shr     bl, 1
                shr     bl, 1
                shr     bl, 1

@@:             call    readStatus
swp1::          jc      @B
                js      @B

                mov     al, bl          ; Get ready to send high nibble
                out     dx, al          ; Output high nibble

@@:             call    readStatus
swp2::          jc      @B
                jns     @B

sw_timeout::    call    clear_alarm_par

                ret

send_byte       ENDP

; send_pack_parallel  Send a packet
;   Inputs:
;       cx          Length of buffer to be sent
;       es:si       Pointer to buffer to be sent
;
;   Outputs:
;       CF          Set if packet successfully sent
;
;   Registers Destroyed: AX, BX, CX, DX, SI, DI, BP
;

send_pack_parallel      PROC    NEAR

                DBG     ''
                call    start_packet
                mov     send_ptr, si
                mov     send_count, cx
                dec     cx
                add     si, cx
                jc      sp_fail             ; Buff ptr + cnt = seg wrap

                mov     dx, port_address; dx = base (data) register
                or      dx, dx
                jz      sp_fail

                cmp     last_operation, SEND_OPERATION
                je      sp_proceed

;--- Wait for line turnaround

                mov     bl, last_nib_received
                call    wait_send_ack
                mov     last_operation, SEND_OPERATION

sp_proceed:     mov     di, send_count
                mov     si, send_ptr
                mov     cx, INITIAL_CRC     ; Initialize CRC accumulator
                mov     ax, SYNC_TICKS
                mov     bl, seq_num
                call    send_byte
                jc      sp_pack_err

                cmp     al, RACK
                jne     sp_error

                mov     bx, di
                mov     ax, MINIMUM_TICKS
                call    send_byte       ; Send LSB of count
                jc      sp_pack_err

                mov     bl, bh  
                mov     ax, MINIMUM_TICKS
                call    send_byte       ; Send MSB of count
                jc      sp_pack_err

                cmp     fx_parallel_speed, PARALLEL_NORMAL
                je      sp_normal

                mov     ticks_remaining, MINIMUM_TICKS
                mov     code_list_ptr, DVR:send_pack_list2
                call    set_alarm_par   ; Start the race. . .

sp_loop:        mov     ticks_remaining, MINIMUM_TICKS
                mov     al, es:[si]     ; al = byte to send
                mov     bl, al          ; Keep a copy for CRC calculation
                inc     si              ; Point to next byte
                mov     ah, al          ; Preserve High nibble
                or      al, 10H         ; Or in transition bit
                out     dx, al          ; Output lower nibble
                shr     ah, 1
                shr     ah, 1
                shr     ah, 1
                shr     ah, 1
                inc     dx              ; Point to status register

@@:             in      al, dx          ; Wait for receivers transition
                or      al, al
spp2::          js      @B

                dec     dx              ; Point to data register
                mov     al, ah          ; al = high nibble
                out     dx, al          ; output high nibble
                xchg    ch, cl
                xor     cl, bl
                xor     bx, bx
                xchg    bl, cl
                shl     bx, 1
                xor     cx, crctab[bx]
                inc     dx              ; Point to status register

@@:             in      al, dx          ; Wait for receivers transition
                or      al, al
spp3::          jns     @B

                dec     dx              ; Point to data register
                dec     di              ; Decrement count
spp4::          jnz     sp_loop         ; Repeat until no bytes left

                call    clear_alarm_par ; Turn off alarm
                jc      sp_timeout


sp_common:      not     cx              ; Complement CRC accumulator
                mov     bx, cx
                xchg    bh, bl
                mov     ax, MINIMUM_TICKS
                call    send_byte       ; Send complemented CRC accumulator MSB
                jc      sp_retry_err

                mov     bl, bh
                mov     al, bl
                mov     cl, 4
                shr     al, cl
                mov     last_nib_sent, al
                mov     ax, MINIMUM_TICKS
                call    send_byte
                jc      sp_retry_err

                cmp     al, RACK        ; Did CRC match?
                jne     sp_crc_err

                inc     seq_num
                and     seq_num, SEQUENCE_BITS
                clc                     ; Set success flag
                jmp     SHORT sp_exit

sp_crc_err:     inc     crc_errors      ; Increment CRC error counts
                DBG     '~'
                jmp     short sp_retry_err

sp_timeout::    call    clear_alarm_par
                DBG     '@'

sp_retry_err:   cmp     fx_parallel_speed, PARALLEL_NORMAL
                je      sp_error

;--- Got an error at TURBO speed so retry at NORMAL speed.

                DBG     ''
                mov     fx_parallel_speed, PARALLEL_NORMAL
                mov     dx, port_address
                mov     al, WNAK
                out     dx, al
                mov     ax, 4 * MINIMUM_TICKS
                call    delay
                jmp     sp_proceed

sp_pack_err:

sp_error:       DBG     '*'
                mov     dx, port_address
                mov     al, WNAK        ; Set transition bit to a known state
                out     dx, al
                call    lost_connection

sp_fail:        stc

sp_exit:        call    end_packet
                ret

sp_normal:      mov     ticks_remaining, MINIMUM_TICKS
                mov     code_list_ptr, DVR:sp_normal_list
                call    set_alarm_par   ; Start the race. . .

spn_loop:       mov     ticks_remaining, MINIMUM_TICKS
                mov     al, es:[si]     ; al = byte to send
                mov     bl, al          ; Keep a copy for CRC calculation
                inc     si              ; Point to next byte
                mov     bh, al          ; Preserve High nibble
                or      al, 10H         ; Or in transition bit
                out     dx, al          ; ==> Output lower nibble
                shr     bh, 1           ; ##### Replace w/ shr bh, 4 on 286
                shr     bh, 1
                shr     bh, 1
                shr     bh, 1

@@:             call    readStatus
spn2::          jc      @B
                js      @B

                mov     al, bh          ; al = high nibble
                out     dx, al          ; ==> output high nibble
                xchg    ch, cl
                xor     cl, bl
                xor     bx, bx
                xchg    bl, cl
                shl     bx, 1
                xor     cx, crctab[bx]

@@:             call    readStatus
spn3::          jc      @B
                jns     @B

                dec     di              ; Decrement count
spn4::          jnz     spn_loop        ; Repeat until no bytes left

                call    clear_alarm_par ; Turn off alarm
                jnc     sp_common

                jmp     sp_pack_err

spn_timeout::   jmp     sp_timeout


send_pack_parallel      ENDP


; recv_byte_noack
;   Receives a byte on port DX
;   This routine assumes that the sender posted an ACK on the port.
;
;   The final acknowledgement is not sent by this routine, but must be sent by
;   the caller of this routine.  This allows either an ACK or a NAK to be sent
;   back to the sender.
;
;   The complement of this routine is send_byte
;
;
;   Inputs:
;       AX          Ticks to wait for word
;       DX          Port base address
;
;   Outputs:
;       BL          byte received (Unknown if error)
;       CF          Clear if byte successfully recieved
;                   Set if error in recieve
;       DX          If no error occurs, port base address.  Otherwise unknown.
;
;   Registers destroyed: AX
;
recv_byte_noack PROC    NEAR

                mov     ticks_remaining, ax
                mov     code_list_ptr, DVR:recv_word_list
                call    set_alarm_par   ; And we're off . . .

@@:             call    readStatus
rwp1::          jc      @B
                js      @B

                mov     bl, al          ; Save low nibble
                mov     al, NOT WNAK    ; Set Transition bit
                out     dx, al          ; And output it
                shr     bl, 1
                shr     bl, 1
                shr     bl, 1           ; place low nibble, high bits already 0

@@:             call    readStatus
rwp2::          jc      @B
                jns     @B

                shl     al, 1           ; Fix up nibble
                or      bl, al          ; Whole byte now in BL
                call    update_crc

rw_timeout::    call    clear_alarm_par

rw_ret:         ret 

recv_byte_noack ENDP

wait_send_ack   PROC    NEAR

;* Wait for sender to acknowledge having seen our last ACK/NAK.
;* The last nibble sent will be complemented when sender acknowledges.
;*
;* Enter with:
;*      DX = port base address
;*      BL = last nibble received
;* On return:
;*      AX clobbered
;*      BL clobbered
;*      NC - Carry clear if send acknowledge seen
;*       C - Carry set if no sender acknowledge seen

                mov     ticks_remaining, MINIMUM_TICKS
                mov     code_list_ptr, DVR:wait_send_list
                call    set_alarm_par

                not     bl
                and     bl, 0F0H        ; Now AH has complemented high nibble

;*** Now wait for sender to toggle his high nibble so we know that he saw
;*** our acknowledgment.

@@:             call    readStatus
wsa1::          jc      @B

                shl     al, 1
                cmp     al, bl
                jne     @B

wsa_timeout::   call    clear_alarm_par
                ret

wait_send_ack   ENDP

recv_byte       PROC    NEAR

                call    recv_byte_noack
                jc      recv_byte_ret

                mov     al, WNAK
                out     dx, al
                
recv_byte_ret:  ret

recv_byte       ENDP



; recv_pack_parallel    Recieve a packet
;   Inputs:
;       es:di       pointer to buffer
;       cx          max size of buffer
;
;   Outputs:
;       CF          Set if packet recieved
;                   Clear if timeout or some other error
;       cx          If no error, number of bytes recieved.  Otherwise, unknown.
;
;   Uses registers: ax bx cx dx si di bp
;
; extern unsigned int recv_pack_par(void far *buffer, unsigned int count);
;
; Note: The last nibble written out by send_pack_par will be either an WACK
; or a WNAK.  The last operation will either be SEND or UNKNOWN.
;
recv_pack_parallel      PROC    NEAR

                DBG     ''
                call    start_packet
                mov     dx, port_address   ; Point to base (data) register
                or      dx, dx
                jz      rp_fail

                mov     bp, cx          ; save buffer length
                mov     recv_ptr, di
                dec     cx
                add     cx, di
                jc      rp_fail         ; Buff + max cnt = seg wrap

                cmp     last_operation, RECV_OPERATION
                je      rp_proceed

                mov     al, last_nib_sent
                not     al
                and     al, 0FH
                out     dx, al
                mov     last_operation, RECV_OPERATION

rp_proceed:     mov     di, recv_ptr
                mov     cx, INITIAL_CRC
                mov     ax, RECV_PACK_TICKS
                call    recv_byte_noack
                jc      rp_error

                and     bl, SEQUENCE_BITS
                cmp     bl, seq_num
                jne     rp_error

                mov     al, WACK
                out     dx, al
                mov     ax, MINIMUM_TICKS
                call    recv_byte
                jc      rp_error

                mov     bh, bl          ; Save LSB of length in BH
                mov     ax, MINIMUM_TICKS
                call    recv_byte
                jc      rp_error

                xchg    bh, bl
                dec     bx              ; NOTE: 0 = 64K, so dec before cmp
                dec     bp
                cmp     bx, bp          ; Room in buffer?
                ja      rp_error

                inc     bx
                inc     bp
                mov     si, bx          ; SI = count

                cmp     fx_parallel_speed, PARALLEL_NORMAL
                je      recv_normal

                mov     ticks_remaining, MINIMUM_TICKS
                mov     code_list_ptr, DVR:recv_pack_list
                call    set_alarm_par   ; And there off. . .

rp_loop:        inc     dx              ; Point to status register

@@:             in      al, dx          ; Wait for transition
                or      al, al
rpp1::          js      @B

                in      al, dx          ; re-read after line has settled a bit
                mov     bl, al          ; save low nibble
                dec     dx              ; Point to data register
                mov     al, NOT WNAK    ; set transition bit
                out     dx, al          ; output transition
                shr     bl, 1
                shr     bl, 1
                shr     bl, 1
                inc     dx
                mov     ticks_remaining, MINIMUM_TICKS

@@:             in      al, dx          ; Wait for transition
                or      al, al
rpp2::          jns     @B

                in      al, dx          ; Let line settle a bit
                mov     bh, al          ; save high nibble
                mov     al, WNAK        ; clear transition bit
                dec     dx              ; point to data register
                out     dx, al          ; Output transition
                shl     bh, 1           ; Position high nibble
                and     bh, 0F0H        ; clear out garbage nibble
                or      bl, bh          ; or nibbles together
                mov     al, bl          ; save byte in the buffer
                stosb
                xchg    ch, cl
                xor     cl, bl
                xor     bx, bx
                xchg    bl, cl
                shl     bx, 1
                xor     cx, crctab[bx]

                dec     si              ; Any bytes left to recieve?
rpp3::          jnz     rp_loop

                call    clear_alarm_par ; Turn off the alarm clock
                jc      rp_timeout

recv_common:    mov     ax, MINIMUM_TICKS
                call    recv_byte       ; Get CRC MSB
                jc      rp_timeout

                mov     ax, MINIMUM_TICKS
                call    recv_byte_noack ; Get CRC LSB
                jc      rp_timeout

                cmp     cx, MAGIC_CRC   ; Check for CRC error
                jne     rp_crc_err

                mov     al, WACK        ; Acknowledge packet recieved
                out     dx, al
                mov     last_nib_received, bl
                inc     seq_num
                and     seq_num, SEQUENCE_BITS
                clc                     ; set success flag
                jmp     SHORT rp_exit

rp_crc_err:     inc     crc_errors      ; Increment CRC error counts
                DBG     '~'
                jmp     short rp_check_speed

rp_timeout::    call    clear_alarm_par
                DBG     '*'

rp_check_speed: cmp     fx_parallel_speed, PARALLEL_NORMAL
                je      rp_error

;--- Got an error at TURBO speed so retry at NORMAL speed.

                mov     fx_parallel_speed, PARALLEL_NORMAL
                DBG     ''
                mov     dx, port_address
                mov     al, WNAK
                out     dx, al
                mov     ax, 2 * MINIMUM_TICKS
                call    delay
                jmp     rp_proceed

rp_error:       mov     dx, port_address
                mov     al, WNAK        ; Set transition bit to a known state
                out     dx, al
                call    lost_connection

rp_fail:        stc

rp_exit:        call    end_packet
                ret

recv_normal:    mov     ticks_remaining, MINIMUM_TICKS
                mov     cs:code_list_ptr, DVR:rp_normal_list
                call    set_alarm_par   ; And there off. . .

rpn_loop:       

@@:             call    readStatus
rpn1::          jc      @B
                js      @B

                mov     bl, al          ; save low nibble
                mov     al, NOT WNAK    ; set transition bit
                out     dx, al          ; output transition
                shr     bl, 1           ; get lower nibble into its position
                shr     bl, 1           ; #### Replace with shr bl, 3 on 286
                shr     bl, 1
                mov     ticks_remaining, MINIMUM_TICKS

@@:             call    readStatus
rpn2::          jc      @B
                jns     @B

                mov     bh, al          ; save high nibble
                mov     al, WNAK        ; clear transition bit
                out     dx, al          ; Output transition
                shl     bh, 1           ; Position high nibble
                or      bl, bh          ; or nibbles together
                mov     al, bl          ; save byte in the buffer
                stosb
                xchg    ch, cl
                xor     cl, bl
                xor     bx, bx
                xchg    bl, cl
                shl     bx, 1
                xor     cx, crctab[bx]

                dec     si              ; Any bytes left to recieve?
rpn3::          jnz     rpn_loop

                call    clear_alarm_par ; Turn off the alarm clock
                jnc     recv_common

                jmp     rp_check_speed

rpn_timeout::   jmp     rp_timeout

recv_pack_parallel      ENDP


; save_parallel
;
save_parallel   PROC    NEAR

                push    bx
                mov     dx, port_address
                inc     dx
                inc     dx              ; Point to control register
                in      al, dx
                mov     ah, al          ; AH = original control port value
                xor     al, al
                out     dx, al          ; Write a 00 to control port
                recover
                recover
                in      al, dx
                mov     bl, al          ; Bits read to BL
                mov     al, 0FH
                out     dx, al          ; Write a 0F to control port
                recover
                recover
                in      al, dx
                xor     bl, al          ; BL = bits that changed
                or      bl, 0F0H
                and     bl, NOT DIRECTION_BIT
                mov     bh, 0CH

; BL = change bits.  If bit = 1, copy value from original port value in AH.
; If bit = 0, copy value from standard value in BH.

bit_loop:       shr     bl, 1
                jc      copy_old

                shr     ah, 1
                shr     bh, 1
                jmp     short copy

copy_old:       shr     bh, 1
                shr     ah, 1

copy:           rcr     al, 1
                or      bl, bl
                jnz     bit_loop

                mov     ah, al          ; Save desired control port value
                mov     al, 0CH         ; No Interrupts
                out     dx, al
                dec     dx
                dec     dx              ; Point to data register
                in      al, dx
                mov     WORD PTR save_area, ax   ; keep copy of original data
                pop     bx
                ret

save_parallel   ENDP



; reset_port_par  Reset the I/O port
;
;   Restores the port registers to there original values, restores any interrupt
;   vectors, and performs any other cleanup needed to release the current
;   communication port.  Essentially this routine undoes what init_port does.
;
;   Inputs:  None
;
;   Outputs: None
;
;   Destroys registers: AL, DX
;
;   extern void reset_port_par(void);
;
restore_parallel    PROC    NEAR

                mov     dx, port_address
                mov     ax, WORD PTR save_area
                out     dx, al          ; Restore original data
                add     dl, 2
                mov     al, ah
                out     dx, al          ; Restore original control
                ret

restore_parallel    ENDP


PARALLEL        ENDS


INIT            SEGMENT WORD PUBLIC 'CODE'


                PUBLIC  setup_ports_parallel
                PUBLIC  reset_ports_parallel

setup_ports_parallel    PROC    NEAR

                cmp     num_par_ports, 0
                je      setup_done

                mov     ax, 3500H + TIMER_INTERRUPT
                int     21H             ; Current timer vector -> par_timer_save
                mov     WORD PTR par_timer_save, bx
                mov     WORD PTR par_timer_save + 2, es
                mov     timer_jmp, DVR:timer_passthru_par
par_fixup3      EQU     $ - 2
                mov     dx, DVR:driver_timer_handler
par_fixup4      EQU     $ - 2
                mov     ax, 2500H + TIMER_INTERRUPT
                int     21H             ; Set timer vector to timer handler

setup_done:     ret

setup_ports_parallel    ENDP

reset_ports_parallel    PROC    NEAR

                cmp     num_par_ports, 0
                je      reset_done

                push    ds
                mov     ax, 2500H + TIMER_INTERRUPT
                lds     dx, par_timer_save
                int     21H
                pop     ds

reset_done:     ret

reset_ports_parallel    ENDP


INIT            ENDS

                END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\driver\drmain.asm ===
;***
;* $Workfile:   main.asm  $
;* $Revision:   1.5  $
;*   $Author:   Dave Sewell  $
;*     $Date:   08 Aug 1989 16:44:52  $
;***

                TITLE   Main program for driver when run as a .EXE file
                PAGE    66, 132

                INCLUDE drivers.mac
                INCLUDE packets.mac
                INCLUDE debug.mac

INIT            SEGMENT WORD PUBLIC 'CODE'
                EXTRN   print_msg:NEAR
                EXTRN   toupper:NEAR
                EXTRN   is_alpha:NEAR
                EXTRN   show_char:NEAR
                EXTRN   show_units:NEAR
                EXTRN   show_printers:NEAR
                EXTRN   signon:NEAR
                EXTRN   get_dos_version:NEAR
                EXTRN   show_crlf:NEAR
                EXTRN   connect:NEAR
                EXTRN   requires_dos3:BYTE
                EXTRN   m_not_installed:BYTE
                EXTRN   invalid_switch:BYTE
                EXTRN   doslink_help:BYTE
                EXTRN   m_drive_syntax:BYTE
                EXTRN   m_drive_map:BYTE
                EXTRN   m_client_letter:BYTE
                EXTRN   m_server_letter:BYTE
                EXTRN   m_not_connected:BYTE
                EXTRN   m_dl_ver_mismatch:BYTE
                EXTRN   show_drive_map:NEAR
                EXTRN   show_prn_map:NEAR
                EXTRN   m_lost_connect:BYTE
                EXTRN   device_high:BYTE
                EXTRN   init_size:WORD
                EXTRN   low_memory:BYTE
                EXTRN   driver_size:WORD
INIT            ENDS

BLOCK           SEGMENT WORD PUBLIC 'CODE'
                EXTRN   block_start:BYTE
                EXTRN   block_init_end:BYTE
BLOCK           ENDS

CORE            SEGMENT WORD PUBLIC 'CODE'
                EXTRN   end_low_stub:BYTE
                EXTRN   end_core_data:BYTE
                EXTRN   finger_print:BYTE
                EXTRN   major_version:WORD
                EXTRN   dos_major:BYTE
                EXTRN   strat_seg:WORD
                EXTRN   driver_call:DWORD
                EXTRN   drive_mapping:BYTE
                EXTRN   default_mapping:BYTE
                EXTRN   printer_loaded:BYTE
                EXTRN   first_unit:BYTE
                EXTRN   units:BYTE
                EXTRN   slave_units:BYTE
                EXTRN   is_serial:BYTE
                EXTRN   idle_semaphore:BYTE
                EXTRN   gri_proc:NEAR
CORE            ENDS

STACK           SEGMENT WORD STACK 'STACK'
                db      512 dup(?)
STACK           ENDS

MAIN            SEGMENT WORD PUBLIC 'CODE'

psp             dw      ?
help            db      0               ; Set to TRUE if help   display desired

startup         PROC    FAR

                cld
                push    cs
                pop     ds
                call    get_dos_version
                cmp     dos_major, 2
                ja      get_psp

                pmsg    requires_dos3
                jmp     short error_exit

get_psp:        mov     ah, 62H
                int     21H
                mov     cs:psp, bx      ; Save PSP and pass to show_help in BX
                call    show_help       ; Show help if requested
                jc      normal_exit     ; and exit if help was shown

                call    find_driver
                jc      error_exit

                call    parse_mappings
                jc      drive_syntax

                call    show_crlf
                call    connect         ; NOTE: turns off idling
                pushf
                call    reset_map       ; Reset default map.
                popf
                jnc     process_cmd     ; If connected, process command line

                pmsg    m_not_connected
                jmp     short error_exit

process_cmd:    call    show_drive_map
                jc      error_exit

                call    show_prn_map

normal_exit:    mov     idle_semaphore, MINIMUM_TICKS + 1   ; Turn on idling
                mov     ax, 4C00H       ; Terminate with code 0
                int     21H

drive_syntax:   pmsg    m_drive_syntax

error_exit:     mov     ax, 4C01H       ; Terminate with code 1
                int     21H

lost_connect:   pmsg    m_lost_connect
                jmp     error_exit

startup         ENDP

reset_map       PROC    NEAR

                push    ds
                pop     es
                mov     al, DONT_CARE
                mov     di, DVR:default_mapping
                mov     cx, MAX_DEVICES
            rep stosb
                ret

reset_map       ENDP

show_help       PROC    NEAR

; Enter with:
;   BX = PSP segment
; Return:
;   NC - Help was not requested (with "/?" on command line).
;   C  - Help was requested and displayed.

                mov     es, bx
                mov     si, 81H         ; Point ES:SI to cmd line in PSP

sh_loop:        mov     ax, es:[si]
                cmp     al, ' '
                jb      sh_no_help

                cmp     ax, "?/"
                jne     sh_next

                pmsg    doslink_help
                stc
                jmp     short sh_ret

sh_next:        inc     si
                jmp     sh_loop

sh_no_help:     clc

sh_ret:         ret

show_help       ENDP

local_drive     db      ?

parse_mappings  PROC    NEAR

                mov     es, cs:psp
                mov     si, 81H         ; Point ES:SI to cmd line in PSP

pm_grab_char:   mov     al, es:[si]
                call    toupper
                inc     si
                cmp     al, '/'
                je      skip_arg

                cmp     al, ','
                je      pm_grab_char

                cmp     al, ':'
                je      pm_grab_char

                cmp     al, ' '
                je      pm_grab_char

                jb      parse_ok

                call    is_alpha
                jc      parse_error

                sub     al, 'A'
                cmp     al, MAX_DEVICES
                jae     parse_error

                sub     al, first_unit
                mov     cs:local_drive, al

look_equal:     mov     al, es:[si]
                call    toupper
                cmp     al, ' '
                jb      parse_error

                inc     si

                cmp     al, ':'
                je      look_equal

                cmp     al, '='
                jne     parse_error

look_server:    mov     al, es:[si]
                call    toupper
                xor     bh, bh
                mov     bl, cs:local_drive
                cmp     al, ' '
                jbe     deassign

                cmp     al, ':'
                je      swallow_colon

                cmp     bl, units
                jae     parse_error

                call    is_alpha
                jc      deassign

                inc     si
                cmp     al, 'Z'
                ja      parse_error

                sub     al, 'A'

                mov     ah, UNASSIGNED
                mov     dx, ds
                call    delete_server
                jmp     short store_mapping

deassign:       mov     al, UNASSIGNED

store_mapping:  mov     drive_mapping[bx], al
                mov     default_mapping[bx], al
                jmp     pm_grab_char

swallow_colon:  inc     si
                jmp     look_server

skip_arg:       mov     al, es:[si]
                cmp     al, ' '
                je      pm_grab_char

                jb      parse_ok

                inc     si
                jmp     skip_arg

parse_error:    stc
                jmp     short pm_parse_exit

parse_ok:       clc

pm_parse_exit:  ret

parse_mappings  ENDP

delete_server   PROC    NEAR

; Enter with:
;   AL = server drive letter
;   AH = replacement value if found (DONT_CARE or UNASSIGNED)
;   DX = segment of map table

                push    cx
                push    di
                push    es
                mov     es, dx
                mov     di, DVR:drive_mapping
                mov     cx, MAX_DEVICES

        repne   scasb
                jne     del_done

                mov     BYTE PTR es:[di - 1], ah

del_done:       pop     es
                pop     di
                pop     cx
                ret

delete_server   ENDP


find_driver     PROC    NEAR

                mov     ax, 352FH
                int     21H
                mov     ax, es
                or      ax, bx
                jz      not_found

                mov     ax, (INTERLNK_MULTIPLEX_ID SHL 8) OR 0
                mov     bl, 0
                mov     dx, 0FFFFH
                int     2FH
                cmp     al, 0FFH
                jne     not_found

                cmp     dx, 0FFFFH
                je      not_found

                mov     es, dx
                mov     si, DVR:finger_print
                mov     di, si
                mov     cx, 8
        repe    cmpsb
                je      found

not_found:      pmsg    m_not_installed

fd_show_prog:   call    print_prog_name
                call    show_crlf
                stc
                jmp     short find_ret

found:          cmp     WORD PTR es:major_version, (MAJOR_VER OR (MINOR_VER SHL 8))
                je      same_version

                pmsg    m_dl_ver_mismatch
                jmp     fd_show_prog

same_version:   mov     ds, es:strat_seg
                clc

find_ret:       ret

find_driver     ENDP

IFDEF DEBUG
show_hex_byte   PROC    NEAR

                push    ax
                push    cx
                push    dx
                mov     cl, 4
                shl     ax, cl
                shr     al, cl
                and     ax, 0F0FH
                mov     dl, ah
                call    show_hex_nibble
                mov     dl, al
                call    show_hex_nibble
                mov     dl, ' '
                call    show_char
                pop     dx
                pop     cx
                pop     ax
                ret

show_hex_byte   ENDP

show_hex_nibble PROC    NEAR

                add     dl, '0'
                cmp     dl, '9'
                jbe     show_nibble

                add     dl, 7

show_nibble:    call    show_char
                ret

show_hex_nibble ENDP
ENDIF

print_prog_name PROC    NEAR

                mov     es, cs:psp
                mov     es, es:[2CH]    ;Get segment of environment
                xor     di, di
                xor     ax, ax
                mov     cx, 8000H

scan_end: repne scasb
                scasb
                jne     scan_end

                inc     di
                inc     di

print_prog:     mov     dl, es:[di]
                mov     ah, 6
                int     21H
                inc     di
                or      al, al
                jnz     print_prog

                ret

print_prog_name ENDP

MAIN            ENDS

                END     startup
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\driver\block.asm ===
;***
;* $Workfile:   block.asm  $
;* $Revision:   1.5  $
;*   $Author:   Dave Sewell  $
;*     $Date:   08 Aug 1989 16:44:52  $
;***

                TITLE   Permanent device driver code and data
                PAGE    66, 132
                
                INCLUDE drivers.mac
                INCLUDE packets.mac
                INCLUDE debug.mac

                SUBTTL  MS-DOS device driver definitions
                PAGE

DOS30           EQU (3 SHL 8) + 30      ; MS-DOS 3.30 word format version number
DOS331          EQU (3 SHL 8) + 31      ; MS-DOS 3.31 word format version number
DOS40           EQU (4 SHL 8) + 00      ; MS-DOS 4.00 word format version number
DOS50           EQU (5 SHL 8) + 00      ; MS-DOS 5.00 word format version number


CORE            SEGMENT WORD PUBLIC 'CODE'
                EXTRN   header:BYTE
                EXTRN   init_size:WORD
                EXTRN   strat_seg:WORD
                EXTRN   header_seg:WORD
                EXTRN   crctab:WORD
                EXTRN   dos_version:WORD
                EXTRN   dos_minor:BYTE
                EXTRN   dos_major:BYTE
                EXTRN   slave_dos_version:WORD
                EXTRN   slave_dos_minor:BYTE
                EXTRN   slave_dos_major:BYTE
                EXTRN   busy_semaphore:BYTE
                EXTRN   idle_semaphore:BYTE
                EXTRN   is_serial:BYTE
                EXTRN   win386_enh_mode:BYTE
                EXTRN   int2f_ok:BYTE
                EXTRN   send_pack:WORD
                EXTRN   recv_pack:WORD
                EXTRN   send_sync:WORD
                EXTRN   get_remote_info:WORD
                EXTRN   rhptr:DWORD
                EXTRN   packet_buf:BYTE
                EXTRN   default_units:BYTE
                EXTRN   first_unit:BYTE
                EXTRN   slave_units:BYTE
                EXTRN   initialized:BYTE
                EXTRN   port_address:WORD
                EXTRN   drive_mapping:BYTE
                EXTRN   dd_attributes:WORD
                EXTRN   invalid:BYTE
                EXTRN   device_id:BYTE
                EXTRN   actual_prn_map:BYTE
        IFDEF DEBUG
                EXTRN   hex_out:WORD
                EXTRN   debug_msg:WORD
        ENDIF
CORE            ENDS

INIT            SEGMENT WORD PUBLIC 'CODE'
                EXTRN   initialize:NEAR
                EXTRN   init_end:BYTE
INIT            ENDS


BLOCK           SEGMENT WORD PUBLIC 'CODE'
                PUBLIC  intr
                PUBLIC  block_start
                PUBLIC  intr_vector
                PUBLIC  block_init_end
                PUBLIC  max_devices
                PUBLIC  units
                PUBLIC  max_secsize
                PUBLIC  dispatch
                PUBLIC  bpb_array
                PUBLIC  bpb_pnt_array
                PUBLIC  unmapped_unit
                PUBLIC  lpt_dispatch
                PUBLIC  lpt_unused

                ORG     0

block_start     LABEL   BYTE

MAX_LPT_BUFF    EQU     64

save_sp         dw      ?               ; save area for DOS stack
save_ss         dw      ?

; Device driver stack.  If debugging, the device driver stack has words
; 1234H and 4321H on the top and bottom.  These are used in debugging to
; check for stack overflows and under flows.  They have no other purpose.
; The stack must be aligned on an even boundry.

                EVEN

IFDEF   DEBUG
                dw      1234H           ; Start of stack has a 1234H
ENDIF
                db      STACK_SIZE dup (0)
stack_end:
IFDEF   DEBUG
                dw      4321H           ; End of stack always 4321H
ENDIF

lpt_buff        db      MAX_LPT_BUFF dup(0)
lpt_count       dw      0
lpt_write_count dw      0
lpt_buffering   db      0


intr            PROC    FAR             ; device driver "Interrupt" routine

                pushf                   ; Save flags
                cli                     ; Disable until switch to larger stack
                cld                     ; Set direction flag to UP
                push    ds              ; Save all registers
                push    es
                push    bx
                mov     bx, cs          ; make local data addressable
                mov     ds, bx
                mov     bl, 0FFH
                xchg    busy_semaphore, bl
                or      bl, bl
                jnz     intr_busy
 
                push    cx
                push    dx
                push    di
                push    si
                push    bp
                mov     device_id, al   ; Save device ID passed in AL
                mov     save_sp, sp     ; save old stack location
                mov     save_ss, ss
                mov     bx, cs
                mov     ss, bx          ; Interrupts must be disabled--in case
                mov     sp, DVR:stack_end   ; we're on an old 8088/8086!
                sti                     ; ok to turn interrupts back on now

                call    initialize      ; Call address get modified!!
        intr_vector     EQU     $ - 2

                mov     busy_semaphore, 0
                cli                     ; Just in case an old 8088/8086
                mov     ss, save_ss     ; restore the old stack
                mov     sp, save_sp
                pop     bp
                pop     si
                pop     di
                pop     dx
                pop     cx
                jmp     short intr_restore

intr_busy:      les     bx, rhptr
                mov     es:[bx].static_rhp.rhp_status, STATUS_ERROR OR STATUS_DONE OR ERR_NOT_READY

intr_restore:   pop     bx
                pop     es
                pop     ds
                popf
                pop     ax
                ret                     ; return (far) to MS-DOS

intr            ENDP

; units         This is the number of logical devices supported by the driver.
;
units           db  0                   ; Number of devices

;==== Above here is the core portion of BLOCK which is always loaded =====

block_init_end  LABEL   BYTE

; max_devices   This is the maximum number of devices ever allowed by the
;               the driver, reguardless of the default units.
;
max_devices     db  MAX_DEVICES         ; Maximum number of devices allowed

max_secsize     dw      ?               ; Maximum sector size for driver

; bpb_pnt_array is the array of offsets to the BPBs addressed by the unit
; number in the RHP.
;
bpb_pnt_array   LABEL   WORD            ; Array of offsets to the BPBs
        CNT = 0
        REPT    MAX_DEVICES
                dw      DVR:bpb_array + CNT
            CNT = CNT + TYPE bios_parameter_block
        ENDM

mapped_unit     dw  ?                       ; Device number on slave system

unmapped_unit   dw  ?                       ; Unit on master system

vol_ser_buff    db      MAX_VOLUME DUP (0)  ; Safe area for volume label
                dd      0                   ; and serial number

comm_start_time dw      ?
handler_index   dw      ?

handler_value   LABEL   BYTE
                db      'i'                 ;  0 = initialize driver
                db      'm'                 ;  1 = media check on block device
                db      'b'                 ;  2 = build BIOS parameter Block
                db      'o'                 ;  3 = I/O control read
                db      'r'                 ;  4 = read input from device
                db      'n'                 ;  5 = non-destructive read
                db      '6'                 ;  6 = return current input status
                db      'f'                 ;  7 = flush device input buffers
                db      'w'                 ;  8 = write (output) to device
                db      'v'                 ;  9 = write with verify
                db      'O'                 ; 10 = return current output status
                db      'B'                 ; 11 = flush output buffers
                db      'W'                 ; 12 = I/O control write
                db      'd'                 ; 13 = device open
                db      'D'                 ; 14 = device close
                db      'r'                 ; 15 = removable media
                db      'u'                 ; 16 = output until busy
                db      '7'                 ; 17 = not used
                db      '8'                 ; 18 = not used
                db      'g'                 ; 19 = generic IOCTL
                db      '0'                 ; 20 = not used
                db      '1'                 ; 21 = not used
                db      '2'                 ; 22 = not used
                db      'l'                 ; 23 = get logical device
                db      'L'                 ; 24 = set logical device
                db      '?'                 ; Invalid commands


;*** The table below corresponds to the dispatch table below it.  A non-zero
;*** value in this table means the handler needs to communicate with the
;*** remote system.  It also contains the size of the request header packet
;*** which should be saved and restored when retries are necessary.  Doing
;*** this allows the lower level routines to modify the request header fields
;*** as necessary without worrying about messing up retries.

;*** IMPORTANT NOTE:  The buffer below MUST be at least as large as the largest
;*** number in the table below it.

rhp_size        LABEL   BYTE
                db      0                   ;  0 = initialize driver
                db      14                  ;  1 = media check on block device
                db      16                  ;  2 = build BIOS parameter Block
                db      0                   ;  3 = I/O control read
                db      28                  ;  4 = read input from device
                db      0                   ;  5 = non-destructive read
                db      0                   ;  6 = return current input status
                db      0                   ;  7 = flush device input buffers
                db      22                  ;  8 = write (output) to device
                db      22                  ;  9 = write with verify
                db      0                   ; 10 = return current output status
                db      0                   ; 11 = flush output buffers
                db      0                   ; 12 = I/O control write
                db      3                   ; 13 = device open
                db      3                   ; 14 = device close
                db      0                   ; 15 = removable media
                db      0                   ; 16 = output until busy
                db      0                   ; 17 = not used
                db      0                   ; 18 = not used
                db      23                  ; 19 = generic IOCTL
                db      0                   ; 20 = not used
                db      0                   ; 21 = not used
                db      0                   ; 22 = not used
                db      0                   ; 23 = get logical device
                db      0                   ; 24 = set logical device
                db      0                   ; Invalid commands

                EVEN

dispatch        LABEL   WORD                ; Interrupt routine command-code
                                            ; dispatch table
                dw      DVR:init_block      ;  0 = inititalize driver
                dw      DVR:media_check     ;  1 = media check on block device
                dw      DVR:build_bpb       ;  2 = build BIOS parameter Block
                dw      DVR:unused          ;  3 = I/O control read
                dw      DVR:read            ;  4 = read input from device
                dw      DVR:unused          ;  5 = non-destructive read
                dw      DVR:unused          ;  6 = return current input status
                dw      DVR:unused          ;  7 = flush device input buffers
                dw      DVR:write           ;  8 = write (output) to device
                dw      DVR:write_verify    ;  9 = write with verify
                dw      DVR:unused          ; 10 = return current output status
                dw      DVR:unused          ; 11 = flush output buffers
                dw      DVR:unused          ; 12 = I/O control write
                dw      DVR:device_open     ; 13 = device open
                dw      DVR:device_close    ; 14 = device close
                dw      DVR:removable_media ; 15 = removable media
                dw      DVR:unused          ; 16 = output until busy

                                            ; commands below are for MS-DOS 3.2+
                dw      0                   ; 17 = not used
                dw      0                   ; 18 = not used
                dw      DVR:generic_ioctl   ; 19 = generic IOCTL
                dw      0                   ; 20 = not used
                dw      0                   ; 21 = not used
                dw      0                   ; 22 = not used
                dw      0                   ; 23 = get logical device
                dw      0                   ; 24 = set logical device

lpt_dispatch    LABEL   WORD                ; Interrupt routine command-code
                                            ; dispatch table
                dw      DVR:init_char       ;  0 = inititalize driver
                dw      0                   ;  1 = media check on block device
                dw      0                   ;  2 = build BIOS parameter Block
                dw      0                   ;  3 = I/O control read
                dw      0                   ;  4 = read input from device
                dw      0                   ;  5 = non-destructive read
                dw      0                   ;  6 = return current input status
                dw      0                   ;  7 = flush device input buffers
                dw      DVR:lpt_write       ;  8 = write (output) to device
                dw      DVR:lpt_write       ;  9 = write with verify
                dw      DVR:output_status   ; 10 = return current output status
                dw      DVR:flush_output    ; 11 = flush output buffers
                dw      0                   ; 12 = I/O control write
                dw      DVR:lpt_dev_open    ; 13 = device open
                dw      DVR:lpt_dev_close   ; 14 = device close
                dw      0                   ; 15 = removable media
                dw      0                   ; 16 = output until busy

IFDEF DEBUG
print_sector    PROC    NEAR

                push    ax
                push    bx
                push    dx
                mov     bx, handler_index
                mov     al, handler_value[bx]
                cmp     al, 'r'
                je      print

                cmp     al, 'w'
                jne     print_done

print:          xor     dx, dx
                mov     ax, es:[di].io_req.io_start
                cmp     ax, 0FFFFH
                jne     print_high

                mov     ax, word ptr es:[di].io_req.io_huge_start
                mov     dx, word ptr es:[di].io_req.io_huge_start + 2

print_high:     or      dx, dx
                jz      print_low

                HEX     dh
                HEX     dl

print_low:      or      dh, dl
                or      dh, ah
                jz      @F

                HEX     ah

@@:             HEX     al
                mov     ax, es:[di].io_req.io_requested
                cmp     ax, 1
                je      print_done

                DBG     ','
                or      ah, ah
                jz      low_length

                HEX     ah

low_length:     HEX     al

print_done:     pop     dx
                pop     bx
                pop     ax
                ret

print_sector    ENDP
ENDIF

normal_intr     PROC    NEAR
                PUBLIC  normal_intr

                les     di, rhptr           ; es:di = request header ptr
                mov     bl, es:[di].static_rhp.rhp_command
                xor     bh, bh              ; bx = driver subfunction

                cmp     device_id, 0
                jne     lpt_driver

                mov     al, handler_value[bx]
                DBG     al
                cmp     bl, 24
                ja      invalid_cmd

                shl     bx, 1
                cmp     dispatch[bx], 0
                je      invalid_cmd

                shr     bx, 1
                call    handler
                jmp     short handler_done

lpt_driver:     cmp     bl, 16
                ja      invalid_cmd

                mov     al, handler_value[bx]
                DBG     al
                shl     bx, 1
                cmp     lpt_dispatch[bx], 0
                je      invalid_cmd

                shr     bx, 1
                call    lpt_handler
                jmp     short handler_done

invalid_cmd:    mov     ax, STATUS_ERROR OR ERR_UNK_COMMAND

handler_done:   or      ax, STATUS_DONE     ; set the done bit
                mov     idle_semaphore, MINIMUM_TICKS + 1
                les     di, rhptr
                mov     es:[di].static_rhp.rhp_status, ax
                ret

normal_intr     ENDP

handler         PROC    NEAR

                mov     handler_index, bx
                cmp     bl, 19          ; Generic IOCTL?
                jne     @F

;--- For generic IOCTL, bypass connection attempt unless function == 46H or 66H

                les     di, rhptr
                mov     al, es:[di].gen_ioctl_req.gen_function
                cmp     al, 46H
                je      @F

                cmp     al, 66H
                jne     call_handler

@@:             cmp     rhp_size[bx], 0
                je      call_handler
    IFDEF DEBUG
                call    print_sector
    ENDIF

                cmp     port_address, 0
                jne     call_handler

                call    send_sync       ; Insure we are connected
                jc      not_ready

                call    get_remote_info ; Insure we are initialized.
                jc      not_ready

call_handler:   mov     bx, handler_index
                shl     bx, 1           ; form index to dispatch table
                les     di, rhptr
                call    dispatch[bx]    ; Call the handler
                cmp     port_address, 0
                jne     handler_ret

                mov     bx, handler_index
                cmp     rhp_size[bx], 0
                je      handler_ret

not_ready:      mov     ax, STATUS_ERROR OR ERR_NOT_READY

;--- NOTE: If a write, or write-verify request fails due to a
;--- communications problem, we must insure the transfer count is zeroed.

                mov     bx, handler_index
                cmp     bl, 4
                je      rd_wr_fail

                cmp     bl, 8
                je      rd_wr_fail

                cmp     bl, 9
                jne     handler_ret

rd_wr_fail:     les     di, rhptr
                mov     es:[di].io_ans.io_transfered, 0

handler_ret:    ret

handler         ENDP


lpt_handler     PROC    NEAR

                mov     handler_index, bx
                cmp     rhp_size[bx], 0
                je      call_handler

                cmp     port_address, 0
                jne     call_handler

                call    send_sync           ; Insure we are connected
                jc      not_ready

                call    get_remote_info     ; Insure we are initialized.
                jc      not_ready

call_handler:   mov     bx, handler_index
                shl     bx, 1               ; form index to dispatch table
                les     di, rhptr
                call    lpt_dispatch[bx]    ; Call the handler
                cmp     port_address, 0
                jne     handler_ret

                mov     bx, handler_index
                cmp     rhp_size[bx], 0
                je      handler_ret

not_ready:      mov     ax, STATUS_ERROR OR ERR_NOT_READY
                mov     bx, handler_index

;--- NOTE: Always return success for device_open and device_close to get 
;--- around problem with CHCP command.

                cmp     bl, 13
                je      open_close_ok

                cmp     bl, 14
                je      open_close_ok

;--- NOTE: If a read, write, or write-verify request fails due to a
;--- communications problem, we must insure the transfer count is zeroed.
                
                cmp     bl, 8
                je      wr_fail

                cmp     bl, 9
                jne     handler_ret

wr_fail:        les     di, rhptr
                mov     es:[di].io_ans.io_transfered, 0
                jmp     short handler_ret

open_close_ok:  xor     ax, ax

handler_ret:    ret

lpt_handler     ENDP


; error_packet -- This routine sends an error packet to the remote system.
; Any communication errors are ignored.
;
; Inputs:
;   ah              error code
;   mapped_unit     Mapped unit number
;   unmapped_unit   Unit number passed in from DOS
;
; Outputs: none
;
; Destroys all registers
;
error_packet    PROC    NEAR

                mov     packet_buf.common_packet.packet_type, ERROR_REQ
                                        ; Set up media check request packet
                mov     packet_buf.error_r.err_code, ah
                mov     packet_buf.error_r.err_block_dvr, 0FFH

                mov     al, BYTE PTR unmapped_unit
                mov     packet_buf.error_r.err_unit, al
                mov     al, BYTE PTR mapped_unit
                mov     packet_buf.error_r.err_data, al

                mov     cx, TYPE error_r ; Set up send pack parameters
                mov     si, DVR:packet_buf
                push    ds
                pop     es              ; es:si, cx = packet

                call    send_pack       ; Ignore errors

                ret

error_packet    ENDP



; map_unit  converts the masters unit number into the slaves device number
;           checking for invalid units
;
; Inputs:
;   es:di           pointer to request header packet (with valid rhp_unit)
;   units           number of units on master system
;   slave_units     number of block devices on slave system
;   drive_mapping   translation table
;
; Outputs:
;   CF              Clear if unit is OK
;                   Set if invalid unit number 
;                   If error, AX is also set to STATUS_ERROR OR ERR_UNK_UNIT
;   mapped_unit     The translated unit number (WORD)
;   unmapped_unit   The masters unit number (WORD)
;   ax              same as mapped_unit
;   bx              same as unmapped_unit
;
; Destroys registers: ax, bx
;
map_unit        PROC    NEAR

                mov     bl, es:[di].static_rhp.rhp_unit
                cmp     bl, units       ; See if valid unit number
                jae     mu_unknown

                xor     bh, bh          ; bx = master unit number
                mov     al, drive_mapping[bx]
                and     al, 7FH         ; And off write protect
                cmp     al, slave_units ; See if valid slave unit number
                jae     mu_unknown

                xor     ah, ah
                mov     mapped_unit, ax ; keep track of unit numbers
                mov     unmapped_unit, bx

                clc
                ret

mu_unknown:     stc
                mov     ax, STATUS_ERROR OR ERR_UNK_UNIT
                ret

map_unit        ENDP

; convert_start_sector  Convert requested sector number into appropriate format
;                       for slave system.
;   Inputs:
;       es:di       Pointer to current request header packet
;       mapped_unit Unit number on the slave system
;
;   Outputs:
;       packet_buf.io_r.ior_start       16 bit start packet value
;       packet_buf.io_r.ior_huge_start  32 bit start packet value
;
;   Uses registers: ax, bx, cx, dx
;   
convert_start_sector    PROC    NEAR

                ; Now get the 16 bit start sector into cx and the 32 bit start
                ; sector into dx,ax

                cmp     dos_version, DOS331
                ja      css_dos40
                je      css_dos331

                mov     cx, es:[di].io_req.io_start
                mov     ax, cx
                xor     dx, dx
                jmp     SHORT css_convert

css_dos331:     mov     cx, es:[di].io_req.io_start
                mov     ax, cx
                mov     dx, es:[di].io_req.io_start_high
                jmp     SHORT css_convert

css_dos40:      mov     ax, WORD PTR es:[di].io_req.io_huge_start
                mov     dx, WORD PTR es:[di].io_req.io_huge_start + 2
                mov     cx, ax

css_convert:    ; Now find out if we need to stuff a FFFF in for the 16 bit
                ; sector number (DOS 4.0 HUGE media only)

                cmp     slave_dos_version, DOS331
                jbe     load_start

                mov     bx, mapped_unit ; Get device driver attributes
                shl     bx, 1
                test    dd_attributes[bx], ATT_HUGE
                jz      load_start

                mov     cx, 0FFFFH

                ; Now put the values into the ior packet

load_start:     mov     packet_buf.io_r.ior_start, cx
                mov     WORD PTR packet_buf.io_r.ior_huge_start, ax
                mov     WORD PTR packet_buf.io_r.ior_huge_start + 2, dx

                ret

convert_start_sector    ENDP

; check_unit -- Check for valid unit number
;   Inputs:
;       initialized         Current initialization state
;       rhptr               Seg:Off of reequest header packet
;
;   Outputs:
;       CF                  Set if unit number ok
;                           Clear if invalid unit number
;       AX                  If invalid unit or not initialized,
;                               STATUS_ERROR OR <appropriate critical error>
;                           If valid unit, ax = undefined
;
;       packet_buf.master_id Set to master code if unit is ok (most routines
;                           need to set this anyway, so it saves a little code
;                           to set it here).
;
;       initialized         Set if communications are established
;
;   If driver has not been initialized (communications established with remote)
;   get_remote_info will be called.  So all of the inputs of get_remote_info
;   need to be set before calling this routine (they should have been
;   calculated in initialize).  Also, the outputs of get_remote_info will be
;   set (overwriting the default information).
;
;   Registers destroyed: ALL
;
;   This function first checks to see if communications have been initialized.
;
;   Once communcations have been initialized, the unit for the request is
;   verified.  First, it must be a valid unit number (x < units) and the
;   CHARACTER bit must be clear in the device attribute word.  build_bpb sets
;   ATT_CHARACTER if the master system is going to have a problem reading this
;   device (the device has HUGE sectors and the master's DOS version is before
;   4.00 or 16-bit fat table entries and the master's DOS version is before
;   3.00, or the devices sector size is to big).
;
;
check_unit      PROC    NEAR            ; Check unit number

    ; Check the unit for which I/O is being requested.

                les     di, rhptr
                call    map_unit        ; ax = mapped unit, bx = unmapped unit
                jc      cu_error

                shl     ax, 1           ; ax = offset in attribute list
                mov     bx, ax
                mov     bx, dd_attributes[bx] ; bx = device's driver attribute
                test    bx, ATT_CHARACTER
                jz      stuff_code

                mov     ah, ER_BAD_MEDIA
                call    error_packet    ; Send a bad media packet

                mov     ax, STATUS_ERROR OR ERR_UNK_MEDIA
                jmp     SHORT cu_error

stuff_code:     clc                     ; Set success flag
                ret

cu_error:       stc                     ; Set fail flag
                ret

check_unit      ENDP


; copy_label    Copies a volume label from a packet to a safe place in the
;               driver
; Inputs:
;
; Outputs: none
;
; Uses registers si, es:di, cx
;

copy_label      PROC    NEAR

                mov     cx, MAX_VOLUME + 4  ; add 4 for vol id number
                push    ds
                pop     es              ; es:di = safe place to store label
                mov     di, DVR:vol_ser_buff
            rep movsb                   ; copy the label
                les     di, rhptr
                ret

copy_label      ENDP

                SUBTTL  Subfunction handlers
                PAGE

COMMENT @
    Command code subfunctions follow:
        Inputs:     es:di   - Points to the request header packet
        Outputs:    ax      - 0 if function completed succesfully
                            - STATUS_ERROR OR (error code) if error condition

        Registers need not be preserved.
@

media_check     PROC    NEAR            ; function 1 = Media Check

                call    check_unit      ; Check for errors & send sync
                jc      mc_exit

                les     di, rhptr       ; es:di -> request header packet
                mov     packet_buf.common_packet.packet_type, MEDIA_CHECK_REQ
                                        ; Set up media check request packet
                mov     al, BYTE PTR mapped_unit
                mov     packet_buf.media_check_r.mcr_unit, al

                mov     al, es:[di].media_check_req.media_id
                mov     packet_buf.media_check_r.mcr_media_id, al

                mov     cx, TYPE media_check_r  ; Set up send pack parameters
                mov     si, DVR:packet_buf
                push    ds
                pop     es              ; es:si, cx = packet
                call    send_pack
                jc      mc_error

                mov     di, DVR:packet_buf
                mov     cx, MAX_PACKET
                call    recv_pack       ; receive media check answer
                jc      mc_error

                les     di, rhptr       ; Now setup return packet
                mov     al, packet_buf.media_check_a.mca_changed
                mov     si, DVR:packet_buf.media_check_a.mca_volume
                call    copy_label              ; Copy label from server

                mov     bx, unmapped_unit
                test    invalid[bx], 0FFH
                jz      mc_store_mc     ; See if invalid flag set

                mov     al, MEDIA_CHANGED ; If unit invalid, force media changed

mc_store_mc:    mov     es:[di].media_check_ans.media_changed, al
                cmp     al, MEDIA_CHANGED
                jne     mc_status

                mov     WORD PTR es:[di].media_check_ans.media_label, DVR:vol_ser_buff
                mov     WORD PTR es:[di].media_check_ans.media_label + 2, ds

mc_status:      mov     ax, packet_buf.media_check_a.mca_status
                jmp     short mc_exit

mc_error:       mov     ax, STATUS_ERROR OR ERR_NOT_READY

mc_exit:        ret

media_check     ENDP


build_bpb       PROC    NEAR            ; function 2 = Build BIOS param block

                call    check_unit
                jc      bb_exit

                les     di, rhptr       ; es:di -> request header packet
                mov     packet_buf.common_packet.packet_type, BUILD_BPB_REQ
                mov     al, BYTE PTR mapped_unit
                mov     packet_buf.build_bpb_r.bbr_unit, al
                mov     al, es:[di].build_bpb_req.media_id
                mov     packet_buf.build_bpb_r.bbr_media_id, al
                mov     cx, TYPE build_bpb_r    ; set up send pack parameters
                mov     si, DVR:packet_buf
                push    ds
                pop     es                  ; es:si, cx = packet
                call    send_pack
                jc      bb_error

                mov     di, DVR:packet_buf
                mov     cx, MAX_PACKET  ; es:di, cx -> recieve area
                call    recv_pack
                jnc     bb_ok

bb_error:       mov     ax, STATUS_ERROR OR ERR_NOT_READY
                jmp     short bb_exit

bb_ok:          les     di, rhptr                   ; Now setup return packet
                mov     bx, unmapped_unit
                shl     bx, 1                       ; bx = unit * 2
                mov     bx, bpb_pnt_array[bx]       ; bx = offset of units bpb
                mov     WORD PTR es:[di].build_bpb_ans.bpb_bpb, bx
                mov     WORD PTR es:[di].build_bpb_ans.bpb_bpb + 2, ds
                test    packet_buf.build_bpb_a.bba_status, STATUS_ERROR
                jnz     bb_status                   ; On error, skip copying BPB

                push    ds                          ; Get ready for block move
                pop     es                          ; es:di = dest. for BPB
                mov     di, bx
                mov     si, DVR:packet_buf.build_bpb_a.bba_bpb  ; ds:si = bpb address in packet
                mov     cx, TYPE bios_parameter_block
            rep movsb
                mov     bx, unmapped_unit
                mov     invalid[bx], 0              ; Clear invalid flag

    ; Now check the media for unusable types.
    ; bad media if  32-bit sectors and not DOS 3.31+, 
    ; or devices sector size greater than masters maximum sector size

                mov     si, packet_buf.build_bpb_a.bba_bpb.bytes_per_sector
                cmp     si, max_secsize ; devices sector size is larger than
                ja      bb_bad_media    ; maximum sector size -> bad media

                mov     bx, packet_buf.build_bpb_a.bba_bpb.total_sectors
                or      bx, bx          ; Check for 32 bit sector addressing
                jnz     bb_status       ; No - we're OK then

                cmp     dos_version, DOS331 ; Yes - require DOS 3.31 or later
                jb      bb_bad_media    ; dos_version < MS-DOS 3.31 -> bad media

    ; Note: MS-DOS 3.31 can address 32-bit sectors, but the format of the
    ; RHP is different than DOS 4.0.

                cmp     slave_dos_version, DOS331
                jae     bb_status

bb_bad_media:   mov     bx, mapped_unit
                shl     bx, 1           ; si = offset of attribute word
                or      dd_attributes[bx], ATT_CHARACTER
                                        ; Flag device as having incompatable media
                mov     ax, STATUS_ERROR OR ERR_UNK_MEDIA
                ret

bb_status:      mov     ax, packet_buf.build_bpb_a.bba_status

bb_exit:        ret

build_bpb       ENDP

check_data_len  PROC    NEAR

; Enter with:
;       AX = # of sectors to read or write
; Return:
;    DX:AX = # of bytes to read or write
;       CX = copy of final AX value
;       BX = bytes per sector from BPB
;       NC - success if DX:CX != 00000H and DX:CX <= 10000H
;        C - failure (bad count)

                mov     bx, unmapped_unit
                shl     bx, 1           ; bx = unit * 2
                mov     bx, bpb_pnt_array[bx]       ; bx = offset of units bpb
                mov     bx, [bx].bios_parameter_block.bytes_per_sector   ; bx = length of one sector
                mul     bx              ; dx:ax = bytes to transfer
                mov     cx, ax
                jcxz    check_64k

                or      dx, dx
                jnz     bad_length

                jmp     short check_ok

check_64k:      cmp     dx, 1           ; If CX == 0, DX must equal 1
                je      check_ok

bad_length:     stc
                jmp     short check_ret

check_ok:       clc

check_ret:      ret

check_data_len  ENDP


read_count      dw      ?

read            PROC    NEAR            ; function 4 = read (input)

                call    check_unit
                jc      rd_err_exit

                les     di, rhptr       ; es:di -> request header packet
                mov     packet_buf.common_packet.packet_type, READ_REQ
                mov     al, BYTE PTR mapped_unit
                mov     packet_buf.io_r.ior_unit, al
                mov     al, es:[di].io_req.media_id
                mov     packet_buf.io_r.ior_media_id, al
                mov     ax, es:[di].io_req.io_requested
                or      ax, ax
                jz      rd_bad_length

                mov     packet_buf.io_r.ior_requested, ax
                call    convert_start_sector    ; Convert sector numbers
                mov     cx, TYPE io_r   ; set up send pack parameters
                mov     si, DVR:packet_buf
                push    ds
                pop     es            ; es:si, cx = packet
                call    send_pack
                jc      rd_error

                mov     di, DVR:packet_buf
                mov     cx, MAX_PACKET
                call    recv_pack
                jc      rd_error

                les     di, rhptr
                mov     ax, packet_buf.io_a.ioa_status
                cmp     al, ERR_DISK_CHANGE
                jne     check_count

                mov     si, DVR:packet_buf.io_a.ioa_volume
                call    copy_label      ; Get the label into a safe place
                mov     WORD PTR es:[di].io_ans.io_label, DVR:vol_ser_buff
                mov     WORD PTR es:[di].io_ans.io_label + 2, ds

check_count:    mov     ax, packet_buf.io_a.ioa_transfered
                mov     read_count, ax
                or      ax, ax          ; see if anything transfered
                jz      rd_done

                cmp     ax, es:[di].io_req.io_requested
                ja      rd_bad_length

                call    check_data_len
                jc      rd_bad_length

                les     di, es:[di].io_req.io_data
                call    recv_pack
                jc      rd_error

rd_done:        les     di, rhptr
                mov     ax, read_count
                mov     es:[di].io_ans.io_transfered, ax
                mov     ax, packet_buf.io_a.ioa_status
                ret

rd_bad_length:  mov     ax, STATUS_ERROR OR ERR_READ_FAULT
                jmp     short rd_err_exit

rd_error:       mov     ax, STATUS_ERROR OR ERR_NOT_READY

rd_err_exit:    les     di, rhptr       ; Error in transfer
                mov     es:[di].io_ans.io_transfered, 0    ; set NO data transfered

rd_exit:        ret

read            ENDP


write           PROC    NEAR            ; function 8 = Write (output)
write_verify    LABEL   PROC            ; function 9 = Write with verify

                mov     bl, es:[di].static_rhp.rhp_unit
                xor     bh, bh          ; See if device is write protected!
                test    drive_mapping[bx], 80H
                jz      not_wr_prot

                mov     ax, STATUS_ERROR OR ERR_WRITE_PROT
                jmp     wr_err_exit

not_wr_prot:    call    check_unit
                jc      wr_err_exit

                les     di, rhptr       ; es:di -> request header packet
                mov     packet_buf.common_packet.packet_type, WRITE_REQ
                cmp     es:[di].static_rhp.rhp_command, WRITE
                je      @F

                mov     packet_buf.common_packet.packet_type, WRITE_VER_REQ

@@:             mov     al, BYTE PTR mapped_unit
                mov     packet_buf.io_r.ior_unit, al
                mov     al, es:[di].io_req.media_id
                mov     packet_buf.io_r.ior_media_id, al
                mov     ax, es:[di].io_req.io_requested
                mov     packet_buf.io_r.ior_requested, ax
                call    convert_start_sector
                mov     cx, TYPE io_r   ; set up send pack parameters
                mov     si, DVR:packet_buf
                push    ds
                pop     es              ; es:si, cx = packet
                call    send_pack
                jc      wr_error

                les     di, rhptr       ; Now get ready to send data
                mov     ax, es:[di].io_req.io_requested
                call    check_data_len
                jc      wr_bad_length

                les     si, es:[di].io_req.io_data ; es:si, cx -> buffer
                call    send_pack       ; Send the data
                jc      wr_error

                push    ds
                pop     es              ; receive write answer
                mov     di, DVR:packet_buf
                mov     cx, MAX_PACKET
                call    recv_pack
                jc      wr_error

                les     di, rhptr
                mov     ax, packet_buf.io_a.ioa_status
                cmp     al, ERR_DISK_CHANGE
                jne     copy_count

                mov     si, DVR:packet_buf.io_a.ioa_volume
                call    copy_label      ; Get the label into a safe place
                mov     WORD PTR es:[di].io_ans.io_label, DVR:vol_ser_buff
                mov     WORD PTR es:[di].io_ans.io_label + 2, ds

copy_count:     mov     bx, packet_buf.io_a.ioa_transfered
                mov     es:[di].io_ans.io_transfered, bx
;NOTE: AX still has status in it from before the copy_label call
                ret

wr_bad_length:  mov     ax, STATUS_ERROR OR ERR_WRITE_FAULT
                jmp     short wr_err_exit

wr_error:       mov     ax, STATUS_ERROR OR ERR_NOT_READY

wr_err_exit:    les     di, rhptr       ; Error in transmission
                mov     es:[di].io_ans.io_transfered, 0    ; Return no data transfered

wr_exit:        ret

write           ENDP

lpt_write_block PROC    NEAR

; Enter with:
;   EX:SI - points to block of characters to print
;      CX - count

                push    bx
                mov     packet_buf.common_packet.packet_type, AUX_WRITE_REQ
                mov     bl, device_id
                xor     bh, bh
                dec     bx
                mov     al, actual_prn_map[bx]
                cmp     al, 3
                jae     unknown_lpt

                mov     packet_buf.lpt_o_r.lpt_id, al
                mov     packet_buf.lpt_o_r.print_count, cx
                mov     al, es:[si]
                mov     packet_buf.lpt_o_r.print_data, al
                push    cx
                push    si
                push    es
                mov     cx, TYPE lpt_o_r    ; set up send pack parameters
                mov     si, DVR:packet_buf
                push    ds
                pop     es              ; es:si, cx = packet
                call    send_pack
                pop     es
                pop     si
                pop     cx
                jc      wr_error

                cmp     packet_buf.lpt_o_r.print_count, 1
                je      get_reply

                call    send_pack       ; Send the data
                jc      wr_error

get_reply:      push    ds
                pop     es              ; receive write answer
                mov     di, DVR:packet_buf
                mov     cx, MAX_PACKET
                call    recv_pack
                jc      wr_error

                les     di, rhptr
                mov     bx, packet_buf.lpt_o_a.lpt_transferred
                mov     es:[di].io_ans.io_transfered, bx
                mov     ax, packet_buf.lpt_o_a.lpt_status
                jmp     short wr_exit

unknown_lpt:    mov     ax, STATUS_ERROR OR ERR_UNK_UNIT
                jmp     short wr_zero_trans

wr_error:       mov     ax, STATUS_ERROR OR ERR_NOT_READY
                les     di, rhptr       ; Error in transmission

wr_zero_trans:  mov     es:[di].io_ans.io_transfered, 0    ; Return no data transfered

wr_exit:        pop     bx
                ret

lpt_write_block ENDP

lpt_write       PROC    NEAR            ; function 8 = Write (output)

                call    get_lpt_id
                jae     unknown_lpt

                les     bx, rhptr
                mov     cx, es:[bx].io_req.io_requested
                mov     lpt_write_count, cx

check_count:    mov     ax, lpt_count
                add     ax, cx
                jc      flush

                cmp     ax, MAX_LPT_BUFF
                ja      flush

insert:         cmp     lpt_buffering, 0
                je      write_data

                push    cx
                push    ds                          ; Save driver DS
                push    es
                mov     di, lpt_count
                add     di, DVR:lpt_buff
                push    ds
                lds     si, es:[bx].io_req.io_data
                pop     es                          ; Driver DS to ES
            rep movsb
                pop     es
                pop     ds
                pop     cx
                add     lpt_count, cx
                xor     cx, cx
                mov     ax, lpt_count
                cmp     ax, MAX_LPT_BUFF
                jb      flush_done

flush:          call    lpt_flush
                test    ax, STATUS_ERROR
                jnz     write_done

flush_done:     jcxz    write_ok

                cmp     cx, MAX_LPT_BUFF
                jb      insert

write_data:     les     di, rhptr
                les     si, es:[di].io_req.io_data
                call    lpt_write_block
                jmp     short write_done

write_error:    les     di, rhptr
                mov     es:[di].io_ans.io_transfered, 0
                jmp     short write_done

write_ok:       les     di, rhptr
                mov     cx, lpt_write_count
                mov     es:[di].io_ans.io_transfered, cx
                mov     ax, STATUS_DONE
                jmp     short write_done

unknown_lpt:    mov     ax, STATUS_ERROR OR ERR_UNK_UNIT

write_done:     ret

lpt_write       ENDP

lpt_flush       PROC    NEAR

                push    cx
                push    si
                push    es
                xor     ax, ax              ; Preset for no error
                mov     cx, lpt_count
                jcxz    flush_done

                mov     si, DVR:lpt_buff
                push    ds
                pop     es
                call    lpt_write_block
                test    ax, STATUS_ERROR
                jnz     flush_done

                mov     lpt_count, 0

flush_done:     test    ax, STATUS_ERROR    ; Set flags (NZ = error)
                pop     es
                pop     si
                pop     cx
                ret

lpt_flush       ENDP

get_lpt_id      PROC    NEAR

; Returns: 
;       AL = lpt_id
;        B if lpt_id is valid (0 - 2)
;       AE if lpt_id is invalid

                mov     bl, device_id
                xor     bh, bh
                dec     bx
                mov     al, actual_prn_map[bx]
                cmp     al, 3
                ret

get_lpt_id      ENDP

output_status   LABEL   NEAR

                mov     packet_buf.common_packet.packet_type, OUTPUT_STATUS_REQ
                jmp     short lpt_dev_common

flush_output    LABEL   NEAR

                call    lpt_flush
                jnz     dev_exit

                mov     packet_buf.common_packet.packet_type, FLUSH_OUTPUT_REQ
                jmp     short lpt_dev_common

lpt_dev_open    LABEL   NEAR

                call    get_lpt_id
                jb      @F

                mov     ax, STATUS_DONE
                jmp     short dev_exit

@@:             call    lpt_flush
                jnz     dev_exit

                mov     lpt_buffering, 1
                mov     packet_buf.common_packet.packet_type, AUX_DEV_OPEN_REQ
                jmp     short lpt_dev_common

lpt_dev_close   PROC    NEAR

                call    get_lpt_id
                jb      @F

                mov     ax, STATUS_DONE
                jmp     short dev_exit

@@:             call    lpt_flush
                jnz     dev_exit

                mov     lpt_buffering, 0
                mov     packet_buf.common_packet.packet_type, AUX_DEV_CLOSE_REQ

lpt_dev_common::call    get_lpt_id
                jae     unknown_lpt

                mov     packet_buf.lpt_cmd_r.lpt_id, al
                mov     cx, TYPE lpt_cmd_r    ; set up send pack parameters
                mov     si, DVR:packet_buf
                push    ds
                pop     es              ; es:si, cx = packet
                call    send_pack
                jc      dev_error

                mov     di, DVR:packet_buf
                mov     cx, MAX_PACKET
                call    recv_pack
                jc      dev_error

                mov     ax, packet_buf.lpt_cmd_a.lca_status
                jmp     short dev_exit

unknown_lpt:    mov     ax, STATUS_ERROR OR ERR_UNK_UNIT
                jmp     short dev_exit

dev_error:      mov     ax, STATUS_ERROR OR ERR_NOT_READY

dev_exit::      ret

lpt_dev_close   ENDP

removable_media PROC    NEAR            ; function 15 = Removable media

; NOTE: We always say the media is removeable without asking the server.

                call    map_unit
                jc      rm_exit

                mov     ax, STATUS_DONE ; Return busy bit == 0 for removable

rm_exit:        ret

removable_media ENDP


device_open     PROC    NEAR            ; function 13 = Device Open
device_close    LABEL   PROC            ; function 14 = Device Close

                call    map_unit        ; ax = mapped unit, bx = unmapped unit
                jc      do_exit

                mov     bx, ax          ; See if slave driver supports ATT_OCRM
                mov     ax, STATUS_DONE ; Set return status in case slave
                                        ; doesn't support ATT_OCRM
                shl     bx, 1
                test    dd_attributes[bx], ATT_OCRM
                jz      do_exit

                call    check_unit      ; Unit supports it, so go ahead and
                jc      do_exit         ; send the packet

                les     di, rhptr
                mov     al, DEV_OPEN_REQ
                cmp     BYTE PTR es:[di].static_rhp.rhp_command, DEVICE_OPEN
                je      do_send

                mov     al, DEV_CLOSE_REQ

do_send:        mov     packet_buf.common_packet.packet_type, al
                mov     al, BYTE PTR mapped_unit
                mov     packet_buf.ocrm_r.ocr_unit, al
                
                mov     cx, TYPE ocrm_r
                mov     si, DVR:packet_buf
                push    ds
                pop     es              ; es:si, cx = packet
                call    send_pack       ; Send request
                jc      do_error

                mov     di, DVR:packet_buf
                mov     cx, MAX_PACKET
                call    recv_pack
                jc      do_error

                mov     ax, packet_buf.ocrm_a.oca_status

do_exit:        ret

do_error:       mov     ax, STATUS_ERROR OR ERR_NOT_READY
                ret

device_open     ENDP

gen_data_save   dd      ?

generic_ioctl   PROC    NEAR            ; function 19 = Generic IOCTL

                call    map_unit        ; ax = mapped unit, bx = unmapped unit
                jc      gi_exit

                mov     bx, ax          ; See if slave driver supports ATT_GEN_IOCTL
                shl     bx, 1
                test    dd_attributes[bx], ATT_GEN_IOCTL
                jz      gi_unsupported

                les     di, rhptr
                cmp     es:[di].gen_ioctl_req.gen_category, 8
                jne     gi_unsupported

                mov     al, es:[di].gen_ioctl_req.gen_function
                mov     packet_buf.gen_ioctl_r.gir_function, al ; Save function code
                HEX     al
                les     si, es:[di].gen_ioctl_req.gen_data      ; Get data ptr
                cmp     al, 46H
                je      supported

                cmp     al, 66H
                jne     gi_unsupported

supported:      mov     WORD PTR gen_data_save, si
                mov     WORD PTR gen_data_save[2], es
                mov     packet_buf.common_packet.packet_type, GEN_IOCTL_REQ
                mov     al, BYTE PTR mapped_unit
                mov     packet_buf.gen_ioctl_r.gir_unit, al
                mov     packet_buf.gen_ioctl_r.gir_category, 8
                mov     cx, TYPE gen_ioctl_r
                mov     si, DVR:packet_buf
                push    ds
                pop     es
                call    send_pack
                jc      gi_error

                les     si, gen_data_save
                cmp     packet_buf.gen_ioctl_r.gir_function, 66H
                je      gi_recv

                mov     cx, TYPE media_id_buffer
                call    send_pack
                jc      gi_error

gi_recv:        push    ds
                pop     es              ; receive response
                mov     di, DVR:packet_buf
                mov     cx, MAX_PACKET
                call    recv_pack
                jc      gi_error

                test    packet_buf.gen_ioctl_a.gia_status, STATUS_ERROR
                jnz     gi_done

                les     di, rhptr
                cmp     es:[di].gen_ioctl_req.gen_function, 46H
                je      gi_done

                mov     cx, TYPE media_id_buffer
                les     di, gen_data_save
                call    recv_pack
                jc      gi_error

gi_done:        mov     ax, packet_buf.gen_ioctl_a.gia_status
                jmp     short gi_exit

gi_unsupported: mov     ax, STATUS_ERROR OR ERR_UNK_COMMAND
                jmp     short gi_exit

gi_error:       mov     ax, STATUS_ERROR OR ERR_NOT_READY

gi_exit:        ret

generic_ioctl   ENDP


lpt_unused      PROC    FAR

                push    es
                push    di
                les     di, cs:rhptr
                mov     WORD PTR es:[di].static_rhp.rhp_status, STATUS_DONE
                pop     di
                pop     es
                pop     ax
                ret

lpt_unused      ENDP


unused          PROC    NEAR

                xor     ax, ax
                ret

unused          ENDP



                PAGE

init_char       PROC    NEAR

                mov     ax, init_size
                mov     WORD PTR es:[di].init_ans.init_end, ax
                mov     ax, header_seg
                mov     WORD PTR es:[di].init_ans.init_end + 2, ax
                xor     ax, ax
                ret

init_char       ENDP

init_block      PROC    NEAR

                mov     ax, init_size
                mov     WORD PTR es:[di].init_ans.init_end, ax
                mov     ax, header_seg
                mov     WORD PTR es:[di].init_ans.init_end + 2, ax
                mov     WORD PTR es:[di].init_ans.init_bpb, DVR:bpb_pnt_array
                mov     WORD PTR es:[di].init_ans.init_bpb + 2, ds   ; BPB offset array
                mov     al, units
                mov     es:[di].init_ans.init_units, al
                mov     cs:header.device_header.name_num[0], al  ; Number of units
                xor     ax, ax
                ret

init_block      ENDP


BLOCK           ENDS


                SUBTTL  Resident variable length data
                PAGE
VARLEN          SEGMENT WORD PUBLIC 'CODE'

                EVEN

bpb_array       LABEL   bios_parameter_block
        bios_parameter_block MAX_DEVICES DUP (<200H, 1, 1, 2, 64, 128, 0, 1>)
                                        ; Allocation for BPB array

VARLEN          ENDS


                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\driver\printer.asm ===
;***
;* $Workfile:   printer.asm  $
;* $Revision:   1.1  $
;*   $Author:   Dave Sewell  $
;*     $Date:   30 Jun 1989 18:27:00  $
;***

TIMEOUT         equ     01H             ; Timeout bit
ERROR           equ     08H             ; Error bit
SELECTED        equ     10H             ; Selected bit
OUT_OF_PAPER    equ     20H             ; Out of paper bit
ACKNOWLEDGE     equ     40H             ; Acknowledge bit
NOT_BUSY        equ     80H             ; Not busy bit

BUSY            equ     SELECTED        ; Printer ok but busy

PRINTER_WRITE   equ     0               ; Printer write request
PRINTER_INIT    equ     1               ; Printer initialize request
PRINTER_STATUS  equ     2               ; Printer status request


                INCLUDE drivers.mac
                INCLUDE packets.mac
                INCLUDE debug.mac

CORE            SEGMENT WORD PUBLIC 'CODE'
                EXTRN   send_pack:WORD
                EXTRN   recv_pack:WORD
                EXTRN   send_sync:WORD
                EXTRN   get_remote_info:WORD
                EXTRN   busy_semaphore:BYTE
                EXTRN   initialized:BYTE
                EXTRN   actual_prn_map:BYTE
                EXTRN   printer_loaded:BYTE
                EXTRN   packet_buf:BYTE
                EXTRN   request:WORD
                EXTRN   port:BYTE
                EXTRN   old_int17:DWORD
                EXTRN   port_address:WORD
                EXTRN   idle_semaphore:BYTE
        IFDEF DEBUG
                EXTRN   hex_out:WORD
                EXTRN   debug_msg:WORD
        ENDIF
CORE            ENDS

PRINTER         SEGMENT WORD PUBLIC 'CODE'
                PUBLIC  printer_start
                PUBLIC  prn_fixup

                ORG     0

printer_start   LABEL   BYTE


int17_trap      PROC    FAR             ; INT 17H entry point

                cmp     dl, 3           ; Check for illegal LPT value
                jae     int17_passthru  ; If illegal, let previous guy handle it

                push    bx
                mov     bl, dl
                xor     bh,bh
                cmp     cs:actual_prn_map[bx], 3
                jb      remote          ; Value falls with 0 - 2

                pop     bx

int17_passthru: 
                jmp     cs:old_int17    ; Pass request to previous INT 17H handler

remote:         push    cx
                push    dx
                push    di
                push    si
                push    bp
                push    ds
                push    es
                mov     bx, cs
                mov     ds, bx          ; Local data now addressable
                mov     bl, 0FFH
                xchg    bl, busy_semaphore
                or      bl, bl
                jz      not_busy

                mov     ah, BUSY        ; Return printer busy if main driver
                jmp     SHORT it_exit   ; is busy

not_busy:       mov     request, ax
                mov     port, dl
                cld                     ; Insure direction flag is UP
                sti                     ; Insure interrupts enabled for transfer

                cmp     port_address, 0
                jne     send_remote

                call    send_sync       ; Insure we are connected
                jc      it_error

                call    get_remote_info ; Insure we are initialized
                jc      it_error
                
send_remote:    call    bios_remote

                mov     al, BYTE PTR request
                jmp     short it_done

it_error:       mov     ah, SELECTED OR ERROR OR TIMEOUT

it_done:        mov     idle_semaphore, MINIMUM_TICKS + 1
                mov     busy_semaphore, 0       ; Clear communications busy flag

it_exit:        pop     es              ; Restore remaining registers
                pop     ds
                pop     bp
                pop     si
                pop     di
                pop     dx
                pop     cx
                pop     bx
                iret

int17_trap      ENDP

; bios_remote   Sends a BIOS request packet to the remote system.
;
; Inputs:
;   request original request value in ax
;   port    original port number in dx
;
; Outputs:
;   AH = printer status (ERROR OR TIMEOUT on communication error)
;
bios_remote     PROC    NEAR

                mov     bl, port
                xor     bh, bh
                mov     al, actual_prn_map[bx]  ; Get server LPT (0 - 2)
                mov     packet_buf.bios_r.bsr_bios_port, al
                mov     ax, request
                cmp     ah, PRINTER_WRITE
                jne     @F

                DBG     'p'
                mov     packet_buf.common_packet.packet_type, BIOS_PRINT_REQ
                mov     packet_buf.bios_r.bsr_char, al
                mov     cx, TYPE bios_r
                jmp     SHORT br_go

@@:             mov     cx, TYPE bios_r - 1
                mov     packet_buf.common_packet.packet_type, BIOS_INIT_REQ
                cmp     ah, PRINTER_INIT; Initialize printer request?
                je      br_go

                DBG     's'
                mov     packet_buf.common_packet.packet_type, BIOS_STATUS_REQ

br_go:          push    ds                  ; send the packet
                pop     es
                mov     si, DVR:packet_buf  ; es:si, cx = packet
                call    send_pack
                jc      br_error

                mov     di, DVR:packet_buf
                mov     cx, TYPE packet_buf
                call    recv_pack
                jnc     br_endio

br_error:       mov     packet_buf.bios_a.bsa_status, ERROR OR TIMEOUT

br_endio:       mov     ah, packet_buf.bios_a.bsa_status
                ret

bios_remote     ENDP

printer_end     LABEL   BYTE            ; End of printer resident code

PRINTER         ENDS

INIT            SEGMENT WORD PUBLIC 'CODE'

printer_init    PROC    NEAR
                PUBLIC  printer_init

                cmp     printer_loaded, 0   ; Any printers to redirect?
                je      hook_done

                mov     ax, 3517H       ; Get current INT 17H vector
                int     21H

                mov     WORD PTR old_int17, bx
                mov     WORD PTR old_int17 + 2, es

                mov     ax, 2517H       ; Set new INT 17H vector
                mov     dx, DVR:int17_trap
prn_fixup       EQU     $ - 2
                int     21H

hook_done:      ret

printer_init    ENDP

INIT            ENDS

                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\driver\init.asm ===
;***
;* $Workfile:   init.asm  $
;* $Revision:   1.5  $
;*   $Author:   Dave Sewell  $
;*     $Date:   08 Aug 1989 16:44:52  $
;***

                TITLE   Expansion Box Main Device Driver
                PAGE    66, 132


                INCLUDE drivers.mac
                INCLUDE packets.mac
                INCLUDE debug.mac


CORE            SEGMENT WORD PUBLIC 'CODE'
                EXTRN   C int2f_handler:FAR
                EXTRN   C int25_handler:FAR
                EXTRN   C int26_handler:FAR
                EXTRN   header:BYTE
                EXTRN   lpt3_header:BYTE
                EXTRN   lpt2_header:BYTE
                EXTRN   lpt1_header:BYTE
                EXTRN   strat_seg:WORD
                EXTRN   intr0_seg:WORD
                EXTRN   intr1_seg:WORD
                EXTRN   intr2_seg:WORD
                EXTRN   intr3_off:WORD
                EXTRN   intr3_seg:WORD
                EXTRN   end_low_stub:BYTE
                EXTRN   finger_print:BYTE

                EXTRN   setup_ports_parallel:NEAR
                EXTRN   setup_ports_serial:NEAR
                EXTRN   reset_ports_parallel:NEAR
                EXTRN   reset_ports_serial:NEAR

                EXTRN   intr_error:FAR
        IFDEF DEBUG
                EXTRN   debug_init:NEAR
                EXTRN   debug_msg:WORD
                EXTRN   hex_out:WORD
        ENDIF
                EXTRN   gri_proc:NEAR
                EXTRN   send_sync_proc:NEAR
                EXTRN   driver_call:DWORD
                EXTRN   header_seg:WORD
                EXTRN   driver_id:BYTE
                EXTRN   client_id:DWORD
                EXTRN   max_baud:BYTE
                EXTRN   client_max_baud:BYTE
                EXTRN   idle_semaphore:BYTE
                EXTRN   max_secsize:WORD
                EXTRN   dos_version:WORD
                EXTRN   dos_major:BYTE
                EXTRN   rhptr:DWORD
                EXTRN   bios_port_num:BYTE
                EXTRN   is_serial:BYTE
                EXTRN   port_address:WORD
                EXTRN   port_index:WORD
                EXTRN   int2f_ok:BYTE
                EXTRN   old_int2f_vec:DWORD
                EXTRN   old_int25_vec:DWORD
                EXTRN   old_int26_vec:DWORD
                EXTRN   num_ports:BYTE
                EXTRN   num_ser_ports:BYTE
                EXTRN   num_par_ports:BYTE
                EXTRN   serial_ports:BYTE
                EXTRN   parallel_ports:BYTE
                EXTRN   printer_loaded:BYTE
                EXTRN   parallel_start:BYTE
                EXTRN   par_fixup_start:WORD
                EXTRN   par_fixup_end:WORD
                EXTRN   device_high:BYTE
                EXTRN   init_size:WORD
                EXTRN   low_memory:BYTE
                EXTRN   driver_size:WORD
                EXTRN   initialized:BYTE
                EXTRN   display_scan:BYTE
                EXTRN   fx_force_variable:BYTE
                EXTRN   Virt_Dev_File:BYTE
                EXTRN   Win386_Startup_Info:Win386_Startup_Info_Struc
CORE            ENDS

BLOCK           SEGMENT WORD PUBLIC 'CODE'
                EXTRN   intr_vector:WORD
                EXTRN   normal_intr:NEAR
                EXTRN   block_start:BYTE
                EXTRN   block_init_end:BYTE
                EXTRN   bpb_array:WORD
                EXTRN   units:BYTE
                EXTRN   default_units:BYTE
                EXTRN   first_unit:BYTE
                EXTRN   dd_attributes:WORD
                EXTRN   max_devices:BYTE
                EXTRN   dispatch:WORD
                EXTRN   bpb_pnt_array:WORD
                EXTRN   lpt_unused:NEAR
BLOCK           ENDS

SERIAL          SEGMENT WORD PUBLIC 'CODE'
SERIAL          ENDS

PARALLEL        SEGMENT WORD PUBLIC 'CODE'
                EXTRN   par_fixup1:WORD
                EXTRN   par_fixup2:WORD
                EXTRN   par_fixup3:WORD
                EXTRN   par_fixup4:WORD
PARALLEL        ENDS

PRINTER         SEGMENT WORD PUBLIC 'CODE'
                EXTRN   prn_fixup:WORD
PRINTER         ENDS

                EXTRN   serial_start:BYTE
                EXTRN   printer_start:BYTE
                EXTRN   comma_space:BYTE
                EXTRN   invalid_switch:BYTE
                EXTRN   product_name:BYTE
                EXTRN   port_address_msg:BYTE
                EXTRN   port_address_loc:BYTE
                EXTRN   ser_port_name:BYTE
                EXTRN   ser_port_number:BYTE
                EXTRN   par_port_name:BYTE
                EXTRN   par_port_number:BYTE
                EXTRN   baud_msg:BYTE,           baud_loc:BYTE
                EXTRN   irq_msg:BYTE,            irq_loc:BYTE
                EXTRN   cr_lf:BYTE
                EXTRN   signon_default:BYTE,     signon_dfirst:BYTE
                EXTRN   signon_paren:BYTE
                EXTRN   signon_dlast:BYTE,       signon_ndrives:WORD
                EXTRN   printer_default:BYTE,    printer_dfirst:BYTE
                EXTRN   printer_paren:BYTE
                EXTRN   printer_dlast:BYTE,      printer_ndrives:BYTE
                EXTRN   msg_no_ports:BYTE
                EXTRN   msg_no_devices:BYTE
                EXTRN   too_big:BYTE
                EXTRN   m_bad_ser_addr:BYTE
                EXTRN   m_too_many_ser:BYTE
                EXTRN   m_bad_bios_ser:BYTE
                EXTRN   m_bad_par_addr:BYTE
                EXTRN   m_too_many_par:BYTE
                EXTRN   m_bad_bios_par:BYTE
                EXTRN   m_com_bad:BYTE
                EXTRN   m_lpt_bad:BYTE
                EXTRN   m_connect_try:BYTE
                EXTRN   m_connect_ok:BYTE
                EXTRN   m_connect_fail:BYTE
                EXTRN   m_baud_error:BYTE
                EXTRN   m_max_baud:BYTE

MAXCMD          equ 16                  ; Maximum allowed command code
                                        ; 12 for MS-DOS 2.x
                                        ; 16 for MS-DOS 3.0-3.1
                                        ; 24 for MS-DOS 3.2-3.3

TIMER_0         EQU 40H         ;8253 counter 0 port
TIMER_CTL       EQU 43H         ;8253 control port
TIMER_0_LATCH   EQU 00H         ;8253 cmd to save channel 0 current count

DOS30           EQU (3 SHL 8) + 30      ; MS-DOS 3.30 word format version number
DOS331          EQU (3 SHL 8) + 31      ; MS-DOS 3.31 word format version number
DOS40           EQU (4 SHL 8) + 00      ; MS-DOS 4.00 word format version number
DOS50           EQU (5 SHL 8) + 00      ; MS-DOS 5.00 word format version number


INIT            SEGMENT WORD PUBLIC 'CODE'
                PUBLIC  get_dos_version
                PUBLIC  show_crlf
                PUBLIC  init_end
                EXTRN   num_lpt:BYTE
                EXTRN   num_com:BYTE
                EXTRN   auto_str:BYTE
                EXTRN   spaces_str:BYTE
                EXTRN   none_str:BYTE
                EXTRN   printer_init:NEAR
                EXTRN   printer_signon:BYTE
                EXTRN   drives_error:BYTE
                EXTRN   no_drives:BYTE
                EXTRN   no_printers:BYTE
                EXTRN   m_prn_cl_letter:BYTE
                EXTRN   m_prn_se_letter:BYTE
                EXTRN   m_prn_map:BYTE
                EXTRN   m_lost_connect:BYTE
                EXTRN   actual_prn_map:BYTE
                EXTRN   packet_buf:BYTE
                EXTRN   m_map_header:BYTE
                EXTRN   m_drive_map:BYTE
                EXTRN   m_client_letter:BYTE
                EXTRN   m_server_letter:BYTE
                EXTRN   m_no_driver:BYTE
                EXTRN   send_pack:WORD
                EXTRN   recv_pack:WORD
                EXTRN   drive_mapping:BYTE

                ORG     0

                DB      "Copyright (C) 1989-1991 by Sewell Development Corp."

force_low       db      0               ; Set non-zero if forcing low memory
bpb_start       dw      ?
noscan          db      0
auto            db      0               ; TRUE if load only on connect
umb_allocated   db      0               ; Set TRUE if high mem block allocated

initialize      PROC    NEAR            ; function 0 = initialize driver
                PUBLIC  initialize

                mov     ax, cs
                mov     WORD PTR driver_call + 2, ax
                mov     header_seg, ax
        IFDEF DEBUG
                call    debug_init
        ENDIF
                call    signon

get_version:    call    get_dos_version ; Get DOS version number
                call    make_client_id  ; Get an arbitrary client ID
                les     di, rhptr
                call    get_equipment
                les     si, es:[di].init_req.init_cmd    ; es:si -> command line
                call    parse_args      ; Parse and process command line args
                jc      init_no_install

                call    get_max_secsize ; Get the maximum sector size on MASTER
                                        ; Also get first unit number

                mov     al, 'Z' - 'A' + 1   ; Calculate max devices
                sub     al, first_unit
                mov     max_devices, al
                mov     al, default_units
                cmp     al, max_devices ; See if we can use all of the default
                jbe     save_units      ; devices

                mov     al, max_devices ; If not enough device letters, use only
                                        ; those that are available

save_units:     mov     units, al       ; Save the number of units

; Force NON_IBM format.  This will avoid the initial read of the first
; sector of the FAT before a build BPB call.  The slave system will perform
; this read if necessary.
;
; Force OCRM, HUGE, & GEN_IOCTL.  We maintain count of the open files even
; if the
; slave driver doesn't.  We will always use HUGE addressing, the read and
; write I/O routines, convert the 32-bit sector numbers into the appropriate
; format for the slave system.  We must force HUGE because the other side
; may use HUGE addressing and we don't know about it (because communications
; couldn't be established above).  If we didn't, we might start addressing
; a HUGE disk on the slave system with small sectors -- which would destroy
; the disk!!!  On DOS versions before 3.31, this bit should be ignored!

                mov     header.device_header.attribute, ATT_NON_IBM OR ATT_OCRM OR ATT_HUGE OR ATT_GEN_IOCTL

;--- Load only those segments of code into memory which are really needed ---

                push    ds
                pop     es
                mov     di, DVR:block_init_end
                mov     ax, DVR:normal_intr
                sub     ax, DVR:intr_vector + 2
                mov     intr_vector, ax
                mov     di, DVR:serial_start
                cmp     num_ser_ports, 0
                je      copy_parallel

                mov     di, DVR:parallel_start

copy_parallel:  cmp     num_par_ports, 0
                je      copy_printer

                mov     si, DVR:parallel_start
                mov     cx, DVR:printer_start
                call    check_copy_code
                jc      copy_printer              ; Carry set if no copy needed

                sub     par_fixup1, ax
                sub     par_fixup2, ax
                sub     par_fixup3, ax
                sub     par_fixup4, ax
            rep movsw
                mov     si, DVR:par_fixup_start
                mov     cx, DVR:par_fixup_end
                call    fixup_table

copy_printer:   cmp     printer_loaded, 0
                je      fixup_bpbs

                mov     si, DVR:printer_start
                mov     cx, DVR:bpb_array
                call    check_copy_code
                jc      fixup_bpbs

            rep movsw
                sub     WORD PTR prn_fixup, ax

fixup_bpbs:     mov     bpb_start, di
                cmp     units, 0
                je      check_size

                mov     si, DVR:bpb_array
                cmp     si, di
                je      check_size

                mov     cx, (MAX_DEVICES * TYPE bios_parameter_block) / 2
            rep movsw

                mov     ax, bpb_start
                mov     cx, MAX_DEVICES
                mov     di, DVR:bpb_pnt_array

fix_bpb_pnt:    stosw
                add     ax, TYPE bios_parameter_block
                loop    fix_bpb_pnt

check_size:     mov     al, units       ; Now calculate length of BPB array
                mov     cl, TYPE bios_parameter_block
                mul     cl

                add     ax, bpb_start   ; Calculate Driver length
                mov     cx, ax          ; cx = break address offset

                add     ax, 000FH       ; Include all of last paragraph in
                and     ax, 0FFF0H      ; required space message

                cmp     dos_version, DOS50
                jl      save_size

                ; have determined that we are dos 5.0 or greater, so
                ; check end address to make sure we will not go past
                ; it with bpb array.

                mov     dx, cs
                mov     cl, 4
                shr     ax, cl
                add     dx, ax         
                        ; compare max address seg. to break seg (both
                        ; normalized) to see if we will fit
                les     di, rhptr
                mov     bx, WORD PTR es:[di].init_ans.init_end
                shr     bx, cl
                add     bx, WORD PTR es:[di].init_ans.init_end + 2
                cmp     dx, bx
                jbe     load_size_ok

                pmsg    too_big
                jmp     init_no_install ; Not enough room!

load_size_ok:   shl     ax, cl          ; restore ax to num bytes

save_size:      mov     driver_size, ax ; Save driver size in bytes
                mov     init_size, ax
                cmp     num_ports, 0
                jne     init_show_port

                pmsg    msg_no_ports
                jmp     init_no_install

init_show_port: cmp     units, 0
                jne     @F

                cmp     printer_loaded, 0
                jne     @F

                pmsg    msg_no_devices
                jmp     init_no_install

@@:             call    show_max_baud

                mov     bx, cs
                cmp     bx, 0A000H
                jb      in_low

                inc     device_high
                dec     low_memory      ; Set low_memory to 0
                jmp     short connect_scan

in_low:         cmp     force_low, 0
                jne     connect_scan

                cmp     dos_version, DOS50
                jb      connect_scan

                mov     bx, driver_size ; Get size (already rounded up)
                mov     cl, 4
                shr     bx, cl          ; Convert size to paragraphs
                mov     ah, 48H         ; Try to allocate UMB memory block
                int     21H
                jc      connect_scan    ; Failed - must be none available

                inc     umb_allocated
                mov     strat_seg, ax
                mov     intr0_seg, ax
                mov     intr1_seg, ax
                mov     intr2_seg, ax
                mov     intr3_seg, ax
                mov     WORD PTR driver_call + 2, ax
                dec     low_memory
                mov     init_size, (DVR:end_low_stub + 15)
                and     init_size, 0FFF0H
                dec     ax                      ; Point to MCB just in front
                mov     es, ax
                inc     ax                      ; Restore our segment
                mov     si, DVR:finger_print
                mov     di, 8
                mov     es:[di - 7], ax         ; Point "owner" word to us
                mov     cx, 4
            rep movsw
                mov     es, ax
                xor     si, si
                xor     di, di
                mov     cx, driver_size
                shr     cx, 1                   ; Change to word count
            rep movsw                           ; ===> Move the driver! <===
                mov     ds, ax                  ; Update DS with new driver seg

connect_scan:   call    setup_ports_parallel    ; Parallel setup
                call    setup_ports_serial      ; Serial setup
                cmp     cs:noscan, 0
                jne     init_show

                call    connect
                jnc     init_show               ; Connection succeeded

                cmp     cs:auto, 0              ; Connection failed
                je      init_show

                call    reset_ports_parallel
                call    reset_ports_serial
                jmp     init_no_install

init_show:      call    printer_init            ; Printer redirection setup
                call    show_units
                call    show_printers
                cmp     initialized, 0
                je      init_continue

                call    show_drive_map
                jc      init_continue

                call    show_prn_map

init_continue:  call    hook_int2f
                call    hook_int25_26

init_done:      mov     idle_semaphore, MINIMUM_TICKS + 1
                les     di, rhptr

;--- Unlink LPT drivers that aren't necessary.

                mov     ax, DVR:header
                cmp     units, 0
                jne     check_num_lpt

                mov     ax, -1              ; Cause block driver to be unlinked

check_num_lpt:  cmp     printer_loaded, 0
                je      load_only_one

                cmp     num_lpt, 0
                je      zero_lpts

                cmp     num_lpt, 1
                je      one_lpt

load_only_one:  mov     cs:lpt3_header.device_header.next_offset, ax
                cmp     printer_loaded, 0
                je      make_null

                cmp     num_lpt, 2
                je      init_ret_size

make_null:      mov     WORD PTR cs:lpt3_header.device_header.name_num, "UN"
                mov     WORD PTR cs:lpt3_header.device_header.name_num[2], "2L"
                mov     cs:intr3_off, DVR:lpt_unused
                jmp     short init_ret_size

zero_lpts:      mov     cs:lpt1_header.device_header.next_offset, ax
                jmp     short init_ret_size

one_lpt:        mov     cs:lpt2_header.device_header.next_offset, ax

init_ret_size:  mov     ax, init_size
                mov     WORD PTR es:[di].static_rhp.rhp_status, STATUS_DONE
                mov     WORD PTR es:[di].init_ans.init_end, ax
                mov     WORD PTR es:[di].init_ans.init_end + 2, cs   ; Break address
                cmp     init_size, 0
                jne     init_ret

;--- We are not going to load, so unlink the other drivers.

                mov     cs:lpt3_header.device_header.next_offset, -1
                cmp     cs:umb_allocated, 0
                je      init_ret

                mov     es, strat_seg
                mov     ah, 49H
                int     21H             ; Return allocated block in UMB

init_ret:       ret

init_no_install:mov     units, 0        ; and do not install driver
                mov     printer_loaded, 0
                mov     init_size, 0
                pmsg    m_no_driver
                jmp     init_done

initialize      ENDP

IFDEF DEBUG

dump_break      PROC    NEAR

                mov     ax, es
                DBG     ' '
                DBG     'r'
                DBG     'h'
                DBG     '='
                HEX     ah
                HEX     al
                DBG     ':'
                mov     ax, di
                HEX     ah
                HEX     al
                DBG     ' '
                DBG     'b'
                DBG     'a'
                DBG     '='
                mov     ax, WORD PTR es:[di].init_ans.init_end + 2
                HEX     ah
                HEX     al
                DBG     ':'
                mov     ax, WORD PTR es:[di].init_ans.init_end
                HEX     ah
                HEX     al
                ret

dump_break      ENDP
ENDIF

hook_int2f      PROC    NEAR

                mov     ax, 352FH
                int     21H
                mov     ax, es
                or      ax, bx
                jz      change_int2f

                inc     int2f_ok        ; Vector is not zero
                mov     WORD PTR old_int2f_vec, bx
                mov     WORD PTR old_int2f_vec + 2, es
                mov     ax, (INTERLNK_MULTIPLEX_ID SHL 8) OR 0
                mov     bl, 0
                mov     dx, 0FFFFH
                int     2FH
                cmp     al, 0FFH
                je      @F

                xor     bl, bl

@@:             inc     bl
                mov     driver_id, bl

change_int2f:   mov     dx, DVR:int2f_handler       ;DS:DX -> int2f_handler
                mov     ax, 252FH
                int     21H
                mov     WORD PTR Win386_Startup_Info.SIS_Virt_Dev_File_Ptr + 2, ds
                ret

hook_int2f      ENDP

hook_int25_26   PROC    NEAR

                mov     ax, 3525H
                int     21H
                mov     WORD PTR old_int25_vec, bx
                mov     WORD PTR old_int25_vec + 2, es
                mov     dx, DVR:int25_handler
                mov     ax, 2525H
                int     21H

                mov     ax, 3526H
                int     21H
                mov     WORD PTR old_int26_vec, bx
                mov     WORD PTR old_int26_vec + 2, es
                mov     dx, DVR:int26_handler
                mov     ax, 2526H
                int     21H

                ret

hook_int25_26   ENDP

signon          PROC    NEAR
                PUBLIC  signon

                pmsg    product_name
                ret

signon          ENDP


show_units      PROC    NEAR
                PUBLIC  show_units

                mov     al, units
                aam
                add     ax, "00"
                xchg    ah, al
                cmp     al, '0'
                jne     stuff_ndrives

                mov     al, ' '

stuff_ndrives:  mov     cs:signon_ndrives, ax
                cmp     units, 0
                jne     show_drives

                pmsg    no_drives
                jmp     short show_units_ret

show_drives:    mov     bl, first_unit  ; Setup default drive mapping message
                add     bl, 'A'
                mov     cs:signon_dfirst, bl
                add     bl, units
                dec     bl
                mov     cs:signon_dlast, bl
                cmp     units, 1
                jne     show

                mov     WORD PTR cs:signon_paren, 0D29H         ; ")\r"
                mov     WORD PTR cs:signon_paren + 2, 240AH     ; "\n$"

show:           pmsg    signon_default

show_units_ret: ret

show_units      ENDP


show_printers   PROC    NEAR
                PUBLIC  show_printers

                cmp     printer_loaded, 0
                jne     have_printers

                pmsg    no_printers
                jmp     short show_pr_ret

have_printers:  mov     al, 3
                sub     al, num_lpt
                mov     ah, al              ; Save number of printers in AH
                add     al, '0'
                mov     cs:printer_ndrives, al
                mov     bl, 3
                sub     bl, ah
                add     bl, '1'
                mov     cs:printer_dfirst, bl
                add     bl, ah
                dec     bl
                mov     cs:printer_dlast, bl
                cmp     ah, 1
                jne     show_pr

                mov     WORD PTR cs:printer_paren, 0D29H        ; ")\r"
                mov     WORD PTR cs: printer_paren + 2, 240AH   ; "\n$"

show_pr:        pmsg    printer_default

show_pr_ret:    ret

show_printers   ENDP


connect         PROC    NEAR
                PUBLIC  connect

                pmsg    m_connect_try
                inc     display_scan
                mov     ax, DVR:send_sync_proc
                call    driver_call
                dec     display_scan    ;"dec" DOES NOT AFFECT CARRY FLAG
                jc      connect_fail

                mov     initialized, 0
                mov     ax, DVR:gri_proc
                call    driver_call
                jc      connect_fail

show_ok:        pmsg    m_connect_ok
                mov     bx, port_index
                cmp     is_serial, 0
                jne     connect_ser

                call    show_port_par
                jmp     short connect_ok

connect_ser:    call    show_port_ser

connect_ok:     call    show_crlf
                mov     idle_semaphore, 0       ; Turn off idler for now
                clc
                jmp     short connect_done

connect_fail:   pmsg    m_connect_fail
                stc

connect_done:   ret

connect         ENDP


print_asciiz    PROC    NEAR

                push    dx

print_loop:     lodsb
                or      al, al
                jz      blank_fill

                mov     ah, 2
                mov     dl, al
                int     21H
                loop    print_loop

blank_fill:     jcxz    print_done
                
blank_loop:     mov     ah, 2
                mov     dl, ' '
                int     21H
                loop    blank_loop

print_done:     pop     dx
                ret

print_asciiz    ENDP

print_msg       PROC    NEAR
                PUBLIC  print_msg

                push    ds
                push    cs
                pop     ds
                mov     ah, 9
                int     21H
                pop     ds
                ret

print_msg       ENDP

show_drive_map  PROC    NEAR
                PUBLIC  show_drive_map

                pmsg    m_map_header
                mov     cl, units
                xor     ch, ch
                or      cx, cx
                jz      show_map_ret

                xor     bx, bx

show_unit_loop: mov     al, bl
                add     al, first_unit
                add     al, 'A'
                mov     cs:m_client_letter, al
                mov     al, drive_mapping[bx]
                cmp     al, MAX_DEVICES
                jae       next_unit

                add     al, 'A'
                mov     cs:m_server_letter, al
                pmsg    m_drive_map

                push    bx
                push    cx
                mov     packet_buf.common_packet.packet_type, DRIVE_INFO_REQ
                mov     al, drive_mapping[bx]
                mov     packet_buf.drive_info_r.dir_unit, al
                mov     cx, TYPE drive_info_r
                mov     si, DVR:packet_buf
                push    ds
                pop     es
                mov     ax, send_pack   ; Verify that send_pack preserves ES
                call    driver_call
                jc      show_map_err

                mov     di, DVR:packet_buf
                mov     cx, MAX_PACKET
                mov     ax, recv_pack
                call    driver_call
                jc      show_map_err

                mov     si, DVR:packet_buf.drive_info_a.dia_size
                mov     cx, 8
                call    print_asciiz

                mov     si, DVR:packet_buf.drive_info_a.dia_vol_label
                mov     cx, 12
                call    print_asciiz
                call    show_crlf
                pop     cx
                pop     bx

next_unit:      inc     bx
                dec     cx
                jcxz    show_map_ret

                jmp     show_unit_loop
                
show_map_ret:   clc
                ret

show_map_err:   pop     cx
                pop     bx
                pmsg    m_lost_connect
                stc
                ret

show_drive_map  ENDP


show_prn_map    PROC    NEAR
                PUBLIC  show_prn_map
    
                cmp     printer_loaded, 0
                je      show_prn_ret

                mov     cx, 3
                mov     bx, 0

prn_loop:       mov     al, actual_prn_map[bx]
                cmp     al, 0FFH
                je      prn_next

                add     al, '1'
                mov     cs:m_prn_se_letter, al
                mov     al, bl
                add     al, '1'
                mov     cs:m_prn_cl_letter, al
                pmsg    m_prn_map

prn_next:       inc     bx
                loop    prn_loop

show_prn_ret:   ret

show_prn_map    ENDP


fixup_table     PROC    NEAR

; Enter with AX = fixup value, SI = start of table, CX = end of table
; Destroys BX, SI

                xor     bx, bx

table_loop:     cmp     [si], bx
                je      advance

                sub     [si], ax

advance:        add     si, 2
                cmp     si, cx
                jb      table_loop

                ret

fixup_table     ENDP

check_copy_code PROC    NEAR

                sub     cx, si          ; CX = number of bytes to move
                mov     ax, si
                sub     ax, di          ; Leave fixup value in AX
                jz      no_copy

                shr     cx, 1
                clc                     ; Indicate copy needs to be done
                jmp     short copy_done

no_copy:        add     di, cx
                stc

copy_done:      ret

check_copy_code ENDP

get_equipment   PROC    NEAR

                int     11H
                push    ax
                rol     ax, 1
                rol     ax, 1
                and     al, 3
                mov     num_lpt, al
                cmp     al, 3
                jne     @F

                mov     printer_loaded, 0

@@:             pop     ax
                mov     cl, 9
                shr     ax, cl
                and     al, 7
                cmp     al, 4
                jbe     ser_count_ok

                mov     al, 4

ser_count_ok:   mov     num_com, al
                ret

get_equipment   ENDP

baud_buff       db      "115200"
baud_buff_tail  EQU     $ - 1
                db      CR, LF, '$'

show_max_baud   PROC    NEAR
                PUBLIC  show_max_baud

                mov     bl, client_max_baud
                cmp     bl, BAUD_115200
                jb      show_max

                mov     client_max_baud, BAUD_115200
                jmp     short show_max_ret

show_max:       pmsg    m_max_baud
                xor     bh, bh
                mov     dl, cs:baud_table_high[bx]
                xor     dh, dh
                shl     bx, 1
                mov     ax, cs:baud_table_low[bx]
                mov     di, DVR:baud_buff_tail

            	mov     bx, ax      ;DX:BX = value
                mov     cx, 10      ;Get radix to CX

next_digit:     xchg    ax,dx       ;Divide hi
	            xor     dx,dx
	            div     cx          ;DX = rem, AX = hi div
                xchg    ax,bx       ;AX = lo,  BX = hi div
	            div     cx          ;DX = rem, BX:AX = div
	            xchg    ax,dx       ;AX = rem, BX:DX = div
	            xchg    dx,bx       ;AX = rem, DX:BX = div
	            add     al,'0'
                mov     cs:[di], al
                dec     di
	            mov     ax,dx
	            or      ax,bx
	            jnz     next_digit

                inc     di
                mov     dx, di
                call    print_msg

show_max_ret:   ret

show_max_baud   ENDP


get_dos_version PROC    NEAR            ; Gets dos version numbers

                mov     ax, 3000H       ; Get the dos version number
                int     21H

                xchg    al, ah          ; Put version number in WORD format

                cmp     ax, DOS30       ; Make special check for Zenith DOS 3.30+
                jne     @F

                cmp     bh, 5           ; 5 is Zeniths OEM number
                jne     @F

                mov     ax, DOS331      ; Pretend Zenith-DOS 3.30+ is DOS 3.31

@@:             mov     dos_version, ax
                ret

get_dos_version ENDP

toupper         PROC    NEAR
                PUBLIC  toupper

                cmp     al, 'a'
                jb      toupper_ret

                cmp     al, 'z'
                ja      toupper_ret

                sub     al, 'a' - 'A'

toupper_ret:    ret

toupper         ENDP

arg_table       db      3, 'COM'
                dw      DVR:set_com_port
                db      3, 'LPT'
                dw      DVR:set_lpt_port
                db      3, 'LOW'
                dw      DVR:set_force_low
                db      6, 'DRIVES'
                dw      DVR:set_num_drives
                db      9, 'NOPRINTER'
                dw      DVR:set_noprinter
                db      6, 'NOSCAN'
                dw      DVR:set_noscan
                db      4, 'AUTO'
                dw      DVR:set_auto
                db      4, 'BAUD'
                dw      DVR:set_baud
                db      1, 'V'
                dw      DVR:set_variable
                db      0

parse_line      PROC    NEAR
                PUBLIC  parse_line

                push    si

convert_upper:  mov     al, es:[si]
                cmp     al, ' '
                jb      convert_done

                call    toupper
                mov     es:[si], al
                inc     si
                jmp     convert_upper

convert_done:   pop     si

grab_char:      mov     al, es:[si]
                inc     si
                cmp     al, '/'
                je      found_arg

                cmp     al, '-'
                je      found_arg

                cmp     al, ' '
                je      grab_char

                jb      parse_exit

                mov     di, si
                jmp     short bad_option

found_arg:      mov     di, si
                mov     si, DVR:arg_table
                xor     ch, ch

arg_loop:       lodsb   
                or      al, al
                jz      bad_option

                mov     cl, al
                push    di
        repe    cmpsb
                mov     bl, es:[di]         ; Grab next character
                pop     di
                jne     no_match

                cmp     bl, 'A'
                jb      arg_match

                cmp     bl, 'Z'
                ja      arg_match

no_match:       add     si, cx
                add     si, 2
                jmp     arg_loop

arg_match:      mov     cl, al
                add     di, cx              ; Point past the arg
                lodsw
                mov     si, di
                call    ax
                jmp     grab_char

bad_option:     pmsg    invalid_switch

                mov     dl, es:[di - 1]
                mov     ah, 2
                int     21H

unrecog_loop:   mov     al, es:[di]
                cmp     al, '0'
                jb      unrecog_done

                mov     dl, al
                mov     ah, 2
                int     21H
                inc     di
                jmp     unrecog_loop

unrecog_done:   call    show_crlf
                stc
                jmp     short parse_ret

parse_exit:     clc

parse_ret:      ret

parse_line      ENDP

default_cl      DB      '/LPT* /COM*', CR

get_exe_name    PROC    NEAR

                push    di
                mov     di, DVR:Virt_Dev_File

;--- Skip any leading white space

skip_white:     mov     al, es:[si]
                cmp     al, ' '
                ja      skip_done

                or      al, al
                jz      get_exe_done

                inc     si
                jmp     skip_white

skip_done:      cmp     BYTE PTR es:[si + 1], ':'
                jne     unknown_drive

                mov     ah, es:[si + 1]
                mov     [di], ax
                add     di, 2
                add     si, 2
                jmp     check_root

unknown_drive:  
;                mov     WORD PTR [di], ":?"
                mov     ah, 19H             ;===> Can we really do this? <===
                int     21H
                add     al, 'A'
                mov     ah, ':'
                mov     WORD PTR [di], ax
                add     di, 2                

check_root:     cmp     BYTE PTR es:[si], '\'
                je      copy_exe_name

                mov     BYTE PTR [di], '\'
                inc     di

copy_exe_name:  mov     al, es:[si]
                cmp     al, '/'
                je      get_exe_done

                cmp     al, ' '
                jbe     get_exe_done

                mov     [di], al
                inc     di
                inc     si
                jmp     copy_exe_name

get_exe_done:   pop     di
                ret

get_exe_name    ENDP

parse_args      PROC    NEAR

                call    get_exe_name

IFDEF DEBUG
                push    si
                mov     si, DVR:Virt_Dev_File
                DBG     '<'
                DBG     '<'
                DBG     '<'

show_loop:      lodsb
                or      al, al
                jz      show_done

                DBG     al
                jmp     show_loop

show_done:
                DBG     '>'
                DBG     '>'
                DBG     '>'
                pop     si
ENDIF

;--- Skip any leading white space after .EXE file name

skip_white:     mov     al, es:[si]
                cmp     al, ' '
                jne     skip_non_white

                inc     si
                jmp     skip_white

skip_non_white: 
IFDEF OLD_CODE
                mov     al, es:[si]
                cmp     al, ' '
                jb      parse_default

                je      do_parse

                inc     si
                jmp     skip_non_white
ENDIF

do_parse:       call    parse_line
                jc      parse_fail

                cmp     num_ports, 0
                jne     parse_ok

parse_default:  push    cs
                pop     es
                mov     si, DVR:default_cl
                call    parse_line
                jmp     short parse_done

parse_ok:       clc
                jmp     short parse_done

parse_fail:     stc

parse_done:     ret

parse_args      ENDP

show_port_ser   PROC    NEAR

; Enter with BX = index into serial_ports[]

                mov     al, serial_ports[bx].SERIAL_PORT_DEF.sp_biosnum
                or      al, al
                jz      not_ser_bios

                add     al, '0'
                mov     cs:ser_port_number, al
                pmsg    ser_port_name
                jmp     short show_sp_done

not_ser_bios:   mov     cs:ser_port_number, '$'
                pmsg    ser_port_name
                mov     ax, serial_ports[bx].SERIAL_PORT_DEF.sp_address
                call    show_address

show_sp_done:   ret

show_port_ser   ENDP


show_port_par   PROC    NEAR

                mov     al, parallel_ports[bx].PARALLEL_PORT_DEF.pp_biosnum
                or      al, al
                jz      not_par_bios

                add     al, '0'
                mov     cs:par_port_number, al
                pmsg    par_port_name
                jmp     short show_pp_done

not_par_bios:   mov     cs:par_port_number, '$'
                pmsg    par_port_name
                mov     ax, parallel_ports[bx].PARALLEL_PORT_DEF.pp_address
                call    show_address

show_pp_done:   ret

show_port_par   ENDP


is_alpha        PROC    NEAR
                PUBLIC  is_alpha

                cmp     al, 'A'
                jb      out_of_range

                cmp     al, 'Z'
                jbe     in_range

                cmp     al, 'z'
                ja      out_of_range

                cmp     al, 'a'
                jb      out_of_range

in_range:       clc
                jmp     short alpha_ret

out_of_range:   stc

alpha_ret:      ret

is_alpha        ENDP

find_arg        PROC    NEAR

; Skip the optional colon (or equal sign) and point at the numeric argument
; (if present).
; Error if next character is alphabetic.
; Error if end of command line (< ' ') or '/' seen before argument.

                mov     al, es:[si]
                cmp     al, ':'
                je      colon_or_equal

                cmp     al, '='
                je      colon_or_equal

                jmp     short grab_first

colon_or_equal: inc     si

grab_first:     mov     al, es:[si]
                call    is_alpha
                jnc     arg_error

                clc
                jmp     short arg_ret

arg_error:      stc
                
arg_ret:        ret

find_arg        ENDP

find_port_arg   PROC    NEAR

                mov     al, es:[si]
                cmp     al, ' '
                jbe     fpa_ok                  ; /COM or /LPT is OK

                call    find_arg
                jc      fpa_fail

                mov     al, es:[si]
                cmp     al, '*'
                je      fpa_incr

                cmp     al, '0'
                jb      fpa_fail

                cmp     al, '9'
                jbe     fpa_ok

fpa_fail:       stc
                jmp     short fpa_ret

fpa_incr:       inc     si

fpa_ok:         clc

fpa_ret:        ret

find_port_arg   ENDP

set_force_low   PROC    NEAR

                mov     force_low, 1
                ret

set_force_low   ENDP

set_num_drives  PROC    NEAR

                mov     ax, es:[si]
                cmp     al, ':'
                je      colon_equal

                cmp     al, '='
                je      colon_equal

                jmp     short set_nd_error

colon_equal:    cmp     ah, '0'
                jb      set_nd_error

                cmp     ah, '9'
                ja      set_nd_error

                inc     si
                call    decimal_number
                jc      set_nd_error

                cmp     ax, MAX_DEVICES     ; #### Can we really do this many?
                ja      set_nd_error

                mov     default_units, al
                jmp     short snd_ret

set_nd_error:   pmsg    drives_error

snd_ret:        ret

set_num_drives  ENDP

baud_table_low  dw      1200                ;   1200 baud   (index 0)     
                dw      2400                ;   2400 baud   (index 1)
                dw      4800                ;   4800 baud   (index 2)
                dw      9600                ;   9600 baud   (index 3)
                dw      19200               ;  19200 baud   (index 4)
                dw      38400               ;  38400 baud   (index 5)
                dw      57600               ;  57600 baud   (index 6)
                dw      49664               ; 115200 baud   (index 7)
NUM_BAUD_VALUES EQU     (($ - baud_table_low) / 2)

baud_table_high db      0                   ;   1200 baud   (index 0) 
                db      0                   ;   2400 baud   (index 1)
                db      0                   ;   4800 baud   (index 2)
                db      0                   ;   9600 baud   (index 3)
                db      0                   ;  19200 baud   (index 4)
                db      0                   ;  38400 baud   (index 5)
                db      0                   ;  57600 baud   (index 6)
                db      1                   ; 115200 baud   (index 7)

set_baud        PROC    NEAR
                PUBLIC  set_baud

                mov     ax, es:[si]
                inc     si
                cmp     al, ':'
                je      sb_colon_equal

                cmp     al, '='
                jne     set_baud_error

sb_colon_equal: cmp     ah, '0'
                jb      set_baud_error

                cmp     ah, '9'
                ja      set_baud_error

                call    decimal_number
                jc      set_baud_error

                push    es
                push    cs
                pop     es
                mov     di, DVR:baud_table_low + (2 * 3)
                mov     cx, NUM_BAUD_VALUES
        repne   scasw
                pop     es
                jne     set_baud_error

                sub     di, DVR:baud_table_low + 2
                mov     bx, di
                shr     bx, 1
                cmp     dl, cs:baud_table_high[bx]
                jne     set_baud_error

                mov     client_max_baud, bl
                mov     max_baud, bl
                jmp     short set_baud_ret

set_baud_error: pmsg    m_baud_error

set_baud_ret:   ret

set_baud        ENDP

set_noscan      PROC    NEAR

                inc     noscan
                ret

set_noscan      ENDP


set_auto        PROC    NEAR

                inc     auto
                ret

set_auto        ENDP


set_variable    PROC    NEAR

                inc     fx_force_variable
                ret

set_variable    ENDP


set_noprinter   PROC    NEAR

                mov     printer_loaded, 0
                ret

set_noprinter   ENDP


set_com_port    PROC    NEAR

                call    find_port_arg
                jc      com_bad

                cmp     al, ' '
                jbe     com_wild

                cmp     al, '*'
                jne     com_not_wild

com_wild:       mov     cl, num_com
                xor     ch, ch
                jcxz    c_get_port_ret

                mov     bios_port_num, 1

com_wild_loop:  mov     al, bios_port_num
                xor     ah, ah
                call    set_port_ser
                inc     bios_port_num
                loop    com_wild_loop

                jmp     short c_get_port_ret

com_not_wild:   call    hex_number
                call    set_port_ser
                jmp     short c_get_port_ret

com_bad:        pmsg    m_com_bad

c_get_port_ret: ret

set_com_port    ENDP


set_lpt_port    PROC    NEAR

                call    find_port_arg
                jc      lpt_bad

                cmp     al, ' '
                jbe     lpt_wild

                cmp     al, '*'
                jne     lpt_not_wild

lpt_wild:       mov     cl, num_lpt
                xor     ch, ch
                jcxz    l_get_port_ret

                mov     bios_port_num, 1

lpt_wild_loop:  mov     al, bios_port_num
                xor     ah, ah
                call    set_port_par
                inc     bios_port_num
                loop    lpt_wild_loop

                jmp     short l_get_port_ret

lpt_not_wild:   call    hex_number
                call    set_port_par
                jmp     short l_get_port_ret

lpt_bad:        pmsg    m_lpt_bad

l_get_port_ret: ret

set_lpt_port    ENDP


hex_number      PROC    NEAR

; Input:
;   ES:SI pointing at hexadecimal string
;
; Output:
;   AX = binary value
;

                xor     ax, ax          ; Clear accumulator
                mov     cl, 4

hex_loop:       mov     bl, es:[si]     ; Get the next digit
                cmp     bl, '0'         ; Check range
                jb      hex_done

                cmp     bl, 'a'
                jb      check_hex

                sub     bl, 'a' - 'A'   ; Convert to upper case

check_hex:      cmp     bl, '9'
                jbe     is_digit

                cmp     bl, 'F'
                ja      hex_done

                cmp     bl, 'A'
                jb      hex_done

                sub     bl, '7'
                jmp     short add_digit

is_digit:       sub     bl, '0'

add_digit:      shl     ax, cl
                or      al, bl

                inc     si
                jmp     hex_loop

hex_done:       ret

hex_number      ENDP


decimal_number  PROC    NEAR

; Input:
;   ES:SI pointing at decimal string
;
; Output:
;   DX:AX = decimal value
;
; NOTE:  This routine stops scanning after it overflows into DX.  It can
; handle numbers as big as 655350 before it stops scanning.
;

                xor     ax, ax          ; Clear accumulator
                xor     bx, bx
                xor     dx, dx
                mov     di, 10          ; Base 10 multiplier

decimal_loop:   mov     bl, es:[si]     ; Get the next digit
                cmp     bl, '0'         ; Check range
                jb      decimal_ret

                cmp     bl, '9'
                ja      decimal_ret

                sub     bl, '0'         ; It's a digit, so normalize it
                or      dx, dx
                jnz     dec_overflow

                mul     di              ; Multiply previous value by 10
                add     ax, bx          ; Add in new 'ones' value
                adc     dx, 0
                inc     si
                jmp     decimal_loop

decimal_ret:    clc
                ret

dec_overflow:   stc
                ret

decimal_number  ENDP


validate_port   PROC    NEAR

                test    ax, 3
                jnz     bad_port

                cmp     ax, 200H
                jb      bad_port

                cmp     ax, 8000H
                jae     bad_port

                clc
                jmp     short vp_ret

bad_port:       stc

vp_ret:         ret

validate_port   ENDP

set_port_ser    PROC    NEAR

                push    cx
                or      ax, ax
                jz      bad_ser_addr

                cmp     ax, 4
                ja      ser_do_set

                cmp     al, num_com
                ja      bad_bios_ser

                mov     bios_port_num, al
                push    es
                mov     bx, 40H
                mov     es, bx
                dec     ax
                mov     di, ax
                shl     di, 1               ; Serial table at 40:0
                mov     ax, es:[di]
                pop     es

ser_do_set:     call    validate_port
                jc      bad_ser_addr

                xor     bx, bx
                mov     cl, 0

walk_ser:       cmp     cl, num_ser_ports
                jae     new_ser

                cmp     ax, serial_ports[bx].SERIAL_PORT_DEF.sp_address
                je      set_port_ret                ; Ignore duplicate address

                inc     cl
                add     bx, TYPE SERIAL_PORT_DEF
                jmp     walk_ser

new_ser:        cmp     num_ser_ports, MAX_SERIAL_PORTS
                jae     too_many_ser

                mov     serial_ports[bx].SERIAL_PORT_DEF.sp_address, ax
                push    es
                push    di
                xor     di, di
                mov     cx, 40H
                mov     es, cx
                mov     cl, num_com
                xor     ch, ch
        repne   scasw
                mov     ax, di
                pop     di
                pop     es
                je      save_ser_bios

                xor     ax, ax

save_ser_bios:  shr     al, 1
                mov     serial_ports[bx].SERIAL_PORT_DEF.sp_biosnum, al
                inc     num_ser_ports
                inc     num_ports
                jmp     short set_port_ret

bad_ser_addr:   push    ax
                pmsg    m_bad_ser_addr
                jmp     short show_hex_addr

bad_bios_ser:   push    ax
                pmsg    m_bad_bios_ser
                jmp     short show_hex_addr

too_many_ser:   push    ax
                pmsg    m_too_many_ser

show_hex_addr:  pop     ax
                call    show_hex
                call    show_crlf

set_port_ret:   pop     cx
                ret

set_port_ser    ENDP

set_port_par    PROC    NEAR

                push    cx
                or      ax, ax
                jz      bad_par_addr

                cmp     ax, 3
                ja      par_do_set

                cmp     al, num_lpt
                ja      bad_bios_par

                mov     bios_port_num, al
                push    es
                mov     bx, 40H
                mov     es, bx
                dec     ax
                mov     di, ax
                shl     di, 1               ; Serial table at 40:0
                add     di, 8               ; Parallel table at 40:8
                mov     ax, es:[di]
                pop     es

par_do_set:     call    validate_port
                jc      bad_par_addr

                xor     bx, bx
                mov     cl, 0

walk_par:       cmp     cl, num_par_ports
                jae     new_par

                cmp     ax, parallel_ports[bx].PARALLEL_PORT_DEF.pp_address
                je      par_sp_ret          ; Ignore duplicate address

                inc     cl
                add     bx, TYPE PARALLEL_PORT_DEF
                jmp     walk_par

new_par:        cmp     num_par_ports, MAX_PARALLEL_PORTS
                jae     too_many_par

                mov     parallel_ports[bx].PARALLEL_PORT_DEF.pp_address, ax
                push    es
                push    di
                mov     di, 8
                mov     cx, 40H
                mov     es, cx
                mov     cl, num_lpt
                xor     ch, ch
        repne   scasw
                mov     ax, di
                pop     di
                pop     es
                je      save_par_bios

                mov     al, 8

save_par_bios:  sub     al, 8
                shr     al, 1
                mov     parallel_ports[bx].PARALLEL_PORT_DEF.pp_biosnum, al
                inc     num_par_ports
                inc     num_ports
                jmp     short par_sp_ret

bad_par_addr:   push    ax
                pmsg    m_bad_par_addr
                jmp     short show_hex_par

bad_bios_par:   push    ax
                pmsg    m_bad_bios_par
                jmp     short show_hex_par

too_many_par:   push    ax
                pmsg    m_too_many_par

show_hex_par:   pop     ax
                call    show_hex
                call    show_crlf

par_sp_ret:     pop     cx
                ret

set_port_par    ENDP

show_crlf       PROC    NEAR

                pmsg    cr_lf
                ret

show_crlf       ENDP

show_hex        PROC    NEAR

                push    bx
                push    cx
                mov     bx, 3
                mov     cl, 4

skip_zero_loop: test    ah, 0F0H
                jnz     show_digits

                rol     ax, cl
                dec     bx
                jnz     skip_zero_loop

show_digits:    inc     bx

show_dig_loop:  rol     ax, cl
                mov     dl, al
                and     dl, 0FH
                add     dl, '0'
                cmp     dl, '9'
                jbe     show_dig

                add     dl, 7

show_dig:       call    show_char
                dec     bx
                jnz     show_dig_loop

                pop     cx
                pop     bx
                ret

show_hex        ENDP

show_address    PROC    NEAR

                mov     dl, '('
                call    show_char
                call    show_hex
                mov     dl, ')'
                call    show_char
                ret

show_address    ENDP

show_char       PROC    NEAR
                PUBLIC  show_char

                push    ax
                mov     ah, 2
                int     21H
                pop     ax
                ret

show_char       ENDP

IFDEF   DEBUG
wait_message    db      LF, "Hit any key to continue. . .$"

wait_for_key    PROC    NEAR

                pmsg    wait_message

                mov     ah, 08H         ; Wait for any key
                int     21H

                call    show_crlf

                ret

wait_for_key    ENDP
ENDIF

; get_max_secsize finds the largest allowable sector size on the MASTER
; system.  Any device that has a sector size larger that max_secsize on the
; slave system cannot be used!  This subroutine also determines the first
; unit number!
; 
get_max_secsize PROC    NEAR

                mov     ah, 52H         ; Get DOS's list of lists
                int     21H

                ; Use DOS 3.0+ offsets

                mov     ax, es:[bx + 10H]   ; Max sector size
                mov     cl, es:[bx + 20H]   ; First unit

                mov     max_secsize, ax
                mov     first_unit, cl

                ret

get_max_secsize ENDP

read_timer      PROC    NEAR

                pushf
                cli
                mov     al, TIMER_0_LATCH
                out     TIMER_CTL, al   ;Latch current count in 8253
                jmp     short $+2       ;Insure 5 clocks for 8253 recovery time
                in      al, TIMER_0     ;Get low order byte
                mov     ah, al          ;Save it in AH
                jmp     short $+2       ;Insure 5 clocks for 8253 recovery time
                in      al, TIMER_0     ;Get high order byte
                popf
                ret

read_timer      ENDP

; make_client_id gets an arbitrary non-zero number and places it in
; client_id.  This value is used to identify this image of the device driver
; to the server system.  If the ID's don't match in a SERVER_INFO exchange,
; the initialized flag will be cleared to force a re-initialization.
;
make_client_id  PROC    NEAR

                push    bx
                push    cx
                push    dx
                push    si
                push    es
                mov     si, 40H
                mov     es, si
                xor     si, si
                mov     cx, 64

; Build a 32-bit machine ID by XORing the first 64 DWORDS in the BIOS data
; area into DX:BX.  Let DX:BX start with whatever happens to be in them at
; the time.

build_loop:     lodsw
                xor     bx, ax
                lodsw
                xor     dx, ax
                loop    build_loop

                call    read_timer      ; Now XOR timer value into high word
                xor     bx, ax
                call    read_timer      ; and again into low word
                xor     dx, ax

                or      bx, dx
                jnz     @F

                inc     bx              ; insure != 0

@@:             mov     word ptr client_id, bx
                mov     word ptr client_id + 2, dx
                pop     es
                pop     si
                pop     dx
                pop     cx
                pop     bx
                ret

make_client_id ENDP

init_end        LABEL   BYTE

INIT            ENDS

                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\driver\serial.asm ===
;***
;* $Workfile:   serial.asm  $
;* $Revision:   1.3  $
;*   $Author:   Dave Sewell  $
;*     $Date:   25 Jul 1990 12:05:02  $
;***

                TITLE   Serial communications subroutines
                PAGE    66, 132

;NO_TIMEOUT     EQU     1

                INCLUDE drivers.mac
                INCLUDE debug.mac

                PUBLIC  send_pack_serial
                PUBLIC  recv_pack_serial

                PUBLIC  init_port_serial
                PUBLIC  reset_port_serial

                PUBLIC  send_sync_serial

                SUBTTL  Definitions
                PAGE

TIMER_INTERRUPT equ 08H                 ; Timer interrupt vector

; Note on timings:  timer_handler counts how many normal clock ticks pass
; each tick occurs every 55 milli-seconds.  However, from the time that the
; alarm is set to the first tick can be from zero seconds up to 55 milli-
; seconds.  So maximum times should be calculated using the number of ticks
; minus one.  Also, for the same reason, MINIMUM_TICKS must be >= 2.
;
; MINIMUM_TICKS is the minimum time allowed on the timer.  This must be no less
; that 2.  If it is 1, it is possible for the timeout to occur immediately.
;
; For a data segment of 65535 bytes (maximum number of bytes possible) the
; timeout would be 129 ticks (using shift factor 9, minimum 2) or 7.04 seconds.
;

INITIAL_CRC     equ     0FFFFH          ; Initial CRC accumulator
MAGIC_CRC       equ     1D0FH           ; Magic CRC number

OVERRUN_ERROR   EQU     00000010B
PARITY_ERROR    EQU     00000100B
FRAMING_ERROR   EQU     00001000B

DATA_PORT       EQU     0               ; Serial port definitions
INT_ENABLE      EQU     1
INT_ID          EQU     2
LINE_CONTROL    EQU     3
MODEM_CONTROL   EQU     4
LINE_STATUS     EQU     5
MODEM_STATUS    EQU     6

PICSTAT1        EQU     20H
PICSTAT2        EQU     21H
IRQ3_BIT        EQU     08H
IRQ4_BIT        EQU     10H
SPECIFIC_EOI    EQU     60H

DATABITS8       EQU     03H
DATABITS7       EQU     02H

STOPBITS1       EQU     00H
STOPBITS2       EQU     04H

NOPARITY        EQU     00H
ODDPARITY       EQU     08H
EVENPARITY      EQU     18H

PCKTS_TO_UPBAUD EQU     64

INT_MASK        EQU     0FEH        ; All but timer disabled

FX_ERR_FAIL         EQU     -3

CORE            SEGMENT WORD PUBLIC 'CODE'
                PUBLIC  last_operation
                EXTRN   serial_ports:BYTE
                EXTRN   num_ser_ports:BYTE
                EXTRN   crctab:WORD
                EXTRN   crc_errors:WORD
                EXTRN   seq_num:BYTE
                EXTRN   is_serial:BYTE
                EXTRN   busy_semaphore:BYTE
                EXTRN   idle_semaphore:BYTE
                EXTRN   win386_enh_mode:BYTE
                EXTRN   win386_std_mode:BYTE
                EXTRN   win_386_api:DWORD
                EXTRN   win_386_api_ok:BYTE
                EXTRN   port_address:WORD
                EXTRN   save_area:BYTE
                EXTRN   timeout:BYTE
                EXTRN   code_save:WORD
                EXTRN   ticks_remaining:WORD
                EXTRN   set_alarm_time:WORD
                EXTRN   alarm_vector:WORD
                EXTRN   client_max_baud:BYTE
                EXTRN   max_baud:BYTE
                EXTRN   max_serial_block:WORD
                EXTRN   start_packet:WORD
                EXTRN   end_packet:WORD
                EXTRN   fx_force_variable:BYTE
        IFDEF DEBUG
                EXTRN   debug_msg:WORD
                EXTRN   hex_out:WORD
        ENDIF

BAUD_1200       EQU     0
BAUD_2400       EQU     1
BAUD_4800       EQU     2
BAUD_9600       EQU     3
BAUD_19200      EQU     4
BAUD_38400      EQU     5
BAUD_57600      EQU     6
BAUD_115200     EQU     7
                
CONNECT_BAUD    EQU     BAUD_9600

baud_table      db      96          ;   1200 baud   (index 0)
                db      48          ;   2400 baud   (index 1)
                db      24          ;   4800 baud   (index 2)
                db      12          ;   9600 baud   (index 3)
                db       6          ;  19200 baud   (index 4)
                db       3          ;  38400 baud   (index 5)
                db       2          ;  57600 baud   (index 6)
                db       1          ; 115200 baud   (index 7)
NUM_BAUD_VALUES EQU     ($ - baud_table)

desired_baud        db  ?

polite_timer        db  ?

bios_count          db  ?               ; Count of Actual # of BIOS COM ports

interrupt_mask      db  ?               ; Save area for previous interrupt mask

hp_95lx         db      0


                EVEN

timer_save      dd      0               ; Old timer vector
lost_ticks      dw      ?               ; Tick count while timer set

SEND_OPERATION      EQU     0
RECEIVE_OPERATION   EQU     1

MAX_SEND_FAILS  EQU     2

last_operation  db      ?
packet_ok       db      ?
fx_errno        dw      0
fx_baud         db      CONNECT_BAUD
prior_baud      db      ?
recv_buff_ptr   dw      ?               ; Save area for recv buffer ptr
idle_recv_wait  db      0
first_send      db      ?
fx_send_echoplex    db      0
fx_recv_echoplex    db      0
need_send_echo  db      0
echo_byte       db      ?
echo_ret        dw      ?
ax_save         dw      ?
send_fails      db      0

baud_list1      db      ?, 0FFH, 000H, 05AH, 055H, 0AAH, 0F0H, 00FH, 0E7H, 07EH, 0C3H, 03CH, 081H, 018H, 000H, 0FFH
BAUD_LIST_SIZE  EQU     $ - baud_list1
baud_list2      db      ?, 000H, 0FFH, 0A5H, 0AAH, 055H, 0F0H, 00FH, 0FFH, 000H, 018H, 081H, 03CH, 0C3H, 07EH, 0E7H

send_remaining  dw      ?           ; Number of bytes remaining in send

recv_sync_ticks dw      ?

recv_byte_error db      ?

CORE                ENDS


SERIAL              SEGMENT WORD PUBLIC 'CODE'
                    PUBLIC  serial_start

                    ORG     0

serial_start        LABEL   BYTE

;----------------------------------------------------------------------------
timer_handler   PROC   FAR

;*** The two bytes below are modified as follows:
;***    impolite handler set:   1st 2 bytes of:
;***                                            push    ax
;***                                            mov     al, 20H
;***    alarm not set:          jmp short timer_passthru
;***    polite alarm set:       jmp short polite_handler
;***
;*** IMPORTANT: handlers below MUST be within short jump distance from here!!!

                push    ax
                mov     al, 20H         ; Non-Specific EOI
                out     20H, al
                inc     cs:lost_ticks
                dec     cs:ticks_remaining
                jz      @F              ; Jump if time has expired

th_ret:         pop     ax
                iret

@@:             call    modify_code
                jmp     SHORT th_ret                         

polite_handler  LABEL   FAR

                push    ax
                push    bx
                call    GetTicks
                mov     bx, ax
                sub     ax, cs:set_alarm_time
                mov     cs:set_alarm_time, bx       ; Update set_alarm_time
                sub     cs:ticks_remaining, ax
                pop     bx
                pop     ax
                jc      timed_out

                jnz     @F

timed_out:      call    modify_code

@@:             jmp     DWORD PTR cs:timer_save


; timer_passthru -- Interrupt handler when alarm is not set!
;
timer_passthru  LABEL   FAR         ; Interrupt handler while alarm not on!

                cmp     cs:busy_semaphore, 0
                jne     pass_it

                cmp     cs:port_address, 0
                je      pass_it

                cmp     cs:is_serial, 0
                je      pass_it

                cmp     cs:idle_semaphore, 0
                je      pass_it

                cmp     cs:idle_semaphore, 1
                je      do_idle

                dec     cs:idle_semaphore
                mov     cs:idle_recv_wait, 0
                jmp     short pass_it

do_idle:        push    ax
                call    GetTicks
                cmp     ax, cs:set_alarm_time
                mov     cs:set_alarm_time, ax       ; Update set_alarm_time
                pop     ax
                je      pass_it

                call    idle_handler

pass_it:        jmp     cs:timer_save   ; chain through old timer vector

timer_handler   ENDP

made_connection PROC    NEAR

                push    ax
                mov     al, client_max_baud
                mov     max_baud, al            ; Reload max_baud
                DBG     '{'
                HEX     al
                DBG     '}'
                pop     ax
                ret

made_connection ENDP

lost_connection PROC    NEAR

                mov     port_address, 0     ; Connection lost
                mov     idle_semaphore, 0
                ret

lost_connection ENDP


idle_handler    PROC    NEAR

                push    ax
                push    bx
                push    dx
                push    ds
                push    cs
                pop     ds              ; Load DS with our segment
                mov     last_operation, SEND_OPERATION
                mov     dx, port_address
                mov     al, seq_num
                xor     al, 1               ; Toggle low order sequence bit
                or      al, IDLE_BITS
                mov     bx, ax              ; Save copy of idle byte in BL
                cmp     win_386_api_ok, 0
                jne     send_by_vfxd

                call    SendByte            ; Send idle if status is ready
                call    GetByte
                jmp     short check_response

send_by_vfxd:   mov     ax, SERIAL_IDLER        ; function to send idle
                call    dword ptr win_386_api   ; Note: idle passed in BL

check_response: jc      no_recv

                cmp     al, bl
                jne     no_recv

                mov     idle_recv_wait, 0
                jmp     short idle_ret

no_recv:        inc     idle_recv_wait
                cmp     idle_recv_wait, 2 * MINIMUM_TICKS
                jbe     idle_ret

drop_connect:   call    lost_connection

idle_ret:       pop     ds
                pop     dx
                pop     bx
                pop     ax
                ret

idle_handler    ENDP


;----------------------------------------------------------------------------

modify_code     PROC    NEAR

; Destroys NOTHING

                cmp     cs:timeout, 1
                je      modify_ret

                push    ax
                mov     cs:timeout, 1
                mov     ax, 0EBH OR ((OFFSET send_byte_fail - (OFFSET sbs1 + 2)) SHL 8)
                xchg    ax, WORD PTR cs:sbs1
                mov     cs:code_save[0], ax
                mov     ax, 0EBH OR ((OFFSET recv_byte_fail - (OFFSET rbs1 + 2)) SHL 8)
                xchg    ax, WORD PTR cs:rbs1
                mov     cs:code_save[2], ax
                pop     ax

modify_ret:     ret

modify_code     ENDP


; set_alarm_ser -- Starts the alarm counting down ticks.
;
; Destroys registers: None
;
; set_alarm_ser changes the timer interrupt vector from timer_passthru to
; timer_handler_ser.  Before calling this routine start_transaction must have
; been called.  Also, alarm_vector should be set to the offset of the timeout
; code and ticks_remaining should be set to the number of ticks before a
; timeout trap should occur.  Since the granularity of the alarm is  tick,
; ticks_remaining should always be set to 2 or more (if set to 1, a timeout
; could occur immediately after the return from this routine).
;
set_alarm_ser   PROC    NEAR

; Destroys NOTHING

                push    ax
                mov     cs:timeout, 0
                mov     cs:lost_ticks, 0    ; Clear the lost ticks count
    IFDEF   NO_TIMEOUT
                mov     WORD PTR cs:timer_handler, 0EBH OR ((OFFSET timer_passthru - (OFFSET timer_handler + 2)) SHL 8)
    ELSE
                mov     al, win386_enh_mode ; Always polite if 386 Enhanced Mode
                or      al, win386_std_mode ; or if standard mode
                or      al, hp_95lx         ; or if running on HP 95LX
                or      al, fx_force_variable   ; or if forced variable mode
                or      polite_timer, al
                cmp     polite_timer, 0
                jnz     set_polite

                cmp     fx_baud, BAUD_9600
                ja      mask_ints

                mov     polite_timer, 1 ; 9600 baud or slower - always polite
                jmp     short set_polite

mask_ints:      in      al, 21H         ; Get current interrupt mask
                mov     interrupt_mask, al

                mov     al, INT_MASK    ; Set our interrupt mask
                out     21H, al

                mov     WORD PTR cs:timer_handler, 0B050H   ; <=== modifies instruction
                jmp     short set_alarm_ret
    ENDIF

set_polite:     call    GetTicks
                mov     set_alarm_time, ax
                mov     WORD PTR cs:timer_handler, 0EBH OR (16H SHL 8)
.ERRE (OFFSET polite_handler - (OFFSET timer_handler + 2)) EQ 16H

set_alarm_ret:  pop     ax
                ret

set_alarm_ser   ENDP


; clear_alarm_ser -- Reset the timer interrupt handler to timer_passthru
;
; Destroys registers: None
;
clear_alarm_ser PROC    NEAR

                mov     WORD PTR cs:timer_handler, 0EBH OR (3AH SHL 8)
.ERRE (OFFSET timer_passthru - (OFFSET timer_handler + 2)) EQ 3AH
                push    ax              ; Preserve Register
                push    cx

    IFNDEF  NO_TIMEOUT
                cmp     polite_timer, 0
                jne     cascade_done

                mov     al, interrupt_mask
                out     21H, al
    ENDIF
                mov     cx, cs:lost_ticks
                jcxz    cascade_done

                cli

ca_cascade:     pushf                   ; make up lost timer ticks
                call    cs:timer_save
                loop    ca_cascade

                sti
                mov     cs:lost_ticks, 0

cascade_done:   cmp     cs:timeout, 0
                je      no_timeout

                mov     ax, cs:code_save[0]
                mov     WORD PTR cs:sbs1, ax
                mov     ax, cs:code_save[2]
                mov     WORD PTR cs:rbs1, ax
                stc
                jmp     short clear_done

no_timeout:     clc

clear_done:     pop     cx
                pop     ax
                ret

clear_alarm_ser ENDP

; send_byte_ser Send byte on serial port
;
; The timeout routines must already be executing before this routine is called.
;
; Inputs:
;   bl      Byte to be sent
;   dx      Base I/O port
;   cx      return address
;
; Outputs: none
;
;   If control returns inline, the character has been sent.  The only other
;   way out of this routine is through a timeout.
;
; Destroys AX only
;

send_byte_fail  LABEL   NEAR

                pop     ax
                sub     dl, LINE_STATUS ; Point back to data output register
                add     sp, 2           ; Pop off the return address
                jmp     WORD PTR cs:alarm_vector

send_byte_ser   PROC    NEAR

; Inputs:
;   dx      Base I/O port
;
; Destroys:
;   AX only - CRC is updated

                push    ax              ; Save current CRC value

                add     dl, LINE_STATUS

@@:             in      al, dx          ; Wait for transmitter holding to empty
                test    al, 20H
sbs1::          jz      @B

                sub     dl, LINE_STATUS ; Point back to data output register
                mov     al, bl          ; Get the byte to output.
                out     dx, al          ; and output it.

                pop     ax              ; restore current CRC value
                push    bx
                xchg    ah, al
                xor     al, bl
                xor     bx, bx
                xchg    bl, al
                shl     bx, 1
                xor     ax, crctab[bx]
                pop     bx
                ret

send_byte_ser   ENDP

send_byte_echo  PROC    NEAR

                cmp     fx_send_echoplex, 0
                je      send_byte_ser

                pop     echo_ret         ; Pop off return address
                mov     echo_byte, bl
                call    send_byte_ser
                mov     ax_save, ax

wait_echo:      call    bp
                cmp     bl, echo_byte
                jne     wait_echo

                mov     ax, ax_save
                jmp     echo_ret

send_byte_echo  ENDP

last_ticks      dw      0
current_ticks   dw      0

GetTicks        PROC    NEAR

;* Enter with:
;* Uses:
;*      AX = logical tick count returned

                pushf
                cli
                push    es
                push    bx
                mov     ax, 040H
                mov     es, ax
                mov     ax, es:[06CH]
                mov     bx, ax
                sub     ax, cs:last_ticks
                mov     cs:last_ticks, bx
                cmp     ax, 2 * 18
                jb      @F

;*** NOTE: Elapsed time greater than or equal to 2 seconds means either:
;***
;***    1)  Clock rolled over at midnight, so we adjust by only 1 tick.
;***    2)  User is starting a new timing sequence, so it doesn't matter.

                mov     ax, 1

@@:             add     cs:current_ticks, ax
                mov     ax, cs:current_ticks
                pop     bx
                pop     es
                popf
                ret

GetTicks        ENDP

check_hp_95lx   PROC    NEAR

                push    bx
                push    cx
                push    dx
                push    di
                push    si
                push    bp
                push    es
                mov     hp_95lx, 0
                xor     bx, bx
                mov     ax, 4DD4H
                int     15H
                cmp     bx, "HP"            ; Look for BH = 'H', BL = 'P'
                jne     @F

                inc     hp_95lx

@@:             pop     es
                pop     bp
                pop     si
                pop     di
                pop     dx
                pop     cx
                pop     bx
                ret

check_hp_95lx   ENDP


WaitIdle        PROC    NEAR

;* Uses:
;*      AX
;* Returns:
;*      DX    = port address
;*      CARRY = Timed out

                push    cx
                mov     dx, port_address
                call    GetTicks
                mov     cx, ax

wait_loop:      add     dl, LINE_STATUS
                in      al, dx
                sub     dl, LINE_STATUS
                cmp     al, 60H
                je      wi_done

                rcr     al, 1
                jnc     check_time

                in      al, dx

check_time:     call    GetTicks
                sub     ax, cx
                cmp     ax, 2
                jbe     wait_loop

                stc
                jmp     short wi_ret

wi_done:        clc

wi_ret:         pop     cx
                ret

WaitIdle        ENDP

SetBaud         PROC    NEAR
;* Enter with:
;*      AL = desired baud_table index
;* Uses:
;*      AX
;* Returns:
;*      DX = port base address

                push    cx
                push    si
                push    es
                mov     fx_baud, al
                xor     ah, ah
                mov     si, ax
                call    WaitIdle

                add     dl, LINE_CONTROL
                mov     al, 80H OR NOPARITY OR STOPBITS1 OR DATABITS8
                out     dx, al
                recover

                sub     dl, 2               ; dx -> Baud Rate (MSB)
                xor     al, al              
                out     dx, al
                recover

                dec     dx                  ; dx -> Baud Rate (LSB)
                mov     al, baud_table[si]
                out     dx, al
                recover

                add     dl, LINE_CONTROL
                mov     al, NOPARITY OR STOPBITS1 OR DATABITS8
                out     dx, al
                recover

                sub     dl, LINE_CONTROL
                call    WaitIdle

                pop     es
                pop     si
                pop     cx
                ret

SetBaud         ENDP

; send_sync -- Send synchronization byte
;
;   Inputs: None
;
;   Outputs:
;       CF      Set if synchronization was OK.  Clear otherwise.
;       seq_num Set to zero if Sync was OK.
;
;   Registers used: FLAGS
;
;   The complement of this routine is recv_sync.
;
;   extern int send_sync_ser(void);
;
send_sync_serial        PROC    NEAR

; Destroys AX only

                push    bx
                push    cx
                push    dx
                push    di
                push    si
                push    bp

                mov     si, DVR:ConnectSendAA
                call    GetTicks
                mov     bp, ax              ; Grab current logical tick count
                mov     dx, port_address

sync_loop:      call    si
                jnc     sync_ret            ; Return with NC on success

                call    GetTicks
                sub     ax, bp
                cmp     ax, CONNECT_TICKS
                jb      sync_loop

                stc

sync_ret:       pop     bp
                pop     si
                pop     di
                pop     dx
                pop     cx
                pop     bx
                ret

send_sync_serial        ENDP

GetByte         PROC    NEAR

;* Enter with:
;*      DX = port base address
;* Uses:
;*      AX
;* Performs:    Returns carry set if no byte is available.  If a byte is
;*              read it is returned in AL.

                add     dl, LINE_STATUS
                in      al, dx
                sub     dl, LINE_STATUS
                test    al, 1
                jz      return_error

                in      al, dx
                clc
                ret

return_error:   stc
                ret

GetByte         ENDP

SendByte        PROC    NEAR

;* Enter with:
;*      AL = byte to send
;*      DX = port base address
;* Returns:
;*      JC = byte could not be sent
;*      JNC= byte sent
;* Uses:
;*      ALL REGISTERS PRESERVED
                
                push    ax
                add     dl, LINE_STATUS
                in      al, dx
                sub     dl, LINE_STATUS
                test    al, 20H
                pop     ax
                jz      SendByteFail

                out     dx, al
                clc
                ret

SendByteFail:   stc
                ret

SendByte        ENDP


ConnectSendAA   PROC    NEAR

;* Enter with:
;*      DX = port base address
;*      BX = port vector index
;* Uses:
;*      AX
;* Performs:    Sends AA.  Sets vector to Get00

                mov     al, 0AAH
                call    SendByte
                jc      SendAA_Fail

                DBG     '1'
;--- Reset time here in case Windows did a Device Conflict dialogue

                call    GetTicks
                mov     bp, ax
                mov     si, DVR:ConnectGet00

SendAA_Fail:    stc
                ret

ConnectSendAA   ENDP

ConnectGet00    PROC    NEAR

;* Enter with:
;*      DX = port base address
;*      BX = port vector index
;* Uses:
;*      AX
;* Performs:    Waits to receive 00.  If 00 is received, sets vector to Send55.

                call    GetByte
                jc      Get00_Fail

                DBG     '2'
                DBG     '('
                HEX     al
                DBG     ')'
                cmp     al, 0
                jne     Get00_Fail

                call    GetTicks
                mov     bp, ax                      ; Reset timeout
                mov     si, DVR:ConnectSend55

Get00_Fail:     stc
                ret

ConnectGet00    ENDP

ConnectSend55   PROC    NEAR

;* Enter with:
;*      DX = port base address
;*      BX = port vector index
;* Uses:
;*      AX
;* Performs:    Sends 55.  Sets vector to GetFF

                mov     al, 055H
                call    SendByte
                jc      Send55_Fail

                DBG     '3'
                mov     si, DVR:ConnectGetFF

Send55_Fail:    stc
                ret

ConnectSend55   ENDP


ConnectGetFF    PROC    NEAR

;* Enter with:
;*      DX = port base address
;*      BX = port vector index
;* Uses:
;*      AX
;* Performs:    Waits to receive FF.  If FF is received, sets vector to Send5A

                call    GetByte
                jc      GetFF_Fail

                DBG     '4'
                DBG     '('
                HEX     al
                DBG     ')'
                cmp     al, 0FFH
                jne     GetFF_Fail

                call    GetTicks
                mov     bp, ax                      ; Reset timeout
                mov     si, DVR:ConnectSend5A

GetFF_Fail:     stc
                ret

ConnectGetFF    ENDP

ConnectSend5A   PROC    NEAR

;* Enter with:
;*      DX = port base address
;*      BX = port vector index
;* Uses:
;*      AX
;* Performs:    Sends 5A.  Sets vector to Get11

                mov     al, 05AH
                call    SendByte
                jc      Send5A_Fail

                DBG     '5'
                mov     si, DVR:ConnectGet11

Send5A_Fail:    stc
                ret

ConnectSend5A   ENDP


ConnectGet11    PROC    NEAR

;* Enter with:
;*      DX = port base address
;*      BX = port vector index
;* Uses:
;*      AX
;* Performs:    Waits to receive 11.  If 11 is received, returns success.

                call    GetByte
                jc      Get11_Fail

                DBG     '6'
                DBG     '('
                HEX     al
                DBG     ')'
                cmp     al, 011H
                jne     Get11_Fail

                call    made_connection
                mov     last_operation, SEND_OPERATION
                mov     seq_num, 0      ; reset sequence number
                mov     need_send_echo, 0
                mov     fx_send_echoplex, 0
                mov     fx_recv_echoplex, 0
                mov     first_send, 1
                clc
                ret

Get11_Fail:     stc
                ret

ConnectGet11    ENDP

send_baud_rate  PROC    NEAR
;   Inputs:
;       cl          desired baud rate index
;   Outputs:        JC: Set baud attempt failed, fx_errno = -4
;                   JNC: No loss of connection
;                        NOTE: baud rate may not actually have changed

                push    bx
                push    cx
                push    di
                mov     al, fx_baud
                mov     prior_baud, al
                mov     cs:ticks_remaining, SYNC_TICKS
                mov     cs:alarm_vector, DVR:time_out
                mov     polite_timer, 1
                DBG     '{'
                call    set_alarm_ser

                cmp     last_operation, RECEIVE_OPERATION
                jne     sent_last           ; if the last operation was a receive
                                            ; then we just sent a packet_ok, and
wait_turn:      call    bp                  ; need to receive the channel turn-
                HEX     bl
                DBG     ','
                cmp     bl, seq_num         ; around byte
                jne     wait_turn

                mov     last_operation, SEND_OPERATION

sent_last:      mov     bl, seq_num
                not     bl
                mov     bh, bl              ; Save byte we will expect in BH
                not     bh
                HEX     bl
                call    send_byte_ser       ; send baud rate change request
                DBG     '|'

wait_sync:      call    bp                  ; receive acknowledgement
                HEX     bl
                cmp     bl, bh              ; check for current sequence
                jne     wait_sync

                DBG     '}'
                call    clear_alarm_ser
                mov     cs:alarm_vector, DVR:request_fail
                mov     cs:ticks_remaining, MINIMUM_TICKS
                mov     polite_timer, 1
                call    set_alarm_ser

                mov     bl, cl
                call    send_byte_ser       ; send back desired baud

                mov     al, bl
                call    clear_alarm_ser
                call    SetBaud

                mov     cs:alarm_vector, DVR:change_fail
                mov     cs:ticks_remaining, 2 * MINIMUM_TICKS
                mov     polite_timer, 1
                call    set_alarm_ser

                shl     cl, 1
                shl     cl, 1
                shl     cl, 1
                shl     cl, 1               ; Get baud value to high nibble
                or      cl, seq_num

get_answer:     call    bp                  ; Receive answer
                cmp     bl, cl
                jne     get_answer

                mov     baud_list1[0], cl
                not     cl
                mov     baud_list2[0], cl
                xor     di, di

sbr_send_loop:  mov     bl, baud_list1[di]
                call    send_byte_ser       ; send new baud rate again
sbr_recv_loop:  call    bp
                cmp     bl, baud_list2[di]
                jne     sbr_recv_loop

                inc     di
                cmp     di, BAUD_LIST_SIZE
                jb      sbr_send_loop

return_ok:      call    clear_alarm_ser
                mov     fx_errno, 0
                clc
                jmp     short sbr_ret

request_fail:   call    clear_alarm_ser
                DBG     '@'
                mov     fx_errno, -4
                stc
                jmp     short sbr_ret

change_fail:    call    clear_alarm_ser
                cmp     cl, prior_baud
                jb      request_fail        ; change error on step down is fatal
                
                DBG     '#'
                mov     al, prior_baud
                mov     max_baud, al
                DBG     '{'
                HEX     al
                DBG     '}'
                call    SetBaud
                jmp     return_ok

time_out:       call    clear_alarm_ser
                DBG     '*'
                mov     fx_errno, 4
                stc

sbr_ret:        pop     di
                pop     cx
                pop     bx
                ret

send_baud_rate  ENDP

goto_max_baud   PROC    NEAR
                
                cmp     first_send, 1
                jne     goto_max_ret

                push    cx
                mov     cl, fx_baud

max_loop:       cmp     cl, max_baud
                je      done                ; done if at max already

                jb      advance

                mov     cl, max_baud
                jmp     short change_rate

advance:        inc     cl
                DBG     ''

change_rate:    call    send_baud_rate
                mov     cl, fx_baud         ; Get actual new baud rate
                jnc     max_loop

done:           pop     cx
                mov     first_send, 0

goto_max_ret:   ret

goto_max_baud   ENDP

setup_recv_byte PROC    NEAR

                mov     bp, DVR:recv_byte_ser
                cmp     win386_enh_mode, 0
                je      setup_ret

                mov     bp, DVR:recv_byte_win

setup_ret:      ret

setup_recv_byte ENDP


; send_pack_serial  Send a packet
;   Inputs:
;       cx      Length of buffer to be sent
;       es:si   Pointer to buffer to be sent
;       seq_num Current packet sequence number
;
;   Outputs:
;       CF      Set if packet succesfully sent
;       seq_num Incremented if packet successfully sent
;
;   Registers Destroyed: all
;
; extern int send_pack_ser(void far *buffer, unsigned int count);
;
send_pack_serial        PROC    NEAR

                mov     send_fails, 0
                call    start_packet
                push    bp
                call    setup_recv_byte
                mov     dx, port_address
                or      dx, dx
                jz      sps_err_ret

                mov     send_remaining, cx
                xor     bl, bl              ; Clear all flags
                call    goto_max_baud       ; Go to max baud if first time

next_block:     mov     cx, send_remaining
                jcxz    split               ; Full 64K packet - must split

                cmp     cx, max_serial_block; remainder > max_serial_block?
                jbe     no_split            ; if not don't split

split:          or      bl, CONTINUED_PACKET; indicate packet to follow
                mov     cx, max_serial_block
                jmp     short send_it

no_split:       and     bl, NOT CONTINUED_PACKET

send_it:        and     bl, NOT ECHOPLEX
                or      bl, need_send_echo
                call    SendSerialBlock     ; attempt transmission
                cmp     fx_errno, -1        ; check for failure
                jl      packet_fail

                cmp     fx_errno, 0
                jne     return

                test    bl, CONTINUED_PACKET
                jz      sps_ok

                mov     ax, max_serial_block
                sub     send_remaining, ax
                add     si, ax              ; advance pointer in buffer
                mov     send_fails, 0
                jmp     next_block          ; send the rest

packet_fail:    cmp     fx_send_echoplex, 0
                jne     @F

                mov     send_fails, 0
                mov     need_send_echo, ECHOPLEX
                jmp     next_block          ; Try again in echoplex

@@:             inc     send_fails
                cmp     send_fails, MAX_SEND_FAILS
                jb      next_block

                mov     cl, fx_baud
                cmp     cl, CONNECT_BAUD
                ja      shift_down

                mov     fx_errno, -1
                xor     ax, ax
                jmp     short sps_fail

shift_down:     dec     cl                  ; drop down one baud rate
                DBG     ''
                call    send_baud_rate      ; if not, then step down baud
                jc      return              ; return the error
                
                mov     send_fails, 0
                mov     need_send_echo, 0
                jmp     next_block

return:         cmp     fx_errno, 0
                jne     sps_fail

sps_ok:         clc
                jmp     short sps_ret

sps_fail:       call    lost_connection

sps_err_ret:    stc

sps_ret:        pop     bp
                call    end_packet
                ret
                
send_pack_serial        ENDP

; SendSerialBlock
;   Inputs:
;       bl          Will have status bits for sync exchange set
;       cx          Length of buffer to be sent
;       es:si       Pointer to buffer to be sent
SendSerialBlock      PROC    NEAR
  
                DBG     ''
                or      ch, ch              ; see if length fits in byte
                jnz     word_length         ; assume clear bit if not
                
                or      bl, BYTE_LENGTH     ; set byte length bit
                jmp     short save_flags

word_length:    and     bl, NOT BYTE_LENGTH ; clear byte length bit

save_flags:     mov     bh, bl
                push    bx
                push    cx
                push    si
                mov     cs:ticks_remaining, SYNC_TICKS
                mov     cs:alarm_vector, DVR:sp_total_fail
                mov     polite_timer, 1
                DBG     '['
                call    set_alarm_ser

                cmp     last_operation, RECEIVE_OPERATION
                jne     ssb_sent_last       ; if the last operation was a receive
                                            ; then we just sent a packet_ok, and
ssb_wait_turn:  call    bp                  ; need to receive the channel turn-
                HEX     bl
                DBG     ','
                cmp     bl, seq_num         ; around byte
                jne     ssb_wait_turn

                mov     last_operation, SEND_OPERATION

ssb_sent_last:  call    drain               ; Drain away leftovers
                mov     bl, bh
                or      bl, seq_num         ; Add sequence to status bits
                mov     packet_ok, bl       ; packet_ok is original sync with
                HEX     bl
                call    send_byte_ser
                DBG     '|'

                not     bl                  ; sync_ans is inverse of sync
                mov     bh, bl
                and     bh, NOT ECHOPLEX

ssb_wait_sync:  call    bp
                HEX     bl
                mov     al, bl
                and     bl, NOT ECHOPLEX
                cmp     bl, bh              ; expect back inverse
                jne     ssb_wait_sync

                and     al, ECHOPLEX
                mov     fx_send_echoplex, al
                DBG     ']'
                call    clear_alarm_ser
                mov     cs:alarm_vector, DVR:sp_fail
                mov     cs:ticks_remaining, 2 * MINIMUM_TICKS
                mov     polite_timer, 1     ; Polite timer while sending
                call    set_alarm_ser

                mov     ax, INITIAL_CRC     ; start CRC calculations in AX
                mov     bl, cl              ; send length (LSB)
                call    send_byte_echo

                or      ch, ch              ; see if length was < 256
                jz      send_data_loop

                mov     bl, ch              ; send length (MSB)
                call    send_byte_echo

send_data_loop: mov     cs:ticks_remaining, 2 * MINIMUM_TICKS
                mov     bl, es:[si]
                inc     si
                call    send_byte_echo
                loop    send_data_loop

                mov     bx, ax              ; get CRC
                not     bx
                mov     cs:ticks_remaining, 2 * MINIMUM_TICKS
                xchg    bl, bh              ; send high byte
                call    send_byte_echo
                mov     bl, bh              ; send low byte
                call    send_byte_ser

get_reply:      mov     cs:ticks_remaining, 2 * MINIMUM_TICKS
                call    bp
                cmp     bl, packet_ok
                jne     sp_bad_reply

                call    clear_alarm_ser
                inc     seq_num
                and     seq_num, 3
                mov     ax, 1
                jmp     short sp_exit

sp_total_fail:  call    clear_alarm_ser
                DBG     '*'
                mov     ax, -1
                jmp     short sp_err_exit

sp_bad_reply:   DBG     '$'

sp_fail:        call    clear_alarm_ser
                DBG     '#'
                mov     ax, FX_ERR_FAIL

sp_err_exit:    mov     fx_errno, ax
                xor     ax, ax
                jmp     short sp_ret

sp_exit:        mov     fx_errno, 0

sp_ret:         pop     si
                pop     cx
                pop     bx
                ret

SendSerialBlock      ENDP


; recv_byte_ser Get a byte from serial port
;
; The timeout routines must already be executing before this routine is called.
;
;
; Inputs:
;   dx                  Base I/O port
;   cx                  return address
;
; Outputs:
;   ah      Line status
;   al      Read character (May be garbled if an error occured)
;
;   If control returns in line, the character was successfully read
;
; Registers used: ax
;

recv_byte_fail  LABEL   NEAR

                sub     dl, LINE_STATUS ; Point DX back where it started
                add     sp, 2           ; Pop off return address from stack
                jmp     cs:alarm_vector

recv_byte_ser   PROC    NEAR

                mov     bl, al          ; Save AL in BL

next_byte:      add     dl, LINE_STATUS 

@@:             in      al, dx          ; Wait for transmitter holding to empty
                shr     al, 1           ; Data Ready?
rbs1::          jnc     @b

                sub     dl, LINE_STATUS
                test    al, ((FRAMING_ERROR OR PARITY_ERROR OR OVERRUN_ERROR) SHR 1)
                jnz     record_error    ; Record error

rb_grab::       in      al, dx          ; grab the character

recv_got_byte:  xchg    bl, al          ; return byte recvd in bl, restore CRC
                push    bx
                xchg    ah, al
                xor     al, bl
                xor     bx, bx
                xchg    bl, al
                shl     bx, 1
                xor     ax, crctab[bx]
                pop     bx
                ret

record_error:   mov     recv_byte_error, al
                in      al, dx
                jmp     next_byte

recv_byte_ser   ENDP

recv_byte_win   PROC    NEAR

                mov     bl, al          ; Save AL in BL

recv_next:      add     dl, LINE_STATUS 

recv_look:      in      al, dx          ; Wait for transmitter holding to empty
                shr     al, 1           ; Data Ready?
                jnc     recv_chek_time

                sub     dl, LINE_STATUS
                test    al, ((FRAMING_ERROR OR PARITY_ERROR OR OVERRUN_ERROR) SHR 1)
                jz      rb_grab         ; ====> Jump to code in above PROC

                mov     recv_byte_error, al
                in      al, dx          ; Throw away possible garbage character
                jmp     recv_next

recv_chek_time: push    ax
                call    GetTicks
                sub     ax, set_alarm_time
                cmp     ax, ticks_remaining
                pop     ax
                jl      recv_look

                jmp     recv_byte_fail

recv_byte_win   ENDP

recv_byte_echo  PROC    NEAR

                pop     echo_ret
                call    bp
                push    ax
                mov     al, bl
                call    SendByte
                pop     ax
                jmp     echo_ret

recv_byte_echo  ENDP

recv_baud_rate  PROC    NEAR
            
                push    bx
                push    cx
                push    di
                push    si
                push    bp
                call    drain
                mov     cs:alarm_vector, DVR:rbr_req_fail
                mov     cs:ticks_remaining, MINIMUM_TICKS
                mov     polite_timer, 1
                call    set_alarm_ser

                mov     bl, bh
                not     bl
                HEX     bl
                DBG     ']'
                call    send_byte_ser       ; send inverse of received byte
                DBG     '<'
                call    bp                  ; expect back desired baud
                HEX     bl
                call    clear_alarm_ser
                cmp     bl, fx_baud
                jb      recv_change         ; Going down - don't look at max

                cmp     bl, max_baud        ; Don't go above max baud
                ja      rbr_ok

recv_change:    DBG     '>'
                mov     al, bl
                mov     bl, fx_baud
                mov     prior_baud, bl
                call    SetBaud

                mov     bh, fx_baud
                mov     cl, 4
                shl     bh, cl
                or      bh, seq_num
                mov     al, bh
                not     al
                mov     baud_list2[0], al
                xor     di, di

rbr_save_time:  call    GetTicks
                mov     cx, ax              ; Save original tick count in CX
                mov     si, ax

send_loop1:     mov     bp, DVR:send_loop1
                mov     al, bh
                call    SendByte
                jc      rbr_check_time

                call    GetTicks
                mov     si, ax
                mov     bp, DVR:get_byte_loop

get_byte_loop:  call    GetByte
                jnc     got_byte

                call    GetTicks
                push    ax
                sub     ax, si
                pop     si
                jnz     send_loop1

                jmp     short rbr_check_time

got_byte:       cmp     al, bh
                jne     rbr_check_time

send_loop:      mov     bp, DVR:send_loop
                mov     al, baud_list2[di]
                call    SendByte
                jc      rbr_check_time

                mov     bp, DVR:recv_loop
                inc     di
                cmp     di, BAUD_LIST_SIZE
                jae     rbr_ok

recv_loop:      call    GetByte
                jc      rbr_check_time

                cmp     al, baud_list1[di]
                je      send_loop

rbr_check_time: call    GetTicks
                sub     ax, cx
                cmp     ax, MINIMUM_TICKS
                ja      rbr_change_fail

                jmp     bp

rbr_req_fail:   call    clear_alarm_ser

rbr_ok:         clc                         ; assume false request, stay in sync
                jmp     short rbr_ret

rbr_change_fail:mov     al, prior_baud
                DBG     '#'
                cmp     al, fx_baud
                jae     rbr_fatal_fail      ; change error on step down is fatal

                mov     max_baud, al
                DBG     '{'
                HEX     al
                DBG     '}'
                call    SetBaud
                clc
                jmp     short rbr_ret

rbr_fatal_fail: mov     ax, 4
                DBG     '~'
                stc

rbr_ret:        pop     bp
                pop     si
                pop     di
                pop     cx
                pop     bx
                ret

recv_baud_rate  ENDP

; recv_pack_serial    Recieve a packet
;   Inputs:
;       es:di       pointer to buffer
;       cx          max size of buffer
;
;   Outputs:
;       CF          Set if packet recieved
;                   Clear if timeout or some other error
;       cx          If no error, number of bytes recieved.  Otherwise, unknown.
;
;   Uses registers: ax bx cx dx si di bp
;
; extern unsigned int recv_pack_serial(void far *buffer, unsigned int count);
;

recv_pack_serial    PROC    NEAR
;   Inputs:
;       cx          Length of buffer to be received
;    es:di          Pointer to buffer to be received

                call    start_packet
                call    check_hp_95lx
                push    bp
                call    setup_recv_byte
                mov     ax, RECV_PACK_TICKS
                mov     recv_sync_ticks, ax
                cmp     port_address, 0
                je      rps_fail

                mov     bx, di
                add     bx, cx
                jc      rps_fail            ; Buff ptr + max count = seg wrap

                xor     bx, bx              ; count received

recv_next_block:
                push    bx                  ; preserve current count
                call    RecvSerialBlock
                mov     recv_sync_ticks, SYNC_TICKS
                jc      recv_error

                test    bl, CONTINUED_PACKET; see if split block received
                jz      rps_return          ; if not we're done

                pop     bx                  ; get prior length
                add     bx, ax              ; add received length
                sub     cx, ax              ; subtract received length
                add     di, ax              ; move up buffer pointer
                jmp     recv_next_block

recv_error:     cmp     fx_errno, -1        ; no retry if we didn't sync
                je      rps_error

                cmp     fx_errno, 0
                jg      rps_error

                pop     bx
                jmp     recv_next_block     ; try again

rps_return:     pop     bx                  ; get prior length
                add     bx, ax              ; add received length
                mov     ax, bx
                clc                         ; Carry clear on success
                jmp     short rps_ret

rps_error:      pop     bx
                call    lost_connection

rps_fail:       xor     ax, ax              ; return 0 for error
                stc                         ; and set carry flag

rps_ret:        pop     bp
                call    end_packet
                ret

recv_pack_serial        ENDP

drain           PROC    NEAR

@@:             add     dl, LINE_STATUS
                in      al, dx
                sub     dl, LINE_STATUS
                test    al, 1
                jz      empty

                in      al, dx
                jmp     @b

empty:          ret

drain           ENDP

IFDEF DEBUG
bell            PROC    NEAR

                mov     ah, 14
                mov     al, 7
		        INT	    10H
                ret

bell            ENDP

display_block   PROC    NEAR

                DBG     '<'
                DBG     '<'
                push    si
                mov     si, recv_buff_ptr

disp_loop:      cmp     si, di
                jae     disp_done

                cmp     si, recv_buff_ptr
                je      @F

                DBG     ','

@@:             mov     al, es:[si]
                HEX     al
                inc     si
                jmp     disp_loop

disp_done:      pop     si
                DBG     '>'
                DBG     '>'
                ret

display_block   ENDP

ENDIF

; RecvSerialBlock       Recieve a packet
;   Inputs:
;       es:di       pointer to buffer
;       cx          max size of buffer
;
;   Outputs:
;       bl          sync byte received
;       CF          Set if packet recieved
;                   Clear if timeout or some other error
;       cx          If no error, number of bytes recieved.  Otherwise, unknown.
;
;   Uses registers: ax bx cx dx si di bp
;
; Slave definition:
;   Inputs:
;       buffer      Far pointer to buffer for data
;       count       size of buffer
;
;   Globals:
;       serial_port base register of port to use
;
;   Returns:
;       integer     number of bytes recieved
;                   zero if some error occured
;
; extern unsigned int recv_pack_ser(void far *buffer, unsigned int count);
;
RecvSerialBlock      PROC    NEAR

                DBG     ''
                push    cx
                push    di
                push    si
                mov     recv_buff_ptr, di
                mov     fx_errno, 0
                mov     dx, port_address
                DBG     '['
                cmp     last_operation, SEND_OPERATION  ; if the last operation was a 
                jne     rsb_sync_retry          ; send, then this side just
                                                ; received a packet_ok, and 
                mov     al, seq_num             ; needs to send a byte to turn
                HEX     al
                DBG     ','
                call    SendByte                ; around the channel
                mov     last_operation, RECEIVE_OPERATION

rsb_sync_retry: mov     ax, recv_sync_ticks
                mov     cs:ticks_remaining, ax
                mov     dx, port_address
                mov     cs:alarm_vector, DVR:rp_total_fail
                mov     polite_timer, 1
                call    set_alarm_ser

rsb_wait_sync:  call    bp
                HEX     bl
                DBG     '|'
                mov     bh, bl              ; save copy in high byte
                and     bl, SEQUENCE_BITS   ; check for sequence
                cmp     bl, seq_num
                je      short send_reply

                not     bl                  ; check for inverse of sequence
                and     bl, SEQUENCE_BITS
                cmp     bl, seq_num
                je      @F

                jmp     rsb_wait_sync

@@:             call    clear_alarm_ser
                call    recv_baud_rate
                jnc     rsb_sync_retry

                DBG     '@'
                jmp     rp_err_ret

send_reply:     call    clear_alarm_ser
                call    drain
                mov     packet_ok, bh
                mov     ah, bh
                and     ah, ECHOPLEX
                cmp     fx_force_variable, 0
                jne     force_echoplex

                cmp     win386_enh_mode, 0
                jne     force_echoplex  ; Force echoplex if 386 Enhanced Mode

                cmp     hp_95lx, 0      ; Force echoplex if on HP 95LX
                je      @F

force_echoplex: or      ah, ECHOPLEX

@@:             mov     fx_recv_echoplex, ah
                mov     bl, bh
                xor     bh, bh          ; Zero out BH for later
                not     bl              ; send inverse
                and     bl, NOT ECHOPLEX
                or      bl, ah          ; BL has reply byte to send back
                HEX     bl
                mov     cs:alarm_vector, DVR:rp_fail
                mov     cs:ticks_remaining, MINIMUM_TICKS
                mov     al, fx_recv_echoplex
                mov     polite_timer, al    ; Use polite timer if echoplex
                call    set_alarm_ser
                mov     recv_byte_error, 0
                test    fx_recv_echoplex, ECHOPLEX
                jnz     echo_recv

                call    send_byte_ser   ; Send reply
                DBG     ']'
                mov     ax, INITIAL_CRC ; start CRC calculation
                call    bp              ; Length (LSB)
                test    packet_ok, BYTE_LENGTH
                jnz     skip_len_byte

                mov     bh, bl          ; save LSB in bh
                call    bp              ; Length (MSB)
                xchg    bh, bl          ; flip bytes to correct order

skip_len_byte:  dec     bx
                dec     cx
                cmp     bx, cx          ; See if packet is to big for buffer
                ja      len_too_big

                inc     bx
                mov     cx, bx          ; Count to CX

read_data_loop: call    bp
                mov     cs:ticks_remaining, MINIMUM_TICKS
                mov     es:[di], bl
                inc     di
                loop    read_data_loop

                call    bp
                call    bp
                jmp     recv_common

;--- Echoed version

echo_recv:      call    send_byte_ser   ; Send reply
                DBG     ']'
                mov     ax, INITIAL_CRC ; start CRC calculation
                call    recv_byte_echo  ; Length (LSB)
                test    packet_ok, BYTE_LENGTH
                jnz     skip_len2

                mov     bh, bl          ; save LSB in bh
                call    recv_byte_echo              ; Length (MSB)
                xchg    bh, bl          ; flip bytes to correct order

skip_len2:      dec     bx
                dec     cx
                cmp     bx, cx          ; See if packet is to big for buffer
                ja      len_too_big

                inc     bx
                mov     cx, bx          ; Count to CX

read_data2:     call    recv_byte_echo
                mov     cs:ticks_remaining, MINIMUM_TICKS
                mov     es:[di], bl
                inc     di
                loop    read_data2

                call    recv_byte_echo
                call    bp

recv_common:    cmp     recv_byte_error, 0
                jne     rb_error

                cmp     ax, MAGIC_CRC   ; Is it a match?
                jne     bad_crc

                ; Send ACK and seq_num back to sender

send_ok:        mov     bl, packet_ok
                mov     cs:ticks_remaining, MINIMUM_TICKS
                call    send_byte_ser

                call    clear_alarm_ser
                inc     seq_num
                and     seq_num, 3
                mov     ax, di
                sub     ax, recv_buff_ptr
                clc
                jmp     rp_ret

rb_error:       DBG     '%'
                DBG     '%'
IFDEF DEBUG
                test    recv_byte_error, (FRAMING_ERROR SHR 1)
                jz      @F

                DBG     'f'

@@:             test    recv_byte_error, (PARITY_ERROR SHR 1)
                jz      @F

                DBG     'p'

@@:             test    recv_byte_error, (OVERRUN_ERROR SHR 1)
                jz      @F

                DBG     'o'
@@:
ENDIF
                jmp     short dump_block

bad_crc:        DBG     '~'
                DBG     '~'
                jmp     short dump_block

;--- Bad length - we dropped something already, so drain the rest.

len_too_big:    DBG     'g'
                DBG     '('
                HEX     bh
                HEX     bl
                DBG     ','
                HEX     ch
                HEX     cl
                DBG     ')'
IFDEF DEBUG
                cmp     recv_byte_error, 0
                jne     rb_error
ENDIF
                jmp     short dump_block

len_zero:       DBG     'z'

dump_block:     mov     cs:ticks_remaining, MINIMUM_TICKS
                call    bp
                jmp     dump_block

rp_total_fail:  call    clear_alarm_ser
                DBG     '*'
                mov     ax, -1
                jmp     short rp_err_ret                

rp_fail:        call    clear_alarm_ser ; Clear alarm clock
                DBG     '#'
                mov     ax, FX_ERR_FAIL

rp_err_ret:     mov     fx_errno, ax
                xor     ax, ax
                stc

rp_ret:         mov     bl, packet_ok       ; return split flag for RecvSerial
                pop     si
                pop     di
                pop     cx
                ret

RecvSerialBlock      ENDP

init_polling    PROC    NEAR

; Destroys AX only
     
                push    dx
                mov     dx, port_address
                inc     dx              ; dx -> Interrupt Enable
                xor     al, al
                out     dx, al          ; Turn off all interrupts
                recover

                add     dl, MODEM_CONTROL - INT_ENABLE  ; dx -> Modem Control
                xor     al, al          ; Disable OUT2 & insure not in loopback
                out     dx, al
                recover

                mov     al, fx_baud
                call    SetBaud
                pop     dx
                ret

init_polling    ENDP


; init_port_serial  Initialize I/O port
;
;   Sets up all initial values needed for communications on the port, caputures
;   any needed interrupt vectors and saves necessary values for a subsequent
;   reset_port_serial call.
;
;   Inputs:
;       AL      Bios number for port
;
;
;   Outputs: CF     Set if port successfully initialized, clear otherwise
;
;   Registers used: All
;
;   extern int init_port_ser(unsigned int port_num, unsigned char far *save_area);
;
;
init_port_serial        PROC    NEAR

                mov     fx_baud, CONNECT_BAUD
                mov     dx, port_address
                push    ds
                pop     es
                mov     di, DVR:save_area
                call    WaitIdle        ; Returns with DX = port_address

                inc     dx              ; dx -> Interrupt Enable
                in      al, dx
                recover
                stosb                   ; save_area[0] = Interrupt Enable

                add     dl, MODEM_CONTROL - INT_ENABLE  ; dx -> Modem Control
                in      al, dx
                recover
                stosb                   ; save_area[1] = Modem Control

                dec     dx              ; dx -> Line Control
                in      al, dx
                recover
                stosb                   ; save_area[2] = Line Control

                or      al, 80H
                out     dx, al          ; Set DLAB = 1
                recover

                sub     dl, LINE_CONTROL - INT_ENABLE   ; dx -> Baud Rate (MSB)
                in      al, dx
                recover
                stosb                   ; save_area[3] = Baud Rate (MSB)

                dec     dx              ; dx -> Baud Rate (LSB)
                in      al, dx
                recover
                stosb                   ; save_area[4] = Baud Rate (LSB)

                add     dl, LINE_CONTROL ; Line Control register
                mov     al, NOPARITY OR STOPBITS1 OR DATABITS8
                out     dx, al          ; Set DLAB = 0
                call    init_polling
                ret

init_port_serial        ENDP


; reset_port_serial  Reset the I/O port
;
;   Restores the port registers to there original values, restores any interrupt
;   vectors, and performs any other cleanup needed to release the current
;   communication port.  Essentially this routine undoes what init_port does.
;
;   Inputs:  None
;
;   Outputs: None
;
;   Destroys registers: All   
;
;   NOTE: in the slave version for most of this routine, DS does not point to
;   the data segment!  So if any variables need to be referenced, ds will need
;   to be restored before doing so!
;
;   extern void reset_port_ser(unsigned int base_port, unsigned char far *save_area);
;
reset_port_serial       PROC    NEAR

                push    ax
                mov     dx, port_address
                mov     si, DVR:save_area
                inc     dx              ; dx -> Interrupt Enable
                lodsb
                out     dx, al
                recover

                add     dl, MODEM_CONTROL - INT_ENABLE  ; dx -> Modem Control
                lodsb
                out     dx, al
                recover

                dec     dx              ; dx -> Line Control
                lodsb
                or      al, 80H         ; Set DLAB
                out     dx, al
                recover

                sub     dl, LINE_CONTROL - INT_ENABLE   ; dx -> Baud Rate (MSB)
                lodsb
                out     dx, al                  ;Update high byte of divisor
                recover

                dec     dx              ; dx -> Baud Rate (LSB)
                lodsb
                out     dx, al
                recover

                add     dl, LINE_CONTROL    ; dx -> Line Control
                mov     al, [si - 3]    ; Get back original line control
                out     dx, al
                recover

                sub     dl, LINE_CONTROL    ; dx -> Receive data/Base register
                in      al, dx          ; Read to prime interrupt pump
                pop     ax
                ret

reset_port_serial       ENDP


SERIAL          ENDS

INIT            SEGMENT WORD PUBLIC 'CODE'

                PUBLIC  setup_ports_serial
                PUBLIC  reset_ports_serial

setup_ports_serial      PROC    NEAR

                cmp     num_ser_ports, 0
                je      setup_done

                mov     ax, 3500H + TIMER_INTERRUPT
                int     21H             ; Current timer vector -> timer_save
                mov     WORD PTR timer_save, bx
                mov     WORD PTR timer_save + 2, es
                mov     WORD PTR timer_handler, 0EBH OR (3AH SHL 8)
.ERRE (OFFSET timer_passthru - (OFFSET timer_handler + 2)) EQ 3AH
                mov     dx, DVR:timer_handler
                mov     ax, 2500H + TIMER_INTERRUPT
                int     21H             ; Set timer vector to timer handler

setup_done:     ret

setup_ports_serial      ENDP


reset_ports_serial      PROC    NEAR

                cmp     num_ser_ports, 0
                je      reset_done

                push    ds
                mov     ax, 2500H + TIMER_INTERRUPT
                lds     dx, timer_save
                int     21H
                pop     ds

reset_done:     ret

reset_ports_serial      ENDP

INIT            ENDS

                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\driver\vtd.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	VTD.INC -
;
;   Version:	1.00
;
;   Date:	10-Aug-1988
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   10-Aug-1988 RAL Original
;   12-Oct-1988 RAL Converted to VxD_Service_Table macros
;
;==============================================================================


Begin_Service_Table VTD

VTD_Service	VTD_Get_Version, LOCAL
VTD_Service	VTD_Update_System_Clock, LOCAL
VTD_Service	VTD_Get_Interrupt_Period, LOCAL
VTD_Service	VTD_Begin_Min_Int_Period, LOCAL
VTD_Service	VTD_End_Min_Int_Period, LOCAL
VTD_Service	VTD_Disable_Trapping, LOCAL
VTD_Service	VTD_Enable_Trapping, LOCAL

End_Service_Table VTD
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\driver\vsd.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	Virtual Sound Device Exported Services
;
;   Version:	1.00
;
;   Date:	12-Oct-1988
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   12-Oct-1988 RAL Original
;
;==============================================================================


Begin_Service_Table VSD

VSD_Service VSD_Get_Version, LOCAL
VSD_Service VSD_Bell, LOCAL

End_Service_Table VSD
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\driver\vcd.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	VCD.inc -
;
;   Version:	1.00
;
;   Date:	3-May-1989
;
;   Author:	RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   3-May-1989 RAP
;
;==============================================================================

Begin_Service_Table VCD

VCD_Service	VCD_Get_Version, LOCAL
VCD_Service	VCD_Set_Port_Global, LOCAL
VCD_Service	VCD_Get_Focus, LOCAL
VCD_Service	VCD_Virtualize_Port, LOCAL

End_Service_Table VCD


;***********
;  UART ports and offsets
;
UART_PORTS	equ	7		; # of ports for UART
UART_REG_MASK	equ	7

UART_BAUD_LSB	equ	0		; Least Signif. Byte of BAUD divisor
UART_BAUD_MSB	equ	1		; Most	Signif. Byte of BAUD divisor
UART_RBR	equ	0		; Receive buffer register
UART_THR	equ	0		; Transmit holding register
UART_IER	equ	1		; Interrupt enble register
UART_IIR	equ	2		; Interrupt identity register
UART_LCR	equ	3		; Line control register
UART_MCR	equ	4		; Modem control register
UART_LSR	equ	5		; Line status register
UART_MSR	equ	6		; Modem status register

;***********
;  Interrupt Enable Register Equates
;
IER_MS		equ	08h		; Modem Status
IER_LS		equ	04h		; Line Status
IER_THRE	equ	02h		; Transmit Holding Register Empty
IER_DR		equ	01h		; Data Ready

;***********
;  Interrupt Identity Register Equates
;
IIR_NONE	equ	01h	; No interrupt pending
IIR_LS		equ	06h	; Line Status Interrupt
IIR_DR		equ	04h	; Data Ready Interrupt
IIR_THRE	equ	02h	; Transmit Holding Register Empty
IIR_MS		equ	00h	; Modem Status Interrupt

;***********
;  Line Control Register Equates
;
LCR_DLAB	equ	80h	; Divisor Latch Access

;***********
;  Modem Control Register Equates
;
MCR_INTEN	equ	08h	; Interrupt Enable
MCR_RTS		equ	02h	; Request to Send
MCR_DTR 	equ	01h	; Data Terminal Ready
MCR_Loopback	equ	10h	; Enable Internal Loopback

;***********
;  Line Status Register Equates
;
LSR_THRE	equ	20h	; Transmit Holding Register Empty
LSR_DR		equ	01h	; Data Ready
LSR_OE		equ	02h	; Overrun Error
LSR_PE		equ	04h	; Parity Error
LSR_FE		equ	08h	; Frame Error
LSR_BI		equ	10h	; Break Detected
LSR_ERRBITS	equ	1Eh	; All the error bits
LSR_TXBITS	equ	60h	; THRE and TEMT

;***********
;  Modem Status Register Equates
;
MSR_DELTA	equ	0Fh	; Modem Status DELTA bits
MSR_DCTS	equ	01h	; Delta Clear to Send
MSR_DDSR	equ	02h	; Delta Data Set Ready
MSR_TERI	equ	04h	; Trailing Edge Ring Indicator
MSR_DRLSD	equ	08h	; Delta Receive Line Signal Detect
MSR_CTS 	equ	10h	; Clear to Send
MSR_DSR 	equ	20h	; Data Set Ready
MSR_RING	equ	40h	; Ring Indicator
MSR_RLSD	equ	80h	; Receive Line Signal Detect

;***********
;  Masks for read status flags
;
VCD_Read_LSR_Mask equ   01h     ; Read Line Status Register
VCD_Read_MSR_Mask equ   02h     ; Read Modem Status Register



;***********
;  Flag bits  for VCD_COM_Struc.VCD_Flags
;
VCD_global_port 	equ 00000001b
VCD_global_port_Bit	equ	   0
VCD_IRQ_Init		equ 00000100b	; Set if COM attempted to virt IRQ
VCD_IRQ_Init_Bit	equ	 2
VCD_Owns_IRQ		equ 00001000b	; Set if COM DID virtualize IRQ
VCD_Owns_IRQ_Bit	equ	3
VCD_SetOwner_Event	equ 00100000b	; Set if event scheduled to set owner
VCD_SetOwner_Event_Bit	equ   5
VCD_Windows_Port	equ 01000000b	; Set if Windows has control of this port
VCD_Windows_Port_Bit	equ  6
VCD_Virtualized 	equ 10000000b	; Set if VCD_Virtualize_Port was called
VCD_Virtualized_Bit	equ 7

;***********
;  Flag bits  for VCD_CB_Struc.VCD_CB_Flags
;
VCD_Contended		equ 00000001b	; set if VM contended for port and lost
VCD_Contended_Bit	equ	   0
VCD_CB_Windows_Port	equ 01000000b	; Set if Windows has control of this port
VCD_CB_Windows_Port_Bit equ  6
VCD_Touched		equ 10000000b
VCD_Touched_Bit 	equ 7

.errnz VCD_CB_Windows_Port_Bit - VCD_Windows_Port_Bit

;******************************************************************************
;			  D A T A   S T R U C T U R E S
;******************************************************************************

;***********
;
; Per-VM structure
;
VCD_CB_Struc STRUC
VCD_BAUD_LSB	    db	?	; LSB of virtual BAUD
VCD_BAUD_MSB	    db	?	; MSB of virtual BAUD
VCD_IER 	    db	?	; Virtual Int Enable Reg
VCD_LCR 	    db	?	; Virtual Line Ctrl Reg
VCD_MCR 	    db	?	; Virtual Modem Ctrl Reg
VCD_Read_Stat	    db	?	; Status of LSR & MSR reads
VCD_CB_Flags	    dw	?
		    dd	4 DUP(?); reserved
VCD_CB_Struc ENDS


;***********
;
; Global state data
;
VCD_COM_Struc STRUC

VCD_CB_Offset	dd	?	; Offset in VM control block for per VM data
VCD_Number	db	?	; Either 1 or 2 for COM1 or COM2
VCD_IRQN	db	?	; h/w IRQ number for this device
VCD_Flags	dw	0	; Flags for Mouse, Virtualized, etc.
VCD_IRQ_Desc	dd	?	; Pointer to IRQ descriptor
VCD_Auto_Assign dd	?	; -1 = never auto assign, 0 = always auto assign
				; > 0, auto assign after n msec of no use
VCD_Name	db	8 DUP(?); Pointer to name of COM port
VCD_IObase	dd	?	; Base of IO regs
VCD_Owner	dd	0	; VM handle owning this COM device
VCD_IRQ_Handle	dd	?	; Handle used to talk to VPIC
VCD_Last_Use	dd	?

VCD_COMDEB	dd	?	; linear ptr to Windows COMDEB, if VCD_Windows_Port
VCD_QIn 	dd	?	; linear ptr to input queue, if VCD_Windows_Port
VCD_QOut	dd	?	; linear ptr to output queue, if VCD_Windows_Port

; NOTE:  The bytes BAUD_LSB - Def_MCR MUST BE LEFT IN THIS ORDER.  They are
;        copied into each VMs control block.
VCD_Def_BAUD_LSB    db  ?       ; Default virtual BAUD rate LSB
VCD_Def_BAUD_MSB    db  ?       ; Default virtual BAUD rate MSB
VCD_Def_IER     db      ?       ; Default vitrual Interrupt Enable register
VCD_Def_LCR     db      ?       ; Default virtual Line Control Register
VCD_Def_MCR     db      ?       ; Default virtual Modem Control Register
VCD_Def_LSR     db      ?       ; Default virtual Line Status Register
VCD_Def_MSR     db      ?       ; Default virtual Modem Status Register

VCD_Virt_IIR	db	?	; IIR value read in ring 0

VCD_virt_procs	dd	?

VCD_Hw_Int_Proc 	dd  ?
VCD_Virt_Int_Proc	dd  ?
VCD_EOI_Proc		dd  ?
VCD_Mask_Change_Proc	dd  ?
VCD_IRET_Proc		dd  ?

		dd	4 DUP(?); reserved
VCD_COM_Struc ENDS


VCD_Control_Set_Owner	equ 0


COM_IRQ_Sharable    equ 00000001h


;***********
;
; List of virtualization procs
;
VCD_ProcList_Struc STRUC
; Control proc for handling status change notifications
; proc will be entered with:
;     EAX = message #
;     EBX = VM Handle
;     ESI -> VCD_COM_Struc
VPS_Control_Proc	dd  ?

; Procs for virtualizing the IRQ, 0 = none - use default
; procs will be entered with:
;     EAX = IRQ handle
;     EBX = VM handle
;     ESI -> VCD_COM_Struc
;
VPS_Hw_Int_Proc 	dd  0	; hardware int for IRQ
VPS_Virt_Int_Proc	dd  0	; virtual int for IRQ
VPS_EOI_Proc		dd  0	; EOI for IRQ
VPS_Mask_Change_Proc	dd  0	; mask change for IRQ
VPS_IRET_Proc		dd  0	; virtual iret for IRQ

; Procs for virtualizing I/O while port owned
; procs will be entered with:
;     EBX = VM handle
;     ESI -> VCD_COM_Struc
;     EDX = port #
;     ECX = 0 - Input, 4 - Output
;     AL = data, if output
; procs should return AL = data, if input
VPS_In_RxTxB		dd  ?	; in from receive buffer
VPS_Out_RxTxB		dd  ?	; out to transmit buffer
VPS_In_IER		dd  ?	; in from Interrupt Enable Register
VPS_Out_IER		dd  ?	; out to Interrupt Enable Register
VPS_In_IIR		dd  ?	; in from Interrupt Identification Register
VPS_Out_IIR		dd  ?	; out to Interrupt Identification Register
VPS_In_LCR		dd  ?	; in from Line Control Register
VPS_Out_LCR		dd  ?	; out to Line Control Register
VPS_In_MCR		dd  ?	; in from Modem Control Register
VPS_Out_MCR		dd  ?	; out to Modem Control Register
VPS_In_LSR		dd  ?	; in from Line Status Register
VPS_Out_LSR		dd  ?	; out to Line Status Register
VPS_In_MSR		dd  ?	; in from Modem Status Register
VPS_Out_MSR		dd  ?	; out to Modem Status Register
VCD_ProcList_Struc ENDS


.errnz VCD_Virt_Int_Proc - VCD_Hw_Int_Proc - 4
.errnz VCD_EOI_Proc - VCD_Virt_Int_Proc - 4
.errnz VCD_Mask_Change_Proc - VCD_EOI_Proc - 4
.errnz VCD_IRET_Proc - VCD_Mask_Change_Proc - 4

.errnz VPS_Virt_Int_Proc - VPS_Hw_Int_Proc - 4
.errnz VPS_EOI_Proc - VPS_Virt_Int_Proc - 4
.errnz VPS_Mask_Change_Proc - VPS_EOI_Proc - 4
.errnz VPS_IRET_Proc - VPS_Mask_Change_Proc - 4
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\driver\vild.asm ===
.386p

LINE_STATUS    EQU  5

MICROSOFT_OEM_ID    EQU  0
SEWELL_OEM_ID       EQU  (298 SHL 5)
INTERLNK_ID         EQU  0

VILD_Device_ID EQU  SEWELL_OEM_ID OR INTERLNK_ID

INCLUDE VMM.INC
INCLUDE VTD.INC
INCLUDE VCD.INC
INCLUDE VSD.INC

Declare_Virtual_Device VILD, 0, 72, VILD_Control, VILD_Device_ID, \
		       Undefined_Init_Order, VILD_V86_API_Handler, 

VxD_DATA_SEG

old_priority_flags  dd  ?

can_use_flag_addr   dd  0

VxD_DATA_ENDS

VxD_LOCKED_CODE_SEG

;******************************************************************************
;
;   VILD_Control
;
;   DESCRIPTION:    dispatch control messages to the correct handlers
;
;   ENTRY:
;
;   EXIT:           Carry clear if no error
;
;   USES:
;
;==============================================================================

BeginProc VILD_Control

    cmp     eax, Sys_Critical_Exit
    jne     SHORT VILD_Ctrl_Exit

    mov     ecx, [can_use_flag_addr]
    jecxz   VILD_Ctrl_Exit

    mov     BYTE PTR [ecx], 0

VILD_Ctrl_Exit:
    clc
    ret

EndProc VILD_Control

VxD_LOCKED_CODE_ENDS

VxD_CODE_SEG

;******************************************************************************
;
;   VILD_V86_API_Handler
;

BeginProc VILD_V86_API_Handler

    pushfd
    push    eax
    mov     al, [ebp.Client_al]

    cmp     al, 0
    je      short Serial_Idle

    cmp     al, 1
    je      Set_VMStat_High_Pri_Back

    cmp     al, 2
    je      Reset_VMStat_High_Pri_Back

    cmp     al, 5
    je      short Parallel_Idle

    cmp     al, -1
    je      short Set_OK_Flag


    pop     eax
    popfd
    ret

EndProc VILD_V86_API_Handler


BeginProc Set_OK_Flag

    push    edi   

;
; This should be called only once by only one user, but we'll check
; to make sure.  If a second user is calling this then turn off the
; first one's flag.
;
    mov     edi, [can_use_flag_addr]
    test    edi, edi
    jz      short SOF_Not_Totally_Stupid
    mov     BYTE PTR [edi], 0
SOF_Not_Totally_Stupid:

    movzx   eax, [ebp.Client_DS]
    shl     eax, 4
    movzx   edi, [ebp.Client_DI]
    add     edi, eax
    mov     BYTE PTR [edi], 1
    mov     [can_use_flag_addr], edi

    pop     edi
    pop     eax
    popfd
    ret

 
EndProc Set_OK_Flag


BeginProc Serial_Idle
    
    push    edx
    mov     dx, [ebp.Client_dx]
    add     dl, LINE_STATUS
    in      al, dx
    sub     dl, LINE_STATUS
    test    al, 20h
    jz      short send_byte_fail

    mov     al, [ebp.Client_bl]
    out     dx, al

send_byte_fail:
    add     dl, LINE_STATUS
    in      al, dx
    sub     dl, LINE_STATUS
    test    al, 1
    jz      short set_error

    in      al, dx
    mov     [ebp.Client_al], al
    and     [ebp.Client_flags], 0FFFEh  ; clear carry
    jmp     short return

set_error:    
    or      [ebp.Client_flags], 1       ; set carry

return:
    pop     edx
    pop     eax
    popfd
    ret

EndProc Serial_Idle
    

BeginProc Parallel_Idle
    
    push    edx
    mov     dx, [ebp.Client_dx]
    mov     al, [ebp.Client_bl]
    out     dx, al
    inc     dx
    in      al, dx
    mov     [ebp.Client_al], al
    pop     edx
    pop     eax
    popfd
    ret

EndProc Parallel_Idle
    

BeginProc Set_VMStat_High_Pri_Back

    push    ecx
    push    edx
    push    esi
    VMMcall Get_Time_Slice_Priority
    mov     [old_priority_flags], eax
    or      eax, VMStat_High_Pri_Back
    VMMcall Set_Time_Slice_Priority
    pop     esi
    pop     edx
    pop     ecx
    pop     eax
    popfd
    ret

EndProc Set_VMStat_High_Pri_Back

BeginProc Reset_VMStat_High_Pri_Back

    push    ecx
    push    edx
    push    esi
    VMMcall Get_Time_Slice_Priority
    mov     eax, [old_priority_flags]
    VMMcall Set_Time_Slice_Priority
    pop     esi
    pop     edx
    pop     ecx
    pop     eax
    popfd
    ret

EndProc Reset_VMStat_High_Pri_Back

VxD_CODE_ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\fxlib\clone.c ===
#include "fastlynx.h"
#include <string.h>

#define CTRL_C      3

#define ONE_SECOND  18

#define PROMPT_WAIT (5 * ONE_SECOND + 1)

#define MAX_SYNC_TRIES  3

static int (_far _cdecl *CloneCheckAbort)(void);
static byte _far *loader_ptr;
static byte copying_bootstrap;
static int port_index;

unsigned _near _pascal _fxc_bios_ticks(void);
int _near _pascal _fxc_read_serial(void);
void _near _pascal _fxc_drain(void);
void _near _pascal _fxc_wait_copy(void);
void _near _fastcall _fxc_output(byte value);
void _near _fastcall _fxc_init_port(int port_index);
void _near _pascal _fxc_reset_port(void);
void _near _fastcall _fxc_send_byte(byte value);
int _near _fastcall _fxc_recv_byte(unsigned tick_value);

static int near aborted(void)
{
    static int aborted_flag = FALSE;

    if (aborted_flag || (*CloneCheckAbort)() != 0) {
        aborted_flag = TRUE;
    }
    return aborted_flag;
}

static int near wait(byte *waitlist, unsigned tick_count)
{
    int c;
    byte *ptr;
    unsigned old_ticks, new_ticks;

    old_ticks = _fxc_bios_ticks();
    do {
        c = _fxc_read_serial();
        if (c >= 0) {
            ptr = waitlist;
            while (*ptr) {
                if (*ptr == (byte) c)
                    return (byte) c;
                ptr++;
            }
        }
        new_ticks = _fxc_bios_ticks();
    } while (new_ticks - old_ticks < tick_count);
    return 0;
}

static void _near delay(unsigned tick_count)
{
    wait("", tick_count);
}

static int _near outstr(char const _near *str)
{
    byte list[2];

    list[1] = '\0';
    while (*str) {
//        delay(1);  
        _fxc_output(*str);
        list[0] = *str;
        if ( !wait(list, ONE_SECOND) )      
            return FALSE;
        if (*str == '\r') {
            if ( !wait("\n", ONE_SECOND) )
                return FALSE; 
        }
        str++;
    }
    return TRUE;
}

int _far _fastcall FxCloneInit(int clone_port_index, int remote_port, char const _near *loading_bootstrap_msg, int (_far _cdecl *CheckAbort)(void))
{
    int error_code;
    int got;
    byte prompt_reset;
    static char copy_bootstrap_str[] = "COPY COM#: FXB.COM\r";
    int tried_aux = FALSE;
    extern unsigned _far loader_bios_port;

    CloneCheckAbort = CheckAbort;
    port_index = clone_port_index;
    loader_bios_port = remote_port;
    prompt_reset = FALSE;
    copying_bootstrap = FALSE;
    error_code = 0;
    _fxc_init_port(port_index);
    FxSyncTimeout(2 * SYNC_ONE_SECOND);
begin:
    _fxc_drain();
    _fxc_output(CTRL_C);
    if ( !(got = wait("C", 9)) ) error_code = 1;
    else if ( !(got = wait(">", PROMPT_WAIT)) ) {
        if (!prompt_reset) {
            prompt_reset = TRUE;
            if (outstr("prompt=\r")) goto begin;
            error_code = 8;
        }
        else error_code = 2;
    }
    if (!error_code) {
        delay(ONE_SECOND);
        if ( !outstr("echo ") || !outstr(loading_bootstrap_msg) ||
             !outstr(" > CON\r") ) error_code = 9;
        else {
            if ( !wait(">", PROMPT_WAIT) ) error_code = 10;
            else {
                memcpy(&copy_bootstrap_str[5], "COM", 3);
                copy_bootstrap_str[8] = (char) '1' + (char) remote_port;
start_copy:     delay(ONE_SECOND);
                if ( !outstr(copy_bootstrap_str) )
                    error_code = 4;
            }
        }
    }
    if (error_code) {
        _fxc_reset_port();
        return aborted() ? -1 : error_code;
    }
    if ( wait(">", 3 * ONE_SECOND) ) {  // If prompt came back, SHARE loaded
        if ( (remote_port == 0) && !tried_aux ) {
            tried_aux = TRUE;
            memcpy(&copy_bootstrap_str[5], " AUX", 4);
            goto start_copy;
        }
        else {
            FxCloneExit();
            return aborted() ? -1 : 88;
        }
    }
    return 0;
}

int _far _fastcall FxBootstrapInit(void)
{
    extern byte _far loader_start;
    extern byte _far loader_end;

    copying_bootstrap = TRUE;
    loader_ptr = &loader_start;
    return &loader_end - &loader_start;
}

static int _near terminate_copy(void)
{
    int i;
    int got;

    if (copying_bootstrap) {
        copying_bootstrap = FALSE;
        _fxc_output(0x1a);
        for (i = 0; i < 4; i++) {
            if ( (got = wait(">^", ONE_SECOND / 2)) ) {
                return got;
            }
            _fxc_output(0x1a);
        }
    }
    return 0;
}

int _far _fastcall FxSendBootstrap(int num_bytes)
{
    if ( aborted() ) {
        return -1;
    }
    while (num_bytes--) {
        while ( _fxc_read_serial() >= 0 )
            ;
        _fxc_output(*loader_ptr++);
    }
    return 0;
}

int _far _pascal FxBootstrapVerify(void)
{
    int error_code = 0;
    int got;

    if ( aborted() ) {
        return -1;
    }
    got = terminate_copy();
    if (got == '>')
        return 0;
    else if (got == '^')
        goto got_hat;
    /* Sometimes after copy there is a delay before getting prompt back.    */
    /* NOTE: if the disk is write protected we will get this error.
       Maybe we should check for that condition.
    */
    if ( !(got = wait(">^", 10 * ONE_SECOND)) )
        error_code = 5; 
    else if (got == '^') {
got_hat:
        if ( !outstr("\r") ) error_code = 6;
        else if ( !wait(">", 10 * ONE_SECOND) ) error_code = 7;
    }
    if (error_code)
        _fxc_reset_port();      // Reset current port.
    else
        delay(ONE_SECOND);
    return aborted() ? -1 : error_code;
}

int _far _pascal FxStartBootstrap(void)
{
    int error_code = 0;
    int i;
    static byte check_alive[2] = { CLONE_UNKNOWN_CMD, 0 };
    /***
    * NOTE: The two bytes above correspond to the clone_cmd structure.
    * The first byte is the command code, which is set to unknown so that
    * it will be ignored.  The next byte MUST be a null so that the
    * ok_msg field will be a null string.
    ***/

    _fxc_output(CTRL_C);
    if ( !wait(">", 3 * ONE_SECOND) )
        error_code = 21;
    else if ( !outstr("fxb\r") )
        error_code = 22;
    if (!error_code) {
        delay(ONE_SECOND / 2);
        _fxc_reset_port();
        delay(ONE_SECOND / 2);
        for (i = 0; i < MAX_SYNC_TRIES; i++) {
            if ( FxSendSerialBlock(&check_alive, sizeof(check_alive)) ) {
                // Lengthen timeout for sending files.
                FxSyncTimeout(10 * SYNC_ONE_SECOND);
                break;          // successful
            }
        }
        if (i == MAX_SYNC_TRIES) {           // Couldn't find bootstrap
            error_code = 99;
        }
    }
    return aborted() ? -1 : error_code;
}

int _far _pascal FxCloneExit(void)
{
#define MAX_ATTEMPTS    5
    int attempt;
    int error_code = 11;

#if 0
            if ( got_reply(space_str) )
                error_code = -1;                  // Disk full
            else
#endif
    terminate_copy();                           // Insure copying complete.
    _fxc_init_port(port_index);
    for (attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        if ( !wait(">", ONE_SECOND) ) {
            _fxc_output(CTRL_C);
        }
        else {
            delay(3);
            if ( aborted() ) {
                outstr("del fxb.com\r");
                wait(">", ONE_SECOND);
            }
            if ( outstr("ctty con\r") ) {
                error_code = 0;
                break;
            }
        }
    }
    delay(3);
    _fxc_reset_port();
    return aborted() ? -1 : error_code;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\driver\vmm.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	VMM.INC - Include file for Virtual Machine Manager
;
;   Version:	1.00
;
;   Date:	05-May-1988
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   05-May-1988 RAL Original
;
;==============================================================================


; NON Windows/386 Virtual Device sources can include this file to get some
; useful equates by declaring the symbol "Not_VxD"  If this symbol is defined,
; then everything that has to do with the specifics of the 32 bit environment
; for virtual devices is removed.  Useful equates include:  device ID's, pushad
; structure, BeginDoc/EndDoc/BeginMsg/EndMsg equates, page table equates, etc.



False	EQU	0
True	EQU	NOT False

;
;   These null macros are recognized by a utility program that produces
;   documentation files.
;
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>


BeginDoc
;******************************************************************************
;
;			EQUATES FOR REQUIRED DEVICES
;
;   Device ID formulation note:
;
;	Device ID's are a combination of OEM # and device # in the form:
;
;		xOOOOOOOOOODDDDD
;
;	The high bit of the device ID is reserved for future use.  The next
;	10 bits are the OEM # which is assigned by Microsoft.  The last 5 bits
;	are the device #.  This allows each OEM to create 32 unique devices.
;	If an OEM is creating a replacement for a standard device, then it
;	should re-use the standard ID listed below.  Microsoft reserves the
;	first 16 OEM #'s (0 thru 0Fh)
;
;==============================================================================

Undefined_Device_ID		EQU	00000h
VMM_Device_ID			EQU	00001h	; Used for dynalink table
Debug_Device_ID 		EQU	00002h
VPICD_Device_ID 		EQU	00003h
VDMAD_Device_ID 		EQU	00004h
VTD_Device_ID			EQU	00005h
V86MMGR_Device_ID		EQU	00006h
PageSwap_Device_ID		EQU	00007h
Parity_Device_ID		EQU	00008h
Reboot_Device_ID		EQU	00009h
VDD_Device_ID			EQU	0000Ah
VSD_Device_ID			EQU	0000Bh
VMD_Device_ID			EQU	0000Ch
VKD_Device_ID			EQU	0000Dh
VCD_Device_ID			EQU	0000Eh
VPD_Device_ID			EQU	0000Fh
VHD_Device_ID			EQU	00010h
VMCPD_Device_ID 		EQU	00011h
EBIOS_Device_ID 		EQU	00012h
BIOSXlat_Device_ID		EQU	00013h
VNETBIOS_Device_ID		EQU	00014h
DOSMGR_Device_ID		EQU	00015h
WINLOAD_Device_ID		EQU	00016h
SHELL_Device_ID 		EQU	00017h
VMPoll_Device_ID		EQU	00018h
VPROD_Device_ID 		EQU	00019h
DOSNET_Device_ID		EQU	0001Ah
VFD_Device_ID			EQU	0001Bh
VDD2_Device_ID			EQU	0001Ch	; Secondary display adapter
WINDEBUG_Device_ID		EQU	0001Dh
TSRLoad_Device_ID		EQU	0001Eh	; TSR instance utility ID

;
;   Initialization order equates.  Devices are initialized in order from
;   LOWEST to HIGHEST.	If 2 or more devices have the same initialization
;   order value, then they are initialized in order of occurance, so a
;   specific order is not guaranteed.  Holes have been left to allow maximum
;   flexibility in ordering devices.
;

VMM_Init_Order			EQU	000000000h
Debug_Init_Order		EQU	004000000h
VPROD_Init_Order		EQU	008000000h
VPICD_Init_Order		EQU	00C000000h
VTD_Init_Order			EQU	014000000h
PageSwap_Init_Order		EQU	01C000000h
Parity_Init_Order		EQU	020000000h
Reboot_Init_Order		EQU	024000000h
EBIOS_Init_Order		EQU	026000000h
VDD_Init_Order			EQU	028000000h
VSD_Init_Order			EQU	02C000000h
VCD_Init_Order			EQU	030000000h
VMD_Init_Order			EQU	034000000h
VKD_Init_Order			EQU	038000000h
VPD_Init_Order			EQU	03C000000h
VHD_Init_Order			EQU	040000000h
VFD_Init_Order			EQU	044000000h
VMCPD_Init_Order		EQU	048000000h
BIOSXlat_Init_Order		EQU	050000000h
VNETBIOS_Init_Order		EQU	054000000h
DOSMGR_Init_Order		EQU	058000000h
DOSNET_Init_Order		EQU	05C000000h
WINLOAD_Init_Order		EQU	060000000h
VMPoll_Init_Order		EQU	064000000h

Undefined_Init_Order		EQU	080000000h

WINDEBUG_Init_Order		EQU	081000000h
VDMAD_Init_Order		EQU	090000000h
V86MMGR_Init_Order		EQU	0A0000000h
SHELL_Init_Order		EQU	0B0000000h
EndDoc

;******************************************************************************
;
;   Macro to cause a delay in between I/O accesses to the same device.
;
;------------------------------------------------------------------------------

IO_Delay    macro
jmp $+2
ENDM

Pushad_Struc	STRUC
Pushad_EDI	dd	?		; Client's EDI
Pushad_ESI	dd	?		; Client's ESI
Pushad_EBP	dd	?		; Client's EBP
Pushad_ESP	dd	?		; ESP at pushall
Pushad_EBX	dd	?		; Client's EBX
Pushad_EDX	dd	?		; Client's EDX
Pushad_ECX	dd	?		; Client's ECX
Pushad_EAX	dd	?		; Client's EAX
Pushad_Struc	ENDS



IFNDEF Not_VxD

??_CUR_CODE_SEG = 0


??_CODE  = 1
??_ICODE = 2
??_LCODE = 3
??_RCODE = 4

?_CODE	equ <(??_CUR_CODE_SEG MOD 8) - ??_CODE>
?_ICODE equ <(??_CUR_CODE_SEG MOD 8) - ??_ICODE>
?_LCODE equ <(??_CUR_CODE_SEG MOD 8) - ??_LCODE>
?_RCODE equ <(??_CUR_CODE_SEG MOD 8) - ??_RCODE>

;
;  SEGMENT definitions and order
;

;*	32 Bit locked code
_LTEXT		SEGMENT DWORD USE32 PUBLIC 'CODE'
_LTEXT		ENDS

;*	32 Bit code
_TEXT		SEGMENT DWORD USE32 PUBLIC 'PCODE'
_TEXT		ENDS

;*	32 Bit initialization code
_ITEXT		SEGMENT DWORD USE32 PUBLIC 'ICODE'
_ITEXT		ENDS

;*	Contains 32 Bit locked data
_LDATA		SEGMENT DWORD PUBLIC 'CODE'
_LDATA		ENDS

;*	Contains 32 Bit data
_DATA		SEGMENT DWORD PUBLIC 'PCODE'
_DATA		ENDS

;*	Contains 32 Bit initialization data
_IDATA		SEGMENT DWORD PUBLIC 'ICODE'
_IDATA		ENDS

;*	Real Mode initialization code/data for devices
_RCODE		SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE		ENDS


_LGROUP GROUP _LTEXT, _LDATA
_PGROUP GROUP _TEXT, _DATA
_IGROUP GROUP _ITEXT, _IDATA

	ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT


OFFSET32 EQU <OFFSET FLAT:>


BeginDoc
;==============================================================================
; The following macros are used in defining the routines
;   in a VxD which are going to be registered with VMM as callable entry
;   points. Once registered, the entry points can be called by any other
;   devices via the "VxDCall" macro, defined below. In the comments below,
;   replace "VxD" with the appropriate device name.
;
;*******
;   In the VxD.INC file, put the following lines, replacing <function_name>
;	with an appropriate name describing the function of the routine.
;
;	Begin_Service_Table VxD[,<segname>]
;	VxD_Service <function_name>[,<local segname>]
;	VxD_Service <function_name>[,<local segname>]
;		. . .
;	VxD_Service <function_name>[,<local segname>]
;	End_Service_Table   VxD[,<segname>]
;
;   Note that <segname> is an optional argument and, if specified, the
;	table is put in the segment defined by the macro "yyy_Data_Seg",
;	where yyy=segname. Otherwise the segment is defined by the
;	"VxD_Data_Seg" macro, defined below.
;   Note that <local segname> is an optional argument and, if specified,
;	the procedure's segment is defined by the macro "zzz_Code_Seg",
;	where zzz=segname. Otherwise the segment is defined by the
;	"VxD_Code_Seg" macro, defined below.
;
;*******
; One VxD module should have the following in order to define the entry points:
;Create_VxD_Service_Table = 1			; Only in module where table is
;	INCLUDE     VxD.INC			; Include the table definition
;
;*******
; All modules that want to call the services defined in the table should include
;   VxD.INC, but not define the label "Create_VxD_Service_Table". This
;   will define the service names to be used with the VxDCall macro.
;
EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment
IFB <Def_Segment>
	BST2 Device_Name, VxD
ELSE
	BST2 Device_Name, Def_Segment
ENDIF
	ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table
Def_Segment&_LOCKED_DATA_SEG
Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg
    PUBLIC $&&Procedure
    IF1
    $&&Procedure LABEL DWORD
    ENDIF
    IFDIFI <Local_Seg>, <LOCAL>
	IFNB <Local_Seg>
Local_Seg&&_SEG
	ELSE
Def_Segment&_CODE_SEG
	ENDIF
	EXTRN	@&&Procedure:NEAR
	IFNB <Local_Seg>
Local_Seg&&_ENDS
	ELSE
Def_Segment&_CODE_ENDS
	ENDIF
    ENDIF
	dd	OFFSET32 @&&Procedure
	Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
	Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
	ENDM

ELSE

Device_Name&_Service MACRO Procedure
	Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
	Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
	ENDM

ENDIF

	ENDM

;------------------------------------------------------------------------------

End_Service_Table MACRO Device_Name, Def_Segment

	PURGE	Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table
IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF
ENDIF

	ENDM


;******************************************************************************
;
;   Dword_Align -- Aligns code to dword boundry by inserting nops
;
;------------------------------------------------------------------------------

Dword_Align MACRO Seg_Name
	LOCAL segn
IFNB <Seg_Name>
	segn equ Seg_Name
ELSE
IFE ?_CODE
	segn equ <_TEXT>
ELSE
IFE ?_ICODE
	segn equ <_ITEXT>
ELSE
IFE ?_LCODE
	segn equ <_LTEXT>
ELSE
.err Dword_Align not supported
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
	    ENDM


BeginDoc
;******************************************************************************
;
;   Fatal_Error
;
;   DESCRIPTION:
;	This macro is used to crash Windows/386 when an unrecoverable error
;	is detected.  If Msg_Ptr is ommitted then no error message will be
;	displayed, otherwise Msg_Ptr is the address
;	when the
;
;   PARAMETERS:
;	Msg_Ptr (OPTIONAL) - Points to an ASCIIZ string to display.
;
;   EXIT:
;	To DOS (hopefully).  This macro never returns.
;
;==============================================================================
EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
	pushad
IFB <Msg_Ptr>
	xor	esi, esi
ELSE
	mov	esi, Msg_Ptr
IFB <Exit_Flags>
	xor	eax, eax
ELSE
	mov	eax, Exit_Flags
ENDIF
ENDIF
	VMMcall Fatal_Error_Handler
	ENDM

EF_Hang_On_Exit     EQU     1h


;******************************************************************************
;==============================================================================
;------------------------------------------------------------------------------

BeginDoc
;******************************************************************************
;   The following are control block offsets of items that can be of interest
;	to VxDs.
;*******
; VM status indicates globally interesting VM states
CB_VM_Status		EQU	DWORD PTR 00h

VMStat_Exclusive	EQU	000000000000000000001b	; VM is exclusive mode
VMStat_Exclusive_Bit	EQU	0
VMStat_Background	EQU	000000000000000000010b	; VM runs in background
VMStat_Background_Bit	EQU	1
VMStat_Creating 	EQU	000000000000000000100b	; In process of creating
VMStat_Creating_Bit	EQU	2
VMStat_Suspended	EQU	000000000000000001000b	; VM not scheduled
VMStat_Suspended_Bit	EQU	3
VMStat_Not_Executeable	EQU	000000000000000010000b	; VM partially destroyed
VMStat_Not_Executeable_Bit  EQU 4
VMStat_PM_Exec		EQU	000000000000000100000b	; Currently in PM app
VMStat_PM_Exec_Bit	EQU	5
VMStat_PM_App		EQU	000000000000001000000b	; PM app present in VM
VMStat_PM_App_Bit	EQU	6
VMStat_PM_Use32 	EQU	000000000000010000000b	; PM app is 32-bit
VMStat_PM_Use32_Bit	EQU	7
VMStat_VxD_Exec 	EQU	000000000000100000000b	; Call from VxD
VMStat_VxD_Exec_Bit	EQU	8
VMStat_High_Pri_Back	EQU	000000000001000000000b	; High pri background
VMStat_High_Pri_Back_Bit    EQU 9
VMStat_Blocked		EQU	000000000010000000000b	; Blocked on semaphore
VMStat_Blocked_Bit	EQU	0Ah
VMStat_Awakening	EQU	000000000100000000000b	; Woke up after blocked
VMStat_Awakening_Bit	EQU	0Bh
VMStat_PageableV86	EQU	000000001000000000000b	; part of V86 is pageable (PM app)
VMStat_PageableV86Bit	EQU	0Ch
VMStat_V86IntsLocked	EQU	000000010000000000000b	; Rest of V86 is locked
VMStat_V86IntsLockedBit EQU	0Dh			;  regardless of pager type
VMStat_TS_Sched 	EQU	000000100000000000000b	; Scheduled by time-slicer
VMStat_TS_Sched_Bit	EQU	0Eh
VMStat_Idle		EQU	000001000000000000000b	; VM has released time
VMStat_Idle_Bit 	EQU	0Fh			; slice

VMStat_Use32_Mask	EQU	VMStat_PM_Use32 OR VMStat_VxD_Exec


;*******
; Add this value to a V86 linear address to get address of VM's memory in
;	the VMM linear address space
CB_High_Linear		EQU	DWORD PTR 04h

;*******
CB_Client_Pointer	EQU	DWORD PTR 08h

CB_VMID 		EQU	DWORD PTR 0Ch

;
;   Equates for protected mode application control blocks
;
PMCB_Flags		EQU	DWORD PTR 00h
PMCB_Parent		EQU	DWORD PTR 04h
EndDoc

;******************************************************************************
;			    V M M   S E R V I C E S
;******************************************************************************

Begin_Service_Table VMM, VMM

VMM_Service	Get_VMM_Version, LOCAL		; MUST REMAIN SERVICE 0!

VMM_Service	Get_Cur_VM_Handle
VMM_Service	Test_Cur_VM_Handle
VMM_Service	Get_Sys_VM_Handle
VMM_Service	Test_Sys_VM_Handle
VMM_Service	Validate_VM_Handle

VMM_Service	Get_VMM_Reenter_Count, LOCAL
VMM_Service	Begin_Reentrant_Execution, LOCAL
VMM_Service	End_Reentrant_Execution, LOCAL

VMM_Service	Install_V86_Break_Point
VMM_Service	Remove_V86_Break_Point
VMM_Service	Allocate_V86_Call_Back
VMM_Service	Allocate_PM_Call_Back

VMM_Service	Call_When_VM_Returns


VMM_Service	Schedule_Global_Event
VMM_Service	Schedule_VM_Event
VMM_Service	Call_Global_Event
VMM_Service	Call_VM_Event
VMM_Service	Cancel_Global_Event
VMM_Service	Cancel_VM_Event
VMM_Service	Call_Priority_VM_Event
VMM_Service	Cancel_Priority_VM_Event

VMM_Service	Get_NMI_Handler_Addr, LOCAL
VMM_Service	Set_NMI_Handler_Addr, LOCAL
VMM_Service	Hook_NMI_Event

VMM_Service	Call_When_VM_Ints_Enabled
VMM_Service	Enable_VM_Ints
VMM_Service	Disable_VM_Ints

VMM_Service	Map_Flat
VMM_Service	Map_Lin_To_VM_Addr

;
;   Scheduler services
;
VMM_Service	Adjust_Exec_Priority
VMM_Service	Begin_Critical_Section
VMM_Service	End_Critical_Section
VMM_Service	End_Crit_And_Suspend
VMM_Service	Claim_Critical_Section
VMM_Service	Release_Critical_Section
VMM_Service	Call_When_Not_Critical
VMM_Service	Create_Semaphore
VMM_Service	Destroy_Semaphore
VMM_Service	Wait_Semaphore
VMM_Service	Signal_Semaphore
VMM_Service	Get_Crit_Section_Status
VMM_Service	Call_When_Task_Switched
VMM_Service	Suspend_VM
VMM_Service	Resume_VM
VMM_Service	No_Fail_Resume_VM
VMM_Service	Nuke_VM
VMM_Service	Crash_Cur_VM

VMM_Service	Get_Execution_Focus
VMM_Service	Set_Execution_Focus
VMM_Service	Get_Time_Slice_Priority
VMM_Service	Set_Time_Slice_Priority
VMM_Service	Get_Time_Slice_Granularity
VMM_Service	Set_Time_Slice_Granularity
VMM_Service	Get_Time_Slice_Info
VMM_Service	Adjust_Execution_Time
VMM_Service	Release_Time_Slice
VMM_Service	Wake_Up_VM
VMM_Service	Call_When_Idle

VMM_Service	Get_Next_VM_Handle

;
;   Time-out and system timer services
;
VMM_Service	Set_Global_Time_Out
VMM_Service	Set_VM_Time_Out
VMM_Service	Cancel_Time_Out
VMM_Service	Get_System_Time
VMM_Service	Get_VM_Exec_Time

VMM_Service	Hook_V86_Int_Chain
VMM_Service	Get_V86_Int_Vector
VMM_Service	Set_V86_Int_Vector
VMM_Service	Get_PM_Int_Vector
VMM_Service	Set_PM_Int_Vector

VMM_Service	Simulate_Int
VMM_Service	Simulate_Iret
VMM_Service	Simulate_Far_Call
VMM_Service	Simulate_Far_Jmp
VMM_Service	Simulate_Far_Ret
VMM_Service	Simulate_Far_Ret_N
VMM_Service	Build_Int_Stack_Frame

VMM_Service	Simulate_Push
VMM_Service	Simulate_Pop

;
; Heap Manager
;
VMM_Service	_HeapAllocate
VMM_Service	_HeapReAllocate
VMM_Service	_HeapFree
VMM_Service	_HeapGetSize

; ---------------------------------------------------
;
;	 Flags for heap allocator calls
;
; ---------------------------------------------------


HeapZeroInit	equ	00000000000000000000000000000001B
HeapZeroReInit	equ	00000000000000000000000000000010B
HeapNoCopy	equ	00000000000000000000000000000100B

; NOTE: HIGH 8 BITS (bits 24-31) are reserved


;
; Page Manager
;
VMM_Service	_PageAllocate
VMM_Service	_PageReAllocate
VMM_Service	_PageFree
VMM_Service	_PageLock
VMM_Service	_PageUnLock
VMM_Service	_PageGetSizeAddr
VMM_Service	_PageGetAllocInfo
VMM_Service	_GetFreePageCount
VMM_Service	_GetSysPageCount
VMM_Service	_GetVMPgCount
VMM_Service	_MapIntoV86
VMM_Service	_PhysIntoV86
VMM_Service	_TestGlobalV86Mem
VMM_Service	_ModifyPageBits
VMM_Service	_CopyPageTable
VMM_Service	_LinMapIntoV86
VMM_Service	_LinPageLock
VMM_Service	_LinPageUnLock
VMM_Service	_SetResetV86Pageable
VMM_Service	_GetV86PageableArray
VMM_Service	_PageCheckLinRange
VMM_Service	_PageOutDirtyPages
VMM_Service	_PageDiscardPages

; ---------------------------------------------------
;
;	 Flags for other page allocator calls
;
; ---------------------------------------------------
PageZeroInit		equ	00000000000000000000000000000001B
PageUseAlign		equ	00000000000000000000000000000010B
PageContig		equ	00000000000000000000000000000100B
PageFixed		equ	00000000000000000000000000001000B
PageDEBUGNulFault	equ	00000000000000000000000000010000B
PageZeroReInit		equ	00000000000000000000000000100000B
PageNoCopy		equ	00000000000000000000000001000000B
PageLocked		equ	00000000000000000000000010000000B
PageLockedIfDP		equ	00000000000000000000000100000000B
PageSetV86Pageable	equ	00000000000000000000001000000000B
PageClearV86Pageable	equ	00000000000000000000010000000000B
PageSetV86IntsLocked	equ	00000000000000000000100000000000B
PageClearV86IntsLocked	equ	00000000000000000001000000000000B
PageMarkPageOut 	equ	00000000000000000010000000000000B
PagePDPSetBase		equ	00000000000000000100000000000000B
PagePDPClearBase	equ	00000000000000001000000000000000B
PageDiscard		equ	00000000000000010000000000000000B
PagePDPQueryDirty	equ	00000000000000100000000000000000B

; NOTE: HIGH 8 BITS (bits 24-31) are reserved

;
; Informational services
;
VMM_Service	_GetNulPageHandle
VMM_Service	_GetFirstV86Page
VMM_Service	_MapPhysToLinear
VMM_Service	_GetAppFlatDSAlias
VMM_Service	_SelectorMapFlat
VMM_Service	_GetDemandPageInfo
;
; Data structure for _GetDemandPageInfo
;
DemandInfoStruc struc
DILin_Total_Count     dd	      ?       ; # pages in linear address space
DIPhys_Count	      dd	      ?       ; Count of phys pages
DIFree_Count	      dd	      ?       ; Count of free phys pages
DIUnlock_Count	      dd	      ?       ; Count of unlocked Phys Pages
DILinear_Base_Addr    dd	      ?       ; Base of pageable address space
DILin_Total_Free      dd	      ?       ; Total Count of free linear pages
DIReserved	      dd      10 dup (?)      ; Resvd for expansion
DemandInfoStruc ends

VMM_Service	_GetSetPageOutCount
;
; Flags bits for _GetSetPageOutCount
;
GSPOC_F_Get	equ	00000000000000000000000000000001B

;
; Device VM page manager
;
VMM_Service	Hook_V86_Page
VMM_Service	_Assign_Device_V86_Pages
VMM_Service	_DeAssign_Device_V86_Pages
VMM_Service	_Get_Device_V86_Pages_Array
VMM_Service	MMGR_SetNULPageAddr

;
; GDT/LDT management
;
VMM_Service	_Allocate_GDT_Selector
VMM_Service	_Free_GDT_Selector
VMM_Service	_Allocate_LDT_Selector
VMM_Service	_Free_LDT_Selector
VMM_Service	_BuildDescriptorDWORDs
;
; Flag equates for _BuildDescriptorDWORDs
;
BDDExplicitDPL	EQU	00000000000000000000000000000001B
;
; Flag equates for _Allocate_LDT_Selector
;
ALDTSpecSel	EQU	00000000000000000000000000000001B

VMM_Service	_GetDescriptor
VMM_Service	_SetDescriptor


VMM_Service	_MMGR_Toggle_HMA
;
; Flag equates for _MMGR_Toggle_HMA
;
MMGRHMAPhysical EQU	00000000000000000000000000000001B
MMGRHMAEnable	EQU	00000000000000000000000000000010B
MMGRHMADisable	EQU	00000000000000000000000000000100B
MMGRHMAQuery	EQU	00000000000000000000000000001000B


VMM_Service	Get_Fault_Hook_Addrs, LOCAL
VMM_Service	Hook_V86_Fault, LOCAL
VMM_Service	Hook_PM_Fault, LOCAL
VMM_Service	Hook_VMM_Fault, LOCAL

VMM_Service	Begin_Nest_V86_Exec
VMM_Service	Begin_Nest_Exec
VMM_Service	Exec_Int
VMM_Service	Resume_Exec
VMM_Service	End_Nest_Exec

VMM_Service	Allocate_PM_App_CB_Area, VMM_ICODE
VMM_Service	Get_Cur_PM_App_CB

VMM_Service	Set_V86_Exec_Mode
VMM_Service	Set_PM_Exec_Mode

VMM_Service	Begin_Use_Locked_PM_Stack
VMM_Service	End_Use_Locked_PM_Stack

VMM_Service	Save_Client_State
VMM_Service	Restore_Client_State

VMM_Service	Exec_VxD_Int

VMM_Service	Hook_Device_Service, LOCAL

VMM_Service	Hook_Device_V86_API
VMM_Service	Hook_Device_PM_API

VMM_Service	System_Control

;
;   I/O and software interrupt hooks
;
VMM_Service	Simulate_IO
VMM_Service	Install_Mult_IO_Handlers
VMM_Service	Install_IO_Handler
VMM_Service	Enable_Global_Trapping
VMM_Service	Enable_Local_Trapping
VMM_Service	Disable_Global_Trapping
VMM_Service	Disable_Local_Trapping


;
;   Linked List Abstract Data Type Services
;
VMM_Service	List_Create
VMM_Service	List_Destroy
VMM_Service	List_Allocate
VMM_Service	List_Attach
VMM_Service	List_Attach_Tail
VMM_Service	List_Insert
VMM_Service	List_Remove
VMM_Service	List_Deallocate
VMM_Service	List_Get_First
VMM_Service	List_Get_Next
VMM_Service	List_Remove_First

;
;   Flags used by List_Create
;
LF_Async		EQU	00000001b
LF_Async_Bit		EQU	0
LF_Use_Heap		EQU	00000010b
LF_Use_Heap_Bit 	EQU	1
LF_Alloc_Error		EQU	00000100b
LF_Alloc_Error_Bit	EQU	2


;==============================================================================
;	I N I T I A L I Z A T I O N   P R O C E D U R E S
;------------------------------------------------------------------------------


;
; Instance data manager
;
VMM_Service	_AddInstanceItem
;
; Data structure for _AddInstanceItem
;
InstDataStruc struc
InstLinkF	      dd	      0       ; RESERVED SET TO 0
InstLinkB	      dd	      0       ; RESERVED SET TO 0
InstLinAddr	      dd	      ?       ; Linear address of start of block
InstSize	      dd	      ?       ; Size of block in bytes
InstType	      dd	      ?       ; Type of block
InstDataStruc ends
;
; Values for InstType
;
INDOS_Field	equ	100h	; Bit indicating INDOS switch requirements
ALWAYS_Field	equ	200h	; Bit indicating ALWAYS switch requirements

;
; System structure data manager
;
VMM_Service	_Allocate_Device_CB_Area, VMM_ICODE
VMM_Service	_Allocate_Global_V86_Data_Area, VMM_ICODE
VMM_Service	_Allocate_Temp_V86_Data_Area, VMM_ICODE
VMM_Service	_Free_Temp_V86_Data_Area, VMM_ICODE

;
; Flag bits for _Allocate_Global_VM_Data_Area
;
GVDAWordAlign		EQU		00000000000000000000000000000001B
GVDADWordAlign		EQU		00000000000000000000000000000010B
GVDAParaAlign		EQU		00000000000000000000000000000100B
GVDAPageAlign		EQU		00000000000000000000000000001000B
GVDAInstance		EQU		00000000000000000000000100000000B
GVDAZeroInit		EQU		00000000000000000000001000000000B
GVDAReclaim		EQU		00000000000000000000010000000000B

;
; Initialization information calls (win.ini and environment parameters)
;
VMM_Service	Get_Profile_Decimal_Int, VMM_ICODE
VMM_Service	Convert_Decimal_String, VMM_ICODE
VMM_Service	Get_Profile_Fixed_Point, VMM_ICODE
VMM_Service	Convert_Fixed_Point_String, VMM_ICODE
VMM_Service	Get_Profile_Hex_Int, VMM_ICODE
VMM_Service	Convert_Hex_String, VMM_ICODE
VMM_Service	Get_Profile_Boolean, VMM_ICODE
VMM_Service	Convert_Boolean_String, VMM_ICODE
VMM_Service	Get_Profile_String, VMM_ICODE
VMM_Service	Get_Next_Profile_String, VMM_ICODE
VMM_Service	Get_Environment_String, VMM_ICODE
VMM_Service	Get_Exec_Path, VMM_ICODE
VMM_Service	Get_Config_Directory, VMM_ICODE
VMM_Service	OpenFile, VMM_ICODE
VMM_Service	Get_PSP_Segment, VMM_ICODE
VMM_Service	GetDOSVectors, VMM_ICODE
VMM_Service	Get_Machine_Info

GMIF_80486	EQU	00010000h
GMIF_80486_Bit	EQU	10h
GMIF_PCXT	EQU	00020000h
GMIF_PCXT_Bit	EQU	11h
GMIF_MCA	EQU	00040000h
GMIF_MCA_Bit	EQU	12h
GMIF_EISA	EQU	00080000h
GMIF_EISA_Bit	EQU	13h


;
; Following service is not restricted to initialization
;
VMM_Service	GetSet_HMA_Info
VMM_Service	Set_System_Exit_Code

VMM_Service	Fatal_Error_Handler
VMM_Service	Fatal_Memory_Error

;
;   Called by VTD only
;
VMM_Service	Update_System_Clock

;==============================================================================
;		    D E B U G G I N G	E X T E R N S
;==============================================================================

VMM_Service	Test_Debug_Installed		; Valid call in retail also

VMM_Service	Out_Debug_String		; Valid in DEBLEVEL=1
VMM_Service	Out_Debug_Chr
VMM_Service	In_Debug_Chr
VMM_Service	Debug_Convert_Hex_Binary
VMM_Service	Debug_Convert_Hex_Decimal

VMM_Service	Debug_Test_Valid_Handle
VMM_Service	Validate_Client_Ptr
VMM_Service	Test_Reenter
VMM_Service	Queue_Debug_String
VMM_Service	Log_Proc_Call
VMM_Service	Debug_Test_Cur_VM

.errnz Debug_Test_Cur_VM - 100CCh   ; VMM service table changed above this service

VMM_Service	Get_PM_Int_Type
VMM_Service	Set_PM_Int_Type

VMM_Service	Get_Last_Updated_System_Time
VMM_Service	Get_Last_Updated_VM_Exec_Time

End_Service_Table VMM, VMM



;******************************************************************************

IFDEF DEBUG
DebFar	EQU	NEAR PTR
ELSE
DebFar	EQU	SHORT
ENDIF

BeginDoc

;******************************************************************************
;
;		     EQUATES FOR SYSTEM_CONTROL CALLS
;
;==============================================================================

;
; Sys_Critical_Init is a device init call. Devices that have a critical
;   function that needs initializing before interrupts are enabled should
;   do it at Sys_Critical_Init. Devices which REQUIRE a certain range of
;   V86 pages to operate (such as the VDD video memory) should claim them
;   at Sys_Critical_Init. SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT
;   ALLOWED. Returning carry aborts device load only.
;
Sys_Critical_Init	EQU	0000h		; Devices required for virt mode
;
; Device init is where most devices do the bulk of their initialization.
;   SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
;   aborts device load only.
;
Device_Init		EQU	0001h		; All other devices init
;
; Init_Complete is the final phase of device init called just before the
;   WIN386 INIT pages are released and the Instance snapshot is taken.
;   Devices which wish to search for a region of V86 pages >= A0h to use
;   should do it at Init_Complete.
;   SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
;   aborts device load only.
;
Init_Complete		EQU	0002h		; All devices have initialized

;----------------- INITIALIZATION CODE AND DATA DISCARDED ---------------------

;
; Same as VM_Init, except for SYS VM.
;
Sys_VM_Init		EQU	0003h		; Execute the system VM (Win86)
;
; Same as VM_Terminate, except for SYS VM (Normal WIN386 exit ONLY, on a crash
;   exit this call is not made). SYS VM Simulate_Int, Exec_Int activity is
;   allowed.
;
Sys_VM_Terminate	EQU	0004h		; System VM terminted (exiting)

;------------------------------------------------------------------------------

;
; System_Exit call is made when WIN386 is exiting either normally or via
;   a crash. INTERRUPS ARE ENABLED. Instance snapshot has been restored.
;   SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT ALLOWED.
;
System_Exit		EQU	0005h		; Devices prepare to exit
;
; System_Exit call is made when WIN386 is exiting either normally or via
;   a crash. INTERRUPS ARE DISABLED. SYS VM Simulate_Int, Exec_Int ACTIVITY
;   IS NOT ALLOWED.
;
Sys_Critical_Exit	EQU	0006h		; System critical devices reset

;
; Create_VM creates a new VM. EBX = VM handle of new VM. Returning Carry will
;   fail the Create_VM.
;
Create_VM		EQU	0007h
;
; Second phase of Create_VM. EBX = VM handle of new VM. Returning Carry will
;   cause the VM to go Not_Executeable, then be destroyed. VM Simulate_Int,
;   Exec_Int activity is NOT allowed.
;
VM_Critical_Init	EQU	0008h
;
; Third phase of Create_VM. EBX = VM handle of new VM. Returning Carry will
;   cause the VM to go Not_Executeable, then be destroyed. VM Simulate_Int,
;   Exec_Int activity is allowed.
;
VM_Init 		EQU	0009h

;
; NORMAL (First phase) of Destroy_VM. EBX = VM Hanlde. This occurs on normal
;   termination of the VM. Call cannot be failed. VM Simulate_Int, Exec_Int
;   activity is allowed.
;
VM_Terminate		EQU	000Ah		; Still in VM -- About to die
;
; Second phase of Destroy_VM. EBX = VM Handle, EDX = Flags (see below). Note
;   that in the case of destroying a running VM, this is the first call made
;   (VM_Terminate call does not occur). Call cannot be failed. VM Simulate_Int,
;   Exec_Int activity is NOT allowed.
;
VM_Not_Executeable	EQU	000Bh		; Most devices die (except VDD)
;
; Final phase of Destroy_VM. EBX = VM Handle. Note that considerable time
;   can elaps between the VM_Not_Executeable call and this call. Call cannot
;   be failed. VM Simulate_Int, Exec_Int activity is NOT allowed.
;
Destroy_VM		EQU	000Ch		; VM's control block about to go

;
;   Flags for VM_Not_Executeable control call (passed in EDX)
;
VNE_Crashed		EQU	0000000000000000000000001b
VNE_Crashed_Bit 	EQU	0		; VM was crashed
VNE_Nuked		EQU	0000000000000000000000010b
VNE_Nuked_Bit		EQU	1		; VM was destroyed while active
VNE_CreateFail		EQU	0000000000000000000000100b
VNE_CreateFail_Bit	EQU	2		; Some device failed Create_VM
VNE_CrInitFail		EQU	0000000000000000000001000b
VNE_CrInitFail_Bit	EQU	3		; Some device failed VM_Critical_Init
VNE_InitFail		EQU	0000000000000000000010000b
VNE_InitFail_Bit	EQU	4		; Some device failed VM_Init

;------------------------------------------------------------------------------

;
; EBX = VM Handle. Call cannot be failed.
;
VM_Suspend		EQU	000Dh		; VM not runnable until resume
;
; EBX = VM Handle. Returning carry fails and backs out the resume.
;
VM_Resume		EQU	000Eh		; VM is leaving suspended state

;------------------------------------------------------------------------------

;
; EBX = VM Handle to set device focus to. EDX = Device ID if device specific
;   setfocus. == 0 if device critical setfocus (all devices). THIS CALL CANNOT
;   BE FAILED.
;
;   NOTE: In case where EDX == 0, ESI is a FLAG word that indicates special
;	  functions. Currently Bit 0 being set indicates that this Device
;	  critical set focus is also "VM critical". It means that we do not
;	  want some other VM to take the focus from this app now. This is
;	  primarily used when doing a device critical set focus to Windows
;	  (the SYS VM) it is interpreted by the SHELL to mean "if an old app
;	  currently has the Windows activation, set the activation to the
;	  Windows Shell, not back to the old app". ALSO in the case where
;	  Bit 0 is set, EDI = The VM handle of the VM that is "having trouble".
;	  Set this to 0 if there is no specific VM associated with the problem.
;
Set_Device_Focus	EQU	000Fh

;------------------------------------------------------------------------------

;
; EBX = VM Handle going into message mode. THIS CALL CANNOT BE FAILED.
;
Begin_Message_Mode	EQU	0010h
;
; EBX = VM Handle leaving message mode. THIS CALL CANNOT BE FAILED.
;
End_Message_Mode	EQU	0011h

;------------------------- SPECIAL CONTROL CALLS ------------------------------

;
; Request for reboot. Call cannot be failed.
;
Reboot_Processor	EQU	0012h		; Request a machine reboot
;
; Query_Destroy is an information call made by the SHELL device before an
;   attempt is made to initiate a destroy VM sequence on a running VM which
;   has not exited normally. EBX = VM Handle. Returning carry indicates that
;   a device "has a problem" with allowing this. THE DESTROY SEQUENCE CANNOT
;   BE ABORTED HOWEVER, this decision is up to the user. All this does is
;   indicate that there is a "problem" with allowing the destroy. The device
;   which returns carry should call the SHELL_Message service to post an
;   informational dialog about the reason for the problem.
;
Query_Destroy		EQU	0013h		; OK to destroy running VM?

;------------------------- DEBUGGING CONTROL CALL -----------------------------

;
; Special call for device specific DEBUG information display and activity.
;
Debug_Query		EQU	0014h

;---------- CALLS FOR BEGIN/END OF PROTECTED MODE VM EXECUTION ----------------

;
;   About to run a protected mode application.
;   EBX = Current VM handle.
;   EDX = Flags
;   EDI -> Application Control Block
;   Returning with carry set fails the call.
;
Begin_PM_App		EQU	0015h

;
;   Flags for Begin_PM_App (passed in EDX)
;
BPA_32_Bit		EQU	00000001b
BPA_32_Bit_Flag 	EQU	1

;
;   Protected mode application is terminating.
;   EBX = Current VM handle.  THIS CALL CAN NOT FAIL.
;   EDI -> Application Control Block
;
End_PM_App		EQU	0016h

EndDoc

BeginDoc
;******************************************************************************
; BeginProc is a macro for defining entry points to routines in VMM and in the
;   VxDs. It correctly defines the procedure name for VxD services(it prepends
;   a "@" to the procedure name), DWORD aligns the procedure, takes care of
;   public declaration and does some calling verification for debug versions
;   of the software. EndProc is a macro which defines the end of the procedure.
;
; Valid parameters to the BeginProc macro are:
;	PUBLIC				; Routine used outside this module
;	HIGH_FREQ			; DWORD align procedure
;	SERVICE 			; Routine is called via VxDCall
;	ASYNC_SERVICE			; Same as "SERVICE" plus routine can
;					;	be called under interrupt.
; After the routine header in which the routine entry conditions, exit
;   conditions, side affects and functionality are specified, the BeginProc
;   macro should be used to define the routine's entry point. It has up to
;   four parameters as specified below. For example:
;
;BeginProc  <Function_Name>,PUBLIC, HIGH_FREQ, ASYNC_SERVICE
;
;	<code>
;
;EndProc    <Function_Name>
;==============================================================================
EndDoc

BeginProc MACRO Name, P1, P2, P3, P4
	LOCAL	Profile_Data, Skip_Data

IF ?_RCODE

Process_Param MACRO P
IFNB <P>
IFIDNI <P>, <HIGH_FREQ>
Dword_Align
ELSE
IFIDNI <P>, <SERVICE>
??_SERVICE = 1
ELSE
IFIDNI <P>, <ASYNC_SERVICE>
??_ASYNC_SERVICE = 1
IF ?_LCODE
%OUT ERROR:  ASYNC_SERVICE's must be in LOCKED code
;;.err
ENDIF
ELSE
IFIDNI <P>, <NO_LOG>
??_NO_LOG = 1
ELSE
IFDIFI <P>, <PUBLIC>
%OUT ERROR:  Bad para "&P" to BeginProc
.ERR
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM


??_SERVICE = 0
??_ASYNC_SERVICE = 0
??_NO_LOG = 0

Process_Param P1
Process_Param P2
Process_Param P3
Process_Param P4


IFE ??_SERVICE + ??_ASYNC_SERVICE

PUBLIC Name
Name PROC NEAR
IFDEF DEBUG
IFE ??_NO_LOG
IFNDEF VMMSYS
	VMMcall Log_Proc_Call
ENDIF
ENDIF
ENDIF

ELSE

IFDEF DEBUG
	jmp	SHORT Skip_Data
Profile_Data LABEL DWORD
	dd	0
Skip_Data:
ENDIF

PUBLIC @&Name
@&Name PROC NEAR

IFDEF DEBUG
IFE ??_NO_LOG
;;;;IFNDEF VMMSYS
	VMMcall Log_Proc_Call
;;;;ENDIF
ENDIF
	pushfd
	inc	[Profile_Data]
IFE ??_ASYNC_SERVICE
	VMMcall Test_Reenter
ENDIF
	popfd
ENDIF
ENDIF

ELSE
IFIDNI <P1>, <PUBLIC>
PUBLIC Name
ENDIF
Name PROC NEAR
ENDIF


	ENDM



EndProc MACRO Name
IFDEF @&Name
@&Name ENDP
ELSE
IFDEF Name
Name ENDP
ELSE
.ERR
%OUT EndProc for &Name does not match BeginProc
ENDIF
ENDIF
	ENDM


;******************************************************************************
;	       S C H E D U L E R   B O O S T   V A L U E S
;==============================================================================

Reserved_Low_Boost	EQU	00000000000000000000000000000001b
Cur_Run_VM_Boost	EQU	00000000000000000000000000000100b
Low_Pri_Device_Boost	EQU	00000000000000000000000000010000b
High_Pri_Device_Boost	EQU	00000000000000000001000000000000b
Critical_Section_Boost	EQU	00000000000100000000000000000000b
Time_Critical_Boost	EQU	00000000010000000000000000000000b
Reserved_High_Boost	EQU	01000000000000000000000000000000b


;******************************************************************************
;	 F L A G S   F O R   C A L L _ P R I O R I T Y _ V M _ E V E N T
;==============================================================================

PEF_Wait_For_STI	EQU	0000001b
PEF_Wait_For_STI_Bit	EQU	0
PEF_Wait_Not_Crit	EQU	0000010b
PEF_Wait_Not_Crit_Bit	EQU	1
PEF_Dont_Unboost	EQU	0000100b
PEF_Dont_Unboost_Bit	EQU	2
PEF_Always_Sched	EQU	0001000b
PEF_Always_Sched_Bit	EQU	3


;******************************************************************************
;	 F L A G S   F O R   B E G I N _ C R I T I C A L _ S E C T I O N
;		       A N D   W A I T _ S E M A P H O R E
;==============================================================================

Block_Svc_Ints			EQU	0000001b
Block_Svc_Ints_Bit		EQU	0
Block_Svc_If_Ints_Locked	EQU	0000010b
Block_Svc_If_Ints_Locked_Bit	EQU	1
Block_Enable_Ints		EQU	0000100b
Block_Enable_Ints_Bit		EQU	2



BeginDoc
;******************************************************************************
; The following structures are pointed to by EBP when VxD routines are entered,
;   both for VxD control calls and traps(I/O traps, software INT traps, etc.).
;   The first structure as DWORD values, the second WORD values and the last
;   has BYTE values.
;
Client_Reg_Struc   struc
Client_EDI	dd	?		; Client's EDI
Client_ESI	dd	?		; Client's ESI
Client_EBP	dd	?		; Client's EBP
		dd	?		; ESP at pushall
Client_EBX	dd	?		; Client's EBX
Client_EDX	dd	?		; Client's EDX
Client_ECX	dd	?		; Client's ECX
Client_EAX	dd	?		; Client's EAX
Client_Error	dd	?		; Dword error code
Client_EIP	dd	?		; EIP
Client_CS	dw	?		; CS
		dw	?		;   (padding)
Client_EFlags	dd	?		; EFLAGS
Client_ESP	dd	?		; ESP
Client_SS	dw	?		; SS
		dw	?		;   (padding)
Client_ES	dw	?		; ES
		dw	?		;   (padding)
Client_DS	dw	?		; DS
		dw	?		;   (padding)
Client_FS	dw	?		; FS
		dw	?		;   (padding)
Client_GS	dw	?		; GS
		dw	?		;   (padding)
Client_Alt_EIP	dd	?
Client_Alt_CS	dw	?
		dw	?
Client_Alt_EFlags  dd	?
Client_Alt_ESP	dd	?
Client_Alt_SS	dw	?
		dw	?
Client_Alt_ES	dw	?
		dw	?
Client_Alt_DS	dw	?
		dw	?
Client_Alt_FS	dw	?
		dw	?
Client_Alt_GS	dw	?
		dw	?
Client_Reg_Struc   ends


Client_Word_Reg_Struc	struc
Client_DI	dw	?		; Client's DI
		dw	?		;   (padding)
Client_SI	dw	?		; Client's SI
		dw	?		;   (padding)
Client_BP	dw	?		; Client's BP
		dw	?		;   (padding)
		dd	?		; ESP at pushall
Client_BX	dw	?		; Client's BX
		dw	?		;   (padding)
Client_DX	dw	?		; Client's DX
		dw	?		;   (padding)
Client_CX	dw	?		; Client's CX
		dw	?		;   (padding)
Client_AX	dw	?		; Client's AX
		dw	?		;   (padding)
		dd	?		; Dword error code
Client_IP	dw	?		; Client's IP
		dw	?		;   (padding)
		dd	?		; CS
Client_Flags	dw	?		; Client's flags (low)
		dw	?		;   (padding)
Client_SP	dw	?		; SP
		dw	?
		dd	5 dup (?)
Client_Alt_IP	dw	?
		dw	?
		dd	?
Client_Alt_Flags    dw	?
		dw	?
Client_Alt_SP	dw	?
Client_Word_Reg_Struc	ends



Client_Byte_Reg_Struc	struc
		dd	4 dup (?)	; EDI, ESI, EBP, ESP at pushall
Client_BL	db	?		; Client's BL
Client_BH	db	?		; Client's BH
		dw	?		;   (padding)
Client_DL	db	?		; Client's DL
Client_DH	db	?		; Client's DH
		dw	?		;   (padding)
Client_CL	db	?		; Client's CL
Client_CH	db	?		; Client's CH
		dw	?		;   (padding)
Client_AL	db	?		; Client's AL
Client_AH	db	?		; Client's AH
Client_Byte_Reg_Struc	ends

;==============================================================================
EndDoc

.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX



PushCParams MACRO P1, P2, P3, P4, P5, P6, P7, P8, P9, P10
	IRP Param, <P10, P9, P8, P7, P6, P5, P4, P3, P2, P1>
	IFNB <Param>
	push	Param
	ENDIF
	ENDM
	ENDM

ClearCParams MACRO Count, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10
IFNB <P1>
	ClearCParams %(Count+1), <P2>, <P3>, <P4>, <P5>, <P6>, <P7>, <P8>, <P9>, <P10>
ELSE
IF Count
	add	esp, Count*4
ENDIF
ENDIF
	ENDM



Dyna_Link_Int	EQU 20h

;
;
BeginDoc
;******************************************************************************
; The VMMCall and VxDCall macros provide a dynamic link to the VMM and VxD
;   service routines. For example:
;
;   VMMCall Enable_VM_Ints		; Equivalent to STI in VM code
;
;   mov     eax,[My_IRQ_Handle]
;   VxDCall VPICD_Set_Int_Request	; Set IRQ for my device's interrupt
;
; Note that Enable_VM_Ints is defined in VMM.INC and VPICD_Set_Int_Request is
;	defined in VPICD.INC
;
;==============================================================================
EndDoc


BeginDoc
;******************************************************************************
; VxDCall
;==============================================================================
EndDoc
VxDcall MACRO P, Param
	PushCParams Param
	int	Dyna_Link_Int
	dd	P
	ClearCParams 0, Param
	ENDM

VxDjmp	MACRO P, Param
IFNB <Param>
%OUT ERROR:  Parameters may not be passed to VxDjmp or VMMjmp macros
.ERR
ENDIF
	int	Dyna_Link_Int
IFDEF DEBUG
	dd	P
	ret
ELSE
	dd	P OR DL_Jmp_Mask
ENDIF
	ENDM

DL_Jmp_Mask	EQU	8000h
DL_Jmp_Bit	EQU	0Fh


VMMcall MACRO P, Param
	.ERRNZ (P SHR 16) - VMM_Device_ID
	VxDcall <P>, <Param>
	ENDM

VMMjmp MACRO P, Param
	.ERRNZ (P SHR 16) - VMM_Device_ID
	VxDjmp <P>, <Param>
	ENDM

cCall MACRO P, Param
	PushCParams Param
	call	P
	ClearCParams 0, Param
	ENDM


BeginDoc
;******************************************************************************
; Segment definition macros
;
; The segment definition macros are a convenience used in defining the
;	segments used by the device driver. They are:
;VxD_ICODE_SEG	 defines start of initialization code segment
;VxD_ICODE_ENDS  defines end of initialization code segment
;VxD_IDATA_SEG	 defines start of initialization data segment
;VxD_IDATA_ENDS  defines end of initialization data segment
;VxD_CODE_SEG	 defines start of always present code segment
;VxD_CODE_ENDS	 defines end of always present code segment
;VxD_DATA_SEG	 defines start of always present data segment
;VxD_DATA_ENDS	 defines end of always present data segment
;==============================================================================
EndDoc


;   Protected mode code
VxD_CODE_SEG	EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS	EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 3 + ??_LCODE
	ASSUME	cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
		ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 3
_LTEXT	 ENDS
		ENDM



;   Protected mode initialization code
VxD_ICODE_SEG	MACRO
_ITEXT	SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 3 + ??_ICODE
	ASSUME	cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
		ENDM

VxD_ICODE_ENDS	MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 3
_ITEXT	ENDS
		ENDM


;   Protected mode data
VxD_DATA_SEG	EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS	EQU <VxD_LOCKED_DATA_ENDS>



VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA	 SEGMENT
IFB <NO_ALIGN>
	ALIGN 4
ENDIF
		ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA	 ENDS
		ENDM




;   Protected mode initialization data
VxD_IDATA_SEG	MACRO
_IDATA	SEGMENT
		ENDM
VxD_IDATA_ENDS	MACRO
_IDATA	ENDS
		ENDM

VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 3 + ??_RCODE
		  ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 3
_RCODE ENDS
		   ENDM

ENDIF

DDK_Version equ 300h

VxD_Desc_Block STRUC
DDB_Next		dd  ?			; VMM RESERVED FIELD
DDB_SDK_Version 	dw  DDK_Version 	; VMM RESERVED FIELD
DDB_Req_Device_Number	dw  Undefined_Device_ID ; Required device number
DDB_Dev_Major_Version	db  0			; Major device number
DDB_Dev_Minor_Version	db  0			; Minor device number
DDB_Flags		dw  0			; Flags for init calls complete
DDB_Name		db  "        "		; Device name
DDB_Init_Order		dd  Undefined_Init_Order; Initialization Order
DDB_Control_Proc	dd  ?			; Offset of control procedure
DDB_V86_API_Proc	dd  0			; Offset of API procedure (or 0)
DDB_PM_API_Proc 	dd  0			; Offset of API procedure (or 0)
DDB_V86_API_CSIP	dd  0			; CS:IP of API entry point
DDB_PM_API_CSIP 	dd  0			; CS:IP of API entry point
DDB_Reference_Data	dd  ?			; Reference data from real mode
DDB_Service_Table_Ptr	dd  0			; Pointer to service table
DDB_Service_Table_Size	dd  0			; Number of services
VxD_Desc_Block ENDS


IFNDEF Not_VxD

; flag values for DDB_Flags

DDB_Sys_Crit_Init_Done	    EQU 00000001b
DDB_Sys_Crit_Init_Done_Bit  EQU        0
DDB_Device_Init_Done	    EQU 00000010b
DDB_Device_Init_Done_Bit    EQU       1

BeginDoc
;******************************************************************************
;
;   Declare_Virtual_Device macro
;
; ???? Write something here ????
;
;==============================================================================
EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc
	LOCAL	V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len

dev_id_err MACRO
%OUT Device ID required when providing services
.ERR
	ENDM

IFB <V86_Proc>
	V86_API_Offset EQU 0
ELSE
IFB <Device_Num>
	dev_id_err
ENDIF
	V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF
IFB <PM_Proc>
	PM_API_Offset EQU 0
ELSE
IFB <Device_Num>
	dev_id_err
ENDIF
	PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF
IFDEF Name&_Service_Table
IFB <Device_Num>
	dev_id_err
ELSE
IFE Device_Num - Undefined_Device_ID
	dev_id_err
ENDIF
ENDIF
	Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
	Serv_Tab_Len	EQU Num_&Name&_Services
ELSE
	Serv_Tab_Offset EQU 0
	Serv_Tab_Len	EQU 0
ENDIF


VxD_LOCKED_DATA_SEG
PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
			 OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
			 ,,,Serv_Tab_Offset, Serv_Tab_Len>
VxD_LOCKED_DATA_ENDS
	ENDM


BeginDoc
;******************************************************************************
; The Begin_Control_Dispatch macro is used for building a table for dispatching
; messages passed to the VxD_Control procedure.  It is used with
; Control_Dispatch and End_Control_Dispatch.  The only parameter is used to
; contruct the procedure label by adding "_Control" to the end (normally the
; device name is used i.e. VKD results in creating the procedure VKD_Control,
; this created procedure label must be included in Declare_Virtual_Device)
;
; An example of building a complete dispatch table:
;
; Begin_Control_Dispatch MyDevice
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
; Control_Dispatch  Sys_VM_Init, MyDeviceSysInitProcedure
; Control_Dispatch  Create_VM,	 MyDeviceCreateVMProcedure
; End_Control_Dispatch MyDevice
;
; (NOTE: Control_Dispatch can be used without Begin_Control_Dispatch, but
;	 then it is the programmer's responsibility for declaring a procedure
;	 in locked code (VxD_LOCKED_CODE_SEG) and returning Carry clear for
;	 any messages not processed.  The advantage in using
;	 Begin_Control_Dispatch is when a large # of messages are processed by
;	 a device, because a jump table is built which will usually require
;	 less code space then the compares and jumps that are done when
;	 Control_Dispatch is used alone.
;
;==============================================================================
EndDoc
Begin_Control_Dispatch MACRO VxD_Name
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control
ENDM

End_Control_Dispatch   MACRO VxD_Name
	LOCAL ignore, table

jmpproc MACRO num
	jmp	??_cd_&&num
ENDM

procoff MACRO num
IFDEF ??_cd_&&num
	dd	OFFSET32 ??_cd_&&num
ELSE
	dd	OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
	cmp	eax, ??_cd_low
	jne	short ignore
	jmpproc %(??_cd_low)
ignore:
	clc
	ret
ELSE
	cmp	eax, ??_cd_high
	ja	short ignore
	sub	eax, ??_cd_low
	jb	short ignore
	jmp	cs:[eax*4+table]
ignore:
	clc
	ret

table label dword
	REPT   ??_cd_high - ??_cd_low + 1
	procoff %(??_cd_low)
	??_cd_low = ??_cd_low + 1
	ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE jmpproc
PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc
;******************************************************************************
; The Control_Dispatch macro is used for dispatching based on message
;	passed to the VxD_Control procedure. E.G.:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
;
; (NOTE: Control_Dispatch can be used with Begin_Control_Dispatch and
;	 End_Control_Dispatch to create a jump table for dispatching messages,
;	 when a large # of messages are processed.)
;
;==============================================================================
EndDoc
Control_Dispatch MACRO Service, Procedure
	LOCAL Skip_Interseg_Jump

IFE ?_lcode
IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
	cmp	eax, Service
	jne	SHORT Skip_Interseg_Jump
	jmp	Procedure
Skip_Interseg_Jump:
ENDIF
ELSE
%OUT ERROR:  The Control proc should be in LOCKED code.
%OUT	     Control_Dispatch can only be used inside of VxD_LOCKED_CODE_SEG.
.err
ENDIF
	ENDM


BeginDoc
;******************************************************************************
; The following are the definitions for the "type of I/O" parameter passed
;   to a I/O trap routine
Byte_Input	EQU	000h
Byte_Output	EQU	004h
Word_Input	EQU	008h
Word_Output	EQU	00Ch
Dword_Input	EQU	010h
Dword_Output	EQU	014h

Output		EQU	0000000000000100b
Output_Bit	EQU	2
Word_IO 	EQU	0000000000001000b
Word_IO_Bit	EQU	3
Dword_IO	EQU	0000000000010000b
Dword_IO_Bit	EQU	4

String_IO	EQU	00000020h
String_IO_Bit	EQU	5
Rep_IO		EQU	00000040h
Rep_IO_Bit	EQU	6
Addr_32_IO	EQU	00000080h
Addr_32_IO_Bit	EQU	7
Reverse_IO	EQU	00000100h
Reverse_IO_Bit	EQU	8

IO_Seg_Mask	EQU	0FFFF0000h		; Use these bits to get segment
IO_Seg_Shift	EQU	10h			; Must shift right this many

;==============================================================================
EndDoc

BeginDoc
;******************************************************************************
;
;   Dispatch_Byte_IO macro
;
; Dispatch_Byte_IO Byte_In_Proc, Byte_Out_Proc
;==============================================================================
EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
	LOCAL	Byte_IO
	cmp	ecx, Byte_Output
	jbe	SHORT Byte_IO
	VMMjmp	Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
	je	Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
	jb	In_Proc
ELSE
	je	Out_Proc
	jmp	In_Proc
ENDIF
ENDIF
	ENDM

BeginDoc
;******************************************************************************
;
;   Emulate_Non_Byte_IO
;
; Emulate_Non_Byte_IO
;
;==============================================================================
EndDoc
Emulate_Non_Byte_IO MACRO
	LOCAL	Byte_IO
	cmp	ecx, Byte_Output
	jbe	SHORT Byte_IO
	VMMjmp	Simulate_IO
Byte_IO:
	ENDM


VxD_IOT_Hdr STRUC
VxD_IO_Ports	dw  ?
VxD_IOT_Hdr ENDS

VxD_IO_Struc STRUC
VxD_IO_Port	dw  ?
VxD_IO_Proc	dd  ?
VxD_IO_Struc ENDS


BeginDoc
;******************************************************************************
;
; Begin_VxD_IO_Table
;
;   Example:
; Begin_VxD_IO_Table MyTableName
;
;==============================================================================
EndDoc
.ERRNZ SIZE VxD_IOT_Hdr - 2	; Begin_VxD_IO_Table creates a 1 word count hdr
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD
IF2
IFNDEF Table_Name&_Entries
%OUT ERROR:  No End_VxD_IO_Table for &Table_Name
.ERR
ENDIF
	dw	Table_Name&_Entries
ELSE
	dw	?
ENDIF

	ENDM

.ERRNZ SIZE VxD_IO_Struc - 6	; VxD_IO creates 6 byte I/O port entries
VxD_IO MACRO Port, Proc_Name
	dw	Port
	dd	OFFSET32 Proc_Name
	ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
%OUT ERROR:  No Begin_VxD_IO_Table for &Table_Name
.ERR
ELSE
	Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
%OUT ERROR:  Invalid number of port traps in &Table_Name
.ERR
ENDIF
ENDIF
	    ENDM


;******************************************************************************
;******************************************************************************

Push_Client_State MACRO
	sub	esp, SIZE Client_Reg_Struc
	push	edi
	lea	edi, [esp+4]
	VMMcall Save_Client_State
	pop	edi
	ENDM

Pop_Client_State MACRO
	push	esi
	lea	esi, [esp+4]
	VMMcall Restore_Client_State
	pop	esi
	add	esp, SIZE Client_Reg_Struc
	ENDM

BeginDoc
;******************************************************************************
;
;   CallRet -- Call procedure and return.  For debugging purposes only.
;	       If compiled with debugging then this will generate a call
;	       followed by a return.  If non-debugging version then the
;	       specified label will be jumped to.
;
;   PARAMETERS:
;	Label_Name = Procedure to be called
;
;   EXIT:
;	Return from current procedure
;
;------------------------------------------------------------------------------
EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
	call	P2
ELSE
	call	P1
ENDIF
	ret
ELSE
	jmp	P1 P2
ENDIF
	ENDM


; ebp offsets to segments pushed by PMode_Fault in Fault_Dispatch
PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16


Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off

IFDIFI <Reg_32>, <EAX>
	push	eax
ENDIF
IFB <Cli_Off>
	mov	ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
	mov	ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
	VMMcall Map_Flat

IFDIFI <Reg_32>, <EAX>
	mov	Reg_32, eax
	pop	eax
ENDIF

	ENDM

;------------------------------------------------------------------------------

VxDint	MACRO	Int_Number
	push	DWORD PTR Int_Number
	VMMcall Exec_VxD_Int
	ENDM


ENDIF	; Not_VxD


BeginDoc
;******************************************************************************
;
;   The following equates are for flags sent to the real mode
;   initialization portion of a device driver:
;
Duplicate_Device_ID	    equ 0000000000000001b   ; duplicate device ID already
Duplicate_Device_ID_Bit     equ 	       0    ; loaded
Duplicate_From_INT2F	    equ 0000000000000010b   ; duplicate device ID already
Duplicate_From_INT2F_Bit    equ 	      1     ; loaded as part of INT 2F
						    ; device list
Loading_From_INT2F	    equ 0000000000000100b   ; this device was specified
Loading_From_INT2F_Bit	    equ 	     2	    ; in the INT 2F device list

EndDoc

BeginDoc
;******************************************************************************
;
;   The following equates are used to indicate the result of the real mode
;   initialization portion of a device driver:
;

Device_Load_Ok	    equ 0		; protected mode portion of device
					; should be loaded
Abort_Device_Load   equ 1		; don't load any protected mode portion
					; of this device, but continue loading
					; the rest of the devices
Abort_Win386_Load   equ 2		; fatal-error: abort the load of Win386

No_Fail_Message     equ 8000h		; The high bit is set in the return
No_Fail_Message_Bit equ 15		; code, if the loader should not print
					; any message for results
					; Abort_Device_Load or Abort_Win386_Load
;==============================================================================
EndDoc


;==============================================================================

; CR0 bit assignments
PE_Mask 	EQU	0001h	; 1 = Protected Mode
PE_Bit		EQU	0
MP_Mask 	EQU	0002h	; 1 = Monitor Coprocessor
MP_Bit		EQU	1
EM_Mask 	EQU	0004h	; 1 = Emulate Math Coprocessor
EM_Bit		EQU	2
TS_Mask 	EQU	0008h	; 1 = Task Switch occured
TS_Bit		EQU	3
ET_Mask 	EQU	0010h	; 1 = 387 present, 0 = 287 present
ET_Bit		EQU	4
PG_Mask 	EQU 80000000h	; 1 = paging enabled, 0 = paging disabled
PG_Bit		EQU	31

; EFLAGs bit assignments
CF_Mask 	EQU	000000000000000001b	; Carry flag
CF_Bit		EQU	0
PF_Mask 	EQU	000000000000000100b	; Parity flag
PF_Bit		EQU	2
AF_Mask 	EQU	000000000000010000b	; Aux flag
AF_Bit		EQU	4
ZF_Mask 	EQU	000000000001000000b	; Zero flag
ZF_Bit		EQU	6
SF_Mask 	EQU	000000000010000000b	; Sign flag
SF_Bit		EQU	7
TF_Mask 	EQU	000000000100000000b	; Trace flag
TF_Bit		EQU	8
IF_Mask 	EQU	000000001000000000b	; Int flag
IF_Bit		EQU	9
DF_Mask 	EQU	000000010000000000b	; Direction flag
DB_Bit		EQU	10
OF_Mask 	EQU	000000100000000000b	; Overflow flag
OF_Bit		EQU	11
IOPL_Mask	EQU	000011000000000000b	; IOPL flags
IOPL_Bit0	EQU	12
IOPL_Bit1	EQU	13
NT_Mask 	EQU	000100000000000000b	; Nested task flag
NT_Bit		EQU	14
RF_Mask 	EQU	010000000000000000b	; Resume flag
RF_Bit		EQU	16
VM_Mask 	EQU	100000000000000000b	; Virtual Mode flag
VM_Bit		EQU	17


;------------------------------------------------------------------------------
;
;	  Temporary MASM macros (to be removed when supported by MASM)
;
;------------------------------------------------------------------------------

loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>


;******************************************************************************
; PAGE TABLE EQUATES
;******************************************************************************


P_SIZE		equ	1000h		; page size

; ---------------------------------------------------
;
;	Page table entry bits
;
; ---------------------------------------------------

P_PRES		equ	01h		; page present bit
P_WRITE 	equ	02h		; write access bit
P_USER		equ	04h		; access bit for User mode
P_ACC		equ	20h		; page accessed bit
P_DIRTY 	equ	40h		; page dirty bit

P_AVAIL 	equ	(P_PRES+P_WRITE+P_USER) ; avail to everyone & present

; ---------------------------------------------------
;
;  Page types - definition of the OS reserved bits in the page table
;		entry.
; ---------------------------------------------------

PG_TYPE 	equ	0E00h		; TYPE bits in PTE

; ---------------------------------------------------
;
;	 Page types for page allocator calls
;
; ---------------------------------------------------
PG_VM		equ	0
PG_SYS		equ	1
PG_RESERVED1	equ	2
PG_PRIVATE	equ	3
PG_RESERVED2	equ	4
PG_RELOCK	equ	5		; PRIVATE to MMGR
PG_INSTANCE	equ	6
PG_HOOKED	equ	7
PG_IGNORE	equ	0FFFFFFFFh


; ---------------------------------------------------
;
;	 Types for page table entries
;
; ---------------------------------------------------
PgT_VM		equ	PG_VM SHL 9
PgT_SYS 	equ	PG_SYS SHL 9
PgT_RESERVED1	equ	PG_RESERVED1 SHL 9
PgT_PRIVATE	equ	PG_PRIVATE SHL 9
PgT_RESERVED2	equ	PG_RESERVED2 SHL 9
PgT_RELOCK	equ	PG_RELOCK SHL 9
PgT_INSTANCE	equ	PG_INSTANCE SHL 9
PgT_HOOKED	equ	PG_HOOKED SHL 9



;******************************************************************************

; ---------------------------------------------------
;
; Definitions for the access byte in a descriptor
;
; ---------------------------------------------------


; Following fields are common to segment and control descriptors

D_PRES		equ	080h		; present in memory
D_NOTPRES	equ	0		; not present in memory

D_DPL0		equ	0		; Ring 0
D_DPL1		equ	020h		; Ring 1
D_DPL2		equ	040h		; Ring 2
D_DPL3		equ	060h		; Ring 3

D_SEG		equ	010h		; Segment descriptor
D_CTRL		equ	0		; Control descriptor

D_GRAN_BYTE	equ	000h		; Segment length is byte granular
D_GRAN_PAGE	equ	080h		; Segment length is page granular
D_DEF16 	equ	000h		; Default operation size is 16 bits
D_DEF32 	equ	040h		; Default operation size is 32 bits


; Following fields are specific to segment descriptors

D_CODE		equ	08h		; code
D_DATA		equ	0		; data

D_RX		equ	02h		; if code, readable
D_X		equ	0		; if code, exec only
D_W		equ	02h		; if data, writable
D_R		equ	0		; if data, read only

D_ACCESSED	equ	1		; segment accessed bit


; Useful combination access rights bytes

RW_Data_Type equ (D_PRES+D_SEG+D_DATA+D_W)
R_Data_Type  equ (D_PRES+D_SEG+D_DATA+D_R)
Code_Type    equ (D_PRES+D_SEG+D_CODE+D_RX)

D_PAGE32	equ	(D_GRAN_PAGE+D_DEF32)		  ; 32 bit Page granular

; Masks for selector fields

SELECTOR_MASK	equ	0fff8h		; selector index
SEL_LOW_MASK	equ	0f8h		; mask for low byte of sel indx
TABLE_MASK	equ	04h		; table bit
RPL_MASK	equ	03h		; privilige bits
RPL_CLR 	equ	not 03h 	; clear ring bits
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\fxlib\clonesub.asm ===
INCLUDE         model.inc
INCLUDE         fastlynx.inc

DATA_PORT       EQU     0
INT_ENABLE      EQU     1
INT_ID          EQU     2
LINE_CONTROL    EQU     3
MODEM_CONTROL   EQU     4
LINE_STATUS     EQU     5
MODEM_STATUS    EQU     6

DATABITS8       EQU     3
STOPBITS1       EQU     0
NOPARITY        EQU     0

PICSTAT1        EQU     20H
PICSTAT2        EQU     21H
IRQ3_BIT        EQU     08H
IRQ4_BIT        EQU     10H
SPECIFIC_EOI    EQU     60H

PROMPT_WAIT     EQU     (5 * 18 + 1)

CTRL_C          EQU     3

INTQ_SIZE       EQU     64

                .DATA
                EXTRN   serial_port:WORD
                EXTRN   seq_num:BYTE
                EXTRN   last_operation:BYTE

irq_vec_save    dd      ?
irq_num         db      ?       ; COM1 & COM3 = IRQ4 (4), COM2 & COM4 = IRQ3 (3)
irq_vec_num     db      ?       ; COM1 & COM3 = vector 12, COM2 & COM4 = 11
irq_bit         db      ?

clone_port_idx  dw      ?

prompt_reset    db      ?

                EVEN

intq_buff       db      INTQ_SIZE DUP(?)
intq_num        dw      ?
intq_front      dw      ?
intq_rear       dw      ?


        		.CODE	text
                EXTRN   GetPortInfo:NEAR
                EXTRN   InitPort:NEAR
                EXTRN   GetTicks:NEAR
                EXTRN   SetBaud:NEAR

_fxc_bios_ticks	PROC    NEAR    PASCAL
                
;* NAME
;*	bios_ticks -- Return current BIOS tick count.
;*
;* SYNOPSIS
;*	time = bios_ticks();
;*
;*	unsigned time;	 Current number of ticks (approximately 18.2 ticks/sec).
;*
;*	extern	unsigned _cdecl bios_ticks(void);

                push    bp
                push    bx
                push    cx
                push    dx
                mov     ah, 0
                int     1AH
                mov     ax, dx      ; Low  portion of tick count to AX
                pop     dx
                pop     cx
                pop     bx
                pop     bp
                ret

_fxc_bios_ticks	ENDP

irq_handler     PROC    FAR

                push    ax
                push    bx
                push    dx
                push    ds
                mov     ax, DGROUP
                mov     ds, ax
                mov     dx, serial_port
                add     dl, INT_ID
                in      al, dx
                and     al, 6
                cmp     al, 4
                jne     send_eoi

                cmp     intq_num, INTQ_SIZE
                jb      @F

                call    clear_buffer

@@:             inc     intq_num
                mov     bx, intq_rear
                sub     dl, INT_ID
                in      al, dx              ;Get the character
                mov     intq_buff[bx], al
                inc     intq_rear
                cmp     intq_rear, INTQ_SIZE
                jb      send_eoi

                mov     intq_rear, 0

send_eoi:       mov     al, irq_num
                or      al, SPECIFIC_EOI
                out     PICSTAT1, al
                pop     ds
                pop     dx
                pop     bx
                pop     ax
                iret

irq_handler     ENDP

@_fxc_send_byte PROC    NEAR USES CX

                mov     dx, serial_port
                mov     bl, al
                add     dl, LINE_STATUS
                call    GetTicks
                mov     cx, ax

send_wait:      in      al, dx
                test    al, 20H
                jnz     output

                call    GetTicks
                sub     ax, cx
                cmp     ax, 2
                jb      send_wait

output:         sub     dl, LINE_STATUS
                mov     al, bl
                out     dx, al
                ret

@_fxc_send_byte ENDP

@_fxc_recv_byte PROC    NEAR USES CX

                mov     bx, ax
                mov     dx, serial_port
                call    GetTicks
                mov     cx, ax

point_status:   add     dl, LINE_STATUS

recv_wait:      in      al, dx
                shr     al, 1
                jc      got_byte

                call    GetTicks
                sub     ax, cx
                cmp     ax, bx
                jb      recv_wait

                mov     ax, -1
                jmp     short recv_ret

got_byte:       sub     dl, LINE_STATUS
                test    al, 7               ; Check for overrun, parity, framing
                in      al, dx
                jnz     point_status

                xor     ah, ah

recv_ret:       ret

@_fxc_recv_byte ENDP

@_fxc_output    PROC    NEAR  USES CX ES

                mov     bl, al
                mov     dx, serial_port
                add     dl, MODEM_CONTROL
                mov     al, 0BH
                out     dx, al                  ; Raise DTR and RTS
                recover

                mov     ax, 40H
                mov     es, ax
                mov     cx, es:[6CH]
                inc     dx                      ; Point to LINE_STATUS

wait_ready:     in      al, dx
                test    al, 20H
                jnz     do_send

                mov     ax, es:[6CH]
                sub     ax, cx
                cmp     ax, 2
                jb      wait_ready

do_send:        sub     dl, LINE_STATUS
                mov     al, bl
                out     dx, al
                ret

@_fxc_output    ENDP

_fxc_read_serial    PROC    NEAR PASCAL   USES SI

                cmp     intq_num, 0
                je      no_chars

                mov     si, intq_front
                mov     al, intq_buff[si]
                inc     si
                xor     ah, ah
                dec     intq_num
                cmp     si, INTQ_SIZE
                jb      update_front

                xor     si, si

update_front:   mov     intq_front, si
                jmp     short read_ser_ret

no_chars:       xor     ax, ax
                dec     ax

read_ser_ret:   ret

_fxc_read_serial    ENDP

@_fxc_init_port PROC    NEAR USES ES

                LOCAL   biosnum:BYTE

                mov     bx, ax              ; Get port index to BX
                shl     bx, 1               ; Make it a word port index
                mov     clone_port_idx, bx
                call    GetPortInfo
                mov     biosnum, ah
                mov     serial_port, dx
                add     dl, LINE_CONTROL
                mov     al, 80H
                out     dx, al              ; Set DLAB = 1
                recover

                sub     dl, (LINE_CONTROL - 1)  ; Point to base + 1
                xor     al, al              ; High byte of 2400 baud divisor
                out     dx, al
                recover

                dec     dx
                mov     al, 48              ; Low byte of 2400 baud divisor
                out     dx, al
                recover

                add     dl, LINE_CONTROL
                mov     al, NOPARITY OR DATABITS8 OR STOPBITS1
                out     dx, al
                recover

                sub     dl, (LINE_CONTROL - INT_ENABLE)
                mov     al, 1
                out     dx, al              ; Data available interrupt
                recover

                add     dl, MODEM_CONTROL - INT_ENABLE
                mov     al, 9
                out     dx, al
                call    clear_buffer
                
                mov     ah, biosnum
                dec     ah
                and     ah, 1
                mov     al, 12
                sub     al, ah
                mov     irq_vec_num, al
                mov     ah, 35H
                int     21H
                mov     word ptr irq_vec_save, bx
                mov     word ptr irq_vec_save[2], es
                push    ds
                mov     ah, 25H
                mov     al, irq_vec_num
                push    cs
                pop     ds
                mov     dx, OFFSET irq_handler
                int     21H
                pop     ds
                mov     ah, biosnum
                dec     ah
                and     ah, 1
                mov     al, 4
                sub     al, ah
                mov     irq_num, al
                or      al, SPECIFIC_EOI
                out     PICSTAT1, al
                mov     dx, serial_port
                in      al, dx              ; Read to clear possible stray char
                mov     ah, IRQ3_BIT
                test    biosnum, 1
                jz      unmask

                mov     ah, IRQ4_BIT

unmask:         mov     irq_bit, ah
                in      al, PICSTAT2
                recover

                not     ah
                and     al, ah
                out     PICSTAT2, al

                call    _fxc_drain
                ret

@_fxc_init_port ENDP

_fxc_reset_port PROC    NEAR    PASCAL

                in      al, PICSTAT2
                recover

                or      al, irq_bit
                out     PICSTAT2, al
                push    ds
                mov     ah, 25H
                mov     al, irq_vec_num
                lds     dx, irq_vec_save
                int     21H
                pop     ds
                mov     bx, clone_port_idx
                call    GetPortInfo
                call    InitPort
                mov     al, BAUD_38400
                call    SetBaud             ; Set baud rate to 38400 for clone
                mov     last_operation, SEND_OPERATION
                mov     seq_num, 0
                ret

_fxc_reset_port ENDP

_fxc_drain      PROC    NEAR PASCAL USES CX DI SI ES

                mov     ax, 40H
                mov     es, ax
                mov     cx, es:[6CH]        ; Save original time in CX
                mov     di, cx              ; DI = last_ticks

clear_loop:     call    _fxc_read_serial
                mov     si, es:[6CH]        ; SI = new_ticks
                or      ax, ax
                js      check_time

                mov     di, si

check_time:     mov     ax, si
                sub     ax, di
                cmp     ax, 3
                ja      clear_done          ; 3 ticks elapsed with no new chars

                mov     ax, si
                sub     ax, cx
                cmp     ax, 18
                jbe     clear_loop

clear_done:     ret

_fxc_drain      ENDP

_fxc_delay      PROC    NEAR

                push    cx
                mov     ax, 40H
                mov     es, ax
                mov     cx, es:[6CH]

wait_loop:      mov     ax, es:[6CH];
                sub     ax, cx
                cmp     ax, bx
                jb      wait_loop

                pop     cx
                ret

_fxc_delay      ENDP

clear_buffer    PROC    NEAR

                xor     ax, ax
                mov     intq_num, ax
                mov     intq_front, ax
                mov     intq_rear, ax
                ret

clear_buffer    ENDP

                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\fxlib\crctab.asm ===
TITLE   CRC table
                PAGE    66, 132

COMMENT @
    crctab.asm : Alan Butt : May 1, 1989 : Expansion Box Project

    This module contains the CRC table and related variables that are common
    to both the serial and parallel communications.
@

INCLUDE         model.inc
INCLUDE         fastlynx.inc

                .DATA

                PUBLIC __crctab
                PUBLIC __crc_errors

                EVEN

__crctab  DW 00000H, 01021H, 02042H, 03063H, 04084H, 050a5H, 060c6H, 070e7H
        DW 08108H, 09129H, 0a14aH, 0b16bH, 0c18cH, 0d1adH, 0e1ceH, 0f1efH
        DW 01231H, 00210H, 03273H, 02252H, 052b5H, 04294H, 072f7H, 062d6H
        DW 09339H, 08318H, 0b37bH, 0a35aH, 0d3bdH, 0c39cH, 0f3ffH, 0e3deH
        DW 02462H, 03443H, 00420H, 01401H, 064e6H, 074c7H, 044a4H, 05485H
        DW 0a56aH, 0b54bH, 08528H, 09509H, 0e5eeH, 0f5cfH, 0c5acH, 0d58dH
        DW 03653H, 02672H, 01611H, 00630H, 076d7H, 066f6H, 05695H, 046b4H
        DW 0b75bH, 0a77aH, 09719H, 08738H, 0f7dfH, 0e7feH, 0d79dH, 0c7bcH
        DW 048c4H, 058e5H, 06886H, 078a7H, 00840H, 01861H, 02802H, 03823H
        DW 0c9ccH, 0d9edH, 0e98eH, 0f9afH, 08948H, 09969H, 0a90aH, 0b92bH
        DW 05af5H, 04ad4H, 07ab7H, 06a96H, 01a71H, 00a50H, 03a33H, 02a12H
        DW 0dbfdH, 0cbdcH, 0fbbfH, 0eb9eH, 09b79H, 08b58H, 0bb3bH, 0ab1aH
        DW 06ca6H, 07c87H, 04ce4H, 05cc5H, 02c22H, 03c03H, 00c60H, 01c41H
        DW 0edaeH, 0fd8fH, 0cdecH, 0ddcdH, 0ad2aH, 0bd0bH, 08d68H, 09d49H
        DW 07e97H, 06eb6H, 05ed5H, 04ef4H, 03e13H, 02e32H, 01e51H, 00e70H
        DW 0ff9fH, 0efbeH, 0dfddH, 0cffcH, 0bf1bH, 0af3aH, 09f59H, 08f78H
        DW 09188H, 081a9H, 0b1caH, 0a1ebH, 0d10cH, 0c12dH, 0f14eH, 0e16fH
        DW 01080H, 000a1H, 030c2H, 020e3H, 05004H, 04025H, 07046H, 06067H
        DW 083b9H, 09398H, 0a3fbH, 0b3daH, 0c33dH, 0d31cH, 0e37fH, 0f35eH
        DW 002b1H, 01290H, 022f3H, 032d2H, 04235H, 05214H, 06277H, 07256H
        DW 0b5eaH, 0a5cbH, 095a8H, 08589H, 0f56eH, 0e54fH, 0d52cH, 0c50dH
        DW 034e2H, 024c3H, 014a0H, 00481H, 07466H, 06447H, 05424H, 04405H
        DW 0a7dbH, 0b7faH, 08799H, 097b8H, 0e75fH, 0f77eH, 0c71dH, 0d73cH
        DW 026d3H, 036f2H, 00691H, 016b0H, 06657H, 07676H, 04615H, 05634H
        DW 0d94cH, 0c96dH, 0f90eH, 0e92fH, 099c8H, 089e9H, 0b98aH, 0a9abH
        DW 05844H, 04865H, 07806H, 06827H, 018c0H, 008e1H, 03882H, 028a3H
        DW 0cb7dH, 0db5cH, 0eb3fH, 0fb1eH, 08bf9H, 09bd8H, 0abbbH, 0bb9aH
        DW 04a75H, 05a54H, 06a37H, 07a16H, 00af1H, 01ad0H, 02ab3H, 03a92H
        DW 0fd2eH, 0ed0fH, 0dd6cH, 0cd4dH, 0bdaaH, 0ad8bH, 09de8H, 08dc9H
        DW 07c26H, 06c07H, 05c64H, 04c45H, 03ca2H, 02c83H, 01ce0H, 00cc1H
        DW 0ef1fH, 0ff3eH, 0cf5dH, 0df7cH, 0af9bH, 0bfbaH, 08fd9H, 09ff8H
        DW 06e17H, 07e36H, 04e55H, 05e74H, 02e93H, 03eb2H, 00ed1H, 01ef0H

__crc_errors    dw      0



                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\fxlib\macros.inc ===
;--- Macro for I/O recovery time when doing port accesses

recover     MACRO
            jmp     $+2
            ENDM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\fxlib\loader.asm ===
;* Loader sent in upload.
;* Generated by running "make" in load subdirectory.

INCLUDE         model.inc

                .CODE text

                PUBLIC C loader_start
                PUBLIC C loader_end
                PUBLIC C loader_bios_port

loader_start    LABEL   BYTE

DB 0fcH,0b8H,000H,033H,0cdH,021H,052H,0b8H,001H,033H,0b2H,000H,0cdH,021H,0e8H,007H
DB 000H,0b8H,001H,033H,05aH,0cdH,021H,0c3H,055H,08bH,0ecH,081H,0ecH,0bcH,020H,0c7H
DB 046H,0feH,0ffH,0ffH,0e8H,0dfH,002H,0e8H,03dH,001H,0b8H,003H,000H,0e8H,047H,002H
DB 08dH,09eH,044H,0dfH,0b8H,0b9H,020H,0e8H,095H,001H,00bH,0c0H,074H,0f2H,080H,0beH
DB 044H,0dfH,001H,075H,010H,08dH,09eH,0eeH,0dfH,08dH,046H,0feH,0e8H,095H,002H,00bH
DB 0c0H,074H,04aH,0ebH,060H,080H,0beH,044H,0dfH,002H,075H,014H,08bH,046H,0feH,08dH
DB 09eH,0fdH,0dfH,08bH,096H,0fbH,0dfH,0e8H,05fH,002H,03bH,086H,0fbH,0dfH,0ebH,0e1H
DB 080H,0beH,044H,0dfH,003H,075H,01fH,08bH,046H,0feH,08bH,096H,0e8H,0dfH,08bH,09eH
DB 0e6H,0dfH,0e8H,070H,002H,08bH,046H,0feH,0e8H,04eH,002H,00bH,0c0H,075H,026H,0c7H
DB 046H,0feH,0ffH,0ffH,0ebH,007H,080H,0beH,044H,0dfH,004H,074H,009H,08dH,09eH,045H
DB 0dfH,0e8H,0aaH,000H,0ebH,08aH,083H,07eH,0feH,000H,07cH,010H,08dH,09eH,0eeH,0dfH
DB 0e8H,04cH,002H,0ebH,007H,08dH,09eH,095H,0dfH,0e8H,092H,000H,0b8H,030H,000H,0e8H
DB 0b5H,001H,08bH,0e5H,05dH,0c3H,066H,078H,062H,02eH,063H,06fH,06dH,000H,000H,000H
DB 000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,050H,0b0H,020H,0e6H,020H
DB 02eH,0ffH,006H,0d0H,001H,02eH,0ffH,00eH,0d2H,001H,058H,0cfH,050H,053H,052H,006H
DB 033H,0c0H,0a3H,0d0H,001H,0c7H,006H,0d2H,001H,012H,000H,0e4H,021H,0a2H,0d4H,001H
DB 0b0H,0feH,0e6H,021H,0b8H,008H,035H,0cdH,021H,089H,01eH,0d7H,001H,08cH,006H,0d9H
DB 001H,0baH,0dbH,001H,0b8H,008H,025H,0cdH,021H,007H,05aH,05bH,058H,0c3H,050H,01eH
DB 0c5H,016H,0d7H,001H,0b8H,008H,025H,0cdH,021H,01fH,0a0H,0d4H,001H,0e6H,021H,08bH
DB 00eH,0d0H,001H,0e3H,008H,0faH,09cH,0ffH,01eH,0d7H,001H,0e2H,0f9H,0fbH,058H,0c3H
DB 050H,053H,055H,0bbH,007H,000H,0b4H,00eH,0cdH,010H,05dH,05bH,058H,0c3H,08aH,007H
DB 043H,00aH,0c0H,074H,011H,03cH,00aH,075H,008H,0b0H,00cH,040H,0e8H,0e1H,0ffH,0b0H
DB 00aH,0e8H,0dcH,0ffH,0ebH,0e8H,0c3H,057H,0bfH,010H,004H,033H,0d2H,01eH,007H,0b1H
DB 004H,08bH,0c2H,08bH,0d8H,0d3H,0ebH,033H,0c3H,08aH,0f8H,032H,0dbH,0d3H,0e3H,033H
DB 0c3H,08aH,0d8H,032H,0ffH,0feH,0c1H,0d3H,0e3H,033H,0c3H,0abH,042H,00aH,0f6H,074H
DB 0deH,05fH,0c3H,0ecH,0a8H,020H,074H,0fbH,080H,0eaH,005H,08aH,0c4H,0eeH,080H,0c2H
DB 005H,0c3H,053H,0ecH,0d0H,0e8H,072H,00cH,083H,03eH,0d2H,001H,000H,07dH,0f4H,0b8H
DB 0ffH,0ffH,0ebH,017H,080H,0eaH,005H,0ecH,080H,0c2H,005H,032H,0e4H,086H,0e9H,032H
DB 0c8H,033H,0dbH,086H,0d9H,0d1H,0e3H,033H,08fH,010H,004H,05bH,00bH,0c0H,0c3H,055H
DB 051H,057H,056H,006H,01eH,007H,08bH,0fbH,08bH,0e8H,08bH,016H,0ceH,001H,080H,0c2H
DB 005H,0c7H,006H,0d2H,001H,012H,000H,0e8H,0b8H,0ffH,078H,0f5H,08aH,0d8H,024H,003H
DB 038H,006H,0d5H,001H,075H,0ebH,0e8H,0f3H,0feH,08aH,0e3H,088H,026H,0d6H,001H,0f6H
DB 0d4H,080H,0e4H,0fbH,0e8H,08cH,0ffH,0b9H,0ffH,0ffH,0e8H,095H,0ffH,078H,050H,032H
DB 0e4H,0f6H,0c3H,080H,08bH,0d8H,075H,007H,0e8H,087H,0ffH,078H,042H,08aH,0f8H,00bH
DB 0dbH,074H,047H,03bH,0ddH,077H,043H,08bH,0ebH,08bH,0f3H,0e8H,074H,0ffH,078H,02fH
DB 0aaH,0c7H,006H,0d2H,001H,012H,000H,04eH,075H,0f1H,0e8H,065H,0ffH,078H,020H,0e8H
DB 060H,0ffH,078H,01bH,081H,0f9H,00fH,01dH,075H,020H,08aH,026H,0d6H,001H,0e8H,042H
DB 0ffH,0feH,006H,0d5H,001H,080H,026H,0d5H,001H,003H,08bH,0c5H,0ebH,003H,090H,033H
DB 0c0H,0e8H,0baH,0feH,007H,05eH,05fH,059H,05dH,0c3H,0c7H,006H,0d2H,001H,012H,000H
DB 0e8H,02fH,0ffH,079H,0f5H,0ebH,0e8H,056H,08bH,0c8H,033H,0c0H,08eH,0c0H,08bH,01eH
DB 00eH,004H,003H,0dbH,026H,08bH,097H,000H,004H,089H,016H,0ceH,001H,0bbH,003H,000H
DB 08bH,0f2H,080H,0c2H,005H,0ecH,024H,060H,03cH,060H,075H,0f9H,04aH,032H,0c0H,0eeH
DB 0ebH,000H,04aH,0b0H,080H,0eeH,0ebH,000H,08bH,0d6H,042H,032H,0c0H,0eeH,0ebH,000H
DB 08aH,0c1H,04aH,0eeH,0ebH,000H,083H,0c2H,003H,08aH,0c3H,024H,01fH,0eeH,0ebH,000H
DB 04aH,04aH,032H,0c0H,0eeH,0ebH,000H,05eH,0c3H,08bH,0caH,08bH,0d3H,08bH,0d8H,0b4H
DB 040H,0cdH,021H,072H,001H,0c3H,033H,0c0H,0c3H,08bH,0d8H,0b4H,03eH,0cdH,021H,072H
DB 002H,033H,0c0H,0c3H,08bH,0d3H,050H,033H,0c9H,0b4H,03cH,0cdH,021H,05bH,072H,004H
DB 089H,007H,033H,0c0H,0c3H,08bH,0cbH,08bH,0d8H,0b8H,001H,057H,0cdH,021H,0c3H,08bH
DB 0d3H,0b4H,041H,0cdH,021H,0c3H,0baH,0c6H,001H,0b4H,041H,0cdH,021H,0c3H

loader_bios_port	DW	0ddddH


loader_end      LABEL   BYTE

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\fxlib\fastlynx.h ===
#ifndef TRUE
#define TRUE    1
#endif
#ifndef FALSE
#define FALSE   0
#endif

#define MAX_PORTS 8

#pragma pack(1)

typedef unsigned char byte;
typedef unsigned int  word;

#define SERIAL_PORT         0
#define PARALLEL_PORT       1

#define  PARALLEL_NORMAL   0
#define  PARALLEL_TURBO    1

const int _near fx_port;            // -1 if not connected, else current port index.
const byte _near fx_baud;           // Current serial baud rate (index to baud_table)
const byte _near fx_serial_7_wire;
const byte _near fx_send_variable;
const byte _near fx_recv_variable;
const byte _near fx_parallel_speed; // Current parallel operating speed
const byte fx_max_serial_baud;
word fx_max_serial_block;
byte fx_error_checking_mode;     // Set to ECM_ALLOW_CHECKSUM or ECM_FORCE_CRC
byte fx_force_variable;

#ifdef _PAR18
#define  PARALLEL_11_WIRE        0
#define  PARALLEL_18_WIRE        1
#define  PARALLEL_BIDIRECTIONAL  2

const byte _near fx_parallel_mode;  // Indicates current parallel operating mode.
byte _near fx_disable_par18;        // Set to TRUE to disable parallel 18 wire
#endif

enum fx_errno {
    FX_ERR_TIMEOUT = -1,         // Timeout during initial packet negotiation
    FX_ERR_CRC     = -2,         // Packet completed, but got a CRC / Checksum error
    FX_ERR_FAIL    = -3          // Packet failed to complete
};

const enum fx_errno _near fx_errno;   // Set only on failure of FxSend or FxReceive

#define BAUD_1200       0
#define BAUD_2400       1
#define BAUD_4800       2
#define BAUD_9600       3
#define BAUD_19200      4
#define BAUD_38400      5
#define BAUD_57600      6
#define BAUD_115200     7

#ifdef FX_MAIN
char *baud_table[] = {
    "1200  ",
    "2400  ",
    "4800  ",
    "9600  ",
    "19200 ",
    "38400 ",
    "57600 ",
    "115200"
};
#else
extern char *baud_table[];
#endif

int _near fx_num_ports;               // Number of ports in FxPortInfo array.

struct FxBiosInfo {
    byte num_serial;
    byte num_parallel;
    word serial_address[4];
    word parallel_address[3];
};

#define PF_BAD_PORT     0x80

struct FxPortInfo {
    byte type;
    byte biosnum;
    word address;
    const byte flags;   // Set to PF_BAD_PORT by FastLynxInit if hardware error.
};

struct FxPortInfo _near FxPortInfo[MAX_PORTS];

#define ECM_FORCE_CRC         0
#define ECM_ALLOW_CHECKSUM    8 // Note: must correpond to internal flag bit.

#define MAX_SERIAL_BLOCK    8 * 1024

struct FxSettings {
    word time_out;  // Timeout value in ticks for FxConnect() and FxListen().
    byte error_checking_mode;   // ECM_CRC or ECM_CHECKSUM
    word max_serial_block;
    byte max_serial_baud;
    word allow_7_wire;          // TRUE to enable 7 wire
};

extern struct FxSettings _near FxSettings;

typedef unsigned long FILESIZE;
typedef unsigned long FILEDATE;

struct dir_entry {
    byte attrib;        /* Attribute of matching file        */
    FILEDATE date;      /* Time stamp of file                */
    FILESIZE size;      /* Size of file in bytes             */
    char name[13];      /* Name of matching file             */
};

/*** Bootstrap loader command codes. ***/

#define CLONE_CREATE_CMD  1
#define CLONE_WRITE_CMD   2
#define CLONE_CLOSE_CMD   3
#define CLONE_EXIT_CMD    4
#define CLONE_UNKNOWN_CMD 5

/*** Structure for packets sent to clone bootstrap loader. ***/

#define MAX_CLONE_DATA      2048

struct clone_cmd {
    byte command;
    char ok_msg[80];
    char error_msg[80];
    struct dir_entry dir;
    unsigned cnt;           // Number of bytes of data to write.
    byte   data[MAX_CLONE_DATA];
};

/*** Function prototypes. ***/

void _far _fastcall FxQueryBios(struct FxBiosInfo _near *bios_info);

void _far _pascal FxInit(void); 
// Call once during program init.

void _far _pascal FxExit(void);       // MUST be called before exiting!

int  _far _pascal FxConnect(void);
// FxConnect returns either:
//  Success (1) -  Connected
//  Failure (-1) - Timed out - can retry on next call
//  Continue (0) - Will continue on next call

int  _far _pascal FxListen(void);

// FxStartIdle should be called to restart the idler after a call to FxSend or
// FxReceive, both of which stop the idler.
void _far _pascal FxStartIdle(void);

void _far _pascal FxDisconnect(void);

#define CHECK_ABORT_WAITING     0
#define CHECK_ABORT_DONE        1

void _far _fastcall FxSetCheckAbort(int (_far _fastcall *CheckAbort)(word elapsed_ticks, byte status));

#define SYNC_NO_TIMEOUT         0xFFFF
#define SYNC_ONE_SECOND             18

void _far _fastcall FxSyncTimeout(word timeout);

int _far _fastcall FxSendWord(word command);
int _far _fastcall FxSend(void const _far * buf, word length);
word _far _fastcall FxReceive(void _far *buf, word max_len);
void _far _pascal FxShowBaud (void (_far _pascal *ShowBaud)(void));

int _far _fastcall FxCloneInit(int port_index, int remote_port, char const _near *loading_bootstrap_msg, int (_far _cdecl *CheckAbort)(void));
int _far _fastcall FxBootstrapInit(void);
int _far _fastcall FxSendBootstrap(int num_bytes);
int _far _pascal FxBootstrapVerify(void);
int _far _pascal FxStartBootstrap(void);
int _far _fastcall FxSendSerialBlock(void const _far * buf, word length);
int _far _pascal FxCloneExit(void);
int _far _fastcall FxSetBaud(byte BaudIndex, word PortAddress);
#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\fxlib\model.inc ===
%           .MODEL model
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\fxlib\listen.asm ===
INCLUDE         model.inc
INCLUDE         fastlynx.inc

                .DATA
                EXTRN   last_operation:BYTE
                PUBLIC  FirstListen
FirstListen     db      1
StartTicks      dw      ?
                
        		.CODE	text
                PUBLIC  ResetListenTime
                EXTRN   FxRestorePorts:NEAR
                EXTRN   FxInitPorts:NEAR
                EXTRN   GetTicks:NEAR
                EXTRN   SetPortInfo:NEAR
                EXTRN   GetPortInfo:NEAR

ResetListenTime PROC    NEAR

                call    GetTicks
                mov     StartTicks, ax
                ret

ResetListenTime ENDP

FxListen        PROC    FAR PASCAL

;* extern int _pascal FxListen(void);

                cmp     FirstListen, 1
                jne     no_reset

                call    ResetListenTime
                mov     FirstListen, 0

no_reset:       xor     bx, bx

listen_loop:    cmp     bx, fx_tail
                jae     fail

                call    GetPortInfo
                call    fx_listen_vector[bx]
                jnc     success

                inc     bx
                inc     bx
                jmp     listen_loop

fail:           call    GetTicks
                sub     ax, StartTicks
                cmp     ax, FxSettings.FxSettingsDef.fxs_time_out
                jl      no_timeout

                call    FxInitPorts

no_timeout:     xor     ax, ax
                ret

success:        call    SetPortInfo
                call    FxRestorePorts
                mov     last_operation, RECV_OPERATION
                mov     ax, 1
                ret

FxListen        ENDP

	            END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\fxlib\fastlynx.inc ===
PAGE    66, 132

INCLUDE     macros.inc

TRUE                    EQU     1
FALSE                   EQU     0

MAX_PORTS               EQU     8

MAX_BIOS_SERIAL         EQU     4
MAX_BIOS_PARALLEL       EQU     3

SERIAL_PORT             EQU     0
PARALLEL_PORT           EQU     1

PARALLEL_NORMAL         EQU     0
PARALLEL_TURBO          EQU     1

IFDEF _PAR18
PARALLEL_11_WIRE        EQU     0
PARALLEL_18_WIRE        EQU     1
PARALLEL_BIDIRECTIONAL  EQU     2
ENDIF

BAUD_1200               EQU     0
BAUD_2400               EQU     1
BAUD_4800               EQU     2
BAUD_9600               EQU     3
BAUD_19200              EQU     4
BAUD_38400              EQU     5
BAUD_57600              EQU     6
BAUD_115200             EQU     7

SEND_OPERATION          EQU     0
RECV_OPERATION          EQU     1

MINIMUM_TICKS           EQU     4

FX_ERR_TIMEOUT          EQU     -1
FX_ERR_CRC              EQU     -2
FX_ERR_FAIL             EQU     -3
FX_ERR_BAD_COUNT        EQU     -4
FX_ERR_BAD_SEQUENCE     EQU     -5

FxBiosInfo              STRUC
    num_serial          db  ?       ;NOTE: num_serial must immediately precede
    num_parallel        db  ?       ;num_parallel because a word store is used
    serial_address      dw  MAX_BIOS_SERIAL DUP(?)
    parallel_address    dw  MAX_BIOS_PARALLEL DUP(?)
FxBiosInfo              ENDS
                
FxPortInfoDef           STRUC
    pi_type             db  ?
    pi_biosnum          db  ?
    pi_address          dw  ?
    pi_flags            db  ?
FxPortInfoDef           ENDS

MAX_SERIAL_BLOCK        EQU     8 * 1024

;--- Definition of bits in the sequence number/flags byte

BYTE_LENGTH             EQU     10000000B
CONTINUED_PACKET        EQU     01000000B
COMPRESSED              EQU     00100000B
SEVEN_WIRE              EQU     00010000B
USE_CHECKSUM            EQU     00001000B
ECHOPLEX                EQU     00000100B
SEQUENCE_BITS           EQU     00000011B
IDLE_BITS               EQU     11111100B

FXS_FORCE_CRC           EQU     0
FXS_ALLOW_CHECKSUM      EQU     USE_CHECKSUM

FxSettingsDef               STRUC
    fxs_time_out            dw  2 * 18          ; Default timeout of 2 seconds
    fxs_error_checking_mode db  FXS_FORCE_CRC   ; Default to using CRC only
    fxs_max_serial_block    dw  MAX_SERIAL_BLOCK
    fxs_max_serial_baud     db  BAUD_115200
    fxs_allow_7_wire        dw  1               ; Default to enabled
FxSettingsDef               ENDS

CHECK_ABORT_WAITING     EQU     0
CHECK_ABORT_DONE        EQU     1

ONE_SECOND              EQU     18

SEWELL_OEM_ID  EQU  298 SHL 5
FX_ID          EQU    0         ; 0 - 7 are the only ones available under this
                                ; OEM ID.

VFXD_Device_ID EQU  SEWELL_OEM_ID OR FX_ID

                        .DATA

                EXTRN   C fx_port:WORD
                EXTRN   C fx_baud:BYTE
                EXTRN   C fx_parallel_speed:BYTE
		        EXTRN	C fx_num_ports:WORD
                EXTRN   C fx_serial_7_wire:BYTE
                EXTRN   C fx_send_variable:BYTE
                EXTRN   C fx_recv_variable:BYTE
                EXTRN   C fx_error_checking_mode:BYTE
                EXTRN   C FxPortInfo:BYTE
                EXTRN   C fx_errno:WORD
                EXTRN   C fx_max_serial_block:WORD
                EXTRN   C fx_max_serial_baud:BYTE
                EXTRN   C fx_error_checking_mode:BYTE
                EXTRN   C fx_force_variable:BYTE
        IFDEF   _PAR18
                EXTRN   C fx_parallel_mode:BYTE
                EXTRN   C fx_disable_par18:BYTE
        ENDIF

        IFNDEF  FX_MAIN
                EXTRN   fx_port_save_area:BYTE
                EXTRN   fx_connect_vector:WORD
                EXTRN   fx_listen_vector:WORD
                EXTRN   fx_tail:WORD
                EXTRN   fx_index:WORD
                EXTRN   seq_num:BYTE
                EXTRN   C FxSettings:BYTE
        ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\fxlib\init.asm ===
; FxInit is used to save the current state of all ports, and to set the
; port listen and connect vectors to their initial state.

FX_MAIN         EQU     1

INCLUDE         model.inc
INCLUDE         fastlynx.inc

                .DATA
                PUBLIC  seq_num
                PUBLIC  fx_tail
                PUBLIC  fx_index
                PUBLIC  fx_port_save_area
                PUBLIC  fx_connect_vector
                PUBLIC  fx_listen_vector
                PUBLIC  last_operation
                PUBLIC  C FxSettings
                EXTRN   FirstListen:BYTE

seq_num             db      ?
fx_port_save_area   db      (3 * 2) * MAX_PORTS DUP(?)
fx_tail             dw      ?
fx_index            dw      ?
fx_connect_vector   dw      MAX_PORTS DUP(?)
fx_listen_vector    dw      MAX_PORTS DUP(?)
last_operation      db      ?
FxSettings          FxSettingsDef <>


                .CODE   text
                EXTRN   FxSaveAllPorts:NEAR
                EXTRN   FxRestoreAllPorts:NEAR
                EXTRN   SerialListenInit:NEAR
                EXTRN   ParallelListenInit:NEAR
                EXTRN   RestoreSerial:NEAR
                EXTRN   RestoreParallel:NEAR
                EXTRN   SerialInit:NEAR
                EXTRN   SerialExit:NEAR
                EXTRN   ParallelInit:NEAR
                EXTRN   ParallelExit:NEAR
                EXTRN   GetPortInfo:NEAR
                PUBLIC  GetTicks

RestorePort     dw      OFFSET RestoreSerial
                dw      OFFSET RestoreParallel

ListenInit      dw      OFFSET SerialListenInit
                dw      OFFSET ParallelListenInit

last_ticks      dw      0
current_ticks   dw      0

GetTicks        PROC    NEAR

;* Enter with:
;* Uses:
;*      AX = logical tick count returned

                pushf
                cli
                push    es
                push    bx
                mov     ax, 040H
                mov     es, ax
                mov     ax, es:[06CH]
                mov     bx, ax
                sub     ax, cs:last_ticks
                mov     cs:last_ticks, bx
                cmp     ax, 2 * 18
                jb      @F

;*** NOTE: Elapsed time greater than or equal to 2 seconds means either:
;***
;***    1)  Clock rolled over at midnight, so we adjust by only 1 tick.
;***    2)  User is starting a new timing sequence, so it doesn't matter.

                mov     ax, 1

@@:             add     cs:current_ticks, ax
                mov     ax, cs:current_ticks
                pop     bx
                pop     es
                popf
                ret

GetTicks        ENDP


FxInitPorts     PROC    NEAR    USES AX BX SI

; This sets the listen and connect vectors for each port to it's initial state.

                mov     FirstListen, 1
                xor     ax, ax
                dec     ax
                mov     fx_port, ax         ; fx_port  := -1
                mov     fx_index, ax        ; fx_index := -1
                xor     bx, bx

init_loop:      cmp     bx, fx_tail
                jae     finished

                call    GetPortInfo         ; Returns port type in AL
                xor     ah, ah              ;
                mov     si, ax
                shl     si, 1
                call    ListenInit[si]
                inc     bx
                inc     bx
                jmp     init_loop

finished:       ret

FxInitPorts     ENDP


FxInit          PROC    PASCAL

;* extern _pascal FxInit(void);

                mov     ax, fx_num_ports
                shl     ax, 1
                mov     fx_tail, ax         ; fx_tail = fx_num_ports * 2
                call    FxSaveAllPorts
                call    SerialInit
                call    ParallelInit
                call    FxInitPorts

                ret

FxInit          ENDP

FxExit          PROC    PASCAL PUBLIC

                call    FxRestoreAllPorts
                call    SerialExit
                call    ParallelExit
                ret

FxExit          ENDP


                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\fxlib\querybio.asm ===
INCLUDE         model.inc
INCLUDE         fastlynx.inc
    
        		.CODE	text

@FxQueryBios	PROC    USES CX SI ES
                PUBLIC  @FxQueryBios

;* void _far _fastcall FxQueryBios(struct FxBiosInfo _near *);

                int     11H
                mov     al, ah
                mov     cl, 6
                shr     ah, cl          ; Isolate # of printer ports in ah
                shr     al, 1
                and     al, 7           ; Isolate # of serial ports in AL
                cmp     al, 4
                jbe     save_counts

                mov     al, 4

save_counts:    mov     dx, ax          ; DH = # serial ports, DL = # printer
                mov     ax, 40H
                mov     es, ax
                xor     si, si
                xor     cx, cx

serial_loop:    cmp     cl, dl
                jae     setup_parallel

                mov     ax, es:[si]
                or      ax, ax
                jz      setup_parallel

                mov     [bx + si].FxBiosInfo.serial_address, ax
                inc     cl
                add     si, 2
                jmp     serial_loop

setup_parallel: xor     si, si

parallel_loop:  cmp     ch, dh
                jae     store_nums

                mov     ax, es:[si + 8]
                or      ax, ax
                jz      store_nums
                
                mov     [bx + si].FxBiosInfo.parallel_address, ax
                inc     ch
                add     si, 2
                jmp     parallel_loop

store_nums:     mov     word ptr [bx].FxBiosInfo.num_serial, cx
                ret

@FxQueryBios    ENDP

	            END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\fxlib\sendrecv.asm ===
;***
;* $Workfile:   sendrecv.asm  $
;* $Revision:   1.0  $
;*   $Author:   Dave Sewell  $
;*     $Date:   05 May 1989 16:34:22  $
;***

INCLUDE         model.inc
INCLUDE         fastlynx.inc


                .DATA
                PUBLIC  SendVector
                PUBLIC  SyncTimeout
                PUBLIC  RecvVector
                PUBLIC  SyncStart
                PUBLIC  SyncDone
                PUBLIC  CheckAbort
                EXTRN   parallel_port:WORD
                EXTRN   serial_port:WORD
                EXTRN   seq_num:BYTE            ; Serial sequence number


SendVector      dw      SendParallel
RecvVector      dw      RecvParallel

CheckAbortVec   dw      OFFSET DefaultCheckAbort
                dw      SEG DefaultCheckAbort

SyncTimeout     dw      2 * ONE_SECOND          ; Default sync timeout

SyncStartTime   dw      ?

        		.CODE	text
                EXTRN   FxInitPorts:NEAR
                EXTRN   FxRestorePorts:NEAR
                EXTRN   SendSerial:NEAR
                EXTRN   SendSerialBlock:NEAR
                EXTRN   RecvSerial:NEAR
                EXTRN   SendParallel:NEAR
                EXTRN   RecvParallel:NEAR
                EXTRN   setup_recv_byte:NEAR
                EXTRN   GetTicks:NEAR

SetPortInfo     PROC    NEAR USES DX            ; Enter with BX = port index

                mov     fx_index, bx            ; Save index as word value
                shr     bx, 1                   ; Convert to byte index
                mov     fx_port, bx
                shl     bx, 1                   ; Back to word index
                call    GetPortInfo
                cmp     al, SERIAL_PORT
                je      set_serial

                mov     SendVector, OFFSET SendParallel
                mov     RecvVector, OFFSET RecvParallel
                mov     parallel_port, dx
                jmp     short set_done

set_serial:     mov     SendVector, OFFSET SendSerial
                mov     RecvVector, OFFSET RecvSerial
                mov     serial_port, dx

set_done:       mov     seq_num, 0
                ret

SetPortInfo     ENDP

GetPortIndex    PROC    NEAR USES DX

                shr     bx, 1                   ; Convert to byte index
                mov     ax, TYPE FxPortInfoDef
                mul     bx
                shl     bx, 1                   ; Back to word index
                mov     si, ax
                ret

GetPortIndex    ENDP

GetPortInfo     PROC    NEAR    USES SI

; Enter with BX = word port index
; Returns    DX = port address
;            AL = port type
;            AH = biosnum

                call    GetPortIndex
                mov     dx, FxPortInfo[si].FxPortInfoDef.pi_address
                mov     al, FxPortInfo[si].FxPortInfoDef.pi_type
                mov     ah, FxPortInfo[si].FxPortInfoDef.pi_biosnum
                ret

GetPortInfo     ENDP


@FxSendSerialBlock  LABEL   FAR
                    PUBLIC  @FxSendSerialBlock

@FXSENDSERIALBLOCK  PROC    FAR PASCAL PRIVATE USES CX DI SI ES, buf:FAR PTR

                mov     cx, ax          ; CS    := length
                les     si, buf         ; ES:SI := buf ptr
                xor     bl, bl          ; clear all sending flags
                mov     dx, serial_port
                call    setup_recv_byte ; Note: BP is clobbered in here
                call    SendSerialBlock
                ret

@FXSENDSERIALBLOCK  ENDP

@FxSend         LABEL   FAR
                PUBLIC  @FxSend

@FXSEND         PROC    FAR PASCAL PRIVATE USES CX DI SI ES, buf:FAR PTR

;* int _far _fastcall FxSend(byte _far *buf, word length);

                mov     cx, ax          ; CX    := length
                les     si, buf         ; ES:SI := buff ptr
                dec     ax
                add     ax, si
                jnc     count_ok

                mov     fx_errno, FX_ERR_BAD_COUNT
                xor     ax, ax
                jmp     short send_fail

count_ok:       call    SendVector
                or      ax, ax
                jnz     FxSendRet       ; Returns non-zero value if success

send_fail:      call    FxInitPorts     ; zero if failure

FxSendRet:      ret

@FXSEND         ENDP


@FxReceive      LABEL   FAR
                PUBLIC  @FxReceive

@FXRECEIVE      PROC    FAR PASCAL PRIVATE USES CX DI SI ES, buf:FAR PTR

;* word _far _fastcall FxReceive(byte _far *buf, word max_len);

                mov     cx, ax          ; CX    := max length
                les     di, buf         ; ES:DI := buff ptr
                dec     ax
                add     ax, di
                jnc     count_ok

                mov     fx_errno, FX_ERR_BAD_COUNT
                xor     ax, ax
                jmp     short recv_fail

count_ok:       call    RecvVector
                or      ax, ax
                jnz     FxRecvRet       ; Returns count received on success

recv_fail:      call    FxInitPorts     ; zero if failure

FxRecvRet:      ret

@FXRECEIVE      ENDP

DefaultCheckAbort   PROC    FAR                 ; Default CheckAbort procedure

                xor     ax, ax
                ret

DefaultCheckAbort   ENDP

DoCheckAbort    PROC    NEAR USES BX CX ES

                call    GetTicks
                sub     ax, SyncStartTime
                call    dword ptr CheckAbortVec
                ret

DoCheckAbort    ENDP

SyncStart       PROC    NEAR

                call    GetTicks
                mov     SyncStartTime, ax
                ret

SyncStart       ENDP

SyncDone        PROC    NEAR USES AX DX

                pushf
                mov     dl, CHECK_ABORT_DONE
                call    DoCheckAbort
                popf
                ret

SyncDone        ENDP

CheckAbort      PROC    NEAR USES DX

; Enter with:
;   AX = elapsed tick count
; Return with:
;   AX = 0 to continue, else error code to be placed in fx_errno
;   ALL OTHER REGISTERS PRESERVED

                mov     dl, CHECK_ABORT_WAITING
                call    DoCheckAbort
                or      ax, ax
                jz      CheckAbortRet           ; Return with NC if AX == 0

                mov     fx_errno, ax
                stc

CheckAbortRet:  ret

CheckAbort      ENDP

@FxSyncTimeout  PROC

                xchg    ax, SyncTimeout
                ret

@FxSyncTimeout  ENDP

@FxSetCheckAbort    LABEL   FAR
                    PUBLIC  @FxSetCheckAbort

@FXSETCHECKABORT    PROC    FAR PASCAL PRIVATE USES ES, func:FAR PTR

                les     ax, func
                mov     dx, es                  ; DX:AX := func ptr
                mov     bx, dx
                or      bx, ax
                jnz     set_func_ptr

                mov     ax, OFFSET DefaultCheckAbort
                push    cs
                pop     dx

set_func_ptr:   mov     word ptr CheckAbortVec, ax
                mov     word ptr CheckAbortVec[2], dx
                ret

@FXSETCHECKABORT    ENDP

                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\fxlib\parallel.asm ===
INCLUDE         model.inc
INCLUDE         fastlynx.inc

;### NOIDLE     EQU     1
;### DEBUG      EQU     1
;### NO_TIMEOUT EQU     1

                PUBLIC  SendParallel
                PUBLIC  RecvParallel
                PUBLIC  parallel_port

                EXTRN   __crctab:WORD
                EXTRN   __crc_errors:WORD


                SUBTTL  Definitions
                PAGE

TIMER_INTERRUPT equ 1CH                 ; User timer interrupt vector

; Read and Write ACK/NAK values:
; The read values are the same as the write values execpt that they are shifted
; three to the left and the most significant bit is complemented.

WACK            equ     00000110B       ; WACK = 06H    NOT WACK = F9H
WNAK            equ     00000011B       ; WNAK = 03H    NOT WNAK = FCH
WIDLE           equ     00001010B

RACK            equ     ((WACK SHL 3) AND 7FH) OR ((NOT (WACK SHL 3)) AND 80H)
                                        ; RACK = B0H    NOT RACK = 4FH
RNAK            equ     ((WNAK SHL 3) AND 7FH) OR ((NOT (WNAK SHL 3)) AND 80H)
                                        ; RNAK = 98H    NOT RNAK = 67H

RIDLE           equ     ((WIDLE SHL 3) AND 7FH) OR ((NOT (WIDLE SHL 3)) AND 80H)

WSYNC           equ     00010101B       ; WSYNC = 15H   NOT WSYNC = EAH
RSYNC           equ     ((WSYNC SHL 3) AND 7FH) OR ((NOT (WSYNC SHL 3)) AND 80H)
                                        ; RSYNC = A8H   NOT RSYNC = 57H

INITIAL_CRC     equ     0FFFFH          ; Initial CRC accumulator
MAGIC_CRC       equ     1D0FH           ; Magic CRC number

DIRECTION_BIT   EQU     00100000B


                SUBTTL  protocol Specific Data
                PAGE

                .DATA
                EXTRN   SyncTimeout:WORD
                EXTRN   last_operation:BYTE

parallel_port       dw  ?               ; I/O port base address
save_length         dw  ?               ; Save area for received byte count
recv_ptr            dw  ?               ; Save area for buffer pointer
send_ptr            dw  ?               ; Save area for send buffer pointer
send_count          dw  ?               ; Save area for send count
ticks_remaining     dw  ?               ; Number of ticks until timeout occurs
last_nib_sent       db  ?
last_nib_received   db  ?



        		.CODE	text
                EXTRN   SyncStart:NEAR
                EXTRN   SyncDone:NEAR
                EXTRN   CheckAbort:NEAR
                EXTRN   GetTicks:NEAR
                EXTRN   NearShowBaud:NEAR
                
; These variables must be addressable relative to the CS register.

                EVEN

data_segment    dw      DGROUP
timer_save      dd      0               ; Old timer vector
alarm_vector    dw      ?

;******************************************************************************
;* IMPORTANT NOTE:  There must not be more than MAX_FIXUPS entries in any of
;* the lists below (not counting the initial fail address and trailing null).
;*
;* Also, each jump must be within short jump distance (128 bytes) of the fail
;* address, or of the the next jump that follows it.
;******************************************************************************

MAX_FIXUPS      EQU     5

send_word_list  dw      OFFSET sw_timeout, OFFSET swp1, OFFSET swp2, 0
send_pack_list2 dw      OFFSET sp_timeout, OFFSET spp2, OFFSET spp3, OFFSET spp4, 0
sp_normal_list  dw      OFFSET spn_timeout, OFFSET spn2, OFFSET spn3, OFFSET spn4, 0
recv_word_list  dw      OFFSET rw_timeout, OFFSET rwp1, OFFSET rwp2, 0
recv_pack_list  dw      OFFSET rp_timeout, OFFSET rpp1, OFFSET rpp2, OFFSET rpp3, 0
rp_normal_list  dw      OFFSET rpn_timeout, OFFSET rpn1, OFFSET rpn2, OFFSET rpn3, 0
wait_send_list  dw      OFFSET wsa_timeout, OFFSET wsa1, 0

code_list_ptr   dw      ?
code_save       dw      MAX_FIXUPS dup (?)

timer_jmp       dw      ?

timeout         db      ?
set_alarm_time  dw      ?

DBG     MACRO   char
        ENDM

HEX     MACRO   char
        ENDM


delay           PROC    NEAR

                push    ax
                push    bx
                push    cx
                mov     bx, ax

                call    GetTicks
                mov     cx, ax

delay_loop:     call    GetTicks
                sub     ax, cx
                cmp     ax, bx
                jb      delay_loop

                pop     cx
                pop     bx
                pop     ax
                ret

delay           ENDP


readStatus      PROC    NEAR

;* Performs:    Reads a byte from the status port five times, and determines
;*              if the defined bits are equal all five times.
;* Enter with:
;*      DX  = port base address
;* Returns:
;*      C   - Bytes were NOT equal
;*      NC  - Bytes were all equal, in which case sign bit is set as follows:
;*            S  : High bit of AL is set
;*            NS : High bit of AL is not set
;* Uses:
;*      AX

                inc     dx
                in      al, dx
                mov     ah, al
                and     ah, 0F8H

        REPT    4
                in      al, dx
                and     al, 0F8H
                cmp     al, ah
                jne     read_fail
        ENDM

                dec     dx              ; Restore DX
                or      al, al
                clc
                ret

read_fail:      dec     dx              ; Restore DX
                stc

read_ret:       ret

readStatus      ENDP


SaveParallel      PROC    NEAR

;* Enter with:
;*      DX    = port address
;*      ES:DI = ptr to 2 byte save area, as follows:
;*              data    register
;*              control register

                push    bx
                in      al, dx          ; Grab data register
                stosb
                inc     dx
                inc     dx
                in      al, dx          ; Grab control register (BASE + 2)

                mov     ah, al          ; AH = original port value
                xor     al, al
                out     dx, al          ; Write a 00 to control port
                recover
                recover
                in      al, dx
                mov     bl, al          ; Bits read to BL
                mov     al, 0FH
                out     dx, al          ; Write a 0F to control port
                recover
                recover
                in      al, dx
                xor     bl, al          ; BL = bits that changed
                or      bl, 0F0H
                and     bl, NOT DIRECTION_BIT
                mov     bh, 0CH

; BL = change bits.  If bit = 1, copy value from original port value in AH.
; If bit = 0, copy value from standard value in BH.

bit_loop:       shr     bl, 1
                jc      copy_old

                shr     ah, 1
                shr     bh, 1
                jmp     short copy

copy_old:       shr     bh, 1
                shr     ah, 1

copy:           rcr     al, 1
                or      bl, bl
                jnz     bit_loop

                stosb
                pop     bx
                ret

SaveParallel    ENDP

RestoreParallel PROC    NEAR

;* Enter with:
;*      DX    = port address
;*      DS:SI = ptr to 2 byte save area, as follows:
;*              data    register
;*              control register

                lodsb
                out     dx, al          ; Restore data register
                lodsb
                inc     dx
                inc     dx
                out     dx, al          ; Restore control register
                ret

RestoreParallel ENDP

; Listen should send a synchronization signal, and then wait for an answer.
; Upon failure to receive an answer, it should back up to sending the prior
; signal.

ParallelListenInit      PROC    NEAR

;* Enter with:
;*      BX    = vector index

                mov     fx_listen_vector[bx], OFFSET ListenSendWSYNC_2
                stc
                ret

ParallelListenInit      ENDP

ListenSendWSYNC_2       PROC    NEAR

;* Enter with:
;*      DX    = port base address
;*      BX    = port vector index
;* Uses:
;*      AX

                mov     al, NOT WSYNC
                out     dx, al
                mov     fx_listen_vector[bx], OFFSET ListenGetRSYNC
                stc
                ret

ListenSendWSYNC_2       ENDP

ListenGetRSYNC          PROC    NEAR

;* Enter with:
;*      DX    = port base address
;*      BX    = port vector index
;* Uses:
;*      AX

                call    readStatus
                jc      return

                cmp     al, RSYNC
                jne     return

                mov     al, WSYNC
                out     dx, al
                mov     fx_listen_vector[bx], OFFSET ListenGetRSYNC_2
return:         stc
                ret

ListenGetRSYNC          ENDP


ListenGetRSYNC_2        PROC    NEAR

;* Enter with:
;*      DX    = port base address
;*      BX    = port vector index
;* Uses:
;*      AX
;* Performs:    Tries to receive an RSYNC_2, upon failure will set the state
;*              back to waiting for RSYNC.

                call    readStatus
                jc      return

                cmp     al, (NOT RSYNC) AND 0F8H
                jne     test_2

                mov     al, WNAK
                out     dx, al
                mov     fx_listen_vector[bx], OFFSET ListenSendWSYNC_2
                mov     fx_parallel_speed, PARALLEL_TURBO
                clc
                ret

test_2:         cmp     al, (NOT RNAK) AND 0F8H
                jne     return

                mov     fx_listen_vector[bx], OFFSET ListenSendWSYNC_2
return:         stc
                ret

ListenGetRSYNC_2        ENDP


driver_timer_handler    LABEL   FAR

                jmp     WORD PTR cs:timer_jmp

; timer_handler_par -- Interrupt handler for timing while alarm is running
;
;   timer_handler_par is the interrupt handler which counts down the ticks in a
;   running alarm.  When the remaining ticks reaches zero, the interrupt return
;   will be modified to return to the timeout address.
;
;   In all cases, this routine appropriately chains to the previous interrupt
;   handler.
;
timer_handler_par   PROC    FAR

                push    ax
                push    bx
                push    ds
                mov     ds, cs:data_segment
                call    GetTicks
                mov     bx, ax
                sub     ax, cs:set_alarm_time
                mov     cs:set_alarm_time, bx       ; Update set_alarm_time
                sub     ticks_remaining, ax
                pop     ds
                pop     bx
                pop     ax
                jc      timed_out

                jnz     passthru        ; Jump if any time left

timed_out:      push    ax              ; Preserve used registers
                push    bx
                push    di
                push    si

                mov     cs:timeout, 1   ; Flag occurrence of timeout
                mov     di, cs:code_list_ptr
                xor     bx, bx

save_code_loop: mov     si, cs:[di + bx + 2]
                or      si, si
                jz      fixup_return

                mov     ax, cs:[di]     ; Get vector to fail address
                sub     ax, si          ; Get forward jump delta to AX
                sub     ax, 2           ; Adjust size of short jump
                cmp     ax, 127
                jbe     in_range

                mov     ax, cs:[di + bx + 4]    ; Grab following jump address
                sub     ax, si
                sub     ax, 2

in_range:       mov     ah, al
                mov     al, 0EBH        ; Jump short directly to fail location.
                xchg    ax, cs:[si]
                mov     cs:code_save[bx], ax
                add     bx, 2
                jmp     save_code_loop

fixup_return:   pop     si
                pop     di
                pop     bx
                pop     ax

timer_passthru_par  LABEL   FAR         ; Interrupt handler while alarm not on!


passthru:       jmp     cs:timer_save   ; chain through old timer vector

timer_handler_par   ENDP




; set_alarm_par -- Starts the alarm counting down ticks.
;
; Destroys registers: None
;
; set_alarm_par changes the timer interrupt vector from timer_passthru_par to
; timer_handler_par.  Before calling this routine ticks_remaining should be set
; to the number of ticks before a timeout trap should occur and code_list_ptr
; should be set to point to the list of code locations to change to NOPs.
; Since the granularity of the alarm is  tick,
; ticks_remaining should always be set to 2 or more (if set to 1, a timeout
; could occur immediately after the return from this routine).
;
set_alarm_par   PROC    NEAR

                mov     cs:timeout, 0
                push    ax
                call    GetTicks
                mov     cs:set_alarm_time, ax
                pop     ax
                mov     WORD PTR cs:timer_jmp, OFFSET timer_handler_par
                ret

set_alarm_par   ENDP


; clear_alarm_par -- Reset the timer interrupt handler to timer_passthru_par
;
; Destroys registers: None
;
; Outputs:
;   CF set if OK.  Clear if timeout occurred.
;
clear_alarm_par PROC    NEAR

                mov     WORD PTR cs:timer_jmp, OFFSET timer_passthru_par
                cmp     cs:timeout, 0
                je      no_timeout

                push    ax
                push    bx
                push    di
                push    si
                mov     di, cs:code_list_ptr
                xor     bx, bx

restore_code:   mov     si, cs:[di + bx + 2]
                or      si, si
                jz      restore_done

                mov     ax, cs:code_save[bx]
                mov     cs:[si], ax
                add     bx, 2
                jmp     restore_code

restore_done:   pop     si
                pop     di
                pop     bx
                pop     ax
                stc                     ; Set carry flag for timeout failure
                ret

no_timeout:     clc                     ; No carry if OK
                ret

clear_alarm_par ENDP


update_crc      PROC    NEAR

; Update CRC/checksum value in CX based on byte value in BL
; Destroys no registers


                push    bx
                xchg    ch, cl
                xor     cl, bl
                xor     bx, bx
                xchg    bl, cl
                shl     bx, 1
                xor     cx, __crctab[bx]
                pop     bx
                ret


update_crc      ENDP

; send_byte
;   The complement of this routine is recv_byte (and recv_byte_noack).
;
;   Inputs:
;       AL          Ticks to wait
;       BL          Byte to be sent
;       DX          Port base address
;
;   Outputs:
;       NC          Carry clear if byte successfully sent
;       C           Carry set if error in send
;       AL          If no error, final acknowledgment value
;                   Otherwise, unknown
;       DX          If no error occured, port base address--otherwise unknown
;
;   Registers destroyed: AX, BL
;
send_byte       PROC    NEAR

                xor     ah, ah
                mov     ticks_remaining, ax
                call    update_crc
                mov     cs:code_list_ptr, OFFSET send_word_list
                call    set_alarm_par   ; And we're off . . .
                mov     al, bl          ; Send low byte first
                or      al, 10H         ; Set transition bit
                out     dx, al          ; Send lower nibble
                shr     bl, 1           ; Prepare high nibble
                shr     bl, 1
                shr     bl, 1
                shr     bl, 1

@@:             call    readStatus      ; Wait for transition to occur
swp1::          jc      @B
                js      @B

                mov     al, bl          ; Get ready to send high nibble
                out     dx, al          ; Output high nibble

@@:             call    readStatus
swp2::          jc      @B
                jns     @B

sw_timeout::    call    clear_alarm_par

                ret

send_byte       ENDP

make_seq_flags  PROC    NEAR

                mov     bl, seq_num
                ret

make_seq_flags  ENDP


send_byte_sync  PROC    NEAR USES SI

                call    update_crc
                call    SyncStart
                mov     si, ax              ; Save starting time in SI
                mov     al, bl
                or      al, 10H
                out     dx, al
                shr     bl, 1
                shr     bl, 1
                shr     bl, 1
                shr     bl, 1
                mov     bp, OFFSET sbs_wait1

sbs_wait1:      call    readStatus
                jc      sbs_check
                js      sbs_check

                mov     al, bl          ; Get ready to send high nibble
                out     dx, al          ; Output high nibble
                mov     bp, OFFSET sbs_wait2

sbs_wait2:      call    readStatus
                jc      sbs_check
                jns     sbs_check

                clc
                jmp     short sbs_ret

sbs_check:      call    GetTicks
                sub     ax, si
                cmp     ax, SyncTimeout
                ja      sbs_fail

                call    CheckAbort
                jc      sbs_fail

                jmp     bp

sbs_fail:       stc

sbs_ret:        call    SyncDone
                ret

send_byte_sync  ENDP

; SendParallel
;   Inputs:
;       cx          Length of buffer to be sent
;       es:si       Pointer to buffer to be sent
;
;   Outputs:
;       CF          Set if packet successfully sent
;
;   Registers Destroyed: AX, BX, CX, DX, SI, DI, BP
;
; extern int SendParallel(void far *buffer, unsigned int count);
;

SendParallel    PROC    NEAR

                DBG     ''
                mov     send_ptr, si
                mov     send_count, cx
                mov     dx, parallel_port   ; dx = base (data) register
                cmp     last_operation, SEND_OPERATION
                je      sp_proceed

;--- Wait for line turnaround

                mov     bl, last_nib_received
                call    wait_send_ack
                mov     last_operation, SEND_OPERATION

sp_proceed:     mov     di, send_count
                mov     si, send_ptr
                mov     cx, INITIAL_CRC     ; Initialize CRC accumulator
                call    make_seq_flags      ; Prepares sequence & flags in BL
                call    send_byte_sync      ; Expects param in AH
                jc      sp_error

                cmp     al, RACK
                jne     sp_pack_err         ; Seq num error - unrecoverable

                mov     bx, di
                mov     al, MINIMUM_TICKS
                call    send_byte
                jc      sp_pack_err

                mov     bl, bh              ; Send MSB of count
                mov     al, MINIMUM_TICKS
                call    send_byte
                jc      sp_pack_err

                cmp     fx_parallel_speed, PARALLEL_NORMAL
                je      sp_normal

                mov     ticks_remaining, MINIMUM_TICKS

                mov     cs:code_list_ptr, OFFSET send_pack_list2
                call    set_alarm_par   ; Start the race. . .

sp_loop:        mov     ticks_remaining, MINIMUM_TICKS
                mov     al, es:[si]     ; al = byte to send
                mov     bl, al          ; Keep a copy for CRC calculation
                inc     si              ; Point to next byte
                mov     ah, al          ; Preserve High nibble
                or      al, 10H         ; Or in transition bit
                out     dx, al          ; ==> Output lower nibble
                shr     ah, 1           ; ##### Replace w/ shr ah, 4 on 286
                shr     ah, 1
                shr     ah, 1
                shr     ah, 1
                inc     dx              ; Point to status register

@@:             in      al, dx          ; Wait for receivers transition
                or      al, al
spp2::          js      @B

                dec     dx              ; Point to data register
                mov     al, ah          ; al = high nibble
                out     dx, al          ; ==> output high nibble
                xchg    ch, cl
                xor     cl, bl
                xor     bx, bx
                xchg    bl, cl
                shl     bx, 1
                xor     cx, __crctab[bx]
                inc     dx              ; Point to status register

@@:             in      al, dx          ; Wait for receivers transition
                or      al, al
spp3::          jns     @B

                dec     dx              ; Point to data register
                dec     di              ; Decrement count
spp4::          jnz     sp_loop         ; Repeat until no bytes left

                call    clear_alarm_par ; Turn off alarm
                jc      sp_timeout

sp_common:      not     cx              ; Complement CRC accumulator
                mov     bx, cx
                xchg    bh, bl
                mov     al, MINIMUM_TICKS
                call    send_byte       ; Send complemented CRC accumulator MSB
                jc      sp_retry_err

                mov     bl, bh
                mov     al, bl
                mov     cl, 4
                shr     al, cl
                mov     last_nib_sent, al
                mov     al, MINIMUM_TICKS
                call    send_byte       ; Send complemented CRC accumulator LSB
                jc      sp_retry_err

                cmp     al, RACK        ; Did CRC match?
                jne     crc_error

sp_ok:          inc     seq_num
                and     seq_num, SEQUENCE_BITS
                mov     ax, 1           ; Return AX == 1 on success
                jmp     SHORT sp_ret

crc_error:      inc     __crc_errors    ; Increment CRC error counts
                mov     ax, FX_ERR_CRC
                jmp     short sp_retry_err  ; Get out if to many

sp_timeout::    DBG     '*'
                call    clear_alarm_par

sp_retry_err:   mov     ax, FX_ERR_FAIL

sp_check_speed: cmp     fx_parallel_speed, PARALLEL_NORMAL
                je      sp_error

;--- Got an error at TURBO speed so retry at NORMAL speed.

                mov     fx_parallel_speed, PARALLEL_NORMAL
                call    NearShowBaud
                mov     dx, parallel_port
                mov     al, WNAK
                out     dx, al
                mov     ax, 4 * MINIMUM_TICKS
                call    delay
                jmp     sp_proceed

sp_pack_err:    mov     ax, FX_ERR_FAIL

sp_error:       mov     fx_errno, ax
                mov     dx, parallel_port
                mov     al, WNAK
                out     dx, al
                xor     ax, ax          ; Return 0 on failure

sp_ret:         ret

;----------------------- normal (slow) code ----------------------------------

sp_normal:      mov     ticks_remaining, MINIMUM_TICKS
                mov     cs:code_list_ptr, OFFSET sp_normal_list
                call    set_alarm_par   ; Start the race. . .

spn_loop:       mov     ticks_remaining, MINIMUM_TICKS
                mov     al, es:[si]     ; al = byte to send
                mov     bl, al          ; Keep a copy for CRC calculation
                inc     si              ; Point to next byte
                mov     bh, al          ; Preserve High nibble
                or      al, 10H         ; Or in transition bit
                out     dx, al          ; ==> Output lower nibble
                shr     bh, 1           ; ##### Replace w/ shr ah, 4 on 286
                shr     bh, 1
                shr     bh, 1
                shr     bh, 1

@@:             call    readStatus
spn2::          jc      @B
                js      @B

                mov     al, bh          ; al = high nibble
                out     dx, al          ; ==> output high nibble
                xchg    ch, cl
                xor     cl, bl
                xor     bx, bx
                xchg    bl, cl
                shl     bx, 1
                xor     cx, __crctab[bx]

@@:             call    readStatus
spn3::          jc      @B
                jns     @B

                dec     di              ; Decrement count
spn4::          jnz     spn_loop        ; Repeat until no bytes left

                call    clear_alarm_par ; Turn off alarm
                jnc     sp_common

                jmp     sp_pack_err

spn_timeout::   DBG     '*'
                jmp     sp_timeout


SendParallel   ENDP



; recv_byte_noack
;   Receives a byte on port DX
;   This routine assumes that the sender posted an ACK on the port.
;
;   The final acknowledgement is not sent by this routine, but must be sent by
;   the caller of this routine.  This allows either an ACK or a NAK to be sent
;   back to the sender.
;
;   The complement of this routine is send_byte
;
;
;   Inputs:
;       AX          Ticks to wait for word
;       DX          Port base address
;
;   Outputs:
;       BL          byte received (Unknown if error)
;       CF          Clear if byte successfully recieved
;                   Set if error in recieve
;       DX          If no error occurs, port base address.  Otherwise unknown.
;
;   Registers destroyed: AX
;
;   If the last nibble recieved is RNAK, the alternate ready flag will be set.
;   Othersize it will be cleared
;
recv_byte_noack PROC    NEAR

                xor     ah, ah
                mov     ticks_remaining, ax
                mov     cs:code_list_ptr, OFFSET recv_word_list
                call    set_alarm_par   ; And we're off . . .

@@:             call    readStatus
rwp1::          jc      @B
                js      @B

                mov     bl, al          ; Save low nibble
                mov     al, NOT WNAK    ; Set Transition bit
                out     dx, al          ; And output it
                shr     bl, 1
                shr     bl, 1
                shr     bl, 1           ; place low nibble, high bit already 0

@@:             call    readStatus
rwp2::          jc      @B
                jns     @B

                shl     al, 1           ; Fix up nibble
                or      bl, al          ; Whole byte now in BL
                call    update_crc
                
rw_timeout::    call    clear_alarm_par

rw_ret:         ret 

recv_byte_noack ENDP

wait_send_ack   PROC    NEAR

;* Wait for sender to acknowledge having seen our last ACK/NAK.
;* The last nibble sent will be complemented when sender acknowledges.
;*
;* Enter with:
;*      DX = port base address
;*      BL = last nibble received
;* On return:
;*      AX, BL clobbered
;*      NC - Carry clear if send acknowledge seen
;*       C - Carry set if no sender acknowledge seen

                mov     ticks_remaining, MINIMUM_TICKS
                mov     cs:code_list_ptr, OFFSET wait_send_list
                call    set_alarm_par

                not     bl                      ; Complement the high nibble
                and     bl, 0F0H                ; Isolate turnaround bits

;*** Now wait for sender to toggle his high nibble so we know that he saw
;*** our acknowledgment.

@@:             call    readStatus
wsa1::          jc      @B

                shl     al, 1
                cmp     al, bl
                jne     @B

wsa_timeout::   call    clear_alarm_par
                ret

wait_send_ack   ENDP

recv_byte       PROC    NEAR

                call    recv_byte_noack
                jc      recv_byte_ret

                mov     al, WNAK
                out     dx, al
                
recv_byte_ret:  ret

recv_byte       ENDP

recv_byte_sync  PROC    NEAR USES SI DI BP

; Enter with:
;   DX = port_address
; On return:
;   BL = character read, NC, C flag set if error
;   BH, AX  clobbered

                call    SyncStart
                mov     di, ax          ; Save original time
                mov     bh, 0FFH        ; Put impossible input into BH
                mov     bp, OFFSET rbs1

reset_time:     call    GetTicks
                mov     si, ax          ; Save starting time in SI

rbs1:           call    readStatus
                jc      rbs_check
                jns     rbs_high_nib

                cmp     al, RIDLE       ; 11010000B
                je      valid_idle

                cmp     al, 10101000B
                jne     rbs_check

valid_idle:     push    ax
                call    GetTicks
                sub     ax, di
                cmp     ax, 3
                pop     ax
                jb      rbs_check

                mov     ah, al          ; Save copy in AH
                shr     al, 1
                shr     al, 1
                shr     al, 1
                and     al, 0FH
                out     dx, al
                cmp     ah, bh
                mov     bh, ah
                jne     reset_time

                jmp     short rbs_check

rbs_high_nib:   mov     bl, al          ; Save low nibble
                mov     al, NOT WNAK    ; Set Transition bit
                out     dx, al          ; And output it
                shr     bl, 1
                shr     bl, 1
                shr     bl, 1           ; place low nibble, high bits already 0
                mov     bp, OFFSET rbs2

rbs2:           call    readStatus
                jc      rbs_check
                jns     rbs_check

                shl     al, 1           ; Fix up nibble
                or      bl, al          ; Whole byte now in BL
                clc
                jmp     short rbs_ret

rbs_check:      call    GetTicks
                sub     ax, si
                cmp     ax, SyncTimeout
                ja      rbs_fail

                call    CheckAbort
                jc      rbs_fail

                jmp     bp

rbs_fail:       stc

rbs_ret:        call    SyncDone
                ret

recv_byte_sync  ENDP

; RecvParallel     Recieve a packet
;   Inputs:
;       es:di       pointer to buffer
;       cx          max size of buffer
;
;   Outputs:
;       CF          Set if packet recieved
;                   Clear if timeout or some other error
;       cx          If no error, number of bytes recieved.  Otherwise, unknown.
;
;   Uses registers: ax bx cx dx si di
;
; extern unsigned int RecvParallel(void far *buffer, unsigned int count);
;
RecvParallel    PROC    NEAR

                DBG     ''
                mov     fx_errno, 0
                mov     bp, cx              ; save buffer length
                mov     recv_ptr, di
                mov     dx, parallel_port   ; Point to base (data) register
                cmp     last_operation, RECV_OPERATION
                je      rp_proceed

                mov     al, last_nib_sent
                not     al
                and     al, 0FH
                out     dx, al
                mov     last_operation, RECV_OPERATION

rp_proceed:     mov     di, recv_ptr
                call    recv_byte_sync
                mov     ax, FX_ERR_TIMEOUT
                jc      rp_error


                mov     cx, INITIAL_CRC     ; Initialize CRC accumulator
                call    update_crc
                and     bl, SEQUENCE_BITS
                cmp     bl, seq_num
                je      get_cnt

                mov     ax, FX_ERR_BAD_SEQUENCE
                jmp     rp_error

get_cnt:        mov     al, WACK
                out     dx, al          ; ==> Acknowledge sequence number
                mov     al, MINIMUM_TICKS
                call    recv_byte
                jc      rp_fail

                mov     bh, bl          ; Save LSB of length in BH
                mov     al, MINIMUM_TICKS
                call    recv_byte
                jc      rp_fail

                xchg    bh, bl
                dec     bx              ; NOTE: 0 = 64K, so dec before cmp
                dec     bp
                cmp     bx, bp          ; Room in buffer?
                ja      rp_fail

                inc     bx
                inc     bp
                mov     si, bx          ; SI = count
                mov     save_length, bx ; Save number of bytes to be read
                cmp     fx_parallel_speed, PARALLEL_NORMAL
                je      recv_normal

                mov     ticks_remaining, MINIMUM_TICKS

                mov     cs:code_list_ptr, OFFSET recv_pack_list
                call    set_alarm_par   ; And there off. . .

rp_loop:        inc     dx              ; Point to status register

@@:             in      al, dx          ; Wait for transition
                or      al, al
rpp1::          js      @B

                in      al, dx          ; re-read after line has settled a bit
                mov     bl, al          ; save low nibble
                dec     dx              ; Point to data register
                mov     al, NOT WNAK    ; set transition bit
                out     dx, al          ; output transition
                shr     bl, 1           ; get lower nibble into its position
                shr     bl, 1           ; #### Replace with shr bl, 3 on 286
                shr     bl, 1
                inc     dx
                mov     ticks_remaining, MINIMUM_TICKS

@@:             in      al, dx          ; Wait for transition
                or      al, al
rpp2::          jns     @B

                in      al, dx          ; Let line settle a bit
                mov     bh, al          ; save high nibble
                mov     al, WNAK        ; clear transition bit
                dec     dx              ; point to data register
                out     dx, al          ; Output transition
                shl     bh, 1           ; Position high nibble
                and     bh, 0F0H        ; clear out garbage nibble
                or      bl, bh          ; or nibbles together
                mov     al, bl          ; save byte in the buffer
                stosb
                xchg    ch, cl
                xor     cl, bl
                xor     bx, bx
                xchg    bl, cl
                shl     bx, 1
                xor     cx, __crctab[bx]

                dec     si              ; Any bytes left to recieve?
rpp3::          jnz     rp_loop

                call    clear_alarm_par ; Turn off the alarm clock
                jc      rp_timeout

recv_common:    mov     al, MINIMUM_TICKS
                call    recv_byte       ; Receive CRC MSB
                jc      rp_timeout

                mov     al, MINIMUM_TICKS
                call    recv_byte_noack ; Receive CRC LSB
                jc      rp_timeout

                cmp     cx, MAGIC_CRC   ; Check for CRC error
                jne     crc_error

rp_ok:          mov     al, WACK        ; Acknowledge packet recieved
                out     dx, al
                mov     last_nib_received, bl   ; Save copy of last nibble
                inc     seq_num
                and     seq_num, SEQUENCE_BITS
                mov     ax, save_length
                jmp     SHORT rp_exit

crc_error:      inc     __crc_errors      ; Increment CRC error counts
                DBG     '~'
                mov     ax, FX_ERR_CRC
                jmp     short rp_check_speed

rp_timeout::    call    clear_alarm_par
                DBG     '*'
                mov     ax, FX_ERR_FAIL

rp_check_speed: cmp     fx_parallel_speed, PARALLEL_NORMAL
                je      rp_error

;--- Got an error at TURBO speed so retry at NORMAL speed.

                mov     fx_parallel_speed, PARALLEL_NORMAL
                call    NearShowBaud
                mov     dx, parallel_port
                mov     al, WNAK
                out     dx, al
                mov     ax, 2 * MINIMUM_TICKS
                call    delay
                jmp     rp_proceed

rp_fail:        mov     ax, FX_ERR_FAIL

rp_error:       mov     fx_errno, ax
                mov     dx, parallel_port
                mov     al, WNAK
                out     dx, al
                xor     ax, ax

rp_exit:        ret

;--------------------- normal (slow) receive code ---------------------------

recv_normal:    mov     ticks_remaining, MINIMUM_TICKS
                mov     cs:code_list_ptr, OFFSET rp_normal_list
                call    set_alarm_par   ; And there off. . .

rpn_loop:       call    readStatus
rpn1::          jc      rpn_loop
                js      rpn_loop

                mov     bl, al          ; save low nibble
                mov     al, NOT WNAK    ; set transition bit
                out     dx, al          ; output transition
                shr     bl, 1           ; get lower nibble into its position
                shr     bl, 1           ; #### Replace with shr bl, 3 on 286
                shr     bl, 1
                mov     ticks_remaining, MINIMUM_TICKS

@@:             call    readStatus
rpn2::          jc      @B
                jns     @B

                mov     bh, al          ; save high nibble
                mov     al, WNAK        ; clear transition bit
                out     dx, al          ; Output transition
                shl     bh, 1           ; Position high nibble
                or      bl, bh          ; or nibbles together
                mov     al, bl          ; save byte in the buffer
                stosb
                xchg    ch, cl
                xor     cl, bl
                xor     bx, bx
                xchg    bl, cl
                shl     bx, 1
                xor     cx, __crctab[bx]

                dec     si              ; Any bytes left to recieve?
rpn3::          jnz     rpn_loop

                call    clear_alarm_par ; Turn off the alarm clock
                jc      rp_fail

                jmp     recv_common

rpn_timeout::   DBG     '*'
                jmp     rp_timeout


RecvParallel    ENDP


ParallelInit    PROC    NEAR

                mov     ax, 3500H + TIMER_INTERRUPT
                int     21H             ; Current timer vector -> timer_save
                mov     WORD PTR cs:timer_save, bx
                mov     WORD PTR cs:timer_save + 2, es

                mov     WORD PTR cs:timer_jmp, OFFSET timer_passthru_par
                mov     dx, OFFSET driver_timer_handler
                push    ds              ; Save DS
                push    cs
                pop     ds              ; ds:dx -> driver_timer_handler
                mov     ax, 2500H + TIMER_INTERRUPT
                int     21H             ; Set timer vector to timer handler
                pop     ds              ; restore DS
                ret

ParallelInit    ENDP

ParallelExit    PROC    NEAR

                push    ds
                lds     dx, cs:timer_save
                mov     ax, 2500H + TIMER_INTERRUPT
                int     21H
                pop     ds
                ret

ParallelExit    ENDP


                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\fxlib\serial.asm ===
INCLUDE         model.inc
INCLUDE         fastlynx.inc

;### NO_TIMEOUT      EQU    1
;### DEBUG           EQU    1

INT_MASK        EQU     0FEH            ; All but timer disabled
TIMER_INTERRUPT EQU     08H             ; Timer interrupt vector

; Note on timings:  timer_handler counts how many normal clock ticks pass
; each tick occurs every 55 milli-seconds.  However, from the time that the
; alarm is set to the first tick can be from zero seconds up to 55 milli-
; seconds.  So maximum times should be calculated using the number of ticks
; minus one.  Also, for the same reason, MINIMUM_TICKS must be >= 2.
;
; MINIMUM_TICKS is the minimum time allowed on the timer.  This must be no less
; that 2.  If it is 1, it is possible for the timeout to occur immediately.
;
; For a data segment of 65535 bytes (maximum number of bytes possible) the
; timeout would be 129 ticks (using shift factor 9, minimum 2) or 7.04 seconds.
;
; SEND_PACK_TICKS is the default timeout value used in send_pack_ser.
; 19 ticks allows the receiver .99 seconds to respond to the send request.
;
;

CONNECT_BAUD    EQU     BAUD_9600

INITIAL_CRC     EQU     0FFFFH          ; Initial CRC accumulator
MAGIC_CRC       EQU     1D0FH           ; Magic CRC number

OVERRUN_ERROR   EQU     00000010B
PARITY_ERROR    EQU     00000100B
FRAMING_ERROR   EQU     00001000B
PARITY_OR_FRAMING_ERROR EQU 0CH

; Serial port flags
BAD_PORT        EQU     80H

DATA_PORT       EQU     0               ; Serial port definitions
INT_ENABLE      EQU     1
INT_ID          EQU     2
LINE_CONTROL    EQU     3
MODEM_CONTROL   EQU     4
LINE_STATUS     EQU     5
MODEM_STATUS    EQU     6

DATABITS8       EQU     3
STOPBITS1       EQU     0
NOPARITY        EQU     0


                PUBLIC  SendSerialBlock
                PUBLIC  SendSerial
                PUBLIC  RecvSerial
                PUBLIC  SetBaud
                PUBLIC  @FxSetBaud
                PUBLIC  FxShowBaud
                PUBLIC  serial_port
                PUBLIC  NearShowBaud

                EXTRN   __crctab:WORD
                EXTRN   __crc_errors:WORD

                .DATA
                EXTRN   last_operation:BYTE
                EXTRN   SyncTimeout:WORD
        IFDEF DEBUG
                EXTRN   _display_segment:WORD
                PUBLIC  screen_offset
        ENDIF

ShowBaud        dw      OFFSET  far_null_proc
                dw      SEG far_null_proc

MAX_BLOCK       EQU     8192
                

client          db      ?
server          db      ?
first_send      db      ?
polite_timer    db      ?    
interrupt_mask  db      ?
recv_type       db      ?               ; type of packet received
recv_buff_ptr   dw      ?               ; Save area of recv_buff_ptr
recv_byte_error db      ?
serial_port     dw      ?               ; I/O port base address
win386_enh_mode db      ?
hp_95lx         db      0
need_send_echo  db      0
send_remaining  dw      ?           ; Number of bytes remaining in send

recv_table      dw      OFFSET recv_3_norm
                dw      OFFSET recv_3_echo
                dw      OFFSET recv_3_norm
                dw      OFFSET recv_3_echo
                dw      OFFSET recv_3_norm
                dw      OFFSET recv_3_echo
                dw      OFFSET recv_3_norm
                dw      OFFSET recv_3_echo

send_table      dw      OFFSET send_3_norm
                dw      OFFSET send_3_echo
                dw      OFFSET send_3_norm
                dw      OFFSET send_3_echo
                dw      OFFSET send_3_norm
                dw      OFFSET send_3_echo
                dw      OFFSET send_3_norm
                dw      OFFSET send_3_echo

baud_table      db      96          ;   1200 baud   (index 0)
                db      48          ;   2400 baud   (index 1)
                db      24          ;   4800 baud   (index 2)
                db      12          ;   9600 baud   (index 3)
                db       6          ;  19200 baud   (index 4)
                db       3          ;  38400 baud   (index 5)
                db       2          ;  57600 baud   (index 6)
                db       1          ; 115200 baud   (index 7)

packet_ok        db      ?
prior_baud       db      ?

MAX_SEND_FAILS  EQU     2

echo_byte       db      ?
echo_ret        dw      ?
ax_save         dw      ?
send_fails      db      0


baud_list1      db      ?, 0FFH, 000H, 05AH, 055H, 0AAH, 0F0H, 00FH, 0E7H, 07EH, 0C3H, 03CH, 081H, 018H, 000H, 0FFH
BAUD_LIST_SIZE  EQU     $ - baud_list1
baud_list2      db      ?, 000H, 0FFH, 0A5H, 0AAH, 055H, 0F0H, 00FH, 0FFH, 000H, 018H, 081H, 03CH, 0C3H, 07EH, 0E7H

        		.CODE   text
                EXTRN   ResetListenTime:NEAR
                EXTRN   GetTicks:NEAR
                EXTRN   GetPortInfo:NEAR
                EXTRN   GetPortIndex:NEAR
                EXTRN   SyncStart:NEAR
                EXTRN   SyncDone:NEAR
                EXTRN   CheckAbort:NEAR
                PUBLIC  SerialInit
                PUBLIC  setup_recv_byte

; These variable must be addressable relative to the CS register.

                EVEN

is_serial       db      0               ; 1 if connected on a serial port
alarm_vector    dw      ?               ; Return offset when timeout occurs
timer_save      dd      0               ; Old timer vector
ticks_remaining dw      ?               ; Number of ticks until timeout occurs
lost_ticks      dw      ?               ; Tick count while timer set
set_alarm_time  dw      ?

MAX_FIXUPS      EQU     5

null_code_list  dw      0, 0
code_list_ptr   dw      OFFSET null_code_list
code_save       dw      (2 + MAX_FIXUPS) dup (?)
timeout         db      ?


DBG     MACRO   char
    IFDEF DEBUG
        push    ax
        mov     al, char
        call    debug_msg_proc     ; debug_msg pops off AX and restores it
    ENDIF
        ENDM

HEX     MACRO   char
    IFDEF DEBUG
        push    ax
        mov     al, char
        call    hex_out_proc
        pop     ax
    ENDIF
        ENDM

IFDEF DEBUG
MIN_OFFSET      EQU     2 * 2 * 80
MAX_OFFSET      EQU     8 * 2 * 80
screen_offset   dw      MIN_OFFSET
debug_ret       dw      ?

@debug_char     PROC    FAR
                PUBLIC  @debug_char

                push    ax
                call    debug_msg_proc
                ret

@debug_char     ENDP

@debug_hex      PROC    FAR
                PUBLIC  @debug_hex

                call    hex_out_proc
                ret

@debug_hex      ENDP

debug_msg_proc  PROC    NEAR

; AX has been pushed on the stack before calling this routine
; Output the character in AL
;   ALL REGISTERS AND FLAGS PRESERVED

                pop     cs:debug_ret
                pushf
                push    es
                push    di
                mov     di, _display_segment
                mov     es, di
                mov     ah, 70H
                mov     di, cs:screen_offset
                stosw
                cmp     di, MAX_OFFSET
                jb      @F

                mov     di, MIN_OFFSET

@@:             mov     ax, 720H
                mov     es:[di], ax
                mov     cs:screen_offset, di
                pop     di
                pop     es
                popf
                pop     ax
                jmp     cs:debug_ret

debug_msg_proc  ENDP

hex_nibble      PROC    NEAR

                and     al, 0FH
                add     al, '0'
                cmp     al, '9'
                jbe     @F

                add     al, 7

@@:             ret

hex_nibble      ENDP


hex_out_proc    PROC    NEAR

; Output value in AL as hex digits
;   ALL REGISTERS AND FLAGS PRESERVED

                pushf
                push    ax
                mov     ah, al
                shr     al, 1
                shr     al, 1
                shr     al, 1
                shr     al, 1
                call    hex_nibble          ; Prepare original high nibble
                call    debug_msg_proc
                push    ax
                call    hex_nibble          ; Prepare original low nibble
                call    debug_msg_proc
                popf
                ret

hex_out_proc    ENDP
ENDIF

;----------------------------------------------------------------------------
timer_handler   PROC   FAR

;*** The two bytes below are modified as follows:
;***    impolite handler set:   1st 2 bytes of:
;***                                            push    ax
;***                                            mov     al, 20H
;***    alarm not set:          jmp short timer_passthru
;***    polite alarm set:       jmp short polite_handler
;***
;*** IMPORTANT: handlers below MUST be within short jump distance from here!!!

                push    ax
                mov     al, 20H         ; Non-Specific EOI
                out     20H, al
                inc     cs:lost_ticks
                dec     cs:ticks_remaining
                jz      @F              ; Jump if time has expired

th_ret:         pop     ax
                iret

@@:             call    modify_code
                jmp     SHORT th_ret

polite_handler  LABEL   FAR

                push    ax
                push    bx
                call    GetTicks
                mov     bx, ax
                sub     ax, cs:set_alarm_time
                mov     cs:set_alarm_time, bx
                sub     cs:ticks_remaining, ax
                pop     bx
                pop     ax
                jc      timed_out

                jnz     @F

timed_out:      call    modify_code

@@:             jmp     DWORD PTR cs:timer_save


; timer_passthru -- Interrupt handler when alarm is not set!
;
timer_passthru  LABEL   FAR         ; Interrupt handler while alarm not on!


passthru:       jmp     DWORD PTR cs:timer_save   ; chain through old timer vector

timer_handler   ENDP

far_null_proc   PROC    FAR

                ret

far_null_proc   ENDP

check_windows   PROC    NEAR

                push    bx
                push    cx
                push    dx
                push    di
                push    si
                push    bp
                push    es
                mov     win386_enh_mode, 0
                mov     hp_95lx, 0
                mov     ax, 352FH
                int     21H
                mov     ax, es
                or      ax, bx
                jz      check_done

                mov     ax, 1600H
                int     2FH
                test    al, 7FH
                jz      check_done

                cmp     al, 1
                je      check_done

                cmp     al, 0FFH
                je      check_done

                inc     win386_enh_mode

check_done:     xor     bx, bx
                mov     ax, 4DD4H
                int     15H
                cmp     bx, "HP"            ; Look for BH = 'H', BL = 'P'
                jne     @F

                inc     hp_95lx

@@:             pop     es
                pop     bp
                pop     si
                pop     di
                pop     dx
                pop     cx
                pop     bx
                ret

check_windows   ENDP


WaitIdle        PROC    NEAR    USES CX

;* Enter with:
;*      DX = port base address
;*      BX = port vector index
;* Uses:
;*      AX
;* Returns:
;*      CARRY = Timed out

                call    GetTicks
                mov     cx, ax

wait_loop:      add     dl, LINE_STATUS
                in      al, dx
                sub     dl, LINE_STATUS
                cmp     al, 60H
                je      wi_done

                rcr     al, 1
                jnc     check_time

                in      al, dx

check_time:     call    GetTicks
                sub     ax, cx
                cmp     ax, MINIMUM_TICKS
                jbe     wait_loop

                stc
                jmp     short return

wi_done:        clc

return:         ret

WaitIdle        ENDP

SetBaud         PROC    NEAR USES SI DX
;* Enter with:
;*      AL = desired baud_table index
;*      DX = port base address
;* Uses:
;*      AX
;* Returns:
;*      NC - set baud succeeded
;*      C  - set baud failed

                mov     fx_baud, al
                xor     ah, ah
                mov     si, ax
                call    WaitIdle
                jc      sb_ret              ; Return with carry set

                add     dl, LINE_CONTROL
                mov     al, 80H OR NOPARITY OR STOPBITS1 OR DATABITS8
                out     dx, al
                recover

                sub     dl, 2               ; dx -> Baud Rate (MSB)
                xor     al, al              
                out     dx, al
                recover

                dec     dx                  ; dx -> Baud Rate (LSB)
                mov     al, baud_table[si]
                out     dx, al
                recover

                add     dl, LINE_CONTROL
                mov     al, NOPARITY OR STOPBITS1 OR DATABITS8
                out     dx, al
                recover

                sub     dl, LINE_CONTROL
                call    WaitIdle
                jc      sb_ret              ; Return with carry set

                cmp     fx_port, -1
                je      sb_ok

                call    NearShowBaud

sb_ok:          clc

sb_ret:         ret

SetBaud         ENDP

@FxSetBaud      PROC    FAR

                call    SetBaud
                mov     ax, 0
                jc      set_baud_ret

                inc     ax

set_baud_ret:   ret

@FxSetBaud      ENDP

InitPort        PROC    NEAR    USES SI

;* Enter with:
;*      DX = port base address
;*      BX = port vector index
;* Uses:
;* Performs:

                call    WaitIdle
                jc      bad_port            ; could not obtain idle

                add     dl, INT_ENABLE      ; dx -> INT_ENABLE
                xor     al, al              ; Turn off all interrupts
                out     dx, al
                recover

                add     dl, MODEM_CONTROL - INT_ENABLE  ; dx -> MODEM_CONTROL
                out     dx, al
                recover

                sub     dl, MODEM_CONTROL

                mov     al, CONNECT_BAUD
                call    SetBaud
                jc      bad_port

                call    GetPortIndex
                and     FxPortInfo[si].FxPortInfoDef.pi_flags, BAD_PORT XOR 0FFH
                ret

bad_port:       call    GetPortIndex
                or      FxPortInfo[si].FxPortInfoDef.pi_flags, BAD_PORT
                ret

InitPort        ENDP
                
SerialInit      PROC    NEAR

;* Enter with:
;* Uses:
;*      BX
;* Performs:    Cycles through all of the ports defined to fastlynx and for
;*              each port that is serial initializes the UART and sets the
;*              baud rate to CONNECT_BAUD.

                xor     bx, bx

init_loop:      cmp     bx, fx_tail
                jae     steal_vector

                call    GetPortInfo
                cmp     al, SERIAL_PORT
                jne     skip

                call    InitPort

skip:           inc     bx
                inc     bx
                jmp     init_loop

steal_vector:   push    dx
                push    ds
                mov     ax, 3500H + TIMER_INTERRUPT
                int     21H             ; Current timer vector -> timer_save
                mov     WORD PTR cs:timer_save, bx
                mov     WORD PTR cs:timer_save + 2, es
;###            mov     WORD PTR cs:timer_handler, 0EBH OR ((OFFSET timer_passthru - (OFFSET timer_handler + 2)) SHL 8)
                mov     WORD PTR cs:timer_handler, 0EBH OR (3Ah SHL 8)
.ERRE (OFFSET timer_passthru - (OFFSET timer_handler + 2)) EQ 3Ah
                mov     dx, OFFSET timer_handler
                push    cs
                pop     ds              ; ds:dx -> timer_handler
                mov     ax, 2500H + TIMER_INTERRUPT
                int     21H             ; Set timer vector to timer handler
                pop     ds
                pop     dx
                ret

SerialInit      ENDP

SaveSerial      PROC    NEAR

;* Enter with:
;*      DX    = port address
;*      ES:DI = ptr to 5 byte save area
;* 5 bytes of port info is saved for each port as follows:
;*    Interrupt Enable Register
;*    Modem Control Register
;*    Line Control Register
;*    Baud Rate Divisor high byte
;*    Baud Rate Divisor low  byte

                inc     dx
                cli                             ;Disable interrupts
                in      al, dx                  ;Grab INT ENABLE byte
                recover
                stosb
                add     dx, 3                   ;Point to MODEM CONTROL
                in      al, dx
                recover
                stosb
                dec     dx                      ;Point back to LINE CONTROL
                in      al, dx
                recover
                stosb
                sub     dx, LINE_CONTROL        ;Point back to DATA port
                call    GetBaudRate           ;Interrupts re-enabled in here
                xchg    al, ah                  ;Store high byte, then low
                stosw
                ret

SaveSerial      ENDP

RestoreSerial   PROC    NEAR

;* Enter with:
;*      DX    = port address
;*      DS:SI = ptr to 5 byte save area
;*      AH    = bios port number of COM port (0 if none)
;* 5 bytes of port info is restored for each port as follows:
;*    Interrupt Enable Register
;*    Modem Control Register
;*    Line Control Register
;*    Baud Rate Divisor high byte
;*    Baud Rate Divisor low  byte

                inc     dx
                lodsb
                cli                             ;Disable interrupts
                out     dx, al                  ;Update INT ENABLE
                recover
                add     dx, 3                   ;Point to MODEM CONTROL
                lodsb
                out     dx, al
                recover
                dec     dx                      ;Point back to LINE CONTROL
                lodsb
                or      al, 80H                 ;Set DLAB
                out     dx, al
                recover
                dec     dx
                dec     dx
                lodsb
                out     dx, al                  ;Update high byte of divisor
                recover
                lodsb
                dec     dx
                out     dx, al                  ;Update low byte of divisor
                recover
                add     dx, 3                   ;Point back to LINE CONTROL
                mov     al, [si - 3]            ;Get back original line control
                out     dx, al                  ;Update line control
                recover
                sub     dx, 3                   ;Point back to data port
                in      al, dx                  ;Read to prime interrupt pump
                or      ah, ah                  ;BIOS port?
                jz      @F                      ;Not BIOS port - don't reset IRQ

                mov     al, 64H
                dec     ah                      ;Convert 1 - 4 to 0 - 3
                and     ah, 1                   ;Isolate low bit
                sub     al, ah                  ;COM1 & 3: IRQ4, COM2 & 4: IRQ3
                out     20H, al                 ;Specific EOI for IRQ

@@:             sti                             ;Re-enable interrupts
                ret

RestoreSerial   ENDP

SerialExit      PROC    NEAR

                push    ds
                push    dx
                lds     dx, cs:timer_save
                mov     ax, 2500H + TIMER_INTERRUPT
                int     21H
                pop     dx
                pop     ds
                ret

SerialExit      ENDP

GetBaudRate     PROC    NEAR USES BX

;Enter with:
;   DX = serial port base address
;Return:
;   AX = current baud rate divisor

                cli                             ;Disable interrupts
                add     dl, LINE_CONTROL
                in      al, dx
                push    ax                      ;Save original LINE CONTROL
                recover
                or      al, 80H
                out     dx, al                  ;Set DLAB
                sub     dl, 2
                in      al, dx                  ;Grab high byte of divisor
                mov     bh, al
                recover
                dec     dx
                in      al, dx                  ;Grab low byte of divisor
                mov     bl, al
                recover
                add     dl, 3                   ;Point back to LINE CONTROL
                pop     ax                      ;Restore original LINE CONTROL
                and     al, 7FH                 ;Mask off DLAB just in case
                out     dx, al                  ;Reset DLAB
                mov     ax, bx
                sti                             ;Re-enable interrupts
                ret

GetBaudRate     ENDP

GetByte             PROC    NEAR

;* Inputs:
;*      DX = port base address
;* Returns:
;*      JC = no byte available on port
;*      AL = byte received if no carry
;* Uses:
;*      NONE

                add     dl, LINE_STATUS
                in      al, dx
                sub     dl, LINE_STATUS
                test    al, 1
                jz      fail

                in      al, dx
                clc
                ret

fail:           stc
                ret

GetByte             ENDP

SendByte            PROC    NEAR    USES BX

;* Enter with:
;*      AL = byte to send
;*      DX = port base address
;* Returns:
;*      JC = byte could not be sent
;*      JNC= byte sent
;* Uses:
;*      NONE
                
                mov     bl, al
                add     dl, LINE_STATUS
                in      al, dx
                sub     dl, LINE_STATUS
                test    al, 20H
                jz      fail

                mov     al, bl
                out     dx, al
                clc
                ret

fail:           stc
                ret

SendByte            ENDP


SerialListenInit    PROC    NEAR    USES CX SI

;* Enter with:
;*      BX = port vector index
;* Uses:
;*      AX

                mov     fx_listen_vector[bx], OFFSET SerialListenInit
                call    GetPortIndex                    ; index si to FxPortInfo
                test    FxPortInfo[si].FxPortInfoDef.pi_flags, BAD_PORT
                jnz     return

                mov     dx, FxPortInfo[si].FxPortInfoDef.pi_address   ; get port base address
                call    InitPort                        ; initialize port, set baud rate
                mov     word ptr ShowBaud, OFFSET far_null_proc
                mov     word ptr ShowBaud[2], cs
                mov     cs:is_serial, 0
                test    FxPortInfo[si].FxPortInfoDef.pi_flags, BAD_PORT
                jnz     return

                mov     fx_listen_vector[bx], OFFSET ListenGetAA

return:         stc
                ret

SerialListenInit    ENDP


ListenGetAA         PROC    NEAR
            
;* Enter with:
;*      DX = port base address
;*      BX = port vector index
;* Uses:
;*      AX
;* Performs:    Waits to receive AA.  If AA is received, sets vector to Send00.

                call    GetByte
                jc      fail
                               
                cmp     al, 0AAH
                jne     fail


next_state:     call    ResetListenTime
                mov     fx_listen_vector[bx], OFFSET ListenSend00

fail:           stc
                ret

ListenGetAA         ENDP


ListenSend00        PROC    NEAR

;* Enter with:
;*      DX = port base address
;*      BX = port vector index
;* Uses:
;*      AX
;* Performs:    Sends 00.  Sets vector to Get55.

                xor     al, al
                call    SendByte
                jc      fail

                call    ResetListenTime
                mov     fx_listen_vector[bx], OFFSET ListenGet55

fail:           stc
                ret

ListenSend00        ENDP


ListenGet55         PROC    NEAR

;* Enter with:
;*      DX = port base address
;*      BX = port vector index
;* Uses:
;*      AX
;* Performs:    Waits to receive 55.  If 55 is received, sets vector to SendFF.

                call    GetByte
                jc      fail

                cmp     al, 055H
                jne     fail


next_state:     call    ResetListenTime
                mov     fx_listen_vector[bx], OFFSET ListenSendFF

fail:           stc
                ret

ListenGet55         ENDP


ListenSendFF        PROC    NEAR

;* Enter with:
;*      DX = port base address
;*      BX = port vector index
;* Uses:
;*      AX
;* Performs:    Sends 00.  Sets vector to Get5A.

                mov     al, 0FFH
                call    SendByte
                jc      fail

                mov     fx_listen_vector[bx], OFFSET ListenGet5A

fail:           stc
                ret

ListenSendFF        ENDP


ListenGet5A         PROC    NEAR

;* Enter with:
;*      DX = port base address
;*      BX = port vector index
;* Uses:
;*      AX
;* Performs:    Waits to receive 5A.  If 5A is received, sets vector to Send11.

                call    GetByte
                jc      fail

                cmp     al, 05AH
                jne     fail


next_state:     call    ResetListenTime
                mov     fx_listen_vector[bx], OFFSET ListenSend11

fail:           stc
                ret

ListenGet5A         ENDP


ListenSend11        PROC    NEAR

;* Enter with:
;*      DX = port base address
;*      BX = port vector index
;* Uses:
;*      AX
;* Performs:    Sends 11.  Resets vector to SerialListenInit on success.

                mov     al, 011H
                call    SendByte
                jc      fail

                mov     fx_listen_vector[bx], OFFSET SerialListenInit
                mov     al, FxSettings.FxSettingsDef.fxs_max_serial_baud
                mov     fx_max_serial_baud, al
                mov     ax, FxSettings.FxSettingsDef.fxs_max_serial_block
                mov     fx_max_serial_block, ax   ; start at maximum block size
                mov     first_send, 1
                mov     server, 1           ; listen means I'm the server
                mov     client, 0
                mov     need_send_echo, 0
                mov     fx_send_variable, 0
                mov     fx_recv_variable, 0
                mov     fx_errno, 0
                mov     cs:is_serial, 1
                call    check_windows
                clc
                ret

fail:           stc
                ret

ListenSend11        ENDP


modify_code     PROC    NEAR

; Destroys NOTHING

                push    ax
                push    bx
                push    di
                push    si

                cmp     cs:timeout, 0
                jne     fixup_return

                mov     cs:timeout, 1
                mov     si, OFFSET sbs1
                mov     ax, 0EBH OR ((OFFSET send_byte_fail - (OFFSET sbs1 + 2)) SHL 8)
                xchg    ax, cs:[si]
                mov     cs:code_save[0], ax
                mov     si, OFFSET rbs1
                mov     ax, 0EBH OR ((OFFSET recv_byte_fail - (OFFSET rbs1 + 2)) SHL 8)
                xchg    ax, cs:[si]
                mov     cs:code_save[2], ax
                mov     di, cs:code_list_ptr
                xor     bx, bx

save_code_loop: mov     si, cs:[di + bx + 2]
                or      si, si
                jz      fixup_return

                mov     ax, cs:[di]     ; Get vector to fail address
                sub     ax, si          ; Get forward jump delta to AX
                sub     ax, 2           ; Adjust size of short jump
                cmp     ax, 127
                jbe     in_range

                mov     ax, cs:[di + bx + 4]    ; Grab following jump address
                sub     ax, si
                sub     ax, 2

in_range:       mov     ah, al
                mov     al, 0EBH        ; Jump short directly to fail location.
                xchg    ax, cs:[si]
                mov     cs:code_save[bx + 4], ax
                add     bx, 2
                jmp     save_code_loop

fixup_return:   pop     si
                pop     di
                pop     bx
                pop     ax
                ret

modify_code     ENDP


; clear_alarm_ser -- Reset the timer interrupt handler to timer_passthru
;
; Destroys registers: None, FLAGS ARE PRESERVED ALSO
;
clear_alarm_ser PROC    NEAR

                pushf
;###            mov     WORD PTR cs:timer_handler, 0EBH OR ((OFFSET timer_passthru - (OFFSET timer_handler + 2)) SHL 8)
                mov     WORD PTR cs:timer_handler, 0EBH OR (3AH SHL 8)
.ERRE (OFFSET timer_passthru - (OFFSET timer_handler + 2)) EQ 3AH
                push    ax              ; Preserve Register
                push    cx

                cmp     polite_timer, 0
                jne     cascade_done

                mov     al, interrupt_mask
                out     21H, al
                mov     cx, cs:lost_ticks
                jcxz    cascade_done

                cli

ca_cascade:     pushf                   ; make up lost timer ticks
                call    cs:timer_save
                loop    ca_cascade

                sti
                mov     cs:lost_ticks, 0

cascade_done:   cmp     cs:timeout, 0
                je      clear_done

                push    bx
                push    di
                push    si
                mov     si, OFFSET sbs1
                mov     ax, cs:code_save[0]
                mov     cs:[si], ax
                mov     si, OFFSET rbs1
                mov     ax, cs:code_save[2]
                mov     cs:[si], ax
                mov     di, cs:code_list_ptr
                xor     bx, bx

restore_code:   mov     si, cs:[di + bx + 2]
                or      si, si
                jz      restore_done

                mov     ax, cs:code_save[bx + 4]
                mov     cs:[si], ax
                add     bx, 2
                jmp     restore_code

restore_done:   pop     si
                pop     di
                pop     bx

clear_done:     pop     cx
                pop     ax
                popf
                ret

clear_alarm_ser ENDP


; set_alarm_ser -- Starts the alarm counting down ticks.
;
; Destroys registers: None
;
; set_alarm_ser changes the timer interrupt vector from timer_passthru to
; timer_handler_ser.  Before calling this routine alarm_vector should be set 
; to the offset of the timeout code and ticks_remaining should be set to the 
; number of ticks before a timeout should occur.  Since the granularity of the 
; alarm is  1 tick, ticks_remaining should always be set to 2 or more (if set 
; to 1, a timeout could occur immediately after the return from this routine).
;
set_alarm_ser   PROC    NEAR

; Destroys NOTHING

                push    ax
                mov     cs:timeout, 0
                mov     cs:lost_ticks, 0    ; Clear the lost ticks count
                mov     al, win386_enh_mode ; Always polite if Windows 386 Enh
                or      al, hp_95lx         ; Always polite if HP 95LX
                or      al, fx_force_variable   ; Always polite if forced variable
                or      polite_timer, al
                cmp     polite_timer, 0
                jnz     set_polite

                cmp     fx_baud, BAUD_9600
                ja      mask_ints

                mov     polite_timer, 1 ; 9600 baud or slower - always polite
                jmp     short set_polite

mask_ints:      in      al, 21H         ; Get current interrupt mask
                mov     interrupt_mask, al

                mov     al, INT_MASK    ; Set our interrupt mask
                out     21H, al

                mov     WORD PTR cs:timer_handler, 0B050H   ; <=== modifies instruction
                jmp     short set_alarm_ret

set_polite:     call    GetTicks
                mov     cs:set_alarm_time, ax
                mov     WORD PTR cs:timer_handler, 0EBH OR (16H SHL 8)
.ERRE (OFFSET polite_handler - (OFFSET timer_handler + 2)) EQ 16H

set_alarm_ret:  pop     ax
                ret

set_alarm_ser   ENDP

; send_byte_ser Send byte on serial port.
;               Updates CRC (doesn't support checksum)
;
; The timeout routines must already be executing before this routine is called.
;
; Inputs:
;   ax      Current CRC
;   bl      Byte to be sent
;   dx      Base I/O port
;
; Outputs:
;   ax      Updated CRC
;
;   If control returns inline, the character has been sent.  The only other
;   way out of this routine is through a timeout.

send_byte_fail  LABEL   NEAR

                pop     ax              ; restore stack frame
                sub     dl, LINE_STATUS ; Point back to data output register
                add     sp, 2           ; Pop off the return address
                jmp     WORD PTR cs:alarm_vector

send_byte_ser   PROC    NEAR

                push    ax              ; preserve current CRC
                add     dl, LINE_STATUS ; set dx to status port

@@:             in      al, dx          ; Wait for transmitter holding to empty
                test    al, 20H
sbs1::          jz      @B

                sub     dl, LINE_STATUS ; Point back to data output register
                mov     al, bl          ; Get the byte to output.
                out     dx, al          ; and output it.

                pop     ax              ; restore current CRC value
                push    bx
                xchg    ah, al
                xor     al, bl
                xor     bx, bx
                xchg    bl, al
                shl     bx, 1
                xor     ax, __crctab[bx]
                pop     bx
                ret

send_byte_ser   ENDP

send_byte_echo  PROC    NEAR

                cmp     fx_send_variable, 0
                je      send_byte_ser

                pop     echo_ret            ; Pop off return address
                mov     echo_byte, bl
                call    send_byte_ser
                mov     ax_save, ax

wait_echo:      call    bp
                cmp     bl, echo_byte
                jne     wait_echo

                mov     ax, ax_save
                jmp     echo_ret

send_byte_echo  ENDP

recv_byte_echo  PROC    NEAR

                pop     echo_ret
                call    bp
                push    ax
                mov     al, bl
                call    SendByte
                pop     ax
                jmp     echo_ret

recv_byte_echo  ENDP

drain           PROC    NEAR

                push    ax
@@:             add     dl, LINE_STATUS
                in      al, dx
                sub     dl, LINE_STATUS
                test    al, 1
                jz      empty

                in      al, dx
                jmp     @b

empty:          pop     ax
                ret

drain           ENDP

; recv_byte_ser Get a byte from serial port.  Updates CRC
;
;   NOTE:   This does not support CheckSum and is only used in 3 wire mode.
;
; The timeout routines must already be executing before this routine is called.
;
; Inputs:
;   ax      Current CRC
;   dx      Base I/O port
;
; Outputs:
;   ax      Updated CRC
;   bl      Read character (May be garbled if an error occured)
;
;   If control returns in line, the character was successfully read
;

recv_byte_fail  LABEL   NEAR

                sub     dl, LINE_STATUS ; Point DX back where it started
                add     sp, 2           ; Pop off return address from stack
                jmp     WORD PTR cs:alarm_vector

recv_byte_ser   PROC    NEAR

                mov     bl, al          ; Save AL in BL

next_byte:      add     dl, LINE_STATUS

@@:             in      al, dx          ; Wait for received data ready
                shr     al, 1
rbs1::          jnc     @b

                sub     dl, LINE_STATUS
                test    al, ((FRAMING_ERROR OR PARITY_ERROR OR OVERRUN_ERROR) SHR 1)
                jnz     record_error    ; Record error

rb_grab::       in      al, dx          ; grab the character

                xchg    bl, al          ; return byte recvd in bl, restore CRC
                push    bx
                xchg    ah, al
                xor     al, bl
                xor     bx, bx
                xchg    bl, al
                shl     bx, 1
                xor     ax, __crctab[bx]
                pop     bx
                ret

record_error:   mov     recv_byte_error, al
                in      al, dx
                jmp     next_byte

recv_byte_ser   ENDP

recv_byte_win   PROC    NEAR

                mov     bl, al          ; Save AL in BL

recv_next:      add     dl, LINE_STATUS 

recv_look:      in      al, dx          ; Wait for transmitter holding to empty
                shr     al, 1           ; Data Ready?
                jnc     recv_chek_time

                sub     dl, LINE_STATUS
                test    al, ((FRAMING_ERROR OR PARITY_ERROR OR OVERRUN_ERROR) SHR 1)
                jz      rb_grab         ; ====> Jump to code in above PROC

                mov     recv_byte_error, al
                in      al, dx          ; Throw away possible garbage character
                jmp     recv_next

recv_chek_time: push    ax
                call    GetTicks
                sub     ax, cs:set_alarm_time
                cmp     ax, cs:ticks_remaining
                pop     ax
                jl      recv_look

                jmp     recv_byte_fail

recv_byte_win   ENDP

send_baud_rate  PROC    NEAR  USES BX CX DI
;   Inputs:
;       cl          desired baud rate index
;   Outputs:        JC: Set baud attempt failed, fx_errno = -4
;                   JNC: Baud rate changed

                mov     al, fx_baud
                mov     prior_baud, al

                mov     bl, seq_num
                not     bl
                DBG     '{'
                call    send_sync_ser
                jc      sync_fail

                DBG     '}'
                mov     cs:alarm_vector, OFFSET request_fail
                mov     cs:code_list_ptr, OFFSET null_code_list
                mov     cs:ticks_remaining, MINIMUM_TICKS
                mov     polite_timer, 1
                call    set_alarm_ser

                mov     bl, cl
                call    send_byte_ser       ; send back desired baud

                mov     al, bl
                call    clear_alarm_ser
                call    SetBaud
                jc      request_fail

                mov     cs:alarm_vector, OFFSET change_fail
                mov     cs:ticks_remaining, 2 * MINIMUM_TICKS
                mov     polite_timer, 1
                call    set_alarm_ser

                mov     ch, cl              ; save baud rate in ch
                shl     cl, 1               ; shift baud rate to high nibble
                shl     cl, 1
                shl     cl, 1
                shl     cl, 1
                or      cl, seq_num         ; put seq_num in low nibble

get_ack:        call    bp                  ; get new baud 
                cmp     bl, cl
                jne     get_ack

                mov     baud_list1[0], cl
                not     cl
                mov     baud_list2[0], cl
                xor     di, di

sbr_send_loop:  mov     bl, baud_list1[di]
                call    send_byte_ser       ; send new baud rate again
sbr_recv_loop:  call    bp
                cmp     bl, baud_list2[di]
                jne     sbr_recv_loop

                inc     di
                cmp     di, BAUD_LIST_SIZE
                jb      sbr_send_loop

return_ok:      call    clear_alarm_ser
                mov     fx_errno, 0
                clc
                ret

sync_fail:      mov     fx_errno, ax
                ret

request_fail:   call    clear_alarm_ser
                DBG     '*'
                mov     fx_errno, -4
                xor     ax, ax
                stc
                ret

change_fail:    call    clear_alarm_ser
                cmp     ch, prior_baud
                jb      request_fail        ; change error on step down is fatal
                
                DBG     '#'
                mov     al, prior_baud
                mov     fx_max_serial_baud, al
                call    SetBaud
                jc      request_fail

                jmp     return_ok

time_out:       xor     ax, ax
                mov     fx_errno, 4
                stc
                ret

send_baud_rate  ENDP

goto_max_baud   PROC    NEAR
                
                cmp     first_send, 1
                jne     goto_max_ret

                push    cx
                mov     cl, fx_baud

max_loop:       cmp     cl, fx_max_serial_baud
                je      done                ; done if at max already

                jb      advance

                mov     cl, fx_max_serial_baud
                jmp     short change_rate

advance:        inc     cl
                DBG     ''

change_rate:    call    send_baud_rate
                mov     cl, fx_baud         ; Get actual new baud rate
                jnc     max_loop

done:           pop     cx
                mov     first_send, 0

goto_max_ret:   ret

goto_max_baud   ENDP

SendSerial      PROC    NEAR
;   Inputs:
;       cx          Length of buffer to be sent
;       es:si       Pointer to buffer to be sent
;
;   Uses:   ax, bx, cx, si

                mov     bl, fx_error_checking_mode
                mov     dx, serial_port     ; set up port in DX
                mov     send_remaining, cx
                call    setup_recv_byte
                call    goto_max_baud       ; connected with connect, crank baud

next_block:     mov     cx, send_remaining
                jcxz    split

                cmp     cx, fx_max_serial_block     ; see if packet > block size
                jbe     no_split

split:          or      bl, CONTINUED_PACKET        ; indicate packet to follow
                mov     cx, fx_max_serial_block
                jmp     short send_it

no_split:       and     bl, NOT CONTINUED_PACKET

send_it:        and     bl, NOT ECHOPLEX    ; setup echoplex flag
                or      bl, need_send_echo
                call    SendSerialBlock     ; attempt transmission
                cmp     fx_errno, -1        ; check for failure
                jl      packet_fail

                cmp     fx_errno, 0
                jne     send_ser_ret

                test    bl, CONTINUED_PACKET
                jz      send_ser_ret

                mov     ax, fx_max_serial_block
                sub     send_remaining, ax
                add     si, ax
                mov     send_fails, 0
                jmp     next_block     ; send the rest

packet_fail:    cmp     fx_send_variable, 0 ; first recourse on failure is to
                jne     @F                  ; send echo_plex

                mov     send_fails, 0
                mov     need_send_echo, ECHOPLEX
                mov     fx_send_variable, ECHOPLEX
                call    NearShowBaud
                jmp     next_block                  ; Try again in echoplex


@@:             inc     send_fails
                cmp     send_fails, MAX_SEND_FAILS
                jb      next_block

                mov     cl, fx_baud
                cmp     cl, CONNECT_BAUD
                ja      shift_down

                mov     fx_errno, -1
                mov     fx_port, -1
                xor     ax, ax
                jmp     send_ser_ret

shift_down:     dec     cl                  ; drop down one baud rate
                DBG     ''
                call    send_baud_rate
                jc      send_ser_ret

                mov     send_fails, 0
                mov     fx_send_variable, 0
                mov     need_send_echo, 0
                call    NearShowBaud
                jmp     next_block          ; try again

send_ser_ret:   ret
                
SendSerial      ENDP

NearShowBaud    PROC    NEAR USES ES AX BX CX DX

                call    dword ptr ShowBaud          ; call to user's ShowBaud
                ret

NearShowBaud    ENDP

send_sync_ser   PROC    NEAR    USES BP BX CX
;   Inputs:     
;            BL  synchronization byte, status flags w/ sequence number
;            DX  serial port base address
;   Returns: JC  sync failure
;            fx_send_variable set to receiver's request
;   Uses:
;           AX

                call    SyncStart
                mov     cx, ax              ; Save original tick count in CX
                cmp     last_operation, RECV_OPERATION
                jne     sent_last

                mov     bp, OFFSET wait_turn

wait_turn:      call    GetByte
                jc      check_abort

                HEX     al
                DBG     ','
                cmp     al, seq_num
                jne     check_abort

                mov     last_operation, SEND_OPERATION

sent_last:      mov     bp, OFFSET send_sync
                call    drain               ; Drain away any leftover bytes

send_sync:      mov     al, bl              ; get synchronization byte
                call    SendByte
                jc      check_abort

                HEX     al
                DBG     '|'
                not     bl                  ; sync_ans is inverse of sync
                and     bl, NOT ECHOPLEX
                mov     bp, OFFSET get_ans

get_ans:        call    GetByte
                jc      check_abort

                HEX     al
                mov     bh, al
                and     bh, ECHOPLEX
                and     al, NOT ECHOPLEX
                cmp     al, bl
                jne     check_abort

                cmp     bh, fx_send_variable
                je      @F

                mov     fx_send_variable, bh
                call    NearShowBaud

@@:             clc                         ; carry clear on success
                jmp     short return

check_abort:    call    GetTicks
                sub     ax, cx
                cmp     ax, SyncTimeout
                ja      time_out

                call    CheckAbort
                jc      error_exit

                jmp     bp

time_out:       mov     ax, FX_ERR_TIMEOUT

error_exit:     mov     fx_errno, ax

                xor     ax, ax
                stc

return:         call    SyncDone
                ret

send_sync_ser   ENDP

; SendSerialBlock
;   Inputs:
;       bl          Will have status bits for sync exchange set
;       cx          Length of buffer to be sent
;       es:si       Pointer to buffer to be sent
SendSerialBlock PROC    NEAR   USES BX SI

                DBG     ''
                or      ch, ch              ; see if length fits in byte
                jnz     word_length         ; clear bit if not
                
                or      bl, BYTE_LENGTH     ; set byte length bit
                jmp     short byte_length

word_length:    and     bl, NOT BYTE_LENGTH ; clear byte length bit

byte_length:    or      bl, seq_num         ; add sequence to status bits
                mov     packet_ok, bl       ; packet_ok is original sync
                DBG     '['
                call    send_sync_ser
                jc      ssb_sync_fail
                           
                DBG     ']'
                push    bx
                xor     bx, bx              ; zero al and or in send states
                or      bl, fx_send_variable
                or      bl, fx_serial_7_wire
                or      bl, fx_error_checking_mode
                shr     bl, 1               ; convert to table vector
                mov     ax, send_table[bx]
                pop     bx
                call    ax
                jc      ssb_fail

                inc     seq_num
                and     seq_num, SEQUENCE_BITS
                mov     ax, 1
                mov     fx_errno, 0

ssb_return:     ret

ssb_sync_fail:  DBG     '*'
                jmp     ssb_return

ssb_fail:       mov     fx_errno, FX_ERR_FAIL
                xor     ax, ax
                jmp     ssb_return

SendSerialBlock ENDP

send_3_echo     PROC    NEAR

;*  USES:   AX, BX, CX, SI

                DBG     '{'
                DBG     '3'
                DBG     'E'
                mov     cs:alarm_vector, OFFSET sp_fail
                mov     cs:ticks_remaining, 2 * MINIMUM_TICKS
                mov     cs:code_list_ptr, OFFSET null_code_list
                mov     polite_timer, 1
                call    set_alarm_ser

                mov     ax, INITIAL_CRC     ; start CRC calculations in AX
                mov     bl, cl              ; send length (LSB)
                call    send_byte_echo

                or      ch, ch              ; see if length was < 256
                jz      send_data

                mov     bl, ch              ; send length (MSB)
                call    send_byte_echo

send_data:      mov     cs:ticks_remaining, 2 * MINIMUM_TICKS
                mov     bl, es:[si]
                inc     si
                call    send_byte_echo
                loop    send_data

                DBG     '}'
                mov     bx, ax              ; get CRC
                not     bx
                mov     cs:ticks_remaining, 2 * MINIMUM_TICKS
                xchg    bl, bh              ; send high byte
                call    send_byte_echo
                mov     bl, bh              ; send low byte
                call    send_byte_ser

                mov     cs:ticks_remaining, 2 * MINIMUM_TICKS
                call    bp
                cmp     bl, packet_ok
                je      send_3_ok

                DBG     '@'
                HEX     bl

sp_fail:        stc
                DBG     '#'       
                jmp     short return

send_3_ok:      clc

return:         call    clear_alarm_ser
                ret

send_3_echo     ENDP

send_3_norm     PROC    NEAR

;*  USES:   AX, BX, CX, SI

                DBG     '{'
                DBG     '3'
                DBG     'N'
                DBG     '('
                HEX     ch
                HEX     cl
                DBG     ')'
                mov     cs:alarm_vector, OFFSET sp_fail
                mov     cs:ticks_remaining, 2 * MINIMUM_TICKS
                mov     cs:code_list_ptr, OFFSET null_code_list
                mov     polite_timer, 1
                call    set_alarm_ser

                mov     ax, INITIAL_CRC     ; start CRC calculations in AX
                mov     bl, cl              ; send length (LSB)
                call    send_byte_ser

                or      ch, ch              ; see if length was < 256
                jz      send_data_loop

                mov     bl, ch              ; send length (MSB)
                call    send_byte_ser

send_data_loop: mov     cs:ticks_remaining, 2 * MINIMUM_TICKS
                mov     bl, es:[si]
                inc     si
                call    send_byte_ser
                loop    send_data_loop

                DBG     '}'
                mov     cs:ticks_remaining, 2 * MINIMUM_TICKS
                mov     bx, ax              ; get CRC
                not     bx
                xchg    bl, bh              ; send high byte
                call    send_byte_ser
                mov     bl, bh              ; send low byte
                call    send_byte_ser

                mov     cs:ticks_remaining, 2 * MINIMUM_TICKS
                call    bp
                cmp     bl, packet_ok
                jne     sp_fail

                clc

return:         call    clear_alarm_ser
                ret

sp_fail:        stc
                DBG     '#'       
                DBG     '('
                HEX     ch
                HEX     cl
                DBG     ')'
                jmp     short return

send_3_norm     ENDP

recv_baud_rate  PROC    NEAR USES BX CX DI SI BP

                call    drain
                mov     cs:alarm_vector, OFFSET request_fail
                mov     cs:code_list_ptr, OFFSET null_code_list
                mov     cs:ticks_remaining, MINIMUM_TICKS
                mov     polite_timer, 1
                call    set_alarm_ser

                HEX     bl
                DBG     ']'
                call    send_byte_ser       ; send inverse of received byte
                DBG     '<'
                call    bp                  ; expect back desired baud
                HEX     bl
                call    clear_alarm_ser
                cmp     bl, fx_baud
                jb      recv_change         ; Going down - don't look at max

                cmp     bl, fx_max_serial_baud
                ja      request_ok          ; Don't go above max_baud

recv_change:    DBG     '>'
                mov     al, bl
                mov     bl, fx_baud
                mov     prior_baud, bl
                call    SetBaud
                jc      fatal_fail

                mov     bh, fx_baud
                mov     cl, 4
                shl     bh, cl
                or      bh, seq_num

                mov     al, bh
                not     al
                mov     baud_list2[0], al
                xor     di, di

rbr_save_time:  call    GetTicks
                mov     cx, ax              ; Save original tick count in CX
                mov     si, ax              ; and a copy in SI

send_loop1:     mov     bp, OFFSET send_loop1
                mov     al, bh
                call    SendByte
                jc      check_time

                call    GetTicks
                mov     si, ax
                mov     bp, OFFSET get_byte_loop

get_byte_loop:  call    GetByte
                jnc     got_byte

                call    GetTicks
                push    ax
                sub     ax, si
                pop     si
                jnz     send_loop1

                jmp     short check_time

got_byte:       cmp     al, bh
                jne     check_time

send_loop:      mov     bp, OFFSET send_loop
                mov     al, baud_list2[di]
                call    SendByte
                jc      check_time

                mov     bp, OFFSET recv_loop
                inc     di
                cmp     di, BAUD_LIST_SIZE
                jae     request_ok

recv_loop:      call    GetByte
                jc      check_time

                cmp     al, baud_list1[di]
                je      send_loop

check_time:     call    GetTicks
                sub     ax, cx
                cmp     ax, MINIMUM_TICKS
                ja      change_fail

                jmp     bp

request_fail:   call    clear_alarm_ser
request_ok:     clc                         ; assume false request, stay in 
                ret                         ; sync loop

change_fail:    mov     al, prior_baud
                DBG     '#'
                cmp     al, fx_baud
                jae     fatal_fail          ; change error on step down is fatal

                mov     fx_max_serial_baud, al
                call    SetBaud
                jnc     request_ok

fatal_fail:     mov     ax, 4
                DBG     '~'
                stc
                ret

recv_baud_rate  ENDP

RecvSerial      PROC    NEAR    USES BP
;   Inputs:
;       cx          Length of buffer to be received
;    es:di          Pointer to buffer to be received

                call    setup_recv_byte
                xor     bx, bx              ; count received

next_block:     push    cx                  ; preserve length remaining
                push    di                  ; preserve buffer pointer
                push    bx                  ; preserve current count
                call    RecvSerialBlock
                jc      recv_error

                test    bl, CONTINUED_PACKET; see if split block received
                jz      return              ; if not we're done

                pop     bx                  ; get prior length
                add     bx, ax              ; add received length
                pop     di                  ; restore buffer pointer
                pop     cx                  ; restore length remaining
                sub     cx, ax              ; subtract received length
                add     di, ax              ; move up buffer pointer
                jmp     next_block

recv_error:     cmp     fx_errno, -1        ; no retry if we didn't sync
                je      return_error

                cmp     fx_errno, 0
                jg      return_error

                pop     bx
                pop     di
                pop     cx
                jmp     next_block          ; try again

return:         pop     bx                  ; get prior length
                add     bx, ax              ; add received length
                pop     di
                pop     cx
                mov     ax, bx
                jmp     short rs_ret

return_error:   pop     bx
                pop     di
                pop     cx
                xor     ax, ax              ; return 0 for error

rs_ret:         ret

RecvSerial      ENDP

recv_sync_ser   PROC    NEAR    USES CX
;   Inputs:
;           DX  serial port base address
;   Returns:
;           BL  sync byte received
;   Uses:
;           NONE

                push    bp
                call    SyncStart           ; Returns current tick count in AX
                mov     cx, ax              ; Save original tick count in CX
                DBG     '['

                cmp     last_operation, SEND_OPERATION
                jne     recvd_last

                mov     al, seq_num
                mov     bp, OFFSET send_seq

send_seq:       call    SendByte
                jc      check_abort

                HEX     al
                DBG     ','
                mov     last_operation, RECV_OPERATION

recvd_last:     mov     bp, OFFSET wait_sync

wait_sync:      call    GetByte
                jc      check_abort

                mov     ah, seq_num
                xor     ah, 1               ; Toggle low order sequence bit
                or      ah, IDLE_BITS
                cmp     al, ah
                jne     not_idle

                mov     bp, OFFSET send_idle

send_idle:      call    SendByte            ; Echo back what we received
                jc      check_abort

recv_restart:   call    GetTicks
                mov     cx, ax
                mov     bp, OFFSET wait_sync
                jmp     short check_abort

not_idle:       HEX     al
                DBG     '|'
                mov     bl, al
                and     al, SEQUENCE_BITS   ; check for sequence
                cmp     al, seq_num
                je      send_reply

                not     al                  ; check for inverse of sequence
                and     al, SEQUENCE_BITS
                cmp     al, seq_num
                jne     check_abort

                not     bl
                pop     bp
                call    recv_baud_rate
                push    bp
                jc      error_exit

                jmp     recv_restart

send_reply:     call    drain
                mov     packet_ok, bl
                clc                         ; carry clear on success
                jmp     short return

check_abort:    call    GetTicks
                sub     ax, cx
                cmp     ax, SyncTimeout
                ja      time_out

                call    CheckAbort
                jc      error_exit

                jmp     bp

time_out:       mov     ax, FX_ERR_TIMEOUT
                DBG     '$'

error_exit:     mov     fx_errno, ax
                xor     ax, ax
                stc

return:         call    SyncDone
                pop     bp
                ret

recv_sync_ser   ENDP

; recv_pack_ser     Recieve a packet
;   Inputs:
;       es:di       pointer to buffer
;       cx          max size of buffer
;
;   Outputs:
;       bl          sync byte received
;       CF          Set if packet recieved
;                   Clear if timeout or some other error
;       cx          If no error, number of bytes recieved.  Otherwise, unknown.
;
;   Uses registers: ax bx cx dx si di bp
;
; Slave definition:
;   Inputs:
;       buffer      Far pointer to buffer for data
;       count       size of buffer
;
;   Globals:
;       serial_port base register of port to use
;
;   Returns:
;       integer     number of bytes recieved
;                   zero if some error occured
;
; extern unsigned int recv_pack_ser(void far *buffer, unsigned int count);
;
RecvSerialBlock      PROC    NEAR USES si di

                DBG     ''
                mov     recv_buff_ptr, di   ; Save original buff ptr
                mov     fx_errno, 0
                mov     dx, serial_port
                call    recv_sync_ser
                jc      rp_ret              ; Return with carry set for error

                xor     al, al              ; al to be mode change indicator
                mov     ah, bl
                and     ah, ECHOPLEX        ; isolate echoplex bit
                cmp     fx_force_variable, 0
                jne     force_echoplex

                cmp     win386_enh_mode, 0
                jne     force_echoplex      ; Force echoplex if 386 Enhanced Mode

                cmp     hp_95lx, 0          ; Force echoplex if on HP 95LX
                je      @F

force_echoplex: or      ah, ECHOPLEX

@@:             cmp     ah, fx_recv_variable   
                je      @F                     
                                               
                mov     fx_recv_variable, ah
                inc     ax

@@:             cmp     al, 0
                je      dispatch

                call    NearShowBaud

dispatch:       mov     recv_byte_error, 0
                push    bx
                xor     bx, bx
                or      bl, fx_serial_7_wire
                or      bl, fx_recv_variable
                or      bl, fx_error_checking_mode
                shr     bl, 1
                mov     ax, recv_table[bx]
                pop     bx
                call    ax

rp_ret:         ret

RecvSerialBlock      ENDP

recv_3_norm     PROC    NEAR

;*  INPUTS:
;*          BL = sync byte received from sender.
;*          CX = receive buffer length.
;*          DX = serial port.
;*          BP = recv_byte_ser or recv_byte_win.
;*       ES:DI = pointer to receive buffer.
;*  OUTPUTS:
;*          AX = length received.
;*          BL = sync byte received from sender.
;*
;*  USES:   BH

                mov     cs:alarm_vector, OFFSET r3n_fail
                mov     cs:ticks_remaining, MINIMUM_TICKS
                mov     cs:code_list_ptr, OFFSET null_code_list
                mov     polite_timer, 0
                call    set_alarm_ser
                mov     si, bx          ; Save sync flags in low byte of SI
                not     bl              ; Complement what we got in recv_sync
                and     bl, NOT ECHOPLEX
                xor     bh, bh          ; zero high byte of length
                HEX     bl
                DBG     ']'
                call    send_byte_ser   ; Send back reply
                mov     ax, INITIAL_CRC ; start CRC calculation
                call    bp              ; Length (LSB)
                test    si, BYTE_LENGTH ; Is length only 1 byte?
                jnz     skip_len_byte

                mov     bh, bl          ; save LSB in bh
                call    bp              ; Length (MSB)
                xchg    bh, bl          ; flip bytes to correct order

skip_len_byte:  dec     bx
                dec     cx
                cmp     bx, cx          ; See if packet is to big for buffer
                jbe     @F

                call    dump_block

@@:             inc     bx
                mov     cx, bx          ; Count to CX
                DBG     '{'
                DBG     '3'
                DBG     'N'

read_data_loop: call    bp
                mov     cs:ticks_remaining, MINIMUM_TICKS
                mov     es:[di], bl
                inc     di
                loop    read_data_loop

                DBG     '}'
                call    bp              ; recv CRC bytes
                call    bp
                cmp     recv_byte_error, 0
                je      check_crc

                DBG     '%'
                call    dump_block

check_crc:      cmp     ax, MAGIC_CRC   ; Is it a match?
                je      send_ok

                DBG     '~' 
                call    dump_block

send_ok:        mov     bx, si          ; return sync byte received to sender
                mov     cs:ticks_remaining, MINIMUM_TICKS
                call    send_byte_ser

                call    clear_alarm_ser
                inc     seq_num
                and     seq_num, 3
                mov     ax, di
                sub     ax, recv_buff_ptr
                mov     fx_errno, 0
                clc

rp_ret:         mov     bx, si          ; return split flag for RecvSerial
                ret

r3n_fail:       call    clear_alarm_ser ; Clear alarm clock
                DBG     '#'
                mov     fx_errno, FX_ERR_FAIL
                xor     ax, ax
                stc
                jmp     rp_ret

recv_3_norm     ENDP

recv_3_echo     PROC    NEAR

                mov     cs:alarm_vector, OFFSET r3e_fail
                mov     cs:ticks_remaining, MINIMUM_TICKS
                mov     cs:code_list_ptr, OFFSET null_code_list
                mov     polite_timer, 1 ; Polite timer for echo mode!
                call    set_alarm_ser
                mov     si, bx
                not     bl
                or      bl, ECHOPLEX
                xor     bh, bh
                HEX     bl
                DBG     ']'
                call    send_byte_ser
                mov     ax, INITIAL_CRC ; start CRC calculation
                call    recv_byte_echo  ; Length (LSB)
                test    si, BYTE_LENGTH ; Is length only 1 byte?
                jnz     skip_len_byte

                mov     bh, bl          ; save LSB in bh
                call    recv_byte_echo  ; Length (MSB)
                xchg    bh, bl          ; flip bytes to correct order

skip_len_byte:  dec     bx
                dec     cx
                cmp     bx, cx
                jbe     @F

                call    dump_block

@@:             inc     bx
                mov     cx, bx          ; Count to CX
                DBG     '{'
                DBG     '3'
                DBG     'E'

read_data:      call    recv_byte_echo
                mov     cs:ticks_remaining, MINIMUM_TICKS
                mov     es:[di], bl
                inc     di
                loop    read_data

                DBG     '}'
                call    recv_byte_echo  ; recv CRC bytes
                call    bp
                cmp     recv_byte_error, 0
                je      check_crc

                DBG     '%'
                call    dump_block

check_crc:      cmp     ax, MAGIC_CRC   ; Is it a match?
                je      send_ok

                DBG     '~' 
                call    dump_block

send_ok:        mov     bx, si          ; return sync byte received to sender
                mov     cs:ticks_remaining, MINIMUM_TICKS
                call    send_byte_ser

                call    clear_alarm_ser
                inc     seq_num
                and     seq_num, SEQUENCE_BITS
                mov     ax, di
                sub     ax, recv_buff_ptr   ; Calculate # of received bytes
                mov     fx_errno, 0
                clc

rp_ret:         mov     bx, si          ; return split flag for RecvSerial
                ret

r3e_fail:       call    clear_alarm_ser ; Clear alarm clock
                DBG     '#'
                mov     fx_errno, FX_ERR_FAIL
                xor     ax, ax
                stc
                jmp     rp_ret

recv_3_echo     ENDP

dump_block      PROC    NEAR

;*  INPUTS:
;*          DX = serial port.
;*          BP = recv_byte_ser or recv_byte_win.
;*  NOTE:
;*          dump_block only returns to the fail vector.  Alarms must be set
;*          by the caller.
;*
;*  USES:   BL

                add     sp, 2           ; prepare stack for return via alarm

@@:             mov     cs:ticks_remaining, MINIMUM_TICKS
                call    bp
                jmp     @B

dump_block      ENDP


FxShowBaud      PROC    PASCAL USES ES, func:FAR PTR

                les     ax, func
                mov     word ptr ShowBaud, ax
                mov     word ptr ShowBaud[2], es
                ret

FxShowBaud      ENDP




setup_recv_byte PROC    NEAR

                mov     bp, OFFSET recv_byte_ser
                cmp     win386_enh_mode, 0
                je      setup_ret

                mov     bp, OFFSET recv_byte_win
                mov     fx_serial_7_wire, 0 ; disable seven wire in windows

setup_ret:      ret

setup_recv_byte ENDP


	            END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\fxlib\server.h ===
#define MAX_DOS_PATH    67

/*** Packet types. ***/

/*** 
* Packet types 0 - 127 are reserved for packets which may be supported
* by multiple developers.  These types must be assigned by Sewell Development.
* Packet types from 0 to MAX_REQUIRED_PACKET_TYPE must be
* supported by all servers.  Packet types from MAX_REQUIRED_PACKET_TYPE + 1 to
* Each developer will be assigned a range of 128 packet types for their
* private use.  Developers should not use private packet types outside of
* their assigned range.
*
* Packet types 128 - 255 are reserved for Sewell Development.
* Packet types 256 - 383 are reserved for Symantec.
***/

#define SERVER_INFO_REQ         0
#define FILE_XFER_REQ           1
#define CHDDIR_REQ              2
#define DDIR_INFO_REQ           3
#define DISK_FREE_REQ           4
#define DIRLIST_REQ             5
#define FILE_RECV_REQ           6
#define FCB_DELETE_REQ          7
#define FILE_DELETE_REQ         8
#define FILE_ATTRIB_REQ         9
#define RMDIR_REQ               10
#define RENAME_REQ              11
#define DISK_INFO_REQ           12
#define FILE_INFO_REQ           13
#define ECHO_REQ                14
#define MKDIR_REQ               15
#define MAX_REQUIRED_PACKET_TYPE    15
#define FILE_OPEN_REQ       122
#define FILE_READ_REQ       123
#define FILE_CLOSE_REQ      124
#define SERVER_EXIT_REQ     125
#define SET_TIMEOUT_REQ     126
#define SWITCH_REQ          127

#define MAX_COMMON_PACKET_TYPE  127

/*** Packet structures. ***/

/*** NOTE: os_type values must be assigned by Sewell Development. ***/
enum os_type {                  // Operating system type.
    OS_MSDOS   = 0,
    OS_OS2     = 1,
    OS_NETWARE = 2
};

/*** NOTE: developer values must be assigned by Sewell Development. ***/
enum developer {
    DEV_SEWELL   = 0,
    DEV_SYMANTEC = 1
};

struct capabilities {
    byte checksum;                  // TRUE if checksum supported/desired
    byte crc;                       // TRUE if CRC desired
    word max_serial_block;          // Maximum serial block size
    byte reserved[12];              // Reserved for expansion, should be zero.
};

/*** 
* NOTE: the product and version numbers in the structures below are for the
* private use of each developer.  In general, these numbers should be ignored
* unless the client and server program are by the same developer.
***/

struct server_info_req {
    enum os_type os_type;
    enum developer developer;
    word product;                       // Developer assigned product ID code.
    word version;                       // Developer assigned version number.
    byte device_driver;                 // TRUE if client is a device driver.
    byte want_packets_supported;        // TRUE if packets_supported info desired
    struct capabilities client_caps;    // Client capabilities
    long client_id;                     // 32-bit client ID
    long last_server_id;                // Last server ID received by client
};

struct server_info_ans {
    enum os_type os_type;
    enum developer developer;
    word product;                       // Developer assigned product ID code.
    word version;                       // Developer assigned version number.
    byte device_server;                 // TRUE if device server functions supported
    struct capabilities agreed_caps;    // Agreed upon capabilities
    long last_client_id;                // Last client ID received by server
    long server_id;                     // 32-bit server ID
    // NOTE: the packets_supported field should not be sent if the client
    // want_packets_supported is FALSE.  Also, if a server does not support
    // these functions (for example a minimal device driver server), it does
    // not need to return this field, even if it has been requested.
    // Therefore, the client should look at the packet length to see if this
    // field is present.
    byte packets_supported[MAX_COMMON_PACKET_TYPE + 1];
};

struct switch_ans {
    byte wants_client;      // TRUE if client/server switch desired by server
};                          // Server would normally return FALSE

#define XFER_CREATE_FILE  1
#define XFER_OPEN_FILE    2
#define XFER_CHDIR        3
#define XFER_EXIT         4

/***
* file_xfer_req packet is structured as a series of commands prefixed by
* a one byte command code:
*
*   XFER_CREATE_FILE - Create a file which may or may not exist on server.
*                    Followed by a dir_entry structure.
*                    Followed by dir_entry.size bytes of data for the file
*                    which may be spread across multiple FILE_SEND_REQ packets.
*   XFER_OPEN_FILE   - Open a file which is known to exist on the server.
*                    Followed by same info as FX_CREATE_FILE.
*   XFER_CHDIR       - Change to indicated directory.
*                    Followed by a null terminated string containing directory
*                    name.
*   XFER_EXIT      - Return from file transfer.
*   (NOTE)         - A FILE_SEND_REQ packets may begin with data still expected
*                    to fulfill a previous FX_CREATE_FILE or FX_OPEN_FILE 
*                    command.
***/

enum file_xfer_error {
    XFER_OK           = 0,
    XFER_CREATE_ERROR = 1,
    XFER_OPEN_ERROR   = 2,
    XFER_WRITE_ERROR  = 3,
    XFER_FULL_ERROR   = 4,
    XFER_CHDIR_ERROR  = 5
};

/***
* NOTE: If there were no errors in processing the FILE_XFER_REQ packet, the
* server should send back a word size FILE_XFER_ANS packet with file_send_error 
* set to XFER_OK.  Otherwise, the file or directory name (null-terminated) 
* should be sent back along with the appropriate file_send_error code and DOS 
* error code.
***/

struct file_xfer_ans {
    enum file_send_error error;
    short errno;
    char  pathname[MAX_DOS_PATH];
};

struct chddir_req {
    byte create;            // TRUE = create if directory does not exist.
    char pathname[MAX_DOS_PATH];
};

struct chddir_ans {
    short errno;
};

struct ddir_info_ans {
    char pathname[MAX_DOS_PATH];    // Current drive and directory of server
};

typedef unsigned long FILESIZE;
typedef unsigned long FILEDATE;

struct disk_free_ans {                      // Used in DISK_FREE_ANS packet
    unsigned short bytes_per_cluster;
    FILESIZE bytes_free;
};

/***
* A FILE_INFO_REQ can only be used to obtain the dir_entry structure for a file
* in the server's current directory.  The pathname is a null terminated string.
***/

struct file_info_req {
    char pathname[MAX_DOS_PATH];
};

/***
* The FILE_INFO_ANS will have exists set to TRUE if the file exists in the
* server's current directory.  Otherwise, exists will be FALSE and dir_entry
* will be undefined.
***/

struct file_info_ans {
    int exists;
    struct dir_entry dir_entry;
};


struct mkdir_req {
    char pathname[MAX_DOS_PATH];
};

struct mkdir_ans {
    short errno;
};

#define MIN_FILEDATE    0LU
#define MAX_FILEDATE    0xFFFFFFFFLU

#define MAX_FILE_LIST_SIZE   512

struct dirlist_req {
    byte attrib;                                // Attributes to search for.
    FILEDATE min_date;
    FILEDATE max_date;
    char file_list[MAX_FILE_LIST_SIZE];
};

/***
* A DIRLIST_REQ can only be used to request a directory list in the current
* directory.  The filespec_list is a list of filespecs to include in the
* directory search, followed by a list of filespecs to exclude.  Each 
* filespec is null-terminated.  The list of include filespecs is terminated
* by a null filespec as is the list of exclude filespecs.  In other words,
* there are two null bytes to mark the end of each list.  All alphabetic
* characters in either list must be in upper-case.  Filespecs must either
* be pure root names (possibly including wildcards), or must be full path
* names (without drive letter prefixes).  If a full path name is specified,
* the '\' character must be used as the path separator (instead of '/').
* All root name specs are checked during the lookup.  Full path name specs
* are only check if the directory prefix of the path name matches the
* current working directory.
*
* Example filespec list: 
*   "*.bak", 0 "*.old", 0 "myfile.doc", 0 "\wp\*.doc", 0 "\wp\learn", 0, 0
*
* In the example above, all files matching the specification "*.bak",
* "*.old", or "myfile.doc" will be included. Files matching the specification 
* "*.doc" will only if the current directory happens to "\wp".  A file or
* directory named "learn" will be included only if the directory being 
* searched is the "\wp" directory.
***/

struct dirlist_ans {
    word not_included_files;    // Files skipped because they were not included
    word excluded_files;        // Files excluded by exclude list.
    word excluded_dirs;         // Directories excluded by exclude list.
    word min_cutoff_files;      // Files excluded by minimum cutoff time.
    word max_cutoff_files;      // Files excluded by maximum cutoff time.
};
/***
* NOTE: dirlist_ans packet consists of the above structure followed by an
* array of dir_entry structures.
***/

/***
* file_recv_req packet is structured as a series of commands prefixed by a
* one byte command code:
*       
*   XFER_CREATE_FILE - Create a file which may or may not exist on client.
*                      Followed by a dir_entry structure.
*   XFER_OPEN_FILE   - Open a file which is known to exist on the client.
*                      Followed by a dir_entry structure.
*   XFER_CHDIR       - Change to indicated directory.
*                      Followed by a null terminated string containing directory
*                      name.
*   XFER_EXIT        - Will be returned in sequence to terminate the exchange.
*
* NOTE: after receiving this packet the server should build a series of
* FILE_XFER_REQ packets and send them to the client.  The client responds to
* each with a FILE_XFER_ANS packet.
***/

struct server_exit_req {
    byte dos_exit_code;
};


struct fcb_delete_req {
    byte attrib;        // Allowable attributes for files to be deleted
    char filespec[13];  // File spec (allows wildcards)
};

struct fcb_delete_ans {
    short result;       // 0 = OK, -1 = no files or some read-onlys not deleted
};

struct file_delete_req {
    char filespec[MAX_DOS_PATH];       // Does DOS function 41H delete
};

struct file_delete_ans {
    short errno;
};

struct file_attrib_req {
    byte set_attrib;            // 1 = set attributes, 0 = get attributes
    word attrib;                // attribute if setting
    char filespec[MAX_DOS_PATH];
};

struct file_attrib_ans {
    short errno;
    word  attrib;
};

struct rmdir_req {
    char pathname[MAX_DOS_PATH];
};

struct rmdir_ans {
    short errno;
};

struct rename_req {
    char current_name[MAX_DOS_PATH];
    char new_name[MAX_DOS_PATH];
};

struct rename_ans {
    short errno;
};

struct disk_info_req {                       // Used for DISK_INFO_REQ
    struct disk_free_ans diskfree;
    char   cwd[MAX_DOS_PATH];
};

/***
* NOTE: SERVER_WAIT_REQ is a command packet which a client that normally
* transmits IDLE_REQ's in order to maintain the connection may send to inform
* the server that it will be temporarily unable to transmit IDLE_REQ's.  The
* server should then disable it's timeouts until it again receives an IDLE_REQ.
***/

struct file_open_req {
    byte access_mode;
    char filespec[MAX_DOS_PATH];
};

struct file_open_ans {
    short errno;
    word  handle;
};

struct file_read_req {
    word handle;
    long offset;
    word count;
};

struct file_read_ans {
    short errno;
    word  count;            // Number of bytes actually read.
    byte  data[1];          // Data from read
};

struct file_close_req {
    word handle;
};

struct file_close_ans {
    short errno;
};

struct set_timeout_req {
    word timeout;
};
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\fxlib\saveport.asm ===
;***
;* $Workfile:   saveport.asm  $
;* $Revision:   1.0  $
;*   $Author:   Dave Sewell  $
;*     $Date:   05 May 1989 16:34:22  $
;***

INCLUDE         model.inc
INCLUDE         fastlynx.inc

                .DATA
    
        		.CODE	text
                
                EXTRN   SaveSerial:NEAR
                EXTRN   SaveParallel:NEAR
                EXTRN   RestoreSerial:NEAR
                EXTRN   RestoreParallel:NEAR
                EXTRN   GetPortInfo:NEAR
                PUBLIC  FxRestorePorts

FxSaveAllPorts  PROC    NEAR

                xor     bx, bx

save_loop:      cmp     bx, fx_tail
                jae     save_done

                call    FxSavePort

                inc     bx
                inc     bx
                jmp     save_loop

save_done:      ret

FxSaveAllPorts  ENDP

FxSavePort      PROC    NEAR    USES BX DI SI ES

                mov     al, 3
                mul     bl
                mov     di, ax
                push    ds
                pop     es                          ; ES:DI = ptr to save area
                add     di, OFFSET DGROUP:fx_port_save_area
                call    GetPortInfo
                cmp     al, SERIAL_PORT
                je      save_serial

                call    SaveParallel
                jmp     short save_ret

save_serial:    call    SaveSerial

save_ret:       ret

FxSavePort      ENDP

FxRestorePort   PROC    NEAR    USES BX SI

;*  Enter with:
;*      BX = Port to be restored

                mov     al, 3
                mul     bl
                mov     si, ax
                add     si, OFFSET DGROUP:fx_port_save_area
                call    GetPortInfo
                cmp     al, SERIAL_PORT
                je      restore_serial

                call    RestoreParallel
                jmp     short restore_ret

restore_serial: call    RestoreSerial

restore_ret:    ret

FxRestorePort   ENDP


FxRestorePorts  PROC    NEAR    USES SI

                xor     bx, bx

restore_loop:   cmp     bx, fx_tail
                jae     done

                cmp     bx, fx_index
                je      restore_next

                call    FxRestorePort

restore_next:   inc     bx
                inc     bx
                jmp     restore_loop

done:           ret

FxRestorePorts  ENDP

FxRestoreAllPorts   PROC    NEAR

                xor     bx, bx

restore_loop:   cmp     bx, fx_tail
                jae     restore_done

                call    FxRestorePort

                inc     bx
                inc     bx
                jmp     restore_loop

restore_done:   ret

FxRestoreAllPorts   ENDP

	            END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\include\bioskybd.h ===
/***
* $Workfile:   bioskybd.h  $
* $Revision:   1.2  $
*   $Author:   Dave Sewell  $
*     $Date:   24 Apr 1990  7:24:24  $
***/

#define CTRL_C	    0x003
#define ESC	    0x01B
#define F1	    0x13B
#define F2	    0x13C
#define F3	    0x13D
#define F4	    0x13E
#define F5	    0x13F
#define F6	    0x140
#define F7	    0x141
#define F8	    0x142
#define F9	    0x143
#define F10	    0x144
#define LEFT	    0x14B
#define RIGHT	    0x14D
#define UP	    0x148
#define DOWN	    0x150
#define HOME	    0x147
#define END	    0x14F
#define PGUP	    0x149
#define PGDN	    0x151
#define C_LEFT	    0x173
#define C_RIGHT     0x174
#define C_HOME	    0x177
#define C_END	    0x175
#define C_PGUP	    0x184
#define C_PGDN	    0x176
#define INS	    0x152
#define DEL	    0x153
#define SHIFT_F5    0x158
#define SHIFT_F7    0x15A
#define ALT_C	    0x12E
#define ALT_D	    0x120
#define ALT_F	    0x121
#define ALT_H       0x123
#define ALT_L       0x126
#define ALT_M	    0x132
#define ALT_N       0x131
#define ALT_P       0x119
#define ALT_R	    0x113
#define ALT_S	    0x11F
#define ALT_T       0x114
#define ALT_U	    0x116
#define ALT_V       0x12F
#define ALT_W       0x111
#define ALT_X       0x12D

extern int (* background_proc)(void);
extern int cdecl interrupt_key_level;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\include\osdep.h ===
/***
* $Workfile:   osdep.h  $
* $Revision:   1.0  $
*   $Author:   Dave Sewell  $
*     $Date:   28 Apr 1989 17:00:10  $
*
* This header file supplies information needed to interface with the
* particular operating system and C compiler being used.
**/

#ifndef OSDEP
#define OSDEP

#include "dos.h"

/*** MS-DOS version ***/
#ifndef MSDOS
#define MSDOS	1
#endif
#define OS_TYPE 2

/**
* NULLDPTR should be the appropriate value for a null data pointer.
* NULLCPTR should be the appropriate value for a null code pointer.
**/

#if	defined(M_I86LM)
/*** In large model, both code and data pointers are longs. ***/
#define LDATA	    1
#define LCODE	    1
#define NULLCPTR    0L
#define NULLDPTR    0L
#elif	defined(M_I86MM)
/*** In middle model, code pointers are long, data pointers are short. ***/
#define LDATA	    0
#define LCODE	    1
#define NULLCPTR    0L
#define NULLDPTR    0
#elif	defined(M_I86HM)
/*** In huge model, both code pointers and data pointers are long. ***/
#define LDATA	    1
#define LCODE	    1
#define NULLCPTR    0L
#define NULLDPTR    0L
#elif	defined(M_I86CM)
/*** In compact model, code pointers are short, data pointers are long. ***/
#define LDATA	    1
#define LCODE	    0
#define NULLCPTR    0
#define NULLDPTR    0L
#elif	defined(M_I86SM)
/*** In small model, both code and data pointers are short. ***/
#define LDATA	    0
#define LCODE	    0
#define NULLCPTR    0
#define NULLDPTR    0
#else
ERROR: undefined model
#endif

/**
* The following type definition takes care of the machine dependency caused by
* the unspecified handling of sign extension in the C language.  When
* converting "char" to "int", some compilers will extend the sign, while others
* will not.  For situations where sign extension is not desired, the type
* "byte" can be used because it is equivalent to "unsigned char".
**/

typedef unsigned char  byte;
typedef unsigned short word;
typedef unsigned long  dword;

/*** Define maximum file name size, and maximum path size. ***/
/***
* On DOS, maximum path name size is 2 chars for drive and colon, 64
* for directory name, one for null.  For file names, add 13 more bytes (
* 1 for another slash, 8 for root, 1 for period, 3 for extension).
***/

#define FNAMESIZE   80
#define PATHSIZE    67

#define PATHCHAR    '\\'
#define BADPATHCHAR '/'

/**
* These next few constants and macros are not machine dependant, but
* they are nice to have around.
**/

#define TRUE	1
#define FALSE	0
#define ON	1
#define OFF	0

/*** Absolute value, maximum, and minimum defines. ***/

#define ABS(val) ( ((val) < 0 ? -(val) : (val)) )
#define MAX(val1, val2) ( ((val1) > (val2) ? (val1) : (val2)) )
#define MIN(val1, val2) ( ((val1) < (val2) ? (val1) : (val2)) )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\biostick.asm ===
;***
;* $Workfile:   biostick.asm  $
;* $Revision:   1.0  $
;*   $Author:   Dave Sewell  $
;*     $Date:   05 May 1989 16:34:22  $
;*
;* Routine to read BIOS tick count.
;***

%		.MODEL memmodel, C

    IF  @CodeSize
		.CODE	_TEXT
    ELSE
        .CODE
    ENDIF

bios_ticks	    PROC
                
;* NAME
;*	bios_ticks -- Return current BIOS tick count.
;*
;* SYNOPSIS
;*	time = bios_ticks();
;*
;*	unsigned time;	 Current number of ticks (approximately 18.2 ticks/sec).
;*
;*	extern	unsigned _cdecl bios_ticks(void);

                push    bp
                push    bx
                push    cx
                push    dx
                mov     ah, 0
                int     1AH
                mov     ax, dx      ; Low  portion of tick count to AX
                pop     dx
                pop     cx
                pop     bx
                pop     bp
                ret

bios_ticks	    ENDP

	            END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\include\umfunc.h ===
/***
* $Workfile:   umfunc.h  $
* $Revision:   1.13  $
*   $Author:   Dave Sewell  $
*     $Date:   11 Sep 1990  8:40:44  $
***/
/* File ..\absdisk.asm */
extern int cdecl absread(int drive, int sector, int numsectors, char *buff);
extern int cdecl abswrite(int drive, int sector, int numsectors, char *buff);
/* File ..\absdiskf.asm */
extern int cdecl absreadf(int drive, int sector, int numsectors, char far *buff);
extern int cdecl abswritef(int drive, int sector, int numsectors, char far *buff);
/* File ..\atwrite.asm */
extern int at_ascii_write(unsigned char *buff, int cnt_save);
/* File ..\b_keybrd.asm */
extern unsigned pascal paragon_bios_keybrd(unsigned service);
/* File ..\biostick.asm */
extern	unsigned _cdecl bios_ticks(void);
/* File ..\blockcmp.asm */
extern int cdecl blockcmp(void *memptr, unsigned int count, int value);
/* File ..\calcgmt.asm */
extern	long cdecl calcgmt(int days, int hours, int minutes, int seconds);
/* File ..\checksum.asm */
extern	unsigned short checksum(unsigned char *buff, int len);
/* File ..\crbuff.asm */
extern int cdecl crunch_buff(byte far *bp, unsigned cnt, byte far *dest, unsigned destsize);
/* File ..\desqview.asm */
extern void pascal dv_pause(void);
/* File ..\dosflush.asm */
extern  int pascal _dos_flush(int fd);
/* File ..\doslseek.asm */
extern  long pascal _dos_lseek(int fd, long offset, int method);
/* File ..\dskspace.asm */
extern	int dskspace(int drivenum, long *total, long *avail);
/* File ..\fixslash.asm */
extern void pascal fixslash(char *str);
/* File ..\flkforf.asm */
extern	char far * pascal flookforf(char far *str, int len, char far *buff, int bufflen);
/* File ..\fmemcmpf.asm */
extern int pascal fmemcmpf(byte far *p1, byte far *p2, unsigned int count);
/* File ..\fmemcpy.asm */
extern void pascal fmemcpy(void far *dest, const void *src, int count);
/* File ..\fmemcpyf.asm */
extern void pascal fmemcpyf(void far *dest, const void far *src, unsigned int count);
/* File ..\fmemsetw.asm */
extern void pascal fmemsetw(unsigned far *memptr, int value, unsigned int count);
/* File ..\fstrcpy.asm */
extern void pascal fstrcpy(void far *dest, const void *src);
/* File ..\fstrcpyf.asm */
extern void pascal fstrcpyf(void far *dest, const void far *src);
/* File ..\getwd.asm */
extern  void pascal getwd(char *buff);
/* File ..\htoi.asm */
extern int pascal htoi(char *pnt);
/* File ..\in_dst.asm */
extern  int cdecl in_dst(struct tm *);
/* File ..\inittick.asm */
extern	int pascal init_ticks(void);
/* File ..\kbcheck.asm */
extern  int kbcheck(void);
extern  int kbget(void);
/* File ..\lookfor.asm */
extern	char * pascal lookfor(char *str, int len, char *buff, int bufflen);
/* File ..\memcpyf.asm */
extern void pascal memcpyf(void *dest, const void far *src, int count);
/* File ..\memrchr.asm */
extern	char * cdecl memrchr(char *memptr, int value, int count);
/* File ..\memsetw.asm */
extern void pascal memsetw(short *memptr, short value, short count);
/* File ..\memspace.asm */
extern	void memspace(unsigned int psp, long *total, long *avail);
/* File ..\muldiv.asm */
extern unsigned pascal mul_div(unsigned op1, unsigned op2, unsigned divisor);
/* File ..\nullproc.asm */
/* File ..\patmatch.asm */
extern int _far _pascal patmatch(char *string, char *pattern);
/* File ..\pstrlen.asm */
extern unsigned int _fastcall pstrlen(char *str);
/* File ..\readtick.asm */
extern	unsigned int far pascal fread_ticks(void);
extern	unsigned int near read_ticks(void);
/* File ..\scrmem.asm */
extern void pascal restore_cursor(unsigned value);
extern void pascal locate(int row_col);
extern void pascal cursor_on(void);
extern void pascal cursor_off(void);
extern void pascal set_attribute(int attr);
extern void pascal dispmem(int pos, byte far *buff, int cnt);
extern void pascal clear(int ulpos, int lrpos);
extern void pascal scroll(int ulpos, int lrpos, int attr, int count, int direction);
extern void pascal fill(int ulpos, int height_width, int c);
extern void pascal shade(int ulpos, int height_width);
extern void pascal save_zone(int ulpos, int height_width, byte far *buff);
extern void pascal restore_zone(int ulpos, int height_width, byte far *buff);
extern void _far _pascal init_screen(void);
extern void _far _pascal restore_screen(void);
extern int _far _pascal init_scr(void);
extern void _far _pascal restore_scr(int restore_mode);
/* File ..\seldisk.asm */
extern  int pascal seldisk(char letter);
/* File ..\setcbrk.asm */
extern void cdecl setcbrk(void);
extern void cdecl resetcbrk(void);
/* File ..\setftime.asm */
extern void pascal setftime(int handle, unsigned long filedate);
/* File ..\setwd.asm */
extern  int pascal setwd(char *path);
/* File ..\strcpyf.asm */
extern void pascal strcpyf(void *dest, const void far *src);
/* File ..\string.asm */
extern int pascal fstrcmpf(char far *str1, char far *str2);
extern int pascal fstrcmp(char far *str1, char *str2);
extern int pascal fstrcmpif(char far *str1, char far *str2);
extern int pascal fstrnicmp(char far *str1, char *str2, unsigned int maxlen);
/* File ..\strlenf.asm */
extern unsigned int pascal strlenf(char far *str);
/* File ..\strlwrf.asm */
extern void pascal strlwrf(char far *string);
/* File ..\strrepc.asm */
extern  void pascal strrepc(char *str, int c, int repc);
/* File ..\strtcpy.asm */
extern void pascal strtcpy(char *dest, char *src, unsigned count);
/* File ..\strtcpyf.asm */
extern void pascal strtcpyf(char *dest, char far *src, unsigned count);
/* File ..\struprf.asm */
extern void pascal struprf(char far *string);
/* File ..\swapmem.asm */
extern	void pascal swapmem(char *p1, char *p2, int count);
/* File ..\ticks.asm */
extern	unsigned long pascal ticks(void);
/* File ..\uncrbuff.asm */
extern unsigned int pascal uncrunch_buff(byte far *bp, unsigned cnt, byte far *dest, unsigned destsize);
/* File ..\bioskybd.c */ 
extern  int pascal check_key(void );
extern  int pascal read_raw_key(void );
extern  int pascal grab_key(void );
extern  int pascal read_key(void );
extern  void _fastcall unread_key(int c);
extern  void pascal push_interrupt_keys(void );
extern  void pascal pop_interrupt_keys(void );
extern  void _fastcall enable_interrupt_key(int key,int (*proc)(void ));
extern  void _fastcall disable_interrupt_key(int key);
/* File ..\chwd.c */ 
extern  void pascal pushwd(void );
extern  char *pascal curwd(void );
extern  int pascal chwd(char *path);
extern  void pascal popwd(void );
extern  void pascal popallwd(void );
extern int _fastcall mkdirpath(char *dir_name);
extern int _fastcall force_chwd(char *path, int *created_dir);
/* File ..\dir.c */ 
extern  int pascal opendir(char *name,int dir_change,struct find_t *buffer);
extern  int pascal readdir(struct find_t *buffer);
/* File ..\..\dircat.c */ 
extern  void pascal dircat(char *dest,char *src1,char *src2);
/* File ..\..\dirpath.c */ 
extern  int pascal opendirpath(char *pname);
extern  int pascal readdirpath(struct path *path);
/* File ..\dosstat.c */ 
extern  int cdecl dosstat(char *fn,struct dosstat *st);
/* File ..\drawbox.c */ 
extern  void _fastcall draw_box(int ulpos,int height_width,int ltype,int attrib);
/* File ..\..\filetime.c */ 
extern  int pascal gettime(char *fname,long *time);
/* File ..\..\fixpath.c */ 
extern  void pascal fixpath(char *path,char *buff,int buffsize);
/* File ..\..\huffcnt.c */ 
extern  void huff_count(unsigned char *buff,int cnt);
/* File ..\..\huffdec.c */ 
extern  void huff_decode(unsigned char *src,int scnt,unsigned char *dest,int *dcnt);
/* File ..\..\huffenc.c */ 
extern  int huff_pad(unsigned char *dest);
extern  void huff_encode(unsigned char *src,int scnt,unsigned char *dest,int *dcnt);
/* File ..\..\huffman.c */ 
extern  void huff_init_count(void );
extern  void add_nodes(void );
extern  void huff_analyze(void );
extern  void huff_read_table(unsigned char *buff,int *cnt,long *packed_size);
extern  void huff_write_table(unsigned char *buff);
/* File ..\huntfor.c */ 
extern  long pascal huntfor(int fd,char *str,int len);
/* File ..\justify.c */ 
extern  void _fastcall justify_str(int pos,int len,int attrib,char *str,int justify);
/* File ..\..\lgmtime.c */ 
extern  int makewday(struct tm *date);
extern  long lgmtime(struct tm *date);
extern  long str_gmtime(char *string);
extern  long num_gmtime(int *num);
/* File ..\lzw2.c */ 
extern  int allocate_crunch_memory(int crunching,int big_crunch);
extern  void free_crunch_memory(void );
/* File ..\..\path.c */ 
extern  void pascal set_memory_error_proc(void (*err_proc)(char *));
extern  int pascal openpath(char *pname,int level);
extern  int pascal readpath(struct path *path,int level);
extern  void pascal closepath(int level);
/* File ..\..\pmatch.c */ 
extern  int pmatch(char *pattern,char *string);
extern  int wildword(char *s);
/* File ..\profiler.c */ 
extern  void start_profile(void );
extern  void stop_profile(void );
extern  void start_timer(int section_number,char *section_name);
extern  void stop_timer(int section_number);
/* File ..\..\regex.c */ 
extern  char *re_comp(char *sp);
extern  int cclass(char *set,char c,int af);
extern  int backref(int i,char *lp);
extern  int re_exec(char *p1);
/* File ..\rtc.c */ 
extern  int _rtc_getdate(struct dosdate_t *date);
extern  int _rtc_setdate(struct dosdate_t *date);
extern  int _rtc_gettime(struct dostime_t *time);
extern  int _rtc_settime(struct dostime_t *time);
/* File ..\run.c */ 
extern  int pascal run(char *cmd);
/* File ..\screen.c */ 
extern void _fastcall push_cursor(int on_flag, int location);
extern void pascal pop_cursor(void);
extern  void _fastcall push_attribute(int new_attribute);
extern  void pascal pop_attribute(void );
extern  void _fastcall fill_attr(int ulpos,int height_width,int c,int attrib);
extern  void _fastcall dispstr_attr(int pos,byte far *buff,int attr);
extern  void _fastcall dispmem_attr(int pos,byte far *buff,int cnt,int attrib);
extern  void _fastcall dispstr(int pos,byte far *buff);
extern  void _fastcall dispchar(int pos,int c);
/* File ..\..\strdiff.c */ 
extern  int strdiff(char *str1,char *str2,int ignore_case,int squeeze_white);
/* File ..\..\tsscanf.c */ 
extern  int cdecl tsscanf(char *str,char *format,...);
/* File ..\udscreen.c */ 
extern  void update_screen(unsigned char *screen);
/* File ..\..\watch.c */ 
extern  void pascal setwatch(void );
extern  long pascal watch(void );
extern  char *pascal seconds(long tenths);
extern int pascal fmemcmpw(unsigned far *p1, unsigned far *p2, unsigned int count);
extern int cdecl blockcmpf(void far *memptr, unsigned int count, int value);
extern int pascal wordcmpf(void far *memptr, unsigned count, unsigned value);
extern void pascal fwordcpyf(unsigned far *dest, const unsigned far *src, int count);
extern int pascal rmemcmp(byte *p1, byte *p2, unsigned int count);
extern int pascal frmemcmp(byte far *p1, byte far *p2, unsigned int count);
extern void _fastcall strsize(char *str, int *height, int *width);
extern unsigned long _fastcall mul32(unsigned op1, unsigned op2);
/* normaliz.c */
extern void huge *normalize(void huge *pnt);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\include\screen.h ===
/***
* $Workfile:   screen.h  $
* $Revision:   1.0  $
*   $Author:   Dave Sewell  $
*     $Date:   28 Apr 1989 17:00:08  $
***/

#define BLACK		0
#define BLUE		1
#define GREEN		2
#define CYAN		3
#define RED		4
#define MAGENTA 	5
#define BROWN		6
#define WHITE		7

#define INTENSE 	0x08
#define BLINKING	0x80
#define MONO_REVERSE	0x0100
#define MONO_UNDERLINE	0x0200
#define MONO_NORMAL	0x0400
#define MONO_BOLD	0x0800

#define YELLOW		(BROWN | INTENSE)

#define color(fg, bg)		(((bg) << 4) + (fg))
#define coord(row, col)        (((row) << 8) + (col))
#define boxsize(height, width)	(((height) << 8) + (width))

extern byte near cdecl force_mono;
extern int cdecl _attrib;
extern unsigned int cdecl _origin;
extern byte cdecl desqview;
extern const byte cdecl cursor_row;
extern const byte cdecl cursor_column;
extern const word cdecl cursor_location;
extern const word cdecl cursor_value;
extern const byte _cdecl scr_rows;
extern const byte _cdecl scr_cols;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\bioskybd.c ===
/***
* $Workfile:   bioskybd.c  $
* $Revision:   1.1  $
*   $Author:   Dave Sewell  $
*     $Date:   24 Apr 1990  7:45:36  $
*
* Keyboard service routines which use BIOS calls.
*
* All keyboard return values are integers with the following meaning:
*     0       = no key available
*     1 - 255 = ASCII character
*   256 - 511 = function key, value = scan code + 256
***/

#include "osdep.h"
#include <bios.h>
#include <memory.h>
#include "umfunc.h"
#include "bioskybd.h"

#define MAX_INTERRUPT_KEYS  10
#define MAX_KEY_SAVE        4

int cdecl interrupt_key_level = 0;
int (* background_proc)(void) = 0;

static unsigned key_stack = 0;

static struct keydef {
    int value;
    int (*proc)(void);
} keys[MAX_INTERRUPT_KEYS];

static struct keydef key_save[MAX_INTERRUPT_KEYS * MAX_KEY_SAVE];
static int keyi = 0;        /* Index into key save structures.  */

static int near _fastcall map_key(unsigned service);

static int near _fastcall map_key(service)
unsigned service;
{
    unsigned value;

    value = paragon_bios_keybrd(service);
    if (value == 0) return 0;
    else if ( (byte) value ) return value & 0xFF;
    else return ((value >> 8) & 0xFF) + 256;
}

/***
* Check to see if a keystroke is available.
* Return 0 if no keystroke available.
* Otherwise return the keystroke and leave it in the buffer.
***/
int pascal check_key()
{
    if (key_stack) return key_stack;
    else return map_key(_KEYBRD_READY);
}

int pascal read_raw_key()       /* No check for interrupt functions.    */
{
    unsigned key;

    if (key_stack) {
        key = key_stack;
        key_stack = 0;
        return key;
    }
    if (background_proc) {
        while ( check_key() == 0 ) {   /* No keys yet. */
            if (background_proc) {
                key = (*background_proc)();
                if (key) return key;
            }
        }
    }
    return map_key(_KEYBRD_READ);
}

int pascal grab_key()       /* No check for interrupt functions.    */
{
    return map_key(_KEYBRD_READ);
}

int pascal read_key()
{
    register int c = 0;
    register int i;

    while (c == 0) {
        c = read_raw_key();
        for (i = 0; i < MAX_INTERRUPT_KEYS; i++) {
            if (keys[i].value == c && keys[i].proc) {
                interrupt_key_level++;
                c = (*keys[i].proc)();
                interrupt_key_level--;
                break;
            }
        }
    }
    return c;
}

/***
* Push a keystroke back onto the input buffer.
* Note:  only one keystroke can be pushed back.  Any previously pushed back
* keystrokes will be thrown away.
***/
void _fastcall unread_key(c)
int c;
{
    key_stack = c;
}

void pascal push_interrupt_keys()
{
    if (keyi < MAX_KEY_SAVE) {
        memcpy(&key_save[keyi * MAX_INTERRUPT_KEYS], keys, sizeof(keys));
        keyi++;
    }
}

void pascal pop_interrupt_keys()
{
    if (keyi) {
        keyi--;
        memcpy(keys, &key_save[keyi * MAX_INTERRUPT_KEYS], sizeof(keys));
    }
}

void _fastcall enable_interrupt_key(int key, int (*proc)(void) )
{
    register int i;

    for (i = 0; i < MAX_INTERRUPT_KEYS; i++) {
        if (keys[i].value == key || keys[i].value == 0) {
            keys[i].value = key;
            keys[i].proc = proc;
            break;
        }
    }
}

void _fastcall disable_interrupt_key(key)
int key;
{
    register int i;

    for (i = 0; i < MAX_INTERRUPT_KEYS; i++) {
        if (keys[i].value == key) {
            keys[i].proc = 0;
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\fmemcmpf.asm ===
;***
;* $Workfile:   fmemcmpf.asm  $
;* $Revision:   1.0  $
;*   $Author:   Dave Sewell  $
;*     $Date:   28 Apr 1989 16:50:04  $
;*
;* Far pointer version of "memcmp".
;***

    INCLUDE DOS.MAC

    TEXTSEG


;* NAME
;*	fcmpmemf -- Compare two areas of memory
;*
;* SYNOPSIS
;*	extern int pascal fmemcmpf(byte far *p1, byte far *p2, unsigned int count);
;*
;*	int  result;		Result of comparison
;*	byte far *p1;		Pointer to first area of memory
;*	byte far *p2;		Pointer to second area of memory
;*	unsigned count; 	Number of bytes to compare

PASCALDEF   fmemcmpf

	    procent
	    PUSH    DS
	    LES     DI, DWORD PTR [BP+X+I+FDP]
	    LDS     SI, DWORD PTR [BP+X+I]

;*** Now ES:DI points to first area, DS:SI points to second area

	    MOV     CX, [BP+X]		;And CX gets the count

	    XOR AX, AX			;Preset return value to zero
	    CLD 			;Insure forward compare
	    JCXZ    cmpmem_ret		;Return a zero if count is zero

    REPE    CMPS    BYTE PTR DS:[SI], ES:[DI]

	    JE	    cmpmem_ret		;All bytes were equal

	    INC     AX			;*** Does not affect carry flag!
	    JB	    cmpmem_ret		;Carry means DI (string1) was greater

	    DEC     AX			;Not equal or carry -
	    DEC     AX			;    DI (string1) was smaller

cmpmem_ret:
	    POP     DS
	    procret FDP + FDP + I

PASCALEND   fmemcmpf


    TEXTEND

    END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\fstrcpy.asm ===
;***
;* $Workfile:   fstrcpy.asm  $
;* $Revision:   1.0  $
;*   $Author:   Dave Sewell  $
;*     $Date:   28 Apr 1989 16:50:26  $
;***


    INCLUDE dos.mac

    TEXTSEG

PASCALDEF   fstrcpy

;* NAME
;*	fstrcpy -- Copy a string to a far buffer.
;*
;* SYNOPSIS
;*	extern void pascal fstrcpy(void far *dest, const void *src);
;*	void far *dest;     Pointer to destination area of memory for move
;*	const void *src;    Pointer to source string

	    procent
	    les     di, DWORD PTR [BP + X + DP]
	IF  LDATA
	    push    ds
	    lds     si, DWORD PTR [BP + X]
	ELSE
	    mov     si, WORD PTR [BP + X]
	ENDIF

str_loop:   lodsb
	    stosb
	    or	    al, al
	    jnz     str_loop

	IF  LDATA
	    pop     ds
	ENDIF
	    procret FDP + DP

PASCALEND   fstrcpy

    TEXTEND

    END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\drawbox.c ===
/***
* $Workfile:   drawbox.c  $
* $Revision:   1.2  $
*   $Author:   Dave Sewell  $
*     $Date:   24 Apr 1990  7:45:16  $
***/

#include "osdep.h"
#include "umfunc.h"
#include "screen.h"

#define F_H1	 0xC4
#define F_H2	 0xCD
#define F_V1	 0xB3
#define F_V2	 0xBA

#define F_UL1	 0xDA
#define F_UR1	 0xBF
#define F_LL1	 0xC0
#define F_LR1	 0xD9

#define F_UL2	 0xC9
#define F_UR2	 0xBB
#define F_LL2	 0xC8
#define F_LR2	 0xBC

struct Border {
    byte horizontal;            /* Horizontal line */
    byte vertical;              /* Vertical line */
    byte upperLeft;             /* Upper left corner */
    byte upperRight;            /* Upper right corner */
    byte lowerLeft;             /* Lower left corner */
    byte lowerRight;            /* Lower right corner */
};

/***
* If ltype is 1 or -1 a single line border will be drawn, otherwise double.
* If ltype is negative, the interior of the box will not be cleared.
***/

void _fastcall draw_box(int ulpos, int height_width, int ltype, int attrib)
{
    register struct Border *bp;
    int height = height_width >> 8;
    int width	= height_width & 0xFF;
    static struct Border singleBorder = {
        F_H1, F_V1, F_UL1, F_UR1, F_LL1, F_LR1
    };
    static struct Border doubleBorder = {
        F_H2, F_V2, F_UL2, F_UR2, F_LL2, F_LR2
    };

    bp = (ltype == 1 || ltype == -1) ? &singleBorder : &doubleBorder;
    set_attribute(attrib);
    dispchar(ulpos, bp->upperLeft);
    fill(ulpos + 1, boxsize(1, width - 2), bp->horizontal);
    dispchar(ulpos + width - 1, bp->upperRight);
    fill(ulpos + 0x0100, boxsize(height - 2, 1), bp->vertical);
    if (ltype >= 0) fill(ulpos + 0x0101, height_width - 0x0202, ' ');
    fill(ulpos + 0x100 + width - 1, boxsize(height - 2, 1), bp->vertical);
    dispchar(ulpos + (height << 8) - 0x100, bp->lowerLeft);
    fill(ulpos + 1 + (height << 8) - 0x100, boxsize(1, width - 2),
	    bp->horizontal);
    dispchar(ulpos + height_width - 0x0101, bp->lowerRight);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\b_keybrd.asm ===
;***
;* $Workfile:   b_keybrd.asm  $
;* $Revision:   1.1  $
;*   $Author:   Dave Sewell  $
;*     $Date:   09 Oct 1989 11:56:28  $
;*
;* Fixed version of MSC "_bios_keybrd" routine.
;
;   Their routine messed up on Ctrl-Break.  This routine maps that key to
;   ESC.
;*******************************************************************************

%		.MODEL memmodel, language


        IF  @CodeSize
            .CODE   PARAGON_TEXT
        ELSE
            .CODE
        ENDIF

;***
;extern unsigned pascal paragon_bios_keybrd(unsigned service);
;
;Purpose:
;	The function "_bios_keybrd" performs
;	keyboard services using interrupt 16H.
;
;Entry:
;	unsigned service - specifies which keyboard service is being requested
;
;Exit:
;	For service 0, AL = Character code, AH = Scan Code
;	For service 1, AX = 0 if no key waiting, otherwise same as service 0
;	For service 2, AL = shift status byte
;
;Uses:
;	BX, CX, DX
;
;Exceptions:
;
;*******************************************************************************

paragon_bios_keybrd PROC    service:BYTE

		mov	ah, service
		int	16H		; request keyboard service
		jnz	check_cbrk

		cmp	service, 1
		jne	check_cbrk

		xor	ax,ax		; return 0 to indicate no key ready
		jmp	short done

check_cbrk:	or	ax, ax
		jnz	done

		mov	ax, 011BH	;Map Ctrl-Break to ESC

done:		ret

paragon_bios_keybrd ENDP

		    END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\justify.c ===
/***
* $Workfile:   justify.c  $
* $Revision:   1.1  $
*   $Author:   Dave Sewell  $
*     $Date:   24 Apr 1990  7:45:22  $
***/

#include "osdep.h"
#include "screen.h"
#include "umfunc.h"

void _fastcall justify_str(int pos, int len, int attrib, char *str, int justify)
{
    register int str_len;
    int leading_blanks;     /* Number of blanks to output before string.    */
    int trailing_blanks;    /* Number of blanks to output after string.     */

    push_attribute(attrib);
    str_len = pstrlen(str);
    if (justify < 0) {		/* left justify.    */
	leading_blanks	= 0;
	trailing_blanks = len - str_len;
    }
    else if (justify > 0) {	/* right justify    */
	leading_blanks = len - str_len;
	trailing_blanks = 0;
    }
    else {			/* center	    */
	leading_blanks = (len - str_len) / 2;
	trailing_blanks = len - str_len - leading_blanks;
    }
    fill(pos, boxsize(1, leading_blanks), ' ');
    dispstr(pos + leading_blanks, str);
    fill(pos + leading_blanks + str_len, boxsize(1, trailing_blanks), ' ');
    pop_attribute();
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\htoi.asm ===
;***
;* $Workfile:   htoi.asm  $
;* $Revision:   1.0  $
;*   $Author:   Dave Sewell  $
;*     $Date:   28 Apr 1989 16:50:42  $
;*
;* Hex string to integer, assembly language version
;**/

INCLUDE dos.mac

	TEXTSEG

; extern int pascal htoi(char *pnt);

PASCALDEF   htoi

	    push    bp
	    mov     bp, sp
	    push    si
	IF  LDATA
	    push    ds
	    lds     si, [BP + X]
	ELSE
	    mov     si, [BP + X]
	ENDIF
	    xor     dx, dx
	    mov     cl, 4
	    xor     ah, ah

hloop:	    lodsb
	    cmp     al, 'f'
	    ja	    done

	    cmp     al, 'a'
	    jb	    chkupper

	    sub     al, '0' + ('a' - 'A') + 7
	    jmp     short nextdig

chkupper:   cmp     al, 'F'
	    ja	    done
	    cmp     al, 'A'
	    jb	    chkdigit

	    sub     al, '0' + 7
	    jmp     short nextdig

chkdigit:   sub     al, '0'
	    jc	    done

	    cmp     al, 9
	    ja	    done

nextdig:    shl     dx, cl
	    add     dx, ax
	    jmp     hloop

done:	    mov     ax, dx
	IF  LDATA
	    pop     ds
	ENDIF
	    pop     si
	    pop     bp
	    ret     I

PASCALEND   htoi

	    TEXTEND
	    END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\nullproc.asm ===
;***
;* $Workfile:   nullproc.asm  $
;* $Revision:   1.1  $
;*   $Author:   Dave Sewell  $
;*     $Date:   09 Oct 1989 11:56:16  $
;*
;* Null routine used for short delay.  All it does is a far return.
;***

%		.MODEL memmodel, language

        IF  @CodeSize
            .CODE   PARAGON_TEXT
        ELSE
            .CODE
        ENDIF

null_proc	PROC	FAR

    		ret

null_proc	ENDP

		END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\initscr.asm ===
;***
;* $Workfile:   initscr.asm  $
;* $Revision:   1.0  $
;*   $Author:   Dave Sewell  $
;*     $Date:   11 Sep 1990  8:46:06  $
;***

%               .MODEL MEDIUM, PASCAL

; Hercules Graphics InColor Card constants

DMC_PORT        EQU     03B8H       ; Display mode control port
STATUS_PORT     EQU     03BAH       ; Display status port
INDEX_REG       EQU     03B4H       ; 6845 index register
DATA_REG        EQU     03B5H       ; 6845 data register

XMODE_REG       EQU     14H         ; character mode option port
UNDERSCORE_REG  EQU     15H         ; register to set underscore
OVERSTRIKE_REG  EQU     16H         ; register to set overstrike
EXCEPTION_REG   EQU     17H         ; bit 0-3  cursor color
                                    ; bit 4    palette enable/disable
                                    ; bit 5    normal/alternate attributes
                                    ; bit 6-7  unused
PALETTE_REG     EQU     1CH

ID_MASK         EQU     01110000B   ; to detect the presence of
ID_CODE         EQU     01010000B   ; a GB222 (InColor card)

MOTOROLA_6845   EQU     3DAH

REVERSE_BIT     EQU     1
UNDERLINE_BIT   EQU     2
NORMAL_BIT      EQU     4
BOLD_BIT        EQU     8

BIOS_SEG    SEGMENT AT 40H

            ORG     49H
crt_mode    DB      ?
crt_cols    DW      ?
crt_len     DW      ?
crt_start   DW      ?
cursor_posn DW      ?
            
            ORG     84H
crt_rows    DB      ?

BIOS_SEG    ENDS

                .DATA?
                EXTRN   HerculesInColor:BYTE
                EXTRN   __attrib:WORD
                EXTRN   _desqview:BYTE
                EXTRN   _cursor_column:BYTE
                EXTRN   _cursor_row:BYTE
                EXTRN   _cursor_location:WORD
                EXTRN   _cursor_value:WORD
                EXTRN   _scr_rows:BYTE
                EXTRN   _scr_cols:BYTE
                EXTRN   is_mono:BYTE

topview         DB      ?
HerculesReset   DB      ?               ; Non-zero if users palette was loaded
                                        ; Zero if to reset to Default palette

                .DATA
                EXTRN   _display_segment:WORD
                EXTRN   _display_offset:WORD
                EXTRN   _retrace_wait:BYTE
                EXTRN   _force_mono:BYTE
                EXTRN   _on_cursor_value:WORD
                EXTRN   _off_cursor_value:WORD

old_video_mode  DB      0FFH

; EGA/VGA compatable palette defined below.  This area is also used for the
; buffer when reading the user desired palette from the HPAL file.
;
HerculesPalette DB      0, 1, 2, 3, 4, 5, 20, 7, 56, 57, 58, 59, 60, 61, 62, 63
                DB      00010011B       ; Palette enabled, alternate attributes
                                        ; Cursor Color set to palette index 3
                DB      01101101B       ; Underscore color = index 6, line = 13
PALETTE_LENGTH  EQU     ($ - HerculesPalette)

                EXTRN   PASCAL LoadHerculesPalette:FAR
                EXTRN   PASCAL SetTopview:FAR

                .CODE   FAR_TEXT


;*** The following macro generates code to wait for horizontal retrace
;*** intervals.  This is necessary to prevent screen snow when using the
;*** IBM color adapter.  Interrupts are disabled during the wait.
;*** DX must have the address of the Motorola 6845 status port.
;*** AL is clobbered.

RetraceWait     MACRO
                LOCAL   WaitForLow, WaitForHigh

WaitForLow:     IN      AL, DX
                RCR     AL, 1
                JC      WaitForLow

                CLI

WaitForHigh:    IN      AL, DX
                RCR     AL, 1
                JNC     WaitForHigh

                ENDM

CheckHercules   PROC    NEAR    USES ES SI

                mov     ax, 40H
                mov     es, ax
                mov     si, 6CH
                mov     HerculesInColor, 0  ;Pre-set for not Hercules
                mov     dx, STATUS_PORT     ; record state
                in      al, dx
                and     al, 80h             ; save bit 7 for test
                mov     bl, al

                mov     cx, es:[si]

@@:             in      al, dx              ; take another reading
                and     al, 80h             ; again, save bit seven
                cmp     al, bl
                jne     hgc_ok              ; if bit 7 changes, then it

                mov     ax, es:[si]
                sub     ax, cx
                cmp     ax, 2
                jb      @B                  ;No - keep looking

                jmp     SHORT exit          ; Test failed - leave flag zero

hgc_ok:         in      al, dx              ; test for GB222
                and     al, ID_MASK         ; clear all but bits 4, 5, and 6

                cmp     al, ID_CODE         ; test ID bits
                jne     exit                ; exit if failed - not a GB222

                inc     HerculesInColor     ; It is a GB222, set flag non-zero

exit:           ret

CheckHercules   ENDP


; SetHerculesPalette    loads the HerculesPalette data into the InColor palette
;                       registers, enables the palette and the alternate
;                       attribute set.

SetHerculesPalette  PROC

                mov     dx, INDEX_REG
                mov     al, PALETTE_REG ; point at GB222 palette registers
                out     dx, al
                inc     dx              ; increment to 6845 data register
                in      al, dx          ; reset the palette pointer

                mov     cx, 16          ; 16 registers in the palette
                mov     si, OFFSET HerculesPalette

@@:             lodsb                   ; load 1st 16 bytes into color index
                out     dx, al          ; registers
                loop    @B

                dec     dx              ; Set Palette, Attribute set, and cursor color
                mov     al, EXCEPTION_REG
                out     dx, al
                inc     dx
                lodsb
                out     dx, al

                dec     dx              ; Set the underscore position and color
                mov     al, UNDERSCORE_REG
                out     dx, al
                inc     dx
                lodsb
                out     dx, al

                mov     dx, DMC_PORT
                mov     al, 00001000B   ; Page zero, blink off, enable video,
                out     dx, al          ; text mode

                ret

SetHerculesPalette  ENDP

; Sets Hercules InColor card to default (hardware) settings.  This routine is
; called if the users palette could not be loaded for any reason.
;
SetHerculesDefault  PROC

                mov     dx, INDEX_REG
                mov     al, EXCEPTION_REG
                out     dx, al
                inc     dx
                mov     al, 00100000B   ; Normal attributes, palette disabled
                out     dx, al

                dec     dx
                mov     al, UNDERSCORE_REG
                out     dx, al
                inc     dx
                mov     al, 0           ; reset underscore register
                out     dx, al

                ret

SetHerculesDefault  ENDP

init_scr        PROC    FAR USES BP DI SI

                LOCAL   mode_set:WORD

;* extern int _far _pascal init_scr(void);

                mov     _scr_rows, 25
                mov     _scr_cols, 80
                xor     ax, ax
                mov     _retrace_wait, al
                mov     mode_set, ax
                mov     ah, 1AH             ;AH = 0x1A, AL = 0
                INT     10H
                cmp     al, 1AH
                jne     check_ega

                cmp     bl, 2
                jne     determine_mode

need_retrace:   inc     _retrace_wait
                jmp     short determine_mode

check_ega:      mov     ah, 12H
                mov     bl, 10H
                INT     10H
                cmp     bl, 10H
                jne     determine_mode

                INT     11H         ;Get BIOS equipment list
                and     al, 30H
                cmp     al, 30H
                jne     need_retrace

determine_mode: mov     ah, 15
                INT     10H
                mov     old_video_mode, al
                cmp     ah, 80              ; Insure we are in 80 column mode
                jne     set_mode

                cmp     al, 7
                je      check_rows

                cmp     al, 3
                jne     set_mode

check_rows:     mov     bx, 40H
                mov     es, bx
                mov     bl, es:crt_rows
                cmp     bl, 24              ; 25 line mode OK
                je      save_rows

                cmp     bl, 42              ; 43 line mode OK
                je      save_rows

                cmp     bl, 49
                je      save_rows

set_mode:       mov     ax, 3
                INT     10H
                inc     mode_set
                mov     bl, es:crt_rows
                cmp     bl, 24              ; 25 line mode OK
                je      save_rows

                cmp     bl, 42
                je      save_rows

                cmp     bl, 49
                jne     determine_seg

save_rows:      inc     bl
                mov     _scr_rows, bl

determine_seg:  mov     ah, 3
                INT     10H
                mov     _cursor_location, dx
                mov     _cursor_value, cx
                mov     ah, 15
                INT     10H
                cmp     al, 7
                je      mono_seg

color_seg:      mov     _display_segment, 0B800H
                mov     is_mono, 0
                mov     _on_cursor_value, 0607H
                mov     _off_cursor_value, 2607H
                jmp     short check_dv

mono_seg:       mov     _display_segment, 0B000H
                mov     is_mono, 1
                mov     _on_cursor_value, 0B0CH
                mov     _off_cursor_value, 2B0CH
                mov     _retrace_wait, 0

                call    CheckHercules   ; See if we are on an InColor Card
                cmp     HerculesInColor, 0
                je      check_dv

                call    SetHerculesPalette  ; Set Palette to EGA/VGA colors

    ; If using an InColor card, load (but do not set) the users default palette.
    ; Restore_screen may be called from the critical error handler.  During
    ; critical error handling the users palette could not be loaded as the load
    ; process involves DOS I/O.  However, since we load the users palette here,
    ; there is no problem calling restore_screen from the critical error
    ; handler.

                push    ds              ; Seg:offset of palette buffer
                mov     ax, OFFSET HerculesPalette
                push    ax

                mov     ax, PALETTE_LENGTH
                push    ax              ; buffer length
                call    LoadHerculesPalette
                mov     HerculesReset, al

check_dv:       mov     _desqview, 0
                mov     topview,  0
                mov     cx, 'DE'
                mov     dx, 'SQ'
                mov     ax, 2B01H
                int     21H
                cmp     al, 0FFH
                je      @F

                inc     _desqview

@@:             mov     es, _display_segment
                mov     di, _display_offset
                mov     ah, 0FEH
                INT     10H                     ;Check for TopView windowing
                mov     ax, es
                cmp     ax, _display_segment
                jne     display_change

                cmp     di, _display_offset
                je      init_done

display_change: mov     _display_segment, es
                mov     _display_offset,  di
                mov     _retrace_wait, 0
                cmp     _desqview, 0
                jne     init_done

                inc     topview                 ;Topview (needs update calls)
                mov     al, topview
                call    SetTopview

init_done:      mov     ax, mode_set
                ret

init_scr        ENDP

restore_scr     PROC    FAR USES BP DI SI, restore_mode:WORD

;* extern void _far _pascal restore_scr(int restore_mode);

                cmp     HerculesInColor, 0
                je      reset_mode

                cmp     HerculesReset, 0
                je      @F

                call    SetHerculesPalette
                jmp     short reset_mode

@@:             call    SetHerculesDefault

reset_mode:     cmp     restore_mode, 0
                je      restore_ret

                mov     al, old_video_mode
                xor     ah, ah
                INT     10H

restore_ret:    ret

restore_scr     ENDP


                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\loadherc.c ===
/***
* $Workfile:   loadherc.c  $
* $Revision:   1.2  $
*   $Author:   Dave Sewell  $
*     $Date:   11 Sep 1990  8:48:50  $
*
* Load Hercules Graphics InColor palette routine.
***/

#include <dos.h>
#include <fcntl.h>
#include <stdlib.h>
#include "osdep.h"

/* LoadHerculesPalette -- Loads the file specified by the HPAL environment
    variable into the passed in buffer.  This file should contain the users
    favorite color palette for the InColor card.

    This routine is called from init_screen() only.
*/

int _far _pascal LoadHerculesPalette(void far *palette_buffer, unsigned length)
{
    int fd, retval;
    unsigned bytes;
    char *path = getenv("HPAL");

    if (!path) return FALSE;
    if (_dos_open(path, O_RDONLY, &fd)) return FALSE;
    retval = (_dos_read(fd, palette_buffer, length, &bytes) || bytes !=length) ?
        FALSE : TRUE;
    _dos_close(fd);
    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\pstrlen.asm ===
;***
;* $Workfile:   pstrlen.asm  $
;* $Revision:   1.2  $
;*   $Author:   Dave Sewell  $
;*     $Date:   06 Sep 1990 14:49:40  $
;*
;*  pstrlen.asm     Alan Butt	May 12, 1988
;*
;*  String length function using pascal calling conventions
;*

%               .MODEL memmodel

        IF  @CodeSize
                .CODE   PARAGON_TEXT
        ELSE
                .CODE
        ENDIF
            
@pstrlen        PROC
                PUBLIC  @pstrlen

;   extern unsigned int _fastcall pstrlen(char near *str);
;*
;*  string length with _fastcall calling conventions
;*

                push    di
	            push    ds
	            pop     es
	            mov     di, bx

	            xor     ax, ax
	            mov     cx, -1
	            repne   scasb
	            mov     ax, cx
	            not     ax
	            dec     ax

                pop     di
	            ret

@pstrlen        ENDP

        	    END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\memcpyf.asm ===
;***
;* $Workfile:   memcpyf.asm  $
;* $Revision:   1.0  $
;*   $Author:   Dave Sewell  $
;*     $Date:   28 Apr 1989 16:51:08  $
;***


    INCLUDE dos.mac

    TEXTSEG

PASCALDEF   memcpyf

;* NAME
;*	memcpyf -- Copy a block of memory from a far buffer.
;*
;* SYNOPSIS
;*	extern void pascal memcpyf(void *dest, const void far *src, int count);
;*	void *dest;		Pointer to destination area of memory for move
;*	const void far *src;	Pointer to source area of memory
;*	int count;		Number of bytes to move

	    procent
	IF  LDATA
	    les     di, DWORD PTR [BP + X + I + FDP]
	ELSE
	    push    ds
	    pop     es
	    mov     di, WORD PTR [BP + X + I + FDP]
	ENDIF
	    push    ds
	    lds     si, DWORD PTR [BP + X + I]
	    mov     cx, [BP + X]
	    jcxz    memcpyf_ret 		;Ignore count of zero

	rep movs    BYTE PTR ES:[DI], BYTE PTR DS:[SI]

memcpyf_ret:
	    pop     ds
	    procret DP+FDP+I

PASCALEND  memcpyf

    TEXTEND

    END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\readtick.asm ===
;***
;* $Workfile:   readtick.asm  $
;* $Revision:   1.2  $
;*   $Author:   Dave Sewell  $
;*     $Date:   10 Sep 1990 13:34:30  $
;*
;* "read_ticks" routine to read the 16-bit timer.
;***

%		.MODEL memmodel, language

TIMER_0 	EQU	40H	    ;8253 counter 0 port
TIMER_CTL	EQU	43H	    ;8253 control port
TIMER_SET	EQU	00110100B   ;8253 Counter 0, set LOB/HOB, mode 2, binary
TIMER_0_LATCH	EQU	00H	    ;8253 cmd to save channel 0 current count

    EXTRN   NULL_PROC:FAR
                IF	@CodeSize
		            .CODE	PARAGON_TEXT
                ELSE
	            .CODE
                ENDIF

loc_null_proc	PROC	NEAR

		ret

loc_null_proc	ENDP

fread_ticks PROC    FAR

;*	extern	unsigned int far pascal fread_ticks(void);

	    call    read_ticks
	    ret

fread_ticks ENDP

read_ticks  PROC    NEAR

;* NAME
;*	read_ticks -- Return high resolution timer information.
;*
;* SYNOPSIS
;*	time = read_ticks();
;*
;*	unsigned int time;	Current number of ticks (0.838 microseconds).
;*
;* DESCRIPTION
;*	Routine current value in 8253 timer.
;*
;*	NOTE:  values count DOWN instead of up, as they do in "ticks()".
;*
;*	extern	unsigned int near read_ticks(void);

	    PUSHF
	    CLI
	    MOV     AL, TIMER_0_LATCH
	    OUT     TIMER_CTL, AL	;Latch current count in 8253
	    CALL    NULL_PROC
	    IN	    AL, TIMER_0 	;Get low order byte
	    MOV     AH, AL		;Save it in AH
	    CALL    NULL_PROC    	;Insure 5 clocks for 8253 recovery time
	    IN	    AL, TIMER_0 	;Get high order byte
	    POPF
	    XCHG    AH, AL		;Get high, low bytes in right order
	    RET 			;Return value in AX

read_ticks  ENDP

	    END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\scrsave.c ===
#include "osdep.h"
#include "umfunc.h"
#include "screen.h"

static int screen_mode_switched;
static unsigned original_cursor_value;
static unsigned original_cursor_location;
static byte _far screen_buffer[2 * 80 * 50];

void _far _pascal init_screen(void)
{
    screen_mode_switched = init_scr();
    if (!screen_mode_switched)
        save_zone(coord(0, 0), boxsize(scr_rows, scr_cols), screen_buffer);
    original_cursor_value = cursor_value;
    original_cursor_location = cursor_location;
}

void _far _pascal restore_screen(void)
{
    restore_scr(screen_mode_switched);   // this is a far call.
    if (!screen_mode_switched) {
        restore_zone(coord(0, 0), boxsize(scr_rows, scr_cols), screen_buffer);
        locate(original_cursor_location);
        restore_cursor(original_cursor_value);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\setcbrk.asm ===
;***
;* $Workfile:   setcbrk.asm  $
;* $Revision:   1.0  $
;*   $Author:   Dave Sewell  $
;*     $Date:   28 Apr 1989 16:52:14  $
;*
;* Routine to set Control Break address.
;*****************************************************************************

INCLUDE     dos.mac

	    DATASEG
cbreak	    DB	    ?	    ;Initial state of Control-Break checking
	    DATAEND

	    TEXTSEG

cbrk	    PROC    FAR

	    iret	    ;Ignore Control-C

cbrk	    ENDP

PUBPROCDEF  setcbrk
;	extern void cdecl setcbrk(void);
	    procent
	    mov     ax, 3300H
	    INT     21H
	    mov     cbreak, dl
	    push    ds
	    mov     dx, OFFSET cbrk
	    push    cs
	    pop     ds
	    mov     ax, 2523H	    ;Set INT 23 vector
	    int     21H

	    mov     ax, 3301H
	    mov     dl, 0
	    INT     21H 	    ;Disable Control-Break handling

	    pop     ds
	    procret

PUBPROCEND  setcbrk

PUBPROCDEF  resetcbrk
;	extern void cdecl resetcbrk(void);

	    procent

	    mov     ax, 3301H
	    mov     dl, cbreak
	    INT     21H
	    procret

PUBPROCEND  resetcbrk

	    TEXTEND

	    END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\strrepc.asm ===
;***
;* $Workfile:   strrepc.asm  $
;* $Revision:   1.0  $
;*   $Author:   Dave Sewell  $
;*     $Date:   28 Apr 1989 16:52:44  $
;*
;* Replace all occurences of a particular character within a string with
;* another character.
;***

INCLUDE dos.mac

	TEXTSEG

PASCALDEF   strrepc
;***
;* strrepc -- Replace occurrences of a character within a string.
;*
;* extern  void pascal strrepc(char *str, int c, int repc);
;*
;* char *str;	    pointer to target string
;* int	c;	    character in the string to replace
;* int	repc;	    replacement character
;*
;***

str	    EQU     X + I + I
c	    EQU     X + I
repc	    EQU     X

	    procent
    IF	    LDATA
	    PUSH    DS
	    LDS     SI, [BP + str]
    ELSE
	    MOV     SI, [BP + str]
    ENDIF
	    MOV     AH, BYTE PTR [BP + c]
	    MOV     BL, BYTE PTR [BP + repc]

RepLoop:    LODS    BYTE PTR DS:[SI]
	    OR	    AL, AL
	    JZ	    RepDone

	    CMP     AL, AH
	    JNE     RepLoop

	    MOV     [SI - 1], BL    ;Replace target character
	    JMP     RepLoop

RepDone:
    IF	LDATA
	    POP     DS
    ENDIF
	    procret DP + I + I

PASCALEND   strrepc

	TEXTEND

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\strlenf.asm ===
;***
;* $Workfile:   strlenf.asm  $
;* $Revision:   1.1  $
;*   $Author:   Dave Sewell  $
;*     $Date:   09 Oct 1989 11:56:14  $
;*
;*  strlenf.asm      Alan Butt   April 26, 1988
;*
;*  String length routine for far pointers.
;*

%               .MODEL  memmodel, PASCAL

            IF  @CodeSize
                .CODE   PARAGON_TEXT
            ELSE
                .CODE
            ENDIF


;   extern unsigned int pascal strlenf(char far *str);
;*
;*  string length of far string
;*
strlenf         PROC    USES DI, str:FAR PTR BYTE

                les     di, str
                xor     al, al
                mov     cx, -1

                repne   scasb

                mov     ax, cx
                not     ax
                dec     ax

                ret

strlenf         ENDP

                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\strtcpy.asm ===
;***
;* $Workfile:   strtcpy.asm  $
;* $Revision:   1.0  $
;*   $Author:   Dave Sewell  $
;*     $Date:   28 Apr 1989 16:52:48  $
;*
;* Assembly language version of "strtcpy".
;*
;* Copy a string and truncate (force trailing null) if needed.	This function
;* operates just like "strcpy", except that a buffer length is passed also,
;* and the function insures that the string is truncated (if necessary) to
;* fit in the buffer.  There will ALWAYS be a trailing null in the destination
;* buffer (unless a zero is passed as the buffer length).
;*
;* NOTE:  this function is NOT identical to the "strtcpy" function in the
;* LDS C-Plus library.	The LDS version null pads the entire buffer if the
;* string is shorter than the buffer length.  This version copies one and
;* only one null into the destination buffer, and leaves the rest of the
;* buffer (if any) unchanged.
;***

	INCLUDE dos.mac

			TEXTSEG

;*  void pascal strtcpy(dest, src, count)
;*  register char *dest;
;*  register char *src;
;*  register unsigned count;
;*  {
;*	if (count) {
;*			count--;		    /* Reserve one byte for trailing null. */
;*		while (count-- && *src) *dest++ = *src++;
;*		*dest = '\0';
;*	}
;*  }
;*
;*  extern void pascal strtcpy(char *dest, char *src, unsigned count);

dest	EQU	X + I + DP
src	EQU	X + I
count	EQU	X

PASCALDEF   strtcpy

	    procent
    IF	    LDATA
	    PUSH    DS
	    LES     DI, [BP + dest]
	    LDS     SI, [BP + src]
    ELSE
	    PUSH    DS
	    POP     ES
	    MOV     DI, [BP + dest]
	    MOV     SI, [BP + src]
    ENDIF
	    MOV     CX, [BP + count]
	    JCXZ    cpy_done

	    DEC     CX

cpy_loop:   JCXZ    plant_null

	    LODSB
	    STOSB
	    OR	    AL, AL
	    JZ	    cpy_done

	    LOOP    cpy_loop

plant_null: XOR     AL, AL
	    MOV     ES:[DI], AL

cpy_done:
	IF  LDATA
	    POP     DS
	ENDIF
	    procret DP + DP + I

PASCALEND   strtcpy


	TEXTEND

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\screen.c ===
/***
* $Workfile:   screen.c  $
* $Revision:   1.1  $
*   $Author:   Dave Sewell  $
*     $Date:   24 Apr 1990  7:48:44  $
*
* Text mode screen access routines for IBM screen memory compatible machines.
***/

#include "osdep.h"
#include <bios.h>
#include <string.h>
#include "screen.h"
#include "umfunc.h"

#define MONO_SEG    0xB000	    /* Segment of monochrome display memory */
#define COLOR_SEG   0xB800	    /* Segment of color display memory	    */

#define MAX_ATTRIBS 6
#define MAX_CURSORS 4

byte const _near _cdecl scr_rows = 25;
byte const _near _cdecl scr_cols = 80;
byte near cdecl force_mono   = FALSE;
byte near cdecl retrace_wait = FALSE;
unsigned short near cdecl display_segment = MONO_SEG;
unsigned short near cdecl display_offset  = 0;
unsigned short near cdecl on_cursor_value;    /* Value needed to turn cursor on.  */
unsigned short near cdecl off_cursor_value;   /* Value needed to turn cursor off. */

static int attrib_stack[MAX_ATTRIBS];
static int asp = 0;			/* Attribute stack pointer.	    */

static struct {
    unsigned value;
    unsigned location;
} cursor_stack[MAX_CURSORS];

static int csp = 0;

void _fastcall push_cursor(int on_flag, int location)
{
    if (csp < MAX_CURSORS) {
        cursor_stack[csp].value    = cursor_value;
        cursor_stack[csp].location = cursor_location;
        csp++;
    }
    if (on_flag) cursor_on();
    else cursor_off();
    locate(location);
}

void pascal pop_cursor()
{
    if (csp) {
        csp--;
        restore_cursor(cursor_stack[csp].value);
        locate(cursor_stack[csp].location);
    }
}


void _fastcall push_attribute(new_attribute)
int new_attribute;
{
    if (asp < MAX_ATTRIBS) attrib_stack[asp++] = _attrib;
    else new_attribute |= BLINKING;	/* Stack overflow - indicate w/blink*/
    set_attribute(new_attribute);
}

void pascal pop_attribute()
{
    if (asp) set_attribute(attrib_stack[--asp]);
    else set_attribute( color(RED, WHITE) | BLINKING );
}

void _fastcall fill_attr(int ulpos, int height_width, int c, int attrib)
{
    set_attribute(attrib);
    fill(ulpos, height_width, c);
}

void _fastcall dispstr_attr(int pos, byte far *buff, int attr)
{
    set_attribute(attr);
    dispstr(pos, buff);
}

void _fastcall dispmem_attr(int pos, byte far *buff, int cnt, int attrib)
{
    set_attribute(attrib);
    dispmem(pos, buff, cnt);
}

void _fastcall dispstr(int pos, byte far *buff)
{
    dispmem(pos, buff, strlenf(buff));
}

void _fastcall dispchar(int pos, int c)
{
    dispmem(pos, (byte far *) &c, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\scrmem.asm ===
;***
;* $Workfile:   scrmem.asm  $
;* $Revision:   1.3  $
;*   $Author:   Dave Sewell  $
;*     $Date:   11 Sep 1990  8:46:08  $
;***

%               .MODEL memmodel, PASCAL

MOTOROLA_6845   EQU     3DAH

REVERSE_BIT     EQU     1
UNDERLINE_BIT   EQU     2
NORMAL_BIT      EQU     4
BOLD_BIT        EQU     8

BIOS_SEG    SEGMENT AT 40H

            ORG     49H
crt_mode    DB      ?
crt_cols    DW      ?
crt_len     DW      ?
crt_start   DW      ?
cursor_posn DW      ?

BIOS_SEG    ENDS

                .DATA?
                PUBLIC  HerculesInColor ; Only referenced in initscr.asm
                PUBLIC  _desqview
                PUBLIC  __attrib
                PUBLIC  _cursor_column
                PUBLIC  _cursor_row
                PUBLIC  _cursor_location
                PUBLIC  _cursor_value

                PUBLIC  is_mono

HerculesInColor DB      ?               ; Non-zero if InColor card present
_desqview       DB      ?
is_mono         DB      ?

_cursor_location    LABEL   WORD
_cursor_column  DB      ?
_cursor_row     DB      ?

_cursor_value   DW      ?

__attrib        DW      ?

                .DATA
                EXTRN   _display_segment:WORD
                EXTRN   _display_offset:WORD
                EXTRN   _retrace_wait:BYTE
                EXTRN   _force_mono:BYTE
                EXTRN   _on_cursor_value:WORD
                EXTRN   _off_cursor_value:WORD

old_video_mode  DB      0FFH

            IF  @CodeSize
                .CODE   PARAGON_TEXT
            ELSE
                .CODE
            ENDIF

topview         DB      ?               ;Put this in code segment for easy ref.

                PUBLIC  fix_attribute

;*** The following macro generates code to wait for horizontal retrace
;*** intervals.  This is necessary to prevent screen snow when using the
;*** IBM color adapter.  Interrupts are disabled during the wait.
;*** DX must have the address of the Motorola 6845 status port.
;*** AL is clobbered.

RetraceWait     MACRO
                LOCAL   WaitForLow, WaitForHigh

WaitForLow:     IN      AL, DX
                RCR     AL, 1
                JC      WaitForLow

                CLI

WaitForHigh:    IN      AL, DX
                RCR     AL, 1
                JNC     WaitForHigh

                ENDM

TopviewUpdate   PROC    NEAR

                cmp     cs:topview, 0
                jz      @F

                push    ax
                push    bp
                push    di
                push    si
                mov     ah, 0FFH
                int     10H
                pop     si
                pop     di
                pop     bp
                pop     ax

@@:             ret

TopviewUpdate   ENDP

SetTopView      PROC    FAR

                mov     topview, al
                ret

SetTopView      ENDP

update_cursor   PROC    NEAR    USES AX DX

;Enter with DX = cursor position, returns DI = offset

                mov     al, 160
                mul     dh
                shl     dl, 1
                xor     dh, dh
                add     ax, dx
                mov     di, ax
                add     di, _display_offset
                ret

update_cursor   ENDP

locate          PROC    USES BP DI SI, row_col:WORD
;***
;* locate -- locate cursor
;*
;* extern void pascal locate(int row_col);
;*
;* int row;         desired screen row (0 - 24)
;* int column;      screen column (0 - 79)
;***

                mov     dx, row_col
                mov     WORD PTR _cursor_column, dx
                MOV     AH, 2               ;locate cursor bios function
                XOR     BH, BH              ;page zero

                INT     10H

                ret

locate          ENDP

set_cursor      PROC    NEAR    USES BP DI SI

                mov     _cursor_value, cx
                mov     ah, 1
                int     10h
                ret

set_cursor      ENDP

cursor_on       PROC    
;***
;* cursor_on -- turn on cursor
;*
;* extern void pascal cursor_on(void);
;***

                mov     cx, _on_cursor_value
                call    set_cursor
                ret

cursor_on       ENDP

cursor_off      PROC    USES BP DI SI
;***
;* cursor_off -- turn off cursor
;*
;* extern void pascal cursor_off(void);
;***

                mov     cx, _off_cursor_value
                call    set_cursor
                ret

cursor_off      ENDP

restore_cursor  PROC    value:WORD
;***
;* restore_cursor -- restore cursor to specified value
;*
;* extern void pascal restore_cursor(unsigned value);
;***

                mov     cx, value
                call    set_cursor
                ret

restore_cursor  ENDP

set_attribute   PROC    attr:WORD
;
; extern void pascal set_attribute(int attr);

                mov     ax, attr
                mov     __attrib, ax
                ret

set_attribute   ENDP

dispmem         PROC    USES    DI SI DS, pos:WORD, buff:FAR PTR, cnt:WORD
;
; extern void pascal dispmem(int pos, byte far *buff, int cnt);

                mov     ax, __attrib
                call    fix_attribute       ;Fix attribute if force_mono set
                mov     dx, pos
                call    update_cursor       ;Now DI has screen offset
                mov     bx, _display_segment
                mov     es, bx
                mov     cx, cnt
                mov     bl, _retrace_wait   ;Save retrace wait flag
                lds     si, buff

                mov     dx, MOTOROLA_6845   ;Address of 6845 status register
                jcxz    dispmem_ret         ;Insure we have something

                or      bl, bl              ;Need to wait for retrace?
                jnz     slow_disp           ;Yes -- Go Do it

fast_disp:      lodsb                       ;Get  a byte of text
                stosw                       ;Save out text & attribute
                loop    fast_disp           ;Go for next char.

                jmp     short dispmem_ret   ;All done

slow_disp:      lodsb                       ;Get a byte of text
                mov     bl, al              ;Save character/attribute

                RetraceWait

                mov     al, bl              ;Recover the character
                stosw                       ;Store character and attribute
                sti                         ;Enable interrupts again
                loop    slow_disp

dispmem_ret:    call    TopviewUpdate
                ret

dispmem         ENDP

clear           PROC    USES DI SI, ulpos:WORD, lrpos:WORD

;extern void pascal clear(int ulpos, int lrpos);

                mov     ax, __attrib
                call    fix_attribute
                mov     bh, ah
                mov     dx, lrpos
                mov     cx, ulpos
                xor     al, al
                mov     ah, 6

                INT     10H

                ret

clear           ENDP

scroll          PROC    USES DI SI, \
                ulpos:WORD, lrpos:WORD, attr:WORD, count:BYTE, \
                direction:WORD

;extern void pascal scroll(int ulpos, int lrpos, int attr, int count, int direction);
;
; int ulpos;    Position of upper left corner
; int lrpos;    Position of lower right corner
; int attrib;   Attribute to use for filling
; int count;    Number of lines to scroll
; int direction;    1 = down, 0 = up

                mov     cx, ulpos
                mov     dx, lrpos
                mov     ax, attr
                call    fix_attribute
                mov     bh, ah
                mov     al, count
                mov     ah, 6
                shr     BYTE PTR direction, 1
                adc     ah, 0                   ;Make it a 7 if DOWN specified
                INT     10H
                ret

scroll          ENDP

fill            PROC    USES DI SI, ulpos:WORD, height_width:WORD, fill_ch:BYTE

;extern void pascal fill(int ulpos, int height_width, int c);

                mov     ax, _display_segment
                mov     es, ax
                mov     dx, ulpos
                call    update_cursor
                mov     si, di              ;Keep destination ptr in SI
                mov     dx, height_width    ;Get height/width pair
                or      dh, dh
                jz      fill_done

                or      dl, dl
                jz      fill_done

                mov     ax, __attrib         ;Get attribute
                call    fix_attribute
                mov     al, fill_ch         ;Get character
                mov     bx, 2 * 80          ;Length of a screen row in bytes
                xor     ch, ch

fill_loop:      mov     di, si              ;Set destination pointer
                mov     cl, dl              ;Set up count
                push    di
                push    cx
                cmp     _retrace_wait, 0
                je      fast_fill

                push    bx
                push    dx
                mov     dx, MOTOROLA_6845   ;Address of 6845 status register
                mov     bl, al

slow_fill:      RetraceWait
                mov     al, bl
                stosw
                sti
                loop    slow_fill

                pop     dx
                pop     bx
                jmp     short end_row

fast_fill:      rep     stosw               ;Fill the line

end_row:        pop     cx
                pop     di
                dec     dh                  ;Decrement # of lines left
                jz      fill_done           ;All done!

                add     si, bx              ;Point to start of next line
                jmp     fill_loop           ;Go back & fill next line

fill_done:      call    TopviewUpdate
                ret

fill            ENDP

shade           PROC    USES DI SI, ulpos:WORD, height_width:WORD

; extern void pascal shade(int ulpos, int height_width);
;
; Change the attribute of a display zone
;

                mov     ax, _display_segment
                mov     es, ax
                mov     dx, ulpos
                call    update_cursor
                mov     si, di              ;Keep destination ptr in SI
                mov     dx, height_width    ;Get height/width pair
                mov     ax, __attrib         ;Get attribute
                call    fix_attribute
                mov     al, ah
                mov     bx, 2 * 80          ;Length of a screen row in bytes
                xor     ch, ch

shade_loop:     mov     di, si                  ;Set destination pointer
                mov     cl, dl                  ;Set up count
                push    di
                push    cx
                cmp     _retrace_wait, 0
                je      shade_each

                push    bx
                push    dx
                mov     dx, MOTOROLA_6845   ;Address of 6845 status register
                mov     bl, al

slow_shade:     inc     di                      ;Skip past char
                RetraceWait                     ;Wait for retrace
                mov     al, bl
                stosb
                sti
                loop    slow_shade

                pop     dx
                pop     bx
                jmp     short shade_next

shade_each:     inc     di                      ;Skip past char
                stosb                           ;Store attribute
                loop    shade_each              ;Do until end of line

shade_next:     pop     cx
                pop     di
                dec     dh                      ;Decrement # of lines left
                jz      shade_done              ;All done!

                add     si, bx                  ;Point to start of next line
                jmp     short shade_loop        ;Go back & fill next line

shade_done:     call    TopviewUpdate
                ret

shade           ENDP

save_zone       PROC    USES DI SI DS, \
                ulpos:WORD, height_width:WORD, buff:FAR PTR

;extern void pascal save_zone(int ulpos, int height_width, byte far *buff);

; Copy the display info in a zone into a far buffer
;
                mov     dx, ulpos
                call    update_cursor
                mov     cx, di
                mov     dx, height_width        ;Height, width to DX
                les     di, buff                ;Buffer pointer to ES:[DI]
                mov     bp, cx                  ;Screen offset goes in BP
                mov     ah, _retrace_wait       ;Get retrace flag to AH
                mov     ds, _display_segment    ;Point to screen memory
                mov     bx, 80 * 2              ;Length of 1 line in bytes
                xor     ch, ch

save_loop:      mov     si, bp                  ;Set destination pointer
                mov     cl, dl                  ;Set up count
                or      ah, ah
                jz      fast_save

                push    dx
                mov     dx, MOTOROLA_6845

slow_save:      RetraceWait
                movsw
                sti
                loop    slow_save

                pop     dx
                jmp     short save_next

fast_save:
            rep movsw                           ;Copy the line

save_next:      dec     dh                      ;Decrement # of lines left
                jz      save_done               ;All done!

                add     bp, bx                  ;Point to start of next line
                jmp     short save_loop         ;Go back & fill next line

save_done:      ret

save_zone       ENDP

restore_zone    PROC    USES DI SI DS, \
                ulpos:WORD, height_width:WORD, buff:FAR PTR

;extern void pascal restore_zone(int ulpos, int height_width, byte far *buff);

;
; Restore a display zone from a buffer
;

                mov     dx, ulpos
                call    update_cursor
                mov     cx, di                  ;Temporarily put offset in CX
                mov     dx, height_width        ;Height, width to DX
                mov     es, _display_segment    ;Point to screen memory
                mov     ah, _retrace_wait       ;Get retrace flag to AH
                lds     si, buff                ;Buffer pointer to DS:[SI]
                mov     bp, cx                  ;Screen offset goes in BP
                mov     bx, 80 * 2              ;Length of 1 line in bytes
                xor     ch, ch

rest_loop:      mov     di, bp                  ;Set destination pointer
                mov     cl, dl                  ;Set up count
                push    di
                push    cx
                or      ah, ah
                jz      fast_rest

                push    bx
                push    dx
                mov     dx, MOTOROLA_6845

slow_rest:      lodsw
                mov     bx, ax
                RetraceWait
                mov     ax, bx
                stosw
                sti
                loop    slow_rest

                pop     dx
                pop     bx
                jmp     short rest_next

fast_rest:
            rep movsw                           ;Copy the line

rest_next:      pop     cx
                pop     di
                dec     dh                      ;Decrement # of lines left
                jz      rest_done               ;All done!

                add     bp, bx                  ;Point to start of next line
                jmp     short rest_loop         ;Go back & fill next line

rest_done:      call    TopviewUpdate
                ret

restore_zone    ENDP


fix_attribute   PROC    NEAR

;Entry:
;   AL = desired attribute for color screen
;   AH may have bits set indicating monochrome adapter attributes as follows:
;       01 - reverse video
;       02 - underline
;Return:
;   AL and AH = physical screen attribute
;
                mov     __attrib, ax
                cmp     is_mono, 0
                jz      color_adapter

;--- Using B000 segment.  Is this a Hercules InColor Card?

                cmp     HerculesInColor, 0
                jne     color_adapter           ;Then leave attributes alone

                test    ah, UNDERLINE_BIT
                jnz     underline

                jmp short   other_tests

;--- Set for underline

underline:      and     al, 88H
                or      al, 1
                jmp     short fix_ret

color_adapter:  cmp     _force_mono, 0
                je      fix_ret

other_tests:    test    ah, REVERSE_BIT
                jnz     mono_reverse

                test    ah, NORMAL_BIT
                jnz     mono_normal

                test    ah, BOLD_BIT
                jnz     mono_bold

                or      al, 07H
                and     al, 8FH
                jmp     short fix_ret

mono_normal:    mov     al, 07H
                jmp short   fix_ret

mono_bold:      mov     al, 0FH
                jmp short   fix_ret

mono_reverse:   or      al, 70H
                and     al, 0F0H

fix_ret:        mov     ah, al
                ret

fix_attribute   ENDP

                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\auxcow.c ===
/*
  -- auxcow.c : COW auxiliary code
  -- NOTE : normally use this code as-is, but you can modify it if you have
  a more advance memory allocation scheme.
*/


/* These must be exported */

VOID   * FAR PASCAL PbAllocWork(WORD);
VOID   FAR PASCAL FreeWork(VOID *);

/* For FAR Work buffer */

VOID FAR *  FAR PASCAL LpbAllocWorkFar(WORD);
VOID FAR PASCAL FreeWorkFar(VOID FAR *);

/* Fake LMEM */

VOID ** FAR PASCAL PpvAllocCb(WORD, WORD);
VOID    FAR PASCAL FreePpv(WORD, VOID **);
BOOL    FAR PASCAL FReallocPpv(WORD, VOID **, WORD);
BOOL    FAR PASCAL FCheckHandle(WORD, VOID **);
WORD    FAR PASCAL CbSizePpv(WORD, VOID **);


#ifdef BASED
BOOL FAR PASCAL WndSegInit (VOID);
BOOL FAR PASCAL WndSegDestroy (VOID);
#endif


#ifdef BASED

BOOL FAR PASCAL WndSegInit ()
{
  pWndSeg = _bheapseg ( 10000 );

  if ( pWndSeg == _NULLSEG )
    return ( FALSE );

  return ( TRUE );
}

BOOL FAR PASCAL WndSegDestroy ()
{
  if ( _bfreeseg ( pWndSeg ) != 0 )
     return ( FALSE );  

  return ( TRUE );  
}


PWND FAR PASCAL
PbAllocWnd (cb)
WORD cb;
{
  PWND pwnd;

  pwnd = (PWND)_bmalloc ( pWndSeg, cb );

  if ( pwnd == _NULLOFF )
    return ( NULL );

  return ( pwnd );
}


VOID FAR PASCAL
FreeWnd ( pwnd )
PWND pwnd;
{
  _bfree ( pWndSeg, pwnd );
}

#else


PWND FAR PASCAL
PbAllocWnd (cb)
WORD cb;
{
  PWND pwnd;

  pwnd = (PWND)PbAllocWork(cb);

  return ( pwnd );
}


VOID FAR PASCAL
FreeWnd ( pwnd )
PWND pwnd;
{
  FreeWork( pwnd );
}


#endif

// Each app should have it's own Exit routine.  Various debugging libs
//  call here to abort cleanly when errors occur.


VOID FAR PASCAL
Exit(ex)
int ex;
{

  if (ex == 0)
    {
    FEnableMouse(FALSE);
    EndCow(!FRestoreOriginalScreen());
    }
  else
    EndCow(FALSE);  /* don't clear screen or restore because
                 there's probably error msg */

  exit(ex);
}


//      Work Buffer Routines

//  -- a near work buffer MUST be provided by the application
//  -- using malloc() / free() really screws up the C-library memory manager


#define cbBufferMax 8000

BYTE rgbBuffer[cbBufferMax];
BYTE *pbBuffer = rgbBuffer;


VOID * FAR PASCAL
PbAllocWork(cb)
WORD cb;
{
  BYTE *pbRet = pbBuffer;

  if (cb & 1)
    cb++;   // make even to keep allocs on word boundary 

  pbBuffer += cb;

  if (pbBuffer > &rgbBuffer[cbBufferMax])
    {
    // trap before out of memory 

#ifdef DEBUG
    printf("Work Buffer Full\n");
#endif /*DEBUG*/

    Exit(100);    // death 
    }

  return pbRet;
}



VOID FAR PASCAL
FreeWork(pv)
VOID *pv;
{
  pbBuffer = pv;
}



VOID FAR * FAR PASCAL
LpbAllocWorkFar(cb)
//
//  -- allocation for screen saves
//  -- NOTE : this routine can not fail !!!!!
WORD cb;
{

#if 0
  ++cLpbAllocWorkFar;
  return _fmalloc(cb);
#else
  WORD FAR *lpw;
  HANDLE hmem;

  if ((hmem = GlobalAlloc(0, (DWORD) (cb+2))) == NULL)
    {
    printf("far alloc fail\n");
    Exit(1);
    }

  lpw = (WORD FAR *) GlobalLock(hmem);

  *lpw++ = hmem;    /* save handle */


  return lpw;
#endif

}


//  -- free far work buffer

VOID FAR PASCAL
FreeWorkFar(lpb)
VOID FAR *lpb;
{

#if 0
  _ffree(lpb);

#else

  HANDLE hmem = *(((WORD FAR *)lpb) - 1);

  GlobalUnlock(hmem);

  GlobalFree(hmem);

#endif
}



//  -- fake local memory handler : for SDM and SMM
//  -- in the future we may "fix" SDM so that near pointers will be used
//  instead of handles
//  -- we use malloc() / free() to allocate fixed blocks and keep a master
//  pointer table for the extra level of indirection

#define cpvMaster 32

VOID *rgpvMaster[cpvMaster];

//  -- return handle to a memory block

VOID ** FAR PASCAL
PpvAllocCb(sb, cb)
WORD sb;      // ignored
WORD cb;      // size of block 
{
  REGISTER VOID **ppv;

  Unreferenced(sb);

  for (ppv = &rgpvMaster[0]; *ppv != NULL; ppv++);

  *ppv = malloc(cb);

  if (*ppv == NULL)
    return(NULL);
  else
    return(ppv);
}


//  -- free local block (return NULL)

VOID FAR PASCAL
FreePpv(sb, ppv)
WORD sb;        // ignored 
REGISTER VOID ** ppv;
{
  Unreferenced(sb);

  free(*ppv);

  *ppv = NULL;
}

//  -- reallocate block with new size, changing master pointer

BOOL FAR PASCAL
FReallocPpv(sb, ppv, cb)
WORD sb;
REGISTER VOID **ppv;
WORD cb;
{
  VOID *pv;

  Unreferenced(sb);

  if ((pv = realloc(*ppv, cb)) == NULL)
    return FALSE;
   else
    {
    *ppv = pv;
    return TRUE;
    }
}


//  -- check that this is a handle to a valid block

BOOL FAR PASCAL
FCheckHandle(sb, ppv)
WORD sb;
VOID **ppv;
{
  Unreferenced(sb);

  return(&rgpvMaster[0] <= ppv && ppv < &rgpvMaster[cpvMaster] &&
      *ppv != NULL);
}

//  -- return size of allocated block

WORD FAR PASCAL
CbSizePpv(sb, ppv)
WORD sb;
VOID **ppv;
{
  Unreferenced(sb);

  return(_msize(*ppv));
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\bseerr.h ===
/****************************** Module Header *****************************\
*
* Module Name: BSEERR.H
*
* This file includes the error codes for Base OS/2 applications.
*
* Copyright (c) 1987-1990, Microsoft Corporation. All rights reserved.
*
* ==========================================================================
*
* The following symbols are used in this file for conditional sections.
*
*   INCL_DOSERRORS -  OS/2 Errors         - only included if symbol defined
*
\**************************************************************************/
/*** Error codes */

#ifdef INCL_ERRORS

#define INCL_DOSERRORS

#endif /* INCL_ERRORS */

#ifdef INCL_DOSERRORS

#define NO_ERROR                        0

#define ERROR_INVALID_FUNCTION          1
#define ERROR_FILE_NOT_FOUND            2
#define ERROR_PATH_NOT_FOUND            3
#define ERROR_TOO_MANY_OPEN_FILES       4
#define ERROR_ACCESS_DENIED             5
#define ERROR_INVALID_HANDLE            6
#define ERROR_ARENA_TRASHED             7
#define ERROR_NOT_ENOUGH_MEMORY         8
#define ERROR_INVALID_BLOCK             9
#define ERROR_BAD_ENVIRONMENT           10
#define ERROR_BAD_FORMAT                11
#define ERROR_INVALID_ACCESS            12
#define ERROR_INVALID_DATA              13

#define ERROR_INVALID_DRIVE             15
#define ERROR_CURRENT_DIRECTORY         16
#define ERROR_NOT_SAME_DEVICE           17
#define ERROR_NO_MORE_FILES             18
#define ERROR_WRITE_PROTECT             19
#define ERROR_BAD_UNIT                  20
#define ERROR_NOT_READY                 21
#define ERROR_BAD_COMMAND               22
#define ERROR_CRC                       23
#define ERROR_BAD_LENGTH                24
#define ERROR_SEEK                      25
#define ERROR_NOT_DOS_DISK              26
#define ERROR_SECTOR_NOT_FOUND          27
#define ERROR_OUT_OF_PAPER              28
#define ERROR_WRITE_FAULT               29
#define ERROR_READ_FAULT                30
#define ERROR_GEN_FAILURE               31
#define ERROR_SHARING_VIOLATION         32
#define ERROR_LOCK_VIOLATION            33
#define ERROR_WRONG_DISK                34
#define ERROR_FCB_UNAVAILABLE           35
#define ERROR_SHARING_BUFFER_EXCEEDED   36
#define ERROR_NOT_SUPPORTED             50

#define ERROR_FILE_EXISTS               80
#define ERROR_DUP_FCB                   81
#define ERROR_CANNOT_MAKE               82
#define ERROR_FAIL_I24                  83
#define ERROR_OUT_OF_STRUCTURES         84
#define ERROR_ALREADY_ASSIGNED          85
#define ERROR_INVALID_PASSWORD          86
#define ERROR_INVALID_PARAMETER         87
#define ERROR_NET_WRITE_FAULT           88
#define ERROR_NO_PROC_SLOTS             89
#define ERROR_NOT_FROZEN                90
#define ERR_TSTOVFL                     91
#define ERR_TSTDUP                      92
#define ERROR_NO_ITEMS                  93
#define ERROR_INTERRUPT                 95
#define ERROR_TOO_MANY_SEMAPHORES       100
#define ERROR_EXCL_SEM_ALREADY_OWNED    101
#define ERROR_SEM_IS_SET                102
#define ERROR_TOO_MANY_SEM_REQUESTS     103
#define ERROR_INVALID_AT_INTERRUPT_TIME 104
#define ERROR_SEM_OWNER_DIED            105
#define ERROR_SEM_USER_LIMIT            106
#define ERROR_DISK_CHANGE               107
#define ERROR_DRIVE_LOCKED              108
#define ERROR_BROKEN_PIPE               109
#define ERROR_OPEN_FAILED               110
#define ERROR_BUFFER_OVERFLOW           111
#define ERROR_DISK_FULL                 112
#define ERROR_NO_MORE_SEARCH_HANDLES    113
#define ERROR_INVALID_TARGET_HANDLE     114
#define ERROR_PROTECTION_VIOLATION      115
#define ERROR_VIOKBD_REQUEST            116
#define ERROR_INVALID_CATEGORY          117
#define ERROR_INVALID_VERIFY_SWITCH     118
#define ERROR_BAD_DRIVER_LEVEL          119
#define ERROR_CALL_NOT_IMPLEMENTED      120
#define ERROR_SEM_TIMEOUT               121
#define ERROR_INSUFFICIENT_BUFFER       122
#define ERROR_INVALID_NAME              123
#define ERROR_INVALID_LEVEL             124
#define ERROR_NO_VOLUME_LABEL           125
#define ERROR_MOD_NOT_FOUND             126
#define ERROR_PROC_NOT_FOUND            127
#define ERROR_WAIT_NO_CHILDREN          128
#define ERROR_CHILD_NOT_COMPLETE        129
#define ERROR_DIRECT_ACCESS_HANDLE      130
#define ERROR_NEGATIVE_SEEK             131
#define ERROR_SEEK_ON_DEVICE            132
#define ERROR_IS_JOIN_TARGET            133
#define ERROR_IS_JOINED                 134
#define ERROR_IS_SUBSTED                135
#define ERROR_NOT_JOINED                136
#define ERROR_NOT_SUBSTED               137
#define ERROR_JOIN_TO_JOIN              138
#define ERROR_SUBST_TO_SUBST            139
#define ERROR_JOIN_TO_SUBST             140
#define ERROR_SUBST_TO_JOIN             141
#define ERROR_BUSY_DRIVE                142
#define ERROR_SAME_DRIVE                143
#define ERROR_DIR_NOT_ROOT              144
#define ERROR_DIR_NOT_EMPTY             145
#define ERROR_IS_SUBST_PATH             146
#define ERROR_IS_JOIN_PATH              147
#define ERROR_PATH_BUSY                 148
#define ERROR_IS_SUBST_TARGET           149
#define ERROR_SYSTEM_TRACE              150
#define ERROR_INVALID_EVENT_COUNT       151
#define ERROR_TOO_MANY_MUXWAITERS       152
#define ERROR_INVALID_LIST_FORMAT       153
#define ERROR_LABEL_TOO_LONG            154
#define ERROR_TOO_MANY_TCBS             155
#define ERROR_SIGNAL_REFUSED            156
#define ERROR_DISCARDED                 157
#define ERROR_NOT_LOCKED                158
#define ERROR_BAD_THREADID_ADDR         159
#define ERROR_BAD_ARGUMENTS             160
#define ERROR_BAD_PATHNAME              161
#define ERROR_SIGNAL_PENDING            162
#define ERROR_UNCERTAIN_MEDIA           163
#define ERROR_MAX_THRDS_REACHED         164
#define ERROR_MONITORS_NOT_SUPPORTED    165
#define ERROR_UNC_DRIVER_NOT_INSTALLED  166
#define ERROR_LOCK_FAILED               167
#define ERROR_SWAPIO_FAILED             168
#define ERROR_SWAPIN_FAILED             169
#define ERROR_BUSY                      170

#define ERROR_INVALID_SEGMENT_NUMBER    180
#define ERROR_INVALID_CALLGATE          181
#define ERROR_INVALID_ORDINAL           182
#define ERROR_ALREADY_EXISTS            183
#define ERROR_NO_CHILD_PROCESS          184
#define ERROR_CHILD_ALIVE_NOWAIT        185
#define ERROR_INVALID_FLAG_NUMBER       186
#define ERROR_SEM_NOT_FOUND             187
#define ERROR_INVALID_STARTING_CODESEG  188
#define ERROR_INVALID_STACKSEG          189
#define ERROR_INVALID_MODULETYPE        190
#define ERROR_INVALID_EXE_SIGNATURE     191
#define ERROR_EXE_MARKED_INVALID        192
#define ERROR_BAD_EXE_FORMAT            193
#define ERROR_ITERATED_DATA_EXCEEDS_64K 194
#define ERROR_INVALID_MINALLOCSIZE      195
#define ERROR_DYNLINK_FROM_INVALID_RING 196
#define ERROR_IOPL_NOT_ENABLED          197
#define ERROR_INVALID_SEGDPL            198
#define ERROR_AUTODATASEG_EXCEEDS_64k   199
#define ERROR_RING2SEG_MUST_BE_MOVABLE  200
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM  201
#define ERROR_INFLOOP_IN_RELOC_CHAIN    202
#define ERROR_ENVVAR_NOT_FOUND          203
#define ERROR_NOT_CURRENT_CTRY          204
#define ERROR_NO_SIGNAL_SENT            205
#define ERROR_FILENAME_EXCED_RANGE      206
#define ERROR_RING2_STACK_IN_USE        207
#define ERROR_META_EXPANSION_TOO_LONG   208
#define ERROR_INVALID_SIGNAL_NUMBER     209
#define ERROR_THREAD_1_INACTIVE         210
#define ERROR_INFO_NOT_AVAIL            211
#define ERROR_LOCKED                    212
#define ERROR_BAD_DYNALINK              213
#define ERROR_TOO_MANY_MODULES          214
#define ERROR_NESTING_NOT_ALLOWED       215

#define ERROR_BAD_PIPE                  230
#define ERROR_PIPE_BUSY                 231
#define ERROR_NO_DATA                   232
#define ERROR_PIPE_NOT_CONNECTED        233
#define ERROR_MORE_DATA                 234

#define ERROR_VC_DISCONNECTED           240

#define ERROR_INVALID_PROCID            303
#define ERROR_INVALID_PDELTA            304
#define ERROR_NOT_DESCENDANT            305
#define ERROR_NOT_SESSION_MANAGER       306
#define ERROR_INVALID_PCLASS            307
#define ERROR_INVALID_SCOPE             308
#define ERROR_INVALID_THREADID          309
#define ERROR_DOSSUB_SHRINK             310
#define ERROR_DOSSUB_NOMEM              311
#define ERROR_DOSSUB_OVERLAP            312
#define ERROR_DOSSUB_BADSIZE            313
#define ERROR_DOSSUB_BADFLAG            314
#define ERROR_DOSSUB_BADSELECTOR        315
#define ERROR_MR_MSG_TOO_LONG           316
#define ERROR_MR_MID_NOT_FOUND          317
#define ERROR_MR_UN_ACC_MSGF            318
#define ERROR_MR_INV_MSGF_FORMAT        319
#define ERROR_MR_INV_IVCOUNT            320
#define ERROR_MR_UN_PERFORM             321
#define ERROR_TS_WAKEUP                 322
#define ERROR_TS_SEMHANDLE              323
#define ERROR_TS_NOTIMER                324
#define ERROR_TS_HANDLE                 326
#define ERROR_TS_DATETIME               327
#define ERROR_SYS_INTERNAL              328
#define ERROR_QUE_CURRENT_NAME          329
#define ERROR_QUE_PROC_NOT_OWNED        330
#define ERROR_QUE_PROC_OWNED            331
#define ERROR_QUE_DUPLICATE             332
#define ERROR_QUE_ELEMENT_NOT_EXIST     333
#define ERROR_QUE_NO_MEMORY             334
#define ERROR_QUE_INVALID_NAME          335
#define ERROR_QUE_INVALID_PRIORITY      336
#define ERROR_QUE_INVALID_HANDLE        337
#define ERROR_QUE_LINK_NOT_FOUND        338
#define ERROR_QUE_MEMORY_ERROR          339
#define ERROR_QUE_PREV_AT_END           340
#define ERROR_QUE_PROC_NO_ACCESS        341
#define ERROR_QUE_EMPTY                 342
#define ERROR_QUE_NAME_NOT_EXIST        343
#define ERROR_QUE_NOT_INITIALIZED       344
#define ERROR_QUE_UNABLE_TO_ACCESS      345
#define ERROR_QUE_UNABLE_TO_ADD         346
#define ERROR_QUE_UNABLE_TO_INIT        347
#define ERROR_VIO_INVALID_MASK          349
#define ERROR_VIO_PTR                   350
#define ERROR_VIO_APTR                  351
#define ERROR_VIO_RPTR                  352
#define ERROR_VIO_CPTR                  353
#define ERROR_VIO_LPTR                  354
#define ERROR_VIO_MODE                  355
#define ERROR_VIO_WIDTH                 356
#define ERROR_VIO_ATTR                  357
#define ERROR_VIO_ROW                   358
#define ERROR_VIO_COL                   359
#define ERROR_VIO_TOPROW                360
#define ERROR_VIO_BOTROW                361
#define ERROR_VIO_RIGHTCOL              362
#define ERROR_VIO_LEFTCOL               363
#define ERROR_SCS_CALL                  364
#define ERROR_SCS_VALUE                 365
#define ERROR_VIO_WAIT_FLAG             366
#define ERROR_VIO_UNLOCK                367
#define ERROR_SGS_NOT_SESSION_MGR       368
#define ERROR_SMG_INVALID_SGID          369
#define ERROR_SMG_INVALID_SESSION_ID    369
#define ERROR_SMG_NOSG                  370
#define ERROR_SMG_NO_SESSIONS           370
#define ERROR_SMG_GRP_NOT_FOUND         371
#define ERROR_SMG_SESSION_NOT_FOUND     371
#define ERROR_SMG_SET_TITLE             372
#define ERROR_KBD_PARAMETER             373
#define ERROR_KBD_NO_DEVICE             374
#define ERROR_KBD_INVALID_IOWAIT        375
#define ERROR_KBD_INVALID_LENGTH        376
#define ERROR_KBD_INVALID_ECHO_MASK     377
#define ERROR_KBD_INVALID_INPUT_MASK    378
#define ERROR_MON_INVALID_PARMS         379
#define ERROR_MON_INVALID_DEVNAME       380
#define ERROR_MON_INVALID_HANDLE        381
#define ERROR_MON_BUFFER_TOO_SMALL      382
#define ERROR_MON_BUFFER_EMPTY          383
#define ERROR_MON_DATA_TOO_LARGE        384
#define ERROR_MOUSE_NO_DEVICE           385
#define ERROR_MOUSE_INV_HANDLE          386
#define ERROR_MOUSE_INV_PARMS           387
#define ERROR_MOUSE_CANT_RESET          388
#define ERROR_MOUSE_DISPLAY_PARMS       389
#define ERROR_MOUSE_INV_MODULE          390
#define ERROR_MOUSE_INV_ENTRY_PT        391
#define ERROR_MOUSE_INV_MASK            392
#define NO_ERROR_MOUSE_NO_DATA          393
#define NO_ERROR_MOUSE_PTR_DRAWN        394
#define ERROR_INVALID_FREQUENCY         395
#define ERROR_NLS_NO_COUNTRY_FILE       396
#define ERROR_NLS_OPEN_FAILED           397
#define ERROR_NLS_NO_CTRY_CODE          398
#define ERROR_NO_COUNTRY_OR_CODEPAGE    398
#define ERROR_NLS_TABLE_TRUNCATED       399
#define ERROR_NLS_BAD_TYPE              400
#define ERROR_NLS_TYPE_NOT_FOUND        401
#define ERROR_VIO_SMG_ONLY              402
#define ERROR_VIO_INVALID_ASCIIZ        403
#define ERROR_VIO_DEREGISTER            404
#define ERROR_VIO_NO_POPUP              405
#define ERROR_VIO_EXISTING_POPUP        406
#define ERROR_KBD_SMG_ONLY              407
#define ERROR_KBD_INVALID_ASCIIZ        408
#define ERROR_KBD_INVALID_MASK          409
#define ERROR_KBD_REGISTER              410
#define ERROR_KBD_DEREGISTER            411
#define ERROR_MOUSE_SMG_ONLY            412
#define ERROR_MOUSE_INVALID_ASCIIZ      413
#define ERROR_MOUSE_INVALID_MASK        414
#define ERROR_MOUSE_REGISTER            415
#define ERROR_MOUSE_DEREGISTER          416
#define ERROR_SMG_BAD_ACTION            417
#define ERROR_SMG_INVALID_CALL          418
#define ERROR_SCS_SG_NOTFOUND           419
#define ERROR_SCS_NOT_SHELL             420
#define ERROR_VIO_INVALID_PARMS         421
#define ERROR_VIO_FUNCTION_OWNED        422
#define ERROR_VIO_RETURN                423
#define ERROR_SCS_INVALID_FUNCTION      424
#define ERROR_SCS_NOT_SESSION_MGR       425
#define ERROR_VIO_REGISTER              426
#define ERROR_VIO_NO_MODE_THREAD        427
#define ERROR_VIO_NO_SAVE_RESTORE_THD   428
#define ERROR_VIO_IN_BG                 429
#define ERROR_VIO_ILLEGAL_DURING_POPUP  430
#define ERROR_SMG_NOT_BASESHELL         431
#define ERROR_SMG_BAD_STATUSREQ         432
#define ERROR_QUE_INVALID_WAIT          433
#define ERROR_VIO_LOCK                  434
#define ERROR_MOUSE_INVALID_IOWAIT      435
#define ERROR_VIO_INVALID_HANDLE        436
#define ERROR_VIO_ILLEGAL_DURING_LOCK   437
#define ERROR_VIO_INVALID_LENGTH        438
#define ERROR_KBD_INVALID_HANDLE        439
#define ERROR_KBD_NO_MORE_HANDLE        440
#define ERROR_KBD_CANNOT_CREATE_KCB     441
#define ERROR_KBD_CODEPAGE_LOAD_INCOMPL 442
#define ERROR_KBD_INVALID_CODEPAGE_ID   443
#define ERROR_KBD_NO_CODEPAGE_SUPPORT   444
#define ERROR_KBD_FOCUS_REQUIRED        445
#define ERROR_KBD_FOCUS_ALREADY_ACTIVE  446
#define ERROR_KBD_KEYBOARD_BUSY         447
#define ERROR_KBD_INVALID_CODEPAGE      448
#define ERROR_KBD_UNABLE_TO_FOCUS       449
#define ERROR_SMG_SESSION_NON_SELECT    450
#define ERROR_SMG_SESSION_NOT_FOREGRND  451
#define ERROR_SMG_SESSION_NOT_PARENT    452
#define ERROR_SMG_INVALID_START_MODE    453
#define ERROR_SMG_INVALID_RELATED_OPT   454
#define ERROR_SMG_INVALID_BOND_OPTION   455
#define ERROR_SMG_INVALID_SELECT_OPT    456
#define ERROR_SMG_START_IN_BACKGROUND   457
#define ERROR_SMG_INVALID_STOP_OPTION   458
#define ERROR_SMG_BAD_RESERVE           459
#define ERROR_SMG_PROCESS_NOT_PARENT    460
#define ERROR_SMG_INVALID_DATA_LENGTH   461
#define ERROR_SMG_NOT_BOUND             462
#define ERROR_SMG_RETRY_SUB_ALLOC       463
#define ERROR_KBD_DETACHED              464
#define ERROR_VIO_DETACHED              465
#define ERROR_MOU_DETACHED              466
#define ERROR_VIO_FONT                  467
#define ERROR_VIO_USER_FONT             468
#define ERROR_VIO_BAD_CP                469
#define ERROR_VIO_NO_CP                 470
#define ERROR_VIO_NA_CP                 471
#define ERROR_INVALID_CODE_PAGE         472
#define ERROR_CPLIST_TOO_SMALL          473
#define ERROR_CP_NOT_MOVED              474
#define ERROR_MODE_SWITCH_INIT          475
#define ERROR_CODE_PAGE_NOT_FOUND       476
#define ERROR_UNEXPECTED_SLOT_RETURNED  477
#define ERROR_SMG_INVALID_TRACE_OPTION  478
#define ERROR_VIO_INTERNAL_RESOURCE     479
#define ERROR_VIO_SHELL_INIT            480
#define ERROR_SMG_NO_HARD_ERRORS        481
#define ERROR_CP_SWITCH_INCOMPLETE      482
#define ERROR_VIO_TRANSPARENT_POPUP     483
#define ERROR_CRITSEC_OVERFLOW          484
#define ERROR_CRITSEC_UNDERFLOW         485
#define ERROR_VIO_BAD_RESERVE           486
#define ERROR_INVALID_ADDRESS           487
#define ERROR_ZERO_SELECTORS_REQUESTED  488
#define ERROR_NOT_ENOUGH_SELECTORS_AVA  489
#define ERROR_INVALID_SELECTOR          490
#define ERROR_SMG_INVALID_PROGRAM_TYPE  491
#define ERROR_SMG_INVALID_PGM_CONTROL   492
#define ERROR_SMG_INVALID_INHERIT_OPT   493
#define ERROR_VIO_EXTENDED_SG           494
#define ERROR_VIO_NOT_PRES_MGR_SG       495
#define ERROR_VIO_SHIELD_OWNED          496
#define ERROR_VIO_NO_MORE_HANDLES       497
#define ERROR_VIO_SEE_ERROR_LOG         498
#define ERROR_VIO_ASSOCIATED_DC         499
#define ERROR_KBD_NO_CONSOLE            500
#define ERROR_MOUSE_NO_CONSOLE          501
#define ERROR_MOUSE_INVALID_HANDLE      502
#define ERROR_SMG_INVALID_DEBUG_PARMS   503
#define ERROR_KBD_EXTENDED_SG           504
#define ERROR_MOU_EXTENDED_SG           505
#define ERROR_SMG_INVALID_ICON_FILE     506


#define ERROR_USER_DEFINED_BASE         0xF000

#define ERROR_I24_WRITE_PROTECT         0
#define ERROR_I24_BAD_UNIT              1
#define ERROR_I24_NOT_READY             2
#define ERROR_I24_BAD_COMMAND           3
#define ERROR_I24_CRC                   4
#define ERROR_I24_BAD_LENGTH            5
#define ERROR_I24_SEEK                  6
#define ERROR_I24_NOT_DOS_DISK          7
#define ERROR_I24_SECTOR_NOT_FOUND      8
#define ERROR_I24_OUT_OF_PAPER          9
#define ERROR_I24_WRITE_FAULT           10
#define ERROR_I24_READ_FAULT            11
#define ERROR_I24_GEN_FAILURE           12
#define ERROR_I24_DISK_CHANGE           13
#define ERROR_I24_WRONG_DISK            15
#define ERROR_I24_UNCERTAIN_MEDIA       16
#define ERROR_I24_CHAR_CALL_INTERRUPTED 17
#define ERROR_I24_NO_MONITOR_SUPPORT    18
#define ERROR_I24_INVALID_PARAMETER     19

#define ALLOWED_FAIL                    0x0001
#define ALLOWED_ABORT                   0x0002
#define ALLOWED_RETRY                   0x0004
#define ALLOWED_IGNORE                  0x0008
#define ALLOWED_DISPATCH                0x8000

#define I24_OPERATION                   0x01
#define I24_AREA                        0x06
#define I24_CLASS                       0x80

/* Values for error CLASS */

#define ERRCLASS_OUTRES                 1
#define ERRCLASS_TEMPSIT                2
#define ERRCLASS_AUTH                   3
#define ERRCLASS_INTRN                  4
#define ERRCLASS_HRDFAIL                5
#define ERRCLASS_SYSFAIL                6
#define ERRCLASS_APPERR                 7
#define ERRCLASS_NOTFND                 8
#define ERRCLASS_BADFMT                 9
#define ERRCLASS_LOCKED                 10
#define ERRCLASS_MEDIA                  11
#define ERRCLASS_ALREADY                12
#define ERRCLASS_UNK                    13
#define ERRCLASS_CANT                   14
#define ERRCLASS_TIME                   15

/* Values for error ACTION */

#define ERRACT_RETRY                    1
#define ERRACT_DLYRET                   2
#define ERRACT_USER                     3
#define ERRACT_ABORT                    4
#define ERRACT_PANIC                    5
#define ERRACT_IGNORE                   6
#define ERRACT_INTRET                   7

/* Values for error LOCUS */

#define ERRLOC_UNK                      1
#define ERRLOC_DISK                     2
#define ERRLOC_NET                      3
#define ERRLOC_SERDEV                   4
#define ERRLOC_MEM                      5

/* Abnormal termination codes */

#define TC_NORMAL               0
#define TC_HARDERR              1
#define TC_GP_TRAP              2
#define TC_SIGNAL               3


/* */
/* intercomponent error codes (from 8000H or 32768) */
/* */
#define ERROR_SWAPPER_NOT_ACTIVE        32768
#define ERROR_INVALID_SWAPID            32769
#define ERROR_IOERR_SWAP_FILE           32770
#define ERROR_SWAP_TABLE_FULL           32771
#define ERROR_SWAP_FILE_FULL            32772
#define ERROR_CANT_INIT_SWAPPER         32773
#define ERROR_SWAPPER_ALREADY_INIT      32774
#define ERROR_PMM_INSUFFICIENT_MEMORY   32775
#define ERROR_PMM_INVALID_FLAGS         32776
#define ERROR_PMM_INVALID_ADDRESS       32777
#define ERROR_PMM_LOCK_FAILED           32778
#define ERROR_PMM_UNLOCK_FAILED         32779
#define ERROR_PMM_MOVE_INCOMPLETE       32780
#define ERROR_UCOM_DRIVE_RENAMED        32781
#define ERROR_UCOM_FILENAME_TRUNCATED   32782
#define ERROR_UCOM_BUFFER_LENGTH        32783
#define ERROR_MON_CHAIN_HANDLE          32784
#define ERROR_MON_NOT_REGISTERED        32785
#define ERROR_SMG_ALREADY_TOP           32786
#define ERROR_PMM_ARENA_MODIFIED        32787
#define ERROR_SMG_PRINTER_OPEN          32788
#define ERROR_PMM_SET_FLAGS_FAILED      32789
#define ERROR_INVALID_DOS_DD            32790
#define ERROR_CPSIO_CODE_PAGE_INVALID   65026
#define ERROR_CPSIO_NO_SPOOLER          65027
#define ERROR_CPSIO_FONT_ID_INVALID     65028
#define ERROR_CPSIO_INTERNAL_ERROR      65033
#define ERROR_CPSIO_INVALID_PTR_NAME    65034
#define ERROR_CPSIO_NOT_ACTIVE          65037
#define ERROR_CPSIO_PID_FULL            65039
#define ERROR_CPSIO_PID_NOT_FOUND       65040
#define ERROR_CPSIO_READ_CTL_SEQ        65043
#define ERROR_CPSIO_READ_FNT_DEF        65045
#define ERROR_CPSIO_WRITE_ERROR         65047
#define ERROR_CPSIO_WRITE_FULL_ERROR    65048
#define ERROR_CPSIO_WRITE_HANDLE_BAD    65049
#define ERROR_CPSIO_SWIT_LOAD           65074
#define ERROR_CPSIO_INV_COMMAND         65077
#define ERROR_CPSIO_NO_FONT_SWIT        65078

#endif /* INCL_DOSERRORS */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\paragon\lib\strtcpyf.asm ===
;***
;* $Workfile:   strtcpyf.asm  $
;* $Revision:   1.0  $
;*   $Author:   Dave Sewell  $
;*     $Date:   28 Apr 1989 16:52:52  $
;*
;* Copy a string and truncate (force trailing null) if needed.	This function
;* operates just like "strcpy", except that a buffer length is passed also,
;* and the function insures that the string is truncated (if necessary) to
;* fit in the buffer.  There will ALWAYS be a trailing null in the destination
;* buffer (unless a zero is passed as the buffer length).
;*
;* NOTE:  this function is NOT identical to the "strtcpy" function in the
;* LDS C-Plus library.	The LDS version null pads the entire buffer if the
;* string is shorter than the buffer length.  This version copies one and
;* only one null into the destination buffer, and leaves the rest of the
;* buffer (if any) unchanged.
;*
;* This routine is the same as strtcpy() execpt that the src is always a far
;* pointer.
;*
;***

	INCLUDE dos.mac

			TEXTSEG

;*  extern void pascal strtcpy(char *dest, char far *src, unsigned count);

dest	EQU	X + I + FDP
src	EQU	X + I
count	EQU	X

PASCALDEF   strtcpyf

	    procent

    IF	    LDATA
	    LES     DI, [BP + dest]
    ELSE
	    PUSH    DS
	    POP     ES
	    MOV     DI, [BP + dest]
    ENDIF

	    PUSH    DS
	    LDS     SI, [BP + src]

	    MOV     CX, [BP + count]
	    JCXZ    cpy_done

	    DEC     CX

cpy_loop:   JCXZ    plant_null

	    LODSB
	    STOSB
	    OR	    AL, AL
	    JZ	    cpy_done

	    LOOP    cpy_loop

plant_null: XOR     AL, AL
	    MOV     ES:[DI], AL

cpy_done:

	    POP     DS

	    procret DP + FDP + I

PASCALEND   strtcpyf


	TEXTEND

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\cgraphic.h ===
/*
	CW : Character Windows
	cgraphic.h : Graphic Drawing

	Yes, COW not only does Windows, but it does graphics too

	CC should be defined for compilation with Cmerge.

-- Created Mon Dec 16 14:32:18 1991 */ 

// Primative Graphic Types 

#ifndef NOGD_GPT
typedef struct _gpoint
	{
	int	x;
	int	y;
	} GPT; // GPOINT / Graphic Point 
#endif

#ifndef NOGD_RECT
typedef struct _grect
	{
	int	xLeft;
	int	yTop;
	int	xRight;
	int	yBottom;
#ifdef BLADE
	} CW_RECT;
#else
	}RECT;
#endif

#endif

#ifndef NOGD_POLYGON
typedef struct _polygon
	{
	WORD	cbPolygon;
#ifdef BLADE
	CW_RECT	rectBound;
#else
	RECT	rectBound;
#endif
	GPT	rggpt[1];
	} POLYGON;
#endif

#define	cpenMax		41	/* maximum number of pens */
#define	icoMax		41	/* maximum ico number */

/* Device descriptor */
typedef struct _ingd
	{
	WORD	fingd;		/* flags -- see below			*/
	WORD	reserved2;	/* for future use			*/
	WORD	fingpSupported;	/* procedures supported -- see below	*/
	WORD	dimH;		/* horizontal size in twips		*/
	WORD	dimV;		/* vertical size in twips		*/
	WORD	dxScreen;	/* number of horizontal pixels		*/
	WORD	dyScreen;	/* number of vertical pixels		*/
	WORD	dimPenH;	/* horizontal pen size in twips		*/
	WORD	dimPenV;	/* vertical pen size in twips		*/
	BYTE	cpen;		/* number of pens available		*/
	BYTE	icoAvailMac;	/* number of colors available		*/
	BYTE	icoPrefMac;	/* number of preferred colors		*/
	BYTE	ipaLineMac;	/* number of line styles		*/
	BYTE	ipaAreaMac;	/* number of area fill patterns		*/
	BYTE	ccopln;		/* number of color planes or ribbons	*/

	WORD	rgcoAvail[cpenMax];
	WORD	rgcoPref[cpenMax];
	BYTE	rgpaLine[5];
	BYTE	rgpaArea[16];
	char	szName[40];
	} INGD;


/* FINGD : Flags for the options supported in INGD */
#define	fingdRstrVctr	0x0004	/* Raster : MUST BE SET */
#define	fingdRasterFonts 0x0040	/* can use raster fonts			*/
#define	fingdMultiColor	0x0100	/* device has infinite colors		*/
#define	fingdVirtualPen	0x0200	/* do not prompt for pen changes	*/
#define	fingdFilm	0x0400	/* film device				*/
#define	fingdVarPenSize	0x1000	/* device can vary the pen size		*/
#define	fingdNotAvailable 0x8000/* device does not support this DEV	*/

/* FINGP: GSD procedures supported */
#define	fingpSetAreaPat	0x0001	/* set the current area pattern		*/
#define	fingpSetLinePat	0x0002	/* set the current line pattern		*/
#define	fingpSetLineWeight 0x0004 /* set the current line weight	*/
#define	fingpSetColor	0x0008	/* set the current color		*/
#define	fingpText	0x0010	/* draw a text string			*/
#define	fingpRectangle	0x0020	/* draw or fill a rectangle		*/
#define	fingpArc	0x0040	/* draw or fill an arc			*/
#define	fingpPolygon	0x0080	/* draw or fill a polygon		*/
#define	fingpBitBlt	0x0100	/* copy a bitmap			*/
#define	fingpInitGraphics 0x0200 /* Init/Term/Move			*/
#define	fingpDraw	0x0400	/* draw					*/
#define	fingpSnapShot	0x0800	/* Capture TSR support		*/
#define	fingpBltBlock	0x1000	/* move a block	*/
#define	fingpSetDrawMode	0x2000	/* set the current draw mode	*/


extern BOOL PASCAL fPrinting;

/* Graphic Drawing Procedures */

#define	FLoadGsd(sz)	(RerrLoadGsd(sz) == rerrOk)
#define	FLoadGpd(sz)	(RerrLoadGpd(sz) == rerrOk)

#ifndef	NOPROCS
WORD	FARPUBLIC RerrLoadGsd(char *);
WORD	FARPUBLIC RerrLoadGpd(char *);
VOID	FARPUBLIC FreeGsd(void);
VOID	FARPUBLIC FreeGpd(void);
VOID	FARPUBLIC SetPrinting(BOOL);

BOOL	FARPUBLIC FInitGraphics(VOID *, VOID FAR *);
VOID	FARPUBLIC TermGraphics(void);
VOID	FARPUBLIC Move(WORD, WORD);
VOID	FARPUBLIC Draw(WORD, WORD);
VOID	FARPUBLIC SetAreaPat(WORD);
VOID	FARPUBLIC SetLinePat(WORD);
VOID	FARPUBLIC SetLineWeight(WORD);
VOID	FARPUBLIC SetColor(WORD, WORD);
VOID	FARPUBLIC Text(char far *, WORD, WORD, WORD, int);

VOID	FARPUBLIC Rectangle(struct _grect far *);
VOID	FARPUBLIC Arc(struct _grect far *, int, int);
VOID	FARPUBLIC BitRead(struct _grect far *, BYTE far *, WORD);
VOID	FARPUBLIC BitBlt(struct _grect far *, BYTE far *, WORD, BOOL);

VOID	FARPUBLIC Polygon(struct _polygon far *);
VOID	FARPUBLIC DrawXOR(WORD, WORD);		/* Capture TSR support */
VOID	FARPUBLIC SetDrawMode(WORD);
VOID	FARPUBLIC BltBlock(WORD,WORD, WORD,WORD, WORD,WORD);

#ifdef KANJI
/* CPD Functions */
// REVIEW: to be documented and properly supported !!!
WORD	FARPUBLIC RerrLoadCpd(char *);
VOID	FARPUBLIC FreeCpd(void);
WORD	FARPUBLIC InitCpd(CPD_STRUCTURE far *);
WORD	FARPUBLIC TermCpd(void);
WORD	FARPUBLIC AdvVertCpd(WORD);
WORD	FARPUBLIC AdvHorizCpd(WORD);
WORD	FARPUBLIC AdvPageCpd(void);
WORD	FARPUBLIC PrintRgchCpd(CPD_STRUCTURE far *);
WORD	FARPUBLIC PrintHdrCpd(CPD_STRUCTURE far *);
WORD	FARPUBLIC CrLfCpd(void);
#endif	/*KANJI*/
#endif	/* !NOPROCS */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\chips.asm ===
dosseg
        .model large
        .data
control dw     0              ; control word needed for the NDP test

        .code

        PUBLIC  _chips
        EXTRN   is386:FAR

_chips         PROC FAR


        push   BP             ; save where Ur at
        mov    BP,SP          ;   going in.....
        push   DI
        push   SI
        push   CX             ; not really needed for MSC but kinda
                              ;   nice to do cuz someone else might
                              ;   want to use the function and we do
                              ;   use CX later on

        call   NEAR PTR cpu_type       ; find out what kinda CPU you got and
                              ;   and save it in DX for future reference
        call   NEAR PTR ndp_type       ; check for math coprocessor (NDP) type
                              ;   and hold that result in AX

        add    AX,DX          ; add the two results together and hold
                              ;   'em in AX for Ur return to the caller

        pop    CX             ; put things back the way that you
        pop    SI             ;   found 'em when you started this
        pop    DI             ;   little drill off.....
        pop    BP
                              ; AND
        ret                   ; go back to where you came from....
                              ;   ( ===>  the calling program )
                              ;   with Ur results sittin' in AX !!
_chips         endp


cpu_type       PROC NEAR

        pushf                 ; pump Ur flags register onto the stack
        xor    DX,DX          ; blow out Ur DX and AX to start off
        xor    AX,AX          ;   with a clean slate
        push   AX             ; put AX on the stack
        popf                  ; bring it back in Ur flags
        pushf                 ; try to set bits 12 thru 15 to a zero
        pop    AX             ; get back Ur flags word in AX
        and    AX, 0f000h     ; if bits 12 thru 15 are set then you got
        cmp    AX, 0f000h     ;   an Intel 8018x or a 808x or maybe even
        jz     dig            ;   a NEC V20/V30 ??? - gotta look more...

; OTHERWISE....
;   Here's the BIG one.... 'tells the difference between an 80286 and
;   an 80386 !!

        mov    AX, 07000h     ; try to set FLAG bits 12 thru 14
                              ;   - NT, IOPL
        push   AX             ; put it onto the stack
        popf                  ;   and try to pump 07000H into Ur flags
        pushf                 ; push Ur flags, again
        pop    AX             ;   and bring back AX for a compare
        and    AX,07000h      ; if Ur bits 12 thru 14 are set
        jnz    got386         ;   then Ur workin' with an 80386
        mov    DX, 0280       ; save 280 in DX cuz it's an 80286
        jmp    SHORT CPUbye   ;   and bail out

got386:
                              ; RoyHa 07/23/90
        call   is386          ; Determine if this is a 386 or 486.
        cmp    ax,1           ; AX=1 means it's a 486
        je     SHORT got486   ; Jump out if it's a 486
        mov    dx,0380        ; Save 380 in DX to represent 386
        jmp    SHORT CPUbye   ; Bail out
got486:
        mov    dx,0480        ; Save 480 in DX to represent 486
        jmp    SHORT CPUbye   ; Bail out


; here's we try to figger out whether it's an 80188/80186, an 8088/8086
;   or an NEC V20/V30 - 'couple of slick tricks from Clif Purkiser.....

dig:    mov    AX, 0ffffh     ; load up AX
        mov    CL, 33         ; HERE's the FIRST TRICK.... this will
                              ;   shift everything 33 times if it's
                              ;   8088/8086, or once for a 80188/80186!
        shl    AX, CL         ; on a shift of 33, all bits get zeroed
        jz     digmor         ;   out so if anything is left ON it's
                              ;   gotta be an 80188/80186
        mov    DX,0180        ; save 180 in DX cuz it's an 80188/80186
        jmp    SHORT CPUbye   ;   and bail out

digmor: xor    AL,AL          ; clean out AL to set ZF
        mov    AL,40h         ; ANOTHER TRICK.... mul on an NEC duz NOT
        mul    AL             ;   effect the zero flag BUT on an Intel
        jz     gotNEC         ;   8088/8086, the zero flag gets thrown
        mov    DX,0080        ; 80 into DX cuz it's an Intel 8088/8086
        jmp    SHORT CPUbye   ;   and bail out

gotNEC: mov    DX,0200        ; it's an NEC V20/V30 so save 200 in DX

CPUbye: popf                  ; putchur flags back to where they were
        ret                   ;   and go back to where you came from
                              ;   (i.e., ===>  _chips) with the CPU type
                              ;   tucked away in DX for future reference
cpu_type       endp

; Check for an NDP.
;
; >>>>NOTE:  If you are using an MASM version < 5.0, don't forget to
; use the /R option or you will bomb cuz of the coprocessor instruc-
; tions.  /R is not needed for version 5.0.<<<<<<<<<<<<<<<<<<<<<<<<<

ndp_type       PROC NEAR

do_we:  fninit                          ; try to initialize the NDP
        mov    byte ptr control+1,0     ; clear memory byte
        fnstcw control                  ; put control word in memory
        mov    AH,byte ptr control+1    ; iff AH is 03h, you got
        cmp    AH,03h                   ;   an NDP on board !!
        je     chk_87                   ; found somethin', keep goin'
        xor    AX,AX                    ; clean out AX to show a zero
        jmp    SHORT NDPbye             ;   return (i.e., no NDP)

; 'got an 8087 ??

chk_87: and    control,NOT 0080h        ; turn ON interrupts (IEM = 0)
        fldcw  control                  ; load control word
        fdisi                           ; turn OFF interrupts (IEM = 1)
        fstcw  control                  ; store control word
        test   control,0080h            ; iff IEM=1, 8087
        jz     chk287                   ; 'guess not!  March on....
        mov    AX,0001                  ; set up for a 1 return to
        jmp    SHORT NDPbye             ;   show an 8087 is on board

; if not.... would you believe an 80287 maybe ??

chk287: finit                 ; set default infinity mode
        fld1                  ; make infinity
        fldz                  ;   by dividing
        fdiv                  ;   1 by zero !!
        fld    st             ; now make a
        fchs                  ;   negative infinity
        fcompp                ; compare Ur two infinities
        fstsw  control        ; iff, for 8087 or 80287
        fwait                 ; sit tight 'til status word is put away
        mov    AX,control     ; getchur control word
        sahf                  ; putchur AH into flags
        jnz    got387         ; NO GOOD.... march on !!
        mov    AX,0002        ; gotta be a 80287 cuz we already tested
        jmp    SHORT NDPbye   ;   for an 8087

; We KNOW that there is an NDP on board otherwise we would have bailed
; out after 'do_we'.  It isn't an 8087 or an 80287 or we wouldn't have
; gotten this far.  It's gotta be an 80387 !!

got387: mov    AX,0003        ; call it an 80387 and return 3

NDPbye: ret                   ; and go back where you came from
                              ;   (i.e., ===>  _chips) carrying the NDP
                              ;   type in Ur AX register
ndp_type       endp

        end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\cedit.h ===
/*
	CW : Character Windows
	cedit.h

	Multi-line edit structures
-- Created Mon Dec 16 14:30:57 1991 */ 

#ifndef NOMULTIEDIT

/*** ld - line buffer */
typedef struct ld
	{
	WORD	flags;
	WORD	cb;	/* count of bytes in buffer */
	WORD	cbMax;	/* max buffer length */
	char *	prgch;	/* pointer to buffer */
	} LD; 

/*** ip - insert point */
typedef struct ip
	{	/* insert point */
	short	ob;	/* offset to current column position */
	short	oln;	/* offset to current line position */
	} IP;

/*** pd - program descripter */
typedef struct pd
	{
	WORD	olntop;	/* offset within progrm display at top of screen */
	short	obleft;	/* offset within list buffer of left most character */
	WORD	oln;	/* current ld line offset within program */
	} PD;

/*** ef - Edit Field ***/
typedef struct ef
	{
	WORD	hBuffer;
	PD	pdCur;
	IP	ipCur;
	IP	ipAnchor;
	LD	*pldCur;
	PWND	pwndScrollV;
	PWND	pwndScrollH;
	WORD	attrCur;
	BYTE	Style;
	BYTE	fSelection;
	} EF;

#define hBufferUndefined	0xffff	/* hBuffer is not defined */

typedef struct LineAttr
	{
	WORD	attr;
	WORD	cb;
	} LineAttr;

extern BOOL PASCAL fPasteOk;
extern BOOL PASCAL fInsertMode;
extern LD PASCAL ldEMScratch;

extern WORD PASCAL emFlags;
#define EMF_IN_EDITMGR 0x01

/* styles */
#define ES_MULTILINE	0x0001
#define ES_NOREDRAW	0x0002
#define ES_NOSELECT	0x0004

/* control messages: */
#define EM_SELCHARS	(WM_USER+2+0)
#define EM_REPLACESEL	(WM_USER+2+1)
#define EM_GETWORD	(WM_USER+2+2)
#define EM_GETLINESEL	(WM_USER+2+3)
#define WM_UNDO 	(WM_USER+2+4)
#define WM_CLEAR	(WM_USER+2+5)
#define WM_SETTEXT	(WM_USER+2+6)
#define WM_GETTEXT	(WM_USER+2+7)
#define WM_SEARCHFIND	(WM_USER+2+8)
#define WM_SEARCHCHANGE (WM_USER+2+9)
#define WM_SETBOOKMARK	(WM_USER+2+10)
#define WM_GOTOBOOKMARK (WM_USER+2+11)
#define WM_SEARCHNEXT	(WM_USER+2+13)
#define WM_MATCHBRACE	(WM_USER+2+14)

/* ldCur.flags values */
#define LD_fDirty			0x0001


/* for Basic Text Manager Only */
#ifndef	NOPROCS
ISA		FARPUBLIC SetInverseIsa(ISA);		/* OPTIONAL */
#endif	/* !NOPROCS */

#endif /*!NOMULTIEDIT*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\cominfo.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * COMINFO.C - Source file for serial port detection code.
 ********************************************************************/


/* Include Files */

#include "msd.h"


/*********************************************************************
 * GetComInfo - Gets the COM port information.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetComInfo (COM_STRUCT *pCom, BOOL fMinimumInfo)
{
  WORD  i, wWait;           /* Looping variables                    */
  WORD  wIndex;             /* Index for strings                    */
  WORD  wPort;              /* COM port address                     */
  WORD  wLCR;               /* Line Control Register value          */
  WORD  wMSR;               /* Modem Status Register value          */
  WORD  wNewIID;            /* Used to store changed IID value      */
  DWORD dwBaudRateDivisor;  /* Used to calculate the baud rate      */
  BOOL  fArcnetCard;        /* True if the 02E0-02EF range should   */
                            /*   be avoided                         */

  /* 40:0 is the port address of the first valid COM port */
  WORD FAR * fwPortAddress = (WORD FAR *) 0x00400000;


  /* Determine if an Arcnet card is present at 02E0 */
  fArcnetCard = ArcnetCardPresent();

  /* Set the values in the structure for each port */

  /* Zero out the count of COM ports */
  pCom->wNmbrComPorts = 0;

  for (i = 0; i < MAX_COM_PORTS; ++i)
    {
      {
        /* Load the port address from the DOS Device table, if it exists */
        pCom->ComxInfo[i].wPortAddress = *(fwPortAddress++);
        wPort = pCom->ComxInfo[i].wPortAddress;

        /* Determine if the port exists in the right range */

        if (wPort >= 0x220  &&  wPort <= 0x3FF)
          {
            ++(pCom->wNmbrComPorts);
            pCom->ComxInfo[i].fComPortDetected = TRUE;
          }
        else
          pCom->ComxInfo[i].fComPortDetected = FALSE;

        /* If the Arcnet card is present, disable COM4 testing */
        if (fArcnetCard && wPort >= 0x2E0 && wPort <= 0x2FF)
          pCom->ComxInfo[i].fComPortDetected = FALSE;

        if (fMinimumInfo || !(pCom->ComxInfo[i].fComPortDetected))
          continue;
      }

      {
        /* Read the Line Control Register Port */

        wLCR = inp (wPort + 3);

        /* If the DLAB bit (bit 7) is 1, we can obtain the Baud Rate    */
        /*   Divisor from *fwPortAddress (LSB) and *fwPortAddress + 1   */
        /*   (MSB)                                                      */

        /* If the DLAB bit is not set, set it, then read the Baud Rate  */
        /*   Divisor                                                    */

        if (!(0x80 & wLCR))
          outp (wPort + 3, 0x80 | wLCR);

        /* Pause briefly for the port to respond */
        for (wWait = 0; wWait < 25; ++wWait)
          ;

        dwBaudRateDivisor = (WORD) (inp (wPort)) +
                            (WORD) (inp (wPort + 1) << 8);

        /* Pause briefly for the port to respond */
        for (wWait = 0; wWait < 25; ++wWait)
          ;

        /* If the DLAB bit was not set originally, put it back to it's  */
        /*   original state.                                            */

        if (!(0x80 & wLCR))
          outp (wPort + 3, wLCR);
      }

      {
        /* Calculate the BAUD rate */

        if (dwBaudRateDivisor == 0)
          pCom->ComxInfo[i].dwBaudRate = 0;
        else
          pCom->ComxInfo[i].dwBaudRate = 115200L / dwBaudRateDivisor;
      }

      {
        /* Parity - If bit 3 of the LCR register is off, parity is none. */
        /*          none.  If bit 3 is on, bits 4 and 5 come into play   */
        /*          like this:                                           */
        /*                                                               */
        /*              Bits: 5 4                                        */
        /*                    0 0 - Odd parity                           */
        /*                    0 1 - Even parity                          */
        /*                    1 0 - Mark parity                          */
        /*                    1 1 - Space parity                         */

        if ((wLCR & 0x08) == 0)
          pCom->ComxInfo[i].wParity = 0;
        else
          pCom->ComxInfo[i].wParity = ((wLCR & 0x30) >> 4) + 1;

        memset (pCom->ComxInfo[i].szParity, '\0', MAX_PARITY);

        wIndex = pCom->ComxInfo[i].wParity;
        strcpy (pCom->ComxInfo[i].szParity, paszParityDesc[wIndex]);
      }

      {
        /* Data Bits - Stored in the LCR in bits 0 and 1: */
        /*                                                */
        /*              Bits: 1 0                         */
        /*                    0 0 - 5 data bits           */
        /*                    0 1 - 6 data bits           */
        /*                    1 0 - 7 data bits           */
        /*                    1 1 - 8 data bits           */

        pCom->ComxInfo[i].wDataBits = (wLCR & 0x03) + 5;
      }

      {
        /* Stop Bits - Stored in the LCR in bit 2.  Off is 1 stop bit, */
        /*             On is two stop bits.                            */
        /*             Note:  If data bits is 5 and LCR bit 2 is on,   */
        /*                    stop bits = 1.5.                         */

        pCom->ComxInfo[i].wStopBits = (wLCR & 0x04) ? 2 : 1;

        if (pCom->ComxInfo[i].wDataBits == 5 &&
            pCom->ComxInfo[i].wStopBits == 2)
          pCom->ComxInfo[i].wStopBits = 3;
      }

      {
        /* Read the Modem Status Register values */

        wMSR = inp (wPort + 6);
      }

      {
        /* Carrier Detect is bit 7 of the MSR */

        pCom->ComxInfo[i].fCarrierDetect = (wMSR & 0x80) ? TRUE : FALSE;
      }

      {
        /* Ring Indicator is bit 6 of the MSR */

        pCom->ComxInfo[i].fRingIndicator = (wMSR & 0x40) ? TRUE : FALSE;
      }

      {
        /* Data Set Ready (DSR) is bit 5 of the MSR */

        pCom->ComxInfo[i].fDataSetReady = (wMSR & 0x20) ? TRUE : FALSE;
      }

      {
        /* Clear to Send is bit 4 of the MSR */

        pCom->ComxInfo[i].fClearToSend = (wMSR & 0x10) ? TRUE : FALSE;
      }

      {
        /* Determine the UART chip type.  This is accomplished by       */
        /*   outputing 11000001 to the FIFO Control Register (FCR).     */
        /*   Then, bits 6 and 7 are checked to see if they are on.  The */
        /*   list below shows how the chip type is determined:          */
        /*                                                              */
        /* Bits: 7 6                                                    */
        /*       0 0 - INS8250 UART                                     */
        /*       0 1 - Unknown                                          */
        /*       1 0 - NS16550 UART                                     */
        /*       1 1 - NS16550AN UART                                   */
        /*                                                              */
        /* This may cause problems with TSR communications programs and */
        /*   COM programs running in OS/2 or Windows while MSD runs,    */
        /*   because in order to determine the chip type, I must modify */
        /*   the behavior of the UART chip.                             */

        /* Turn on bits 6 and 7 */
        outp (wPort + 2, 0xC1);

        /* Pause for a moment to allow the port to take the change. */

        for (wWait = 0; wWait < 25; ++wWait)
          ;

        /* Read the changed value */
        wNewIID = inp (wPort + 2);

        /* Set the chip type, based on bits 6 and 7 */
        wIndex = pCom->ComxInfo[i].wUartChip = wNewIID >> 6;

        memset (pCom->ComxInfo[i].szUartChip, '\0', MAX_UART_CHIP);
        strcpy (pCom->ComxInfo[i].szUartChip, paszUartChips[wIndex]);
      }
    }

  return (FALSE);
}


/*********************************************************************
 * SprintComInfo - Put Com port information into a set of strings to
 *                 be printed or displayed.
 *
 * Returns:  NULL if an error occured.
 *********************************************************************/

QSZ * SprintComInfo (COM_STRUCT *pCom,
                     CHAR szSumStrings[][MAX_SUMM_INFO + 5])
{
  WORD wNmbrStrings;         /* Number of strings                    */
  WORD wNmbrChars;           /* Number of characters in the strings  */
  WORD wComIndex;            /* Index to the structure of COM data   */
  WORD i;                    /* Looping variables                    */
  QSZ  *pqszStrings = NULL;  /* Location for storing string pointers */


  /* Summary information */
  if (szSumStrings != NULL)
    {
      sprintf (szSumStrings[0], "%d", pCom->wNmbrComPorts);
      return (NULL);
    }


  /* Calculate the amount of space required for the strings */

  wNmbrChars   = (MAX_COM_TITLES + 3) * (MAX_COM_INFO_LINE + 1);

  wNmbrStrings = MAX_COM_TITLES + 3;


  /* Allocate space for the pointer area and string area */
  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);



  /* Put the first two strings in place */

  Qmemset (pqszStrings[0], ' ', COM_TITLE_WIDTH + COM_INFO_COL_WIDTH - 5);
  Qstrcpy (&pqszStrings[0][COM_TITLE_WIDTH + COM_INFO_COL_WIDTH - 5],
          pszComHeader);
  pqszStrings[1] = pqszStrings[0] + Qstrlen (pqszStrings[0]) + 1;

  Qmemset (pqszStrings[1], ' ', COM_TITLE_WIDTH + COM_INFO_COL_WIDTH - 5);
  Qstrcpy (&pqszStrings[1][COM_TITLE_WIDTH + COM_INFO_COL_WIDTH - 5],
          pszComUnderline);
  pqszStrings[2] = pqszStrings[1] + Qstrlen (pqszStrings[1]) + 1;


  /* Put the COM port information in place */

  for (i = 2, wComIndex = 0; wComIndex < MAX_COM_TITLES;
       ++i, ++wComIndex)
    {
      WORD wPort;             /* Port number for each display line */
      WORD wLength;           /* Current length of string          */
      WORD wInfoColumn;       /* Column to place the information   */
      CHAR chBuffer[80];      /* Buffer for string data            */
      PSZ  pszString = NULL;  /* String pointer                    */

      /* Clear out the string */
      Qmemset (pqszStrings[i], ' ', MAX_COM_INFO_LINE);
      pqszStrings[i][MAX_COM_INFO_LINE] = '\0';

      /* Put on the title */
      Qstrncpy (pqszStrings[i], paszComTitles[wComIndex],
               strlen (paszComTitles[wComIndex]));

      for (wPort = 0; wPort < MAX_COM_PORTS; ++wPort)
        {
          wInfoColumn = wPort * COM_INFO_COL_WIDTH + COM_TITLE_WIDTH;


          /* Put the N/A under the Port Address for ports that don't exist */

          if (wComIndex == COM_PORT_ADDRESS &&
              pCom->ComxInfo[wPort].fComPortDetected == FALSE)
            {
              QstrncpyAlign (&pqszStrings[i][wInfoColumn], pszNA,
                            strlen (pszNA), COM_INFO_COL_WIDTH);
            }


          /* Add the strings only if the COM port exists */

          if (pCom->ComxInfo[wPort].fComPortDetected)
            {
              switch (wComIndex)
                {
                  case COM_PORT_ADDRESS:
                    {
                      sprintf (chBuffer, "%04XH",
                               pCom->ComxInfo[wPort].wPortAddress);

                      QstrncpyAlign (&pqszStrings[i][wInfoColumn], chBuffer,
                                    strlen (chBuffer), COM_INFO_COL_WIDTH);
                      break;
                    }

                  case COM_BAUD_RATE:
                    {
                      sprintf (chBuffer, "%Lu",
                               pCom->ComxInfo[wPort].dwBaudRate);
                      QstrncpyAlign (&pqszStrings[i][wInfoColumn], chBuffer,
                                    strlen (chBuffer), COM_INFO_COL_WIDTH);
                      break;
                    }

                  case COM_PARITY:
                    {
                      wLength = strlen (pCom->ComxInfo[wPort].szParity);

                      QstrncpyAlign (&pqszStrings[i][wInfoColumn],
                                    pCom->ComxInfo[wPort].szParity,
                                    wLength, COM_INFO_COL_WIDTH);
                      break;
                    }

                  case COM_DATA_BITS:
                    {
                      sprintf (chBuffer, "%d",
                               pCom->ComxInfo[wPort].wDataBits);
                      QstrncpyAlign (&pqszStrings[i][wInfoColumn], chBuffer,
                                    strlen (chBuffer), COM_INFO_COL_WIDTH);
                      break;
                    }

                  case COM_STOP_BITS:
                    {
                      if (pCom->ComxInfo[wPort].wStopBits < 3)
                        {
                          sprintf (chBuffer, "%d",
                                   pCom->ComxInfo[wPort].wStopBits);
                          QstrncpyAlign (&pqszStrings[i][wInfoColumn],
                                        chBuffer,
                                        strlen (chBuffer),
                                        COM_INFO_COL_WIDTH);
                        }
                      else
                        {
                          wLength = strlen (psz1point5);
                          QstrncpyAlign (&pqszStrings[i][wInfoColumn],
                                        psz1point5,
                                        wLength,
                                        COM_INFO_COL_WIDTH);
                        }
                      break;
                    }

                  case COM_CARRIER_DETECT:
                    {
                      pszString = (pCom->ComxInfo[wPort].fCarrierDetect) ?
                                  pszYes : pszNo;

                      wLength = strlen (pszString);

                      QstrncpyAlign (&pqszStrings[i][wInfoColumn], pszString,
                                    wLength, COM_INFO_COL_WIDTH);
                      break;
                    }

                  case COM_RING_INDICATOR:
                    {
                      pszString = (pCom->ComxInfo[wPort].fRingIndicator) ?
                                  pszYes : pszNo;

                      wLength = strlen (pszString);

                      QstrncpyAlign (&pqszStrings[i][wInfoColumn], pszString,
                                    wLength, COM_INFO_COL_WIDTH);
                      break;
                    }

                  case COM_DATA_SET_READY:
                    {
                      pszString = (pCom->ComxInfo[wPort].fDataSetReady) ?
                                  pszYes : pszNo;

                      wLength = strlen (pszString);

                      QstrncpyAlign (&pqszStrings[i][wInfoColumn], pszString,
                                    wLength, COM_INFO_COL_WIDTH);
                      break;
                    }

                  case COM_CLEAR_TO_SEND:
                    {
                      pszString = (pCom->ComxInfo[wPort].fClearToSend) ?
                                  pszYes : pszNo;

                      wLength = strlen (pszString);

                      QstrncpyAlign (&pqszStrings[i][wInfoColumn], pszString,
                                    wLength, COM_INFO_COL_WIDTH);
                      break;
                    }

                  case COM_UART_CHIP:
                    {
                      wLength = strlen (pCom->ComxInfo[wPort].szUartChip);

                      QstrncpyAlign (&pqszStrings[i][wInfoColumn],
                                    pCom->ComxInfo[wPort].szUartChip,
                                    wLength, COM_INFO_COL_WIDTH);
                      break;
                    }
                }
            }
        }

      PrepNextString (pqszStrings, i);
    }

  /* Set the last pointer to a NULL */
  pqszStrings[i] = NULL;

  /* Return the pointer to pqszStrings */
  return (pqszStrings);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\browse.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * BROWSE.C - Source file for the memory browsing functions.
 ********************************************************************/


/* Include Files */

#include "msd.h"

PSZ paszBiosSearchStrings[] =
  {
    "VERSION",
    "COPYRIGHT",
    "TECH",
    "INC.",
    "LTD",
    "COPR.",
    "COMPA",
    "BIOS",
    "CCOO",
    "(C)",
    "ALL RIGHTS RESERVED",
    "REV ",
    "RESI",
    NULL
  };


/*********************************************************************
 * GetBrowseInfo - Gets the browser strings and stores them in the
 *                 structure.
 *
 * pwndCaller        - PWND of the calling dialog box.
 * pszSearchString   - String to search for
 * fpSearchArea      - Area to search
 * wSearchLength     - Length of search
 *
 * Returns:  PSZ * to strings that were found, or NULL if an error
 *           occured.
 *********************************************************************/

QSZ * GetBrowseInfo (PSZ      pszTitle,
                     PSZ      pszSearchString,
                     CHAR FAR *fpSearchArea,
                     DWORD    dwSearchLength)
{
  MEM_STRING_DATA           /* Structure for storing located strings */
      msdStrings[MAX_MSD_STRINGS + 1];
  int  iBrowseResult;        /* Result of the video browse            */
  QSZ  *pqszStrings = NULL;  /* Array of string pointers to display   */
  PSZ  *ppszSearchStrings = NULL;  /* Array of search strings         */
  WORD wSearchLength;        /* Actual search length                  */
  PSZ  paszUserSearchStrings[2];  /* Local array of search strings.   */
                                  /*   Used for user provided string. */


  /* Set the search length */
  if (dwSearchLength > 0xFFFF)
    wSearchLength = 0xFFFF;
  else
    wSearchLength = (WORD) dwSearchLength;


  /* Determine if a search string was given to us */
  if (pszSearchString == NULL || pszSearchString[0] == '\0')
    ppszSearchStrings = paszBiosSearchStrings;
  else
    {
      paszUserSearchStrings[0] = pszSearchString;
      paszUserSearchStrings[1] = NULL;

      ppszSearchStrings = paszUserSearchStrings;
    }


  /* Prepare for the search */
  BrowseInit (fpSearchArea, msdStrings, MAX_MSD_STRINGS);

  /* Perform the search */
  iBrowseResult = Browse (ppszSearchStrings,
                          fpSearchArea,
                          wSearchLength,
                          msdStrings,
                          MAX_MSD_STRINGS);

  /* Convert the info to displayable strings */
  pqszStrings = SprintBrowseInfo (msdStrings);

  return (pqszStrings);
}


/*********************************************************************
 * SprintBrowseInfo - Converts browsed strings into a form displayable
 *                    within an info window.
 *
 * pmsdStrings - The collection of strings and lengths to convert
 *
 * Returns:  String array for display or printing, or NULL on error.
 *********************************************************************/

QSZ * SprintBrowseInfo (MEM_STRING_DATA *pmsdData)
{
  WORD wNmbrStrings;        /* Number of strings                     */
  WORD wNmbrChars;          /* Number of characters in the strings   */
  WORD i, wMsdIndex;        /* Index variables                       */
  INT  iLength;             /* Length of far string                  */
  WORD wLength;             /* Copy of string length                 */
  INT  c;                   /* Character from far memory location    */
  INT  iLineCount;          /* Number of lines in this browse string */
  CHAR FAR *fpString = NULL;/* Far pointer to the string             */
  QSZ  *pqszStrings = NULL; /* Location for storing string pointers  */
  CHAR chBuffer[40];        /* sprintf buffer                        */


  /* Overestimate the amount of space this will require */
  for (i = 0; i < MAX_MSD_STRINGS && pmsdData[i].cfpString != NULL; ++i)
    ;

  wNmbrStrings = (i * MAX_BROWSE_LINES) + 1;
  wNmbrChars   = wNmbrStrings * 72;

  /* Allocate space for the pointer area and string area */
  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);


  /* Put the information in place */

  for (i = 0, wMsdIndex = 0;
       wMsdIndex < MAX_MSD_STRINGS && pmsdData[wMsdIndex].cfpString != NULL;
       ++wMsdIndex)
    {
      sprintf (chBuffer, "%04X:%04X ",
               FP_SEG (pmsdData[wMsdIndex].cfpString),
               FP_OFF (pmsdData[wMsdIndex].cfpString));
      Qstrcpy (pqszStrings[i], chBuffer);

      iLength  = pmsdData[wMsdIndex].iStringLen;
      fpString = pmsdData[wMsdIndex].cfpString;

      iLineCount = 1;

      while (iLength--)
        {
          c = *(fpString++);

          switch (c)
            {
              case '\n':
                break;

              case '\r':
                /* Are we at the maximum number of lines */
                if (++iLineCount > MAX_BROWSE_LINES)
                  {
                    /* No more lines for this one */
                    iLength = 0;
                  }
                else
                  {
                    PrepNextString (pqszStrings, i++);
                    Qmemset (pqszStrings[i], ' ', 10);
                    pqszStrings[i][10] = '\0';
                  }
                break;

              /* This is a printing character */
              default:

                wLength = Qstrlen (pqszStrings[i]);

                /* Is the line too long to add the character */
                if (wLength >= REPORT_WIDTH)
                  {
                    /* Are we at the maximum number of lines */
                    if (++iLineCount > MAX_BROWSE_LINES)
                      {
                        /* No more lines for this one */
                        iLength = 0;

                        break;
                      }
                    else
                      {
                        PrepNextString (pqszStrings, i++);
                        Qmemset (pqszStrings[i], ' ', 10);
                        pqszStrings[i][10] = '\0';
                        wLength = 10;
                      }
                  }

                pqszStrings[i][wLength]     = (CHAR) c;
                pqszStrings[i][wLength + 1] = '\0';

                break;
            }
        }

      PrepNextString (pqszStrings, i++);
    }

  pqszStrings[i] = NULL;

  return (pqszStrings);
}


/*********************************************************************
 * ListOptionRoms - Creates a list of the option ROMs installed in
 *                  the system.
 *
 * Returns:  Array of strings with Option ROM names, addresses, and
 *           sizes, or NULL on an error.
 *********************************************************************/

PSZ * ListOptionRoms (VOID)
{
  WORD wNmbrStrings;             /* Number of strings                   */
  WORD wNmbrChars;               /* Number of characters in the strings */
  ROM_MAP *pRomMap = NULL;       /* ROM area locations and sizes        */
  INT  i;                        /* Looping variable                    */
  WORD wIndex = 0;               /* Index to ppszStrings                */
  WORD wSize;                    /* Size of various structs             */
  PSZ  *ppszStrings = NULL;      /* String buffer                       */
  COMPUTER_STRUCT *pCpu = NULL;  /* For getting BUS type (PS/2)         */
  WORD wBusType;                 /* Stores the BUS type                 */


  /* Get the computer IRQ info (contains bus type) */

  wSize = GetInfoSize (IDI_COMPUTER_RECORD, FALSE);

  if (wSize == 0)
    return (NULL);


  /* Allocate enough room for the info structure */
  pCpu = malloc (wSize);

  if (pCpu == NULL)
    {
      OutOfMemory();
      return (NULL);
    }

  /* Zero out the structure */
  memset (pCpu, '\0', wSize);

  /* Fill the structure with the information */
  if (GetComputerIrqInfo (pCpu))
    {
      free (pCpu);
      return (NULL);
    }

  /* Store the bus type */
  wBusType = pCpu->wBusType;
  free (pCpu);


  /* Make room for the ROM Map */

  pRomMap = malloc (sizeof (ROM_MAP));
  if (pRomMap == NULL)
    {
      OutOfMemory();
      return (NULL);
    }

  memset (pRomMap, '\0', sizeof (ROM_MAP));

  /* Get the ROM Map */
  GetRomMap (pRomMap, wBusType);


  /* Allocate space for the pointer area and string area */

  wNmbrStrings = 10;
  wNmbrChars   = wNmbrStrings * 34;

  if ((ppszStrings = calloc (wNmbrStrings + 1, sizeof (PSZ))) != NULL)
    ppszStrings[0] = malloc (wNmbrChars);

  if (ppszStrings == NULL || ppszStrings[0] == NULL)
    {
      free (ppszStrings);
      free (pRomMap);
      OutOfMemory();
      return (NULL);
    }


  /* Load the ROM BIOS information into ppszStrings */
  for (i = 0; i < 2 && pRomMap->wRomBiosLoc[i] != 0; ++i)
    {
      /* BIOS information */
      if (i == 0)
        {
          if (pRomMap->wRomBiosLoc[1] == 0)
            {
              sprintf (ppszStrings[wIndex],
                       "ROM BIOS              %04X   %6lu",
                       pRomMap->wRomBiosLoc[i],
                       pRomMap->dwRomBiosSize[i]);

              ppszStrings[wIndex + 1] = ppszStrings[wIndex] +
                                        strlen (ppszStrings[wIndex]) + 1;
              ++wIndex;
            }
          else
            {
              sprintf (ppszStrings[wIndex],
                       "ROM BIOS part 1       %04X   %6lu",
                       pRomMap->wRomBiosLoc[i],
                       pRomMap->dwRomBiosSize[i]);

              ppszStrings[wIndex + 1] = ppszStrings[wIndex] +
                                        strlen (ppszStrings[wIndex]) + 1;
              ++wIndex;
            }
        }
      else
        {
          sprintf (ppszStrings[wIndex],
                   "ROM BIOS part 2       %04X   %6lu",
                   pRomMap->wRomBiosLoc[i],
                   pRomMap->dwRomBiosSize[i]);

          ppszStrings[wIndex + 1] = ppszStrings[wIndex] +
                                    strlen (ppszStrings[wIndex]) + 1;
          ++wIndex;
        }
    }


  /* Load the Option ROM information into the listbox */
  for (i = 9; i >=0; --i)
    {
      switch (pRomMap->wOptRomLoc[i])
        {
          case 0x0000:
            continue;

          case 0xC000:
            /* Video ROM */
            sprintf (ppszStrings[wIndex],
                     "Video ROM BIOS        C000  %7lu",
                     pRomMap->dwOptRomSize[i]);
            ppszStrings[wIndex + 1] = ppszStrings[wIndex] +
                                      strlen (ppszStrings[wIndex]) + 1;
            ++wIndex;
            break;

          default:
            /* Generic Option ROM */
            sprintf (ppszStrings[wIndex],
                     "Option ROM            %04X  %7lu",
                     pRomMap->wOptRomLoc[i],
                     pRomMap->dwOptRomSize[i]);
            ppszStrings[wIndex + 1] = ppszStrings[wIndex] +
                                      strlen (ppszStrings[wIndex]) + 1;
            ++wIndex;
            break;
        }
    }

  /* Set the last one to NULL */
  ppszStrings[wIndex] = NULL;

  free (pRomMap);

  return (ppszStrings);
}


/*********************************************************************
 * ReportBrowseInfo - Writes the browser information to the file.
 *
 * fileReportFile - File handle for reporting.
 *
 * Returns: TRUE if an error occured.
 *********************************************************************/

BOOL ReportBrowseInfo (FILE *fileReportFile)
{
  QSZ * pqszStrings;            /* Browser Strings                     */
  PSZ * ppszRomStrings;         /* List of ROM Areas                   */
  WORD  wSearchSegment;         /* Segment to search                   */
  DWORD dwSearchLength;         /* Search Length                       */
  INT   i;                      /* Looping variable                    */
  BOOL  fReturnValue = FALSE;   /* Return value from various functions */
  CHAR  chBuffer[80];           /* sscanf buffer                       */


  /* Get the list of ROMs */
  ppszRomStrings = ListOptionRoms();
  if (ppszRomStrings == NULL)
    return (TRUE);


  /* Report the strings in each one */
  for (i = 0; ppszRomStrings[i] != NULL && fReturnValue == FALSE; ++i)
    {
      /* Obtain the search parameters */
      Qstrcpy (chBuffer, ppszRomStrings[i]);
      sscanf (&chBuffer[TSR_ADDRESS_COL], "%04X", &wSearchSegment);
      dwSearchLength = atol (&chBuffer[TSR_SIZE_COL]);

      /* Get the strings from that ROM area */
      pqszStrings = GetBrowseInfo (ppszRomStrings[i],
                                   NULL,
                                   (CHAR FAR *) ((DWORD) wSearchSegment << 16),
                                   dwSearchLength);

      /* Write out the strings */
      if (pqszStrings != NULL)
        {
          fReturnValue = WriteInfo (fileReportFile,
                                    chBuffer,
                                    pqszStrings);
        }
      else
        return (TRUE);

      /* Free up the allocated memory */
      FreeStringSpace (pqszStrings);
    }

  /* Free up the list of ROMs */
  free (ppszRomStrings[0]);
  free (ppszRomStrings);

  return (fReturnValue);
}


int iStringCount;               /* Total number of strings found */
int iLastNmbrFound;             /* Last number of strings found  */


/*************************************************************************
 * BrowseInit - Prepares for the browsing action.
 *
 * msdFoundStrings - MSD strings to be cleared out.
 *
 * iMaxMSDStrings  - Number of strings to clear.
 *************************************************************************/

VOID BrowseInit (char far *cfpSearchArea,
                 MEM_STRING_DATA *msdFoundStrings,
                 int iMaxMSDStrings)
{
  ClearMSDArray (msdFoundStrings, iMaxMSDStrings);

  iStringCount = 0;
  iLastNmbrFound = 0;
}


/*************************************************************************
 * Browse() - Browses through memory for strings.
 *
 * paszSearchString - Pointer to array of strings to search for in memory.
 *
 * cfpSearchArea - Far pointer to the area of memory to search.
 *
 * uiLengthOfSearch - Number of bytes to search at that cfpSearchArea.
 *
 * msdFoundStrings - Array to store the strings that were found.
 *
 * iMaxMSDStrings - Maximum number of strings to store in MSD array.
 *
 * Returns:  Number of strings found.
 *************************************************************************/

int Browse (char **paszSearchStrings,
            char far *cfpSearchArea,
            unsigned int uiLengthOfSearch,
            MEM_STRING_DATA *msdFoundStrings,
            int iMaxMSDStrings)
{
  register int i1;    /* Looping variables                 */
  int iSearchResult;  /* To store the result of the search */


  /* Get strings from memory browser */

  for (i1 = 0; paszSearchStrings[i1] != NULL; ++i1)
    {
      iStringCount = max((iSearchResult =
                         SingleStringMemSearch (msdFoundStrings,
                                                iMaxMSDStrings,
                                                paszSearchStrings[i1],
                                                cfpSearchArea,
                                                uiLengthOfSearch)),
                         iStringCount);

#if 0
      if (iSearchResult == SEARCH_CANCELED)
        return (SEARCH_CANCELED);
#endif

      iLastNmbrFound = iStringCount;
    }

  return (iStringCount);
}


/**********************************************************************
 * ClearMSDArray - Clears out MEM_STRING_DATA structures
 *
 * msd           - Pointer to the structure to clear
 *
 * iStringCount  - Number of elements in the structure
 **********************************************************************/

void ClearMSDArray (MEM_STRING_DATA *msd, int iStringCount)
{
  register int i;

  for (i = 0; i < iStringCount; ++i)
    {
      msd[i].cfpString = NULL;
      msd[i].iStringLen = 0;
    }
}


/***********************************************************************
 * SingleStringMemSearch - Returns the number of strings found
 *                         during the memory search.
 *
 * MEM_STRING_DATA *msdFoundArray
 *              - This is the pointer to the array that will hold
 *                the strings that are found.
 *
 * int iMaxArray
 *              - The total number of strings msdFoundArray can hold.
 *
 * char *pszSearchString
 *              - Pointer to the strings to search for.
 *
 * char far *cfpAreaToSearch
 *              - Area of memory to search (ie 0xF0000000).
 *
 * unsigned int uiLengthOfSearch
 *              - Total number of bytes to search (ie, 0xFFFF).
 ***********************************************************************/

int SingleStringMemSearch (MEM_STRING_DATA *msdFoundArray,
                           int iMaxArray,
                           char *pszSearchString,
                           char far *cfpAreaToSearch,
                           unsigned int uiLengthOfSearch)
{
  int iLength;                         /* Length of string returned */
                                       /*   from fbiInstr() */
  int iMaxInArray = 0;                 /* Holds the count of strings */
                                       /*   stored in the structure */
  unsigned int uiLengthToEndOfSearch;  /* As strings are found, */
                                       /*   uiSizeOfSearch will look ahead */
                                       /*   only as far as is necessary */
  char far *pszfMatch;                  /* Pointer to the matched character */
  char far *pszfString;                 /* Pointer to the true beginning of */
                                        /*   the string */

  if (pszSearchString == NULL || pszSearchString[0] == '\0')
    return (-1);

  uiLengthToEndOfSearch = uiLengthOfSearch;

  while ((pszfMatch = fbiInstr (cfpAreaToSearch,
                                pszSearchString,
                                uiLengthToEndOfSearch)) != NULL)
    {
#if 0
      if (KbHit())
        {
          if ((c = GetCh()) == ESC)
            return (SEARCH_CANCELED);
          else if (c == '\0')
            GetCh();
        }
#endif

      pszfString = fbMemString (pszfMatch, &iLength);

      iMaxInArray = max (AddToFoundArray (pszfString, iLength,
                                          msdFoundArray, iMaxArray),
                         iMaxInArray);

      /* Begin searching one byte after the found string */

      cfpAreaToSearch = pszfMatch + 1;

      /* If a string was found, set uiLengthToEndOfSearch to the */
      /* number of bytes left to search */

      uiLengthToEndOfSearch  =
          uiLengthOfSearch -
          ((unsigned) ((long int) cfpAreaToSearch & 0x0000ffff));
    }

#if 0
  if (KbHit())
    {
      if ((c = GetCh()) == ESC)
        return (SEARCH_CANCELED);
      else if (c == '\0')
        GetCh();
    }
#endif

  return (iMaxInArray);
}

/***********************************************************************
 * AddToFoundArray - Adds pszfString and iLength to the msdArray if
 *                   msdArray does not already contain this string.
 *
 * char far *pszfString - Far pointer to the area of memory containing
 *                       the string to store.
 *
 * int iStringLength   - Length of the string in memory.
 *
 * MEM_STRING_DATA *msdArray
 *                     - Pointer to structure for storing the
 *                       far string pointers and lengths.
 *
 * int iMaxArray       - Maximum size of the array (so we don't go
 *                       outside the bounds of the array.
 *
 * Global Variable:
 * fIncludeDuplicates  - Flag to determine wether to include duplicate
 *                       strings in the found array.
 *
 * Returns:  The element the string was stored in, or iMaxArray if the
 *           array was full.
 ***********************************************************************/

int AddToFoundArray (char far *pszfString,
                     int iStringLength,
                     MEM_STRING_DATA *msdArray,
                     int iMaxArray)
{
  register int i = 0;    /* Looping variable */

  /* Search to see if this pointer is already in the array */
  while (i < iMaxArray &&
         msdArray[i].cfpString != NULL &&
         msdArray[i].cfpString != pszfString)
    ++i;

  if (i == iMaxArray)
    return (iMaxArray);

  i = 0;

  /* Check to see if this string's contents has already been recorded */

  while (i < iMaxArray &&
         msdArray[i].cfpString != NULL &&
         _fmemcmp (msdArray[i].cfpString, pszfString,
                   max (msdArray[i].iStringLen, iStringLength)))
    ++i;

  /* Add the string if it was not already in the array */

  if (i < iMaxArray && msdArray[i].cfpString == NULL)
    {
      msdArray[i].cfpString  = pszfString;
      msdArray[i].iStringLen = iStringLength;
    }

  return (i + 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\csdm.h ===
/*
	CW : Character Windows

	csdm.h : SDM global exports
-- Created Mon Dec 16 14:30:09 1991 */ 

typedef WORD TMC;		/* iTeM Codes */
typedef WORD DLM;		/* Dialog Messages */
typedef WORD TMM;		/* Control proc Messages */

/* standard item codes (tmc) */
#define	tmcNull		((TMC) 0)
#define	tmcOK		((TMC) 1)
#define	tmcOk		tmcOK
#define	tmcCancel	((TMC) 2)
#define	tmcSysMin	((TMC) 0x10)
#ifdef HELP_BUTTON
#define tmcHelp 	((TMC) tmcSysMin-1)
#endif
#define	tmcSysMax	((TMC) 0x100)
#define	ftmcGrouped	0x8000		/* OR'd to specify whole group
					  as opposed to first button */
#define	tmcUserMin	tmcSysMax
#define	tmcUserMax	((TMC) ftmcGrouped)



/* special ninch (No Input, No CHange) values */
#define	wNinch		(-32767)	/* ints */
#define	uNinch		(0xffff)	/* unsigned */
#define	iszNinchList	uNinch		/* listboxes */
#define	uNinchList	uNinch		/* other name */
#define	uNinchRadio	uNinch		/* radio groups */
#define	uNinchCheck	2		/* check boxes */
#define	wNinchCheck	uNinchCheck	/* old name */

/* special parse error values */
#define	wError		(-32766)	/* ints */
#define	uError		(0xfffe)	/* unsigneds */


/* command argument block header */
typedef struct _cabh
	{
	WORD	cwData;			/* total size of CAB less CABH */
	WORD	cagHandle;		/* # of handles */
	} CABH;

typedef void **HCAB;		/* CAB is just a concept, no real type */
typedef	void *PCAB;		/* pointer to CAB */

typedef	struct _dlg *PDLG;	/* Dialog pointer */

/* minimum CAB size : header + SAB */
#define	cwCabMin	((sizeof(CABH) + sizeof(WORD)) / sizeof(WORD))

/* Dialog Messages */
#define	dlmInit 	0	/* do custom initialization */
#define	dlmClick	1	/* item clicked */
#define	dlmChange	2	/* edit control may have changed */
#define	dlmKey		3	/* any untrapped key */
#define	dlmDblClk	4	/* double click in listbox/radio */

#define	dlmSetFocus	5	/* set focus */
#define	dlmKillFocus	6	/* lose focus */

#define	dlmTerm 	7	/* termination request for one of many reasons */
#define	dlmIdle		8	/* idle for dialogs */

#define	dlmUnclick	9	/* item unclicked */

#define	dlmClientMouse	10	/* mouse click within dialog box */
#define	dlmNonClientMouse	11	/* mouse click outside dialog box */

#define	dlmSuspend	12	/* dialog suspended pending subdialog */
#define	dlmResume	13	/* dialog resumed */
#define	dlmRepaint	14
#define	dlmExit	15	/* the dialog is exiting (last dlm before termination) */

#define	dlmUserMin	16	/* for user extensions */


/* ListboxProc (pfnTm) messages */
#define	tmmCount	0	/* return number of items in listbox */
#define	tmmText 	1	/* return text associated with n'th item in listbox */
#define	tmmEditText	2	/* like msgText for Combo listboxes */

#define	cszUnknown	((WORD) -1)	/* return to tmmCount if unknown */

#define bNoArg		((WORD) -1)	/* put in bArg field if not used */

/* ParseProc (pfnTm) messages */
#define	tmmFormat	0	/* format data */
#define	tmmParse	1	/* parse data */
#define	tmmCwVal	2	/* return size of data in words */

/* RenderProc (pfnTm) messages */
#define	tmmPaint	0	/* paint yourself */


#define	tmmUserMin	16	/* for user extensions */

/* Control Procedure */
typedef WORD	(FARPUBLIC *PWFN_CTL)(WORD, char *, WORD, TMC, WORD, WORD);


/* default no help */
#define	hidDlgNull	0	/* for no help */


/* macro to get void pointer to general CAB arg */
#define	PvParseArg(hObj, bArg) ((VOID *) (*((WORD *)(hObj)) + (bArg)))


/* Iag macro
   returns iag corresponding to field fld in application structure str
*/
#define Iag(str, fld)	((WORD)((int)&(((str *)0)->fld) / sizeof(int) - cwCabMin))


/* Globally Exported Function Definitions */
#ifdef CC

#ifndef	NOPROCS
#ifdef SDM_3X
VOID	FARPUBLIC GetDlgArc(PDLG, NPARC);		/*OPTIONAL*/
#else
VOID	FARPUBLIC GetDlgArc(PDLG, PARC);		/*OPTIONAL*/
#endif

TMC	FARPUBLIC TmcDoDlg(VOID *, HCAB);/*OPTIONAL*/
TMC	FARPUBLIC TmcDoDlgAxAy(VOID *, HCAB, AX, AY);	/*OPTIONAL*/
HCAB	FARPUBLIC HcabAlloc(WORD);				/*OPTIONAL*/
VOID	FARPUBLIC FreeCab(HCAB);				/*OPTIONAL*/
VOID	FARPUBLIC FreeCabData(HCAB);			/*OPTIONAL*/
VOID	FARPUBLIC SzToCab(HCAB, char *, WORD);/*OPTIONAL*/
char *FARPUBLIC SzFromCab(HCAB, char *, WORD, WORD);/*OPTIONAL*/
VOID	FARPUBLIC PszToCab(HCAB, char **, WORD);	/*OPTIONAL*/

VOID	FARPUBLIC EnableTmc(TMC, BOOL);/*OPTIONAL*/
BOOL	FARPUBLIC FEnabledTmc(TMC);	 /*OPTIONAL*/
VOID	FARPUBLIC SetTmcVal(TMC, WORD);/*OPTIONAL*/
WORD	FARPUBLIC GetTmcVal(TMC);		 /*OPTIONAL*/
VOID	FARPUBLIC SetTmcSel(TMC, WORD, WORD);/*OPTIONAL*/
VOID	FARPUBLIC GetTmcText(TMC, char *, WORD);/*OPTIONAL*/
VOID	FARPUBLIC SetTmcText(TMC, char *);		 /*OPTIONAL*/
VOID	FARPUBLIC SetFocusTmc(TMC);				 /*OPTIONAL*/
VOID	FARPUBLIC RedisplayListBox(TMC);			 /*OPTIONAL*/
VOID	FARPUBLIC RedisplayListBoxOriented(TMC, WORD *, WORD *); /*OPTIONAL*/
VOID	FARPUBLIC GetTmcListBoxOrientation(TMC, WORD *, WORD *); /*OPTIONAL*/
VOID	FARPUBLIC GetListBoxEntry(TMC, WORD, char *, WORD);	/*OPTIONAL*/
VOID	FARPUBLIC RedisplayTmc(TMC);/*OPTIONAL*/
VOID	FARPUBLIC SetDefaultTmc(TMC);/*OPTIONAL*/
VOID	FARPUBLIC SzFromInt(char *, int);/*OPTIONAL*/
WORD	FARPUBLIC ParseInt(WORD, char *, HANDLE, TMC, WORD, WORD); /*OPTIONAL*/
VOID	FARPUBLIC SetTmcListWidth(TMC, WORD);		/*OPTIONAL*/
VOID	FARPUBLIC SetTmcEditWidth(TMC, WORD);		/*OPTIONAL*/

VOID	FARPUBLIC InitCab(HCAB, WORD);	/*OPTIONAL*/
VOID	FARPUBLIC ReinitCab(HCAB, WORD);	/*OPTIONAL*/

PWND	FARPUBLIC PwndOfTmc(TMC);			/*OPTIONAL*/

TMC	FARPUBLIC TmcDoDlgExt(VOID *, HCAB, WORD, DWORD);	/* OPTIONAL */

#endif	/* !NOPROCS */

#endif /*CC*/

#define	PwndOfListbox(tmc)	PwndOfTmc(tmc)
#define	TmcListBoxResetcontent(tmc)	\
	SendMessage(PwndOfListbox(tmc), LB_RESETCONTENT, 0, 0L)
#define	TmcListBoxAddstring(tmc,isa,sz,fRedraw)	\
	SendMessage(PwndOfListbox(tmc), LB_ADDSTRING, (WORD) sz, MAKELONG(fRedraw,isa))
#define	TmcListBoxInsertstring(tmc,isaT,szT,isz,fRedraw)	\
	{						\
	SZI	szi;					\
							\
	szi.sz = szT;					\
	szi.isa = isaT;					\
	SendMessage(PwndOfListbox(tmc), LB_INSERTSTRING,(WORD)&szi, MAKELONG(fRedraw,isz)); \
	}
#define	TmcListBoxDeletestring(tmc,isz,fRedraw)	\
	SendMessage(PwndOfListbox(tmc), LB_DELETESTRING, 0, MAKELONG(fRedraw,isz))
#define	TmcListBoxReplacestring(tmc,isa,sz,isz)	\
	SendMessage(PwndOfListbox(tmc), LB_REPLACESTRING, (WORD) sz, MAKELONG(isa,isz))
#define TmcListBoxRepaint(tmc)	\
	SendMessage(PwndOfListbox(tmc), WM_PAINT, 0, 0L)
#define TmcGetClientRrc(tmc,prrc)	\
	GetClientRrc(PwndOfListbox(tmc), prrc)
#define CentryListBoxTmc(tmc)	\
	((WORD)SendMessage(PwndOfListbox(tmc), LB_GETCOUNT, 0, 0L))

// Out Of Memory Support. 
typedef WORD		SEV;
#define sevMinor	1		// Minor (painting) error.
					// don't cast, since used in MASM
#define sevMajor	((SEV)2)	// Major error.
#define sevLmem		((SEV)3)	// Out of LMEM memory.
#define sevHcabFromDlg	((SEV)4)	// HcabFromDlg() failure.
#define sevDirFill	((SEV)5)	// Directory fill failed.
#define sevList		((SEV)6)	// Non-directory ListBox fill failure.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\computer.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * COMPUTER.C - Source file for obtaining the computer data:  BIOS,
 *              Processor, and Keyboard.
 ********************************************************************/


/* Include Files */

#include "msd.h"


/* Computer names */

PSZ ppszComputerNames[] =
  {
    "Unknown",
    "Amstrad", "Wang", "Apricot", "Bull ", "Toshiba", "NEC ", "Texas Inst",
    "Austin", "Cumulus", "Ergo", "Hynudai", "Nokia", "Ogivar", "Siemens",
    "Tandem", "Tandon", "Mitsubishi", "Matsushita", "Sharp", "DEC ",
    "Hewlett Packard", "Hewlett-Packard", "Epson", "Leading Edge", "NCR ",
    "Acer", "ALR ", "Norsk", "Altec", "Altos", "Televideo", "Dell ",
    "Commodore", "CompuAdd", "Gateway", "Hauppauge", "Northgate", "Goldstar",
    "Laser", "Normerel", "Panasonic", "Swan", "Orange", "Xerox", "Zeos",
    "Parallan", "Ampro", "AT&T", "Club ", "Data General", "Sperry", "Unisys",
    "Arche", "PC Brand", "Elonex", "Emerson", "DFI", "SDI ", "AIR ", "CSS ",
    "Dolsh", "Mitsuba", "Osicom", "Polywell", "SAI ", "Micro Express",
    "Packard Bell", "PC Craft", "Headstart", "Telex", "Mitac", "Everex",
    "DTK ", "Koyro", "Tandy", "Wyse", "Zenith", "Amkly", "AST ", "Grid",
    "Cheetah", "Psion", "US Micro", "Smith Corona", "Reply", "Dolch",
    "Aquiline", "Comtrade", "Cardinal", "Compudyne", "Schmit", "Victor",
    "Chicony", "Brother", "Elonex"
  };


/* BIOS names */

PSZ ppszBiosNames[] =
  {
    "Unknown",
    "Phoenix", "AMI ", "American Megatrends", "Award", "DTK", "Micronics",
    "ERSO", "Datatech", "Data Tech", "Olivetti", "Intel", "Seiko", "Ultima",
    "Mylex", "Artek", "Zenith", "(C)ZDS ", "Western Digital",
    "Compaq", "Monolithic", "IBM",
    NULL
  };


COMPUTER_STRUCT FAR *fpComputer = NULL;   /* Stored computer info */

/*********************************************************************
 * GetComputerInfo - Gets the computer related information:  BIOS and
 *                   computer manufacturer, BIOS version, and
 *                   keyboard type.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetComputerInfo (COMPUTER_STRUCT *pComputer, BOOL fMinimumInfo)
{
  union  REGS inregs, outregs;  /* Register structures   */
  BYTE FAR * fbByte = NULL;     /* Far pointer to a byte */
  PSZ pszString     = NULL;     /* String pointer        */
  WORD i;                       /* Looping variable      */


  /* We obtain the computer information only once, then store the    */
  /*   computer information for later requests.  If a second request */
  /*   is made (ie., for IRQ info, etc.), this routine will copy the */
  /*   stored computer information to pComputer and return           */
  /*   immediately.  This is done because obtaining the computer     */
  /*   information after obtaining information about a serial mouse  */
  /*   hard hangs the computer.                                      */

  if (fpComputer != NULL)
    {
      _fmemcpy ((COMPUTER_STRUCT FAR *) pComputer, fpComputer,
                 sizeof (COMPUTER_STRUCT));
      return (FALSE);
    }


  {
    /* Get Computer Name */

    i = GetRomName (GET_COMPUTER_NAME, ppszComputerNames);
    strcpy (pComputer->szComputerName, ppszComputerNames[i]);
    pComputer->wComputerName = i;
  }

  {
    /* Get BIOS Manufacturer */

    i = GetRomName (GET_BIOS_MFGR, ppszBiosNames);
    strcpy (pComputer->szBiosMfgr, ppszBiosNames[i]);
    pComputer->wBiosMfgr = i;
  }

  {
    /* Get IRQ and related Information */

    GetComputerIrqInfo (pComputer);
  }

  {
    /* If mimimum information requested, return now */

    /* Removed */
    /*
    if (fMinimumInfo)
      return (FALSE);
    */
  }

  {
    /* Get BIOS Version */

    GetRomVersion (pComputer->aszBiosVersion,
                   (CHAR FAR *) 0xF0000000, 0xFFFF);
  }

  {
    /* Get the BIOS Date */

    GetRomDate ((CHAR FAR *) 0xF0000000, 0xFFFF, pComputer->szBiosDate);
  }

  {
    /* Determine the BIOS Category */

    GetBiosCategory (pComputer);
  }


  {
    /* Determine Keyboard type */

    /* 0040:0096 is keyboard status byte 3:               */
    /*   If bit 4 is set, an enhanced keyboard is present */

    fbByte = (BYTE FAR *) 0x00400096;

    pszString = (*fbByte & 0x10) ? pszEnhanced : pszNonEnhanced;

    strcpy (pComputer->szKeyboardType, pszString);
  }

  {
    /* Determine the presence of a DMA Controller Chip */

    int86 (0x11, &inregs, &outregs);

    /* If the AX register, bit 8 == 0, then there is a DMA controller. */
    /*   Since AX bit 8 == AH bit 0, I use regs.h.ah.                  */

    pComputer->fDmaChipPresent = !(outregs.h.ah & 1);
  }

  /* Store the computer structure for future use */
  fpComputer = _fmalloc (sizeof (COMPUTER_STRUCT));
  if (fpComputer != NULL)
    {
      _fmemcpy (fpComputer, (COMPUTER_STRUCT FAR *) pComputer,
                sizeof (COMPUTER_STRUCT));
    }

  return (FALSE);
}


/*********************************************************************
 * GetComputerIrqInfo - Gets the IRQ related computer information,
 *                      (Cascaded IRQ2, Co-processor, Real Time
 *                      Clock).
 *
 * pComputer - Computer information structure.
 *********************************************************************/

BOOL GetComputerIrqInfo (COMPUTER_STRUCT *pComputer)
{
  union  REGS inregs, outregs;  /* Register structures         */
  struct SREGS sregs;           /* Segement register structure */
  BYTE FAR * fbByte = NULL;     /* Far pointer to a byte       */
  PSZ pszString     = NULL;     /* String pointer              */


  /* We obtain the computer information only once, then store the    */
  /*   computer information for later requests.  If a second request */
  /*   is made (ie., for IRQ info, etc.), this routine will copy the */
  /*   stored computer information to pComputer and return           */
  /*   immediately.  This is done because obtaining the computer     */
  /*   information after obtaining information about a serial mouse  */
  /*   hard hangs the computer.                                      */

  if (fpComputer != NULL)
    {
      _fmemcpy ((COMPUTER_STRUCT FAR *) pComputer, fpComputer,
                 sizeof (COMPUTER_STRUCT));
      return (FALSE);
    }


  {
    /* Get System Configuration Call */

    segread (&sregs);
    inregs.x.ax = 0;
    inregs.x.bx = 0;
    inregs.x.cx = 0;
    inregs.x.dx = 0;
    inregs.x.si = 0;
    inregs.x.di = 0;
    inregs.x.cflag = 0;
    inregs.h.ah = 0xC0;
    int86x (0x15, &inregs, &outregs, &sregs);

    /* Set the flag if this call is not supported on this BIOS */
    pComputer->fConfigCallSupported = !outregs.x.cflag;

    if (!pComputer->fConfigCallSupported)
      {
        /* If the "System Configuration Call" is not supported, */
        /*   the Computer Type byte is at F000:FFFE.            */

        fbByte = (BYTE FAR *) 0xF000FFFE;
        pComputer->bComputerType      = *fbByte;
        pComputer->bSubModel          = 0;
        pComputer->bRevisionLevel     = 0;
        pComputer->wComputerClass     = COMPUTER_CLASS_XT;
        pComputer->fFixedDiskUsesDMA3 = FALSE;
        pComputer->fCascadeIntLvl2    = FALSE;
        pComputer->fRealTimeClock     = FALSE;
      }
    else
      {
        /* Otherwise, get the information */

        fbByte = (BYTE FAR *)
                   (((DWORD) sregs.es << 16) + (DWORD) outregs.x.bx);

        pComputer->bComputerType      = fbByte[2];
        pComputer->bSubModel          = fbByte[3];
        pComputer->bRevisionLevel     = fbByte[4];
        pComputer->fFixedDiskUsesDMA3 = (fbByte[5] & 0x80) ? TRUE : FALSE;
        pComputer->fCascadeIntLvl2    = (fbByte[5] & 0x40) ? TRUE : FALSE;
        pComputer->fRealTimeClock     = (fbByte[5] & 0x20) ? TRUE : FALSE;


        /* Determine Bus type and computer category */

        if (fbByte[5] & 0x02)
          {
            strcpy (pComputer->szBusType, pszMicroChannel);
            pComputer->wBusType  = MICRO_CHANNEL;
            pComputer->wComputerClass = COMPUTER_CLASS_PS2;
          }
        else
          {
            /* Is this an EISA bus? */

            segread (&sregs);
            inregs.x.ax = 0;
            inregs.x.bx = 0;
            inregs.x.cx = 0;
            inregs.x.dx = 0;
            inregs.x.si = 0;
            inregs.x.di = 0;
            inregs.x.cflag = 0;
            inregs.x.ax = 0xD804;
            inregs.x.cx = 0x0000;
            int86 (0x15, &inregs, &outregs);
            if (outregs.h.ah != 0x86)
              {
                strcpy (pComputer->szBusType, pszEisaBus);
                pComputer->wBusType  = EISA_BUS;
                pComputer->wComputerClass = COMPUTER_CLASS_AT;
              }
            else
              {
                if (pComputer->fCascadeIntLvl2)
                  {
                    strcpy (pComputer->szBusType, pszAtBus);
                    pComputer->wBusType  = AT_BUS;
                    pComputer->wComputerClass = COMPUTER_CLASS_AT;
                  }
                else
                  {
                    strcpy (pComputer->szBusType, pszXtBus);
                    pComputer->wBusType  = XT_BUS;
                    pComputer->wComputerClass = COMPUTER_CLASS_XT;
                  }
              }
          }
      }

    /* Get Extended BIOS Data Segment */

    if (fbByte[5] & 0x04)
      {
        segread (&sregs);
        inregs.x.ax = 0;
        inregs.x.bx = 0;
        inregs.x.cx = 0;
        inregs.x.dx = 0;
        inregs.x.si = 0;
        inregs.x.di = 0;
        inregs.x.cflag = 0;
        inregs.h.ah = 0xC1;
        int86x (0x15, &inregs, &outregs, &sregs);

        if (outregs.x.cflag || sregs.es < 0x1000)
          {
            pComputer->wExtAreaSeg = 0;
            pComputer->wExtAreaLen = 0;
          }
        else
          {
            /* The first byte in the extended BIOS data segment */
            /*   tells the size (in K) of the segment           */
            pComputer->wExtAreaSeg = sregs.es;
            fbByte = (BYTE FAR *) ((DWORD) pComputer->wExtAreaSeg << 16);
            pComputer->wExtAreaLen = *fbByte;

            /* Assume it doesn't exist if it's too large */

          }
      }
  }

  {
    WORD wChipTypes;    /* Stores the chip types                    */
    WORD wProcessor;    /* "chips()" encoding for processor type    */
    WORD wCoProcessor;  /* "chips()" encoding for co-processor type */


    /* Determine Processor and Co-processor Types */

    wChipTypes   = chips();

    wProcessor   = wChipTypes / 10;
    wCoProcessor = wChipTypes % 10;


    /* Set the values for the processor */

    switch (wProcessor)
      {
      case 8:
          pComputer->wProcessor = _8088;
          pszString = pszIntel8088;
          break;

        case 18:
          pComputer->wProcessor = _80186;
          pszString = pszIntel80186;
          break;

        case 28:
          pComputer->wProcessor = _80286;
          pszString = pszIntel80286;
          break;

        case 38:
          pComputer->wProcessor = _80386;
          pszString = pszIntel80386;
          break;

        case 48:
          /* If a 80837 was detected, it is a i486 */
          /*   If not, it was a 486SX              */

          if (wCoProcessor == 3)
            {
              pComputer->wProcessor = _80486;
              pszString = pszInteli486;
            }
          else
            {
              pComputer->wProcessor = _80486SX;
              pszString = pszIntel486SX;
            }

          break;

        case 20:
          pComputer->wProcessor = _NECV20;
          pszString = pszNECV20;
          break;

        default:
          pComputer->wProcessor = 0;
          pszString = "";
     }

    /* Set the string in the structure */
    strcpy (pComputer->szProcessor, pszString);


    /* Set co-processor type */

    switch (wCoProcessor)
      {
        case 0:
          pComputer->wCoProcessor = _NOCOPROCESSOR;
          pszString = pszNone;
          break;

        case 1:
          pComputer->wCoProcessor = _8087;
          pszString = pszIntel8087;
          break;

        case 2:
          pComputer->wCoProcessor = _80287;
          pszString = pszIntel80287;
          break;

        case 3:
          if (wProcessor == 48)
            {
              pszString = pszInternal;
              pComputer->wCoProcessor = _INTERNAL;
            }
          else
            {
              pszString = pszIntel80387;
              pComputer->wCoProcessor = _80387;
            }

          break;

        default:
          pComputer->wCoProcessor = _NOCOPROCESSOR;
          pszString = pszUnknown;
      }

    /* Set the string in the structure */
    strcpy (pComputer->szCoProcessor, pszString);
  }

  return (FALSE);
}


/*********************************************************************
 * SprintComputerInfo - Put "Computer" information into a set of
 *                      strings to be printed or displayed.
 *
 * pComputer    - Pointer to computer information structure.
 * szSumStrings - Strings to store the summary information.
 *
 * Returns:  NULL if an error occured, or if summary information
 *           obtained.
 *********************************************************************/

QSZ * SprintComputerInfo (COMPUTER_STRUCT *pComputer,
                          CHAR szSumStrings[][MAX_SUMM_INFO + 5])
{
  WORD wNmbrStrings;        /* Number of strings                     */
  WORD wNmbrChars;          /* Number of characters in the strings   */
  WORD wIndex;              /* Index to the structure of TSR data    */
  WORD i;                   /* Looping variable                      */
  QSZ  *pqszStrings = NULL; /* Location for storing string pointers  */


  /* Set the summary info, if required */
  if (szSumStrings != NULL)
    {
      WORD wLength;   /* String length */


      /* Computer name */
      strncpy (szSumStrings[0], pComputer->szComputerName, MAX_SUMM_INFO);

      /* Remove trailing spaces */
      wLength = strlen (szSumStrings[0]);

      while (--wLength > 0 && szSumStrings[0][wLength] == ' ')
        szSumStrings[0][wLength] = '\0';

      /* Slash */
      strncat (szSumStrings[0], "/",
               MAX_SUMM_INFO - strlen (szSumStrings[0]));

      /* BIOS Manufacturer */
      strncat (szSumStrings[0], pComputer->szBiosMfgr,
               MAX_SUMM_INFO - strlen (szSumStrings[0]));

      /* Processor and Co-Processor */
      strncpy (szSumStrings[1], pComputer->szProcessor, MAX_SUMM_INFO);
      if (pComputer->wCoProcessor != _NOCOPROCESSOR &&
          pComputer->wCoProcessor != _INTERNAL)
        {
          strncat (szSumStrings[1], "/",
                   MAX_SUMM_INFO - strlen (szSumStrings[1]));
          strncat (szSumStrings[1], pComputer->szCoProcessor,
                   MAX_SUMM_INFO - strlen (szSumStrings[1]));
        }

      return (NULL);
    }

  /* Overestimate the amount of space required for the strings */

  wNmbrStrings = 19;
  wNmbrChars   = sizeof (COMPUTER_STRUCT) +
                 (wNmbrStrings * MAX_COMPUTER_TITLE_LENGTH) + 50;


  /* Allocate space for the pointer area and string area */
  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);


  /* Put the information in place */

  for (i = 0, wIndex = 0; paszComputerTitles[wIndex] != NULL ; ++i, ++wIndex)
    {
      WORD wIndent;                         /* Amount to indent       */
      CHAR chBuffer[MAX_BIOS_VERSION_LEN];  /* Buffer for string data */
      PSZ  pszString = NULL;                /* String pointer         */


      /* Title for this line of data */

      wIndent = MAX_COMPUTER_TITLE_LENGTH -
                strlen (paszComputerTitles[wIndex]);

      Qmemset (pqszStrings[i], ' ', wIndent);

      Qstrcpy (&pqszStrings[i][wIndent], paszComputerTitles[wIndex]);


      /* Place the appropriate information on the line */

      switch (wIndex)
        {
          case COMP_NAME:
            pszString = pComputer->szComputerName;
            break;

          case COMP_BIOS_MFGR:
            pszString = pComputer->szBiosMfgr;
            break;

          case COMP_BIOS_VERSION_1:
            pszString = pComputer->aszBiosVersion[0];

            /* Skip blank BIOS version lines */
            if (pComputer->aszBiosVersion[1][0] == '\0')
              wIndex += 2;
            break;

          case COMP_BIOS_VERSION_2:
            pszString = pComputer->aszBiosVersion[1];

            /* Skip blank BIOS version lines */
            if (pComputer->aszBiosVersion[2][0] == '\0')
              ++wIndex;
            break;

          case COMP_BIOS_VERSION_3:
            pszString = pComputer->aszBiosVersion[2];
            break;

          case COMP_BIOS_CATEGORY:
            pszString = pComputer->szBiosCategory;
            break;

          case COMP_BIOS_ID_BYTES:
            sprintf (chBuffer, "%02X %02X %02X", pComputer->bComputerType,
                     pComputer->bSubModel, pComputer->bRevisionLevel);
            pszString = chBuffer;

            /* Determine if the submodel and revision level */
            /*   bytes are available                        */
            if (pComputer->fConfigCallSupported == FALSE)
              chBuffer[2] = '\0';
            break;

          case COMP_BIOS_DATE:
            pszString = pComputer->szBiosDate;
            break;

          case COMP_PROCESSOR:
            pszString = pComputer->szProcessor;
            break;

          case COMP_COPROCESSOR:
            pszString = pComputer->szCoProcessor;
            break;

          case COMP_KEYBOARD:
            pszString = pComputer->szKeyboardType;
            break;

          case COMP_BUS_TYPE:
            pszString = pComputer->szBusType;
            break;

          case COMP_DMA_CTLRER:
            pszString = (pComputer->fDmaChipPresent) ? pszYes : pszNo;
            break;

          case COMP_CASCADE_IRQ2:
            pszString = (pComputer->fCascadeIntLvl2) ? pszYes : pszNo;
            break;

          case COMP_BIOS_DATA_SEG:
            if (pComputer->wExtAreaSeg)
              {
                sprintf (chBuffer, "%04X %dk", pComputer->wExtAreaSeg,
                         pComputer->wExtAreaLen);
                pszString = chBuffer;
              }
            else
              pszString = pszNone;
            break;

          default:
            pszString = "";
        }

      /* Put the information on the line */
      Qstrcat (pqszStrings[i], pszString);

      /* Set the next pointer */
      PrepNextString (pqszStrings, i);
    }

  /* Set the last pointer to NULL */

  pqszStrings[i] = NULL;

  /* Return the pointer to ppszStrings */

  return (pqszStrings);
}


/*********************************************************************
 * GetRomName - Finds a name in the computer/video card's ROM.
 *
 * fSearchType - Video bios search, or computer name search.
 * ppszStrings - List of names to search for.
 *
 * Returns:  String pointer to computer name, and sets wStringNmbr to
 *           the string number in ppszStrings that was found.
 *********************************************************************/

WORD GetRomName (BOOL fSearchType, PSZ *ppszStrings)
{
  WORD i, u;                /* Looping Variables */
  ADDR_LENGTH *pal = NULL;  /* Address length structure to use */

  /* Addresses to search for computer information*/
  static ADDR_LENGTH alComputer[] =
    {
      { 0xF0000000, 256 },
      { 0xF0001000, 256 }, /* This was added for Zenith    */
      { 0xF00012A0,  32 }, /* This was added for Telex     */
      { 0xF0006000, 256 }, /* This was added for Headstart */
      { 0xF0008000, 256 },
      { 0xF0008D00, 256 }, /* This was added for DTK       */
      { 0xF000A140,  16 }, /* This was added for Mitac     */
      { 0xF000A440,  32 }, /* This was added for Intel     */
      { 0xF000AF70,  64 }, /* This was added for Acer      */
      { 0xF000B3F0, 256 }, /* This was added for Acer      */
      { 0xF000C000, 256 },
      { 0xF000D000, 256 },
      { 0xF000E000, 256 },
      { 0xF000E300, 128 }, /* This was added for Northgate */
      { 0, 0 }
    };

  /* Addresses to search for video information */

  static ADDR_LENGTH alVideoNames[] =
    {
      { 0xC0000000, 512 },
      { 0xC0003F90,  17 }, /* Added for Compaq EGA         */
      { 0xC0000400, 128 }, /* Added for Genoa Spectra      */
      { 0xC0007F00,  64 }, /* Added for Tandy              */
      { 0xC0005F00, 512 }, /* Compaq video cards           */
      { 0, 0 }
    };

  static ADDR_LENGTH alVideoModels[] =
    {
      { 0xC0000000, 512 },
      { 0xC0000400, 256 }, /* Added for Genoa Spectra      */
      { 0xC0000A00, 512 }, /* Added for Video Seven 1024i  */
      { 0xC0000C00, 256 }, /* Added for Genoa Super EGA    */
      { 0xC0003B00, 128 }, /* Added for Tecmar VGA/AD      */
      { 0xC0007A00, 512 }, /* Added for Video Seven FastWrite */
      { 0, 0 }
    };


  /* Choose the correct search areas */

  if (fSearchType == GET_COMPUTER_NAME  ||
      fSearchType == GET_BIOS_MFGR)
    pal = alComputer;
  else if (fSearchType == GET_VIDEO_NAME)
    pal = alVideoNames;
  else
    pal = alVideoModels;


  /* Search for matches */

  for (i = 1; ppszStrings[i] != NULL; ++i)
    for (u = 0; pal[u].wLength != 0; ++u)
      if (fbiInstr ((CHAR FAR *) pal[u].dwAddress, ppszStrings[i],
                    pal[u].wLength))
        return (i);

  return (0);
}


/*********************************************************************
 * GetRomVersion - Finds version numbers stored in ROM.
 *
 * Returns:  TRUE if a version was found, FALSE otherwise
 *********************************************************************/

BOOL GetRomVersion (CHAR pachVersionStrings[][MAX_BIOS_VERSION_LEN],
                    CHAR FAR *fpSearchArea,
                    WORD wSearchLength)
{
  BOOL fFoundFlag = TRUE;   /* Set to TRUE if the item was found        */
  WORD wStringSegment;      /* Segment of the string that was found     */
  WORD wStringOffset;       /* Offset of the string that was found      */
  CHAR FAR *fpChars = NULL; /* Far pointer to the string of characters  */
  CHAR FAR *fpMatch = NULL; /* Used to detect if a match occured        */
  CHAR chSearchChar = '.';  /* Character to search for                  */
  WORD i, u;                /* Looping variables                        */
  WORD iIndex = 0;          /* Index to pachVersionStrings              */
  WORD wRomLength;          /* Length of ROM string start to ver number */

                            /* Version number search strings            */
  static PSZ  paszSearchStrings[] =
    {
      "Ver",
      "Rev",
      "Rel",
      "v0",
      "v1",
      "v2",
      "v3",
      "v4",
      "v5",
      "v6",
      "v7",
      "v8",
      "v9",
      "v 0",
      "v 1",
      "v 2",
      "v 3",
      "v 4",
      "v 5",
      "v 6",
      "v 7",
      "v 8",
      "v 9",
      NULL
    };

  /* Clear out the strings */

  for (i = 0; i < MAX_BIOS_VERSION_STRINGS; ++i)
    pachVersionStrings[i][0] = '\0';


  /* Search for a period with a digit on either side */

  while (iIndex < MAX_BIOS_VERSION_STRINGS && fFoundFlag)
    {
      _asm
        {
          push  di                ; Save DI
          les   di,fpSearchArea   ; Point to search area
          mov   cx,wSearchLength  ; Search the entire distance
          mov   al,chSearchChar   ;   For a period

        ContinueSearch:
          repnz scasb             ; Search

          jnz   not_found         ; If we went to the end, drop out

          mov   ah,es:[di]        ; Is the next character a number
          cmp   ah,'9'            ; Is the next character a number
          jg    keep_looking      ; If > '9', keep looking

          cmp   ah,'0'
          jl    keep_looking      ; If < '0', keep looking

          mov   ah,es:[di-2]      ; Is the previous character a number
          cmp   ah,'9'
          jg    keep_looking      ; If > '9', keep looking

          cmp   ah,'0'
          jl    keep_looking      ; If < '0', keep looking

          jmp   was_found         ; Otherwise, we found it

        keep_looking:             ; This isn't a version/date, keep looking
          inc   di
          dec   cx
          jnz   ContinueSearch

        not_found:
          mov   fFoundFlag,FALSE  ; Set the flag saying we didn't find it
          jmp   done

        was_found:
          mov   fFoundFlag,TRUE   ; We found it
          mov   wSearchLength,cx  ; Set the variables to continue the search
          mov   wStringOffset,di
          mov   wStringSegment,es

        done:
          pop   di
        }

      if (iIndex < MAX_BIOS_VERSION_STRINGS && fFoundFlag)
        {
          /* Set the pointer for continuing the search */
          fpSearchArea = (CHAR FAR *)
                           ((DWORD) wStringSegment << 16) +
                           (DWORD) wStringOffset;

          /* Set the pointer for printing the string */
          fpChars      = fpSearchArea;
          wRomLength   = 0;

          /* Search for the beginning of the string */
          while (wRomLength < MAX_BIOS_VERSION_LEN - 8 &&
                 *fpChars >= ' ' && *fpChars <= 127 && *fpChars != '$')
            --fpChars, ++wRomLength;

          ++fpChars;


          /* Can one of the search strings be found */

          for (u = 0;
               paszSearchStrings[u] != NULL &&
               (fpMatch = fbiInstr (fpChars,
                                    paszSearchStrings[u],
                                    wRomLength)) == 0;
               ++u)
            ;


          /* If fpMatch is non-zero, we found a match */

          if (fpMatch)
            {
              /* Skip leading whitespace */
              for (; *fpChars == ' '; ++fpChars)
                ;

              /* Copy the string into the pachVersionStrings */
              for (i = 0; i < MAX_BIOS_VERSION_LEN - 1 &&
                   *fpChars >= ' ' && *fpChars <= 127 && *fpChars != '$';
                   ++i, ++fpChars)
                pachVersionStrings[iIndex][i] = *fpChars;

              pachVersionStrings[iIndex][i] = '\0';

              /* Bump the index to the version strings */
              ++iIndex;
            }
        }
    }

  return (TRUE);
}



/*********************************************************************
 * GetRomDate - Finds the most recent date in the computer/video
 *              card's ROM.  When GetRomDate encounters a date, it
 *              checks the previously found date to see if the new
 *              date is more recent.
 *
 * fpSearchArea  - Area to search for a date (ie., F000:0000).
 * wSearchLength - Length of search (ie., FFFFH).
 * pchDateString - Location to store the date.
 *
 * Returns:  TRUE if a date was found, FALSE otherwise
 *********************************************************************/

BOOL GetRomDate (CHAR FAR * fpSearchArea,
                 WORD wSearchLength,
                 CHAR * pchDateString)
{
  BOOL fFoundFlag = TRUE;  /* Set to TRUE if the item was found       */
  WORD wStringSegment = 0; /* Segment of the string that was found    */
  WORD wStringOffset  = 0; /* Offset of the string that was found     */
  CHAR FAR *fpChars = NULL;/* Far pointer to the string of characters */
  CHAR chSearchChar = '/'; /* Date separator character                */
  CHAR chPrevDate[MAX_BIOS_DATE];   /* First date found               */
  CHAR chCurrDate[MAX_BIOS_DATE];   /* Date currently being examined  */
  WORD i;                  /* Looping variable                        */
  WORD wLength;            /* Number of characters to move            */


  /* Clear out the previous date */
  memset (chPrevDate, '\0', MAX_BIOS_DATE);



  while (fFoundFlag)
    {
      {
        _asm
          {
            cld
            push  di                ; Save DI
            les   di,fpSearchArea   ; Point to search area
            mov   cx,wSearchLength  ; Search the entire distance
            mov   al,chSearchChar   ;   for the date separator

          ContinueSearch:
            repnz scasb             ; Search


            jnz   not_found         ; If we went to the end, drop out

            cmp   al,es:[di + 2]    ; Is a date separator 2 chars away
            jne   keep_looking      ; If not, keep looking

            mov   ah,es:[di]        ; Is the next character a number
            cmp   ah,'9'
            jg    keep_looking      ; If > '9', keep looking

            cmp   ah,'0'
            jl    keep_looking      ; If < '0', keep looking

            mov   ah,es:[di - 2]    ; Is the previous character a number
            cmp   ah,'9'
            jg    keep_looking      ; If > '9', keep looking

            cmp   ah,'0'
            jl    keep_looking      ; If < '0', keep looking

            jmp   was_found         ; Otherwise, we found it

          keep_looking:             ; This isn't a version/date, keep looking
; ----- This is added in case the BIOS ends with a '/'
            or    cx,cx             ; Are we at the end
            jz    not_found         ; If we are, drop out.
; -----
            inc   di
            dec   cx
            jnz   ContinueSearch

          not_found:
            mov   fFoundFlag,FALSE  ; Set the flag saying we didn't find it
            jmp   done

          was_found:
            mov   fFoundFlag,TRUE   ; We found it
            mov   wSearchLength,cx  ; Set the variables to continue the search
            mov   wStringOffset,di
            mov   wStringSegment,es

          done:
            pop   di
          }
        }


      if (fFoundFlag)
        {

          /* Set the pointer for continuing the search */
          fpSearchArea = (CHAR FAR *)
                           ((DWORD) wStringSegment << 16) +
                           (DWORD) wStringOffset;


          /* Set the pointer to the beginning of the date */

          fpChars      = fpSearchArea - 3;

          /* Copy the year into chCurrDate */
          chCurrDate[0] = fpChars[6];
          chCurrDate[1] = fpChars[7];
          chCurrDate[2] = chSearchChar; /* The 1st "/" for YY/MM/DD */


          /* Copy the month & day into chCurrDate              */
          /*   (Process properly if this is a one digit month) */

          if (*fpChars > '9' || *fpChars < '0')
            {
              ++fpChars;
              chCurrDate[3] = '0';
              i = 4;
              wLength = 4;
            }
          else
            {
              i = 3;
              wLength = 5;
            }

          _fmemcpy ((CHAR FAR *) &chCurrDate[i], fpChars, wLength);


          /* Compare the dates, to see which is more recent */
          if (memcmp (chPrevDate, chCurrDate, MAX_BIOS_DATE - 1) < 0)
            memcpy (chPrevDate, chCurrDate, MAX_BIOS_DATE - 1);
        }
    }


  /* If we did not find a date */

  if (chPrevDate[0] == '\0')
    {
      pchDateString[0] = '\0';
      return (FALSE);
    }


  /* Put the date from chPrevDate's YY/MM/DD format */
  /*   into pchDateString's MM/DD/YY format         */

  pchDateString[5] = chSearchChar;
  pchDateString[6] = chPrevDate[0];
  pchDateString[7] = chPrevDate[1];

  memcpy (pchDateString, &chPrevDate[3], 5);

  pchDateString[8] = '\0';

  return (TRUE);
}


/*********************************************************************
 * fbiInstr - far, buffer, case-insensitive, INSTR function
 *
 * fpSearchArea      Far pointer to the area of memory to search
 *                        (ie, 0xF0000000 for ROM BIOS area)
 *
 * pszSearchString   String you are looking for in the distant
 *                        memory area pointed to by cfpAreaToSearch
 *                        (ie, "COPYRIGHT")
 *
 * wSearchLength     How much memory to search through
 *                        (ie, 0x8000 or 0xFFFF)
 *
 * Returns: Far pointer to the string if it was found, NULL if the
 *          string was not found.
 *********************************************************************/

CHAR FAR *fbiInstr (CHAR FAR *fpSearchArea,
                    PSZ      pszSearchString,
                    WORD     wSearchLength)
{
  BOOL fFoundFlag = TRUE;   /* Set to TRUE if the item was found    */
  CHAR chSearchChar1;       /* First character of search string     */
  CHAR chSearchChar2;       /* Second character of search string    */
  CHAR chSearchChar3;       /* Third character of search string     */
  CHAR chSearchChar4;       /* Fourth character of search string    */
  WORD wStringSegment;      /* Segment of the string that was found */
  WORD wStringOffset;       /* Offset of the string that was found  */
  WORD wLength;             /* Length of search string              */


  /* Set wLength to the length of the search string */
  wLength = strlen (pszSearchString);


  /* Get the first four characters to scan for */
  chSearchChar1 = pszSearchString[0];
  chSearchChar2 = pszSearchString[1];
  chSearchChar3 = pszSearchString[2];
  chSearchChar4 = pszSearchString[3];


  /* Search for the first two characters */

  while (fFoundFlag)
    {
      _asm
        {
          mov   cx,wSearchLength  ; Search the entire distance
          mov   bh,chSearchChar1  ;   for the first four characters
          mov   bl,chSearchChar2
          mov   dh,chSearchChar3
          mov   dl,chSearchChar4

          and   bx,0xDFDF         ; Fast "toupper()" all 4 characters
          and   dx,0xDFDF

          push  ds                ; Save DS
          push  si                ; Save SI
          lds   si,fpSearchArea   ; Point to search area

          push  si

        ContinuePop:              ; For continuing searches
          pop   si

        ContinueSearch:
          lodsb                   ; Search
          and   al,0xDF           ; Fast "toupper()"
          cmp   bh,al             ; Is it a match?

          loopne  ContinueSearch  ; Loop if not found

          push  si                ; Save SI, in case this didn't match.
                                  ;   (DS remains the same, so preserving
                                  ;   it is not necessary).

          and   cx,cx             ; Is CX == 0?
          jz    not_found         ; If so, we're done

          and   bl,bl             ; Is the 2nd character a NULL?
          jz    was_found         ; If so, we found it

          lodsb                   ; Otherwise, check the 2nd character

          and   al,0xDF           ; Fast "toupper()"
          cmp   bl,al             ; Is it a match?

          loopne  ContinuePop     ; Loop if not found

          and   cx,cx             ; Is CX == 0 (end of search length)?
          jz    not_found         ; We're done (no match)

          and   dh,dh             ; Is the 3rd character a NULL?
          jz    was_found         ; If so, we found it

          lodsb                   ; Otherwise, check the 3rd character

          and   al,0xDF           ; Fast "toupper()"
          cmp   dh,al             ; Is it a match?

          loopne  ContinuePop     ; Loop if not found

          and   cx,cx             ; Is CX == 0 (end of search length)?
          jz    not_found         ; We're done (no match)

          and   dl,dl             ; Is the 4th character a NULL?
          jz    was_found         ; If so, we found it

          lodsb                   ; Otherwise, check the 4th character

          and   al,0xDF           ; Fast "toupper()"
          cmp   dl,al             ; Is it a match?

          loopne  ContinuePop     ; Loop if not found

          and   cx,cx             ; Is CX == 0 (end of search length)?
          jz    not_found         ; We're done (no match)

          jmp   was_found         ; Otherwise, we have a match

        not_found:
          pop   ax                ; Remove the SI from the stack
          mov   fFoundFlag,FALSE  ; Set the flag saying we didn't find it
          jmp   done

        was_found:                ; Adjust SI to point
          pop   si                ;   directly at the string
          dec   si

          mov   fFoundFlag,TRUE   ; We found it
          mov   wSearchLength,cx  ; Set the variables to continue the search
          mov   wStringOffset,si
          mov   wStringSegment,ds

        done:
          pop   di
          pop   ds
        }

      if (fFoundFlag)
        {

          /* Set the pointer for continuing the search */
          fpSearchArea = (CHAR FAR *)
                           ((DWORD) wStringSegment << 16) +
                           (DWORD) wStringOffset;

          /* If the strings fully match, return the address of the string */
          if (!(_fmemicmp (fpSearchArea, (CHAR FAR *) pszSearchString,
                          wLength)))
            return (fpSearchArea);
          else
            /* Otherwise, keep searching */
            fpSearchArea = (wLength < 4) ? fpSearchArea + wLength :
                           fpSearchArea + 4;
        }
      else
        return (NULL);
    }
}


/*********************************************************************
 * fbMemString - far, buffer, string locator.  Looks forward and
 *               backwards for the first non-printing ASCII characters
 *               to locate the beginning and ending of a string in
 *               RAM.  Skips white space at the beginning and end of
 *               the string.
 *
 * pszfString1   Far pointer to the area of memory containing the
 *               string.
 *
 * pwLength      Changed to reflect the length of the string.
 *
 * returns CHAR FAR * to beginning of string, and pwLength is changed
 *         to reflect the length of the string.
 *********************************************************************/

CHAR FAR *fbMemString (register CHAR FAR *pszfString,
                       register WORD *pwLength)
{
  int iNewLineCount = 0;    /* Counts the number of newline characters */
  int iCountSinceNewLine = 0; /* Number of characters since the last newline */
  int iCharCount    = 0;    /* Counts the number of characters preceeding */
                            /*   the found string */

  /* Search backwards to beginning of string or 192 bytes */
  /*   or three lines, whichever is less                  */
  while (++iCharCount < 192 && iNewLineCount <= 3 && 
         ((*pszfString >= ' ' && *pszfString <= 126 &&
           *pszfString != '$' && *pszfString != '@') ||
           *pszfString == '\r' || *pszfString == '\n' ||
           *pszfString == '\t'))
    {
      if (*pszfString == '\r' || iCountSinceNewLine > REPORT_WIDTH - 10)
        {
          ++iNewLineCount;
          iCountSinceNewLine = 0;
        }
      else
        ++iCountSinceNewLine;

      --pszfString;
    }

  ++pszfString;
  iNewLineCount = 0;

  /* Skip over whitespace at the beginning of the string */
  while (*pszfString == ' ' || *pszfString == '\r' ||
         *pszfString == '\n' || *pszfString == '\t')
    ++pszfString;

  *pwLength = 0;
  iCountSinceNewLine = 0;

  /* Search forward to end of readable text */
  while ((pszfString[*pwLength] >= ' ' && pszfString[*pwLength] <= 126 &&
          pszfString[*pwLength] != '$' && pszfString[*pwLength] != '@') ||
          pszfString[*pwLength] == '\r' || pszfString[*pwLength] == '\n' ||
          pszfString[*pwLength] == '\t')
    {
      if (pszfString[*pwLength] == '\r')
        if (++iNewLineCount > 4)
          break;
        else
          iCountSinceNewLine = 0;


      if (++iCountSinceNewLine > REPORT_WIDTH - 10)
        if (++iNewLineCount > 4)
          break;
        else
          iCountSinceNewLine = 0;

      ++(*pwLength);
    }

  /* Search backward to first printable character which will */
  /*   skip over whitespace at the end of the string */
  while (pszfString[*pwLength] <= ' ' || pszfString[*pwLength] > 127 ||
         pszfString[*pwLength] == '$' || pszfString[*pwLength] == '@')
    --(*pwLength);

  *pwLength = (++(*pwLength)> 240) ? 240 : *pwLength;

  return (pszfString);
}


/**********************************************************************
 * GetBiosCageory - Uses bComputerType, bSubModel, and bRevisionLevel
 *                           to determine the computer descriptions.
 *
 * pComputer - Computer information structure.
 *
 * Returns:  VOID
 **********************************************************************/

#define UNKNOWN_COMPUTER  paszCommonStrings[0]
#define IBM_PC            paszCommonStrings[1]
#define IBM_PCJR          paszCommonStrings[2]
#define IBM_CONVERTIBLE   paszCommonStrings[3]
#define IBM_XT            paszCommonStrings[4]
#define IBM_XT_286        paszCommonStrings[5]
#define IBM_AT            paszCommonStrings[6]
#define IBM_PS2_25        paszCommonStrings[7]
#define IBM_PS2_25_30     paszCommonStrings[8]
#define IBM_PS2_30        paszCommonStrings[9]
#define IBM_PS2_30_286    paszCommonStrings[10]
#define IBM_PS2_50        paszCommonStrings[11]
#define IBM_PS2_50Z       paszCommonStrings[12]
#define IBM_PS2_55SX      paszCommonStrings[13]
#define IBM_PS2_60        paszCommonStrings[14]
#define IBM_PS2_70        paszCommonStrings[15]
#define IBM_PS2_P70       paszCommonStrings[16]
#define IBM_PS2_70_80     paszCommonStrings[17]
#define IBM_PS2_80        paszCommonStrings[18]
#define IBM_PS2_90        paszCommonStrings[19]
#define IBM_PS1           paszCommonStrings[20]
#define IBM_PS2_65SX      paszCommonStrings[21]

static char *paszCommonStrings[] =
  {
    "Not Determined",
    "IBM PC",
    "IBM PCjr",
    "IBM PC Convertible",
    "IBM PC/XT",
    "IBM PC/XT 286",
    "IBM PC/AT",
    "IBM PS/2 Model 25",
    "IBM PS/2 Model 25/30",
    "IBM PS/2 Model 30 286",
    "IBM PS/2 Model 30",
    "IBM PS/2 Model 50",
    "IBM PS/2 Model 50Z",
    "IBM PS/2 Model 55SX",
    "IBM PS/2 Model 60",
    "IBM PS/2 Model 70",
    "IBM PS/2 Model P70",
    "IBM PS/2 Model 70/80",
    "IBM PS/2 Model 80",
    "IBM PS/2 Model 90",
    "IBM PS/1",
    "IBM PS/2 Model 65SX"
  };

VOID GetBiosCategory (COMPUTER_STRUCT *pComputer)
{
  CHAR chBuffer[80];          /* Buffer for concatination of strings */
  PSZ pszString = chBuffer;   /* String pointer.  Pointing pszString */
                              /*   to chBuffer allows easy           */
                              /*   concatination of strings          */

  switch (pComputer->bComputerType)
    {
      case 0xff:
        {
          switch (pComputer->bRevisionLevel)
            {
              case 00:
              case 01:
                pszString = IBM_PC;
                break;

              case 02:
                pszString = IBM_XT;
                break;

              default:
                pszString = IBM_PC;
                break;
            }
          break;
        }

      case 0xfe:
        pszString = IBM_XT;
        break;

      case 0xfd:
        pszString = IBM_PCJR;
        break;

      case 0xfc:
        {
          switch (pComputer->bSubModel)
            {
              case 00:
              case 01:
                pszString = IBM_AT;
                break;

              case 02:
                pszString = IBM_XT_286;
                break;

              case 03:
                pszString = IBM_AT;
                break;

              case 04:
                {
                  switch (pComputer->bRevisionLevel)
                    {
                      case 00:
                        pszString = IBM_PS2_50;
                        break;

                      case 03:
                        pszString = IBM_PS2_50Z;
                        break;

                      default:
                        pszString = IBM_PS2_50;
                        break;
                    }
                  break;
                }

              case 05:
                pszString = IBM_PS2_60;
                break;

              case 9:
                pszString = IBM_PS2_30_286;
                break;

              case 0x0B:
                pszString = IBM_PS1;
                break;

              case 0x81:
                pszString = "Phoenix PC/AT Compatible BIOS";
                break;

              default:
                pszString = IBM_AT;
                break;
            }
          break;
        }

      case 0xfb:
        pszString = IBM_XT;
        break;

      case 0xfa:
        {
          switch (pComputer->bSubModel)
            {
              case 00:
                pszString = IBM_PS2_30;
                break;

              case 01:
                pszString = IBM_PS2_25;
                break;

              default:
                pszString = IBM_PS2_30;
                break;
            }
          break;
        }

      case 0xf9:
        pszString = IBM_CONVERTIBLE;
        break;

      case 0xf8:
        {
          switch (pComputer->bSubModel)
            {
              case 0:
              case 1:
                pszString = IBM_PS2_80;
                break;

              case 4:
              case 9:
              case 0x0A:
                pszString = IBM_PS2_70;
                break;

              case 0x0C:
                pszString = IBM_PS2_55SX;
                break;

              case 0x0D:
                pszString = IBM_PS2_70;
                break;

              case 0x14:
              case 0x16:
                pszString = IBM_PS2_90;
                break;

              case 0x1C:
                pszString = IBM_PS2_65SX;
                break;

              case 0x0B:
              case 0x50:
                pszString = IBM_PS2_P70;
                break;

              default:
                pszString = IBM_PS2_70_80;
                break;
            }
          break;
        }

      default:
        pszString = UNKNOWN_COMPUTER;
    }

  /* Set the value in the structure */

  strcpy (pComputer->szBiosCategory, pszString);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\config.h ===
/*****************************************************************/
/**		     Microsoft LAN Manager			**/
/**	       Copyright(c) Microsoft Corp., 1987-1990		**/
/*****************************************************************/
/********************************************************************
 *								    *
 *  About this file ...  CONFIG.H				    *
 *								    *
 *  This file contains information about the NetConfig APIs.	    *
 *								    *
 ********************************************************************/

/*NOINC*/
#ifndef NETCONFIG_INCLUDED

#define NETCONFIG_INCLUDED
/*INC*/


/****************************************************************
 *                                                              *
 *              Function prototypes                             *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetConfigGet ( const char far *     pszComponent,
		 const char far *     pszParameter,
		 char far *	      pbBuffer,
                 unsigned short       cbBuffer,
		 unsigned short far * pcbParmlen );

extern API_FUNCTION
  NetConfigGetAll ( const char far *	 pszComponent,
		    char far *		 pbBuffer,
                    unsigned short       cbBuffer,
		    unsigned short far * pcbReturned,
		    unsigned short far * pcbTotalAvail );

extern API_FUNCTION
  NetConfigGet2 ( const char far *     pszServer,
		  const char far *     pszReserved,
		  const char far *     pszComponent,
		  const char far *     pszParameter,
		  char far *	       pbBuffer,
                  unsigned short       cbBuffer,
		  unsigned short far * pcbParmlen );

extern API_FUNCTION
  NetConfigGetAll2 ( const char far *	  pszServer,
		     const char far *	  pszReserved,
		     const char far *	  pszComponent,
		     char far * 	  pbBuffer,
                     unsigned short       cbBuffer,
		     unsigned short far * pcbReturned,
		     unsigned short far * pcbTotalAvail );


/**INTERNAL_ONLY**/

struct config_info_0 {
	char far * Key;
	char far * Data;
};

extern API_FUNCTION
  NetConfigSet (char far * Server, char far * Reserved1, char far * Component,
		unsigned short Level, unsigned short Reserved2, char far * Buffer,
		unsigned short Buflen, unsigned long Reserved3);
/**END_INTERNAL**/

/*NOINC*/
#endif /* NETCONFIG_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\dialogs.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * DIALOGS.C - Source file for handling the various dialog boxes
 ********************************************************************/


/* Include Files */

#include "msd.h"


#ifdef CW_INCLUDED


// An example of how to call ADM to process your dialog.

//VOID CallReportsDialog()
//{
//  WORD wReturn;

  // Call with the address of the dialog template ( in dialog.adm ) and
  // the address of the app's dialog proc.
  // wReturn will contain the value passed to EndDialog () within the apps
  // dialog proc.

//  wReturn = DialogBox ( &dlgReport, ReportDlg );
//}


/* Global to this file */
char EditBuf[256];
char EditBuf2[256];
char EditBuf3[256];


/*********************************************************************
 * ReportDlg - Procedure to handle the Print Report dialog box.
 *********************************************************************/

LONG FAR PASCAL ReportDlg (PWND pwnd,
                           WORD message,
                           WORD wParam,
                           DWORD lParam)
{
  WORD i;                      /* Looping variable              */


  switch (message)
    {
      // WM_INITDIALOG is your chance to perform Dialog initialization before
      // before the dialog box is displayed.

      case WM_INITDIALOG:
        {
          // Gives the dialog box a border.
          SetWindowStyle ( pwnd, pwnd->style | WS_BORDER );

          // Gives the dialog box a shadow.
          //  pwnd->wExtStyle |= WS_SHADOW;

          // It is the repsonsibility of the application to supply a buffer
          //  for the edit control. In the example below, EditBuf is the
          //  buffer declared in the source, somewhere. ( Don't make it a local
          //  variable in this proc!!! ). lParam has two values set, both equal
          //  to 255. These values are the size of the buffer. If your buffer
          //  is only 80 characters wide, then use MAKELONG(80,80).
          //
          SendMessage (GetDlgItem (pwnd, IDD_USER + 33), EM_SETBUF,
                       (WORD) EditBuf, MAKELONG (255, 255));


          /* Set the default edit text */
          SetEditText (GetDlgItem (pwnd, IDD_USER + 33), "REPORT.MSD", TRUE);

          // We should set a default value for the group of radio buttons
          // which indicate where we 'Print To'. Like under Windows,
          // The first parameter is the Dialog PWND, 2nd and third are the id's
          // of the first and last radio button in the group. The fourth paramter
          // is the ID of the radio button that is initally 'on'.

          /* Set the default to what it was when we left (wReportToIndex) */
          CheckDlgRadioButton (pwnd, IDD_USER + 25, IDD_USER + 32,
                               wReportToIndex + IDD_USER + 25);

          /* Set the default items to report */
          for (i = 2; i < MAX_REPORT_ITEM_FLAGS; ++i)
            if (rgfReportItemFlag[i] == TRUE)
              {
                // CheckDlgButton (GetDlgItem (pwnd, IDD_USER + i),
                //                 bstOn, TRUE);

                SendMessage (GetDlgItem (pwnd, IDD_USER + i),
                                    BM_SETCHECK, TRUE, 0L);
                DrawWindow ((PWND_BTN) GetDlgItem (pwnd, IDD_USER + i));
              }

          break;
        }

      case WM_DRAWITEM:
        {
          DrawPlateButton1 (pwnd, message, wParam, lParam);
          break;
        }

      case WM_COMMAND:
        // For the 'Print To' radio group, we have to assume responsability for
        // checking/unchecking the buttons.
        if ( wParam >= IDD_USER + 25 &&
             wParam <= IDD_USER + 32 )
          {
            CheckDlgRadioButton (pwnd, IDD_USER + 25, IDD_USER + 32, wParam);

            /* Set the report filename to the correct item */
            wReportToIndex = wParam - (IDD_USER + 25);

            /* If this is the "File" radio button, set the focus */
            /*   to the edit box.                                */

            if (wParam == IDD_USER + 32)
              SetFocus (GetDlgItem (pwnd, IDD_USER + 33));

            return (TRUE);
          }

        switch (wParam)
          {
            // User pressed the Ok or the Cancel Button.
            //  At this point, you should retrieve any state info you need.
            //  The Edit buffer will contain any text you may need.
            //  EndDialog MUST be called if you intend to end the dialog.

            case IDOK:
              {
                /* Set the filename for the report */
                if (wReportToIndex == 7)  /* File: */
                  {
                    CHAR chBuffer[256];  /* Holds the edit item's text */

                    GetEditText (GetDlgItem (pwnd, IDD_USER + 33),
                                 chBuffer, 255);

                    pszReportFilename = malloc (strlen (chBuffer) + 1);
                    if (pszReportFilename == NULL)
                      {
                        /* If there's insufficient memory, cancel */
                        //  EndDialog (pwnd, wParam);
                        ((PWND_DLG)pwnd)->wParamEnd = IDCANCEL;
                        break;
                      }

                    strcpy (pszReportFilename, chBuffer);
                  }

                /* Set the default items to report */
                for (i = 1; i < MAX_REPORT_ITEM_FLAGS; ++i)
                  {
                    if (SendMessage (GetDlgItem (pwnd, IDD_USER + i),
                                     BM_GETCHECK, 0, 0L))
                      rgfReportItemFlag[i] = TRUE;
                    else
                      rgfReportItemFlag[i] = FALSE;
                  }

                //  EndDialog (pwnd, wParam);
                ((PWND_DLG)pwnd)->wParamEnd = wParam;
                break;
              }

            case IDCANCEL:
              //  EndDialog (pwnd, wParam);
              ((PWND_DLG)pwnd)->wParamEnd = wParam;
              break;

            // The 'Report All' checkbox was clicked on. If it is now 'on', we
            // want to turn on all the other checkbox's. That is what this little
            // piece of code is doing.

            case IDD_USER + 1:
              if (SendMessage (GetDlgItem (pwnd, IDD_USER + 1),
                               BM_GETCHECK, 0, 0L))
                {
                  i = IDD_USER + 2;

                  for (i = IDD_USER + 2; i <= IDD_USER + 23; ++i)
                    {
                      // CheckDlgButton (GetDlgItem (pwnd, i), bstOn, TRUE);

                      SendMessage (GetDlgItem (pwnd, i),
                                   BM_SETCHECK, TRUE, 0L);
                      DrawWindow ((PWND_BTN) GetDlgItem (pwnd, i));
                    }
                }
              break;

            case IDD_USER +  2:
            case IDD_USER +  3:
            case IDD_USER +  4:
            case IDD_USER +  5:
            case IDD_USER +  6:
            case IDD_USER +  7:
            case IDD_USER +  8:
            case IDD_USER +  9:
            case IDD_USER + 10:
            case IDD_USER + 11:
            case IDD_USER + 12:
            case IDD_USER + 13:
            case IDD_USER + 14:
            case IDD_USER + 15:
            case IDD_USER + 16:
            case IDD_USER + 17:
            case IDD_USER + 18:
            case IDD_USER + 19:
            case IDD_USER + 20:
            case IDD_USER + 21:
            case IDD_USER + 22:
            case IDD_USER + 23:
              // CheckDlgButton (GetDlgItem (pwnd, IDD_USER + 1),
              //                 bstOff, TRUE);

              SendMessage (GetDlgItem (pwnd, IDD_USER + 1),
                           BM_SETCHECK, FALSE, 0L);
              DrawWindow ((PWND_BTN) GetDlgItem (pwnd, IDD_USER + 1));

              break;
          }

        break;

      case MY_EN_SETFOCUS:
        SendMessage (pwnd, WM_COMMAND, IDD_USER + 32, 0L);
        break;

      default:
        return (FALSE);
    }

  return (TRUE);
}


BOOL fDlgSearchFlags;

/*********************************************************************
 * FindFileDlg1 - Procedure to handle the Print Report dialog box.
 *********************************************************************/

LONG FAR PASCAL FindFileDlg1 (PWND pwnd,
                              WORD message,
                              WORD wParam,
                              DWORD lParam)
{
  switch (message)
    {
      // WM_INITDIALOG is your chance to perform Dialog initialization before
      // before the dialog box is displayed.

      case WM_INITDIALOG:
        {
          CHAR chPath[_MAX_PATH];   /* Current path */


          // Gives the dialog box a border.
          SetWindowStyle ( pwnd, pwnd->style | WS_BORDER );

          /* Clear out EditBuf and EditBuf2 */
          EditBuf[0]  = '\0';
          EditBuf2[0] = '\0';

          SendMessage (GetDlgItem (pwnd, IDD_USER + 1),
                       EM_SETBUF, (WORD) EditBuf, MAKELONG(255, 255));

          SendMessage (GetDlgItem (pwnd, IDD_USER + 3),
                       EM_SETBUF, (WORD) EditBuf2, MAKELONG(255, 255));

          /* Put the current path into the "Search from" edit item */
          getcwd (chPath, _MAX_PATH - 1);
          SetEditText (GetDlgItem (pwnd, IDD_USER + 3), chPath, TRUE);

          break;
        }

      case WM_DRAWITEM:
        {
          DrawPlateButton1 (pwnd, message, wParam, lParam);
          break;
        }

      case WM_COMMAND:
        switch (wParam)
          {
            WORD wResult;
            // User pressed the Ok or the Cancel Button.
            //  At this point, you should retrieve any state info you need.
            //  The Edit buffer will contain any text you may need.
            //  EndDialog MUST be called if you intend to end the dialog.

            case IDOK:
              {
                if (strlen (EditBuf) == 0)
                  {
                    MessageBox ("A filespec must be entered",
                                "in the \"Search for\" field",
                                NULL, MB_OK | 0x8000);
                    break;
                  }

                /* Check to see if a path was entered in "Search for" */
                if (strchr (EditBuf, '\\') || strchr (EditBuf, ':'))
                  {
                    PSZ pszLast;  /* Last path character */
                    CHAR chBuffer1[256];  /* Holds the edit item's text */
                    CHAR chBuffer2[256];  /* Holds the edit item's text */

                    GetEditText (GetDlgItem (pwnd, IDD_USER + 1),
                                 chBuffer1, 255);

                    /* A path was found, make it the "search from" string */
                    chBuffer2[0] = '\0';
                    strcpy (chBuffer2, chBuffer1);
                    pszLast = max (strrchr (chBuffer2, '\\'),
                                   strrchr (chBuffer2, ':'));
                    if (pszLast[0] == ':')
                      ++pszLast;

                    pszLast[0] = '\0';


                    /* Now, adjust the "search for" string */
                    pszLast = max (strrchr (chBuffer1, '\\'),
                                   strrchr (chBuffer1, ':')) + 1;

                    memmove (chBuffer1, pszLast, strlen (pszLast) + 1);
                    SetEditText (GetDlgItem (pwnd, IDD_USER + 1),
                                 chBuffer1, TRUE);
                    SetEditText (GetDlgItem (pwnd, IDD_USER + 3),
                                 chBuffer2, TRUE);
                  }

                /* Set the flags for the search */
		fDlgSearchFlags = SEARCH_VERSION;

                if (SendMessage (GetDlgItem (pwnd, IDD_USER + 4),
                                 BM_GETCHECK, 0, 0L))
                  fDlgSearchFlags |= RECURSE_INTO_SUB_DIRS;
		/*
                if (SendMessage (GetDlgItem (pwnd, IDD_USER + 5),
                                 BM_GETCHECK, 0, 0L))
                  fDlgSearchFlags |= SEARCH_BOOT_DRIVE;
		*/
		if (SendMessage (GetDlgItem (pwnd, IDD_USER + 5),
                                 BM_GETCHECK, 0, 0L))
                  fDlgSearchFlags |= SEARCH_FLOPPIES | SEARCH_LOCAL_DRIVES |
				  SEARCH_NET_DRIVES | SEARCH_ROOT;


                if ((wResult = DialogBox (&dlgFindFile2, FindFileDlg2))
                     != IDCANCEL)
                  {
                    //  EndDialog(pwnd, wParam );
                    ((PWND_DLG)pwnd)->wParamEnd = wResult;
                  }

                break;
              }

            case IDCANCEL:
              {
                //  EndDialog(pwnd, wParam );
                ((PWND_DLG)pwnd)->wParamEnd = wParam;
                break;
              }
          }

        break;

      default:
        return (FALSE);
    }

  return (TRUE);
}


/*********************************************************************
 * FindFileDlg2 - Procedure to handle the Print Report dialog box.
 *********************************************************************/

LONG FAR PASCAL FindFileDlg2 (PWND pwnd,
                              WORD message,
                              WORD wParam,
                              DWORD lParam)
{
  static FILE_INFO FAR * ffi  = NULL;   /* File Information structure */
  static FILE_INFO FAR * ffi2 = NULL;   /* File Information structure (copy) */


  switch (message)
    {
      // WM_INITDIALOG is your chance to perform Dialog initialization before
      // before the dialog box is displayed.

      case WM_INITDIALOG:
        {
          BOOL fSearchFlags = 0;  /* Search flags for FindFile  */
          CHAR chBuffer[80];      /* String to hand to list box */
          CHAR sprintfBuffer[80]; /* Buffer for sprintf-ing     */


          // Gives the dialog box a border.
          SetWindowStyle ( pwnd, pwnd->style | WS_BORDER );

          /* Clear out the previous FileInfo structure */
          FreeFileInfo (ffi2);

          /* Inform the user that we are searching */
          DisplayStatus (ST_SEARCHING);


          /* Clear out the listbox */
          SendMessage (GetDlgItem (pwnd, IDD_USER + 8),
                       LB_RESETCONTENT,
                       NULL,
                       NULL);


          /* Perform the search */
          if (EditBuf2[0] == '\0')
            ffi = FindFile (EditBuf, NULL, fDlgSearchFlags, '\0');
          else
            ffi = FindFile (EditBuf, EditBuf2, fDlgSearchFlags, '\0');

          /* Preserve the FindFile info */
          ffi2 = ffi;

          /* Redisplay the status line */
          PostMessage (pwndStatusLine, WM_PAINT, NULL, NULL);


          /* Add the filenames to the listbox */
          if (ffi == NULL || ffi->fpNextFileInfo == NULL)
            {
              MessageBox ("No matching files", NULL, NULL, MB_OK | 0x8000);
	      //  EndDialog(pwnd, wParam );

	      /* Display the previous status line text */
	      DisplayStatus (midFind);

              ((PWND_DLG)pwnd)->wParamEnd = IDCANCEL;
              break;
            }

          while (ffi != NULL && ffi->fpNextFileInfo != NULL)
            {
              DATE_INFO FAR *fpDate;  /* For printing the date   */
              WORD      wLength;      /* Length of sprintfBuffer */
              WORD      wYear;        /* Adjusted year           */


              /* Clear out chBuffer */
              memset (chBuffer, ' ', FIND_FILE_LINE_LENGTH);
              chBuffer[FIND_FILE_LINE_LENGTH] = '\0';


              /* Put the text date into chBuffer */
              fpDate = (DATE_INFO FAR *) &(ffi->wDate);

              /* Adjust date if >= year 2000 */
              wYear = 80 + fpDate->Year;
              wYear = (wYear >= 100) ? wYear - 100 : wYear;

              wLength = sprintf (sprintfBuffer, "%2d/%02d/%02d",
                                 fpDate->Month,
                                 fpDate->Day,
                                 wYear);

              strncpy (&chBuffer[DATE_COLUMN],
                       sprintfBuffer,
                       wLength);


              /* Put the file size into chBuffer */
              wLength = sprintf (sprintfBuffer, "%15lu",
                                 ffi->dwSize);

              strncpy (&chBuffer[SIZE_COLUMN],
                       sprintfBuffer,
                       wLength);


              if ((ffi->dwFileVersionMS | ffi->dwFileVersionLS) != 0)
                {
                  wLength = sprintf (sprintfBuffer,
                                     "%u.%u.%u.%u ",
                                     FP_SEG (ffi->dwFileVersionMS),
                                     FP_OFF (ffi->dwFileVersionMS),
                                     FP_SEG (ffi->dwFileVersionLS),
                                     FP_OFF (ffi->dwFileVersionLS));

                  strncpy (&chBuffer[SIZE_COLUMN + 5 - wLength],
                           sprintfBuffer,
                           wLength);
                }


              /* Put the filename into chBuffer */
              wLength = _fstrlen (ffi->fpszPathToFile);

              if (wLength > FIND_FILE_LINE_LENGTH - 2)
                wLength = FIND_FILE_LINE_LENGTH - 2;

              _fstrncpy (chBuffer, ffi->fpszPathToFile, wLength);

              chBuffer[wLength] = ' ';


              /* Add the item to the listbox */
              SendMessage (GetDlgItem (pwnd, IDD_USER + 8),
                           LB_ADDSTRING,
                           ((WORD) (isaNil) << 8) + TRUE,
                           (DWORD) ((CHAR FAR *) (&chBuffer[0])));


              /* Point to the next File info structure */
              ffi = (FILE_INFO FAR *) (ffi->fpNextFileInfo);
            }

          if (SendMessage (GetDlgItem (pwnd, IDD_USER + 8),
                           LB_GETCOUNT, 0, 0L) > 0)
            {
              /* Highlight the first item in the list box */
              SendMessage (GetDlgItem (pwnd, IDD_USER + 8), LB_SETCURSEL, 0, 0L);
            }

          /* Inform the user that we are searching */
          DisplayStatus (ST_FINDFILE2);

          break;
        }

      case WM_DRAWITEM:
        {
          DrawPlateButton1 (pwnd, message, wParam, lParam);
          break;
        }

      case WM_COMMAND:
        switch (wParam)
          {
            // User pressed the Ok or the Cancel Button.
            //  At this point, you should retrieve any state info you need.
            //  The Edit buffer will contain any text you may need.
            //  EndDialog MUST be called if you intend to end the dialog.

            case IDOK:           /* ENTER key    */
            case IDD_USER + 10:  /* Display File */
            case IDD_USER + 11:  /* File Info    */
              {
                INT   i;                    /* Looping variable     */


                /* Get the path */

                /* This gets the index of the item */
                i = (INT) SendMessage (GetDlgItem (pwnd, IDD_USER + 8),
                                       LB_GETCURSEL, 0, 0L);

                /* Find the i'th element of the list */
                ffi = ffi2;

                if (i != isaNil)
                  {
                    while (i-- && ffi != NULL && ffi->fpNextFileInfo != NULL)
                      {
                        /* Point to the next File info structure */
                        ffi = (FILE_INFO FAR *) (ffi->fpNextFileInfo);
                      }

                    if (++i != 0)
                      {
                        pqszBrowseStrings = NULL;
                        pszBrowseTitle = NULL;
                        wParam = IDCANCEL;
                      }
                    else
                      {
                        /* Put the path in a more permanent "home" */
                        _fstrcpy (EditBuf2, ffi->fpszPathToFile);

                        pszBrowseTitle = EditBuf2;
                      }
                  }
                else
                  {
                    pqszBrowseStrings = NULL;
                    pszBrowseTitle = NULL;
                    wParam = IDCANCEL;
                  }

                /* Clear out the previous FileInfo structure */
                FreeFileInfo (ffi2);

                /* Set them back to NULL */
                ffi  = NULL;
                ffi2 = NULL;

                //  EndDialog(pwnd, wParam );
                ((PWND_DLG)pwnd)->wParamEnd = wParam;
                break;
              }

            case IDCANCEL:
              {
                /* Clear out the previous FileInfo structure */
                FreeFileInfo (ffi2);

                /* Set them back to NULL */
                ffi  = NULL;
                ffi2 = NULL;

                /* Display the previous status line text */
                DisplayStatus (midFind);

                //  EndDialog(pwnd, wParam );
                ((PWND_DLG)pwnd)->wParamEnd = wParam;
                break;
              }
          }

        break;

      default:
        return (FALSE);
    }

  return (TRUE);
}


/*********************************************************************
 * InsertCmdDlg1 - Procedure to handle the Insert Command dialog box.
 *********************************************************************/

LONG FAR PASCAL InsertCmdDlg1 (PWND pwnd,
                               WORD message,
                               WORD wParam,
                               DWORD lParam)
{
  switch (message)
    {
      // WM_INITDIALOG is your chance to perform Dialog initialization before
      // before the dialog box is displayed.

      case WM_INITDIALOG:
        {
          // Gives the dialog box a border.
          SetWindowStyle (pwnd, pwnd->style | WS_BORDER);

          // Gives the dialog box a shadow.
          //  pwnd->wExtStyle |= WS_SHADOW;

          /* Display the help string */
          DisplayStatus (ST_INSERT_DLG1);

          ReadCommands (GetDlgItem (pwnd, IDD_USER + 3));

          if (SendMessage (GetDlgItem (pwnd, IDD_USER + 3),
                           LB_GETCOUNT, 0, 0L) > 0)
            {
              /* Highlight the first item in the list box */
              SendMessage (GetDlgItem (pwnd, IDD_USER + 3), LB_SETCURSEL, 0, 0L);
            }

          break;
        }

      case WM_DRAWITEM:
        {
          DrawPlateButton1 (pwnd, message, wParam, lParam);
          break;
        }

      case WM_COMMAND:
        switch (wParam)
          {
            // User pressed the Ok or the Cancel Button.
            //  At this point, you should retrieve any state info you need.
            //  The Edit buffer will contain any text you may need.
            //  EndDialog MUST be called if you intend to end the dialog.

            case IDOK:
              {
                static CHAR szCommand[256];    /* Stores the command string     */
                static CHAR szSection[256];    /* Stores the section to change  */
                static CHAR szFilename[256];   /* Stores the filename to change */
                CHAR szLbString[256];          /* Selected string stored here   */
                INT  i;                        /* Looping variable              */


                /* Get the string from the listbox */
                SendMessage (GetDlgItem (pwnd, IDD_USER + 3), LB_GETTEXT,
                             255, (DWORD) ((CHAR FAR *) szLbString));


                /* Extract the szCommand string */
                if (strlen (szLbString) < INI_SECTION_COL - 1)
                  i = strlen (szLbString);
                else
                  i = INI_SECTION_COL - 1;

                for (; i >= 0 && szLbString[i] == ' '; --i)
                  ;

                if (i > 0)
                  {
                    memcpy (szCommand, szLbString, ++i);
                    szCommand[i] = '\0';
                  }
                else
                  szCommand[0] = '\0';


                /* Extract the szSection string */
                if (strlen (szLbString) < INI_FILENAME_COL - 1)
                  i = strlen (szLbString);
                else
                  i = INI_FILENAME_COL - 1;

                for (; i >= INI_SECTION_COL && szLbString[i] == ' '; --i)
                  ;

                if (i > INI_SECTION_COL)
                  {
                    memcpy (szSection, &szLbString[INI_SECTION_COL],
                            ++i - INI_SECTION_COL);
                    szSection[i - INI_SECTION_COL] = '\0';
                  }
                else
                  szSection[0] = '\0';


                /* Extract the szFilename string */
                for (i = strlen (szLbString);
                     i >= INI_FILENAME_COL && szLbString[i] == ' '; --i)
                  ;

                if (i > INI_FILENAME_COL)
                  {
                    memcpy (szFilename, &szLbString[INI_FILENAME_COL],
                            ++i - INI_FILENAME_COL);
                    szFilename[i - INI_FILENAME_COL] = '\0';
                  }
                else
                  szFilename[0] = '\0';


                /* Bring up edit dialog box */
                pszInsertCommand  = szCommand;
                pszInsertSection  = szSection;
                pszInsertFilename = szFilename;
                if (DialogBox (&dlgInsertCmd2, InsertCmdDlg2) == IDOK)
                  ((PWND_DLG)pwnd)->wParamEnd = IDOK;
                else
                  DisplayStatus (ST_INSERT_DLG1);

                break;
              }

            case IDCANCEL:
              //  EndDialog(pwnd, wParam );
              ((PWND_DLG)pwnd)->wParamEnd = wParam;
              break;
          }

        break;

      default:
        return (FALSE);
    }

  return (TRUE);
}


/*********************************************************************
 * InsertCmdDlg2 - Procedure to handle the Insert Command editing
 *                 dialog box.
 *********************************************************************/

LONG FAR PASCAL InsertCmdDlg2 (PWND pwnd,
                               WORD message,
                               WORD wParam,
                               DWORD lParam)
{
  WORD wReturnValue;  /* Return value */


  switch (message)
    {
      // WM_INITDIALOG is your chance to perform Dialog initialization before
      // before the dialog box is displayed.

      case WM_INITDIALOG:
        {
          // Gives the dialog box a border.
          SetWindowStyle (pwnd, pwnd->style | WS_BORDER);

          // Gives the dialog box a shadow.
          //  pwnd->wExtStyle |= WS_SHADOW;

          /* Display the help string */
          DisplayStatus (ST_INSERT_DLG2);

          // It is the repsonsibility of the application to supply a buffer
          //  for the edit control. In the example below, EditBuf is the
          //  buffer declared in the source, somewhere. ( Don't make it a local
          //  variable in this proc!!! ). lParam has two values set, both equal
          //  to 255. These values are the size of the buffer. If your buffer
          //  is only 80 characters wide, then use MAKELONG(80,80).
          //
          SendMessage (GetDlgItem (pwnd, IDD_USER + 1),
                       EM_SETBUF, (WORD) EditBuf, MAKELONG(255, 255));
          SetEditText (GetDlgItem (pwnd, IDD_USER + 1), pszInsertCommand, TRUE);
          SendMessage (GetDlgItem (pwnd, IDD_USER + 3),
                       EM_SETBUF, (WORD) EditBuf2, MAKELONG(255, 255));
          SetEditText (GetDlgItem (pwnd, IDD_USER + 3), pszInsertSection, TRUE);
          SendMessage (GetDlgItem (pwnd, IDD_USER + 5),
                       EM_SETBUF, (WORD) EditBuf3, MAKELONG(255, 255));
          SetEditText (GetDlgItem (pwnd, IDD_USER + 5), pszInsertFilename, TRUE);
          break;
        }

      case WM_DRAWITEM:
        {
          DrawPlateButton1 (pwnd, message, wParam, lParam);
          break;
        }

      case WM_COMMAND:
        switch (wParam)
          {
            // User pressed the Ok or the Cancel Button.
            //  At this point, you should retrieve any state info you need.
            //  The Edit buffer will contain any text you may need.
            //  EndDialog MUST be called if you intend to end the dialog.

            case IDOK:
              /* Get the updated strings */
              GetEditText (GetDlgItem (pwnd, IDD_USER + 1),
                           pszInsertCommand, 255);
              GetEditText (GetDlgItem (pwnd, IDD_USER + 3),
                           pszInsertSection, 255);
              GetEditText (GetDlgItem (pwnd, IDD_USER + 5),
                           pszInsertFilename, 255);

              /* Check for blank fields */
              if (strlen (pszInsertCommand)  == 0)
                {
                  wReturnValue = MessageBox ("A command must be entered in the Command field",
                                              NULL, NULL, MB_OKCANCEL | 0x8000);

                  if (wReturnValue == IDCANCEL)
                    ((PWND_DLG)pwnd)->wParamEnd = wParam;
                }
              else if (strlen (pszInsertFilename) == 0)
                {
                  wReturnValue = MessageBox ("A filename must be entered in the File field",
                                              NULL, NULL, MB_OKCANCEL | 0x8000);

                  if (wReturnValue == IDCANCEL)
                    ((PWND_DLG)pwnd)->wParamEnd = IDCANCEL;
                }
              else
                ((PWND_DLG)pwnd)->wParamEnd = IDOK;

              break;

            case IDCANCEL:
              //  EndDialog(pwnd, wParam );
              ((PWND_DLG)pwnd)->wParamEnd = IDCANCEL;
              break;
          }

        break;

      default:
        return (FALSE);
    }

  return (TRUE);
}


/*********************************************************************
 * InsertCmdDlg3 - Procedure to handle the Insert Command file choice
 *                 dialog box.
 *********************************************************************/

LONG FAR PASCAL InsertCmdDlg3 (PWND pwnd,
                               WORD message,
                               WORD wParam,
                               DWORD lParam)
{
  FILE_INFO FAR *pfi;   /* Local file info structure */


  switch (message)
    {
      // WM_INITDIALOG is your chance to perform Dialog initialization before
      // before the dialog box is displayed.

      case WM_INITDIALOG:
        {
          // Gives the dialog box a border.
          SetWindowStyle ( pwnd, pwnd->style | WS_BORDER );

          // Gives the dialog box a shadow.
          //  pwnd->wExtStyle |= WS_SHADOW;

          DisplayStatus (ST_INSERT_DLG3);

          /* Clear out the listbox */
          SendMessage (GetDlgItem (pwnd, IDD_USER + 1),
                       LB_RESETCONTENT, NULL, NULL);

          /* Load the list box with the list of matching files */
          pfi = pfiDlg;

          while (pfi != NULL && pfi->fpNextFileInfo != NULL)
            {
              SendMessage (GetDlgItem (pwnd, IDD_USER + 1),
                           LB_ADDSTRING,
                           ((WORD) (isaNil) << 8) + TRUE,
                           (DWORD) (pfi->fpszPathToFile));

              pfi = (FILE_INFO FAR *) pfi->fpNextFileInfo;
            }

          if (SendMessage (GetDlgItem (pwnd, IDD_USER + 1),
                           LB_GETCOUNT, 0, 0L) > 0)
            {
              /* Highlight the first item in the list box */
              SendMessage (GetDlgItem (pwnd, IDD_USER + 1), LB_SETCURSEL, 0, 0L);
            }

          break;
        }

      case WM_DRAWITEM:
        {
          DrawPlateButton1 (pwnd, message, wParam, lParam);
          break;
        }

      case WM_COMMAND:
        switch (wParam)
          {
            // User pressed the Ok or the Cancel Button.
            //  At this point, you should retrieve any state info you need.
            //  The Edit buffer will contain any text you may need.
            //  EndDialog MUST be called if you intend to end the dialog.

            case IDOK:
              {
                /* Get the string from the listbox */
                SendMessage (GetDlgItem (pwnd, IDD_USER + 1), LB_GETTEXT,
                             255, (DWORD) ((CHAR FAR *) EditBuf));

                pszInsertFilename = EditBuf;

                // Fall through to IDCANCEL
              }

            case IDCANCEL:
              //  EndDialog(pwnd, wParam );
              ((PWND_DLG)pwnd)->wParamEnd = wParam;
              break;
          }

        break;

      default:
        return (FALSE);
    }

  return (TRUE);
}


/*********************************************************************
 * InsertCmdDlg4 - Procedure to handle the Insert Command line choice
 *                 dialog box.
 *********************************************************************/

LONG FAR PASCAL InsertCmdDlg4 (PWND pwnd,
                               WORD message,
                               WORD wParam,
                               DWORD lParam)
{
  static CHAR szSearchString[80]; /* String to search for in command file */
  INT  i1, i2;                    /* Looping variables                    */
  BOOL fReturnValue;              /* Return value from various functions  */
  WORD wIndex;                    /* Index to the list box                */
  static WORD wReplaceAllIndex;   /* Index to the "REPLACE ALL" line      */
  FILE *fpIn;                     /* File handles for reading input file  */
  static PWND pwndList;           /* List box's PWND                      */


  switch (message)
    {
      // WM_INITDIALOG is your chance to perform Dialog initialization before
      // before the dialog box is displayed.

      case WM_INITDIALOG:
        {
          // Gives the dialog box a border.
          SetWindowStyle ( pwnd, pwnd->style | WS_BORDER );

          // Gives the dialog box a shadow.
          //  pwnd->wExtStyle |= WS_SHADOW;

          DisplayStatus (ST_INSERT_DLG4);

          /* Clear out the listbox */
          pwndList = GetDlgItem (pwnd, IDD_USER + 1);
          SendMessage (pwndList, LB_RESETCONTENT, 0, 0L);

          /* Add the "ADD LINE" string */
          SendMessage (pwndList, LB_ADDSTRING,
                       ((WORD) (isaNil) << 8) + TRUE,
                       (DWORD) ((CHAR FAR *) "ADD LINE"));


          /* Prepare search string by finding the primary part of the command. */
          /*   This is accomplished by searching for the first "=" character.  */
          /*   If found, extra whitespace behind the "=" sign is removed from  */
          /*   the search string.  If no "=" sign is found, search for the     */
          /*   first whitespace character, and call that the delimiter.        */
          /*                                                                   */
          /*   Examples:                                                       */
          /*             szCommand:                   szSearchString:          */
          /*             "EmmExclude = C000 - EFFF"   "EmmExclude"             */
          /*             "SET TEMP=?"                 "SET TEMP"               */
          /*             "PATH C:\;C:\DOS"            "PATH"                   */

          for (i1 = 0; pszInsertCommand[i1] != '\0' && 
                       pszInsertCommand[i1] != '=';  ++i1)
            ;

          /* Check for "=" sign */

          if (pszInsertCommand[i1] == '=')
            {
              /* Remove white space between command and the "=" sign */

              for (i2 = i1 - 1; i2 >= 0 &&
                                (pszInsertCommand[i2] == ' ' ||
                                 pszInsertCommand[i2] == '\t'); --i2)
                ;

              /* Put the information into the search string */

              for (i1 = 0; i1 <= i2; ++i1)
                szSearchString[i1] = pszInsertCommand[i1];

              szSearchString[i1] = '\0';
            }
          else
            {
              for (i1 = 0; pszInsertCommand[i1] != '\0' &&
                           pszInsertCommand[i1] != ' '  &&
                           pszInsertCommand[i1] != '\t';   ++i1)
                ;

              /* Put the information into the search string, up to, but not */
              /*   including, the white space character.                    */

              for (i2 = 0; i2 < i1; ++i2)
                szSearchString[i2] = pszInsertCommand[i2];

              szSearchString[i2] = '\0';
            }


          /* Open the file */
          fpIn = OpenFile (pszInsertFilename, "rb", TRUE);
          if (fpIn == NULL)
            {
              //  EndDialog(pwnd, wParam );
              ((PWND_DLG)pwnd)->wParamEnd = IDOK;

              return (TRUE);
            }


          /* Locate the section in the file */
          if (pszInsertSection[0] != '\0')
            {
              fReturnValue = FindSection (pszInsertSection, fpIn, NULL);

              if (fReturnValue == TRUE)
                {
                  if (MessageBox (pszInsertSection,
                                  "Was not found.",
                                  "Add this to the file?",
                                  MB_YESNO | 0x8000) == IDNO)
                    {
                      CloseFile (fpIn);

                      //  EndDialog(pwnd, wParam );
                      ((PWND_DLG)pwnd)->wParamEnd = IDOK;

                      return (TRUE);
                    }
                }
            }
          else
            fReturnValue = FALSE;


          /* Load the list box with the list of matching lines */
          if (fReturnValue == FALSE)
            HandleDuplicates (HD_SEARCH,
                              szSearchString,
                              NULL,
                              fpIn,
                              NULL,
                              pwndList);


          wIndex = (WORD) SendMessage (pwndList, LB_GETCOUNT, 0, 0L);

          /* If there is more than 1 add and 1 replace line, */
          /*   add "REPLACE ALL".                            */
          if (wIndex > 2)
            {
              SendMessage (pwndList, LB_ADDSTRING,
                           ((WORD) (isaNil) << 8) + TRUE,
                           (DWORD) ((CHAR FAR *) "REPLACE ALL"));

              wReplaceAllIndex = wIndex;
            }
          else
            wReplaceAllIndex = 2;

          CloseFile (fpIn);

          /* Highlight the first item in the list box */
          SendMessage (pwndList, LB_SETCURSEL, 0, 0L);

          break;
        }

      case WM_DRAWITEM:
        {
          DrawPlateButton1 (pwnd, message, wParam, lParam);
          break;
        }

      case WM_COMMAND:
        switch (wParam)
          {
            // User pressed the Ok or the Cancel Button.
            //  At this point, you should retrieve any state info you need.
            //  The Edit buffer will contain any text you may need.
            //  EndDialog MUST be called if you intend to end the dialog.

            case IDOK:
              {
                wIndex = (WORD) SendMessage (pwndList, LB_GETCURSEL, 0, 0L);

                if (wIndex == wReplaceAllIndex)
                  ChangeFile (pszInsertFilename,
                              pszInsertSection,
                              pszInsertCommand,
                              szSearchString,
                              (WORD) HD_REPLACE_ALL);
                else
                  ChangeFile (pszInsertFilename,
                              pszInsertSection,
                              pszInsertCommand,
                              szSearchString,
                              wIndex);

                // Fall through to IDCANCEL
              }

            case IDCANCEL:
              //  EndDialog(pwnd, wParam );
              ((PWND_DLG)pwnd)->wParamEnd = wParam;
              break;
          }

        break;

      default:
        return (FALSE);
    }

  return (TRUE);
}


/*********************************************************************
 * TestPrinterDlg - Procedure to handle the "Test Printer" dialog box.
 *********************************************************************/

LONG FAR PASCAL TestPrinterDlg (PWND pwnd,
                                WORD message,
                                WORD wParam,
                                DWORD lParam)
{
  switch (message)
    {
      // WM_INITDIALOG is your chance to perform Dialog initialization before
      // before the dialog box is displayed.

      case WM_INITDIALOG:
        {
          // Gives the dialog box a border.
          SetWindowStyle ( pwnd, pwnd->style | WS_BORDER );

          // Gives the dialog box a shadow.
          //  pwnd->wExtStyle |= WS_SHADOW;

          // We should set a default value for the group of radio buttons
          // which indicate where we 'Print To'. Like under Windows,
          // The first parameter is the Dialog PWND, 2nd and third are the id's
          // of the first and last radio button in the group. The fourth paramter
          // is the ID of the radio button that is initally 'on'.

          CheckDlgRadioButton ( pwnd, IDD_USER + 1,
                         IDD_USER + 2,
                         IDD_USER + 1 );

          CheckDlgRadioButton ( pwnd, IDD_USER + 4,
                         IDD_USER + 5,
                         IDD_USER + 4 );

          CheckDlgRadioButton ( pwnd, IDD_USER + 7,
                         IDD_USER + 13,
                         IDD_USER + 7 );

          break;
        }

      case WM_DRAWITEM:
        {
          DrawPlateButton1 (pwnd, message, wParam, lParam);
          break;
        }

      case WM_COMMAND:
        // We have to assume responsability for checking/unchecking
        // radio buttons.

        if ( wParam >= IDD_USER + 1 &&
             wParam <= IDD_USER + 2 )
          {
            CheckDlgRadioButton (pwnd, IDD_USER + 1, IDD_USER + 2, wParam);
            return (TRUE);
          }

        if ( wParam >= IDD_USER + 4 &&
             wParam <= IDD_USER + 5 )
          {
            CheckDlgRadioButton (pwnd, IDD_USER + 4, IDD_USER + 5, wParam);
            return (TRUE);
          }

        if ( wParam >= IDD_USER + 7 &&
             wParam <= IDD_USER + 13 )
          {
            CheckDlgRadioButton (pwnd, IDD_USER + 7, IDD_USER + 13, wParam);
            return (TRUE);
          }

        switch (wParam)
          {
            // User pressed the Ok or the Cancel Button.
            //  At this point, you should retrieve any state info you need.
            //  The Edit buffer will contain any text you may need.
            //  EndDialog MUST be called if you intend to end the dialog.

            case IDOK:
              {
                WORD i;   /* Looping variable */


                /* Postscript Test */
                if (SendMessage (GetDlgItem (pwnd, IDD_USER + 2),
                                 BM_GETCHECK, 0, 0L))
                  tpValue.fPostscript = TRUE;
                else
                  tpValue.fPostscript = FALSE;


                /* Test Type (7 or 8 bit ASCII) */
                if (SendMessage (GetDlgItem (pwnd, IDD_USER + 5),
                                 BM_GETCHECK, 0, 0L))
                  tpValue.f8BitTest = TRUE;
                else
                  tpValue.f8BitTest = FALSE;


                /* Serial/Parallel and Port number */
                for (i =  IDD_USER +  7;
                     i <= IDD_USER + 13 &&
                     SendMessage (GetDlgItem (pwnd, i),
                                  BM_GETCHECK, 0, 0L)  == 0;
                     ++i)
                  ;

                i = i - (IDD_USER + 7);

                if (i < 3)
                  {
                    /* Parallel Port */
                    tpValue.fSerialTest = FALSE;
                    tpValue.wPort = i;
                  }
                else
                  {
                    /* Serial Port */
                    tpValue.fSerialTest = TRUE;
                    tpValue.wPort = i - 3;
                  }

                // Fall through to IDCANCEL.
              }

            case IDCANCEL:
              //  EndDialog(pwnd, wParam );
              ((PWND_DLG)pwnd)->wParamEnd = wParam;
              break;
          }

        break;

      default:
        return (FALSE);
    }

  return (TRUE);
}


/*********************************************************************
 * CustInfoCmdDlg - Procedure to handle the Customer Information
 *                  dialog box.
 *********************************************************************/

LONG FAR PASCAL CustInfoCmdDlg (PWND pwnd,
                                WORD message,
                                WORD wParam,
                                DWORD lParam)
{
  switch (message)
    {
      // WM_INITDIALOG is your chance to perform Dialog initialization before
      // before the dialog box is displayed.

      case WM_INITDIALOG:
        {
          // Gives the dialog box a border.
          SetWindowStyle ( pwnd, pwnd->style | WS_BORDER );

          DisplayStatus (ST_CUST_INFO);

          // Gives the dialog box a shadow.
          //  pwnd->wExtStyle |= WS_SHADOW;

          /* Set up the edit items */
          SendMessage (GetDlgItem (pwnd, IDD_USER + 2),
                       EM_SETBUF, (WORD) pCustInfoDlg->chCustInfo[0],
                       MAKELONG (MAX_CUST_INFO, MAX_CUST_INFO));
          SendMessage (GetDlgItem (pwnd, IDD_USER + 4),
                       EM_SETBUF, (WORD) pCustInfoDlg->chCustInfo[1],
                       MAKELONG (MAX_CUST_INFO, MAX_CUST_INFO));
          SendMessage (GetDlgItem (pwnd, IDD_USER + 6),
                       EM_SETBUF, (WORD) pCustInfoDlg->chCustInfo[2],
                       MAKELONG (MAX_CUST_INFO, MAX_CUST_INFO));
          SendMessage (GetDlgItem (pwnd, IDD_USER + 8),
                       EM_SETBUF, (WORD) pCustInfoDlg->chCustInfo[3],
                       MAKELONG (MAX_CUST_INFO, MAX_CUST_INFO));
          SendMessage (GetDlgItem (pwnd, IDD_USER + 10),
                       EM_SETBUF, (WORD) pCustInfoDlg->chCustInfo[4],
                       MAKELONG (MAX_CUST_INFO, MAX_CUST_INFO));
          SendMessage (GetDlgItem (pwnd, IDD_USER + 12),
                       EM_SETBUF, (WORD) pCustInfoDlg->chCustInfo[5],
                       MAKELONG (MAX_CUST_INFO, MAX_CUST_INFO));
          SendMessage (GetDlgItem (pwnd, IDD_USER + 14),
                       EM_SETBUF, (WORD) pCustInfoDlg->chCustInfo[6],
                       MAKELONG (MAX_CUST_INFO, MAX_CUST_INFO));
          SendMessage (GetDlgItem (pwnd, IDD_USER + 16),
                       EM_SETBUF, (WORD) pCustInfoDlg->chCustInfo[7],
                       MAKELONG (MAX_CUST_INFO, MAX_CUST_INFO));
          break;
        }

      case WM_DRAWITEM:
        {
          DrawPlateButton1 (pwnd, message, wParam, lParam);
          break;
        }

      case WM_COMMAND:
        switch (wParam)
          {
            // User pressed the Ok or the Cancel Button.
            //  At this point, you should retrieve any state info you need.
            //  The Edit buffer will contain any text you may need.
            //  EndDialog MUST be called if you intend to end the dialog.

            case IDOK:
              // Fall through to IDCANCEL.

            case IDCANCEL:
              //  EndDialog(pwnd, wParam );
              ((PWND_DLG)pwnd)->wParamEnd = wParam;
              break;
          }

        break;

      default:
        return (FALSE);
    }

  return (TRUE);
}


/*********************************************************************
 * AboutDlg - Procedure to handle the about box.
 *********************************************************************/

LONG FAR PASCAL AboutDlg (PWND pwnd,
                          WORD message,
                          WORD wParam,
                          DWORD lParam)
{
  switch (message)
    {
      case WM_INITDIALOG:
        {
#if HEAP_DEBUG
          {
            CHAR chBuffer[80];
            PSZ  pszPointer;
            pszPointer = malloc (_memmax() - 16);
            free (pszPointer);
            _heapset (0x50);
            sprintf (chBuffer, "_memavl = %u - _memmax = %u = %u, at = %04X",
                     _memavl(), _memmax(), _memavl() - _memmax(), pszPointer);
            ShowStatus (chBuffer);
          }
#endif
          // Gives the dialog box a border.
          SetWindowStyle ( pwnd, pwnd->style | WS_BORDER );
          break;
        }

      case WM_DRAWITEM:
        {
          DrawPlateButton1 (pwnd, message, wParam, lParam);
          break;
        }

      case WM_COMMAND:
        switch (wParam)
          {
            case IDOK:
            case IDCANCEL:
              //  EndDialog(pwnd, wParam );
              ((PWND_DLG)pwnd)->wParamEnd = wParam;
              break;
          }
        break;

      default:
        return (FALSE);
    }

  return (TRUE);
}


/*********************************************************************
 * MemoryBlockDisplayDlg - Procedure to handle the about box.
 *********************************************************************/

LONG FAR PASCAL MemoryBlockDisplayDlg (PWND pwnd,
                                       WORD message,
                                       WORD wParam,
                                       DWORD lParam)
{
  static MEMORY_STRUCT *pMem;         /* Stores memory structure       */
  static TSR_PROGRAMS_STRUCT *pTsr;   /* Stores TSR Programs structure */
  static MEM_MAP *pmmMap = NULL;      /* Local copy of visual mem map  */
  INT  i, u;                          /* Looping variables             */
  WORD wSize;                         /* Size of various structs       */
  CHAR chBuffer[80];                  /* Local string buffer           */
  QSZ  *pqszStrings = NULL;           /* String buffer                 */


  switch (message)
    {
      case WM_INITDIALOG:
        {
          // Gives the dialog box a border.
          SetWindowStyle ( pwnd, pwnd->style | WS_BORDER );


          /* Set the colors for the listbox */
          {
            PWND_LIST pwndList;

            pwndList = (PWND_LIST) GetDlgItem (pwnd, IDD_USER + 3);
            pwndList->isaHiliteColor = isaMemoryMap;
         /* pwndList->isaColor       = isaMemoryMap; */
          }


          /* Get the memory map */

          wSize = GetInfoSize (IDI_MEMORY_RECORD, FALSE);

          if (wSize == 0)
            break;


          /* Allocate enough room for the info structure */
          pMem = malloc (wSize);

          if (pMem == NULL)
            {
              OutOfMemory();
              break;
            }

          /* Zero out the structure */
          memset (pMem, '\0', wSize);

          /* Fill the structure with the information */
          if (GetInfo (IDI_MEMORY_RECORD, pMem, FALSE, FALSE, FALSE))
            {
              free (pMem);
              break;
            }


          /* Add the memory map to the memory listbox */

          /* Allocate a local copy of the visual mem map */
          pmmMap = malloc (sizeof (MEM_MAP));
          if (pmmMap == NULL)
            {
              free (pMem);
              break;
            }

          /* Clear the list box */
          SendMessage (GetDlgItem (pwnd, IDD_USER + 3),
                       LB_RESETCONTENT, NULL, NULL);

          /* Add all the strings */
          for (i = NUM_OF_ROWS - 1; i >= 0; --i)
            {
              /* Put the overlay over the memory map */
              strcat (chBuffer, pMem->abMemoryMap[i]);
              for (u = 0; u < NUM_OF_COLS - 1; ++u)
                if (pMem->abMemMapOverlay[i][u])
                  pMem->abMemoryMap[i][u] = pMem->abMemMapOverlay[i][u];

              /* Display hexadecimal equivilent of memory location */
              sprintf (chBuffer, "%04X %s", (WORD) i * 0x0400, 
                       pMem->abMemoryMap[i]);

              /* Put the string into the list box */
              SendMessage (GetDlgItem (pwnd, IDD_USER + 3),
                           LB_ADDSTRING,
                           ((WORD) (isaMemoryMap) << 8) + TRUE,
                           (DWORD) ((CHAR FAR *) (chBuffer)));

              /* Store this line of the visual mem map */
              strcpy (pmmMap->abMap[i], chBuffer);
            }


          /* Free up the memory info strcture */
          free (pMem);


          /* Get the TSR list */

          wSize = GetInfoSize (IDI_TSR_PROGRAMS_RECORD, FALSE);

          if (wSize == 0)
            break;


          /* Allocate enough room for the info structure */
          pTsr = malloc (wSize);

          if (pTsr == NULL)
            {
              OutOfMemory();
              break;
            }

          /* Zero out the structure */
          memset (pTsr, '\0', wSize);

          /* Fill the structure with the information */
          if (GetInfo (IDI_TSR_PROGRAMS_RECORD, pTsr, FALSE, FALSE, FALSE))
            {
              free (pTsr);
              break;
            }

          /* Convert the structure to strings */
          pqszStrings = SprintTsrInfo (pTsr, FALSE);


          /* Add the TSR list to the memory listbox */

          /* Clear the list box */
          SendMessage (GetDlgItem (pwnd, IDD_USER + 1),
                       LB_RESETCONTENT, NULL, NULL);;

          for (u = 2; pqszStrings[u] != NULL; ++u)
            ;

          /* Add all the strings */
          for (i = u - 1; i >= 2; --i)
            {
              /* Drop the command line parameters */
              pqszStrings[i][TSR_CMD_LINE_COL] = '\0';


              /* Put the string into the list box */
              SendMessage (GetDlgItem (pwnd, IDD_USER + 1),
                           LB_ADDSTRING,
                           ((WORD) (isaNil) << 8) + TRUE,
                           (DWORD) ((CHAR FAR *) (pqszStrings[i])));
            }

          /* Highlight the first item in the list box */
          SendMessage (GetDlgItem (pwnd, IDD_USER + 1), LB_SETCURSEL, 0, 0L);

          /* Show where the initial item is stored */
          UpdateMemMap (pwnd, pmmMap);

          free (pTsr);
          FreeStringSpace (pqszStrings);

          break;
        }

      case WM_LISTBOX_COMMAND:
        {
          switch (HIWORD (lParam))
            {
              case LBN_SELCHANGE:
                {
                  /* Do nothing if the item was re-selected, or if it */
                  /*   came from the wrong listbox.                   */
                  if ((LOWORD (lParam) & flbrReselect) || wParam != IDD_USER + 1)
                    break;

                  UpdateMemMap (pwnd, pmmMap);
                }
            }

          break;
        }


      case WM_DRAWITEM:
        {
          DrawPlateButton1 (pwnd, message, wParam, lParam);
          break;
        }

      case WM_COMMAND:
        switch (wParam)
          {
            case IDCANCEL:
            case IDOK:
              free (pmmMap);
              //  EndDialog(pwnd, wParam );
              ((PWND_DLG)pwnd)->wParamEnd = wParam;
              break;
          }
        break;

      default:
        return (FALSE);
    }

  return (TRUE);
}


/*********************************************************************
 * UpdateMemMap - Updates the memory map with the indication of where
 *                the currently selected item in the TSR list is
 *                located.
 *
 * pwnd   - Dialog box PWND
 * pmmMap - Pointer to the MEM_MAP structure.
 *********************************************************************/

VOID UpdateMemMap (PWND pwnd, MEM_MAP *pmmMap)
{
  CHAR  chBuffer[80];   /* Local string                       */
  WORD  wAddress;       /* Address of TSR/MCB                 */
  DWORD dwBlockSize;    /* Length of TSR/MCB                  */
  INT   iRow;           /* Row in mem map                     */
  INT   iCol;           /* Column in mem map                  */
  INT   iNumOfChars;    /* Number of marker characters to add */
  PWND  pwndMap;        /* PWND of mem map                    */
  INT   iIndex;         /* Character count of marker          */
  INT   i;              /* Looping variable                   */


  /* Get the visual memory map's PWND */
  pwndMap = GetDlgItem (pwnd, IDD_USER + 3);

  /* Determine which item has been selected */
  SendMessage (GetDlgItem (pwnd, IDD_USER + 1),
               LB_GETTEXT,
               79, (DWORD) ((CHAR FAR *) chBuffer));

  sscanf (&chBuffer[TSR_ADDRESS_COL], "%04X", &wAddress);
  dwBlockSize = atol (&chBuffer[TSR_SIZE_COL]);


  /* Find the place to begin marking the visual mem map */
  iRow        = (NUM_OF_ROWS - 1) - (wAddress / 0x400);
  iCol        = (wAddress % 0x400) / 0x40;
  iNumOfChars = (WORD) ((dwBlockSize + 1023) / 1024);


  /* Re-add the original lines to the listbox */
  SendMessage (pwndMap, LB_RESETCONTENT, NULL, NULL);

  for (i = NUM_OF_ROWS - 1; i >= 0; --i)
    {
      SendMessage (pwndMap, LB_ADDSTRING,
                   ((WORD) (isaMemoryMap) << 8) + FALSE,
                   (DWORD) ((CHAR FAR *) (pmmMap->abMap[i])));
    }

  /* Now change the lines in the list box */

  /* Set the selection to our item */
  SendMessage (pwndMap, LB_SETCURSEL, iRow, NULL);

  /* Get the line from the list box */
  SendMessage (pwndMap, LB_GETTEXT, 79,
               (DWORD) (CHAR FAR *) (chBuffer));

  iIndex = 0;

  while (iIndex < iNumOfChars)
    {
      /* Choose the appropriate character */
      if (iNumOfChars == 1)
        chBuffer[iCol + 5] = '';
      else if (iIndex == 0)
        chBuffer[iCol + 5] = '';
      else if (iIndex + 1 == iNumOfChars)
        chBuffer[iCol + 5] = '';
      else
        chBuffer[iCol + 5] = '';

      /* Calculate the next string */
      if (++iCol > NUM_OF_COLS - 2)
        {
          /* Send the string back into the list box */
          SendMessage (pwndMap, LB_REPLACESTRING, (iRow << 8) + isaMemoryMap,
                       (DWORD) (CHAR FAR *) (chBuffer));

          /* Calculate where the next character should go */
          if (iIndex + 1 < iNumOfChars)
            {
              iCol = 0;
              iRow--;

              /* Get the new string */
              SendMessage (pwndMap, LB_SETCURSEL, iRow, NULL);

              SendMessage (pwndMap, LB_GETTEXT, 79,
                           (DWORD) (CHAR FAR *) (chBuffer));
            }
        }

      ++iIndex;
    }

  /* Send the last string back into the list box */
  SendMessage (pwndMap, LB_REPLACESTRING, (iRow << 8) + isaMemoryMap,
               (DWORD) (CHAR FAR *) (chBuffer));

  /* Cause the listbox to repaint */
  DrawWindow (pwndMap);
}


/*********************************************************************
 * MemoryBrowserDlg - Procedure to handle the about box.
 *********************************************************************/

LONG FAR PASCAL MemoryBrowserDlg (PWND  pwnd,
                                  WORD  message,
                                  WORD  wParam,
                                  DWORD lParam)
{
  static MEMORY_STRUCT *pMem;         /* Stores memory structure       */
  static MEM_MAP *pmmMap = NULL;      /* Local copy of visual mem map  */
  ROM_MAP *pRomMap = NULL;            /* ROM area locations and sizes  */
  COMPUTER_STRUCT *pCpu = NULL;       /* For getting BUS type (PS/2)   */
  INT  i, u;                          /* Looping variables             */
  WORD wSize;                         /* Size of various structs       */
  CHAR chBuffer[80];                  /* Local string buffer           */
  PSZ  *ppszStrings = NULL;           /* String buffer                 */


  switch (message)
    {
      case WM_INITDIALOG:
        {
          // Gives the dialog box a border.
          SetWindowStyle ( pwnd, pwnd->style | WS_BORDER );

          /* Set the colors for the listbox */
          {
            PWND_LIST pwndList;

            pwndList = (PWND_LIST) GetDlgItem (pwnd, IDD_USER + 3);
            pwndList->isaHiliteColor = isaMemoryMap;
         /* pwndList->isaColor       = isaMemoryMap; */
          }


          /* Set up the edit buffer */
          SendMessage (GetDlgItem (pwnd, IDD_USER + 5), EM_SETBUF,
                       (WORD) EditBuf, MAKELONG (64, 64));

          EditBuf[0] = '\0';

          /* Get the memory map */

          wSize = GetInfoSize (IDI_MEMORY_RECORD, FALSE);

          if (wSize == 0)
            break;


          /* Allocate enough room for the info structure */
          pMem = malloc (wSize);

          if (pMem == NULL)
            {
              OutOfMemory();
              break;
            }

          /* Zero out the structure */
          memset (pMem, '\0', wSize);

          /* Fill the structure with the information */
          if (GetInfo (IDI_MEMORY_RECORD, pMem, FALSE, FALSE, FALSE))
            {
              free (pMem);
              break;
            }


          /* Add the memory map to the memory listbox */

          /* Allocate a local copy of the visual mem map */
          pmmMap = malloc (sizeof (MEM_MAP));
          if (pmmMap == NULL)
            {
              free (pMem);
              break;
            }

          /* Clear the list box */
          SendMessage (GetDlgItem (pwnd, IDD_USER + 3),
                       LB_RESETCONTENT, NULL, NULL);

          /* Add all the strings */
          for (i = NUM_OF_ROWS - 1; i >= 0; --i)
            {
              /* Put the overlay over the memory map */
              strcat (chBuffer, pMem->abMemoryMap[i]);
              for (u = 0; u < NUM_OF_COLS - 1; ++u)
                if (pMem->abMemMapOverlay[i][u])
                  pMem->abMemoryMap[i][u] = pMem->abMemMapOverlay[i][u];

              /* Display hexadecimal equivilent of memory location */
              sprintf (chBuffer, "%04X %s", (WORD) i * 0x0400, 
                       pMem->abMemoryMap[i]);

              /* Put the string into the list box */
              SendMessage (GetDlgItem (pwnd, IDD_USER + 3),
                           LB_ADDSTRING,
                           ((WORD) (isaMemoryMap) << 8) + TRUE,
                           (DWORD) ((CHAR FAR *) (chBuffer)));

              /* Store this line of the visual mem map */
              strcpy (pmmMap->abMap[i], chBuffer);
            }


          /* Free up the memory info strcture */
          free (pMem);


          /* Get the list of ROMs and Option ROMs */

          ppszStrings = ListOptionRoms();


          /* Clear the list box */
          SendMessage (GetDlgItem (pwnd, IDD_USER + 1),
                       LB_RESETCONTENT, NULL, NULL);;


          /* Load the Option ROM information into the listbox */
          for (i = 0; ppszStrings[i] != NULL; ++i)
            {
              /* Put the string into the list box */
              SendMessage (GetDlgItem (pwnd, IDD_USER + 1),
                           LB_ADDSTRING,
                           ((WORD) (isaNil) << 8) + TRUE,
                           (DWORD) ((CHAR FAR *) (ppszStrings[i])));
            }

          free (ppszStrings[0]);
          free (ppszStrings);


          /* Highlight the first item in the list box */
          SendMessage (GetDlgItem (pwnd, IDD_USER + 1), LB_SETCURSEL, 0, 0L);


          /* Show where the initial item is stored */
          UpdateMemMap (pwnd, pmmMap);

          break;
        }

      case WM_LISTBOX_COMMAND:
        {
          switch (HIWORD (lParam))
            {
              case LBN_SELCHANGE:
                {
                  /* Do nothing if the item was re-selected, or if it */
                  /*   came from the wrong listbox.                   */
                  if ((LOWORD (lParam) & flbrReselect) ||
                       wParam != IDD_USER + 1)
                    break;

                  UpdateMemMap (pwnd, pmmMap);
                }
            }

          break;
        }


      case WM_DRAWITEM:
        {
          DrawPlateButton1 (pwnd, message, wParam, lParam);
          break;
        }

      case WM_COMMAND:
        switch (wParam)
          {
            case IDOK:
              {
                CHAR  chTitle[80];          /* Title of ROM area    */
                WORD  wSearchSegment;       /* Segment to search    */
                DWORD dwSearchLength;       /* Search Length        */
                INT   i;                    /* Looping variable     */


                /* Get the string from the edit box */
                SendMessage (GetDlgItem (pwnd, IDD_USER + 1), LB_GETTEXT,
                             64, (DWORD) ((CHAR FAR *) chTitle));

                /* Obtain the search parameters */
                sscanf (&chTitle[TSR_ADDRESS_COL], "%04X", &wSearchSegment);
                dwSearchLength = atol (&chTitle[TSR_SIZE_COL]);

                /* Put the title in a more permanent "home" */
                for (i = TSR_ADDRESS_COL - 1; i > 0 && chTitle[i] == ' '; --i)
                  ;
                chTitle[i + 1] = '\0';
                strcpy (EditBuf2, chTitle);

                DisplayStatus (ST_SEARCHING);

                /* Free up the memory map before browsing */
                free (pmmMap);

                pqszBrowseStrings =
                    GetBrowseInfo (EditBuf2,
                                   EditBuf,
                                   (CHAR FAR *) ((DWORD) wSearchSegment << 16),
                                   dwSearchLength);

                pszBrowseTitle = EditBuf2;

                PostMessage (pwndStatusLine, WM_PAINT, NULL, NULL);
                PostMessage (pwndMainFrame, WM_PAINT, NULL, NULL);

                //  EndDialog(pwnd, wParam );
                ((PWND_DLG)pwnd)->wParamEnd = wParam;
                break;
              }

            case IDCANCEL:
              //  EndDialog(pwnd, wParam );
              ((PWND_DLG)pwnd)->wParamEnd = wParam;
              free (pmmMap);
              break;
          }
        break;

      default:
        return (FALSE);
    }

  return (TRUE);
}


/*********************************************************************
 * ViewWhichFile - Procedure to handle the Insert Command file choice
 *                 dialog box.
 *********************************************************************/

LONG FAR PASCAL ViewWhichFileDlg (PWND  pwnd,
                                  WORD  message,
                                  WORD  wParam,
                                  DWORD lParam)
{
  FILE_INFO FAR *pfi;   /* Local file info structure */


  switch (message)
    {
      // WM_INITDIALOG is your chance to perform Dialog initialization before
      // before the dialog box is displayed.

      case WM_INITDIALOG:
        {
          // Gives the dialog box a border.
          SetWindowStyle ( pwnd, pwnd->style | WS_BORDER );

          // Gives the dialog box a shadow.
          //  pwnd->wExtStyle |= WS_SHADOW;

          DisplayStatus (ST_VIEW_WHICH_FILE);


          /* Clear out the listbox */
          SendMessage (GetDlgItem (pwnd, IDD_USER + 1),
                       LB_RESETCONTENT, NULL, NULL);

          /* Load the list box with the list of matching files */
          pfi = pfiDlg;

          while (pfi != NULL && pfi->fpNextFileInfo != NULL)
            {
              SendMessage (GetDlgItem (pwnd, IDD_USER + 1),
                           LB_ADDSTRING,
                           ((WORD) (isaNil) << 8) + TRUE,
                           (DWORD) (pfi->fpszPathToFile));

              pfi = (FILE_INFO FAR *) pfi->fpNextFileInfo;
            }

          if (SendMessage (GetDlgItem (pwnd, IDD_USER + 1),
                           LB_GETCOUNT, 0, 0L) > 0)
            {
              /* Highlight the first item in the list box */
              SendMessage (GetDlgItem (pwnd, IDD_USER + 1), LB_SETCURSEL, 0, 0L);
            }

          break;
        }

      case WM_DRAWITEM:
        {
          DrawPlateButton1 (pwnd, message, wParam, lParam);
          break;
        }

      case WM_COMMAND:
        switch (wParam)
          {
            // User pressed the Ok or the Cancel Button.
            //  At this point, you should retrieve any state info you need.
            //  The Edit buffer will contain any text you may need.
            //  EndDialog MUST be called if you intend to end the dialog.

            case IDOK:
              {
                /* Get the string from the listbox */
                SendMessage (GetDlgItem (pwnd, IDD_USER + 1), LB_GETTEXT,
                             255, (DWORD) ((CHAR FAR *) EditBuf));

                pszInsertFilename = EditBuf;

                // Fall through to IDCANCEL
              }

            case IDCANCEL:
              //  EndDialog(pwnd, wParam );
              ((PWND_DLG)pwnd)->wParamEnd = wParam;
              break;
          }

        break;

      default:
        return (FALSE);
    }

  return (TRUE);
}


/*********************************************************************
 * WarnWindowsUserDlg - Procedure to handle the about box.
 *********************************************************************/

LONG FAR PASCAL WarnWindowsUserDlg (PWND pwnd,
                                    WORD message,
                                    WORD wParam,
                                    DWORD lParam)
{
  switch (message)
    {
      case WM_INITDIALOG:
        {
          // Gives the dialog box a border.
          SetWindowStyle ( pwnd, pwnd->style | WS_BORDER );
          break;
        }

      case WM_DRAWITEM:
        {
          DrawPlateButton1 (pwnd, message, wParam, lParam);
          break;
        }

      case WM_COMMAND:
        switch (wParam)
          {
            case IDOK:
            case IDCANCEL:
              //  EndDialog(pwnd, wParam );
              ((PWND_DLG)pwnd)->wParamEnd = wParam;
              break;
          }
        break;

      default:
        return (FALSE);
    }

  return (TRUE);
}


#endif /* CW_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\devtab.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * DEVTAB.C - Device Driver detection routines.
 *********************************************************************/


/* Include Files */

#include "msd.h"


/* Made global to this file.  This prevents filling the structure with */
/*   more device driver info than was previously allocated (on the     */
/*   extremely odd case of finding more device drivers when we         */
/*   actually get the driver info than when we counted up how many     */
/*   there were.  There is a way in DOS for an .EXE to install a       */
/*   device driver.  Under multitasking systems, the addition of a new */
/*   device driver while this program is running is a rare, though     */
/*   real possibility.                                                 */

WORD wDeviceDriverCount = 0;        /* The number of device drivers */
                                    /*   installed in memory        */

/*********************************************************************
 * GetDeviceDriverSize - Gets number of bytes required to store the
 *                       installed device driver's data.
 *
 * Returns:  The bytes required for the structure.
 *********************************************************************/

WORD GetDeviceDriversSize (VOID)
{
  CHAR FAR * fpDevHeader = NULL;          /* Pointer to the device header  */
  CHAR FAR * FAR * fpNextDevHeader = NULL;/* Pointer to next device header */

  wDeviceDriverCount = 0;  /* Zero out the driver count */

  /* Point to the first device driver */

  fpDevHeader = FindFirstDevHeader();

  /* Count device drivers until the header's offset is 0xFFFF */
  /*   (0xFFFF signifies the end of the list                  */

  while (FP_OFF (fpDevHeader) != 0xFFFF)
    {
      ++wDeviceDriverCount;

      /* Point to the next device driver */

      fpNextDevHeader = (CHAR FAR * FAR *) fpDevHeader;
      fpDevHeader     = *fpNextDevHeader;
    }

  /* Account for the zeroed out Device Driver record at the end */
  ++wDeviceDriverCount;

  /* Return the number of bytes required to store the structure */

  return (wDeviceDriverCount * sizeof (DEVICE_DRIVER_STRUCT));
}


/*********************************************************************
 * GetDeviceDriverInfo - Fills structure with installed device
 *                       driver's data.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetDeviceDriversInfo (DEVICE_DRIVER_STRUCT *pDevStruct,
                           BOOL fMinimumInfo)
{
  WORD wDevIndex;                     /* Index to pDevStruct             */
  WORD i;                             /* Looping variable                */
  CHAR FAR * fpDevHeader   = NULL;    /* Pointer to the device header    */
  CHAR FAR * fpDevFilename = NULL;    /* Pointer to the DEVICE= filename */
  WORD FAR * fwWordPointer = NULL;    /* WORD pointer to obtain WORD     */
                                      /*   values                        */
  CHAR FAR * FAR * fpNextDevHeader = NULL;
                                      /* Pointer to next device header   */


  /* There is no minimum info to return from this routine */

  if (fMinimumInfo)
    return (FALSE);


  /* Point to the first device driver */

  fpDevHeader = FindFirstDevHeader();

  /* Count device drivers until the header's offset is 0xFFFF */
  /*   (0xFFFF signifies the end of the list                  */

  for (wDevIndex = 0;
       wDevIndex < wDeviceDriverCount - 1 &&
       FP_OFF (fpDevHeader) != 0xFFFF;
       ++wDevIndex)
    {
      pDevStruct[wDevIndex].dwHeader = (DWORD) fpDevHeader;

      /* Set the WORD pointer */
      fwWordPointer = (WORD FAR *) fpDevHeader;

      pDevStruct[wDevIndex].wAttributes = fwWordPointer[2];

      /* Set the values for character or block devices */

      if (pDevStruct[wDevIndex].wAttributes & 0x8000)
        {
          /* Bit 15 is set, this is a character device */

          _fmemcpy ((CHAR FAR *) pDevStruct[wDevIndex].szDeviceName,
                    &fpDevHeader[10], 8);

          pDevStruct[wDevIndex].szDeviceName[8] = '\0';

          pDevStruct[wDevIndex].wUnits = 0;
        }
      else
        {
          /* Bit 15 is clear, this is a block device */

          strcpy (pDevStruct[wDevIndex].szDeviceName, pszBlockDevice);

          pDevStruct[wDevIndex].wUnits = (WORD) fpDevHeader[10];
        }


      /* Get the DEVICE= filename */

      fpDevFilename = (CHAR FAR *)
                          ((((DWORD) FP_SEG (fpDevHeader) - 1) << 16) +
                                     FP_OFF (fpDevHeader));

      /* Make sure all characters are printable */
      for (i = 8; i < 16 && fpDevFilename[i] >= ' '; ++i)
        ;

      /* Copy the DEVICE= filename to the structure if it's a Device (D) */
      /*   or an installable file system (I).                            */
      if (i == 16 && (fpDevFilename[0] == 'D') || (fpDevFilename[0] == 'I'))
        {
          _fmemcpy ((CHAR FAR *) pDevStruct[wDevIndex].szDriverFilename,
                    &fpDevFilename[8], 8);
          pDevStruct[wDevIndex].szDriverFilename[8] = '\0';
        }
      else
          pDevStruct[wDevIndex].szDriverFilename[0] = '\0';


      /* Point to the next device driver */

      fpNextDevHeader = (CHAR FAR * FAR *) fpDevHeader;
      fpDevHeader     = *fpNextDevHeader;
    }

  /* Set the last record to zeroes */
  pDevStruct[wDevIndex].dwHeader            = 0;
  pDevStruct[wDevIndex].wAttributes         = 0;
  pDevStruct[wDevIndex].szDeviceName[0]     = '\0';
  pDevStruct[wDevIndex].szDriverFilename[0] = '\0';
  pDevStruct[wDevIndex].wUnits              = 0;

  return (FALSE);
}


/*********************************************************************
 * SprintDeviceDriverInfo - Put installed device driver information
 *                          into a set of strings to be printed or
 *                          displayed.
 *
 * Returns:  NULL if an error occured.
 *********************************************************************/

QSZ * SprintDeviceDriverInfo (DEVICE_DRIVER_STRUCT *pDevStruct)
{
  WORD wNmbrStrings;        /* Number of strings                     */
  WORD wNmbrChars;          /* Number of characters in the strings   */
  WORD wUnderlineLength;    /* Length of the underline string        */
  WORD wDevIndex;           /* Index to the structure of device data */
  WORD i, u, x;             /* Looping variables                     */
  QSZ  *pqszStrings = NULL; /* Location for storing string pointers  */


  /* Calculate the amount of space required for the strings */

  wUnderlineLength = strlen (pszDeviceUnderline);

  wNmbrChars   = strlen (pszDeviceHeader) + 1 +
                 wUnderlineLength         + 1 +
                 (wDeviceDriverCount * (wUnderlineLength + 1));

  /* The underline string is expected to be as long as a line of */
  /*   device driver info.                                       */

  wNmbrStrings = wDeviceDriverCount + 3;

  /* "+ 3" is for the header line, the underline, and the NULL */
  /*   pointer at the end of the array.                        */


  /* Allocate space for the pointer area and string area */
  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);


  /* Put the first two strings in place */

  Qstrcpy (pqszStrings[0], pszDeviceHeader);
  pqszStrings[1] = pqszStrings[0] + Qstrlen (pqszStrings[0]) + 1;

  Qstrcpy (pqszStrings[1], pszDeviceUnderline);
  pqszStrings[2] = pqszStrings[1] + wUnderlineLength + 1;

  /* Put the device driver information in place */

  for (i = 2, wDevIndex = 0; pDevStruct[wDevIndex].dwHeader != 0;
       ++i, ++wDevIndex)
    {
      WORD wLength;       /* Current length of string */
      CHAR chBuffer[80];  /* Buffer for string data   */

      /* Fill the line with spaces */
      Qmemset (pqszStrings[i], ' ', wUnderlineLength);
      pqszStrings[i][wUnderlineLength] = '\0';


      /* Device Name */

      Qstrncpy (pqszStrings[i], pDevStruct[wDevIndex].szDeviceName,
               strlen (pDevStruct[wDevIndex].szDeviceName));


      /* Device Filename */

      Qstrncpy (&pqszStrings[i][DEV_FILENAME_COL],
              pDevStruct[wDevIndex].szDriverFilename,
              strlen (pDevStruct[wDevIndex].szDriverFilename));


      /* Units */

      if ((pDevStruct[wDevIndex].wAttributes & 0x8000) == 0)
        {
          wLength = sprintf (chBuffer, "% 3d", pDevStruct[wDevIndex].wUnits);

          Qstrncpy (&pqszStrings[i][DEV_UNITS_COL], chBuffer, wLength);
        }


      /* Header */

      wLength = sprintf (chBuffer, "%04X:%04X",
                         FP_SEG (pDevStruct[wDevIndex].dwHeader),
                         FP_OFF (pDevStruct[wDevIndex].dwHeader));

      Qstrncpy (&pqszStrings[i][DEV_HEADER_COL], chBuffer, wLength);


      /* Attributes */

      itoa (pDevStruct[wDevIndex].wAttributes, chBuffer, 2);

      wLength = strlen (chBuffer);

      /* Set the Attribute area to periods */
      Qmemset (&pqszStrings[i][DEV_ATTRIBUTE_COL], '.', 16);

      for (x = 0, u = DEV_ATTRIBUTE_COL + 16 - wLength;
           x < wLength; ++x, ++u)
        {
          if (chBuffer[x] == '1')
            pqszStrings[i][u] = '1';
        }

      /* Set the next pointer */
      PrepNextString (pqszStrings, i);
    }

  /* Set the last pointer to NULL */

  pqszStrings[i] = NULL;

  /* Return the pointer to pqszStrings */

  return (pqszStrings);
}


/*********************************************************************
 * FindFirstDevHeader - Finds the pointer to the list of DOS device
 *                      drivers.
 *
 * Returns:  Far pointer to the first DOS device driver (NUL).
 *********************************************************************/

CHAR FAR * FindFirstDevHeader (VOID)
{
  CHAR FAR *fpDevHeader = NULL;
  union REGS regsIn, regsOut;
  struct SREGS sregs;

  /* Get the address of the start of DOS' list of lists (ES:BX) */

  regsIn.h.ah = 0x52;
  int86x (0x21, &regsIn, &regsOut, &sregs);

  fpDevHeader = (VOID FAR *)
                  (((long)(sregs.es) << 16) + (long)(regsOut.x.bx));


  /* Add the correct offset for the version of DOS being run

       DOS Version     Offset
       -----------     ------
           3.0           28H
         3.1-3.3         22H
           4.x           22H
           5.x           22H
  */

  if (wDosMajor == 3 && wDosMinor == 0)
    fpDevHeader = fpDevHeader + 0x28;
  else
    fpDevHeader = fpDevHeader + 0x22;

  return (fpDevHeader);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\csdmtmpl.h ===
/*
	CW : Character Windows

	csdmtmpl.h : SDM template header (include for .sdm files only)				CS Compiled only !!

-- Created Mon Dec 16 14:30:51 1991 */ 

#define	SDM_COW		1


/* Compact Rectangle */
typedef struct _crc
	{
	BYTE	x, y, dx, dy;		/* order critical */
	} CRC;		/* Compact Rectangle */

/* -- defined Dialog Item */
typedef struct _tm
	{
	BITS	tmtBase:6;	/* item type */
	BIT	filler:1;	/* fThinBdr */
	BIT	fAction:1;
#ifdef SDM_ENGINE		/*CW's internal representation */
	BIT	f1:1;
	BIT	f2:1;
	BIT	f3:1;
	BIT	f4:1;
	BIT	f5:1;
	BIT	f6:1;
	BIT	f7:1;
	BIT	f8:1;
#else
	BITS	bitSlot:8;	/* misc flags */
#endif /*SDM_ENGINE*/

#ifdef CC
	WORD	bpString;	/* based pointer or wParam */
#else
	char	sz[];		/* string or wParam */
#endif /*!CC*/

	LONG	l;		/* compact rectangle or PFN */
	} TM;


/* Dialog Proc Type */
typedef BOOL	(FARPUBLIC *PFFN_DLG)(WORD, TMC, WORD, WORD, WORD);


/* dialog header */
typedef struct _dlg
	{
	CRC	crcDlg;			/* Compact Rectangle */
	WORD	hid;			/* dialog help id */
	TMC	tmcSelInit;		/* initial selection */
#ifdef VAP_API
	DWORD	pfnDlg; 		/* dialog function */
#else
	PFFN_DLG pfnDlg; 		/* dialog function */
#endif
	WORD	ctmBase;		/* # of base SDMTMs */
	WORD	filler;			/* bdr */

/* title string : based pointer */
#ifdef CC
	WORD bpTitle;			/* based pointer to title */
#else
	char szTitle[];		/* dialog title */
#endif /*!CC*/


#ifndef CC
	TM	rgtm[];			/* variable length for CS */
#else
#ifdef SDM_ENGINE
	TM	rgtm[1];		/* array starts here */
#endif
#endif /*CC*/
	} DLG;	/* Dialog Template */




// dialog header 
typedef struct _dlgitemtemplate
	{
	WORD  wClass;
	WORD  style;
	WORD  ExStyle;
	WORD  wID;
	BYTE  X;
	BYTE  Y;
	BYTE  Width;
	BYTE  Height;
	WORD  wAccelPos;		// Position of accelerator character within string.
	char *szText;
	} DLGITEMTEMPLATE, *PDLGITEMTEMPLATE;



// dialog header 
typedef struct _dlgheadtemplate
	{
	BYTE  X;
	BYTE  Y;
	BYTE  Width;
	BYTE  Height;
	WORD	hid;				// dialog help id 
	TMC	tmcSelInit;		// initial selection 

	BYTE	ctmBase;			// # of dlg items.
	char *szTitle;		// dialog title 

#ifndef CC
	DLGITEMTEMPLATE	rgtm[];			// variable length for CS 
#else
#ifdef SDM_ENGINE
	DLGITEMTEMPLATE	rgtm[1];		// array starts here 
#endif
#endif
	} DLGHEADTEMPLATE, *PDLGHEADTEMPLATE;



/*****************************************************************************/

/* instances of tmtBase  (basic tm types) */
#define	tmtNull			0
#define	tmtEnd			0
#define	tmtStaticText		1
#define	tmtFormattedText	2
#define	tmtGroupBox		3

#define	tmtPushButton		4
#define	tmtCheckBox		5
#define	tmtRadioButton		6


#define	tmtEdit			7
#define	tmtListBox		8

#define	tmtDummyText		9		/* dummy static text */
#define	tmtGeneralPicture	10		/* with Render Proc */

#define	tmtDropList		11			/* drop down list box */

#define	tmtNormalMax		12

#define	tmtUserMin		16
/* App / future  extensions (32 types) */
#define	tmtUserMax		48

#define	tmtSpecialMin		48
/* Special Records */
#define	tmtConditional		48

/* Extension Records (still Special) */
#define	tmtExtensionMin		61

#define	tmtExt1			61
#define	tmtExt2			62

#define	tmtSpecialMax		64

#define	tmtMax			64		/* 6 bits */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\custinfo.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * CUSTINFO.C - Source file for obtaining the customer data.
 ********************************************************************/


/* Include Files */

#include "msd.h"

/********************************************************************
 * GetCustInfo - Fills in the customer's name and address
 *
 * pCustInfo    - Pointer to structure to be filled with customer
 *                  data.
 * fMinimumInfo - TRUE, if minimum info is requested.
 *
 * Returns: TRUE if an error occured.
 ********************************************************************/

BOOL GetCustInfo (CUSTINFO *pCustInfo, BOOL fMinimumInfo)
{
  BOOL fReturnValue = FALSE;  /* Return value from various functions    */
  INT  i;                     /* Looping variable                       */

  /* There is no minimum info to return from this routine */

  if (fMinimumInfo)
    return (FALSE);

  /* If doing a report only, use a TTY type interface */

  if (fReportOnly)
    {
      /* Something needs to be included to read customer data from */
      /*   the MSD.INI file, as MSD.INI should take the default    */

      /* Display the title lines */

      for (i = 0; fReturnValue == FALSE && paszMsdTitleLines[i] != NULL; ++i)
        fReturnValue = PutString (paszMsdTitleLines[i]);

      /* Get the customer information from the customer */

      for (i = 0; fReturnValue == FALSE && i < MAX_CUST_INFO_TITLES; ++i)
        {
          fReturnValue = GetCustInfoLine (paszCustInfoTitle[i],
                                          pCustInfo->chCustInfo[i]);
        }

      if (fReturnValue == FALSE)
        fReturnValue = PutString ("\nGenerating Report ...\n");

      return (fReturnValue);
    }
#if CW_INCLUDED
  else
    {
      /* We're using CW */

      pCustInfoDlg = pCustInfo;
      if (DialogBox (&dlgCustInfo, CustInfoCmdDlg) == IDCANCEL)
        return (TRUE);
      else
        return (FALSE);
    }
#endif
}

/********************************************************************
 * GetCustInfoLine - Gets a line of data from the customer in TTY
 *                   mode.
 *
 * pszPromptString - Prompt string to print before accepting input.
 * pchInputString  - String to store the input.
 *
 * Returns: TRUE if an error occured.
 ********************************************************************/

BOOL GetCustInfoLine (PSZ pszPromptString, CHAR *pchInputString)
{
  BOOL fReturnValue = FALSE;    /* Return value */
  INT  i;                       /* Looping variable */

  if (pszPromptString != NULL)
    for (i = 0; fReturnValue == FALSE && pszPromptString[i] != '\0'; ++i)
      {
        fReturnValue = putchar (pszPromptString[i]);

        if (fReturnValue == EOF)
          fReturnValue = TRUE;
        else
          fReturnValue = FALSE;
      }

  if (fReturnValue == FALSE)
    fReturnValue = _DosGetLine (pchInputString, MAX_CUST_INFO);

  return (fReturnValue);
}

/********************************************************************
 * SprintCustInfo - Put the customer's name and address into a set of
 *                  strings to be printed.
 *
 * pCustInfo   - Pointer to record containing the data.
 * fReportFlag - TRUE if printing to a report.
 *
 * Returns: Pointer to the array of string pointers.  NULL pointer
 *          indicates that an error occured, or that no customer
 *          information was given.
 ********************************************************************/

QSZ * SprintCustInfo (CUSTINFO *pCustInfo)
{
  WORD wNmbrStrings = 0;    /* Number of stub strings                    */
  WORD wNmbrChars = 0;      /* Number of characters in the stub strings  */
  WORD wLength;             /* Customer String Length                    */
  WORD wTitleLength;        /* Length of title before customer string    */
                            /*   ie. "Company Name: " == 14              */
  WORD i;                   /* Looping variable                          */
  WORD wStringIndex;        /* Index to strings being built              */
  QSZ  *pqszStrings = NULL; /* Location for storing string pointers      */
  PSZ  pszCustString = NULL;/* String pointer to customer name data      */


  /* Count up the number of characters and strings in pszStubStrings */
  for (i = 0; i < MAX_CUST_INFO_TITLES; ++i)
    {
      /* Set the string pointer */

      pszCustString = &pCustInfo->chCustInfo[i][0];

      wLength = strlen (pszCustString);

      if (wLength > 0)
        {
          wTitleLength = strlen (paszCustInfoTitle[i]);

          wNmbrChars += wTitleLength + wLength + 1;

          ++wNmbrStrings;
        }
    }

  /* Bail out if there is no customer information */
  if (wNmbrStrings == 0)
    return (NULL);

  /* Bump the number of strings up one to handle the trailing NULL pointer */
  ++wNmbrStrings;

  /* Allocate space for the pointer area and string area */
  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);


  /* Put the strings in place */
  for (wStringIndex = 0, i = 0; i < MAX_CUST_INFO_TITLES; ++i)
    {
      /* Set the string pointer */

      pszCustString = &pCustInfo->chCustInfo[i][0];

      if (strlen (pszCustString) > 0)
        {
          Qstrcpy (pqszStrings[wStringIndex], paszCustInfoTitle[i]);
          Qstrcat (pqszStrings[wStringIndex], pszCustString);

          pqszStrings[wStringIndex + 1] =
            pqszStrings[wStringIndex] +
            Qstrlen (pqszStrings[wStringIndex]) + 1;

          ++wStringIndex;
        }
    }

  /* Set the last pointer to NULL */
  pqszStrings[wStringIndex] = NULL;

  /* Return the pointer to pqszStrings */
  return (pqszStrings);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\cwindows.h ===
/*
	CW : Character Windows
	cwindows.h

	CC should be defined for compilation with Cmerge.

    If defined, the following flags inhibit definition
      of the indicated constants.

    NOALL		Defines all the following:
    NOCOLOR		colors or ISA's
    NODRAW		drawing macros / constants
    NOMB		MB_* & ID's
    NOMEMMGR		LMEM_*
    NOMENUS		menus
    NOMINMAX		Macros min(a,b) and max(a,b)
    NOMSG		typedef MSG
    NOPROCS		procedure definitions (always for CS)
    NORECT		typedefs ARC, RRC
    NOSCROLL		SB_*
    NOSUBSTYLES		BS_*, LBS_*, ES_*
    NOSWAP		non-swapped version (currently only for small model)
    NOVIRTUALKEYCODES	VK_*
    NOWINMESSAGES	WM_*
    NOWINSTYLES		WS_*
    NOWND		WND / PWND typedef's or macros
    NOWNDMACROS		window creation macros

-- Created Mon Dec 16 14:28:48 1991 */ 


#ifdef NOALL
#define NOCOLOR
#define NODRAW
#define NOKEYSTATE
#define NOMB
#define NOMEMMGR
#define NOMENUS
#define NOMINMAX
#define NOMSG
#define NOPROCS
#define NORECT
#define NOSCROLL
#define NOSUBSTYLES
#define NOSWAP
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOWND
#define NOWNDMACROS
#endif /*NOALL*/


#ifdef OS2_INCLUDED
/* defined in OS2.H */
#undef	CHAR
#endif	/* OS2_INCLUDED */


#ifndef CC
/* -- Pcode Specific Definitions -- */
#ifndef EXPORT
#define	EXPORT	export
#endif
#ifndef NATIVE
#define	NATIVE	native
#endif
#else
/* -- Cmerge Compiler -- */
#ifndef CDECL
#define CDECL cdecl
#endif
#endif /*CC*/


#ifndef PASCAL
#define	PASCAL pascal
#endif

#define	FALSE	0
#define	TRUE	1
#define	NULL	0

#ifndef VAP_API
#define	FAR	far
#else
#define	FAR	near
#endif

#define	LONG	long
#define	VOID	void
#ifdef CC
#define	NEAR	near
#else
#define NEAR
#endif

#define FARPUBLIC	FAR PASCAL		/* all interfaces FAR */

#ifndef OS2_INCLUDED
/* defined in OS2.H */
typedef unsigned char	BYTE;
typedef int		BOOL;
typedef int	(FARPUBLIC *PFN)();		/* General Procedure */
#endif	/* !OS2_INCLUDED */

typedef unsigned short	WORD;
typedef unsigned long	DWORD;
typedef BOOL	(FARPUBLIC *PFFN)();		/* BOOL Procedure */
typedef VOID	(FARPUBLIC *PVFN)();		/* Void Procedure */
typedef WORD	(FARPUBLIC *PWFN)();		/* Word Procedure */
typedef DWORD	(FARPUBLIC *PLFN)();		/* DWORD Procedure */
typedef VOID	(FARPUBLIC *LPFN)();		/* explicit FAR procedure */
typedef BYTE FAR *	(FARPUBLIC *LPFN_LPB)();
typedef WORD		HANDLE;
typedef unsigned	BIT;
typedef unsigned	BITS;

/* special type for WndProc pointers */

// typedef DWORD	(FARPUBLIC *PLFN_WNDPROC)(struct _wnd *, WORD, WORD, DWORD);

/* BYTE/WORD types */
#ifndef CC	/* Pcode => WORD */
typedef WORD		AX;
typedef WORD		AY;
typedef WORD		RX;
typedef WORD		RY;
typedef WORD		ISA;
#else
typedef BYTE		AX;
typedef BYTE		AY;
typedef BYTE		RX;
typedef BYTE		RY;
typedef BYTE		ISA;
#endif /*CC*/

typedef	struct szi_
	{
	char *	sz;
	ISA	isa;
	} SZI;

typedef char FAR	*LPSTR;
typedef int  FAR	*LPINT;

#ifndef NOMINMAX
#define	max(a,b)	((a) > (b) ? (a) : (b))
#define	min(a,b)	((a) < (b) ? (a) : (b))
#endif

#ifndef OS2_INCLUDED
/* defined in OS2.H */
#define	MAKELONG(l, h)	((long)(((unsigned)(l)) | ((unsigned long)((unsigned)(h))) << 16))
#define	LOBYTE(w)	((BYTE) ((w) & 0xff))
#define	HIBYTE(w)	((BYTE)(((WORD)(w) >> 8) & 0xff))
#endif	/* !OS2_INCLUDED */

#define MAKEWORD(l, h)	((WORD)(((BYTE)(l)) | ((WORD)((BYTE)(h))) << 8))
#define	LOWORD(l)	((WORD)(l))
#define	HIWORD(l)	((WORD)(((DWORD)(l) >> 16) & 0xffff))

/* DCHAR = Double Byte Character */
typedef	WORD		DCHAR;
/* CHAR = unsigned char */
typedef unsigned char	CHAR;

/* ACHAR = either a DCHAR or a CHAR */
#ifdef KANJI
typedef	DCHAR		ACHAR;
extern BOOL PASCAL fKanaAccel;	/* set by application to choose accelerators */
#else
typedef	CHAR		ACHAR;
#endif

/*****************************************************************************/

#ifndef NORECT

typedef struct _rrc
	{
	BYTE	rxLeft;
	BYTE	ryTop;
	BYTE	rxRight;
	BYTE	ryBottom;
	};


typedef struct _arc
	{
	BYTE	axLeft;
	BYTE	ayTop;
	BYTE	axRight;
	BYTE	ayBottom;
	};

typedef struct _box
	{
	char	chTopLeftCorner;
	char	chTopRightCorner;
	char	chBottomLeftCorner;
	char	chBottomRightCorner;
	char	chTopSide;
	char	chBottomSide;
	char	chLeftSide;
	char	chRightSide;
	} BOX;

typedef BOX *PBOX;

extern BOX PASCAL boxSingle, PASCAL boxDouble;
extern BOX PASCAL boxActiveWnd;
extern BOX PASCAL boxInactiveWnd;
extern BYTE PASCAL axMac;
extern BYTE PASCAL ayMac;
/* all CW applications should work with screens up to 254x254 */
#define axMax 254
#define ayMax 254

#endif /*!NORECT*/

#ifndef NOWND

#ifndef cwExtraWnd
#ifdef CC
/* -- for CC compiler : fixed length */
#define cwExtraWnd 1 
#else
/* -- for CS compiler : variable length */
#define cwExtraWnd
#endif
#endif



#ifdef BASED

typedef struct _wnd _based(pWndSeg) WND;
typedef WND *PWND;

typedef DWORD	(FARPUBLIC *PLFN_WNDPROC)(PWND, WORD, WORD, DWORD);

typedef struct _rrc RRC;
typedef struct _rrc *NPRRC;
typedef struct _rrc _based(pWndSeg) *PRRC;

typedef struct _arc ARC;
typedef struct _arc *NPARC;
typedef struct _arc _based(pWndSeg) *PARC;

typedef VOID _based(pWndSeg) *PVOID;

#else

typedef VOID *PVOID;

typedef struct _wnd WND;
typedef WND *PWND;

typedef DWORD	(FARPUBLIC *PLFN_WNDPROC)(PWND, WORD, WORD, DWORD);

typedef struct _rrc RRC;
typedef RRC *PRRC;
typedef RRC *NPRRC;

typedef struct _arc ARC;
typedef ARC *PARC;
typedef ARC *NPARC;

#endif



#ifdef BLADE

#ifdef BROADSWORD

typedef struct _wnd
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
	PLFN_WNDPROC pfnWndProc;
	PWND pwndParent;
	PWND pwndSibling;
	PWND pwndChild;
	WORD	pcls;
	BYTE	axCursor;
	BYTE	ayCursor;
	};

#else

typedef struct _wnd
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifndef REVIEW	/* size issue */
	RRC	rrcInvalid;			/* overlap update info */
#endif
	PLFN_WNDPROC pfnWndProc;		/* Medium Model */
	PWND pwndParent;
	PWND pwndSibling;
	PWND pwndChild;
	BYTE	axCursor;
	BYTE	ayCursor;
	BYTE	wndBytes;
#ifdef MLE
	WORD	rgwExtra[cwExtraWnd];
	BYTE	Pad;
#endif
	};

#endif //BROADSWORD


#else	//BLADE

typedef struct _wnd
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
#ifdef BLADE
	WORD	wExtStyle;
#endif
#ifdef PROJECT_PWB
	WORD	wExtStyle;
#endif
	ARC	arcWindow;
	ARC	arcClipping;
#ifndef REVIEW	/* size issue */
	RRC	rrcInvalid;			/* overlap update info */
#endif
	PLFN_WNDPROC pfnWndProc;		/* Medium Model */
	struct _wnd *pwndParent;
	struct _wnd *pwndSibling;
	struct _wnd *pwndChild;

	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef NO_WNDEXTRA
	WORD	rgwExtra[cwExtraWnd];
#endif
	};

#endif //BLADE



#ifndef BROADSWORD

typedef struct wndClass
{
  struct wndClass *next;
  WORD wStyle;
  WORD wExtStyle;
  PLFN_WNDPROC pfnWndProc;
  WORD  cbClsExtra;
  WORD  cbWndExtra;
  WORD  wClass;
} WNDCLASS;

typedef WNDCLASS *PWNDCLASS;

#else

typedef struct tagWNDCLASS
  {
    WORD				style;
	 PLFN_WNDPROC 	lpfnWndProc;
    int				cbClsExtra;
    int				cbWndExtra;
    WORD				hInstance;
    WORD				hIcon;
    WORD				hCursor;
    WORD				hbrBackground;
    WORD				lpszMenuName;
    WORD				lpszClassName;
  } WNDCLASS;

typedef WNDCLASS	    *PWNDCLASS;
typedef WNDCLASS NEAR *NPWNDCLASS;
typedef WNDCLASS FAR	 *LPWNDCLASS;


// Window internal class structure 

typedef struct tagCLS
  {
    // NOTE: The order of the following fields is assumed. 
    struct tagCLS   *pclsNext;
    int					cWndReferenceCount;   // The number of windows registered  with this class 
    WORD					style;
	 PLFN_WNDPROC		lpfnWndProc;
    int					cbClsExtra;
    int					cbWndExtra;
    WORD					hInstance;
    WORD					hIcon;
    WORD					hCursor;
    WORD					hbrBackground;
    WORD					lpszMenuName;
    WORD					lpszClassName;
  } CLS;

typedef CLS *PCLS;
typedef CLS far *LPCLS;
typedef PCLS  *PPCLS;

#endif

typedef BOOL	(FARPUBLIC *PWFN_ENUM)(WORD, WORD );


#ifndef	REVIEW	/* size issue */ /* for wnd static window construction macros */
#define	rrcInvalidStd	{0, 0, 0, 0},
#else
#define	rrcInvalidStd
#endif

// typedef WND *PWND;
#endif /*!NOWND*/


extern BYTE	PASCAL	fMousePresent;		/* valid after init */

#ifndef	NOPROCS

VOID		FARPUBLIC GetProgDir(char *);			/*OPTIONAL*/

BOOL		FARPUBLIC FInitCow(void);			/*OPTIONAL*/
VOID		FARPUBLIC LeaveCow(BOOL);			/*OPTIONAL*/
VOID		FARPUBLIC BackToCow(BOOL);			/*OPTIONAL*/
VOID		FARPUBLIC EndCow(BOOL);				/*OPTIONAL*/

/* Swapped Cow exit */
#ifndef	NOSWAP
#ifdef	CC
VOID		FAR CDECL exit(int);				/*OPTIONAL*/
#endif
#endif

#endif	/* NOPROCS */


/*** mcb - mouse cursor block */
typedef struct mcb
	{
	WORD	colHot;					// Hot Spot for			     
	WORD	rowHot;					//   graphics mouse cursor.	     
	WORD	rgwAndMaskGfx[16];	// Bit map masks for		     
	WORD	rgwXorMaskGfx[16];	//   graphics mouse cursor.	     
	WORD	wAndMaskText;			// Character and Attribute masks for 
	WORD	wXorMaskText;			//   text mouse cursor.		     
	} MCB; 

/*** mcb - mouse conditional off block */
typedef struct mcob
	{
	WORD	xLeft;
	WORD	yTop;
	WORD	xRight;
	WORD	yBottom;
	} MCOB; 

/* Key state masks for mouse messages (in wParam) */

#define	MK_LBUTTON			0x0001
#define	MK_RBUTTON			0x0002
#define	MK_SHIFT				0x0004
#define	MK_CONTROL			0x0008
#define	MK_MBUTTON			0x0010
#define	MK_NONCLIENT		0x0060	/* either X or Y outside */
#define	MK_NONCLIENT_X		0x0020
#define	MK_NONCLIENT_Y		0x0040
#define	MK_ALT				0x8000
#define	MK_MENU				0x8000

#ifndef	NOPROCS

BOOL		FARPUBLIC FEnableMouse(BOOL);
VOID		FARPUBLIC SetMouseCursor(MCB FAR *);		/*OPTIONAL*/
VOID		FARPUBLIC MouseConditionalOff( MCOB *);	/*OPTIONAL*/
VOID		FARPUBLIC SetMousePos(WORD, WORD);			/*OPTIONAL*/
VOID		FARPUBLIC SetMouseDoubleSpeed(WORD);		/*OPTIONAL*/
BOOL		FARPUBLIC SwapMouseButton(BOOL);			 	/*OPTIONAL*/
WORD		FARPUBLIC CbSizeMouseState(void);			/*OPTIONAL*/
VOID		FARPUBLIC SaveMouseState(BYTE FAR *);		/*OPTIONAL*/
VOID		FARPUBLIC RestoreMouseState(BYTE FAR *);	/*OPTIONAL*/

#endif	/* !NOPROCS */


#ifdef COW
#ifdef BLADE
extern AX	PASCAL axMouse;
extern AY	PASCAL ayMouse;
#endif
#endif




typedef	struct _gheap {
	/* FGlobalHeapInfo */
	WORD	cpDataTotal;	/* Sum of all Data blocks */
	WORD	cpCodeTotal;	/* Sum of all Code blocks below fence */
	WORD	cpFreeTotal;	/* Size of all Free blocks below fence */
	WORD	cpFreeMac;	/* Size of largest Free below fence */
	WORD	cpReserve;	/* Size of codefence reserve area */
	} GHEAP;

extern BYTE PASCAL	fShellPresent;		/* DOS 3 : SHELL.EXE hook */

#ifndef	NOPROCS
HANDLE		FARPUBLIC GlobalAlloc(WORD, DWORD);		/*OPTIONAL*/
HANDLE		FARPUBLIC GlobalFree(HANDLE);			/*OPTIONAL*/
LPSTR		FARPUBLIC GlobalLock(HANDLE);			/*OPTIONAL*/
DWORD		FARPUBLIC GlobalHandle(HANDLE);			/*OPTIONAL*/
HANDLE		FARPUBLIC GlobalReAlloc(HANDLE, DWORD, WORD);	/*OPTIONAL*/
BOOL		FARPUBLIC GlobalUnlock(HANDLE);			/*OPTIONAL*/
DWORD		FARPUBLIC GlobalCompact(DWORD);			/*OPTIONAL*/

BOOL		FARPUBLIC FSetCodeReserve(WORD *); 		/*OPTIONAL*/
BOOL		FARPUBLIC FGlobalHeapInfo(GHEAP FAR *); 		/*OPTIONAL*/

DWORD		FARPUBLIC RerrExec(char *, char *, char *, BOOL, BOOL); /*OPTIONAL*/
								/*OPTIONAL*/
BYTE FAR *	FARPUBLIC LpbAppDataUnpack(void);		/*OPTIONAL*/
VOID		FARPUBLIC DosIdle(void);			/*OPTIONAL*/
VOID		FARPUBLIC BindSegment(PFN, BOOL);		/*OPTIONAL*/
VOID		FARPUBLIC AccessSwapFile(BOOL);			/*OPTIONAL*/
#endif	/* !NOPROCS */

/* GlobalAlloc flags */
#define GMEM_MOVEABLE	    0x0002
#define GMEM_ZEROINIT	    0x0040


/* rerr return values */

#define	rerrOk			0			/* must be zero! */

#define	rerrBadFile		2
#define	rerrBadPath		3
#define	rerrAccessDenied	5
#define	rerrNoMemory		8

#define	rerrBadEnv		10
#define	rerrBadFormat		11

#define	rerrBadRead		30

#define	rerrBadVersion		90
#define	rerrBadMemReq		91
#define	rerrMemUnstable		92
#define	rerrNoService		93
#define	rerrTSR			94

/* Key state masks for keyboard messages (in HIWORD(lParam)) */
#define	KK_EXTENDED		0x8000	/* from extended keypad usually */
/* shifts */
#define	KK_CAPLOCK		0x4000
#define	KK_NUMLOCK		0x2000
#define	KK_SCRLOCK		0x1000
#define	KK_ALT			0x0800
#define	KK_CONTROL		0x0400
#define	KK_SHIFT		0x0200

/* for WM_CHAR */
#define	KK_VK			0x01ff	/* mask to get untranslated VK_ */

/* for WM_KEYUP / WM_KEYDOWN */
#define	KK_SC			0x00ff	/* mask to get scan code */

#define KJ_SC			0xff00
#define KJ_KANA 		0x0080
#define KJ_OTHER		0x0040
#define KJ_KK			0x00b0
#define KJ_COUNT		0x003f

#define	abAbortNone	0
#define	abAbortESC	1
#define	abAbortBRK	2
#define	abAbortRepaint	3

extern BOOL PASCAL abAbort;							/* normal Abort */
extern BOOL PASCAL fPollKeyboard;					/* Poll the keyboard ? */
extern BYTE PASCAL fKeyIsUp, PASCAL fKeyWasUp;	/* Key transitions */
extern WORD PASCAL wRateKeyRepeat;					/* repeat rate */

#ifndef	NOPROCS

#ifdef BLADE
BOOL		FARPUBLIC IsAltKeyDown(VOID);					/*OPTIONAL*/
#endif

DWORD	FARPUBLIC EnableKeyboard(BOOL);
VOID	FARPUBLIC PollKeyboard(void);
VOID	FARPUBLIC PollPhysicalKeyboard(void);
VOID	FARPUBLIC SetShiftKk(WORD);
VOID	FARPUBLIC DisableExtendedKeyboard(void);
VOID	FARPUBLIC SetTsrProtocol(WORD, BYTE, BYTE);

#endif	// !NOPROCS 


/*****************************************************************************/
/* Extra Font info */

typedef	struct _inft
	{
	/* character/font size */
	BYTE	dxChar;			/* width of character in pixels */
	BYTE	dyChar;			/* height of character in pixels */

	BYTE	dyBaseLine;		/* base line height */
	BYTE	ifont;			/* font index */
	} INFT;

typedef	struct _cib
	{
	/* CSD info block */
	WORD	flags;
	WORD	coImbue1;		/* default extra color */
	WORD	sig;			/* signature (cwdrv.doc has sigs) */
	WORD	coGridAndShade;		/* KANJI: color for grid & shade */
	WORD	mppHoriz;		/* KANJI: horizontal mickey ratio */
	WORD	mppVert;		/* KANJI: vertical mickey ratio */
	} CIB;

typedef	struct _cdi
	{
	/* CSD Default Information */
	WORD	cwcib;			/* length of rgw */
	CIB	cib;			/* info words */
	} CDI;


/*****************************************************************************/
/* CSD signatures */

#define	sigStandard	0x0000
#define	sigNEC98		0x9800

/*****************************************************************************/
/* font variations */

#ifdef KANJI
typedef	DWORD	FFONT;			/* 32 bit FFONT for Kanji */
#else
typedef	WORD	FFONT;			/* 16 bits normal FFONT */
#endif


#define	ffontNormal		0x0000	/* normal attributes */

#define	ffontUnderline		0x0001
#define	ffontDoubleUnderline	0x0002
#define	ffontOrUnderline	0x0003	/* ... underline */
#define	ffontStrikeThrough	0x0004	/* horizontal strike through */
#define	ffontBold		0x0008
#define	ffontSubscript		0x0010
#define	ffontSuperscript	0x0020
#define	ffontMiniCap		0x0030	/* mini capital */
#define	ffontItalic		0x0040
#define	ffontOrCharacter	0x0080	/* extra field => font extension */
#define	ffontReservedBits	0x0F00
#define	ffontExtraMask		0xf000	/* one of 16 extra items */
#define	ffontOrUnderlineSupport	0x1000

#ifdef KANJI
/* 32-bit ffont extension for Kanji support */
#define	ffontVgrid		0x000F0000
#define	ffontHgrid		0x00F00000
#define	ffontShadeType		0x03000000
#define	ffontDoubleWidth	0x04000000
#define	ffontDoubleHeight	0x08000000
#define	ffontDoubleRight	0x10000000
#define	ffontDoubleLower	0x20000000
#define	ffontDwLeft		(ffontDoubleWidth)
#define	ffontDwRight		(ffontDoubleWidth | ffontDoubleRight)
#define	ffontDhUpper		(ffontDoubleHeight)
#define	ffontDhLower		(ffontDoubleHeight | ffontDoubleLower)
#define	ffontReserved		0xC0000000
#endif /*KANJI*/

/* extra ffont (high 16-bit) for inscr.inc */
#define	fxfontVgrid		0x000F
#define	fxfontHgrid		0x00F0
#define	fxfontShadeType		0x0300
#define	fxfontDoubleWidth	0x0400
#define	fxfontDoubleHeight	0x0800
#define	fxfontDoubleRight	0x1000
#define	fxfontDoubleLower	0x2000
#define	fxfontDwLeft		0x0400
#define	fxfontDwRight		0x1400
#define	fxfontDhUpper		0x0800
#define	fxfontDhLower		0x2800
#define	fxfontReserved		0xC000

/* CSD flags */
#define	CSD_FORCERESET	0x0001	/* force the CSD to do a BIOS reset */
#define	CSD_SNOW	0x0002	/* use snow protection */
#define	CSD_NOSETMOUSE	0x0004	/* this hardware has an obscure mouse */

/*****************************************************************************/
/* Installable state */

typedef WORD	FINST;
#define	finstText		0x0001	/* text mode */
#define	finstGraphics		0x0002	/* graphics mode */
#define	finstMonochrome		0x0004	/* monochrome mode */
#define	finstAlternate		0x0008	/* alternate adapter (2nd screen) */
#define	finstFont		0x0010	/* supports fonts */
#define	finstAttrFont		0x0020	/* map Font calls into attribute info */
#define	finstExtendedMono	0x0040	/* EGA and VGA mono */
#define	finstGraphicArc		0x0080	/* Save/Restore Graphics Arc support */
#define	finstBltArcCsd		0x0100	/* Specific BltArcCsd available */
#define finstSizeable		0x0200	/* app can specify size when mode is
					   initialized */
#define	finstDisableMouse	0x1000	/* gfx w/o mouse support (hercules,os/2) */
#define	finstFastScroll		0x2000	/* fast scroll (BltArc) for gfx text */
#define	finstQuestionable	0x4000	/* questionable mode selection */
#define	finstAvailable		0x8000	/* available with current hardware */


typedef struct _inst
	{
	FINST	finst;
	BYTE	axMac;
	BYTE	ayMac;

	/* color palette info */
	BYTE	coMac;			/* maximum color index */
	BYTE	covMac;			/* maximum color value (palette) */
	WORD	coiMac;			/* maximum color intensity */

	/* Extra information */
	WORD	imode;			/* video mode */

	INFT	inft;			/* font info (pointers may be NULL) */
	WORD	ffontSupported;		/* valid ffont values */
					/* non-grid line styles */

	/* buffers (if non-zero then do not need to be allocated */
	WORD	psPrim;			/* primary screen buffer */
	WORD	psSec;			/* secondary screen buffer */

	WORD	cwExtra;		/* requested extra size */
	WORD	psExtra;		/* extra screen buffer (driver's use) */

	/* CW internal info */
	BIT	fAllocPrim:1;
	BITS	filler:15;

	/* Driver specific info */
	WORD	wDriver1;
	WORD	reserved2[7];
	} INST;

/* Special IMODEs */
#define	imodeUnknown	0xffff	/* unknown mode */

/*****************************************************************************/
/* Installable characters */

typedef struct _inch
	{
	/* Single Line Box */
	char	_chTopLeftCorner1;
	char	_chTopRightCorner1;
	char	_chBottomLeftCorner1;
	char	_chBottomRightCorner1;
	char	_chTopSide1;
	char	_chBottomSide1;
	char	_chLeftSide1;
	char	_chRightSide1;

	/* other single line */
	char	_chMiddleLeft1;
	char	_chMiddleRight1;

	/* Double Line Box */
	char	_chTopLeftCorner2;
	char	_chTopRightCorner2;
	char	_chBottomLeftCorner2;
	char	_chBottomRightCorner2;
	char	_chTopSide2;
	char	_chBottomSide2;
	char	_chLeftSide2;
	char	_chRightSide2;
	/*note: no middles */

	/* Arrows */
	char	_chUpArrow;
	char	_chDownArrow;
	char	_chLeftArrow;
	char	_chRightArrow;

	/* Misc */
	char	_chBullet;			/* for menu */
	char	_chMiddleDot;			/* for edit */
	char	_chScrollbar;			/* for scroll bar */
	char	_chElevator;			/* for scroll bar */
	char	_chShadowInit;			/* b&w shadow character */

	/* For Overlapping windows */
	char	_chClose;			/* Close box */
	char	_chZoomIn;			/* Zoom in */
	char	_chZoomOut;			/* Zoom out */
	char	_chUpDownArrow;			/* double arrow */
	char	_chLeftRightArrow;		/* double arrow */

	WORD	reserved[16];
	} INCH;

/*****************************************************************************/
/* screen save info */

typedef WORD	FVIDS;			/* flags */
#define	fvidsChAttr	1		/* video buffer is in form ch:attr */

typedef	struct _vids
	{
	BYTE	mode;			/* screen mode */
	BYTE	page;			/* page # */
	FVIDS	fvids;			/* flags for saved state */
	WORD	cwVidData;		/* # of bytes of screen data */
	WORD	cwExtra;		/* # of extra bytes for mode info */
	WORD	rgwExtra[1];		/* actually rgwExtra[cwExtra] */
	} VIDS;	/* Video state */

/*****************************************************************************/

#define	fmemFixed	1		/* always set !! */
#define	fmemNear	2		/* allocate near */

/* limit of near space / driver service */
#define	cbNearMemServiceMax	128

/* INDT: Driver Service Types */			/* Extension and Owner/Initiator */
#define	indtNil			0
#define	indtKeyboard		1			/* .KBD	CW */
#define	indtCharacterScreen	2			/* .CSD	CW */
#define	indtGraphicScreen	3			/* .GSD	CW */
#define	indtCharacterPrinter	4			/* .PRD	? */
#define	indtGraphicPrinter	5			/* .GPD	CW */
#define	indtSystem		6			/* .SYD	CW */
#define	indtSerialComm		7			/* .SCD	EBU */
#define	indtCellPrinter		8			/* .CPD	MSKK */
#define	indtMachineData		9			/* .MDD	MSKK */
#define	indtKkcInterface	10			/* .KID	MSKK */
#define	indtPseudoPrinter	11			/* .PPD MSKK */
#define  indtKeytop		12
#define  indtFileTransfer		13			/* .FTD EBU Works */
/* ... others to be defined ... */

typedef struct _indv
	{
	/* input values */
	BYTE	indt;				/* service wanted */
	BYTE	filler;				/* reserved */
	LPFN *	rglpfn;				/* where to put vectors */
	WORD	cpfnNeedMin;			/* # entries needed */
	WORD	cpfnNeedMac;			/* # entries wanted */
	/* return values */
	WORD	psLoaded;			/* != 0 => loaded */
	WORD	cpfnLoaded;			/* # entries loaded */
	} INDV;

#ifndef	NOPROCS
WORD	FARPUBLIC RerrLoadDrv(char *, INDV *, WORD);	/* OPTIONAL */
WORD	FARPUBLIC RerrLoadCwDrv(char *);		/* OPTIONAL */
WORD	FARPUBLIC RerrLoadDrvFd(WORD, INDV *, WORD);	/* OPTIONAL */
WORD	FARPUBLIC RerrLoadCwDrvFd(WORD);		/* OPTIONAL */
VOID	FARPUBLIC FreeDrv(INDV *, WORD);		/* OPTIONAL */
VOID	FARPUBLIC FreeCwDrv(void);			/* OPTIONAL */
#endif	/* !NOPROCS */


extern INST PASCAL instCur;
extern INCH PASCAL inch;		/* near buffer for characters */
extern BOOL PASCAL fFontAvailable;	/* extra "ffont" drawing available ? */

/* name aliases for the actual characters */
#define	chTopSide1		(inch._chTopSide1)
#define	chBottomSide1		(inch._chBottomSide1)
#define	chLeftSide1		(inch._chLeftSide1)
#define	chRightSide1		(inch._chRightSide1)
#define	chTopLeftCorner1	(inch._chTopLeftCorner1)
#define	chTopRightCorner1	(inch._chTopRightCorner1)
#define	chBottomLeftCorner1	(inch._chBottomLeftCorner1)
#define	chBottomRightCorner1	(inch._chBottomRightCorner1)
#define chMiddleLeft1		(inch._chMiddleLeft1)
#define chMiddleRight1		(inch._chMiddleRight1)
#define	chTopSide2		(inch._chTopSide2)
#define	chBottomSide2		(inch._chBottomSide2)
#define	chLeftSide2			(inch._chLeftSide2)
#define	chRightSide2		(inch._chRightSide2)
#define	chTopLeftCorner2	(inch._chTopLeftCorner2)
#define	chTopRightCorner2	(inch._chTopRightCorner2)
#define	chBottomLeftCorner2	(inch._chBottomLeftCorner2)
#define	chBottomRightCorner2	(inch._chBottomRightCorner2)
#define	chUpArrow		(inch._chUpArrow)
#define	chDownArrow		(inch._chDownArrow)
#define	chRightArrow		(inch._chRightArrow)
#define	chLeftArrow		(inch._chLeftArrow)
#define	chBullet		(inch._chBullet)
#define	chMiddleDot		(inch._chMiddleDot)
#define	chScrollbar		(inch._chScrollbar)
#define	chElevator		(inch._chElevator)
#define	chShadowInit		(inch._chShadowInit)

/* for overlapping windows */
#define	chClose			(inch._chClose)
#define	chZoomIn		(inch._chZoomIn)
#define	chZoomOut		(inch._chZoomOut)
#define	chUpDownArrow		(inch._chUpDownArrow)
#define	chLeftRightArrow	(inch._chLeftRightArrow)

/*****************************************************************************/
/* Screen Procedures */

typedef WORD FAR *	(FAR PASCAL *LPFN_DRV_ALLOC)(WORD, WORD);
typedef VOID		(FAR PASCAL *LPFN_DRV_FREE)(WORD FAR *);

#ifndef	NOPROCS
WORD	FARPUBLIC ImodeGuessCurrent(void);			/*OPTIONAL*/
BOOL	FARPUBLIC FQueryInst(INST *, WORD);			/*OPTIONAL*/
BOOL	FARPUBLIC FAllocInstBuffers(INST *, LPFN_DRV_ALLOC, BOOL); /*OPTIONAL*/
VOID	FARPUBLIC FreeInstBuffers(INST *, LPFN_DRV_FREE);	/*OPTIONAL*/

BOOL	FARPUBLIC FAllocOverlapTable(INST *, LPFN_DRV_ALLOC);	/*OPTIONAL*/
VOID	FARPUBLIC FreeOverlapTable(LPFN_DRV_FREE);		/*OPTIONAL*/

BOOL	FARPUBLIC FInitScreen(INST *, WORD);				/*OPTIONAL*/
VOID	FARPUBLIC EndScreen(BOOL);				/*OPTIONAL*/

BOOL	FARPUBLIC FGetColorPalette(WORD, WORD *, WORD *);	/*OPTIONAL*/
VOID	FARPUBLIC SetColorPalette(WORD, WORD, WORD *);		/*OPTIONAL*/

VOID	FARPUBLIC MoveHwCursCsd(AX, AY, WORD);			/*OPTIONAL*/

BOOL	FARPUBLIC FQueryInft(INFT *, WORD);			/*OPTIONAL*/

WORD	FARPUBLIC CbSizeVids(void);				/*OPTIONAL*/
BOOL	FARPUBLIC FSaveVids(VIDS *, INST *);			/*OPTIONAL*/
BOOL	FARPUBLIC FRestoreVids(VIDS *);				/*OPTIONAL*/
VOID	FARPUBLIC SaveVidData(VIDS *, WORD FAR *);		/*OPTIONAL*/
VOID	FARPUBLIC RestoreVidData(VIDS *, WORD FAR *);		/*OPTIONAL*/
VOID	FARPUBLIC EnableVidsMonitor(BOOL);			/*OPTIONAL*/

VOID	FARPUBLIC GetCSDDefaultInfo(CDI *);			/*OPTIONAL*/
VOID	FARPUBLIC SetCSDDefaultInfo(CDI *);			/*OPTIONAL*/


#ifdef KANJI
VOID	FARPUBLIC GetCharMap(INFT *, WORD, BYTE *);
VOID	FARPUBLIC SetCoBackPriority(BYTE FAR *, WORD);	/*OPTIONAL*/
#else /*!KANJI*/
VOID	FARPUBLIC GetCharMap(INFT *, BYTE, BYTE *);
#endif /*KANJI*/
#endif	/* !NOPROCS */


#if !defined(ADM)
	WORD	FARPUBLIC MessageBox(char *, char *, char *, WORD);
	WORD	FARPUBLIC MessageBoxAxAy(char *, char *, char *, WORD, AX, AY);
	VOID	FARPUBLIC SetDialogCaption(HANDLE, char *);	/*OPTIONAL*/
	BOOL	FARPUBLIC EndDlgTmc(WORD);				/*OPTIONAL*/
	BOOL	FARPUBLIC PassMsgToDialogProc ( WORD, WORD, WORD, WORD, WORD );	/*OPTIONAL*/
#else
	VOID	FARPUBLIC SetDialogCaption(HANDLE, char *);	/*OPTIONAL*/
	WORD	FARPUBLIC GetDlgItemText	(PVOID, char *, WORD);	
	VOID	FARPUBLIC SetDlgItemText	(PVOID, char *, BOOL);	
#endif

VOID	FARPUBLIC HiliteDialogAccel(void);	/*OPTIONAL*/

#define	dlmReturn	0x7fff	// for PWB guys to process return key events.

/* Message Box Definitions */

#ifndef NOMB

#define	IDDEFAULT	10
#define	IDOK	  		1
#define	IDCANCEL 	2
#define	IDABORT  	3
#define	IDRETRY  	4
#define	IDIGNORE 	5
#define	IDYES	  		6
#define	IDNO	  		7

#ifdef	HELP_BUTTON
#define	IDHELP		8
#endif

#define	MB_OK					1
#define	MB_YESNOCANCEL		2
#define	MB_RETRYCANCEL		3
#define	MB_OKCANCEL			4
#define	MB_ABORT				5
#define	MB_YESNO				6
#define	MB_RETRY				7
#define	MB_TYPE			0x0f		// message type 
#define	MB_BEEP			0x10
#define	MB_CAPTION		0x20		// 1st param is caption 
#define	MB_BUTTON		0x0300	// button mask 
#define	MB_DEFBUTTON1	0x0000	// initial button to get focus 
#define	MB_DEFBUTTON2	0x0100
#define	MB_DEFBUTTON3	0x0200

#ifdef	HELP_BUTTON
#define	MB_DEFBUTTON4	0x0300
#define	MB_NOHELP		0x8000
#endif

#endif //!NOMB

// for Special MessageBox 
extern BYTE FAR * PASCAL lpbWorkTemp;	// App should never use directly 

#define	InitSpecialMessageBox(lpbBuff)	\
	{				\
	Assert(lpbWorkTemp == NULL);	\
	lpbWorkTemp = (lpbBuff);	\
	}

#define	EndSpecialMessageBox()		\
	{				\
	Assert(lpbWorkTemp != NULL);	\
	lpbWorkTemp = NULL;		\
	}

/* so that rspAppIdle can determine where the current msg box dialog is */
// extern PWND_DLG	pwndDlg;		/* Again, app should never use */

#define PwndDlgCur()		pwndDlg

#if defined(ADM)

#ifdef DEBUG
	VOID FARPUBLIC EndDialog		( PVOID, WORD);	/*OPTIONAL*/
#else
	#define EndDialog(pwnd, wParam )  ((PWND_DLG)pwnd)->wParamEnd = wParam;
#endif

WORD FARPUBLIC DialogBox      ( VOID *, PLFN_WNDPROC );		/*OPTIONAL*/
PWND FARPUBLIC NextChild	( PVOID, PVOID);
PWND FARPUBLIC PrevChild	( PVOID, PVOID );

PWND FARPUBLIC GetNextDlgGroupItem ( PVOID, PVOID, BOOL );

// #define WM_DLGUSER  20

// ADM defines
BOOL FARPUBLIC CreateChildren ( PVOID, VOID *, WORD );		/*OPTIONAL*/
PWND FARPUBLIC WinLoadDlg     ( VOID *, PLFN_WNDPROC );		/*OPTIONAL*/
WORD FARPUBLIC WinProcessDlg  ( PVOID, PLFN );					/*OPTIONAL*/
PWND FARPUBLIC GetDlgItem     ( PVOID, WORD );					/*OPTIONAL*/



#define LB_FILE TRUE
#define LB_DIR  FALSE


PWND FARPUBLIC CreateDialog	( VOID *, PWND, PLFN_WNDPROC );		/*OPTIONAL*/

VOID FARPUBLIC WinDlgDirList	( PVOID, char *, WORD, WORD, WORD, BOOL );  /*OPTIONAL*/

VOID FARPUBLIC DrawDlg			( PVOID, DWORD);											  /*OPTIONAL*/

DWORD FARPUBLIC ADMDialogWndProc ( PVOID,WORD, WORD, DWORD );				  /*OPTIONAL*/
DWORD FARPUBLIC ADMMboxWndProc	( PVOID,WORD, WORD, DWORD );				  /*OPTIONAL*/

WORD FARPUBLIC MessageBox     ( VOID *, VOID *, VOID *, WORD );			  /*OPTIONAL*/
WORD FARPUBLIC MessageBoxAxAy ( VOID *, VOID *, VOID *, WORD, WORD, WORD ); /*OPTIONAL*/

PWND FARPUBLIC CreateMsgBtn ( char *,WORD,WORD,WORD,WORD,WORD,WORD,PVOID,WORD );


#ifdef WIN_BTN

VOID FARPUBLIC CheckRadioButton ( PVOID, WORD, WORD, WORD );				 /*OPTIONAL*/

#define CheckDlgRadioButton(hwnd,idFirstButton,idLastButton,idCheckButton) CheckRadioButton(hwnd,idFirstButton,idLastButton,idCheckButton)

#else

VOID FARPUBLIC CheckDlgRadioButton ( PVOID, WORD, WORD, WORD );				 /*OPTIONAL*/

#endif

#endif //ADM


// Control Procedure 
typedef WORD	(FARPUBLIC *PWFN_CTL)(WORD, char *, WORD, WORD, WORD, WORD);


// BLADE enhanced version.

#ifdef BLADE

#ifdef BROADSWORD

#ifdef FULL_EDIT

#ifdef BASED
	typedef struct _winwnded _based(pWndSeg)  WND_WINEDIT;
#else
	typedef struct _winwnded WND_WINEDIT;
#endif

typedef WND_WINEDIT *PWND_WINEDIT;


typedef struct _winwnded
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	PED ped;
	};

#define GetEditPed(pwnd) (((PWND_WINEDIT)pwnd)->ped)
#define SetEditPed(pwnd, ped) ( ((PWND_WINEDIT)pwnd)->ped = ped)

#endif

#endif


#ifdef BASED
	typedef struct _wndmle _based(pWndSeg) WND_MLE;
#else
	typedef struct _wndmle WND_MLE;
#endif

typedef WND_MLE *PWND_MLE;

typedef struct _wndmle
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;
#endif
	WORD	padding;
	WORD  pEF_Structure;
	};

#ifdef BASED
	typedef struct _wnddesktop _based(pWndSeg) WND_DESKTOP;
#else
	typedef struct _wnddesktop WND_DESKTOP;
#endif

typedef WND_DESKTOP *PWND_DESKTOP;

typedef struct _wnddesktop
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	BYTE  bFill;
	WORD  isaDesktop;
	};



#ifdef BASED
	typedef struct _wndgeneric _based(pWndSeg) WND_GEN;
#else
	typedef struct _wndgeneric WND_GEN;
#endif

typedef WND_GEN *PWND_GEN;

typedef struct _wndgeneric
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	WORD aclDialog;
 	char *szDialog;	
 	WORD cchDialog;			//	 6 bytes
	};



#ifdef BASED
	typedef struct _wndgenpic _based(pWndSeg) WND_GENPIC;
#else
	typedef struct _wndgeneric WND_GENPIC;
#endif

typedef WND_GENPIC *PWND_GENPIC;

typedef struct _wndgenpic
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	WORD aclDialog;
 	char *szDialog;	
 	WORD cchDialog;			//	 6 bytes
	PWFN_CTL pfnGenProc;
 	WORD wParam;				//	 6 bytes
	};

// General window stuff

// #define	PwfnCtlGeneral(pwnd)	(*((PWFN_CTL *) &pwnd->rgwExtra[cwExtraMin]))
#define	PwfnCtlGeneral(pwnd)	((PWND_GENPIC)pwnd)->pfnGenProc
#define	WParamGeneral(pwnd)	((PWND_GENPIC)pwnd)->wParam


#define SetAccelerator(pwnd, Position, szText) \
	 ((PWND_GEN)(pwnd))->aclDialog = (((BYTE)((Position) - 1)) << 8) + \
					    *((unsigned char *)(szText) + ((Position) - 1))

#ifdef BASED
	typedef struct _wndgroup _based(pWndSeg) WND_GROUP;
#else
	typedef struct _wndgroup WND_GROUP;
#endif

typedef WND_GROUP *PWND_GROUP;

typedef struct _wndgroup
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;
#endif
	WORD aclDialog;
 	char *szDialog;
	PWND pwndAccel;	
	};


#ifdef BASED
	typedef struct _wndstatic _based(pWndSeg) WND_STATIC;
#else
	typedef struct _wndstatic WND_STATIC;
#endif

typedef WND_STATIC *PWND_STATIC;

typedef struct _wndstatic
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;						// 31 bytes
#endif
	WORD aclDialog;
 	char *szDialog;
	PWND pwndAccel;	
	};

#ifdef BASED
	typedef struct _dlgwnd _based(pWndSeg)  WND_DLG;
#else
	typedef struct _dlgwnd WND_DLG;
#endif

typedef WND_DLG *PWND_DLG;

typedef struct _dlgwnd
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	WORD aclDialog;
 	char *szDialog;	
 	WORD wParamEnd;
	VOID *pmbsDialog;
	PLFN pfnUserProc;			// 12 bytes
 	WORD hidHelp;
	};

// so that rspAppIdle can determine where the current msg box dialog is 
extern PWND_DLG	pwndDlg;		// Again, app should never use 


typedef struct _drop DROP;
typedef DROP *PDROP;

typedef struct _Drop {
		WORD Dummy;
		WORD wDropFlags;
		PWND pwndDropListBox;
		PWND pwndDropButton;
		PWND pwndDropEdit;
		PLFN_WNDPROC pfnDropListBoxProc;
		PLFN_WNDPROC pfnDropEditProc;
	};


#ifdef BASED
	typedef struct _wnddrop _based(pWndSeg)  WND_DROP;
#else
	typedef struct _wnddrop WND_DROP;
#endif

typedef WND_DROP *PWND_DROP;

typedef struct _wnddrop	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	WORD wDropState;
	WORD wDropFlags;			// TRUE ( 1 ) = Combo, FALSE ( 0 ) = Plain
	PWND pwndDropListBox;
	PWND pwndDropButton;
	PWND pwndDropEdit;
	PLFN_WNDPROC pfnDropListBoxProc;
	PLFN_WNDPROC pfnDropEditProc;		// 20 bytes
	};

#define PwndDropListBox(pwnd) ( (PWND_LIST)( (PWND_DROP)pwnd )->pwndDropListBox ) 
#define PwndDropButton(pwnd) 	( (PWND_BTN)( (PWND_DROP)pwnd )->pwndDropButton )
#define PwndDropEdit(pwnd)		( (PWND_EDIT)( (PWND_DROP)pwnd )->pwndDropEdit)
#define PfnDropListBoxProc(pwnd) ( ( (PWND_DROP)pwnd )->pfnDropListBoxProc)
#define PfnDropEditProc(pwnd)		( ( (PWND_DROP)pwnd )->pfnDropEditProc)


#ifdef BASED
	typedef struct _wnddroplist _based(pWndSeg)  WND_DROP_LIST;
#else
	typedef struct _wnddroplist WND_DROP_LIST;
#endif

typedef WND_DROP_LIST *PWND_DROP_LIST;

typedef struct _wnddroplist	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	PWFN_CTL pfnLBFtn;
	WORD wParam;
	WORD wUnknown;
	WORD iszTopLb; 			// first item in Display 
	WORD cszLb;					// # of strings in list in list 
	WORD iszCurLb;				// currently selected item 
	WORD hmemMpiszoffLb;		// array of offsets in string buffer
	WORD hmemGpszLb;			// string buffer pool 
	WORD offLb; 				// next string buffer pointer 
	WORD offMaxLb; 			// size of string buffer 
	WORD iszMacLb; 			// max isz before index buf is grown
	WORD fSelectedLb;			// do we have a selection ? 
	WORD isaColor;				// colour of the listbox 
	WORD isaHiliteColor;		// colour of the listbox hilite
	WORD ctickRepLb;			// scrolling rate 
	WORD drxItemLb;			// width of a single item (add 1 for space) 
	WORD citemWidthLb;		// max # of items wide 	  // 36 bytes
	PWND_DROP pwndDrop;
	};



#ifdef BASED
	typedef struct _wnddlgdir _based(pWndSeg)  WND_DLGDIR;
#else
	typedef struct _wnddlgdir WND_DLGDIR;
#endif

typedef WND_DLGDIR *PWND_DLGDIR;

typedef struct _wnddlgdir	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	PWND	pwndDirDrivesBox;
	PWND	pwndFilesBox;
	PWND	pwndDirEdit;
	PWND  pwndDirStatic;
	};


#define PwndDlgDirEdit(pwnd)	( ( (PWND_DLGDIR)pwnd )->pwndDirEdit)
#define PwndDirStatic(pwnd)	( ( (PWND_DLGDIR)pwnd )->pwndDirStatic)


typedef struct _Scroll SCROLL;
typedef SCROLL *PSCROLL;

typedef struct _Scroll {
	WORD ctickRepSb;	 	// # of ticks to repeat
	short ptCurSb; 			// current position on scroll line
	short ptMinSb; 			// minimum position on scroll line
	short ptMaxSb; 			// end position on scroll line 
	BYTE ptElevatorSb;		// elevator position
	BYTE dummy; 				// word alignment
	};


#ifdef BASED
	typedef struct _wndscroll _based(pWndSeg)  WND_SCROLL;
#else
	typedef struct _wndscroll WND_SCROLL;
#endif

typedef WND_SCROLL *PWND_SCROLL;

typedef struct _wndscroll
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;			
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	WORD ctickRepSb;	 		// # of ticks to repeat
	short ptCurSb; 				// current position on scroll line
	short ptMinSb; 				// minimum position on scroll line
	short ptMaxSb; 				// end position on scroll line 
	short ptElevatorSb;		// elevator position (lower byte)	// 10 bytes
	};

typedef struct _List LISTBOX;
typedef LISTBOX *PLISTBOX;


typedef struct _List {
	PWFN_CTL pfnLBFtn;
	WORD wParam;
	WORD wUnknown;
	WORD iszTopLb; 			// first item in Display 
	WORD cszLb;					// # of strings in list in list 
	WORD iszCurLb;				// currently selected item 
	WORD hmemMpiszoffLb;		// array of offsets in string buffer
	WORD hmemGpszLb;			// string buffer pool 
	WORD offLb; 				// next string buffer pointer 
	WORD offMaxLb; 			// size of string buffer 
	WORD iszMacLb;				// max isz before index buf is grown
	WORD fSelectedLb;			// do we have a selection ? 
	WORD isaColor;				//	colour of the listbox 
	WORD isaHiliteColor;		// colour of the listbox hilite
	WORD ctickRepLb;			// scrolling rate 
	WORD drxItemLb;			// width of a single item (add 1 for space) 
	WORD citemWidthLb;		// max # of items wide 
	};


#ifdef BASED
	typedef struct _wndlist _based(pWndSeg)  WND_LIST;
#else
	typedef struct _wndlist WND_LIST;
#endif

typedef WND_LIST *PWND_LIST;

typedef struct _wndlist	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	PWFN_CTL pfnLBFtn;
	WORD wParam;
	WORD wUnknown;
	WORD iszTopLb; 			// first item in Display 
	WORD cszLb;					// # of strings in list in list 
	WORD iszCurLb;				// currently selected item 
	WORD hmemMpiszoffLb;		// array of offsets in string buffer
	WORD hmemGpszLb;			// string buffer pool 
	WORD offLb; 				// next string buffer pointer 
	WORD offMaxLb; 			// size of string buffer 
	WORD iszMacLb; 			// max isz before index buf is grown
	WORD fSelectedLb;			// do we have a selection ? 
	WORD isaColor;				// colour of the listbox 
	WORD isaHiliteColor;		// colour of the listbox hilite
	WORD ctickRepLb;			// scrolling rate 
	WORD drxItemLb;			// width of a single item (add 1 for space) 
	WORD citemWidthLb;		// max # of items wide 	  // 36 bytes
	};


#define	PwfnCtlLb(pwnd)	(((PWND_LIST)pwnd)->pfnLBFtn)
#define	WParamLb(pwnd)		(((PWND_LIST)pwnd)->wParam)

// special listbox window specific isa's 

#define IsaListbox(pwnd)			(((PWND_LIST)pwnd)->isaColor)
#define IsaHiliteListbox(pwnd)	(((PWND_LIST)pwnd)->isaHiliteColor)

typedef struct _Edit EDIT;
typedef EDIT *PEDIT;

typedef struct _Edit {
	WORD aclDialog;
 	char *szDialog;	
 	WORD cchDialog;
	WORD isaEb;					// color 
	WORD isaSelEb;				// selected color 
	BYTE chFillDialog;			// fill char for trailing spaces 
	WORD ichMacEb;				// last character in edit buffer 
	WORD ichLeftEb;				// leftmost character displayed 
	WORD ichCursorEb;			// current cursor position, to the left of  insertion point 
	WORD ichSelEb;				// start of selection 
	WORD fNoBracketEb;			// don't show brackets ?? 
	WORD wEb;						// random flags 
	WORD cchMaxEb;				// for fixed length edit items 
	WORD isaDisabledEb;			// disabled color 
	char *szWildCardEb;			// auxilary edit field 
	BOOL fCWAllocated;
	BOOL Dummy;
};

#ifdef BASED
	typedef struct _wnded _based(pWndSeg)  WND_EDIT;
#else
	typedef struct _wnded WND_EDIT;
#endif

typedef WND_EDIT *PWND_EDIT;

typedef struct _wnded
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	WORD aclDialog;
 	char *szDialog;	
 	WORD cchDialog;
	WORD isaEb;					// color 
	WORD isaSelEb;				// selected color 
	BYTE chFillDialog;		// fill char for trailing spaces 
	WORD ichMacEb;				// last character in edit buffer 
	WORD ichLeftEb;			// leftmost character displayed 
	WORD ichCursorEb;			// current cursor position, to the left of  insertion point 
	WORD ichSelEb;				// start of selection 
	WORD fNoBracketEb;		// don't show brackets ?? 
	WORD wEb;					// random flags 
	WORD cchMaxEb;				// for fixed length edit items 
	WORD isaDisabledEb;		// disabled color 
	char *szWildCardEb;		// auxilary edit field 
	BOOL fCWAllocated;
	BOOL Dummy;					// 34 bytes
	};


#define ShowEditBracket(pwnd, fNoBracket ) (((PWND_EDIT)pwnd)->fNoBracketEb = !(fNoBracket)	)
#define SetEditFillCharacter(pwnd, ch)		 (((PWND_EDIT)pwnd)->chFillDialog = (BYTE)(ch) )
#define SetEditDisabledIsa(pwnd, isa)		 (((PWND_EDIT)pwnd)->isaDisabledEb = (isa) )
#define SetEditSelectedIsa(pwnd, isa)		 (((PWND_EDIT)pwnd)->isaSelEb = (isa) )
#define SetEditIsa(pwnd, isa)					 (((PWND_EDIT)pwnd)->isaEb = (isa) )

// special edit window specific isa's 
#define IsaEdit(pwnd)			(((PWND_EDIT)pwnd)->isaEb)
#define IsaSelEdit(pwnd)		(((PWND_EDIT)pwnd)->isaSelEb )
#define IsaDisabledEdit(pwnd)	(((PWND_EDIT)pwnd)->isaDisabledEb)

#ifdef BASED
	typedef struct _btnwnd  _based(pWndSeg) WND_BTN;
#else
	typedef struct _btnwnd WND_BTN;
#endif

typedef WND_BTN *PWND_BTN;

typedef struct _btnwnd
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	WORD aclDialog;
 	char *szDialog;	
 	BYTE cchDialog;
	BYTE wButton;
#ifndef WIN_BTN
	PWND_BTN pwndButtonNext;		//	 8 bytes
#endif
	};


#ifndef WIN_BTN
// walking the list of radio buttons 
#define	PwndButtonNext(pwnd) ((PWND_BTN) (pwnd)->pwndButtonNext)

// is it a (radio) button? 
#define	FPwndIsButton(pwnd) (((pwnd)->style & WS_TYPE) == WS_BUTTON)
#define	FButtonIsRadio(pwnd) (((pwnd)->style & WS_SUBSTYLE) == BS_RADIOBUTTON)

// bits :
//  0..1 '=> bst (button state)
//  2 => fButtonDown
//  3 => first in group
//
// button states 


#ifdef BLADE

#define bstOff		(BYTE)0
#define bstOn		(BYTE)1
#define bstGreyed	(BYTE)2 
#define bstMax		(BYTE)3


// Macros for bit accesses 


#define BstOfWnd(pwnd) ((pwnd)->wButton & 3)

#define SetWndBst(pwnd, bst) (pwnd)->wButton = ((pwnd)->wButton & ~((BYTE)3)) | (bst) 

#define FButtonDown(pwnd) ((pwnd)->wButton & 4)

#define SetFButtonDown(pwnd, fDown) \
	{if (fDown) (pwnd)->wButton |= (BYTE)4; \
	  else (pwnd)->wButton &= ~(BYTE)4;}

#define FFirstButton(pwnd) ((pwnd)->wButton & 8)

#define SetFFirstButton(pwnd) (pwnd)->wButton = ((pwnd)->wButton |= (BYTE)8)

#define SetNextGroupButton(pwnd, pwndNext )  (pwnd)->pwndButtonNext =(pwndNext)


#else

#define bstOff		0
#define bstOn		1
#define bstGreyed	2 
#define bstMax		3


// Macros for bit accesses 


#define BstOfWnd(pwnd) ((pwnd)->wButton & 3)

#define SetWndBst(pwnd, bst) (pwnd)->wButton = ((pwnd)->wButton & ~(3)) | (bst) 

#define FButtonDown(pwnd) ((pwnd)->wButton & 4)

#define SetFButtonDown(pwnd, fDown) \
	{if (fDown) (pwnd)->wButton |= 4; \
	  else (pwnd)->wButton &= ~4;}

#define FFirstButton(pwnd) ((pwnd)->wButton & 8)

#define SetFFirstButton(pwnd) (pwnd)->wButton = ((pwnd)->wButton |= 8)

#define SetNextGroupButton(pwnd, pwndNext )  (pwnd)->pwndButtonNext =(pwndNext)

#endif //BLADE


#endif //WIN_BTN


#ifdef BASED
	typedef struct _framewnd _based(pWndSeg)  WND_FRAME;
#else
	typedef struct _framewnd WND_FRAME;
#endif

typedef WND_FRAME *PWND_FRAME;

typedef struct _framewnd
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;				// 31 bytes
#endif
	BOOL  fWinActive;
	char *szFrameText;
	VOID **hFrameMenu;
	WORD 	 axyLastPos;
	WORD 	 rxyLastPos;
	BOOL	 fZoomFrame;
	ARC	 arcMenuArc;				//	16 bytes
	WORD	 wFrameHeight;
	PLFN_WNDPROC pfnClientWndProc;
	};

#else	 // Non-Blade stuff follows

typedef PWND PWND_MLE;
typedef PWND PWND_SCROLL;
typedef PWND PWND_EDIT;
typedef PWND PWND_BTN;
typedef PWND PWND_DLG;
typedef PWND PWND_GEN;
typedef PWND PWND_STATIC;
typedef PWND PWND_LIST;
typedef PWND PWND_DROP_LIST;
typedef PWND PWND_DROP;
typedef PWND PWND_FRAME;
typedef PWND PWND_DESKTOP;
typedef PWND PWND_GROUP;

#define	GetWindowWord(pwnd, iw) 	((pwnd)->rgwExtra[(iw)])
#define	SetWindowWord(pwnd, iw, w) {(pwnd)->rgwExtra[(iw)] = (w);}


// special edit window specific isa's 

#define IsaEdit(pwnd)			((pwnd)->rgwExtra[3])
#define IsaSelEdit(pwnd)		((pwnd)->rgwExtra[4])
#define IsaDisabledEdit(pwnd)	((pwnd)->rgwExtra[13])


// Common portion of all dialog windows 

#define	cwExtraMin	1		// at least 1 field for all items 
									// not used for dialog box 

#define	aclDialog	rgwExtra[0]	// dialog accelerator 

// Text info for : edit, static and button controls 

#define cwExtraText	(cwExtraMin+2)	// 2 more for text controls 
#define szDialog	rgwExtra[1]			// also Dialog Box caption 
#define cchDialog	rgwExtra[2]			// edit, static & buttons 

// flag indicating whether EndDialog has been
// called.  Used to prevent multiple calls
// to PostQuitMessage 

#define wParamEnd		rgwExtra[2]


// sizes of rgwExtra for the various controls 

#define cwExtraDialog	(cwExtraMin+2)		// szDialog + wParamEnd 

#define cwExtraSdmDlg	(cwExtraDialog+((sizeof(SDS)+1)/2))	// ... + sds 

#define cwExtraMsgBox	(cwExtraDialog+1) // ... + pmbs 
#define cwExtraStatic	(cwExtraText)		// simple text 
#define cwExtraButton	(cwExtraText+2)	// text + button state + next radio
#define cwExtraGroup    (cwExtraText+2)	// text 


#define cwExtraEdit		(cwExtraText+11)	// see sedit.h for details 
#define cwExtraEditAux	(cwExtraEdit+1)	
#define cwExtraGeneral	(cwExtraMin+3)		// see general.h for details 

#ifndef LISTBOX_HORIZ
	#define cwExtraListBox	(cwExtraMin+15)	// see _listbox.h for details 
#else
	#define cwExtraListBox	(cwExtraMin+17)	// see _listbox.h for details 
#endif


#define cwExtraDropDown		(cwExtraMin+9)		// 10
#define cwExtraDropHolder 	(cwExtraMin+1)		// 2
#define cwExtraDropButton 	(cwExtraMin)		// 1


#define wButton 	rgwExtra[cwExtraText]

// flag word for button control 

#define	pwndButtonNext	rgwExtra[cwExtraText+1]	 // next radio button 

//#if cwExtraButton != cwExtraText+2
//.....
//#endif

// walking the list of radio buttons 
#define	PwndButtonNext(pwnd) ((PWND_BTN) (pwnd)->pwndButtonNext)

// is it a (radio) button? 
#define	FPwndIsButton(pwnd) (((pwnd)->style & WS_TYPE) == WS_BUTTON)
#define	FButtonIsRadio(pwnd) (((pwnd)->style & WS_SUBSTYLE) == BS_RADIOBUTTON)

// bits :
//  0..1 '=> bst (button state)
//  2 => fButtonDown
//  3 => first in group
//
// button states 



#define bstOff		0
#define bstOn		1
#define bstGreyed	2 
#define bstMax		3


// Macros for bit accesses 


#define BstOfWnd(pwnd) ((pwnd)->wButton & 3)

#define SetWndBst(pwnd, bst) (pwnd)->wButton = ((pwnd)->wButton & ~(3)) | (bst) 

#define FButtonDown(pwnd) ((pwnd)->wButton & 4)

#define SetFButtonDown(pwnd, fDown) \
	{if (fDown) (pwnd)->wButton |= 4; \
	  else (pwnd)->wButton &= ~4;}

#define FFirstButton(pwnd) ((pwnd)->wButton & 8)

#define SetFFirstButton(pwnd) (pwnd)->wButton = ((pwnd)->wButton |= 8)

#define SetNextGroupButton(pwnd, pwndNext )  (pwnd)->pwndButtonNext =(pwndNext)



#define cwExtraFrame (cwExtraText + 4)	

#define fWinActive   rgwExtra[1]
#define szFrameText  rgwExtra[2]
#define hFrameMenu   rgwExtra[3]

#define axyLastPos	rgwExtra[4]
#define rxyLastPos	rgwExtra[5]
#define fZoomFrame	rgwExtra[6]
#define arcMenuArc   rgwExtra[7]

// General window stuff

#define	PwfnCtlGeneral(pwnd)	(*((PWFN_CTL *) &pwnd->rgwExtra[cwExtraMin]))
#define	WParamGeneral(pwnd)	(pwnd->rgwExtra[cwExtraMin+2])

//#if cwExtraGeneral != cwExtraMin+3
//.....
//#endif

// General window stuff


//listbox stuff

// customization 

// extra word usage 

// 0,1,2 are listbox function and wParam (for on-demand) 

#define iszTopLb 	rgwExtra[cwExtraMin+3]			// first item in Display 
#define cszLb		rgwExtra[cwExtraMin+4]			// # of strings in list in list 
#define iszCurLb	rgwExtra[cwExtraMin+5]			// currently selected item 
#define hmemMpiszoffLb	rgwExtra[cwExtraMin+6]	// array of offsets in string buffer
#define hmemGpszLb	rgwExtra[cwExtraMin+7]		// string buffer pool 
#define offLb 		rgwExtra[cwExtraMin+8]			// next string buffer pointer 
#define offMaxLb 	rgwExtra[cwExtraMin+9]			// size of string buffer 
#define iszMacLb 	rgwExtra[cwExtraMin+10]			// max isz before index buf is grown
#define fSelectedLb	rgwExtra[cwExtraMin+11]		// do we have a selection ? 
#define isaColor	rgwExtra[cwExtraMin+12]			// colour of the listbox 
#define isaHiliteColor	rgwExtra[cwExtraMin+13]	// colour of the listbox hilite
#define ctickRepLb	rgwExtra[cwExtraMin+14]		// scrolling rate 

#ifndef LISTBOX_HORIZ
	#define	cwExtraNeeded	(cwExtraMin+15)
#else
	// Horizontal scrolling extra info 

	#define	drxItemLb	rgwExtra[cwExtraMin+15]		// width of a single item (add 1 for space) 
	#define	citemWidthLb	rgwExtra[cwExtraMin+16]	// max # of items wide 
	#define	cwExtraNeeded	(cwExtraMin+17)
#endif

//#if cwExtraListBox != cwExtraNeeded
//.....
//#endif

#define	PwfnCtlLb(pwnd)	(*((PWFN_CTL *) &pwnd->rgwExtra[cwExtraMin]))
#define	WParamLb(pwnd)		(pwnd->rgwExtra[cwExtraMin+2])


// special listbox window specific isa's 

#define IsaListbox(pwnd)			((pwnd)->rgwExtra[13])
#define IsaHiliteListbox(pwnd)	((pwnd)->rgwExtra[14])

//listbox stuff

//Scrollbar defs

#define cwExtraScroll	5	// size of rgwExtra for scroll windows 

// scroll bar definitions 

#define ctickRepSb	rgwExtra[0]	// # of ticks to repeat 
#define ptCurSb		rgwExtra[1]	// current position on scroll line 
#define ptMinSb		rgwExtra[2]	// minimum position on scroll line 
#define ptMaxSb		rgwExtra[3]	// end position on scroll line 
#define ptElevatorSb	rgwExtra[4]	// elevator position (lower byte) 

//Scrollbar defs



//Editbox defs

// extra word usage (filled by SDM) 

#define	isaEb		rgwExtra[cwExtraText+0]			// color 
#define	isaSelEb	rgwExtra[cwExtraText+1]			// selected color 
#define chFillDialog	rgwExtra[cwExtraText+2]		// fill char for trailing spaces 
#define ichMacEb	rgwExtra[cwExtraText+3]			// last character in edit buffer 
#define ichLeftEb	rgwExtra[cwExtraText+4]			// leftmost character displayed 
#define ichCursorEb	rgwExtra[cwExtraText+5]		// current cursor position, to the left of
															   // insertion point 
#define ichSelEb	rgwExtra[cwExtraText+6]			// start of selection 
#define	fNoBracketEb	rgwExtra[cwExtraText+7]	// don't show brackets ?? 
#define wEb		rgwExtra[cwExtraText+8]				// random flags 
#define cchMaxEb	rgwExtra[cwExtraText+9]			// for fixed length edit items 
#define isaDisabledEb	rgwExtra[cwExtraText+10]// disabled color 
#define szWildCardEb	rgwExtra[cwExtraText+11]	// auxilary edit field 

//#if cwExtraEdit != cwExtraText+11
//.....
//#endif

//#if cwExtraEditAux != cwExtraText+12
//.....
//#endif

//Editbox defs


// Message box defs

// this structure is defined only so that C will allocate enough extra
// words in the msg box window structures put on the stack 

typedef struct _wndm
	{
	WND	wnd;
	WORD 	rgwExtraPlus[cwExtraMsgBox-1];
	} WNDM;

// message box state 
#define pmbsDialog		rgwExtra[cwExtraDialog]

// Message box defs


// Dropdown defs

// dropdown rgwExtra aliases 
#define wDropFlags      rgwExtra[cwExtraMin]
#define pwndDropListBox rgwExtra[cwExtraMin+1]
#define pwndDropButton  rgwExtra[cwExtraMin+2]
#define pwndDropEdit    rgwExtra[cwExtraMin+3]
#define pwndDropHolder  rgwExtra[cwExtraMin+4]
#define pfnDropListBoxProc	rgwExtra[cwExtraMin+5]	// actually two words 
#define pfnDropEditProc	rgwExtra[cwExtraMin+7]		// actually two words 


#define PwndDropListBox(pwnd)		(*(PWND*)&((pwnd)->pwndDropListBox))
#define PwndDropButton(pwnd)		(*(PWND*)&((pwnd)->pwndDropButton))
#define PwndDropEdit(pwnd)			(*(PWND*)&((pwnd)->pwndDropEdit))
#define PwndDropHolder(pwnd)		(*(PWND*)&((pwnd)->pwndDropHolder))
#define PfnDropListBoxProc(pwnd) (*(PLFN_WNDPROC*)&((pwnd)->pfnDropListBoxProc))
#define PfnDropEditProc(pwnd)		(*(PLFN_WNDPROC*)&((pwnd)->pfnDropEditProc))

// dropdown holding window rgwExtra aliases and macros 

#define pwndHolderDrop rgwExtra[cwExtraMin]

#define PwndHolderDrop(pwnd) (*(PWND*)&((pwnd)->pwndHolderDrop))

// Dropdown defs

extern PWND_DLG	pwndDlg;		// Again, app should never use 

#endif //	BLADE

extern PWND_DESKTOP PASCAL pwndDesktop;


typedef PWND HWND; 


#ifdef BLADE

typedef PWND HDC; 

#define HMENU void **

typedef struct _rect
	{
	BYTE	left;
	BYTE	top;
	BYTE	right;
	BYTE  bottom;
	}RECT;

typedef RECT *LPRECT;

typedef RRC PAINTSTRUCT;

typedef WORD HBRUSH;

#endif

#ifdef BROADSWORD

#include <winapi.h>

#endif //BROADSWORD

// #include "wndstruc.h"

#define HEAD	0
#define TAIL	1


#ifndef	NOPROCS

BOOL	FARPUBLIC InitDesktop	( VOID );
DWORD FARPUBLIC DesktopWndProc(PVOID, WORD, WORD, DWORD);

VOID FARPUBLIC RemoveChild		(PVOID);
VOID FARPUBLIC EnableWindow	(PVOID, BOOL);
VOID FARPUBLIC SetWindowStyle	(PVOID, WORD);
VOID FARPUBLIC SetWindowSize	(PVOID, BYTE, BYTE);
VOID FARPUBLIC DrawWindow		(PVOID);
VOID FARPUBLIC TextOut			(PVOID, RX, RY, char *, short, WORD);
VOID FARPUBLIC lpTextOut(PVOID, RX, RY, char far *, short, WORD); /*OPTIONAL*/
VOID FARPUBLIC DrawBorder2			(PVOID, BOX *, WORD, WORD, char *);
VOID FARPUBLIC DrawBorderAlign	(PVOID, BOX *, WORD, WORD, char *, BOOL);
VOID FARPUBLIC CharOut				(PVOID, RX, RY, ACHAR, WORD);
VOID FARPUBLIC CharOutBorder		(PVOID, RX, RY, ACHAR, WORD);
VOID FARPUBLIC BltRrc				(PVOID, RX, RY, BYTE, BYTE, RX, RY);
VOID FARPUBLIC BltRrcTop			(PVOID, RX, RY, BYTE, BYTE, RX, RY);	/*OPTIONAL*/


VOID FARPUBLIC EndPaint				(PVOID, VOID FAR *);
VOID FARPUBLIC DrawBox				(PVOID, NPRRC, BOX *, WORD);
VOID FARPUBLIC SaveRrc				(PVOID, NPRRC, BYTE FAR *);
VOID FARPUBLIC RestoreRrc			(PVOID, NPRRC, BYTE FAR *);
VOID FARPUBLIC EnableCursor		(PVOID, BOOL);
VOID FARPUBLIC MoveCursor			(PVOID, RX, RY);
VOID FARPUBLIC MoveWindow			(PVOID, AX, AY);
BOOL FARPUBLIC IntersectRect		(NPRRC, NPRRC, NPRRC);
VOID FARPUBLIC UnionRect			(NPRRC, NPRRC, NPRRC);
BOOL FARPUBLIC IsRectEmpty			(NPRRC);
VOID FARPUBLIC SetRect				(NPRRC, RX, RY, RX, RY);
BOOL FARPUBLIC PtInRect				(NPRRC, RX, RY);
WORD FARPUBLIC CwSizeRrc			(NPRRC);
VOID FARPUBLIC ShadowArc			(NPARC);
VOID FARPUBLIC EnableOverlap		(BOOL, VOID *, WORD); 
VOID FARPUBLIC ReplaceChild		(PVOID, PVOID);					/*OPTIONAL*/
VOID FARPUBLIC DrawOverlapShadow(PVOID);								/*OPTIONAL*/
VOID FARPUBLIC RedrawDamagedRegions	(void);						/*OPTIONAL*/
BOOL FARPUBLIC FMoveSizeWithKeyboard	(PVOID, BOOL);			 	/*OPTIONAL*/
/*	Listbox routines */
DWORD		FARPUBLIC ListBoxWndProc		(PVOID, WORD, WORD, DWORD);   /*OPTIONAL*/
VOID		FARPUBLIC InitListBox			(PVOID, PWFN);							/*OPTIONAL*/
VOID		FARPUBLIC InitListBoxOriented	(PVOID, PWFN, WORD *, WORD *);	/*OPTIONAL*/
VOID		FARPUBLIC GetListBoxOrientation(PVOID, WORD *, WORD *);			/*OPTIONAL*/
VOID		FARPUBLIC SetListBoxOrientation(PVOID, WORD *, WORD *);

/*	Dropdown Listbox routines */
DWORD		FARPUBLIC DropDownWndProc		(PVOID, WORD, WORD, DWORD);		/*OPTIONAL*/
DWORD		FARPUBLIC DropHolderWndProc	(PVOID, WORD, WORD, DWORD);		/*OPTIONAL*/
DWORD		FARPUBLIC DropListBoxWndProc	(PVOID, WORD, WORD, DWORD);		/*OPTIONAL*/
DWORD		FARPUBLIC DropEditWndProc		(PVOID, WORD, WORD, DWORD);		/*OPTIONAL*/
DWORD		FARPUBLIC DropButtonWndProc	(PVOID, WORD, WORD, DWORD);		/*OPTIONAL*/
VOID		FARPUBLIC AddDropWindow			(PVOID, PVOID, PVOID, PVOID, PVOID, PVOID, BOOL); /*OPTIONAL*/
VOID		FARPUBLIC RemoveDropWindow		(PVOID);									/*OPTIONAL*/

DWORD		FARPUBLIC ButtonWndProc			(PVOID, WORD, WORD, DWORD);   /*OPTIONAL*/
DWORD	   FARPUBLIC StaticWndProc			(PVOID, WORD, WORD, DWORD);   /*OPTIONAL*/

DWORD		FARPUBLIC ScrollBarWndProc(PVOID, WORD, WORD, DWORD);	    /*OPTIONAL*/
DWORD  	FARPUBLIC InternalEditWndProc(PVOID, WORD, WORD, DWORD);  /*OPTIONAL*/

BOOL FARPUBLIC RectEqual( NPRRC, NPRRC );  /*OPTIONAL*/
VOID FARPUBLIC EnumListBoxEntries ( PVOID, PWFN_ENUM );   /*OPTIONAL*/
VOID FARPUBLIC DrawTextJustified ( PVOID, char *, WORD, WORD, NPRRC );   /*OPTIONAL*/
VOID FARPUBLIC SetSeg ( VOID );	/*OPTIONAL*/
VOID FARPUBLIC DrawBoxText ( VOID *, AX, AX, AX );   /*OPTIONAL*/
VOID FARPUBLIC DrawBorderAlign3D ( PVOID, WORD, WORD, char *, BOOL, BOOL, WORD, WORD );	/*OPTIONAL*/
PWND FARPUBLIC TreeToTop ( PVOID );	  /*OPTIONAL*/

#ifdef BLADE

PWND 	FARPUBLIC CreateWindow ( WORD, char *,  WORD, WORD, WORD,WORD,WORD,WORD,	PVOID, HMENU, LPSTR, WORD );  /*OPTIONAL*/
BOOL 	FARPUBLIC DestroyWindow ( PVOID );  /*OPTIONAL*/
BOOL 	FARPUBLIC RegisterWindows( VOID );  /*OPTIONAL*/
DWORD	FARPUBLIC FrameWndProc(PVOID, WORD, WORD, DWORD);   /*OPTIONAL*/
PWND 	FARPUBLIC WindowFromID ( PVOID,WORD );  /*OPTIONAL*/
DWORD	FARPUBLIC DefDlgProc (PVOID, WORD, WORD, DWORD);  /*OPTIONAL*/
VOID	FARPUBLIC SiblingToTop		(PVOID, BOOL);          /*OPTIONAL*/	
VOID	FARPUBLIC DirtyShadow ( PVOID, ARC);
DWORD FARPUBLIC DlgDirWndProc ( PVOID, WORD, WORD, DWORD ); /*OPTIONAL*/
BOOL  FARPUBLIC ShowWindow ( PVOID, WORD, BOOL ); /*OPTIONAL*/
VOID 	FARPUBLIC SetWindowText ( PVOID, char * );  /*OPTIONAL*/
WORD 	FARPUBLIC GetWindowText ( PVOID, char *, WORD );  /*OPTIONAL*/
WORD	FARPUBLIC GetWindowTextLength ( PVOID );  /*OPTIONAL*/
DWORD	FARPUBLIC GroupWndProc(PVOID, WORD, WORD, DWORD);  /*OPTIONAL*/
PWND	FARPUBLIC InternalWindowFromID ( PVOID, WORD );  /*OPTIONAL*/
VOID	FARPUBLIC AddAChild(PVOID, PVOID, WORD);		/*OPTIONAL*/

LONG 	FAR PASCAL DefWindowProc ( PVOID,WORD,WORD,DWORD );  /*OPTIONAL*/


#ifndef BROADSWORD //BLADE and NOT BROADSWORD def's.

/**** BLADE and NOT BROADSWORD def's.	****************/

WORD FARPUBLIC GetWindowWord ( PVOID, WORD );  /*OPTIONAL*/
WORD FARPUBLIC SetWindowWord ( PVOID, WORD, WORD );  /*OPTIONAL*/
BOOL FARPUBLIC RegisterClass ( WORD, WORD, WORD, WORD, WORD, PLFN_WNDPROC );   /*OPTIONAL*/
BOOL FARPUBLIC UnregisterClass ( WORD, HANDLE );   /*OPTIONAL*/
PWNDCLASS FARPUBLIC FindClass	( WORD );   /*OPTIONAL*/

#ifndef DATA_HANDLE
	PWND FARPUBLIC CreateDlgDirCombo ( PVOID, PVOID, PVOID, PVOID, PVOID, char * );/*OPTIONAL*/
#else
	PWND FARPUBLIC CreateDlgDirCombo ( PVOID, PVOID, PVOID, PVOID, PVOID, WORD );  /*OPTIONAL*/
#endif

#endif

#else  // Non-Blade def's.

VOID	FARPUBLIC AddChildHead		(PVOID, PVOID);		/*OPTIONAL*/
VOID	FARPUBLIC AddChildTail		(PVOID, PVOID);		/*OPTIONAL*/

#endif //Non-Blade def's



#ifndef BROADSWORD

VOID  FARPUBLIC FRrcFromArc		( PVOID, NPARC, NPRRC );
VOID	FARPUBLIC WindowToTop		(PVOID);            	/*OPTIONAL*/	
PWND  FARPUBLIC PwndGetTopWindow	(PVOID);					/*OPTIONAL*/
BOOL	FARPUBLIC FIsTopWindow		(PVOID);					/*OPTIONAL*/
VOID	FARPUBLIC GetClientRrc		(PVOID, RRC *);
VOID	FARPUBLIC FillRrc				(PVOID, NPRRC, ACHAR, WORD);
VOID	FARPUBLIC InvalidateRrc		(PVOID,NPRRC);						/*OPTIONAL*/
VOID	FARPUBLIC MoveSizeOverlap	(PVOID, AX, AY, BYTE, BYTE);	/*OPTIONAL*/
VOID	FARPUBLIC BeginPaint			(PVOID, VOID FAR *);

#else	// BROADSWORD exclusive def's.

PWND FARPUBLIC BeginPaint			(PVOID, VOID FAR *);
HWND FARPUBLIC CreateDlgDirCombo ( PVOID, PVOID, PVOID, PVOID, PVOID, char * );  /*OPTIONAL*/
BOOL FARPUBLIC RegisterClass ( LPWNDCLASS ); /*OPTIONAL*/
BOOL FARPUBLIC UnregisterClass ( WORD, HANDLE ); /*OPTIONAL*/

PCLS FARPUBLIC FindClass	( WORD ); /*OPTIONAL*/

WORD FARPUBLIC GetWindowWord ( PVOID, int ); /*OPTIONAL*/
WORD FARPUBLIC SetWindowWord ( PVOID, int, WORD );			 /*OPTIONAL*/

LONG FARPUBLIC GetWindowLong ( PVOID, int ); /*OPTIONAL*/
LONG FARPUBLIC SetWindowLong ( PVOID, int, LONG ); /*OPTIONAL*/

WORD FARPUBLIC GetClassWord ( PVOID, int ); /*OPTIONAL*/
WORD FARPUBLIC SetClassWord ( PVOID, int, WORD ); /*OPTIONAL*/

LONG FARPUBLIC GetClassLong ( PVOID, int );		  /*OPTIONAL*/
LONG FARPUBLIC SetClassLong ( PVOID, int, LONG ); /*OPTIONAL*/

BOOL FARPUBLIC GetClassInfo ( WORD, LPWNDCLASS ); /*OPTIONAL*/

WORD FARPUBLIC GetClassName ( PVOID );				  /*OPTIONAL*/

#endif //BROADSWORD



/************* Button def's. ***********************/
#ifndef WIN_BTN

VOID	FARPUBLIC	CheckDlgButton(PVOID, WORD, BOOL);	  /*OPTIONAL*/
WORD	FARPUBLIC	WButtonChecked(PVOID);					  /*OPTIONAL*/
WORD	FARPUBLIC	BnRadioButtonChecked(PVOID);			  /*OPTIONAL*/
VOID	FARPUBLIC	CheckRadioButton(PVOID, WORD, BOOL);  /*OPTIONAL*/

#ifdef ADM
WORD	FARPUBLIC	BnGroupRadioButtonChecked(PVOID);  /*OPTIONAL*/
#endif

PWND FARPUBLIC	PwndDefaultPushButton(PVOID);  /*OPTIONAL*/

#else

PWND FARPUBLIC	PwndDefaultPushButton(PVOID);	  /*OPTIONAL*/
VOID	FARPUBLIC		CheckDlgButton(PVOID, WORD, WORD);  /*OPTIONAL*/
VOID	FARPUBLIC		CheckRadioButton(PVOID, WORD, WORD, WORD);  /*OPTIONAL*/

#endif

/************* Button def's. ***********************/


/************* Some odds and sods. ***********************/

#ifdef XOR_OUTLINE
VOID		FARPUBLIC DrawXorBoxArc(NPARC);	/*OPTIONAL*/
#endif


#ifdef DATA_HANDLE
	char FAR * FARPUBLIC LpvDerefAppText ( PVOID, WORD, WORD * );		  /*OPTIONAL*/
	char FAR * FARPUBLIC LpvDerefText    ( PVOID, WORD, WORD, WORD * );  /*OPTIONAL*/
	BOOL FARPUBLIC fEnableFarData ( BOOL );							  /*OPTIONAL*/
#endif

#ifndef BIGOVERLAP
	PWND FARPUBLIC PwndAxAy(PVOID, AX, AY);   /*OPTIONAL*/
#endif /* BIGOVERLAP */

#endif	/* !NOPROCS */



#define	OV_NOSHADOW	0x0001

#define	axNil	255
#define	ayNil	255
#define	rxNil	255
#define	ryNil	255

#ifndef NORECT

#define FMoveOverlapWithKeyboard(pwnd) FMoveSizeWithKeyboard(pwnd,TRUE);
#define FSizeOverlapWithKeyboard(pwnd) FMoveSizeWithKeyboard(pwnd,FALSE);

#ifndef BROADSWORD

#define MoveWindowOverlap(pwnd, ax, ay) MoveSizeOverlap(pwnd, ax, ay, rxNil, ryNil)
#define SizeWindowOverlap(pwnd, drx, dry) MoveSizeOverlap(pwnd, axNil, ayNil, drx, dry)
#define CloseWindowOverlap(pwnd) MoveSizeOverlap(pwnd, axNil, ayNil, rxNil, ryNil)

#endif

#define DrawBorder(pwnd, pbox, di, sz)	DrawBorder2(pwnd, pbox, di, di, sz)

#define CopyRect(prrcDest, prrcSrc) {*(prrcDest) = *(prrcSrc) }
#define SetRectEmpty(prrc) {*((long *) prrc) = 0; }

#ifdef BLADE

#define AddChildHead(pwndParent,pwnd)  AddAChild(pwndParent,pwnd,HEAD)
#define AddChildTail(pwndParent,pwnd)  AddAChild(pwndParent,pwnd,TAIL)
#define InvalidateShadow(pwnd,arc)  DirtyShadow((pwnd),(arc))

#endif

#endif /*!NORECT*/

#ifndef NOWNDMACROS

#ifndef BLADE

#ifdef PROJECT_PWB
// Apparently you can't insert an #ifdef in the middle of a macro definition,
// so I have to duplicate all the wnd* definitions just to add the extra
// 0 for wExtStyle
//

#define wndGeneric(id, style, fEnabled, ax, ay, dax, day, pfnWndProc, pwndParent, pwndSibling, pwndChild) { \
	id, style, 0, fEnabled, 0, \
	{ax, ay, ax+dax, ay+day}, \
	{((style) & WS_BORDER) ? ax+1 : ax, \
	 ((style) & WS_BORDER) ? ay+1 : ay, \
	 ((style) & (WS_BORDER | WS_VSCROLL)) ? ax+dax-1 : ax+dax, \
	 ((style) & (WS_BORDER | WS_HSCROLL)) ? ay+day-1 : ay+day}, \
	rrcInvalidStd	\
	(PLFN) pfnWndProc, pwndParent, pwndSibling, pwndChild, 0, 0,

#define wndGenericCursor(id, style, fEnabled, ax, ay, dax, day, pfnWndProc, pwndParent, pwndSibling, pwndChild, axCurs, ayCurs) { \
	id, style, TRUE, fEnabled, 0, \
	{ax, ay, ax+dax, ay+day}, \
	{((style) & WS_BORDER) ? ax+1 : ax, \
	 ((style) & WS_BORDER) ? ay+1 : ay, \
	 ((style) & (WS_BORDER | WS_VSCROLL)) ? ax+dax-1 : ax+dax, \
	 ((style) & (WS_BORDER | WS_HSCROLL)) ? ay+day-1 : ay+day}, \
	rrcInvalidStd	\
	(PLFN) pfnWndProc, pwndParent, pwndSibling, pwndChild, axCurs, ayCurs,
		
#define endWndGeneric }

#define wndListBox(id,fBorder,fSorted,fEnabled,ax,ay,dax,day,pfnWndProc,pwndParent,pwndSibling,pwndChild,color,isaHilite,ctickRep) { \
	id, (WS_CHILD | WS_LISTBOX | WS_VSCROLL | \
	     (fSorted ? LBS_SORT : 0) | (fBorder ? WS_BORDER : 0)), \
	TRUE, fEnabled, 0, {ax, ay, ax+dax, ay+day},		       \
	{ (fBorder ? ax+1 : ax),                                    \
	  (fBorder ? ay+1 : ay),                                    \
	  ((TRUE)  ? ax+dax-1 : ax+dax),                      \
	  (fBorder ? ay+day-1 : ay+day)     }, \
	rrcInvalidStd	\
	(PLFN) pfnWndProc, pwndParent, pwndSibling,      \
	pwndChild, \
        (fBorder ? ax+2 : ax+1), 1 \
 	,{0,0,0,0,0,0,0,0,0,0,1,0,0,color,isaHilite,ctickRep,0} }

#define wndDropDown(id,fEnabled,fCombo) { \
	id, (WS_CHILD | WS_CLIPOUT), FALSE, TRUE, 0, \
	{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, \
	rrcInvalidStd \
	(PLFN) DropDownWndProc, NULL, NULL, NULL, 0, 0, \
	{ 0, (fCombo ? 1 : 0), NULL, NULL, NULL, NULL, \
		NULL, NULL, NULL, NULL } }

#define wndDropDownButton(id, fEnabled, ax, ay) { \
	id, WS_CHILD | WS_CLIPOUT, 0, fEnabled, 0, \
	{ ax, ay, ax + 1, ay + 1 }, \
	{ ax, ay, ax + 1, ay + 1 }, \
	rrcInvalidStd \
	(PLFN) DropButtonWndProc, \
	NULL, NULL, NULL, 0, 0 }

#define wndDropDownHolder() { \
	0, 0, 0, 0, 0, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, \
	rrcInvalidStd \
	(PLFN) NULL, NULL, NULL, NULL, 0, 0, { NULL } }


#define wndButton(id, style, fEnabled, ax,ay,dax,day, szTitle) { \
	id,style,TRUE,fEnabled, 0, {ax,ay,ax+dax,ay+day}, {ax,ay, ax+dax, ay+day},\
	rrcInvalidStd \
	(PLFN) ButtonWndProc, NULL, NULL, NULL, ax,ay, {0,szTitle,0,wButtonInit,NULL}}


#define wndGroup(id, ax,ay,dax,day, szTitle) { \
	id,WS_CHILD | WS_BUTTON | BS_GROUP | WS_BORDER, TRUE,FALSE, 0, \
   {ax,ay,ax+dax,ay+day},  \
	{ ax+1, ay+1, ax+dax-1,ay+day-1}, \
	rrcInvalidStd \
	(PLFN) ButtonWndProc, NULL, NULL, NULL, ax,ay, {0,szTitle,0,wButtonInit,NULL}}


#define wndStatic(id, style, fEnabled, ax,ay,dax,day, szTitle) { \
	id,style,FALSE,fEnabled, 0, {ax,ay,ax+dax,ay+day}, {ax,ay, ax+dax, ay+day},\
	rrcInvalidStd \
	(PLFN) StaticWndProc, NULL, NULL, NULL, ax,ay, {0,szTitle,0,0, NULL }}

#else // !PROJECT_PWB

#define wndGeneric(id, style, fEnabled, ax, ay, dax, day, pfnWndProc, pwndParent, pwndSibling, pwndChild) { \
	id, style, 0, fEnabled, \
	{ax, ay, ax+dax, ay+day}, \
	{((style) & WS_BORDER) ? ax+1 : ax, \
	 ((style) & WS_BORDER) ? ay+1 : ay, \
	 ((style) & (WS_BORDER | WS_VSCROLL)) ? ax+dax-1 : ax+dax, \
	 ((style) & (WS_BORDER | WS_HSCROLL)) ? ay+day-1 : ay+day}, \
	rrcInvalidStd	\
	(PLFN) pfnWndProc, pwndParent, pwndSibling, pwndChild, 0, 0,

#define wndGenericCursor(id, style, fEnabled, ax, ay, dax, day, pfnWndProc, pwndParent, pwndSibling, pwndChild, axCurs, ayCurs) { \
	id, style, TRUE, fEnabled, \
	{ax, ay, ax+dax, ay+day}, \
	{((style) & WS_BORDER) ? ax+1 : ax, \
	 ((style) & WS_BORDER) ? ay+1 : ay, \
	 ((style) & (WS_BORDER | WS_VSCROLL)) ? ax+dax-1 : ax+dax, \
	 ((style) & (WS_BORDER | WS_HSCROLL)) ? ay+day-1 : ay+day}, \
	rrcInvalidStd	\
	(PLFN) pfnWndProc, pwndParent, pwndSibling, pwndChild, axCurs, ayCurs,
		
#define endWndGeneric }

#define wndListBox(id,fBorder,fSorted,fEnabled,ax,ay,dax,day,pfnWndProc,pwndParent,pwndSibling,pwndChild,color,isaHilite,ctickRep) { \
	id, (WS_CHILD | WS_LISTBOX | WS_VSCROLL | \
	     (fSorted ? LBS_SORT : 0) | (fBorder ? WS_BORDER : 0)), \
	TRUE, fEnabled, {ax, ay, ax+dax, ay+day},		    \
	{ (fBorder ? ax+1 : ax),                                    \
	  (fBorder ? ay+1 : ay),                                    \
	  ((TRUE)  ? ax+dax-1 : ax+dax),                      \
	  (fBorder ? ay+day-1 : ay+day)     }, \
	rrcInvalidStd	\
	(PLFN) pfnWndProc, pwndParent, pwndSibling,      \
	pwndChild, \
        (fBorder ? ax+2 : ax+1), 1 \
 	,{0,0,0,0,0,0,0,0,0,0,1,0,0,color,isaHilite,ctickRep,0} }

#define wndDropDown(id,fEnabled,fCombo) { \
	id, (WS_CHILD | WS_CLIPOUT), FALSE, TRUE, \
	{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, \
	rrcInvalidStd \
	(PLFN) DropDownWndProc, NULL, NULL, NULL, 0, 0, \
	{ 0, (fCombo ? 1 : 0), NULL, NULL, NULL, NULL, \
		NULL, NULL, NULL, NULL } }

#define wndDropDownButton(id, fEnabled, ax, ay) { \
	id, WS_CHILD | WS_CLIPOUT, 0, fEnabled, \
	{ ax, ay, ax + 1, ay + 1 }, \
	{ ax, ay, ax + 1, ay + 1 }, \
	rrcInvalidStd \
	(PLFN) DropButtonWndProc, \
	NULL, NULL, NULL, 0, 0 }

#define wndDropDownHolder() { \
	0, 0, 0, 0, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, \
	rrcInvalidStd \
	(PLFN) NULL, NULL, NULL, NULL, 0, 0, { NULL } }


#define wndButton(id, style, fEnabled, ax,ay,dax,day, szTitle) { \
	id,style,TRUE,fEnabled, {ax,ay,ax+dax,ay+day}, {ax,ay, ax+dax, ay+day},\
	rrcInvalidStd \
	(PLFN) ButtonWndProc, NULL, NULL, NULL, ax,ay, {0,szTitle,0,wButtonInit,NULL}}


#define wndGroup(id, ax,ay,dax,day, szTitle) { \
	id,WS_CHILD | WS_BUTTON | BS_GROUP | WS_BORDER, TRUE,FALSE, \
   {ax,ay,ax+dax,ay+day},  \
	{ ax+1, ay+1, ax+dax-1,ay+day-1}, \
	rrcInvalidStd \
	(PLFN) ButtonWndProc, NULL, NULL, NULL, ax,ay, {0,szTitle,0,wButtonInit,NULL}}


#define wndStatic(id, style, fEnabled, ax,ay,dax,day, szTitle) { \
	id,style,FALSE,fEnabled, {ax,ay,ax+dax,ay+day}, {ax,ay, ax+dax, ay+day},\
	rrcInvalidStd \
	(PLFN) StaticWndProc, NULL, NULL, NULL, ax,ay, {0,szTitle,0,0, NULL }}

#endif // PROJECT_PWB
#endif // BLADE

// Routines to access elements of WND struc.

#define	IsWindowEnabled(pwnd) ((pwnd)->fEnabled)

#define	GetWindowProc(pwnd) ((pwnd)->pfnWndProc)
#define	SetWindowProc(pwnd, pfn) {(pwnd)->pfnWndProc = pfn;}

#define	PwndParent(pwnd) ((pwnd)->pwndParent)
#define	PwndChild(pwnd) ((pwnd)->pwndChild)
#define	PwndSibling(pwnd) ((pwnd)->pwndSibling)

#define	GetWindowId(pwnd)   ((pwnd)->id)
#define	SetWindowId(pwnd, wIdNew) {(pwnd)->id = wIdNew;}

#define  GetWinArcClipping(pwnd)       ((pwnd)->arcClipping)
#define  SetWinArcClipping(pwnd, arc)  {(pwnd)->arcClipping = arc;}

#define  GetWinArcWindow(pwnd)       ((pwnd)->arcWindow)
#define  SetWinArcWindow(pwnd, arc)  {(pwnd)->arcWindow = arc;}

#define  GetWindowaxCur(pwnd)           ((pwnd)->axCursor)
#define  SetWindowaxCur(pwnd, axCursor) {(pwnd)->axCursor = axCursor;}

#define  GetWindowayCur(pwnd)           ((pwnd)->ayCursor)
#define  SetWindowayCur(pwnd, ayCursor) {(pwnd)->ayCursor = ayCursor;}

#endif /*NOWNDMACROS*/

#ifndef NODRAW
	/* Window Drawing support */
	#define	AxOfRx(pwnd,rx) (AX)((pwnd)->arcClipping.axLeft+(rx))
	#define	AyOfRy(pwnd,ry) (AY)((pwnd)->arcClipping.ayTop+(ry))
	#define	RxOfAx(pwnd,ax) (RX)((ax)-(pwnd)->arcClipping.axLeft)
	#define	RyOfAy(pwnd,ay) (RY)((ay)-(pwnd)->arcClipping.ayTop)
	#define  CbSizeRrc(prrc) (CwSizeRrc(prrc) << 1)
#endif

#ifndef NOWINSTYLES
/* Window styles */
#define	WS_TILED			0x0000
#define	WS_CHILD			0x0000	/* note : no distinction */

#define WS_BORDER			0x0100
#define WS_VSCROLL		0x0200
#define WS_HSCROLL		0x0400
#define WS_SUBSTYLE		0x001f

#define WS_BEENDIRTIED	0x0020

#ifndef BROADSWORD
	#define WS_OVERLAP		0x0040
#else
	#define WS_OVERLAP		0x0040
//	#define WS_OVERLAP		0x0000
#endif

#define WS_CLIPOUT		0x0080

#define WS_TYPE 		0x3800	// type mask 
#define WS_EDIT		0x0800
#define WS_LISTBOX	0x1000
#define WS_BUTTON		0x1800
#define WS_STATIC		0x2000
#define WS_DIALOG		0x2800
#define WS_SCROLL		0x3000
#define WS_STATIC_NOACCEL	0x3800
#define WS_COMBO		0x3800

#ifdef BROADSWORD
	#define WS_MSGBOX		0x0001
	#define WS_DLGBOX		0x0002
#endif


#define LBS_SORT			0x0001
#define LBS_OWNERHILITE	0x0002

#ifdef BLADE

// The old style identifiers.
#define WS_LBCOMBO	0x0001
#define WS_LBSIMPLE	0x0002
#define WS_LBDROPPED	0x0004
#define WS_LBNOAUTO	0x0008
#define WS_LBNOSAVE	0x0010

// Windows compatible identifiers.
#define CBS_DROPDOWN			0x0001
#define CBS_DROPDOWNLIST	0x0002
#define CBS_SIMPLE			0x0004

// These two are NOT Win Compatible.
#define CBS_LBNOAUTO			0x0008
#define CBS_LBNOSAVE			0x0010

#else

#define WS_LBCOMBO	0x0001
#define WS_LBDROPPED	0x0002
#define WS_LBSIMPLE	0x0002
#define WS_LBNOAUTO	0x0004

#endif



#ifdef PROJECT_PWB
// These are style bits for wExtStyle
//
#define WES_NOVBORDERS		0x8000
#define WES_NOBOTTOMBORDER	0x4000
#endif
#endif /*!NOWINSTYLES*/


// Extended window styles.


#define WS_DLGPARENT		0x0010
#define WS_DLGWINDOW		0x0020
#define WS_VISIBLE		0x0040
#define XS_GROUP			0x0080
#define WF_GROUP			0x0080
#define WS_TABSTOP			0x0100
#define WC_TABSTOP			0x0100
#define WS_FRAME				0x2000
#define WS_OWNERREDRAW		0x4000 
#define WS_SHADOW				0x8000

#define WES_DLGPARENT	0x0010
#define WES_DLGWINDOW	0x0020
#define WES_VISIBLE		0x0040
#define WES_GROUP			0x0080
#define WES_TABSTOP			0x0100
#define WES_HSCROLL			WS_VSCROLL
#define WES_VSCROLL			WS_HSCROLL
#define WES_RADIOGROUP		0x0200
#define WES_3D					0x1000
#define WES_FRAME				0x2000
#define WES_OWNERREDRAW		0x4000 
#define WES_SHADOW			0x8000

#define BS_OWNERDRAWFIXED 	0x4000 


#ifdef BROADSWORD

#define WS_OVERLAPPEDWINDOW  ( WS_OVERLAP | WS_CLIPOUT | WS_BORDER )
#define WES_OVERLAPPEDWINDOW ( WES_FRAME )

#endif


#define IsDlgControl(pwnd)		((pwnd)->wExtStyle & WES_DLGWINDOW)
#define IsWindowVisible(hwnd)	((hwnd)->wExtStyle & WES_VISIBLE)
#define IsAGroupWindow(hwnd)	((hwnd)->wExtStyle & WES_GROUP)
#define IsFrameWindow(hwnd)	((hwnd)->wExtStyle & WES_FRAME)



#define SetExtStyleFlags(pwnd, flags) ((pwnd)->wExtStyle |= (flags))
#define GetExtStyleFlags(pwnd, flags) ((pwnd)->wExtStyle & (flags))
#define ClearExtStyleFlags(pwnd, flags) ((pwnd)->wExtStyle &= ~(flags))


/* codes for listbox item indices */
#define	iszMin	((WORD)	0)
#define	iszNil	((WORD)	-1)		/* invalid isz */

// Frame control styles 
// ---------------------
#define FS_CLOSE           0x01
#define FS_MINMAX          0x02
#define FS_VHSIZE          0x04
#define FS_HSIZE           0x08
#define FS_VSIZE           0x10
#define FS_DEFAULT         0x1f



/*from static.h */
/* static control styles */
#define SS_LEFT 		0	/* left justified text */
#define SS_CENTER 	1	/* centered text */
#define SS_RIGHT 		2	/* right justified text */


//  Frame zone interpretation flags.

#define    FZ_TL      0 	     // top left corner 
#define    FZ_TOP     1         // top side 
#define    FZ_TR      2	        // top right corner 
#define    FZ_LEFT    3         // left side 
#define    FZ_CLIENT  4         // middle 
#define    FZ_RIGHT   5         // right side
#define    FZ_BL      6         // bottom left corner
#define    FZ_BOTTOM  7         // bottom side 
#define    FZ_BR      8         // bottom right corner

#define    FZ_CLOSE   0 	     // top left corner 
#define    FZ_TMOVE   1         // top side 
#define    FZ_ZOOM    2	        // top right corner 
#define    FZ_LMOVE   3         // left side 
#define    FZ_NOP	    4         // middle 
#define    FZ_RSIZE   5         // right side
#define    FZ_LCMOVE  6         // bottom left corner
#define    FZ_BSIZE   7         // bottom side 
#define    FZ_BRCSIZE 8         // bottom right corner

#define    FZ_BLCSIZE 9         // bottom left corner
#define    FZ_TLCSIZE 10         // top left corner
#define    FZ_TRCSIZE 11         // top right corner
#define    FZ_LSIZE   12         // left side size
#define    FZ_TSIZE   13         // top side size

// The largest frame zone code CW defines. App's may pass back other values
//	from the frame filter, in which case the CW overlap filter will pass
//	them to the app directly as a message.
#define    FZ_MAXINTERNAL	FZ_TSIZE

#define WM_DLGRETURN			0x8004

#ifdef BLADE

// Frame control IDs    
// Lower byte is for client ID. Upper byte is reserved for US!
 
#define FID_SYSMENU         0x8002
#define FID_TITLEBAR        0x8003
#define FID_MINMAX          0x8004
#define FID_MENU            0x8005
#define FID_VERTSCROLL      0x8006
#define FID_HORZSCROLL      0x8007

#define FID_FRAME           0x0100
#define FID_CLIENT          0x0200

#define WM_DESTROY         0x0009
#define WM_FRAMEDRAW       0x8000
#define WM_OWNERDRAW       0x8000

#define WM_ADDMENU	      0x8001
#define WM_DELETEMENU      0x8002
#define WM_REPLACEMENU		0x8003

#define WM_VISIBLE			0x8005
#define WM_CALCRECT			0x000b
#define WM_NCCALCSIZE		0x8006
#define WM_VALIDATEDIR		0x8007
#define WM_WINTOTOP			0x8008
#define WM_CALCCLIENT		0x8009
#define WM_SETDLGPOS			0x800a
#define WM_DRAWITEM			0x800b
#define WM_GETDLGCODE		0x800c
#define WM_ENABLE				0x800e
#define WM_CTLCOLOR			0x800f
#define WM_GETDLGCTL			0x8010
#define WM_SYSTIMER			0x8011
#define WM_ERASEBKGND		0x8012
#define WM_NEXTDLGCTL		0x8013
#define WM_SIZESCROLL		0x8014


#define WC_STATIC			0x8001
#define WC_GROUP			0x8003
#define WC_BUTTON			0x8004
#define WC_CHECKBOX		0x8005
#define WC_RADIOBUTTON  0x8006
#define WC_EDIT			0x8007
#define WC_LIST			0x8008

#define WC_DROPDOWN		0x800b
#define WC_DROPEDIT		0x800c
#define WC_DROPBUTTON	0x800d
#define WC_DROPLIST		0x800e
#define WC_DROPHOLDER	0x800f

#define WC_FRAME			0x8010
#define WC_SCROLLBAR		0x8011
#define WC_DIALOG			0x8012
#define WC_MSGBOX			0x8013
#define WC_MLE				0x8014
#define WC_DLGDIR			0x8015
#define WC_MENU			0x8016
#define WC_SCROLL_CLIPPED	0x8017
#define WC_GENPIC			0x8018

#endif // BLADE

#ifdef BROADSWORD

DWORD FARPUBLIC WinEditWndProc(PVOID, WORD, register WORD, DWORD);  /*OPTIONAL*/

#define WC_WINEDIT	0x8018

#endif

#ifndef EDIT_FULLMGR
	#define WM_SETTEXT       0x0002
	#define WM_GETTEXT       0x0004
#else
	#define WM_SETTEXT	(WM_USER+2+6)
	#define WM_GETTEXT	(WM_USER+2+7)
#endif

#define WM_GETTEXTLENGTH 0x000a
#define	WM_INITDIALOG	 0x0381


// Limit size for QB 
#ifdef EDIT_LIMIT_SIZE
	#define cwEditBuffer 64 			// 128 char limit 
#else
	#define cwEditBuffer 128			// 256 char limit 
#endif

#define	cbEditDefault	(cwEditBuffer * sizeof(WORD) - 1)


/********************** CW Button Code. ***********************************/

// There are two sets of button source code. One is the pre-existing button
// code of old CW origin ( Contained in button.c ). The other code is a
// re-write which brings the code into Windows conformity, and corrects 
// many defects of the old code ( Contained in btnctl.c and btndraw.c )
// 
// Apps should strive to use the new button code whenever possible. This
// code was originally written for inclusion in BROADSWORD, but has been
// backported to CW 3.1 for current clients.
// 

#ifndef WIN_BTN
// Button notification codes.

#define BN_DOUBLECLICKED	0
#define BN_CLICKED			1
#define BN_PAINT				2
#define BN_HILITE				3
#define BN_UNHILITE			4
#define BN_DISABLE			5


#define BS_AUTO				0x10
#define BS_PUSHBUTTON		0
#define BS_DEFPUSHBUTTON	1
#define BS_CHECKBOX			2
#define BS_AUTOCHECKBOX		(BS_CHECKBOX | BS_AUTO)
#define BS_RADIOBUTTON		3
#define BS_GROUP 				4


#define	wButtonFirstRadio	8	// Initial value for 1st button 
#define	wButtonInit		0		// Initial value for other buttons 


#define  wsRadioButton	(WS_CHILD | WS_BUTTON | BS_RADIOBUTTON)
#define  wsCheckbox		(WS_CHILD | WS_BUTTON | BS_CHECKBOX)
#define	wsPushButton	(WS_CHILD | WS_BUTTON | BS_PUSHBUTTON)
#define	wsDefPushButton	(WS_CHILD | WS_BUTTON | BS_DEFPUSHBUTTON)
#define	dayPushButton	1		/* single line button */
#define	daxPushButton	2		/* <> overhead */

#else

// The Windows compatable button source.

/* button control styles */
#define BS_PUSHBUTTON    0
#define BS_DEFPUSHBUTTON 1
#define BS_CHECKBOX      2
#define BS_AUTOCHECKBOX  3
#define BS_RADIOBUTTON   4
#define BS_3STATE        5
#define BS_AUTO3STATE    6
#define BS_GROUPBOX      7
#define BS_USERBUTTON    8
#define BS_AUTORADIOBUTTON 9
#define BS_PUSHBOX       10
#define BS_OWNERDRAW	   0x0B

#define BS_GROUP 			  7

/* User Button Notification Codes */
#define BN_CLICKED	0
#define BN_PAINT	   1
#define BN_HILITE	   2
#define BN_UNHILITE	3
#define BN_DISABLE	4
#define BN_DOUBLECLICKED   5

// Button Control Messages 
#define BM_GETCHECK	   (WM_USER+0)
#define BM_SETCHECK	   (WM_USER+1)
#define BM_GETSTATE	   (WM_USER+2)
#define BM_SETSTATE	   (WM_USER+3)
#define BM_SETSTYLE	   (WM_USER+4)
#define BM_CLICK		   (WM_USER+5)

// The following def's are for compatability with the older button
// code. Don't use them if you can help it! They WILL be gone soon.

#define  wsRadioButton	(WS_CHILD | WS_BUTTON | BS_RADIOBUTTON)
#define  wsCheckbox		(WS_CHILD | WS_BUTTON | BS_CHECKBOX)
#define	wsPushButton	(WS_CHILD | WS_BUTTON | BS_PUSHBUTTON)
#define	wsDefPushButton	(WS_CHILD | WS_BUTTON | BS_DEFPUSHBUTTON)
#define	dayPushButton	1		/* single line button */
#define	daxPushButton	2		/* <> overhead */

#endif

/********************** End Of Button Code *********************************/


#ifndef BROADSWORD

#define InvalidateRect(hwnd, prrc) InvalidateRrc((hwnd),prrc)
#define GetClientRect(hwnd,prrc) GetClientRrc((hwnd),prrc)

#define UpdateWindow(pwnd)  XSendMessage((pwnd), WM_PAINT, 0, 0L )

#define GetDC(hWnd)	(hWnd)
#define ReleaseDC(hWnd, hDC)

#endif //!BROADSWORD


#ifdef BLADE

// Owner draw control types 
#define ODT_MENU		1
#define ODT_LISTBOX	2
#define ODT_COMBOBOX	3
#define ODT_BUTTON	4

// Owner draw actions 
#define ODA_DRAWENTIRE	0x0001
#define ODA_SELECT		0x0002
#define ODA_FOCUS			0x0004

// Owner draw state 
#define ODS_SELECTED	0x0001
#define ODS_GRAYED	0x0002
#define ODS_DISABLED	0x0004
#define ODS_CHECKED	0x0008
#define ODS_FOCUS		0x0010


// DRAWITEMSTRUCT for ownerdraw 

typedef struct tagDRAWITEMSTRUCT
	{
	WORD	CtlType;
	WORD	CtlID;
	WORD	itemID;
	WORD	itemAction;
	WORD	itemState;
	HWND	hwndItem;
	HDC	hDC;
#ifdef NOGD_RECT
	RECT	rcItem;
#else
	ARC	rcItem;
#endif
	DWORD	itemData;
	} DRAWITEMSTRUCT;

typedef DRAWITEMSTRUCT NEAR *PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR  *LPDRAWITEMSTRUCT;


// Dialog Codes 
#define DLGC_WANTARROWS			0x0001	// Control wants arrow keys	    
#define DLGC_WANTTAB				0x0002	// Control wants tab keys	    
#define DLGC_WANTALLKEYS		0x0004	// Control wants all keys	    
#define DLGC_WANTMESSAGE		0x0004	// Pass message to control	    
#define DLGC_HASSETSEL			0x0008	// Understands EM_SETSEL message    
#define DLGC_DEFPUSHBUTTON		0x0010	// Default pushbutton		    
#define DLGC_UNDEFPUSHBUTTON	0x0020	// Non-default pushbutton	    
#define DLGC_RADIOBUTTON		0x0040	// Radio button 		    
#define DLGC_WANTCHARS			0x0080	// Want WM_CHAR messages	    
#define DLGC_STATIC				0x0100	// Static item: don't include	    
#define DLGC_BUTTON				0x2000	// Button item: can be checked	    


#endif //BLADE



#define ENUM_START	0
#define ENUM_DATA		1
#define ENUM_END		2


#define WC_STATICDIR	0x0800
#define WC_LISTDIR	0x1000
#define WC_LISTDRIVE	0x1800



typedef	struct fszi_
	{
	LPSTR	lsz;
	ISA	isa;
	} FSZI;


#define RethinkDisplay()		/* Rethinkdisplay is no longer used */


#define SW_VISIBLE	 1
#define SW_INVISIBLE	 2


typedef struct _boxtextparms
	{
#if defined(BLADE) || defined(PROJECT_PWB)
	WORD 	_aclDialog;
#endif
	BOOL	fCenter;
	char *szTitle;
	BOOL	fBottom;
	BOOL	fRight;
	WORD	diRest;
	WORD	diTop;
	ARC * parc;
	BOX * pbox;
	} BOXTEXT_PARMS, *PBOXTEXT_PARMS;



#ifdef ADM

// For TED. Temporary.

#define wndGeneric(id, style, fEnabled, ax, ay, dax, day, pfnWndProc, pwndParent, pwndSibling, pwndChild) { \
	id, style, 0, fEnabled, WS_VISIBLE,\
	{ax, ay, ax+dax, ay+day}, \
	{((style) & WS_BORDER) ? ax+1 : ax, \
	 ((style) & WS_BORDER) ? ay+1 : ay, \
	 ((style) & (WS_BORDER | WS_VSCROLL)) ? ax+dax-1 : ax+dax, \
	 ((style) & (WS_BORDER | WS_HSCROLL)) ? ay+day-1 : ay+day}, \
	rrcInvalidStd	\
	(PLFN) pfnWndProc, pwndParent, pwndSibling, pwndChild, 0, 0, 0,

#define endWndGeneric }

#endif


#ifdef BLADE

#define _optNotButton	0
#define _optIsButton		1
#define _optIsDefButton	2

#endif

#define ID_DESKTOP	0xabcd
#define ID_INTERNAL	0xffff
#define ID_DLGDIR		0xfffd
#define ID_DIALOG		0xfffc
#define ID_MSGBOX		0xfffb

#define ID_VSCROLL	0xfffa
#define ID_HSCROLL	0xfff9


#ifdef BLADE
#define Is3D( pwnd )  (pwnd)->wExtStyle & WES_3D;

extern PBOX pboxUL;
extern PBOX pboxBR;
	
extern PBOX pboxDoubleUL;
extern PBOX pboxDoubleBR;

#endif

#ifdef BROADSWORD

// Window field offsets for GetWindowLong() and GetWindowWord() 

#define GWL_WNDPROC	    (-14)
#define GWW_HWNDPARENT	 (-10)
#define GWW_ID		    	 (-34)
#define GWW_STYLE	    	 (-32)
#define GWW_EXSTYLE	    (-30)

// Class field offsets for GetClassLong() and GetClassWord()

#define GCL_MENUNAME	    	(-4)
#define GCW_HBRBACKGROUND  (-8)
#define GCW_HCURSOR	    	(-10)
#define GCW_HICON	    		(-12)
#define GCW_CBWNDEXTRA	   (-16)
#define GCW_CBCLSEXTRA	   (-18)
#define GCL_WNDPROC	    	(-22)
#define GCW_STYLE	    		(-24)


#endif


#ifndef NOWNDMACROS

#ifndef BLADE

#ifndef	REVIEW	/* fBorder=True not support */
#define wndEdit(id, fBorder, fEnabled, ax, ay, dax, day, pwndParent, pwndSibling, szBuf, cchMax, chFill, isa, isaSel) {\
	id, WS_CHILD | WS_EDIT, \
	0, fEnabled, {ax, ay, ax+dax, ay+day}, \
	{ax, ay, ax+dax, ay+day}, \
	rrcInvalidStd	\
	(PLFN) InternalEditWndProc, pwndParent, pwndSibling, NULL, 0, 0, \
	{0, (WORD) szBuf, cchMax, isa, isaSel, chFill, 0, 0, 0, 0, TRUE, 0, \
	 cchMax}}
#else
#define wndEdit(id, fBorder, fEnabled, ax, ay, dax, day, pwndParent, pwndSibling, szBuf, cchMax, chFill, isa, isaSel) {\
	id, WS_CHILD | WS_EDIT | (fBorder ? WS_BORDER : 0), \
	0, fEnabled, {ax, ay, ax+dax, ay+day}, \
	{((fBorder) ? ax+1 : ax), (fBorder ? ay+1 : ay), \
	 ((fBorder) ? ax+dax-1 : ax+dax), (fBorder ? ay+day-1 : ay+day)}, \
	rrcInvalidStd	\
	(PLFN) InternalEditWndProc, pwndParent, pwndSibling, NULL, 0, 0, \
	{0, (WORD) szBuf, cchMax, isa, isaSel, chFill, 0, 0, 0, 0, TRUE, 0, \
	 cchMax}}
#endif
#endif // BLADE


// Edit Control Text Styles 
#ifndef BROADSWORD

#define ES_LEFT		0	// left justified text 
#define ES_CENTER		1	// centered text 
#define ES_RIGHT		2	// right justified text 

#endif

#define	ES_SECRET	4	// secret edit field 
#define	ES_DLGDIR	8	// edit field belongs to dir/files combo.



// InternalEditWndProc must be forward defined for CS compiler 
DWORD 		FARPUBLIC InternalEditWndProc ( PVOID, WORD, WORD, DWORD);

#endif // !NOWNDMACROS 

/* for selection (SetTmcSel) */
#define	ichSelectEnd	(0x7fff)		/* select to end */

#ifdef BLADE

#ifndef EDIT_FULLMGR	
VOID		FARPUBLIC SetEditText	( PVOID, char far *, BOOL);
#else
VOID		FARPUBLIC SetEditText	(PVOID, char *, BOOL);
#endif

#else

VOID		FARPUBLIC SetEditText	(PVOID, char *, BOOL);

#endif


#ifndef EDIT_FULLMGR	
VOID		FARPUBLIC SetEditWidth	(PVOID, int);				/*OPTIONAL*/
#else
VOID		FARPUBLIC SetEditWidth	(PVOID, WORD);				/*OPTIONAL*/
#endif

WORD		FARPUBLIC GetEditText	(PVOID, char *, WORD);
DWORD		FARPUBLIC EditWndProc	(PVOID, WORD, WORD, DWORD);

VOID		FARPUBLIC DefaultEditMgrInit(VOID);						/*OPTIONAL*/

#define EN_CHANGE			0x0300
#define EN_CURSORMOVED			0x0301


#ifndef NOMSG

// Message structure 

typedef struct _msg
	{
	PWND	pwnd;
	WORD	message;
	WORD	wParam;
	DWORD	lParam;
	DWORD	time;
	} MSG;

typedef MSG *PMSG;

#ifndef	OS2_INCLUDED
#define	HSEM	DWORD
#endif

#ifndef OS2

extern BOOL PASCAL fMessage;
extern BOOL PASCAL fUseCache;

#ifndef	KANJI
#define	FMessage()		(fMessage || fUseCache)
#else
extern BOOL PASCAL fKkcMessage;
#define	FMessage()		(fKkcMessage || fMessage || fUseCache)
#endif

#ifdef DUAL
extern DWORD PASCAL semaMessage;	// message semaphore 
#define	hsemaMessage	((HSEM) (DWORD FAR *) &semaMessage)
#endif

#else

extern DWORD PASCAL semaMessage;	// message semaphore 
#define	hsemaMessage	((HSEM) (DWORD FAR *) &semaMessage)

#endif


#endif // !NOMSG

typedef BOOL (FARPUBLIC *PBFN_KBDMSG)(WORD, WORD, DWORD);

#ifndef NOWINMESSAGES

// Window Messages 

#define	WM_NULL			0x0000
#define	WM_CREATE		0x0001
#define	WM_WANTFOCUS	0x1005
#define	WM_MAKEACTIVE	0x1006
#define	WM_SETFOCUS		0x0007
#define	WM_KILLFOCUS	0x0008
#define	WM_REPAINT		0x100e
#define	WM_PAINT			0x000f
#define	WM_QUIT			0x0012

#define	repModeReset	0		// handled by RepaintScreen
#define	repRedraw		1		// handled by RepaintScreen
#define	repGraphic		2		// app should redraw GSD graphic

// Non-client (for Overlap only) 
#define	WM_NCLBUTTONDOWN	0x00a1

#define	WM_KEYFIRST		0x0100
#define	WM_KEYLAST		0x0102

#define	WM_KEYDOWN		0x0100
#define	WM_KEYUP			0x0101
#define	WM_CHAR			0x0102

#define	WM_CUT			0x0300

#define	WM_COPY			0x0301
#define	WM_PASTE			0x0302
#define	WM_INSERT		0x1303

#define	WM_MENUIDLE			0x1110		// Menu Idle
#define	WM_MENUINACTIVE	0x1111		// Menu inactive 
#define	WM_COMMAND			0x0111
#define	WM_MENUSELECT		0x0112		// selecting a menu item 
#define	WM_MENUSTART		0x0113		// starting a menu action 
#define	WM_HSCROLL			0x0114
#define	WM_VSCROLL			0x0115
#define	WM_INITMENUPOPUP	0x0117
#ifdef ESCHER
#define	WM_MENU_COMMAND	0x0118
#else
#define	WM_MENU_COMMAND	WM_COMMAND
#endif
#define	WM_DISABLEDCOMMAND	0x0119

#define	WM_ALARM				0x1118

#define WM_DLGMSG_START		0x0120
#define WM_DLGMSG_END		0x0121

#define	WM_MOUSEFIRST		0x0200
#define	WM_LMOUSELAST		0x0203	// last of Left mouse actions 
#define	WM_MOUSELAST		0x0209

#define	WM_MOUSEMOVE		0x0200	// mouse related constants 
#define	WM_LBUTTONDOWN		0x0201
#define	WM_LBUTTONUP		0x0202
#define	WM_LBUTTONDBLCLK	0x0203
#define	WM_RBUTTONDOWN		0x0204
#define	WM_RBUTTONUP		0x0205
#define	WM_RBUTTONDBLCLK	0x0206

// Edit Wnd Proc Messages 

#ifndef FULL_EDIT

#define EM_SETSEL	0x0400
#define EM_GETSEL	0x0401

#endif

#ifdef BLADE
	#define EM_SETDEF	0x0402
	#define EM_SETBUF	0x0403

	#define EM_FIRST	EM_SETSEL
	#define EM_LAST	EM_SETBUF
#endif

// Debugging Message 
#define WM_TRACEOUT		0x0500
#define WM_TRACETAG_REGISTER	0x0501

// Overlap Wnd Proc Messages 
#define WM_ACTIVATE		0x0006
#define WM_ZOOM			0x0321
#define WM_CLOSE			0x0010
#define WM_MOVE			0x0003
#define WM_SIZE			0x0005


// WM_ACTIVATE response codes 
#define	rspActiveLive		((DWORD) 2)	// pass activating event on 
#define	rspActive			((DWORD) 1)	// eat activating event 
#define	rspActiveDecline	((DWORD) 0)	// [de]activation declined 


// Dialog related messages 
#define WM_DIALOGINACTIVE	0x0360

//WM-DIALOG is actually private (and LB_SETWIDTH)

#define WM_DIALOG		0x0380

// Listbox Proc Messages 

#define WM_LISTBOX_COMMAND	WM_DIALOG
#define LB_FIRST				LB_RESETCONTENT
#define LB_RESETCONTENT		0x0340
#define LB_ADDSTRING			0x0341
#define LB_DELETESTRING		0x0342
#define LB_SETCURSEL			0x0343
#define LB_GETCURSEL			0x0344
#define LB_SETWIDTH			0x0345
#define LB_GETTEXT			0x0346
#define LB_GETCOUNT			0x0347
#define LB_REPLACESTRING	0x0348
#define LB_INSERTSTRING		0x0349
#define LB_HILITECURSEL		0x0350

#define LB_SETDEF			0x0351
#define LB_INIT			0x0353

#define LB_LAST	 LB_INIT

// VAP Request for application to handle 
#define WM_VAP_REQUEST		0x0390

// Kkc converter message for application to handle 
#define	WM_KKCONVERT		0x03f0
#define	WM_KKPAINT			0x03f1
#define	WM_KKCSTR_START	0x03f2
#define	WM_KKCSTR_END		0x03f3

#define	WM_KKENABLE			0x03f7
#define	WM_KKDISABLE		0x03f8

// drop down listbox notification messages 
#define DD_MINIMIZED		0x0370
#define DD_MAXIMIZED		0x0371
#define DD_MINIMIZE_NOW 0x0372
#define DD_MAXIMIZE_NOW 0x0373

	// Added DD_MAXIMIZE_NOW to allow users to maximize drop down 
	//  listboxes.						    
	// LGT: 10/08/90					     


// parameter for DD_MINIMIZED in low byte of lParam 
#define ddMinEsc			1
#define ddMinEnter		2
#define ddMinControl		4
#define ddMinKillFocus	8
#define ddMinMsg			16

// private window messages start here 
#define	WM_USER			0x0400
#endif

// Window's aliases for KK_ states 

#define	KK_MENU			KK_ALT
#define	KK_CAPITAL		KK_CAPLOCK

// HELP 
#define	VK_HELP_KEY		VK_F1

// listbox notification codes 
#define LBN_SELCHANGE		0
#define LBN_DBLCLK			1
#define LBN_SELECT_DONE		2
#define LBN_OOM				3
#define LBN_OWNERHILITE		4


// List Box Selection Codes 
#define lbrCause		0xf
#define lbrNone		0
#define lbrMouse		1
#define lbrScroll		2
#define lbrKeys		3
#define lbrSpace		4
#define lbrOther		5
#define lbrEnter		6
#define flbrReselect	0x10


// help types/contexts 
#define	hemMenu			1
#define	hemMenuItem		2
#define	hemMbox			3
#define	hemDialog		4
#define	hemUserMin		0x10		// For Application contexts 

// help id's for message boxes 

#ifndef NOMB

#define	hidMboxOk				MB_OK
#define	hidMboxYesNoCancel	MB_YESNOCANCEL
#define	hidMboxRetryCancel	MB_RETRYCANCEL
#define	hidMboxOkCancel		MB_OKCANCEL
#define	hidMboxAbort			MB_ABORT
#define hidMboxYesNo				MB_YESNO
#define hidMboxRetry				MB_RETRY

#endif //!NOMB

VOID		FARPUBLIC SetAlarm( PVOID, WORD);
VOID		FARPUBLIC KillAlarm(void);

#ifndef REVIEW // should UndoRepeat be exported? 
	VOID		FARPUBLIC UndoRepeat(WORD, DWORD);
#endif


DWORD		FARPUBLIC SendMessage	(PVOID, WORD, WORD, DWORD);

// #if defined(BLADE) && !defined(DEBUG)
#ifdef BLADE

#define XSendMessage(pwnd, message, wParam, lParam ) (*(pwnd)->pfnWndProc)( (pwnd), message, wParam, lParam)

#else

#define XSendMessage(pwnd, message, wParam, lParam ) SendMessage((pwnd), (message), (wParam), (lParam) )

#endif


#ifdef BROADSWORD

extern PWND PASCAL pwndCapture;
extern PWND PASCAL pwndFocus;

#define GetFocus()	pwndFocus

#define DispatchMessage(pmsg)	\
	(pmsg)->pwnd != NULL ?  (*((pmsg)->pwnd)->pfnWndProc)((pmsg)->pwnd, (pmsg)->message, (pmsg)->wParam, (pmsg)->lParam) : \
	0L

#define ReleaseCapture() 	SetCapture(NULL)

#ifdef PAINTQ
BOOL		FARPUBLIC PostPaintMessage	( PVOID ); /*OPTIONAL*/
#endif

#else	//BROADSWORD

PWND		FARPUBLIC GetFocus		(void);
DWORD		FARPUBLIC DispatchMessage	(PMSG);
VOID 		FARPUBLIC ReleaseCapture	(void);

#endif	//BROADSWORD


VOID		FARPUBLIC UngetMessage	(PMSG);
BOOL		FARPUBLIC PeekMessage	(PMSG);
BOOL		FARPUBLIC FNextMsg		(PMSG);
PWND		FARPUBLIC SetFocus		( PVOID );
VOID		FARPUBLIC FlushAbort		(void);
PWND		FARPUBLIC SetCapture		( PVOID );
BOOL		FARPUBLIC PostMessage	(PVOID, WORD, WORD, DWORD);
VOID		FARPUBLIC HookKeyboardPoll	(BOOL, LPFN);
WORD		FARPUBLIC SetDoubleClickTime	(WORD);		//OPTIONAL
VOID		FARPUBLIC SynthesizeShiftKeys	(WORD, WORD);	//OPTIONAL
VOID		FARPUBLIC HookKeyboardMessage	(BOOL, PBFN_KBDMSG);
BOOL		FARPUBLIC InsertKeyboardMessage	(WORD, WORD, DWORD);
WORD		FARPUBLIC CmsgKeyboardQueueEntry	(WORD, PMSG);


// CW Hook constants.

#define WH_MENU     0
#define WH_OVERLAP  1
#define WH_DIALOG   2
#define WH_FRAME    3


typedef BOOL	(FARPUBLIC *PFFN_FILTER)(PMSG);	// filter 
typedef BOOL	(FARPUBLIC *PFFN_FRAME_FILTER)(PMSG, WORD *);	// filter 

PFFN_FILTER FARPUBLIC SetCWHook ( WORD, PFFN_FILTER );


/**END_PUBLIC**/

#ifdef COW

// application-supplied callback functions 
BOOL FARPUBLIC FAppNextMsg(PMSG);

// window if alarm set (used by timer) 
extern PWND pwndAlarm;

// is keyboard polling hooked 
extern BOOL fHookPollKeyboard;

#ifdef KANJI
	VOID		FAR PASCAL KeyboardMessage(BYTE, BYTE, WORD, WORD, BOOL);
#else
	VOID		FAR PASCAL KeyboardMessage(BYTE, WORD, WORD, BOOL);
#endif

VOID		FAR PASCAL SpecialTsrAbort(void);
BOOL		FAR PASCAL FTestKeyboardEmpty(void);
VOID		FAR PASCAL FlushKeyEvents(VOID);

#endif


#ifndef NOCOLOR

//	* General colors 
#define	isaNil			((ISA) -1)

#define	isaBackground		0

#define	isaHilite		1		// hilite / inversion 
#define	isaGreyed		2		// not currently used 
#define	isaEnabled		3
#define	isaDisabled		4
#define	isaAlert		5

//	* Dialog elements :	
#define	isaDialogBox		6					// the actual dialog box 
#define	isaStatic			isaDialogBox	// static text 
#define	isaButton			isaDialogBox	// radio/check buttons 
#define	isaPushButton		7					// push buttons 
#define	isaButtonDown		8					// pushed button 
#define	isaListBox			9					// listbox background 
#define	isaEdit				isaDialogBox

//	 Scroll Bars :		
#define	isaScrollbar		10
#define	isaElevator			11

//	Menus :		

#ifdef BLADE

//  NOTE! Due to isa re-mapping for Escher, these two isa's are not used
// 		 internally by CW anymore. There slots are freed up.
//  isaItemHiliteSel
//  isaMenuBox

	#define	isaMenu				13			// non-selected MENU 
	#define	isaMenuBox			isaMenu	// box around pull downs 
	#define	isaMenuSelected	14			// selected menu item 
	#define	isaMenuHilite		15			// hilited character 
#else
	#define	isaMenuBox			12		// box around pull downs 
	#define	isaMenu				13		// non-selected MENU 
	#define	isaMenuSelected	14		// selected menu item 
	#define	isaMenuHilite		15		// hilited character 
#endif

// hilited character under selection 

#ifdef BLADE
	#define	isaMenuHiliteSel	16		// for menu titles 
	#define	isaItemHiliteSel	isaMenuHiliteSel		// for menu items 
#else
	#define	isaMenuHiliteSel	16		// for menu titles 
	#define	isaItemHiliteSel	17		// for menu items 
#endif


#define	isaDialogAccel		18		// dialog accelerators 
#define	isaDialogAccelBor	19		// dialog accelerator border 

//	 Shadows :		
#define	isaShadow		20

#ifdef BLADE
// 3D Effect 


#define	isaDialogBar		21
#define	isaDialogTitle		22

#define	isa3DGroupBoxIn	23		// 3D group box effects 
#define	isa3DGroupBoxOut	24
#define	isa3DListboxIn		25
#define	isa3DListboxOut	26

#define	isa3DPushBtnIn		27
#define	isa3DPushBtnOut	28


#define	isa3DGroupBoxUL	isa3DGroupBoxIn	
#define	isa3DGroupBoxBR	isa3DGroupBoxOut	

#define	isa3DListboxUL		isa3DListboxIn	
#define	isa3DListboxBR		isa3DListboxOut

#define	isa3DPushBtnUL		isa3DPushBtnIn	
#define	isa3DPushBtnBR		isa3DPushBtnOut

#define	isaButtonAccel		29		// dialog accelerators 

#define	isaSystemMax		29

#else	//BLADE

#define	isaSystemMax	   isaShadow

#endif //BLADE

// User Colors :		
#define	isaUserMin		isaSystemMax+1
#define	isaUserMax		(isaUserMin+16)
#define	isaMax			isaUserMax

#ifdef KANJI
#define	ffontNil	((FFONT)0L)
#else
#define	ffontNil	((FFONT)0)
#endif

#endif //!NOCOLOR


#ifndef NOMENUS
/* hack for nameless unions in CC */
#ifdef CC
#define CC_USZ u
#define CC_URG u
#define cwExtraMenu 1
#else
#define CC_USZ
#define CC_URG
#define cwExtraMenu 0
#endif

// Menu Modes : HIWORD(lParam) for WM_COMMAND / WM_MENUSELECT messages 

#define	mmdItem		0		// dropdown item 
#define	mmdAccel		1		// keyboard accelerator 
#define	mmdMenu		2		// dropdown not item 
#define	mmdString	3		// WM_MENUSELECT contains string 

// Help Line codes for wParam WM_MENUSELECT (lParam == 0) 

#define	enClear		0		// clear must be zero 
#define	enCommand	1		// prepare help line for command 


typedef struct _mpvkeyid
	{
	WORD	vkey;
	WORD	idItem;
	} MPVKEYID;
#define VkeyOfVkKk(vk, kk)	((vk) | (kk))

#ifndef SMM			// Old menu structures 

typedef struct _menuitem
	{
	WORD	idItem;			// id for menuitem 
	BITS	fEnabled:1;		// TRUE => enabled, FALSE => greyed 
	BITS	fChecked:1;		// TRUE => checked 
	BITS	fSeparator:1;	// TRUE => separator 
	BITS	fHandle:1;		// TRUE => use pszItem, else szItem 
	BITS	ichHilite:4;	// index of prefix character 
	BITS	bParamUser:8;	// available for application use 

	union
		{
		char *szItem;
		char **pszItem;
		} CC_USZ;
	WORD	wParamUser;		// available for application use 

#ifdef KANJI
	WORD	chKanaAccel;	// Kana Accelerators 
#endif

	} MENUITEM;
typedef struct _menu
	{
	WORD	idMenu;
	BITS	rxTitle:8;
	BITS	ichHilite:4;		// index of prefix character
	BITS	fHandle:1;
	BITS	fEnabled:1;			// is menu 'enabled' (not greyed) 
	BITS	filler:2;
	WORD	cchTitle;
	char	*pchTitle;
	WORD	citem;
	WORD	cchitemMax;
	union
		{
		MENUITEM *rgmenuitem;
		MENUITEM **prgmenuitem;
		} CC_URG;
	WORD	wParamUser;		// available for application use 
#ifdef KANJI
	WORD	chKanaAccel;		// Kana Accelerators 
#endif /*KANJI*/
	} MENU;

typedef struct _menubar
	{
	WORD	cmenu;
	MENU	*rgmenu;
	MPVKEYID *rgmpvkeyid;
	} MENUBAR;

typedef MENU *PMENU;
typedef MENUITEM *PMENUITEM;
typedef MENUBAR *PMENUBAR;

// menu item define macros :
//	D => disabled
//	H => string handle
//	X => with index (otherwise default to 0)

#ifndef KANJI

// enabled simple item 

#define menuitem(mid, sz, w) {(mid), TRUE, FALSE, FALSE, FALSE,\
	0, 0, {(sz)}, (WORD) (w)},

#define menuitemD(mid, sz, w) {(mid), FALSE, FALSE, FALSE, FALSE,\
	0, 0, {(sz)}, (WORD) (w)},

#define menuitemDH(mid, psz, w) {(mid), FALSE, FALSE, FALSE, TRUE,\
	0, 0, {(char *)(psz)}, (WORD)(w)},

#define menuitemX(mid, sz, ich, w) {(mid), TRUE, FALSE, FALSE, FALSE,\
	(ich), 0, {(sz)}, (WORD) (w)},

#define menuitemDX(mid, sz, ich, w) {(mid), FALSE, FALSE, FALSE, FALSE,\
	(ich), 0, {(sz)}, (WORD) (w)},

// separator
#define	menuitemSep	{0, FALSE, FALSE, TRUE, FALSE, 0, 0, {NULL}, 0},

#else	// KANJI - 1 extra value needed for Kana Accelerator 
		// Accelerator should always be at start 

#define menuitem(mid, sz, chKana, w) {(mid), TRUE, FALSE, FALSE, FALSE,\
	0, 0, {(sz)}, (WORD) (w), (WORD) (chKana)},

#define menuitemD(mid, sz, chKana, w) {(mid), FALSE, FALSE, FALSE, FALSE,\
	0, 0, {(sz)}, (WORD) (w), (WORD) (chKana)},

#define menuitemDH(mid, psz, chKana, w) {(mid), FALSE, FALSE, FALSE, TRUE,\
	0, 0, {(char *)(psz)}, (WORD)(w), (WORD) (chKana)},

// separator 
#define	menuitemSep	{0, FALSE, FALSE, TRUE, FALSE, 0, 0, {NULL}, 0, 0},

#endif /*KANJI*/

#else // SMM		  

// New menu structures 

typedef struct _mtm
	{
	WORD	id;
	BYTE	bFlags;
//	BITS	fDisabled:1;
//	BITS	fChecked:1;
//	BITS	fSeparator:1;
//	BITS	fString:1;
//	BITS	fHelp:1;
//	BITS	fMenuBreak:1;
//	BITS	fSubMenu:1;
//	BITS	filler:1;	
	BYTE	cwTotal;
	union
		{
		WORD	sid;
		WORD	iwString;
		} CC_USZ;
	WORD	rgwExtra[cwExtraMenu];
	} MTM, *PMTM;

typedef struct _mnu
	{
	struct _mnu **hmnuNext;
	WORD	cmtm;
	struct _mtm grmtm;
	} MNU, **HMNU;

#define MM_DISABLED	0x01
#define MM_CHECKED	0x02
#define MM_SEPARATOR	0x04
#define MM_STRING		0x08
#define MM_HELP		0x10
#define MM_MENUBREAK	0x20
#define MM_SUBMENU	0x40
#ifdef ESCHER
#define MM_INVISIBLE	0x80
#endif

// defaults: 

#define MM_ENABLED	0
#define MM_UNCHECKED	0
#define MM_SID		0

// special ID#'s 

#define idNil		((WORD) 0)
#define idSysMenu	((WORD) -1)

#define cbMTM (sizeof(MTM)-cwExtraMenu*sizeof(WORD))
#define cwMTM (cbMTM/sizeof(WORD))
#define cbMNU (sizeof(MNU)-sizeof(MTM))

#define HmnuFromPmtm(pmtm) ((HMNU) pmtm->rgwExtra[pmtm->cwTotal-1])
#define SzFromPmtm(pmtm) ((CHAR *) &(pmtm->rgwExtra[pmtm->u.iwString]))

#endif // SMM

#endif // !NOMENUS

#ifndef	NOPROCS
BOOL		FARPUBLIC FEnableMenuBar	(BOOL);			/*OPTIONAL*/
VOID		FARPUBLIC EnableMenuItem	(WORD, BOOL);	/*OPTIONAL*/
VOID		FARPUBLIC CheckMenuItem		(WORD, BOOL);	/*OPTIONAL*/
BOOL		FARPUBLIC FMenuItemChecked	(WORD);		 	/*OPTIONAL*/
VOID		FARPUBLIC DrawMenubar		(VOID);			/*OPTIONAL*/
VOID		FARPUBLIC SetMenuKeys		(WORD, WORD);	/*OPTIONAL*/
VOID		FARPUBLIC OpenMenu			(WORD);			/*OPTIONAL*/
VOID		FARPUBLIC DeAltMenu			(VOID);			/*MACROS ONLY*/

#ifndef SMM			// Old functions 

VOID		FARPUBLIC InitMenu			(PWND, PMENUBAR);	/*OPTIONAL*/
PMENUITEM	FARPUBLIC FindMenuItem	(WORD);			 	/*OPTIONAL*/
VOID		FARPUBLIC EnableMenu			(WORD, BOOL);		/*OPTIONAL*/

#else // SMM

// Replacements for above 
VOID		FARPUBLIC InitMenubar	(PWND, HMNU, NPARC, WORD);	/*OPTIONAL*/
PMTM		FARPUBLIC PmtmFindId		(HMNU, WORD, BOOL);		 	/*OPTIONAL*/

// New functions 

VOID	FARPUBLIC OpenMenuPopup		(PWND, HMNU, NPARC, BOOL);	/*OPTIONAL*/
HMNU	FARPUBLIC HmnuNewMenu		(void);            			/*OPTIONAL*/
PMTM	FARPUBLIC PmtmAddItem		(HMNU, WORD, WORD, CHAR *, HMNU, WORD, BYTE);	/*OPTIONAL*/
VOID	FARPUBLIC DeleteItem			(HMNU, WORD);					/*OPTIONAL*/
VOID	FARPUBLIC DeleteMenu			(HMNU, BOOL);       			/*OPTIONAL*/
WORD	FARPUBLIC CchGetMenuString	(HMNU, WORD, CHAR *, WORD);/*OPTIONAL*/
VOID	FARPUBLIC AddAccelTable		(MPVKEYID **);					/*OPTIONAL*/
VOID	FARPUBLIC DeleteAccelTable	(MPVKEYID **);					/*OPTIONAL*/

#ifdef BLADE

BOOL FARPUBLIC ProcessMenuAccel ( VOID * ); // VOID * is of type PMSG
VOID FARPUBLIC SetMenuBarWindow ( PVOID );
PWND FARPUBLIC GetMenuBarWindow ( VOID );

#endif

#define   MS_ENABLE  0x0001
#define   MS_CALCARC 0x0002

WORD FARPUBLIC SizeMenubar			(PWND, HMNU, NPARC, WORD);					/*OPTIONAL*/
VOID FARPUBLIC DrawWinMenubar 	( PWND, VOID **, NPARC, WORD, WORD );	/*OPTIONAL*/
VOID FARPUBLIC EnableWinMenubar 	( PWND, VOID **, NPARC, WORD, WORD );	/*OPTIONAL*/

#endif // SMM

#endif	/* !NOPROCS */


#ifndef NOCOLOR
#define	DiMake(dm, isa)		((WORD) ((dm) | (isa)))

/*	-- non-special modes --	*/
#define	dmNormal		0
#define	DiNormal(isa)		((WORD) dmNormal | (isa))
#define	dmText			0x100
#define	dmTextOnly		dmText
#define	dmForeBack		0x200
#define	dmAttrOnly		dmForeBack
#define	dmFore			0x300
#define	dmBack			0x400
#define	dmTextFore		0x500
#define	dmTextBack		0x600

/*	-- special modes --	*/
#define	dmSpecialMin		0x700
#define	dmTextMapB		0x700
#define	dmTextMapF		0x800
#define	dmMapB			0x900
#define	dmMapF			0xA00

#define	dmFfontOnly		0xB00

/* special FFONT control */
#define	fdmKeepFfont	0x8000

#ifdef 	KANJI
/* kanji gridline support */
#define	dmGridOnly		0xC00
#define	fdmKeepGrid		0x4000
#endif	/*KANJI*/

// XOR drawing mode
#define dmXor			0xD00

#endif /*!NOCOLOR*/

extern BYTE PASCAL fMonochrome;		/* TRUE => monochrome screen */
extern char PASCAL chShadow;		/* shadow character */
extern WORD PASCAL diShadow;		/* shadow draw mode, 0 => no shadow */

#ifndef	NOPROCS
VOID		FARPUBLIC SetCursorBlock(BOOL);
VOID		FARPUBLIC SetCursorBlink(BOOL);
VOID		FARPUBLIC RepaintScreen(BOOL);
#endif	/* !NOPROCS */

VOID		FARPUBLIC SetGraphicArc( NPARC, BOOL);



#ifndef NOSUBSTYLES				// Scroll bar constants.
#define	SBS_HORZ			0
#define SBS_VERT			1
#ifdef PROJECT_PWB
#define SBS_TRANSPARENT 		0x10
#endif
#endif

#ifndef NOSCROLL					// Scroll commands.
#define	SB_LINEUP		0
#define	SB_LINEDOWN		1
#define	SB_PAGEUP		2
#define	SB_PAGEDOWN		3
#define	SB_THUMBPOSITION	4
#define	SB_THUMBTRACK	5
#define	SB_TOP			6
#define	SB_BOTTOM		7
#define	SB_ENDSCROLL	8
/* define SB_UPCLICK 15 (private message) */
#endif

#ifndef NOWNDMACROS

DWORD		FARPUBLIC ScrollBarWndProc(PVOID, WORD, WORD, DWORD);

#ifdef CC
#ifndef cwExtraWnd
#define cwExtraWnd 5
#endif /*no extra size*/
#endif /*CC*/

#ifndef BLADE

#ifdef PROJECT_PWB
#define wndScrollBar(id, fVert, fEnabled, ax, ay, dax, day, pwndParent, pwndSibling, ctickRep) { \
	id, WS_CHILD | WS_SCROLL | (fVert ? SBS_VERT : SBS_HORZ), \
	0, fEnabled, 0, {ax, ay, ax+dax, ay+day}, {ax, ay, ax+dax, ay+day}, \
	rrcInvalidStd	\
	(PLFN) ScrollBarWndProc, pwndParent, pwndSibling, NULL, 0, 0, \
	{ctickRep, 0, 0, 1, 1}}

#else

#define wndScrollBar(id, fVert, fEnabled, ax, ay, dax, day, pwndParent, pwndSibling, ctickRep) { \
	id, WS_CHILD | WS_SCROLL | (fVert ? SBS_VERT : SBS_HORZ), \
	0, fEnabled, {ax, ay, ax+dax, ay+day}, {ax, ay, ax+dax, ay+day}, \
	rrcInvalidStd	\
	(PLFN) ScrollBarWndProc, pwndParent, pwndSibling, NULL, 0, 0, \
	{ctickRep, 0, 0, 1, 1}}
#endif

#endif

#endif /* !NOWNDMACROS */

#ifndef	NOPROCS

#ifndef BROADSWORD

short		FARPUBLIC SetScrollPos	(PVOID, short, BOOL);
short		FARPUBLIC GetScrollPos	(PVOID);
VOID		FARPUBLIC SetScrollRange(PVOID, short, short, BOOL);

#else

short		FARPUBLIC SetScrollPos	(PVOID, WORD, short, BOOL);
short		FARPUBLIC GetScrollPos	(PVOID, WORD);
VOID		FARPUBLIC SetScrollRange(PVOID, WORD, short, short, BOOL);
VOID		FARPUBLIC GetScrollRange(PVOID, WORD, short *, short *);

#endif

#endif



/*****************************************************************************/
/* System Specifics */
#ifndef	NOPROCS
VOID		FARPUBLIC DoSound(WORD,WORD);
DWORD		FARPUBLIC ClockTicks(void);
BYTE		FARPUBLIC GetPrinterTimeOut(BYTE);
VOID		FARPUBLIC SetPrinterTimeOut(BYTE,BYTE);
WORD		FARPUBLIC PrinterCmd(BYTE,BYTE,BYTE);
WORD		FARPUBLIC ComCmd(BYTE,BYTE,BYTE);
WORD		FARPUBLIC DtOfChDrive(BYTE);
BOOL		FARPUBLIC FInitSyd(void);
VOID		FARPUBLIC TermSyd(void);
#endif	/* !NOPROCS */

/* DtOfChDrive return values (Note that all valid drive return values must
	be bounded by dtValidMin and dtValidMac and all invalid ones must
	be bounded by dtInvalidMin and dtInvalidMac. */
#define dtValidMin	0x0000
#define dtValidMac	0x0fff
#define dtExist		dtValidMin
#define dtRemoveable	(dtValidMin + 1)
#define dtFixed		(dtValidMin + 2)
#define dtInvalidMin	0x1000
#define dtInvalidMac	0xffff
#define dtNone		dtInvalidMin
#define dtPhantom	(dtInvalidMin + 1)


extern BYTE PASCAL	fSingleFloppy;	/* TRUE => 1 floppy system */
extern BYTE PASCAL	fInt24Error;	/* Set if INT 24 error detected */

/* Sound Facilities */
#ifdef PROJECT_PWB
VOID	FARPUBLIC bell (VOID);	/*OPTIONAL*/
#define Beep()		bell ()
#define Click() 	bell ()
#else
#define	Beep()		DoSound(3,1400)
#define	Click()		DoSound(2,700)
#endif

BOOL		FARPUBLIC FValidDrive(char);

/* File find info; it's the DOS 3 structure, emulated in OS/2. */
typedef struct _fde
	{
	char	reserved[21];	/* MSDOS requires this	*/
	char	atr;		/* File attribute	*/
	WORD	wTime;		/* File time of last write */
	WORD	wDate;		/* File date of last write */
	DWORD	cbFile;		/* File size in bytes	*/
#ifndef OS2
	char	szName[13];	/* File name packed	*/
#else	
	char	szName[256];	/* File name packed	*/
#endif
	} FDE;	/* Find directory entry */

typedef FDE *PFDE;

BOOL		FARPUBLIC FFindFirst(PFDE, char *, WORD);
BOOL		FARPUBLIC FFindNext(PFDE);
BOOL		FARPUBLIC FindClose(void);

BOOL		FARPUBLIC FSetCurDir(char *);
VOID		FARPUBLIC GetCurDir(char, char *);
char		FARPUBLIC GetCurDrive(void);
VOID		FARPUBLIC SetCurDrive(char);
#ifndef NOVIRTUALKEYCODES	
#define	VK_MIN		0x100

#define	VK_LBUTTON	0x101
#define	VK_RBUTTON	0x102
#define	VK_CANCEL	0x103
#define	VK_MBUTTON	0x104	/* NOT contiguous with L & RBUTTON */
#define	VK_BACK		0x108
#define	VK_TAB		0x109
#define	VK_CLEAR	0x10C
#define	VK_RETURN	0x10D
#define	VK_SHIFT	0x110
#define	VK_CONTROL	0x111
#define	VK_ALT		0x112
#define	VK_PAUSE	0x113
#define	VK_CAPLOCK	0x114

/* special VK_s for Kanji and Kana-Kanji conversion */
#define	VK_KANA		0x115
#define	VK_ROMAJI	0x116
#define	VK_ZENKAKU	0x117
#define	VK_HIRAGANA	0x118
#define	VK_KANJI	0x119
/* note: hole for 1A and 1B */
#define	VK_CONVERT	0x11C
#define	VK_NONCONVERT	0x11D
#define	VK_ACCEPT	0x11E
#define	VK_MODECHANGE	0x11F

#define	VK_ESCAPE	0x11B
#define	VK_SPACE	0x120

#define	VK_PRIOR	0x121
#define	VK_NEXT		0x122
#define	VK_END		0x123
#define	VK_HOME		0x124
#define	VK_LEFT		0x125
#define	VK_UP		0x126
#define	VK_RIGHT	0x127
#define	VK_DOWN		0x128

#define	VK_0		0x130
/* 1..8 */
#define	VK_9		0x139
#define	VK_A		0x141
/* B..Y */
#define	VK_Z		0x15A

#define	VK_SELECT	0x129
#define	VK_PRINT	0x12A
#define	VK_EXECUTE	0x12B
#define	VK_INSERT	0x12D
#define	VK_DELETE	0x12E
#define	VK_HELP		0x12F

#define	VK_NUMPAD0	0x160
#define	VK_NUMPAD1	0x161
#define	VK_NUMPAD2	0x162
#define	VK_NUMPAD3	0x163
#define	VK_NUMPAD4	0x164
#define	VK_NUMPAD5	0x165
#define	VK_NUMPAD6	0x166
#define	VK_NUMPAD7	0x167
#define	VK_NUMPAD8	0x168
#define	VK_NUMPAD9	0x169
#define	VK_MULTIPLY	0x16A
#define	VK_ADD		0x16B
#define	VK_SEPARATOR	0x16C
#define	VK_SUBTRACT	0x16D
#define	VK_DECIMAL	0x16E
#define	VK_DIVIDE	0x16F

#define	VK_F1		0x170
#define	VK_F2		0x171
#define	VK_F3		0x172
#define	VK_F4		0x173
#define	VK_F5		0x174
#define	VK_F6		0x175
#define	VK_F7		0x176
#define	VK_F8		0x177
#define	VK_F9		0x178
#define	VK_F10		0x179
#define	VK_F11		0x17A
#define	VK_F12		0x17B
#define	VK_F13		0x17C
#define	VK_F14		0x17D
#define	VK_F15		0x17E
#define	VK_F16		0x17F

#define VK_OAX		0x180

#define	VK_NUMLOCK	0x190
#define	VK_SCRLOCK	0x191

#define VK_RESIZE	0x1A0

/* alternative names */
#define	VK_MENU		VK_ALT
#define	VK_CAPITAL	VK_CAPLOCK
#define	VK_OEM_NUMBER	VK_NUMLOCK
#define	VK_OEM_SCROLL	VK_SCRLOCK
#define	VK_SEPARATER	VK_SEPARATOR

#endif /*!NOVIRTUALKEYCODES*/	

#ifndef	NOPROCS
BOOL		FARPUBLIC FIsDbcsChar(ACHAR);		/* OPTIONAL */
WORD		FARPUBLIC CchLenDbcs(unsigned char *);		/* OPTIONAL */
char *		FARPUBLIC PchNextDbcs(unsigned char *);		/* OPTIONAL */
char *		FARPUBLIC PchPrevDbcs(unsigned char *, unsigned char *);	/* OPTIONAL */
WORD		FARPUBLIC CtOfDbcsChar(unsigned char *, unsigned char *);	/* OPTIONAL */
WORD		FARPUBLIC CtOfDbcsCharX(unsigned char far *, unsigned char far *);	/* OPTIONAL */
#endif	/* !NOPROCS */


/* Character Types */
#define	ctSNG	0	/* single byte character */
#define	ctDB1	1	/* 1st byte of double byte character */
#define	ctDB2	2	/* 2nd byte of double byte character */


#define	SetSysColor(isa, coBack, coFore, fBlink, fHilite) \
	SetIsaColor(isa,				\
 	    (coFore) + ((fHilite) ? 8 : 0),	\
 	    (coBack) + ((fBlink) ? 8 : 0))

#ifndef	NOPROCS
VOID		FARPUBLIC SetIsaColor(ISA, WORD, WORD);
VOID		FARPUBLIC GetIsaColor(ISA, WORD *, WORD *);
VOID		FARPUBLIC SetIsaRgca(ISA, BYTE *);
VOID		FARPUBLIC SetIsaFfont(ISA, FFONT);		/*OPTIONAL*/
# ifdef KANJI
FFONT		FARPUBLIC GetIsaFfont(ISA);			/*OPTIONAL*/
# endif /* KANJI */
#endif	/* !NOPROCS */



// LszPromptSwapDisk 

#define	rpsdNULL	-1
#define	rpsdNotFound	1
#define	rpsdLocked	2
#define	rpsdLoadError	3


// RspAppIdle 

#define	rspSleep	1			// sleep some more 
#define	rspContinue	2		// check for new events 
#define	rspAbort	3			// abort from the current context 

#define	cnxNull		0		// context is not given 

#define	cnxMenu		1		// context is Menu 
#define	cnxDialog	2		// context is Dialog 
#define	cnxMBox		3		// context is Message Box 

#define	cnxMacro		4		// context is Key Macro library 
#define	cnxVAP		5		// context is VAP interface 

#define	cnxMoveSize	6		// context is overlap window move/size 


#ifndef NOPROCS

CHAR FAR *	FARPUBLIC LszPromptSwapDisk(char far *, WORD, WORD);	/* OPTIONAL */
WORD		FARPUBLIC RspAppIdle(WORD, DWORD);		/* OPTIONAL */
BOOL		FARPUBLIC FHelpMsg(PMSG, WORD);		/* OPTIONAL */
VOID		FARPUBLIC MoveSizeOOM(PWND);

#endif



/* CPD_STRUCTURE: as yet undocumented CPD structure */
typedef	void	CPD_STRUCTURE;		//REVIEW: define and document this !


/*****************************************************************************/
/* default machine data group/element ID code */
#define mdEidDir	0			/* directory element (all) */

#define mdGidGeneral	0			/* general group */
#define mdEidGenName	1			/* machine name element */

#define mdGidScreen	1			/* screen group */

#define mdGidKey	2			/* key group */

/*****************************************************************************/
/* System Specifics */
#ifndef	NOPROCS
BOOL		FARPUBLIC FInitMachineDataMdd(VOID);	/*OPTIONAL*/
WORD		FARPUBLIC CbMachineDataMdd(BYTE, BYTE); /*OPTIONAL*/
WORD		FARPUBLIC CbGetMachineDataMdd(BYTE, BYTE, WORD, BYTE FAR *);/*OPTIONAL*/
#endif	/* !NOPROCS */


#define	sopsFreeze	0
#define	sopsThaw		1

#define	serrOk		0
#define	serrNoMem	1
#define	serrBadSops	2

typedef	struct _csdc
	{
	WORD	cFreeze;
	WORD	psPrimOld;			/* old primary screen buffer */
	BYTE	axCursCur;
	BYTE	ayCursCur;
	VOID FAR *	lpfnFInit;
	VOID FAR *	lpfnMoveHwCurs;
	VOID FAR *	lpfnPrepUpdate;
	VOID FAR *	lpfnDoUpdate;
	VOID FAR *	lpfnDoneUpdate;
	VOID FAR *	lpfnBltArc;
	} CSDC;

WORD	FARPUBLIC	SerrScreenCtrl(WORD, CSDC FAR *, VOID FAR *);


/*****************************************************************************/
/* Pseudo Printer Specifics */
#ifndef	NOPROCS
WORD		FARPUBLIC RerrLoadPpd(char *);			/*OPTIONAL*/
VOID		FARPUBLIC FreePpd(void);			/*OPTIONAL*/
BOOL		FARPUBLIC FInitPpd(DWORD);			/*OPTIONAL*/
VOID		FARPUBLIC TermPpd(VOID);			/*OPTIONAL*/
BOOL		FARPUBLIC FPrintChPpd(WORD);			/*OPTIONAL*/
#endif	/* !NOPROCS */


/*****************************************************************************/
/* KKC Interface specifics (OPTIONAL) */

/* kkret = KK converter return value */

#define	kkretSuccess		0
#define	kkretFailure		(-1)
#define	kkretThrough		1

/* kkpos = Conversion position */

#define	kkposFree		0
#define	kkposStatus		1
#define	kkposCursor		2

/* Structure to communicate with KID */

#define	cbReservedKkcv		34

typedef struct _kkcv
	{
	WORD		wType;			/* Data type of wAscii */
	WORD		wScan;			/* Key scan code */
	WORD		wAscii;			/* Ascii code */
	WORD		wShift;			/* Shift key status */
	WORD		wExShift;		/* Extended Shift key status */

	WORD		cchResult;		/* Length of Result string */
	CHAR FAR *	lpchResult;		/* Pointer to Result string buffer */

	WORD		cchMode;		/* Length of Mode string */
	CHAR FAR *	lpchMode;		/* Pointer to Mode string buffer */
	CHAR FAR *	lpattrMode;		/* Pointer to Mode attribute buffer */

	WORD		cchSystem;		/* Length of System string */
	CHAR FAR *	lpchSystem;		/* Pointer to System string buffer */
	CHAR FAR *	lpattrSystem;	/* Pointer to System attribute buffer */

	WORD		cchBuf;			/* Length of Display string */
	CHAR FAR *	lpchBuf;		/* Pointer to Display string buffer */
	CHAR FAR *	lpattrBuf;		/* Pointer to Display attribute buffer*/
	WORD		cchBufCursor;	/* Cursor position in Display buffer */                                                                                 
	CHAR		rgbReserved[cbReservedKkcv];
	} KKCV;	/* KK Converter interface structure */


#ifndef NOPROCS
int		FARPUBLIC KKOpen(KKCV FAR *);			/*OPTIONAL*/
int		FARPUBLIC KKClose(VOID);				/*OPTIONAL*/
int		FARPUBLIC KKJoin(KKCV FAR *);			/*OPTIONAL*/
int		FARPUBLIC KKFree(VOID);					/*OPTIONAL*/
int		FARPUBLIC KKInOut(KKCV FAR *);			/*OPTIONAL*/
int		FARPUBLIC KKPosGet(VOID);				/*OPTIONAL*/
int		FARPUBLIC KKPosSet(KKCV FAR *, WORD);	/*OPTIONAL*/
BOOL	FARPUBLIC FKKMode(void);				/*OPTIONAL*/
int		FARPUBLIC KKSetMode(KKCV FAR *, BOOL);	/*OPTIONAL*/
#endif /* !NOPROCS */


#ifdef TRACES_ENABLED

// leave space for null at end 
#define cchWord		7

/* tag structure */
#define cchTagId	12
#define cchOwner	12
#define cchDesc		36

#define FTAG		WORD

typedef struct _tag
	{
	WORD	id;
	CHAR	szTagId[cchTagId];
	CHAR	szOwner[cchOwner];
	CHAR	szDesc[cchDesc];
	FTAG	ftag;
	} TAG;

#define LPTAG		TAG  FAR *
#define LSZ			CHAR FAR *

// CW-defined ftags (the rest are for application use) 

#define ftagMaskOn	0x00ff
#define ftagRegistered	0x8000

// data passed to application for trace 
typedef struct _tod
	{
	LPTAG		lptag;
	LSZ		lsz;
	LONG		lParam;
	} TOD;

#ifndef NO_PROCS

VOID FARPUBLIC InitCWTraceTags(VOID);			 /*OPTIONAL*/
PWND FARPUBLIC PwndSetPwndTrace(PWND);			 /*OPTIONAL*/
VOID FARPUBLIC TraceTagRegister(LPTAG, WORD); /*OPTIONAL*/
VOID FARPUBLIC CWTrace(LPTAG, LSZ, LONG);		 /*OPTIONAL*/
VOID FARPUBLIC AppendSzToSz(CHAR *, CHAR **); /*OPTIONAL*/

#endif

// tracing on/off 
extern PWND PASCAL	pwndTrace;

#define FTracingOn()	(pwndTrace != NULL)

#define FTraceTagOn(tag) \
			(FTracingOn() && ((tag).ftag & ftagMaskOn))
#define FTraceTagRegistered(tag) \
			((tag).ftag & ftagRegistered)

// full tracing macros 

// LGT: Trace renamed to CWTraceMacro
#define CWTraceMacro(tag) \
			if (FTraceTagOn(tag)) CWTrace((LPTAG) &(tag), NULL, 0L)

#define TraceSz(tag, sz) \
			if (FTraceTagOn(tag)) CWTrace((LPTAG) &(tag),	\
							(LSZ) sz, 0L)

#define TraceAssert(fCond, tag, sz) \
	 		if (FTraceTagOn(tag) && fCond)			\
				CWTrace((LPTAG) &(tag), (LSZ) sz, 0L)

#define TraceWord(tag, wParam)  \
			if (FTraceTagOn(tag))				\
				{					\
				CHAR	szWord[cchWord];		\
				SzFromInt(szWord, wParam);		\
				CWTrace((LPTAG) &(tag), (LSZ) szWord,	\
							(LONG) wParam);	\
				}

#define BeginTraceSz(tag) \
			if (FTraceTagOn(tag))				\
				{					\
				CHAR	_szTrace[cchSzTrace];		\
				CHAR *	_pchEnd = _szTrace;

// MUST exist only within BeginTraceSz and EndTraceSz 

#define AppendSzToSzTrace(sz) \
				AppendSzToSz(sz, &_pchEnd)

#define AppendWordToSzTrace(wParam, fform) \
				SzFromInt(_pchEnd, wParam);		\
				_pchEnd += cchWord;

/* MUST follow previous BeginTraceSz() "call" */
#define EndTraceSz(tag) \
				Assert(_pchEnd - _szTrace < cchSzTrace);\
				CWTrace((LPTAG) &(tag), (LSZ) _szTrace, 0L);\
				}

#define DoBenchMark(tag, stmt) \
			{						\
			LONG	lTimeStart;				\
			WORD	wTimeElapsed;				\
			lTimeStart = ClockTicks();			\
			stmt;						\
			wTimeElapsed = (WORD) (ClockTicks() - lTimeStart); \
			TraceWord(tag, wTimeElapsed);			\
			}

#define Repeat(stmt, crep) \
			{ 						\
			REGISTER WORD	irep;				\
			for (irep = 0; irep < crep; irep++)		\
				stmt;					\
			}

#else	// TRACES_ENABLED 

#define InitCWTraceTags()
#define PwndSetPwndTrace(pwnd)
#define TraceTagRegister(rgtag, ctag)

// LGT: Trace renamed to CWTraceMacro
#define CWTraceMacro(tag)

#define TraceSz(tag, sz)
#define TraceAssert(fCond, tag, sz)
#define TraceWord(tag, wParam, fform)
#define BeginTraceSz(tag)
#define AddSzToTraceSz(sz)
#define AddWordToTraceSz(sz)
#define EndTraceSz(tag)
#define DoBenchMark(tag, stmt)
#define Repeat(stmt, crep)

#endif	// !TRACES_ENABLED 


/* Public variables for kkc filter */

extern BOOL PASCAL fKkcAvailable;	/* TRUE -> kkif drv. initialized */
extern BOOL PASCAL fKkcEnabled;		/* TRUE -> kkc enabled */
extern KKCV PASCAL kkcv;			/* Common area for kid and kkc filter */
extern BOOL PASCAL fKkcMessage;		/* TRUE -> converted string pending */


/* kkc filter mode */

#define	kkmodeNil		0
#define	kkmodeLYR		1		/* layer displays undetermined string */
#define	kkmodeAPP		2		/* ap displays undetermined string */


#ifndef NOPROCS
BOOL FARPUBLIC FInitKkc(PWND);			/*OPTIONAL*/
VOID FARPUBLIC TermKkc(VOID);			  	/*OPTIONAL*/
BOOL FARPUBLIC SetModeKkc(WORD);		  	/*OPTIONAL*/
BOOL FARPUBLIC FSuspendKkc(BOOL);	  	/*OPTIONAL*/
BOOL FARPUBLIC FEnableKkc(BOOL);		  	/*OPTIONAL*/
BOOL FARPUBLIC FActivateKkc(BOOL);	  	/*OPTIONAL*/
BOOL FARPUBLIC FActiveKkc(VOID);		  	/*OPTIONAL*/
BOOL FARPUBLIC FSetPosKkc(WORD);		  	/*OPTIONAL*/
BOOL FARPUBLIC GetPosKkc(VOID);		  	/*OPTIONAL*/
BOOL FARPUBLIC FFlushKkc(VOID);		  	/*OPTIONAL*/
VOID FARPUBLIC SetWindowKkc(PRRC);	  	/*OPTIONAL*/
VOID FARPUBLIC SetCursorKkc(RX, RY);  	/*OPTIONAL*/
VOID FARPUBLIC TextOutAttrX(PWND, RX, RY, PRRC, CHAR FAR *, CHAR FAR *, short, short); 	/*OPTIONAL*/
#endif /* !NOPROCS */


char * FARPUBLIC SzDirSpec			(char *, char *, BOOL *);
VOID 	 FARPUBLIC SetCurrentPath	(char *);
VOID	 FARPUBLIC MakeDirName		(char *, char *);

BOOL	FARPUBLIC  FCorrectDriveDir	(char *);
char * FARPUBLIC SzChopText			(PVOID, char * );
char * FARPUBLIC SzWildCard			( char * );

VOID	FARPUBLIC  DlgDirList		( PVOID, char *, PVOID, BOOL, PVOID );
BOOL	FARPUBLIC  DlgDirSelect		( PVOID, char *, PVOID );
BOOL	FARPUBLIC  FMaybeDir			( char *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\extend.h ===
/*----------------------------------------------------------------------*/
/*                                  TIGA                                */
/*  Copyright (C) 1988-1990  Texas Instruments  All Rights Reserved.    */
/*----------------------------------------------------------------------*/
/*  TIGA 2-D Graphics Library include file                              */
/*----------------------------------------------------------------------*/
/*                                                                      */
/*  file            extend.h                                            */
/*                                                                      */
/*  description     This file contains references to functions contained*/
/*                  in the TIGA 2-D Graphics Library.  It must be       */
/*                  included in any Microsoft 'C' application which     */
/*                  calls a graphics library function.                  */
/*                                                                      */
/*                  Note that the tiga.h header file must be included   */
/*                  before this header file.                            */
/*                                                                      */
/*----------------------------------------------------------------------*/
                                                                        
/*----------------------------------------------------------------------*/
/*  Extended function Command Numbers                                   */
/*----------------------------------------------------------------------*/
#define SET_DSTBM           EXT_CP( 0)
#define SET_SRCBM           EXT_CP( 1)
#define STYLED_LINE         EXT_CP( 2)
#define SWAP_BM             EXT_CP( 3)
#define DRAW_POLYLINE_A     EXT_CP( 4)
#define FILL_CONVEX_A       EXT_CP( 5)
#define FILL_POLYGON_A      EXT_CP( 6)
#define PATNFILL_CONVEX_A   EXT_CP( 7)
#define PATNFILL_POLYGON_A  EXT_CP( 8)
#define PATNPEN_POLYLINE_A  EXT_CP( 9)
#define PEN_POLYLINE_A      EXT_CP(10)
#define BITBLT              EXT_DM(11)
#define DRAW_LINE           EXT_DM(12)
#define DRAW_OVAL           EXT_DM(13)
#define DRAW_OVALARC        EXT_DM(14)
#define DRAW_PIEARC         EXT_DM(15)
#define DRAW_POINT          EXT_DM(16)
#define DRAW_POLYLINE       EXT_DM(17)
#define DRAW_RECT           EXT_DM(18)
#define FILL_CONVEX         EXT_DM(19)
#define FILL_OVAL           EXT_DM(20)
#define FILL_PIEARC         EXT_DM(21)
#define FILL_POLYGON        EXT_DM(22)
#define FILL_RECT           EXT_DM(23)
#define FRAME_OVAL          EXT_DM(24)
#define FRAME_RECT          EXT_DM(25)
#define GET_PIXEL           EXT_DM(26)
#define PATNFILL_CONVEX     EXT_DM(27)
#define PATNFILL_OVAL       EXT_DM(28)
#define PATNFILL_PIEARC     EXT_DM(29)
#define PATNFILL_POLYGON    EXT_DM(30)
#define PATNFILL_RECT       EXT_DM(31)
#define PATNFRAME_OVAL      EXT_DM(32)
#define PATNFRAME_RECT      EXT_DM(33)
#define PATNPEN_LINE        EXT_DM(34)
#define PATNPEN_OVALARC     EXT_DM(35)
#define PATNPEN_PIEARC      EXT_DM(36)
#define PATNPEN_POINT       EXT_DM(37)
#define PATNPEN_POLYLINE    EXT_DM(38)
#define PEN_LINE            EXT_DM(39)
#define PEN_OVALARC         EXT_DM(40)
#define PEN_PIEARC          EXT_DM(41)
#define PEN_POINT           EXT_DM(42)
#define PEN_POLYLINE        EXT_DM(43)
#define SEED_FILL           EXT_DM(44)
#define SEED_PATNFILL       EXT_DM(45)
#define SET_DRAW_ORIGIN     EXT_DM(46)
#define SET_PENSIZE         EXT_DM(47)
#define ZOOM_RECT           EXT_DM(48)
#define SET_PATN            EXT_DM(49)
#define INSTALL_FONT        EXT_CP(50)
#define SELECT_FONT         EXT_CP(51)
#define DELETE_FONT         EXT_CP(52)
#define SET_TEXTATTR        EXT_CP(53)
#define GET_TEXTATTR        EXT_CP(54)
#define TEXT_WIDTH          EXT_CP(55)
#define GET_ENV             EXT_CP(56)
#define DECODE_RECT         EXT_CP(57)
#define ENCODE_RECT         EXT_CP(58)
#define MOVE_PIXEL          EXT_DM(59)
#define PUT_PIXEL           EXT_DM(60)
#define STYLED_OVAL         EXT_DM(61)
#define STYLED_OVALARC      EXT_DM(62)
#define STYLED_PIEARC       EXT_DM(63)
#define IN_FONT             EXT_CP(64)
                                     
/*----------------------------------------------------------------------*/
/*  C-Packet function definitions                                       */
/*----------------------------------------------------------------------*/
#define set_dstbm(a,b,c,d,e)        \
        cp_cmd(SET_DSTBM,5,_DWORD(a),_WORD(b),_WORD(c),_WORD(d),_WORD(e))
#define set_srcbm(a,b,c,d,e)        \
        cp_cmd(SET_SRCBM,5,_DWORD(a),_WORD(b),_WORD(c),_WORD(d),_WORD(e))
#define styled_line(a,b,c,d,e,f)    \
        cp_cmd(STYLED_LINE,6,_SWORD(a),_SWORD(b),_SWORD(c),_SWORD(d),_DWORD(e),_WORD(f))
#define swap_bm()                   \
        cp_cmd(SWAP_BM,0)
#define draw_polyline_a(a,b)        \
        cp_cmd_a(DRAW_POLYLINE_A,2,_WORD(a),_WORD_PTR(2*(a),b))
#define fill_convex_a(a,b)          \
        cp_cmd_a(FILL_CONVEX_A,2,_WORD(a),_WORD_PTR(2*(a),b))
#define fill_polygon_a(a,b)         \
        cp_cmd_a(FILL_POLYGON_A,2,_WORD(a),_WORD_PTR(2*(a),b))
#define patnfill_convex_a(a,b)      \
        cp_cmd_a(PATNFILL_CONVEX_A,2,_WORD(a),_WORD_PTR(2*(a),b))
#define patnfill_polygon_a(a,b)     \
        cp_cmd_a(PATNFILL_POLYGON_A,2,_WORD(a),_WORD_PTR(2*(a),b))
#define patnpen_polyline_a(a,b)     \
        cp_cmd_a(PATNPEN_POLYLINE_A,2,_WORD(a),_WORD_PTR(2*(a),b))
#define pen_polyline_a(a,b)         \
        cp_cmd_a(PEN_POLYLINE_A,2,_WORD(a),_WORD_PTR(2*(a),b))
#define install_font(a)             \
        (short)cp_ret(INSTALL_FONT,1,_DWORD(a))
#define select_font(a)              \
        (short)cp_ret(SELECT_FONT,1,_WORD(a))
#define delete_font(a)              \
        (short)cp_ret(DELETE_FONT,1,_WORD(a))
#define set_textattr(a,b,c)         \
        (short)cp_ret(SET_TEXTATTR,3,_STRING(a),_WORD(b),_WORD_PTR(b,c))
#define get_textattr(a,b,c)         \
        (short)cp_alt(GET_TEXTATTR,3,_STRING(a),_WORD(b),_ALTWORD_PTR(b,c))
#define text_width(a)               \
        (short)cp_ret(TEXT_WIDTH,1,_STRING(a))
#define get_env(a)                  \
        (void)cp_alt(GET_ENV,1,_ALTBYTE_PTR(sizeof(ENVIRONMENT),a))
#define decode_rect(a,b,c)          \
        (short)cp_ret(DECODE_RECT,3,_WORD(a),_WORD(b),_DWORD(c))
#define encode_rect(a,b,c,d,e,f,g)  \
        cp_ret(ENCODE_RECT,7,_WORD(a),_WORD(b),_WORD(c),_WORD(d),   \
                             _DWORD(e),_DWORD(f),_WORD(g))
#define in_font(a,b)                \
        (short)cp_ret(IN_FONT,2,_WORD(a),_WORD(b))

/*----------------------------------------------------------------------*/
/*  Direct-Mode function defintions                                     */
/*----------------------------------------------------------------------*/
#define bitblt(a,b,c,d,e,f)         \
        dm_cmd(BITBLT,6,(short)(a),(short)(b),(short)(c),\
                             (short)(d),(short)(e),(short)(f))
#define draw_line(a,b,c,d)          \
        dm_cmd(DRAW_LINE,4,(short)(a),(short)(b),(short)(c),(short)(d))
#define draw_oval(a,b,c,d)          \
        dm_cmd(DRAW_OVAL,4,(short)(a),(short)(b),(short)(c),(short)(d))
#define draw_ovalarc(a,b,c,d,e,f)   \
        dm_cmd(DRAW_OVALARC,6,(short)(a),(short)(b),(short)(c), \
                             (short)(d),(short)(e),(short)(f))
#define draw_piearc(a,b,c,d,e,f)    \
        dm_cmd(DRAW_PIEARC,6,(short)(a),(short)(b),(short)(c), \
                             (short)(d),(short)(e),(short)(f))
#define draw_point(a,b)             \
        dm_cmd(DRAW_POINT,2,(short)(a),(short)(b))
#define draw_polyline(a,b)          \
        dm_psnd(DRAW_POLYLINE,(short)(4*(a)),(short far *)(b))
#define draw_rect(a,b,c,d)          \
        dm_cmd(DRAW_RECT,4,(short)(a),(short)(b),(short)(c),(short)(d))
#define fill_convex(a,b)            \
        dm_psnd(FILL_CONVEX,(short)(4*(a)),(short far *)b)
#define fill_oval(a,b,c,d)          \
        dm_cmd(FILL_OVAL,4,(short)(a),(short)(b),(short)(c),(short)(d))
#define fill_piearc(a,b,c,d,e,f)    \
        dm_cmd(FILL_PIEARC,6,(short)(a),(short)(b),(short)(c), \
                             (short)(d),(short)(e),(short)(f))
#define fill_polygon(a,b)           \
        dm_psnd(FILL_POLYGON,(short)(4*(a)),(short far *)(b))
#define fill_rect(a,b,c,d)          \
        dm_cmd(FILL_RECT,4,(short)(a),(short)(b),(short)(c),(short)(d))
#define frame_oval(a,b,c,d,e,f)     \
        dm_cmd(FRAME_OVAL,6,(short)(a),(short)(b),(short)(c), \
                             (short)(d),(short)(e),(short)(f))
#define frame_rect(a,b,c,d,e,f)     \
        dm_cmd(FRAME_RECT,6,(short)(a),(short)(b),(short)(c), \
                             (short)(d),(short)(e),(short)(f))
#define get_pixel(a,b)              \
        dm_ret(GET_PIXEL,2,(short)(a),(short)(b))
#define patnfill_convex(a,b)        \
        dm_psnd(PATNFILL_CONVEX,4*(a),(short far *)b)
#define patnfill_oval(a,b,c,d)      \
        dm_cmd(PATNFILL_OVAL,4,(short)(a),(short)(b),(short)(c),(short)(d))
#define patnfill_piearc(a,b,c,d,e,f)\
        dm_cmd(PATNFILL_PIEARC,6,(short)(a),(short)(b),(short)(c), \
                             (short)(d),(short)(e),(short)(f))
#define patnfill_polygon(a,b)       \
        dm_psnd(PATNFILL_POLYGON,(short)(4*(a)),(short far *)(b))
#define patnfill_rect(a,b,c,d)      \
        dm_cmd(PATNFILL_RECT,4,(short)(a),(short)(b),(short)(c),(short)(d))
#define patnframe_oval(a,b,c,d,e,f) \
        dm_cmd(PATNFRAME_OVAL,6,(short)(a),(short)(b),(short)(c), \
                             (short)(d),(short)(e),(short)(f))
#define patnframe_rect(a,b,c,d,e,f) \
        dm_cmd(PATNFRAME_RECT,6,(short)(a),(short)(b),(short)(c), \
                             (short)(d),(short)(e),(short)(f))
#define patnpen_line(a,b,c,d)       \
        dm_cmd(PATNPEN_LINE,4,(short)(a),(short)(b),(short)(c),(short)(d))
#define patnpen_ovalarc(a,b,c,d,e,f)\
        dm_cmd(PATNPEN_OVALARC,6,(short)(a),(short)(b),(short)(c), \
                             (short)(d),(short)(e),(short)(f))
#define patnpen_piearc(a,b,c,d,e,f) \
        dm_cmd(PATNPEN_PIEARC,6,(short)(a),(short)(b),(short)(c), \
                             (short)(d),(short)(e),(short)(f))
#define patnpen_point(a,b)          \
        dm_cmd(PATNPEN_POINT,2,(short)(a),(short)(b))
#define patnpen_polyline(a,b)       \
        dm_psnd(PATNPEN_POLYLINE,(short)(4*(a)),(short far *)(b))
#define pen_line(a,b,c,d)           \
        dm_cmd(PEN_LINE,4,(short)(a),(short)(b),(short)(c),(short)(d))
#define pen_ovalarc(a,b,c,d,e,f)    \
        dm_cmd(PEN_OVALARC,6,(short)(a),(short)(b),(short)(c), \
                             (short)(d),(short)(e),(short)(f))
#define pen_piearc(a,b,c,d,e,f)     \
        dm_cmd(PEN_PIEARC,6,(short)(a),(short)(b),(short)(c), \
                             (short)(d),(short)(e),(short)(f))
#define pen_point(a,b)              \
        dm_cmd(PEN_POINT,2,(short)(a),(short)(b))
#define pen_polyline(a,b)           \
        dm_psnd(PEN_POLYLINE,(short)(4*(a)),(short far *)(b))
#define seed_fill(a,b,c,d)          \
        dm_cmd(SEED_FILL,5,(short)(a),(short)(b),(long)(c),(short)(d))
#define seed_patnfill(a,b,c,d)      \
        dm_cmd(SEED_PATNFILL,5,(short)(a),(short)(b),(long)(c),(short)(d))
#define set_draw_origin(a,b)        \
        dm_cmd(SET_DRAW_ORIGIN,2,(short)(a),(short)(b))
#define set_pensize(a,b)            \
        dm_cmd(SET_PENSIZE,2,(short)(a),(short)(b))
#define zoom_rect(a,b,c,d,e,f,g,h,i)\
        dm_cmd(ZOOM_RECT,10,(short)(a),(short)(b),(short)(c), \
                              (short)(d),(short)(e),(short)(f), \
                              (short)(g),(short)(h),(long)(i))
#define set_patn(a)                 \
        dm_psnd(SET_PATN,(short)(sizeof(PATTERN)),(char far *)(a))
#define move_pixel(a,b,c,d)         \
        dm_cmd(MOVE_PIXEL,4,(short)(a),(short)(b),(short)(c),(short)(d))
#define put_pixel(a,b,c)            \
        dm_cmd(PUT_PIXEL,4,(unsigned long)(a),(short)(b),(short)(c))
#define styled_oval(a,b,c,d,e,f)    \
        dm_cmd(STYLED_OVAL,7,(short)(a),(short)(b),(short)(c),(short)(d), \
                             (unsigned long)(e),(short)(f))
#define styled_ovalarc(a,b,c,d,e,f,g,h) \
        dm_cmd(STYLED_OVALARC,9,(short)(a),(short)(b),(short)(c),(short)(d), \
                (short)(e),(short)(f),(unsigned long)(g),(short)(h))
#define styled_piearc(a,b,c,d,e,f,g,h)  \
        dm_cmd(STYLED_PIEARC, 9,(short)(a),(short)(b),(short)(c),(short)(d), \
                (short)(e),(short)(f),(unsigned long)(g),(short)(h))




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\diskinfo.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * DISKINFO.C - Source file for obtaining disk drive information.
 ********************************************************************/


/* Include Files */

#include "msd.h"


/*********************************************************************
 * GetDiskInfo - Gets the disk information.
 *
 * pDisk        - Pointer to disk information structure.
 * fMinimumInfo - TRUE if minimum info is requested.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetDiskInfo (DISK_STRUCT *pDisk, BOOL fMinimumInfo)
{
  BYTE  i;                      /* Looping variable                       */
  BYTE  bCurrentDrive;          /* Stores the current drive number        */
  BYTE  bLastDrive;             /* Last drive number in the system        */
  WORD  wDriveIndex;            /* Index to the table of drive info       */
  union REGS inregs, outregs;   /* Register structures for int86() calls  */
  struct SREGS sregs;           /* Segment registers for int86x() calls   */
  BOOL  fSingleFloppy;          /* TRUE if there is only one floppy drive */
  BOOL  fSkipSizeTest;          /* TRUE if size test should be skipped    */
  BOOL  fUseBiosCall = TRUE;    /* IOCTL 0Dh failed, use BIOS call        */
  BYTE FAR *fbSingleFloppyIsB = (BYTE FAR *) 0x00400104;
                                /* if on a single floppy system, this     */
                                /*   byte is == 1 if the floppy is acting */
                                /*   as drive B:                          */
  WORD  wDosVersion;            /* DOS Version (ie 3.30 == 330)           */
  WORD  wDriveType;             /* Local variable for drive type          */
  WORD  wNmbrFloppies = 0;      /* Number of floppies (for INT 13h)       */
  WORD  wNmbrFixedDisks = 0;    /* Number of hard disks (for INT 13h)     */


  /* Set the local DOS version variable */
  wDosVersion = wDosMajor * 100 + wDosMinor;


  /* Zero out the disk drive information structure */
  memset (pDisk, '\0', sizeof (DISK_STRUCT));


  /* Get the list of installed programs and data */
  if (fMinimumInfo == FALSE)
    GetDiskProgList (pDisk, wDosVersion);


  /* Determine the number of physical floppies in the A:-B: range */

  int86 (0x11, &inregs, &outregs);

  /* Bit 0 is a flag indicating if floppies are present.  If set, */
  /*   bits 6-7 show the count of floppies in the system.         */

  if ((outregs.x.ax & 0x0001) && (outregs.x.ax & 0x00C0) == 0x0000)
    fSingleFloppy = TRUE;
  else
    fSingleFloppy = FALSE;


  /* Store the current drive number */
  bCurrentDrive = DosGetCurrentDrive();
  pDisk->chCurrentDrive = (CHAR) (bCurrentDrive + 'A');

  /* Determine the last valid drive to check */
  bLastDrive = DosSetCurrentDrive (bCurrentDrive);
  pDisk->chLastDrive = (CHAR) (bLastDrive + 'A' - 1);


  /* Begin counting up the valid drives */

  for (i = 0; i < bLastDrive; ++i)
    if (ValidDrive (i))
      {
        /* Default to performing the size test */
        fSkipSizeTest = FALSE;


        /* If this is a single floppy, and it's acting as B: */
        /*   skip the A: check.                              */

        if (fSingleFloppy && *fbSingleFloppyIsB == 1 && i == 0)
          continue;


        /* If this is a single floppy, and it's acting as A: */
        /*   skip the B: check.                              */

        if (fSingleFloppy && *fbSingleFloppyIsB != 1 && i == 1)
          continue;


        /* Bump the count of valid drives */
        wDriveIndex = (WORD) (pDisk->wNmbrDrives)++;

        /* Store the drive letter of the valid drive */
        pDisk->asdi[wDriveIndex].chDriveLetter = (CHAR) (i + 'A');


        /* Check to see if drives are removable or not */

        inregs.x.ax = 0x4408;
        inregs.h.bl = (BYTE) (i + 1);
        int86 (0x21, &inregs, &outregs);

        /* CF is clear if IOCTL call was successful */
        if (outregs.x.cflag == 0)
          {
            /* AX == 0000h means it's a removable drive */
            if (outregs.x.ax == 0x0000)
              {
                pDisk->asdi[wDriveIndex].wDriveType = DISK_FLOPPY_DRIVE;
                strcpy (pDisk->asdi[wDriveIndex].szDriveType,
                        paszDriveTypes[DISK_FLOPPY_DRIVE]);
              }
            else
              {
                pDisk->asdi[wDriveIndex].wDriveType = DISK_FIXED_DISK;
                strcpy (pDisk->asdi[wDriveIndex].szDriveType,
                        paszDriveTypes[DISK_FIXED_DISK]);
              }
          }
        else
          {
            /* Something went wrong.  If this is DOS 3.0 assume */
            /*   it as a "Remote Drive"                         */

            if (wDosVersion == 300)
              {
                pDisk->asdi[wDriveIndex].wDriveType = DISK_REMOTE_DRIVE;
                strcpy (pDisk->asdi[wDriveIndex].szDriveType,
                        paszDriveTypes[DISK_REMOTE_DRIVE]);
              }
          }


        /* If this is DOS 3.1 or better, we can tell for sure if it's */
        /*   a remote drive.                                          */

        if (wDosVersion >= 310)
          {
            inregs.x.ax = 0x4409;
            inregs.h.bl = (BYTE) (i + 1);
            int86 (0x21, &inregs, &outregs);

            /* CF is clear if IOCTL call was successful */
            if (outregs.x.cflag == 0)
              {
                if (outregs.x.dx & 0x8000)
                  {
                    /* Drive is SUBSTutited */
                    pDisk->asdi[wDriveIndex].wDriveType = DISK_SUBST_DRIVE;
                    strcpy (pDisk->asdi[wDriveIndex].szDriveType,
                            paszDriveTypes[DISK_SUBST_DRIVE]);
                    pDisk->fSubstInstalled = TRUE;
                  }
                else if (outregs.x.dx & 0x1000)
                  {
                    /* Check to see if this is a MSCDEX CD-ROM drive */
                    inregs.x.ax = 0x150B;
                    inregs.x.cx = i;
                    int86 (0x2F, &inregs, &outregs);

                    if (outregs.x.bx == 0xADAD && outregs.x.ax != 0x0000)
                      {
                        /* Drive is a CD-ROM drive */
                        pDisk->asdi[wDriveIndex].wDriveType =
                            DISK_CD_ROM_DRIVE;
                        strcpy (pDisk->asdi[wDriveIndex].szDriveType,
                                paszDriveTypes[DISK_CD_ROM_DRIVE]);
                      }
                    else
                      {
                        /* Drive is remote */
                        pDisk->asdi[wDriveIndex].wDriveType =
                            DISK_REMOTE_DRIVE;
                        strcpy (pDisk->asdi[wDriveIndex].szDriveType,
                                paszDriveTypes[DISK_REMOTE_DRIVE]);
                      }
                  }

                if (outregs.x.dx & 0x0200)
                  {
                    /* Direct access is not allowed.  Skip the size test */
                    fSkipSizeTest = TRUE;
                  }
              }
          }


        /* That's all for minimum info */
        if (fMinimumInfo)
          continue;


        /* If this is DOS 3.2 or better, we can use IOCTL call 0Dh,  */
        /*   Generic Block Device Request.  This is where a great    */
        /*   deal of useful information can be found.  Unfortunately */
        /*   this call may require that the disk be "hit."           */

        if (wDosVersion >= 320)
          {
            BYTE abParamBlock[256];   /* Parameter block buffer */
            BYTE FAR *fbByte = NULL;  /* Far pointer to a byte  */
            WORD *pwWord = NULL;      /* WORD pointer           */


            /* Prepare for the Generic Block Device Request */

            fbByte = abParamBlock;

            /* Clear out the register structure */
            memset (&inregs, '\0', sizeof (union REGS));

            inregs.x.ax = 0x440D;
            inregs.h.bl = (BYTE) (i + 1);
            inregs.x.cx = 0x0860;
            sregs.ds    = FP_SEG (fbByte);
            inregs.x.si = FP_SEG (fbByte);
            inregs.x.dx = FP_OFF (fbByte);
            inregs.x.di = FP_OFF (fbByte);
            int86x (0x21, &inregs, &outregs, &sregs);


            /* CF is clear if IOCTL call was successful */
            if (outregs.x.cflag == 0)
              {
                /* Set the disk type */
                if (pDisk->asdi[wDriveIndex].wDriveType != DISK_SUBST_DRIVE &&
                    abParamBlock[1] < 0x0A)
                  {
                    wDriveType = abParamBlock[1] + 2;
                    pDisk->asdi[wDriveIndex].wDriveType = wDriveType;
                    strcpy (pDisk->asdi[wDriveIndex].szDriveType,
                            paszDriveTypes[wDriveType]);
                  }

                /* Set the number of cylinders */
                pwWord = (WORD *) &abParamBlock[4];
                pDisk->asdi[wDriveIndex].wCylinders = *pwWord;


                /* Set the bytes per sector */
                pwWord = (WORD *) &abParamBlock[7];
                pDisk->asdi[wDriveIndex].wBytesPerSector = *pwWord;


                /* Set the sectors per track */
                pwWord = (WORD *) &abParamBlock[20];
                pDisk->asdi[wDriveIndex].wSectorsPerTrack = *pwWord;


                /* Set the number of heads */
                pwWord = (WORD *) &abParamBlock[22];
                pDisk->asdi[wDriveIndex].wHeads = *pwWord;


                /* BIOS Call is not necessary, we have the data */
                fUseBiosCall = FALSE;
              }
            else if (pDisk->asdi[wDriveIndex].wDriveType ==
                        DISK_FLOPPY_DRIVE)
              {
                /* The IOCTL call failed on a floppy drive. */
                /*   Use the BIOS call instead              */
                fUseBiosCall = TRUE;
              }
            else if (pDisk->asdi[wDriveIndex].wDriveType ==
                        DISK_FIXED_DISK)
              {
                /* This is a special case drive.  For now, I'll   */
                /*   assume all special case drives are RAM Disks */

                pDisk->asdi[wDriveIndex].wDriveType = DISK_RAM_DISK;
                strcpy (pDisk->asdi[wDriveIndex].szDriveType,
                        paszDriveTypes[DISK_RAM_DISK]);


                /* BIOS call will not be used on this drive type */
                fUseBiosCall = FALSE;
              }
          }


        if (wDosVersion < 320)
          {
            /* This is DOS 3.1 or lower.  Use the BIOS call */
            fUseBiosCall = TRUE;
          }


        /* BIOS Call to determine disk characteristics */

        if (fUseBiosCall)
          {
            if (pDisk->asdi[wDriveIndex].wDriveType == DISK_FLOPPY_DRIVE)
              {
                /* Get the info for the floppy drive */

                inregs.h.ah = 0x08;
                inregs.h.dl = (BYTE) wNmbrFloppies;
                int86x (0x13, &inregs, &outregs, &sregs);

                if (outregs.x.cflag == 0 &&
                    outregs.h.dl > (BYTE) wNmbrFloppies);
                  {
                    /* Award and AMI BIOS may have bits 10-11 */
                    /*   of cylinder number in DH bits 6-7    */

                    pDisk->asdi[wDriveIndex].wHeads     =
                        outregs.h.dh & 0x3F + 1;

                    pDisk->asdi[wDriveIndex].wCylinders =
                        (WORD) outregs.h.ch +
                        ((((WORD) outregs.h.cl) & 0xC0) << 2) + 1;


                    /* Set the floppy type */

                    switch (outregs.h.bl)
                      {
                        case 1:
                          pDisk->asdi[wDriveIndex].wDriveType =
                              DISK_525_360K;
                          strcpy (pDisk->asdi[wDriveIndex].szDriveType,
                                  paszDriveTypes[DISK_525_360K]);
                          break;

                        case 2:
                          pDisk->asdi[wDriveIndex].wDriveType =
                              DISK_525_12M;
                          strcpy (pDisk->asdi[wDriveIndex].szDriveType,
                                  paszDriveTypes[DISK_525_12M]);
                          break;

                        case 3:
                          pDisk->asdi[wDriveIndex].wDriveType =
                              DISK_35_720K;
                          strcpy (pDisk->asdi[wDriveIndex].szDriveType,
                                  paszDriveTypes[DISK_35_720K]);
                          break;

                        case 4:
                          pDisk->asdi[wDriveIndex].wDriveType =
                              DISK_35_144M;
                          strcpy (pDisk->asdi[wDriveIndex].szDriveType,
                                  paszDriveTypes[DISK_35_144M]);
                          break;
                      }
                  }
              }
            else
              {
                /* This is a fixed disk.  Check to see if */
                /*   SWBIOS is installed for this drive   */

                inregs.h.ah = 0xF9;
                inregs.h.dl = (BYTE) (wNmbrFixedDisks & 0x80);
                int86 (0x13, &inregs, &outregs);

                if (outregs.x.cflag == 0);
                  {
                    /* Find out the true number of cylinders */
                    /*   for this fixed disk                 */

                    inregs.h.ah = 0xFE;
                    inregs.h.dl = (BYTE) (wNmbrFixedDisks + 0x80);
                    int86 (0x13, &inregs, &outregs);

                    /* True cylinder count is in DX */
                    pDisk->asdi[wDriveIndex].wCylinders =
                        outregs.x.dx + 1;
                  }


                /* Call INT 13h/AH=08h to determine disk information */

                inregs.h.ah = 0x08;
                inregs.h.dl = (BYTE) (wNmbrFixedDisks + 0x80);
                int86 (0x13, &inregs, &outregs);

                if (outregs.x.cflag == 0 &&
                    outregs.h.dl > (BYTE) wNmbrFixedDisks);
                  {
                    /* Award and AMI BIOS may have bits 10-11 */
                    /*   of cylinder number in DH bits 6-7    */

                    pDisk->asdi[wDriveIndex].wHeads =
                        outregs.h.dh & 0x3F + 1;


                    /* If the SWBIOS call didn't tell us the number */
                    /*   of cylinders, get it from this call        */

                    if (pDisk->asdi[wDriveIndex].wCylinders == 0)
                      {
                        pDisk->asdi[wDriveIndex].wCylinders =
                            ((WORD) outregs.h.ch) +
                            ((((WORD) outregs.h.cl) & 0xC0) << 2) +
                            ((((WORD) outregs.h.dh) & 0xC0) << 4) + 1;
                      }
                  }
              }
          }


        /* Free space isn't checked on floppy drives */

        wDriveType = pDisk->asdi[wDriveIndex].wDriveType;

        if (wDriveType == DISK_FLOPPY_DRIVE          ||
            wDriveType == DISK_525_360K              ||
            wDriveType == DISK_525_12M               ||
            wDriveType == DISK_35_720K               ||
            wDriveType == DISK_SINGLE_DENSITY_8_INCH ||
            wDriveType == DISK_DOUBLE_DENSITY_8_INCH ||
            wDriveType == DISK_35_144M               ||
            wDriveType == DISK_35_288M)
          {
            fSkipSizeTest = TRUE;

            /* Bump the number of floppies */
            ++wNmbrFloppies;
          }


        /* Free space isn't checked on CD-ROM drives, either */

        if (wDriveType == DISK_CD_ROM_DRIVE)
          fSkipSizeTest = TRUE;


        if (wDriveType == DISK_FIXED_DISK)
          {
            /* Determine CMOS characteristics */
            GetCmosDiskInfo (wNmbrFixedDisks, pDisk, wDriveIndex);

            /* Bump the number of fixed disks */
            ++wNmbrFixedDisks;
          }


        if (fSkipSizeTest == FALSE)
          {
            /* Determine the size of the drive, */
            /*   and the amount of free space   */

            inregs.h.ah = 0x36;
            inregs.h.dl = (BYTE) (i + 1);
            int86 (0x21, &inregs, &outregs);

            if (outregs.x.ax != 0xFFFF)
              {
                /* Free space is AX * BX * CX */
                pDisk->asdi[wDriveIndex].dwFreeBytes = (DWORD) outregs.x.ax *
                                                       (DWORD) outregs.x.bx *
                                                       (DWORD) outregs.x.cx;

                /* Total space (size of drive) is AX * CX * DX */
                pDisk->asdi[wDriveIndex].dwTotalBytes = (DWORD) outregs.x.ax *
                                                        (DWORD) outregs.x.cx *
                                                        (DWORD) outregs.x.dx;


                /* If it has not already been determined, set the number */
                /*   of bytes per sector.                                */

                if (pDisk->asdi[wDriveIndex].wBytesPerSector == 0)
                  pDisk->asdi[wDriveIndex].wBytesPerSector = outregs.x.cx;
              }
          }
      }


  /* Restore the current drive */
  DosSetCurrentDrive (bCurrentDrive);

  return (FALSE);
}


/*********************************************************************
 * GetCmosDiskInfo - Obtains the CMOS drive parameters.
 *
 * wHardDriveNmbr - Hard disk number (0 or 1).
 * pDisk          - Structure for storing disk information.
 * wDriveIndex    - Index to pDisk.
 *
 * Returns:  TRUE if this is a valid drive number.  FALSE if not.
 *********************************************************************/

VOID _cdecl GetCmosDiskInfo (WORD wHardDriveNmbr,
                             DISK_STRUCT *pDisk,
                             WORD wDriveIndex)
{
  WORD i;               /* Looping variable */
  WORD wCmosIndex = 0;  /* Value to obtain  */
  WORD wCmosValue;      /* Value from CMOS  */


  /* Obtain the drive type appropriate for this drive */
  outp (0x70, 0x12);

  /* Wait */
  for (i = 0; i < 1; ++i)
    ;

  /* Input the drive type */
  wCmosValue = inp (0x71);


  /* First HD type is in bits 4-7, second is in bits 0-3 */
  if (wHardDriveNmbr == 0)
    wCmosValue = (wCmosValue & 0xF0) >> 4;
  else
    wCmosValue = (wCmosValue & 0x0F);


  /* If the HD type is 15 (0Fh), look elsewhere */
  if (wCmosValue == 0x0F)
    {
      /* Choose the appropriate value for the hard drive number */
      if (wHardDriveNmbr == 0)
        wCmosIndex = 0x19;
      else
        wCmosIndex = 0x1A;

      outp (0x70, wCmosIndex);

      /* Wait */
      for (i = 0; i < 1; ++i)
        ;

      /* Get the hard drive type */
      wCmosValue = inp (0x71);
    }


  /* Set the CMOS Drive Type */
  pDisk->asdi[wDriveIndex].wCmosDriveType = wCmosValue;


  /* Get the drive parameters */


  /* Is this a user defined drive type (48 or 49) */
  if (pDisk->asdi[wDriveIndex].wCmosDriveType == 48 ||
      pDisk->asdi[wDriveIndex].wCmosDriveType == 49)
    {
      /* Set the base index for the drive paramter table */
      if (wHardDriveNmbr == 0)
        wCmosIndex = 0x20;
      else
        wCmosIndex = 0x35;


      /* Cylinders */
      outp (0x70, wCmosIndex + 1);

      for (i = 0; i < 1; ++i)
        ;

      wCmosValue = inp (0x71);
      wCmosValue = wCmosValue << 8;

      outp (0x70, wCmosIndex + 1);

      for (i = 0; i < 1; ++i)
        ;

      wCmosValue = wCmosValue + inp (0x70);
      pDisk->asdi[wDriveIndex].wCmosCylinders = wCmosValue;


      /* Heads */
      outp (0x70, wCmosIndex + 2);

      for (i = 0; i < 1; ++i)
        ;

      pDisk->asdi[wDriveIndex].wCmosHeads = inp (0x71);


      /* Sectors per track */
      outp (0x70, wCmosIndex + 7);

      for (i = 0; i < 1; ++i)
        ;

      pDisk->asdi[wDriveIndex].wCmosSectorsPerTrack = inp (0x71);
    }
  else
    {
      CMOS_DRIVE_TYPE FAR *pCmosInfo = NULL;  /* CMOS Info in BIOS  */
      WORD wTableNmbr;                        /* Drive Table Number */
      union REGS regs;                        /* int86x registers   */
      struct SREGS sregs;                     /* int86x segments    */


      /* This is a predefined drive type -- located in the BIOS */

      /* Use the appropriate lookup table */
      if (wHardDriveNmbr == 0)
        wTableNmbr = 0x41;
      else
        wTableNmbr = 0x46;


      /* Get the table's address */
      regs.h.ah = 0x35;
      regs.h.al = (BYTE) wTableNmbr;
      int86x (0x21, &regs, &regs, &sregs);

      pCmosInfo = (CMOS_DRIVE_TYPE FAR *)
                      (((DWORD) sregs.es << 16) + regs.x.bx);


      /* Get the information */
      pDisk->asdi[wDriveIndex].wCmosCylinders =
                                      pCmosInfo->wNmbrCylinders;
      pDisk->asdi[wDriveIndex].wCmosHeads     =
                                      pCmosInfo->bNmbrHeads;
      pDisk->asdi[wDriveIndex].wCmosSectorsPerTrack =
                                      pCmosInfo->bSectorsPerTrack;
    }


  /* Set the CMOS type on the "Fixed Disk" line */

  sprintf (pDisk->asdi[wDriveIndex].szDriveType,
           "Fixed Disk, CMOS Type %d",
           pDisk->asdi[wDriveIndex].wCmosDriveType);
}


/*********************************************************************
 * ValidDrive - Determines if this drive number is a valid drive.
 *
 * bDrive - Drive letter to test.
 *
 * Returns:  TRUE if this is a valid drive number.  FALSE if not.
 *********************************************************************/

BOOL ValidDrive (BYTE bDrive)
{
  /* Attempt to make this drive number the current drive */
  DosSetCurrentDrive (bDrive);


  /* Return success or failure */
  if (DosGetCurrentDrive() == bDrive)
    return (TRUE);
  else
    return (FALSE);
}


/*********************************************************************
 * DosGetCurrentDrive - Obtain drive number of the current drive.
 *
 * Returns:  Current drive number.
 *********************************************************************/

BYTE DosGetCurrentDrive (VOID)
{
  union REGS inregs, outregs;   /* Register structures for int86() */


  /* DOS call to return the current drive number */
  inregs.h.ah = 0x19;
  int86 (0x21, &inregs, &outregs);


  /* Return the current drive letter */
  return (outregs.h.al);
}


/*********************************************************************
 * DosSetCurrentDrive - Sets the current drive to the given drive
 *                      number.
 *
 * bDrive      - Drive number to set as the current drive.
 * wDosVersion - DOS Version (ie 3.20 == 320).
 *
 * Returns:  The highest potentially valid drive letter.  The highest
 *           of 5, LASTDRIVE in CONFIG.SYS, or the highest drive
 *           number in the system.
 *********************************************************************/

BYTE DosSetCurrentDrive (BYTE bDrive)
{
  union REGS inregs, outregs;   /* Register structures for int86() */


  /* DOS call to return the current drive number */
  inregs.h.ah = 0x0e;
  inregs.h.dl = bDrive;
  int86 (0x21, &inregs, &outregs);

  return (outregs.h.al);
}


/*********************************************************************
 * GetDiskProgList - Gets the list of disk related programs installed
 *                   in memory (JOIN, ASSIGN, MSCDEX, etc).
 *
 * pDisk - Pointer to disk information structure.
 *********************************************************************/

VOID GetDiskProgList (DISK_STRUCT *pDisk, WORD wDosVersion)
{
  union  REGS  inregs, outregs;   /* Register structures for int86() calls */
  struct SREGS sregs;             /* Segment registers for int86x() calls  */
  BYTE FAR *fbByte = NULL;        /* Far pointer to a BYTE                 */
  WORD   i;                       /* Looping variable                      */

  /* Determine if JOIN.EXE is being used */
  if (wDosVersion >= 310)
    {
      inregs.h.ah = 0x52;
      int86x (0x21, &inregs, &outregs, &sregs);
      fbByte = (BYTE FAR *) ((DWORD) sregs.es << 16) + outregs.x.bx;
      if (fbByte[0x34] != 0)
        pDisk->fJoinInstalled = TRUE;
    }


  /* Determine if SHARE.EXE is installed */
  inregs.x.ax = 0x1000;
  int86 (0x2F, &inregs, &outregs);
  if (outregs.h.al == 0xFF)
    pDisk->fShareInstalled = TRUE;


  /* Determine if ASSIGN.EXE installed */
  inregs.x.ax = 0x0600;
  int86 (0x2F, &inregs, &outregs);
  if (outregs.h.al == 0xFF)
    {
      pDisk->fAssignInstalled = TRUE;

      /* Load up the ASSIGN drive table */
      inregs.x.ax = 0x0601;
      int86x (0x2F, &inregs, &outregs, &sregs);
      if (sregs.es > 0x0000)
        {
          WORD wAssignIndex;    /* Index to the AssignTable */
          /* Point to the drive assignment table */
          fbByte = (BYTE FAR *) ((DWORD) sregs.es << 16) + 0x0102;


          /* Loop through, looking for assignments */
          /*   (ASSIGN reserves room for A:-Z:, no */
          /*   matter what LASTDRIVE is set to).   */

          for (i = 1, wAssignIndex = 0; i < MAX_ASSIGN_TABLE; ++i)
            if (fbByte[i] != (BYTE) i)
              {
                pDisk->atAssignTable[wAssignIndex].chAssignTo   = (CHAR) i;
                pDisk->atAssignTable[wAssignIndex].chAssignFrom = fbByte[i];

                ++wAssignIndex;
              }
        }
    }


  /* Determine if APPEND.EXE installed */
  inregs.x.ax = 0xB700;
  int86 (0x2F, &inregs, &outregs);
  if (outregs.h.al == 0xFF)
    {
      CHAR FAR * fpszAppendPath = NULL; /* Far pointer to the APPEND path */

      pDisk->fAppendInstalled = TRUE;

      /* Locate the APPEND path */
      inregs.x.ax = 0xB704;
      int86x (0x2f, &inregs, &outregs, &sregs);

      /* Place it into the Disk Info structure */
      fpszAppendPath = (CHAR FAR *) ((DWORD) sregs.es << 16) + outregs.x.di;
      _fstrncpy ((CHAR FAR *) pDisk->szAppendPath, fpszAppendPath,
                 MAX_APPEND_PATH - 1);
      pDisk->szAppendPath[MAX_APPEND_PATH - 1] = '\0';
    }


  /* Determine if MSCDEX.EXE is installed */
  inregs.x.ax = 0x1500;
  inregs.x.bx = 0x0000;
  int86 (0x2F, &inregs, &outregs);
  if (outregs.x.bx != 0x0000)
    {
      /* MSCDEX is installed -- Determine version number */

      inregs.x.ax = 0x150C;
      inregs.x.bx = 0x0000;
      int86 (0x2F, &inregs, &outregs);
      if (outregs.x.bx == 0)
        {
          /* Set the version to 1.x */
          pDisk->wMscdexMajor = 1;
          pDisk->wMscdexMinor = 0xFF;
        }
      else
        {
          pDisk->wMscdexMajor = outregs.h.bh;
          pDisk->wMscdexMinor = outregs.h.bl;
        }
    }
}


/*********************************************************************
 * SprintDiskInfo - Put disk information into a set of strings to be
 *                  printed or displayed.
 *
 * Returns:  NULL if an error occured.
 *********************************************************************/

QSZ * SprintDiskInfo (DISK_STRUCT *pDisk,
                      CHAR szSumStrings[][MAX_SUMM_INFO + 5])
{
  WORD wNmbrStrings;        /* Number of strings                    */
  WORD wNmbrChars;          /* Number of characters in the strings  */
  WORD wUnderlineLength;    /* Length of the underline string       */
  WORD wDriveIndex;         /* Index to the structure of disk data  */
  WORD i;                   /* Looping variables                    */
  QSZ  *pqszStrings = NULL; /* Location for storing string pointers */
  CHAR chBuffer[80];        /* Buffer for string data               */


  /* Summary Strings */
  if (szSumStrings != NULL)
    {
      WORD wDrivesThisLine = 0;   /* Current number of drive letters */
                                  /*   on this line.                 */
      i = 0;
      szSumStrings[i][0] = '\0';

      for (wDriveIndex = 0; wDriveIndex < pDisk->wNmbrDrives; ++wDriveIndex)
        {
          /* Drive Letter */
          sprintf (chBuffer, "%c: ", pDisk->asdi[wDriveIndex].chDriveLetter);

          /* Is there room for it on this line */
          if (++wDrivesThisLine > MAX_DRIVES_PER_LINE)
            {
              wDrivesThisLine = 1;

              /* Is there another line that we can use */
              if (++i > 1)
                {
                  /* There are more drives than will fit on   */
                  /*   summary screen.  Put "..." at the end. */
                  /*
                  wNmbrChars = strlen (szSumStrings[1]);
                  szSumStrings[1][wNmbrChars - 4] = '\0';
                  strcat (szSumStrings[1], "...");
                  */
                  return (NULL);
                }
              else
                szSumStrings[i][0] = '\0';
            }

          strncat (szSumStrings[i], chBuffer,
                   MAX_SUMM_INFO - strlen (szSumStrings[0]));
        }

      return (NULL);
    }


  /* Calculate the amount of space required for the strings */

  wNmbrStrings = pDisk->wNmbrDrives + 3;

  for (i = 0; i < pDisk->wNmbrDrives; ++i)
    {
      if (pDisk->asdi[i].wCylinders > 0 ||
          pDisk->asdi[i].wHeads > 0)
        ++wNmbrStrings;

      if (pDisk->asdi[i].wBytesPerSector > 0 ||
          pDisk->asdi[i].wSectorsPerTrack > 0)
        ++wNmbrStrings;

      if (pDisk->asdi[i].wDriveType == DISK_FIXED_DISK)
        {
          /* If the CMOS settings do not match, display the lines. */
          /*   The CMOS cylinders can be off by 2.                 */

          if (!((pDisk->asdi[i].wCylinders      ==
                 pDisk->asdi[i].wCmosCylinders)     ||
                (pDisk->asdi[i].wCylinders + 1  ==
                 pDisk->asdi[i].wCmosCylinders)     ||
                (pDisk->asdi[i].wCylinders + 2  ==
                 pDisk->asdi[i].wCmosCylinders)     &&
                pDisk->asdi[i].wHeads           ==
                pDisk->asdi[i].wCmosHeads           &&
                pDisk->asdi[i].wSectorsPerTrack ==
                pDisk->asdi[i].wCmosSectorsPerTrack))
            {
              wNmbrStrings += 3;
            }
        }
    }
  if (pDisk->fJoinInstalled)
    ++wNmbrStrings;

  if (pDisk->fSubstInstalled)
    ++wNmbrStrings;

  if (pDisk->fShareInstalled)
    ++wNmbrStrings;

  if (pDisk->fAssignInstalled)
    ++wNmbrStrings;

  if (pDisk->fAppendInstalled)
    ++wNmbrStrings;

  if (pDisk->wMscdexMajor != 0)
    ++wNmbrStrings;


  wUnderlineLength = strlen (pszDiskUnderline);

  wNmbrChars   = wNmbrStrings * (wUnderlineLength + 1);


  /* Allocate space for the pointer area and string area */
  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);


  /* Put the first two strings in place */

  Qstrcpy (pqszStrings[0], pszDiskHeader);
  pqszStrings[1] = pqszStrings[0] + Qstrlen (pqszStrings[0]) + 1;

  Qstrcpy (pqszStrings[1], pszDiskUnderline);
  pqszStrings[2] = pqszStrings[1] + wUnderlineLength + 1;


  /* Put the Disk information in place */

  for (i = 2, wDriveIndex = 0; wDriveIndex < pDisk->wNmbrDrives;
       ++i, ++wDriveIndex)
    {
      WORD wLength;       /* Current length of string        */


      /* Clear out the string */
      Qmemset (pqszStrings[i], ' ', wUnderlineLength);
      pqszStrings[i][wUnderlineLength] = '\0';


      /* Drive Letter */
      wLength = sprintf (chBuffer, "%c:",
                         pDisk->asdi[wDriveIndex].chDriveLetter);
      Qstrncpy (&pqszStrings[i][DISK_DRIVE_COL], chBuffer, wLength);


      /* Type */
      Qstrncpy (&pqszStrings[i][DISK_TYPE_COL],
               pDisk->asdi[wDriveIndex].szDriveType,
               strlen (pDisk->asdi[wDriveIndex].szDriveType));


      /* Free Space */
      if (pDisk->asdi[wDriveIndex].dwFreeBytes > (DWORD) 0 ||
          pDisk->asdi[wDriveIndex].dwTotalBytes > (DWORD) 0)
        {
          if (pDisk->asdi[wDriveIndex].dwFreeBytes > 9000000L)
            wLength = sprintf (chBuffer, "%9luM",
                          pDisk->asdi[wDriveIndex].dwFreeBytes / (1024L * 1024L));
          else
            wLength = sprintf (chBuffer, "%9luK",
                          pDisk->asdi[wDriveIndex].dwFreeBytes / 1024);
          Qstrncpy (&pqszStrings[i][DISK_FREE_SPACE_COL], chBuffer, wLength);
        }


      /* Total Free */
      if (pDisk->asdi[wDriveIndex].dwTotalBytes > (DWORD) 0)
        {
          if (pDisk->asdi[wDriveIndex].dwTotalBytes > 9000000L)
            wLength = sprintf (chBuffer, "%9luM",
                          pDisk->asdi[wDriveIndex].dwTotalBytes / (1024L * 1024L));
          else
            wLength = sprintf (chBuffer, "%9luK",
                          pDisk->asdi[wDriveIndex].dwTotalBytes / 1024);
          Qstrncpy (&pqszStrings[i][DISK_TOTAL_FREE_COL], chBuffer, wLength);
        }


      /* Prep the current and next strings */
      PrepNextString (pqszStrings, i);


      /* Cylinders / Heads line */

      if (pDisk->asdi[wDriveIndex].wCylinders > 0 ||
          pDisk->asdi[wDriveIndex].wHeads > 0)
        {
          /* Next string */
          ++i;


          /* Clear out the string */
          Qmemset (pqszStrings[i], ' ', DISK_EXTRA_INFO_COL);
          pqszStrings[i][DISK_EXTRA_INFO_COL] = '\0';


          /* Cylinders */
          if (pDisk->asdi[wDriveIndex].wCylinders > 0)
            {
              sprintf (chBuffer, pszCylinders,
                       pDisk->asdi[wDriveIndex].wCylinders);
              Qstrcat (pqszStrings[i], chBuffer);
            }


          /* Comma space */
          if (pDisk->asdi[wDriveIndex].wCylinders > 0 &&
              pDisk->asdi[wDriveIndex].wHeads > 0)
            Qstrcat (pqszStrings[i], pszCommaSpace);


          /* Heads */
          if (pDisk->asdi[wDriveIndex].wHeads > 0)
            {
              sprintf (chBuffer, pszHeads,
                       pDisk->asdi[wDriveIndex].wHeads);
              Qstrcat (pqszStrings[i], chBuffer);
            }


          /* Prep the current and next strings */
          PrepNextString (pqszStrings, i);
        }


      /* Bytes per sector / Sectors per track line */

      if (pDisk->asdi[wDriveIndex].wBytesPerSector > 0 ||
          pDisk->asdi[wDriveIndex].wSectorsPerTrack > 0)
        {
          /* Next string */
          ++i;


          /* Clear out the string */
          Qmemset (pqszStrings[i], ' ', DISK_EXTRA_INFO_COL);
          pqszStrings[i][DISK_EXTRA_INFO_COL] = '\0';


          /* Bytes per sector */
          if (pDisk->asdi[wDriveIndex].wBytesPerSector > 0)
            {
              sprintf (chBuffer, pszBytesPerSector,
                       pDisk->asdi[wDriveIndex].wBytesPerSector);
              Qstrcat (pqszStrings[i], chBuffer);
            }


          /* Comma space */
          if (pDisk->asdi[wDriveIndex].wBytesPerSector > 0 &&
              pDisk->asdi[wDriveIndex].wSectorsPerTrack > 0)
            Qstrcat (pqszStrings[i], pszCommaSpace);


          /* Sectors per track */
          if (pDisk->asdi[wDriveIndex].wSectorsPerTrack > 0)
            {
              sprintf (chBuffer, pszSectorsPerTrack,
                       pDisk->asdi[wDriveIndex].wSectorsPerTrack);
              Qstrcat (pqszStrings[i], chBuffer);
            }


          /* Prep the current and next strings */
          PrepNextString (pqszStrings, i);
        }

      /* If this is a fixed disk, check the CMOS settings */
      if (pDisk->asdi[wDriveIndex].wDriveType == DISK_FIXED_DISK)
        {
          /* If the CMOS settings do not match, display the lines. */
          /*   The CMOS cylinders can be off by 2.                 */

          if (!((pDisk->asdi[wDriveIndex].wCylinders      ==
                 pDisk->asdi[wDriveIndex].wCmosCylinders)     ||
                (pDisk->asdi[wDriveIndex].wCylinders + 1  ==
                 pDisk->asdi[wDriveIndex].wCmosCylinders)     ||
                (pDisk->asdi[wDriveIndex].wCylinders + 2  ==
                 pDisk->asdi[wDriveIndex].wCmosCylinders)     &&
                pDisk->asdi[wDriveIndex].wHeads           ==
                pDisk->asdi[wDriveIndex].wCmosHeads           &&
                pDisk->asdi[wDriveIndex].wSectorsPerTrack ==
                pDisk->asdi[wDriveIndex].wCmosSectorsPerTrack))
            {
              /* Clear out the string */
              Qmemset (pqszStrings[++i], ' ', wUnderlineLength);
              pqszStrings[i][wUnderlineLength] = '\0';


              /* CMOS title */
              Qstrcpy (&pqszStrings[i][DISK_TYPE_COL],
                      "CMOS Fixed Disk Parameters");
              PrepNextString (pqszStrings, i++);

              /* Clear out the string */
              Qmemset (pqszStrings[i], ' ', DISK_EXTRA_INFO_COL);
              pqszStrings[i][DISK_EXTRA_INFO_COL] = '\0';


              /* Cylinders */
              sprintf (chBuffer, pszCylinders,
                       pDisk->asdi[wDriveIndex].wCmosCylinders);
              Qstrcat (pqszStrings[i], chBuffer);
              Qstrcat (pqszStrings[i], pszCommaSpace);

              /* Heads */
              sprintf (chBuffer, pszHeads,
                       pDisk->asdi[wDriveIndex].wCmosHeads);
              Qstrcat (pqszStrings[i], chBuffer);


              /* Next line */
              PrepNextString (pqszStrings, i++);

              /* Clear out the string */
              Qmemset (pqszStrings[i], ' ', DISK_EXTRA_INFO_COL);
              pqszStrings[i][DISK_EXTRA_INFO_COL] = '\0';


              /* Sectors per track */
              sprintf (chBuffer, pszSectorsPerTrack,
                       pDisk->asdi[wDriveIndex].wCmosSectorsPerTrack);
              Qstrcat (pqszStrings[i], chBuffer);

              PrepNextString (pqszStrings, i);
            }
        }
    }


  /* JOIN */
  if (pDisk->fJoinInstalled)
    {
      /* Clear out the string */
      pqszStrings[i][0] = '\0';

      Qstrcat (pqszStrings[i], pszJoinInstalled);

      /* Prep the current and next strings */
      PrepNextString (pqszStrings, i++);
    }


  /* SUBST */
  if (pDisk->fSubstInstalled)
    {
      /* Clear out the string */
      pqszStrings[i][0] = '\0';

      Qstrcat (pqszStrings[i], pszSubstInstalled);

      /* Prep the current and next strings */
      PrepNextString (pqszStrings, i++);
    }


  /* SHARE */
  if (pDisk->fShareInstalled)
    {
      /* Clear out the string */
      pqszStrings[i][0] = '\0';

      Qstrcat (pqszStrings[i], pszShareInstalled);

      /* Prep the current and next strings */
      PrepNextString (pqszStrings, i++);
    }


  /* ASSIGN */
  if (pDisk->fAssignInstalled)
    {
      /* Clear out the string */
      pqszStrings[i][0] = '\0';

      if (pDisk->atAssignTable[0].chAssignTo == '\0')
        Qstrcat (pqszStrings[i], pszAssignInstalled);
      else
        {
          WORD u;   /* Looping variable */

          Qstrcat (pqszStrings[i], pszAssign);

          /* List the ASSIGNed drive letters */
          for (u = 0; pDisk->atAssignTable[u].chAssignTo != '\0'; ++u)
            {
              sprintf (chBuffer, " %c:=%c:",
                       pDisk->atAssignTable[u].chAssignTo + 'A' - 1,
                       pDisk->atAssignTable[u].chAssignFrom + 'A' - 1);

              Qstrcat (pqszStrings[i], chBuffer);
            }
        }

      /* Prep the current and next strings */
      PrepNextString (pqszStrings, i++);
    }


  /* APPEND */
  if (pDisk->fAppendInstalled)
    {
      /* Clear out the string */
      pqszStrings[i][0] = '\0';

      if (pDisk->szAppendPath[0] == '\0')
        Qstrcat (pqszStrings[i], pszAppendInstalled);
      else
        {
          Qstrcat (pqszStrings[i], pszAppendPath);
          Qstrcat (pqszStrings[i], pDisk->szAppendPath);
        }

      /* Prep the current and next strings */
      PrepNextString (pqszStrings, i++);
    }


  /* MSCDEX */
  if (pDisk->wMscdexMajor != 0)
    {
      /* Clear out the string */
      pqszStrings[i][0] = '\0';

      /* Special case for MSCDEX 1.x */
      if (pDisk->wMscdexMinor == 0xFF)
        sprintf (chBuffer, pszMscdex1x, pDisk->wMscdexMajor);
      else
        sprintf (chBuffer, pszMscdexInstalled, pDisk->wMscdexMajor,
                 pDisk->wMscdexMinor);

      Qstrcat (pqszStrings[i], chBuffer);

      /* Prep the current and next strings */
      PrepNextString (pqszStrings, i++);
    }


  /* LASTDRIVE */

  /* Clear out the string */
  pqszStrings[i][0] = '\0';

  sprintf (chBuffer, pszLastdrive, pDisk->chLastDrive);
  Qstrcat (pqszStrings[i], chBuffer);


  /* Set the last pointer to a NULL */
  pqszStrings[++i] = NULL;

  /* Return the pointer to pqszStrings */
  return (pqszStrings);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\getinfo.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * GETINFO.C - Source file with the primary GetInfo loop.
 ********************************************************************/


/* Include Files */

#include "msd.h"


/********************************************************************
 * GetInfoSize - Returns the number of bytes required to store the
 *               specified record type.
 *
 * wRecordType - Record type requested.  NULL for a total of all
 *               record types.
 *
 * Returns: Count of bytes required to store the data.
 ********************************************************************/

INT GetInfoSize (WORD wRecordType, BOOL fHeaderRecord)
{
  WORD wHeaderSize;         /* Set to the size of the header record, */
                            /*   zero if the header record is not    */
                            /*   required.                           */

  /* If the header record was requested, get the header size only once */

  if (fHeaderRecord &&
      wRecordType != IDI_MSD_HEADER_RECORD &&
      wRecordType != IDI_ALL_RECORDS)
    wHeaderSize = GetInfoSize (IDI_MSD_HEADER_RECORD, FALSE);
  else
    wHeaderSize = 0;


  /* Return the size based on wRecordType */

  switch (wRecordType)
    {
      case IDI_ALL_RECORDS:
        {
          INT i;              /* Looping variable */
          INT iByteCount = 0; /* Count of bytes needed to store all records */

          for (i = 1; i < NMBR_OF_RECORDS; ++i)
            iByteCount += GetInfoSize (rwRecordTypes[i], FALSE);

          return (iByteCount);
        }

      case IDI_MSD_HEADER_RECORD:
        return (21);

      case IDI_CUSTOMER_INFORMATION:
        return (sizeof (CUSTINFO) + wHeaderSize);

      case IDI_SUMMARY_SCREEN:
        return (sizeof (SUMMARY_STRUCT) + wHeaderSize);

      case IDI_COMPUTER_RECORD:
        return (sizeof (COMPUTER_STRUCT) + wHeaderSize);

      case IDI_MEMORY_RECORD:
        return (sizeof (MEMORY_STRUCT) + wHeaderSize);

      case IDI_VIDEO_RECORD:
        return (sizeof (VIDEO_STRUCT) + wHeaderSize);

      case IDI_NETWORK_RECORD:
        return (sizeof (NETWORK_STRUCT) + wHeaderSize);

      case IDI_OS_VERSION_RECORD:
        return (sizeof (OS_VERSION_STRUCT) + wHeaderSize);

      case IDI_MOUSE_RECORD:
        return (sizeof (MOUSE_STRUCT) + wHeaderSize);

      case IDI_OTHER_ADAPTERS_RECORD:
        return (sizeof (OTHER_STRUCT) + wHeaderSize);

      case IDI_DISK_DRIVE_RECORD:
        return (sizeof (DISK_STRUCT) + wHeaderSize);

      case IDI_LPT_RECORD:
        return (sizeof (LPT_STRUCT) + wHeaderSize);

      case IDI_COM_RECORD:
        return (sizeof (COM_STRUCT) + wHeaderSize);

      case IDI_IRQ_RECORD:
        return (sizeof (IRQ_STRUCT) + wHeaderSize);

      case IDI_TSR_PROGRAMS_RECORD:
        return (GetTsrInfoSize() + wHeaderSize);

      case IDI_DEVICE_DRIVERS_RECORD:
        return (GetDeviceDriversSize() + wHeaderSize);

      default:
        return (0);
    }
}

/********************************************************************
 * GetInfo - Fills area pointed to by pStructForInfo with requested
 *           data.
 *
 * wRecordType    - Record type requested.  NULL to fill
 *                  pStructForInfo with all record types.
 * pStructForInfo - Pointer to data area to be filled by GetInfo.
 * fMinimumInfo   - Obtains the minimum amount of data, if TRUE.
 * fHeaderRecord  - Includes header record data if TRUE.
 * fReportFlag    - Used by routines that normally add data to an
 *                  existing window -- BIOS and Disk Drives for
 *                  example.  When TRUE, those routines obtain all
 *                  information before returning.
 *
 * Returns: TRUE if an error condition occured.
 ********************************************************************/

BOOL GetInfo (WORD wRecordType,
              VOID *pStructForInfo,
              BOOL fMinimumInfo,
              BOOL fHeaderRecord,
              BOOL fReportFlag)

{
  /* If the header record was requested, store the header record only once */

  if (fHeaderRecord &&
      wRecordType != IDI_MSD_HEADER_RECORD &&
      wRecordType != IDI_ALL_RECORDS)
    {
      GetInfo (IDI_MSD_HEADER_RECORD,
               pStructForInfo,
               fMinimumInfo,
               FALSE,
               fReportFlag);

      /* Now, move pStructForInfo past the header record */

      pStructForInfo = (BYTE *) pStructForInfo +
                       GetInfoSize (IDI_MSD_HEADER_RECORD, FALSE);
    }


  /* Return the size based on wRecordType */

  switch (wRecordType)
    {
      case IDI_ALL_RECORDS:
        {
          INT i;              /* Looping variable */
          INT iByteCount = 0; /* Count of bytes needed to store all records */

          for (i = 1; i < NMBR_OF_RECORDS; ++i)
            {
              GetInfo (wRecordType,
                       pStructForInfo,
                       fMinimumInfo,
                       FALSE,
                       fReportFlag);

              /* Now, move pStructForInfo past the new record */

              pStructForInfo = (BYTE *) pStructForInfo +
                               GetInfoSize (rwRecordTypes[i], FALSE);
            }
          return (FALSE);
        }

      case IDI_MSD_HEADER_RECORD:
        return (FALSE);

      case IDI_CUSTOMER_INFORMATION:
        return (GetCustInfo (pStructForInfo, fMinimumInfo));

      case IDI_SUMMARY_SCREEN:
        return (GetSummaryInfo (pStructForInfo, fMinimumInfo));

      case IDI_COMPUTER_RECORD:
        return (GetComputerInfo (pStructForInfo, fMinimumInfo));

      case IDI_MEMORY_RECORD:
        return (GetMemInfo (pStructForInfo, fMinimumInfo));

      case IDI_VIDEO_RECORD:
        return (GetVideoInfo (pStructForInfo, fMinimumInfo));

      case IDI_NETWORK_RECORD:
        return (GetNetworkInfo (pStructForInfo, fMinimumInfo));

      case IDI_OS_VERSION_RECORD:
        return (GetOsVersionInfo (pStructForInfo, fMinimumInfo));

      case IDI_MOUSE_RECORD:
        return (GetMouseInfo (pStructForInfo));

      case IDI_OTHER_ADAPTERS_RECORD:
        return (GetOtherInfo (pStructForInfo, fMinimumInfo));

      case IDI_DISK_DRIVE_RECORD:
        return (GetDiskInfo (pStructForInfo, fMinimumInfo));

      case IDI_LPT_RECORD:
        return (GetLptInfo (pStructForInfo, fMinimumInfo));

      case IDI_COM_RECORD:
        return (GetComInfo (pStructForInfo, fMinimumInfo));

      case IDI_IRQ_RECORD:
        return (GetIrqInfo (pStructForInfo, fMinimumInfo));

      case IDI_TSR_PROGRAMS_RECORD:
        return (GetTsrInfo (pStructForInfo, fMinimumInfo));

      case IDI_DEVICE_DRIVERS_RECORD:
        return (GetDeviceDriversInfo (pStructForInfo, fMinimumInfo));

      default:
        {
#if DEBUG
          /* A bogus record arrived */

          CHAR chBuffer[17];  /* Stores the message number */

          itoa (wRecordType, chBuffer, 10);

          ShowError (ERR_OK_BUTTON, "GetInfo", "Invalid Record", chBuffer);
          return (TRUE);
#endif
          return (FALSE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\is386.asm ===
dosseg
        .model large

        public          is386
        public          _GetSuperXmsInfo

.code
;
;       Identify the current CPU being executed.
;       Return with EAX=1 for i486 CPU or EAX=0 for 386 CPU.
;       Leave ESP, EBP, EBX, ESI, and EDI unchanged.
;
is386           PROC FAR
.386
        mov     edx,esp         ; Save current stack pointer to align it
        and     esp,not 3       ; Align stack to avoid AC fault
        pushfd                  ; Push EFLAGS
        pop     eax             ; Get EFLAGS value
        mov     ecx,eax         ; Save original EFLAGS
        xor     eax, 40000H     ; Flip AC bit in EFLAGS
        push    EAX             ; Copy to EFLAGS
        popfd
        pushfd                  ; Get new EFLAGS value
        pop     eax             ; Put into eax
        xor     eax,ecx         ; See if AC bit changed
                                ; EAX=0H if 386 CPU, 40000H if i486 CPU
        shr     eax,18          ; EAX=0H if 386 CPU, 1H if i486 CPU
        and     eax,1           ; Ignore all other bits
        push    ecx
        popfd                   ; Restore original EFLAGS register
        mov     esp,edx         ; Restore original stack pointer
        ret
is386           endp



;
;       Determine the Super Extended Memory amounts
;
_GetSuperXmsInfo   PROC FAR


        push    bp              ; Setup code for being called from 'C'
        mov     bp,sp

        mov     ah,88H          ; Call for super XMS info

        call Dword Ptr [bp + 6] ; Call the XMS driver.

        or      bl,bl           ; Check for error condition
        jnz     gsxi_error_exit ; Jump out if there's an error

        mov     bx, [bp + 10]        ; Address of where to put the answer
        mov     Dword Ptr [bx], eax  ; Largest free
        mov     bx, [bp + 12]        ; Address of where to put the answer
        mov     Dword Ptr [bx], edx  ; Total free

; Some day, the highest address may be useful/accurate, but not today ...
;       mov     bx, [bp + 14]        ; Address of where to put the answer
;       mov     Dword Ptr [bx], ecx  ; Highest address

        jmp short gsxi_exit     ; Information is retrieved, exit

gsxi_error_exit:
        mov     ax,1            ; Set an error code
        jmp short gsxi_ret      ; and return

gsxi_exit:
        xor     ax,ax           ; No error

gsxi_ret:
        pop     bp              ; Clean up and return
        ret

_GetSuperXmsInfo   endp

        END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\lptinfo.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * LPTINFO.C - Source file for parallel printer port detection code.
 ********************************************************************/


/* Include Files */

#include "msd.h"


/*********************************************************************
 * GetLptInfo - Gets the LPT port information.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetLptInfo (LPT_STRUCT *pLpt, BOOL fMinimumInfo)
{
  WORD i;                           /* Looping variable    */
  WORD wLptStatus[MAX_LPT_PORTS];   /* Printer port status */


  {
    /* Zero out the count of LPT ports */

    pLpt->wNmbrLptPorts = 0;


    /* Count the number of LPT ports in the system */

    for (i = 0; i < MAX_LPT_PORTS; i++)
      {
        wLptStatus[i] = _bios_printer (_PRINTER_STATUS, i, 0);

        if (!(wLptStatus[i] & 6))
          ++(pLpt->wNmbrLptPorts);
      }

    if (fMinimumInfo)
      return (FALSE);
  }

  {
    /* Set the values in the structure for each port */

    /* 40:8 is the port address of the first valid LPT port */
    WORD FAR * fwPortAddress = (WORD FAR *) 0x00400008;

    for (i = 0; i < MAX_LPT_PORTS; i++)
      {
        pLpt->LptxInfo[i].fLptPortDetected
                                    = (wLptStatus[i] & 0x06) ? FALSE : TRUE;
        pLpt->LptxInfo[i].wPortAddress
                                    = *(fwPortAddress++);
        pLpt->LptxInfo[i].fOnLine   = (wLptStatus[i] & 0x10) ? TRUE  : FALSE;
        pLpt->LptxInfo[i].fPaperOut = (wLptStatus[i] & 0x20) ? TRUE  : FALSE;
        pLpt->LptxInfo[i].fIoError  = (wLptStatus[i] & 0x08) ? TRUE  : FALSE;
        pLpt->LptxInfo[i].fTimeOut  = (wLptStatus[i] & 0x01) ? TRUE  : FALSE;
        pLpt->LptxInfo[i].fBusy     = (wLptStatus[i] & 0x80) ? FALSE : TRUE;
        pLpt->LptxInfo[i].fAck      = (wLptStatus[i] & 0x40) ? TRUE  : FALSE;
      }
  }

  return (FALSE);
}


/*********************************************************************
 * SprintLptInfo - Put LPT port information into a set of strings to
 *                 be printed or displayed.
 *
 * Returns:  NULL if an error occured.
 *********************************************************************/

QSZ * SprintLptInfo (LPT_STRUCT *pLpt,
                     CHAR szSumStrings[][MAX_SUMM_INFO + 5])
{
  WORD wNmbrStrings;        /* Number of strings                     */
  WORD wNmbrChars;          /* Number of characters in the strings   */
  WORD wUnderlineLength;    /* Length of the underline string        */
  WORD wLptIndex;           /* Index to the structure of LPT data    */
  WORD i;                   /* Looping variables                     */
  QSZ  *pqszStrings = NULL; /* Location for storing string pointers  */


  /* Summary information */
  if (szSumStrings != NULL)
    {
      sprintf (szSumStrings[0], "%d", pLpt->wNmbrLptPorts);
      return (NULL);
    }


  /* Calculate the amount of space required for the strings */

  wUnderlineLength = strlen (pszLptUnderline);

  wNmbrChars   = strlen (pszLptHeader1) + 1 +
                 strlen (pszLptHeader2) + 1 +
                 wUnderlineLength       + 1 +
                 (MAX_LPT_PORTS * (wUnderlineLength + 1));

  /* The underline string is expected to be as long as a line of */
  /*   LPT port info.                                            */

  wNmbrStrings = MAX_LPT_PORTS + 4;

  /* "+ 4" is for the 2 header lines, the underline, and the NULL */
  /*   pointer at the end of the array.                           */


  /* Allocate space for the pointer area and string area */
  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);


  /* Put the first three strings in place */

  Qstrcpy (pqszStrings[0], pszLptHeader1);
  pqszStrings[1] = pqszStrings[0] + Qstrlen (pqszStrings[0]) + 1;

  Qstrcpy (pqszStrings[1], pszLptHeader2);
  pqszStrings[2] = pqszStrings[1] + Qstrlen (pqszStrings[1]) + 1;

  Qstrcpy (pqszStrings[2], pszLptUnderline);
  pqszStrings[3] = pqszStrings[2] + wUnderlineLength + 1;

  /* Put the LPT port information in place */

  for (i = 3, wLptIndex = 0; wLptIndex < MAX_LPT_PORTS;
       ++i, ++wLptIndex)
    {
      WORD wLength;       /* Current length of string */
      CHAR chBuffer[80];  /* Buffer for string data   */

      /* Clear out the string */
      Qmemset (pqszStrings[i], ' ', wUnderlineLength);

      /* Port */
      wLength = sprintf (chBuffer, "LPT%d:", wLptIndex + 1);
      Qstrncpy (&pqszStrings[i][LPT_PORT_COL], chBuffer, wLength);

      if (pLpt->LptxInfo[wLptIndex].fLptPortDetected)
        {
          PSZ pszString = NULL;  /* Pointer to a string */

          /* Port Address */
          wLength = sprintf (chBuffer, "%04XH",
                             pLpt->LptxInfo[wLptIndex].wPortAddress);
          Qstrncpy (&pqszStrings[i][LPT_PORT_ADDR_COL], chBuffer, wLength);

          /* Online */
          pszString = (pLpt->LptxInfo[wLptIndex].fOnLine) ?
                      pszYes : pszNo_;
          Qstrncpy (&pqszStrings[i][LPT_ON_LINE_COL], pszString,
                   Qstrlen (pszString));

          /* Paper Out */
          pszString = (pLpt->LptxInfo[wLptIndex].fPaperOut) ?
                      pszYes : pszNo_;
          Qstrncpy (&pqszStrings[i][LPT_PAPER_OUT_COL], pszString,
                   Qstrlen (pszString));

          /* I/O Error */
          pszString = (pLpt->LptxInfo[wLptIndex].fIoError) ?
                      pszYes : pszNo_;
          Qstrncpy (&pqszStrings[i][LPT_I_O_ERROR_COL], pszString,
                   Qstrlen (pszString));

          /* Time Out */
          pszString = (pLpt->LptxInfo[wLptIndex].fTimeOut) ?
                      pszYes : pszNo_;
          Qstrncpy (&pqszStrings[i][LPT_TIME_OUT_COL], pszString,
                   Qstrlen (pszString));

          /* Busy */
          pszString = (pLpt->LptxInfo[wLptIndex].fBusy) ?
                      pszYes : pszNo_;
          Qstrncpy (&pqszStrings[i][LPT_BUSY_COL], pszString,
                   Qstrlen (pszString));

          /* ACK */
          pszString = (pLpt->LptxInfo[wLptIndex].fAck) ?
                      pszYes : pszNo;
          Qstrcpy (&pqszStrings[i][LPT_ACK_COL], pszString);
        }
      else
        {
          /* Not a valid port, fill with dashes */

          pqszStrings[i][LPT_PORT_ADDR_COL + 2] = '-';
          pqszStrings[i][LPT_ON_LINE_COL   + 1] = '-';
          pqszStrings[i][LPT_PAPER_OUT_COL + 1] = '-';
          pqszStrings[i][LPT_I_O_ERROR_COL + 1] = '-';
          pqszStrings[i][LPT_TIME_OUT_COL  + 1] = '-';
          pqszStrings[i][LPT_BUSY_COL      + 1] = '-';
          pqszStrings[i][LPT_ACK_COL       + 1] = '-';
          pqszStrings[i][LPT_ACK_COL       + 2] = '\0';
        }

      /* Set the pointer for the next string */
      pqszStrings[i + 1] = pqszStrings[i] + Qstrlen (pqszStrings[i]) + 1;
    }

  /* Set the last pointer to a NULL */
  pqszStrings[i] = NULL;

  /* Return the pointer to pqszStrings */
  return (pqszStrings);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\id.inc ===
;/* define IDs for machines and displays.

;------------------------------------------------------------------------------
;
;                 Machine Data values used by MachineTest
;
;------------------------------------------------------------------------------

; These equates match the #defines because these will be the values returned
; when the MachineTest function is called.

UNKNOWN_MACHINE                equ       0
IBMPC_XT_AT                    equ       1
IBMPS2_25_30                   equ       2
IBMPS2_50_60_70_80             equ       3
ATT_PC                         equ       4
HP_VECTRA                      equ       5
ZENITH_PC                      equ       6
IBMPS2_70P                     equ       7

;   STANDARD ROM BIOS MACHINE TYPES used in ROM_BIOS_Machine_ID

IBM_PCAT                       equ       0FCh
IBM_PCAT_SUB1                  equ       000h
IBM_PCAT_SUB2                  equ       001h
IBM_PS2_50_SUB                 equ       004h
IBM_PS2_60_SUB                 equ       005h
IBM_PS2_30                     equ       0FAh
IBM_PS2_80                     equ       0F8h
IBM_PS2_30_SUB                 equ       000h
IBM_PS2_80_SUB                 equ       000h
IBM_PS2_80_SUB2                equ       001h
IBM_PS2_25                     equ       0FAh
IBM_PS2_25_SUB                 equ       001h
IBM_PS2_70                     equ       0f8h
IBM_PS2_70_SUB                 equ       004h
IBM_PS2_70_SUB2                equ       009h
IBM_PS2_70_SUBP                equ       00bh

; These table entries determine what type of test will take place. ie test
; machine ID, do a string compare at an absolute location or end the test.

EndTest                        equ       0
MachineID                      equ       1
StringCompare                  equ       2

; Ok, here are the various display ID's needed and returned from the
; hardtest.asm detection module

; Display ID's. These are returned from the GetDisplayID() func

; Mouse ID's returned by GetMouseType().
;
; n.b., values 1 through 5 should not be changed or reassigned.  They match
; the return values from the mouse driver INT 33h's function 36.

UNKNOWN_MOUSE     equ         0     ; Don't know whether or not a mouse is
                                    ; installed...

BUS_MOUSE         equ         1     ; Type of mouse installed.
SERIAL_MOUSE      equ         2
INPORT_MOUSE      equ         3
IBMPS2_MOUSE      equ         4
HP_MOUSE          equ         5

NO_MOUSE          equ         6     ; No mouse installed.
LT_MOUSE          equ         7
LT_PS2MOUSE       equ         8
MSPS2_MOUSE       equ         9
MSBPOINT_MOUSE    equ        10     ; Ballpoint mouse
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\insert.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * INSERT.C - Source file for the Insert Command function.
 ********************************************************************/


/* Include Files */

#include "msd.h"

extern char EditBuf[256];

/*********************************************************************
 * InsertCommand - Performs the Insert Command function.
 ********************************************************************/

VOID InsertCommand (VOID)
{
  BOOL fSearchFlags;        /* Search flags for FindFile */
  FILE_INFO FAR *pfiNext;   /* File info structure       */
  CHAR chBuffer[80];        /* String buffer             */


  /* Bring up the dialog box */
  if (DialogBox (&dlgInsertCmd1, InsertCmdDlg1) != IDOK)
    return;


  /* Boot files are to be found on the boot drive */
  if (stricmp (pszInsertFilename, "CONFIG.SYS") == 0 ||
      stricmp (pszInsertFilename, "AUTOEXEC.BAT") == 0)
    {
      if (wDosMajor >= 4 && wDosMajor < 10)
        fSearchFlags = SEARCH_BOOT_DRIVE;
      else
        fSearchFlags = SEARCH_BOOT_DRIVE   |
                       SEARCH_FLOPPIES     |
                       SEARCH_LOCAL_DRIVES |
                       SEARCH_ROOT;
    }
  else
    fSearchFlags = SEARCH_LOCAL_DRIVES   |
                   SEARCH_ROOT           |
                   RECURSE_INTO_SUB_DIRS;


  if (strchr (pszInsertFilename, '\\') || strchr (pszInsertFilename, ':'))
    {
      /* A pathname was given */
      strcpy (EditBuf, pszInsertFilename);
    }
  else
    {
      /* Search for the file */
      sprintf (chBuffer, "Searching for %s ...", pszInsertFilename);
      ShowStatus (chBuffer);
      pfiDlg = FindFile (pszInsertFilename, NULL, fSearchFlags, '\0');
      PostMessage (pwndStatusLine, WM_PAINT, NULL, NULL);

      /* Were any files found */
      if (pfiDlg == NULL || pfiDlg->fpNextFileInfo == NULL)
        {
          MessageBox (pszInsertFilename, "Could not be found", NULL, MB_OK | 0x8000);
          return;
        }

      pfiNext = (FILE_INFO FAR *) pfiDlg->fpNextFileInfo;

      /* Give the user a choice if more than one file was found */
      if (pfiNext != NULL && pfiNext->fpNextFileInfo != NULL)
        {
          if (DialogBox (&dlgInsertCmd3, InsertCmdDlg3) != IDOK)
            return;
        }
      else
        {
          _fstrcpy (EditBuf, pfiDlg->fpszPathToFile);
          pszInsertFilename = EditBuf;
        }
    }

  /* Search for and add or replace strings as necessary. */
  /*   Actual code to accomplish this will be in the     */
  /*   dialog box code.                                  */

  DialogBox (&dlgInsertCmd4, InsertCmdDlg4);
  FreeFileInfo (pfiDlg);
}


/*********************************************************************
 * ChangeFile - Performs the requested change to the file.
 *
 * pszFilename     - Filename to change.
 * pszSection      - Section to change.
 * pszCommand      - Command to add or replace.
 * pszSearchString - String to search for.
 * wReplaceLine    - Line to replace.  HD_REPLACE_ALL to replace all
 *                   occurances of the search string.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL ChangeFile (PSZ  pszFilename,
                 PSZ  pszSection,
                 PSZ  pszCommand,
                 PSZ  pszSearchString,
                 WORD wReplaceLine)
{
  FILE *fpInsertFile;               /* File handle for the input file  */
  FILE *fpOutputFile;               /* File handle for the output file */
  CHAR szTempPathname[_MAX_PATH];   /* Path to .TMP file               */
  CHAR szBakPathname[_MAX_PATH];    /* Path to .BAK file               */
  INT  i;                           /* Looping variable                */
  BOOL fReturnValue;                /* Return value from various calls */


  /* Create temporary file */

  strcpy (szTempPathname, pszFilename);

  /* Clear out the original file's name */

  for (i = strlen (szTempPathname) - 1; i >= 0 &&
                                        szTempPathname[i] != '\\'; --i)
    ;

  szTempPathname[i + 1] = '\0';

  if (CreateTempFile (szTempPathname) != 0)
    {
      MessageBox, ("Error Creating File", szTempPathname, NULL,
                   MB_OK | 0x8000);
      return (TRUE);
    }


  if ((fpOutputFile = OpenFile (szTempPathname, "w", TRUE)) == NULL)
    return (TRUE);

  if ((fpInsertFile = OpenFile (pszFilename, "rb", TRUE)) == NULL)
    {
      CloseFile (fpOutputFile);
      return (TRUE);
    }

  if (wReplaceLine == 0)  /* Add Line */
    {
      if (pszSection[0] != '\0' &&
          FindSection (pszSection, fpInsertFile, fpOutputFile) == TRUE)
        {
          /* We are adding the section to the file */
          fReturnValue = OutputLine ("", fpOutputFile);
          if (fReturnValue)
            return (fReturnValue);

          fReturnValue = OutputLine (pszSection, fpOutputFile);
          if (fReturnValue)
            return (fReturnValue);
        }

      fReturnValue = OutputLine (pszCommand, fpOutputFile);
      if (fReturnValue)
        return (fReturnValue);

      WriteThrough (fpInsertFile, fpOutputFile);
    }
  /* Replace All */
  else if (wReplaceLine == HD_REPLACE_ALL)
    {
      if (pszSection[0] != '\0')
        FindSection (pszSection, fpInsertFile, fpOutputFile);

      HandleDuplicates ((WORD) HD_REPLACE_ALL, pszSearchString, pszCommand,
                        fpInsertFile, fpOutputFile, NULL);
    }
  else  /* Replace single line */
    {
      if (pszSection[0] != '\0')
        FindSection (pszSection, fpInsertFile, fpOutputFile);

      HandleDuplicates (wReplaceLine, pszSearchString,
                        pszCommand, fpInsertFile,
                        fpOutputFile, NULL);
    }

  /* Close both files */

  CloseFile (fpInsertFile);
  CloseFile (fpOutputFile);

  /* Delete .BAK file */

  strcpy (szBakPathname, pszFilename);

  /* Clear out the original file's extention, if it exists */

  for (i = strlen (szBakPathname) - 1; i >= 0 &&
                                       szBakPathname[i] != '.'; --i)
    ;

  if (i != -1)
    szBakPathname[i] = '\0';

  strcat (szBakPathname, ".BAK");

  DeleteFile (szBakPathname);

  /* Rename main file to .BAK */
  RenameFile (pszFilename, szBakPathname);

  /* Rename temp file to main filename */
  RenameFile (szTempPathname, pszFilename);

  return (FALSE);
}


/*********************************************************************
 * ReadCommands - Reads the "Insert Commands" commands from the
 *                MSD.INI file and adds them to the listbox pointed
 *                to by pwnd.
 *
 * pwnd - Listbox for storing the commands.
 ********************************************************************/

VOID ReadCommands (PWND pwnd)
{
  FILE *fp;   /* File handle to the MSD.INI file */
  CHAR szIniLine[MAX_INI_LINE_LENGTH + 1];  /* Input line from MSD.INI */
  WORD i;     /* Looping variable */


  /* Clear out the listbox */
  SendMessage (pwnd, LB_RESETCONTENT, NULL, NULL);

  /* Open the file */
  fp = OpenIniFile();

  if (fp != NULL && FindSection ("[Commands]", fp, NULL) == FALSE)
    {
      /* Read the lines from the MSD.INI file */
      while (ReadLine (szIniLine, MAX_INI_LINE_LENGTH, fp, FALSE) != EOF)
        {
          /* Break out if this is the end of the section */
          if (szIniLine[0] == '[')
            break;

          /* Ignore comment lines and blank lines */
          if (szIniLine[0] == ';' || szIniLine[0] == '\0')
            continue;

          /* Add the line to the list box */
          AddIniLine (pwnd, szIniLine);
        }

      CloseFile (fp);
    }
  else
    {
      /* Default MSD.INI file settings */
      for (i = 0; paszDefaultMsdIni[i] != NULL; ++i)
        AddIniLine (pwnd, paszDefaultMsdIni[i]);
    }

  return;
}


/*********************************************************************
 * FindSection - Finds the specified section entry in fpInsertFile.
 *               All information with fpInsertFile up to and including
 *               the section line are written to fpOutputFile.
 *
 * pszSection   - Section to search for.
 * fpInsertFile - File to read.
 * fpOutputFile - File to write.  NULL if no write action is
 *                necessary.
 *
 * Returns:  TRUE if an error occured, or the section was not found.
 *           FALSE if the section was found.
 *********************************************************************/

BOOL FindSection (PSZ  pszSection, FILE *fpInsertFile, FILE *fpOutputFile)
{
  CHAR chBuffer [MAX_INI_LINE_LENGTH + 1];  /* Character buffer - no line */
                                            /*   is assumed to be more    */
                                            /*   than MAX_LINE_LENGTH     */
                                            /*   bytes in length.         */
  WORD i1, i2;                              /* Looping variables          */

  /* If the file does not have a section entry, return FALSE */

  if (pszSection[0] == '\0')
    return (TRUE);

  /*************************/
  /* Find the section here */
  /*************************/

  /* Read the line */

  while (ReadLine (chBuffer, MAX_INI_LINE_LENGTH, fpInsertFile, FALSE) != EOF)
    {
      /* Write it out to the output line */

      if (fpOutputFile != NULL)
        if (OutputLine (chBuffer, fpOutputFile))
          return (TRUE);

      /* Skip whitespace at beginning of chBuffer */

      for (i1 = 0; i1 < MAX_INI_LINE_LENGTH && chBuffer[i1] != '\0' &&
                   (chBuffer[i1] == ' ' || chBuffer[i1] == '\t');  ++i1)
        ;

      /* Compare the two strings, up to the end of pszSection */

      for (i2 = 0; i1 < MAX_INI_LINE_LENGTH && chBuffer[i1] != '\0' &&
                   pszSection[i2] != '\0' &&
                   toupper (pszSection[i2]) == toupper (chBuffer[i1]);
                   ++i1, ++i2)
        ;

      /* Did we find a match -- ie, did we get to the end of pszSection */

      if (pszSection[i2] == '\0')
        return (FALSE);
    }

  /* Section was not found */

  return (TRUE);
}


/**********************************************************************
 * HandleDuplicates - Searches for, and optionally replaces command
 *                    strings within a file.  When replacing, writes
 *                    out the changed file.
 *
 * WORD wFunction - wFunction:
 *               HD_SEARCH  - Search for duplicate commands.  Add
 *                            duplicate commands to lbxList.
 *          HD_REPLACE_ALL  - Replace all matching commands with one
 *                            pszReplace string.  pszReplace will
 *                            replace first matching string.
 *                      0-n - Replace n occurance of search string
 *                            with pszReplace.
 * pszSearch      - String to search for.
 * pszReplace     - String to replace.
 * fpInfile       - Input file to search.
 * fpOutfile      - File to contain changes.
 * pwndList       - List box for storing matching strings.
 *
 * Returns: TRUE if an error occured.
 **********************************************************************/

BOOL HandleDuplicates (WORD wFunction,
                       PSZ  pszSearch,
                       PSZ  pszReplace,
                       FILE *fpInfile,
                       FILE *fpOutfile,
                       PWND pwndList)
{
  char chBuffer [MAX_INI_LINE_LENGTH + 1];  /* Character buffer - no line is */
                                        /*   assumed to be more than     */
                                        /*   MAX_INI_LINE_LENGTH bytes in    */
                                        /*   length.                     */
  char chBuffer2[MAX_INI_LINE_LENGTH + 1];  /* Used for adding "REPLACE " to */
                                        /*   the beginning of the line   */
                                        /*   in the list box.            */
  BOOL fMatch;                          /* Flag for match                */
  WORD wMatchCount = 0;                 /* Incriments for each match     */


  while (ReadLine (chBuffer, MAX_INI_LINE_LENGTH, fpInfile, FALSE) != EOF)
    {
      /* Set match flag */

      fMatch = HdMatch (pszSearch, chBuffer);

      switch (wFunction)
        {
          case HD_SEARCH: /* Search for duplicates */

            /* Does chBuffer match the search string */

            if (fMatch)
              {
                chBuffer2[0] = '\0';
                strcat (chBuffer2, "REPLACE ");
                strcat (chBuffer2, chBuffer);

                /* Add item to the listbox */
                SendMessage (pwndList, LB_ADDSTRING,
                             ((WORD) (isaNil) << 8) + TRUE,
                             (DWORD) ((CHAR FAR *) (chBuffer2)));
              }

            break;

          case HD_REPLACE_ALL: /* Replace all duplicates */

            /* Is this the first match */

            if (fMatch)
              if (++wMatchCount == 1)
                {
                  /* Replace first match with replace string */
                  if (OutputLine (pszReplace, fpOutfile))
                    return (TRUE);
                }

            /* If there was no match, output the line */

            if (!fMatch)
              if (OutputLine (chBuffer, fpOutfile))
                return (TRUE);

            break;

          default:  /* Replace wFunction duplicate line */

            /* Is this the correct matching line */

            if (fMatch && ++wMatchCount == wFunction)
              {
                /* Replace correct match with replace string */

                if (OutputLine (pszReplace, fpOutfile))
                  return (TRUE);

                /* Write out the rest of the file */
                WriteThrough (fpInfile, fpOutfile);
              }
            else
              if (OutputLine (chBuffer, fpOutfile))
                return (TRUE);

            break;
        }
    }

  return (FALSE);
}


/**********************************************************************
 * HdMatch - Match checking routine for HandleDuplicates
 *
 * pszSearch   - Search string to compare for matched strings.
 * pszFullLine - Line to compare to see if a match occured.
 *
 * Returns: TRUE if match occured, FALSE if not.
 **********************************************************************/

BOOL HdMatch (char *pszSearch, char *pszFullLine)
{
  WORD i;   /* Looping variable */

  for (i = 0; i < strlen (pszSearch) &&
              toupper (pszSearch[i]) == toupper (pszFullLine[i]); ++i)
    ;

  if (i == strlen (pszSearch))
    return (TRUE);
  else
    return (FALSE);
}


/*********************************************************************
 * OpenIniFile - Opens the MSD.INI file.
 *
 * Global:
 *   pszPathToProgram - Path to the .EXE file.
 *
 * Returns: File handle to MSD.INI.  NULL if an error occured.
 *********************************************************************/

FILE * OpenIniFile (VOID)
{
  CHAR szIniPathname[_MAX_PATH];      /* Used to store .INI filename */
  static WORD i;                      /* Looping variable */
  static PSZ  pszIniFilename = "MSD.INI";  /* .INI filename */


  /* Copy the pathname to MSD.EXE to szIniPathname */

  strcpy (szIniPathname, pszPathToProgram);

  /* Search for the first "\" (it should be a fully qualified path, */
  /*   as in "C:\WINDOWS\MSD.EXE".                                  */

  for (i = strlen (szIniPathname); i > 0 && szIniPathname[i] != '\\'; --i)
    ;

  if (i == 0) /* szIniPathname did not contain a fully qualified path */
    {
      /* Hope there is a MSD.INI file in the current directory */

      strcpy (szIniPathname, pszIniFilename);
    }
  else /* A fully qualified path was found */
    {
      /* Remove MSD.EXE */

      szIniPathname[++i] = '\0';

      /* Add MSD.INI */

      strcat (szIniPathname, pszIniFilename);
    }

  /* Open the .INI file */

  return (OpenFile (szIniPathname, "rb", FALSE));
}


/**********************************************************************
 * WriteThrough - Writes all characters through from input file to
 *                output file.
 *
 * fpInputFile  - Input file.
 * fpOutputFile - Output file.
 *
 * Returns: TRUE if an error occured.
 **********************************************************************/

BOOL WriteThrough (FILE *fpInputFile, FILE *fpOutputFile)
{
  CHAR chBuffer[256];         /* Input buffer                        */
  BOOL fReturnValue = FALSE;  /* Return value from various functions */

  while (fReturnValue == FALSE)
    {
      if (ReadLine (chBuffer, 255, fpInputFile, FALSE) == EOF)
        fReturnValue = TRUE;

      if (fReturnValue == FALSE)
        fReturnValue = OutputLine (chBuffer, fpOutputFile);
    }

  return (fReturnValue);
}


/**********************************************************************
 * AddIniLine - Adds a line to the list box
 *
 * pszString    - Comma delimited string to add to the list box.
 * plbxCommands - Listbox to fill.
 **********************************************************************/

VOID AddIniLine (PWND pwndList, PSZ pszString)
{
  static char chBuffer[80];      /* Stores expanded string */
  static int i, i1, i2;          /* Looping varaibles */
  static int fQuotedString;      /* Flag.  1 means this is a quoted string */
  static int aiColumns[] =  /* Locations of the columns in list box */
    {
      INI_COMMAND_COL,
      INI_SECTION_COL,
      INI_FILENAME_COL,
      79
    };


  /* Clear out chBuffer */

  memset (chBuffer, ' ', 79);

  chBuffer[80] = '\0';

  /* Start loop to fill in the various sections */

  for (i = 0; aiColumns[i] < 79; ++i)
    {

      /* Skip any white space at the beginning of the string */

      for (i1 = 0; pszString[i1] != '\0' && pszString[i1] != ',' &&
                  (pszString[i1] == '\t' || pszString[i1] == ' ');   ++i1)
        ;

      /* Is the first character a quote */

      if (pszString[i1] == '\"')
        {
          ++i1;
          fQuotedString = 1;
        }
      else
        fQuotedString = 0;

      /* Copy the command to chBuffer */

      for (i2 = aiColumns[i]; i2 < aiColumns[i + 1] &&
                              pszString[i1] != '\0' &&
                              ((fQuotedString && pszString[i1] != '\"') ||
                              (!fQuotedString && pszString[i1] != ','));
                              ++i1, ++i2)
        chBuffer[i2] = pszString[i1];

      /* Search for the next section */

      if (fQuotedString && pszString[i1] != '\0')
        {
          for (++i1; pszString[i1] != '\0' && pszString[i1] != ','; ++i1)
            ;
        }

      if (pszString[i1] != '\0')
        {
          /* Skip white space after the comma */

          for (++i1; pszString[i1] != '\0' && pszString[i1] != ',' &&
                    (pszString[i1] == '\t' || pszString[i1] == ' '); ++i1)
            ;
        }

      pszString += i1;
    }

  chBuffer[i2] = '\0';

  SendMessage (pwndList, LB_ADDSTRING, ((WORD) (isaNil) << 8) + TRUE,
               (DWORD) ((CHAR FAR *) (chBuffer)));
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\irqinfo.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * IRQINFO.C - Source file for serial port detection code.
 ********************************************************************/


/* Include Files */

#include "msd.h"


/* Stores the interrupt vector table at program startup */

DWORD *padwIntTable = NULL;


/*********************************************************************
 * GetIrqInfo - Gets the hardware interrupt (IRQ) information.
 *
 * pIrq         - IRQ structure for storing data
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetIrqInfo (IRQ_STRUCT *pIrq, BOOL fMinimumInfo)
{
  /* Structure pointers for holding data related to IRQs */

  COMPUTER_STRUCT       *pComputer = NULL;
  MOUSE_STRUCT          *pMouse    = NULL;
  DISK_STRUCT           *pDisk     = NULL;
  LPT_STRUCT            *pLpt      = NULL;
  COM_STRUCT            *pCom      = NULL;
  TSR_PROGRAMS_STRUCT   *pTsr      = NULL;
  DEVICE_DRIVER_STRUCT  *pDevice   = NULL;

  BOOL fReturnValue = FALSE;    /* Return value from various GetInfo calls */
  WORD wSize;                   /* Size, in bytes, to store the data       */
  WORD i;                       /* Looping variable                        */
  VOID *pStructForInfo = NULL;  /* Pointer to a generic struct             */
  BYTE FAR *fpBunchOfBytes = NULL;


  /* There is no minimum info from this routine */
  if (fMinimumInfo)
    return (FALSE);

#if HEAP_DEBUG
  HeapCheck ("Beginning of GetIrqInfo");
#endif

  /* See if any low memory locations change */
  fpBunchOfBytes = _fmalloc (256 * 4);
  _fmemcpy (fpBunchOfBytes, (BYTE FAR *) 0x00000000, 256*4);

#if HEAP_DEBUG
  HeapCheck ("After copy of BunchOfBytes");
#endif

  /* Fill the structures with the information related to IRQs */

  for (i = 0; fReturnValue == FALSE && rwIrqRecordTypes[i] != 0; ++i)
    {
      wSize = GetInfoSize (rwIrqRecordTypes[i], FALSE);

      if (wSize == 0)
        {
          fReturnValue = TRUE;
          break;
        }

      pStructForInfo = malloc (wSize);

      if (pStructForInfo == NULL)
        {
          OutOfMemory();
          fReturnValue = TRUE;
          break;
        }


      /* Zero out the structure before passing it on */
      memset (pStructForInfo, '\0', wSize);

      {
#if HEAP_DEBUG
        CHAR chBuffer[80];
        sprintf (chBuffer, "After malloc for IDI_ %d", rwIrqRecordTypes[i]);
        HeapCheck (chBuffer);
#endif
      }

      switch (rwIrqRecordTypes[i])
        {
          case IDI_COMPUTER_RECORD:
            fReturnValue = GetComputerIrqInfo (pStructForInfo);
            if (!fReturnValue)
              pComputer = (COMPUTER_STRUCT *) pStructForInfo;
            break;

          case IDI_MOUSE_RECORD:
            fReturnValue = GetInfo (rwIrqRecordTypes[i],
                                    pStructForInfo,
                                    FALSE,
                                    FALSE,
                                    FALSE);
            if (!fReturnValue)
              pMouse = (MOUSE_STRUCT *) pStructForInfo;
            break;

          case IDI_DISK_DRIVE_RECORD:
            fReturnValue = GetInfo (rwIrqRecordTypes[i],
                                    pStructForInfo,
                                    TRUE,   /* Minimum Info */
                                    FALSE,
                                    FALSE);
            if (!fReturnValue)
              pDisk = (DISK_STRUCT *) pStructForInfo;
            break;

          case IDI_LPT_RECORD:
            fReturnValue = GetInfo (rwIrqRecordTypes[i],
                                    pStructForInfo,
                                    FALSE,
                                    FALSE,
                                    FALSE);
            if (!fReturnValue)
              pLpt = (LPT_STRUCT *) pStructForInfo;
            break;

          case IDI_COM_RECORD:
            fReturnValue = GetInfo (rwIrqRecordTypes[i],
                                    pStructForInfo,
                                    FALSE,
                                    FALSE,
                                    FALSE);
            if (!fReturnValue)
              pCom = (COM_STRUCT *) pStructForInfo;
            break;
        }
    }

  if (fReturnValue)
    {
      free (pCom);
      free (pLpt);
      free (pDisk);
      free (pMouse);
      free (pComputer);

      return (fReturnValue);
    }


  /* Determine how many IRQs the computer has:  A Cascaded IRQ2 */
  /*   means that there are 16 IRQs, without means 8 (IRQs are  */
  /*   numbered starting at zero).                              */

  if (pComputer->fCascadeIntLvl2)
    pIrq->wNmbrIrqs = 15;
  else
    pIrq->wNmbrIrqs = 7;


  /* Set the serial strings for PS/2 or non-PS/2 computers */
  if (pComputer->wComputerClass == COMPUTER_CLASS_PS2)
    {
      paszAtIrqDescriptions[3][5]  = '\0';
      paszAtIrqDescriptions[4][11] = ' ';
    }


  /* Set the "detected" strings */
  SetIrqDetectedStrings (pIrq,
                         pComputer,
                         pMouse,
                         pDisk,
                         pLpt,
                         pCom);
  _memmax();
  free (pComputer);
  free (pMouse);
  free (pDisk);
  free (pLpt);
  free (pCom);
  _memmax();


  /* Get TSR info */
  wSize = GetInfoSize (IDI_TSR_PROGRAMS_RECORD, FALSE);
  if (wSize == 0)
    return (TRUE);

  pTsr = malloc (wSize);
  if (pTsr == NULL)
    {
      OutOfMemory();
      return (TRUE);
    }

  /* Zero out the structure before passing it on */
  memset (pTsr, '\0', wSize);
  fReturnValue = GetInfo (IDI_TSR_PROGRAMS_RECORD, pTsr,
                          FALSE, FALSE, FALSE);


  /* Get Device Driver info */
  wSize = GetInfoSize (IDI_DEVICE_DRIVERS_RECORD, FALSE);
  if (wSize == 0)
    return (TRUE);

  pDevice = malloc (wSize);
  if (pDevice == NULL)
    {
      OutOfMemory();
      return (TRUE);
    }

  /* Zero out the structure before passing it on */
  memset (pDevice, '\0', wSize);
  fReturnValue = GetInfo (IDI_DEVICE_DRIVERS_RECORD, pDevice,
                          FALSE, FALSE, FALSE);

  _memmax();
  /* Set the Interrupt vector address and the "Handled By" string */
  SetIrqHandledByStrings (pIrq,
                          pTsr,
                          pDevice);


  /* Free up the structure data */

  free (pDevice);
  free (pTsr);

#if HEAP_DEBUG
  HeapCheck ("After GetIrqInfo's set of free()s");
#endif

  return (FALSE);
}


/*********************************************************************
 * SetIrqDetectedStrings - Sets the szDetected[][] strings in the IRQ
 *                         data structure.
 *
 * pIrq      - IRQ information structure
 * pComptuer - Computer information structure
 * pMouse    - Mouse information structure
 * pLpt      - LPT Port information structure
 * pCom      - COM Port information structure
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL SetIrqDetectedStrings (IRQ_STRUCT       *pIrq,
                            COMPUTER_STRUCT  *pComputer,
                            MOUSE_STRUCT     *pMouse,
                            DISK_STRUCT      *pDisk,
                            LPT_STRUCT       *pLpt,
                            COM_STRUCT       *pCom)
{
  union REGS inregs, outregs;   /* Register structures for int86 call */
  WORD i, u, x;                 /* Looping variables                  */

  for (i = 0; i <= pIrq->wNmbrIrqs; ++i)
    {
      for (u = 0; u < MAX_IRQ_DETECTED_STRINGS; ++u)
        pIrq->IrqxInfo[i].szDetected[u][0] = '\0';

      /* Zero out the index to pIrq->IrqxInfo[i].szDetected[] */
      u = 0;

      /* PC IRQ 5 == AT IRQ 14 */
      if (i == 5 && pComputer->wComputerClass == COMPUTER_CLASS_XT)
        i = 14;

      switch (i)
        {
          /* Timer Click, always assumed to be there */
          case  0:
            {
              pIrq->IrqxInfo[i].fDetected = TRUE;
              strcpy (pIrq->IrqxInfo[i].szDetected[0], pszYes);
              break;
            }

          /* Keyboard, always assumed to be there */
          case  1:
            {
              pIrq->IrqxInfo[i].fDetected = TRUE;
              strcpy (pIrq->IrqxInfo[i].szDetected[0], pszYes);
              break;
            }

          /* Cascade IRQ2 (AT) or I/O Channel (PC, always */
          /*   assumed to be there)                       */
          case  2:
            {
              if (pComputer->wComputerClass == COMPUTER_CLASS_XT)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++], pszYes);
                }
              else if (pComputer->fCascadeIntLvl2)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++], pszYes);
                }
              else
                {
                  pIrq->IrqxInfo[i].fDetected = FALSE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++], pszNo);
                }

              /* Check for a mouse */
              if (pMouse->wIrq == i)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++],
                          pMouse->szMouseHardwareType);
                }
              break;
            }

          /* COM2: (all), COM4: (non PS/2) */
          case  3:
            {
              /* COM2: index == 1 */
              if (pCom->ComxInfo[1].fComPortDetected)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++], pszCom[2]);
                }

              /* COM4: index == 3 */
              if (pCom->ComxInfo[3].fComPortDetected &&
                  pComputer->wComputerClass != COMPUTER_CLASS_PS2)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++], pszCom[4]);
                }

              /* Check for a mouse */
              if (pMouse->wIrq == i)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++],
                          pMouse->szMouseHardwareType);
                }

              /* If nothing was detected for IRQ 3, set it to "No" */
              if (u == 0)
                {
                  pIrq->IrqxInfo[i].fDetected = FALSE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[0], pszNo);
                }

              break;
            }

          /* COM1:/COM3: (all), COM4: (PS/2) */
          case  4:
            {
              /* COM1: index == 0 */
              if (pCom->ComxInfo[0].fComPortDetected)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++], pszCom[1]);
                }

              /* COM3: index == 2 */
              if (pCom->ComxInfo[2].fComPortDetected)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++], pszCom[3]);
                }

              /* COM4: index == 3 */
              if (pCom->ComxInfo[3].fComPortDetected &&
                  pComputer->wComputerClass == COMPUTER_CLASS_PS2)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++], pszCom[4]);
                }

              /* Check for a mouse */
              if (pMouse->wIrq == i)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++],
                          pMouse->szMouseHardwareType);
                }

              /* If nothing was detected for IRQ 4, set it to "No" */
              if (u == 0)
                {
                  pIrq->IrqxInfo[i].fDetected = FALSE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[0], pszNo);
                }

              break;
            }

          /* LPT2: */
          case  5:
            {
              /* LPT2: index = 1 */
              if (pLpt->LptxInfo[1].fLptPortDetected)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++], pszYes);
                }

              /* Check for a mouse */
              if (pMouse->wIrq == i)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++],
                          pMouse->szMouseHardwareType);
                }

              /* If nothing was detected for IRQ 5, set it to "No" */
              if (u == 0)
                {
                  pIrq->IrqxInfo[i].fDetected = FALSE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[0], pszNo);
                }

              break;
            }

          /* Floppy Controller */
          case  6:
            {
              int86 (0x11, &inregs, &outregs);

              /* Bit zero is set if floppies are present */
              if (outregs.x.ax & 1)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++], pszYes);
                }

              /* Check for a mouse */
              if (pMouse->wIrq == i)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++],
                          pMouse->szMouseHardwareType);
                }

              /* If nothing was detected for IRQ 6, set it to "No" */
              if (u == 0)
                {
                  pIrq->IrqxInfo[i].fDetected = FALSE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[0], pszNo);
                }

              break;
            }

          /* LPT1: */
          case  7:
            {
              /* LPT1: index = 0 */
              if (pLpt->LptxInfo[0].fLptPortDetected)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++], pszYes);
                }

              /* Check for a mouse */
              if (pMouse->wIrq == i)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++],
                          pMouse->szMouseHardwareType);
                }

              /* If nothing was detected for IRQ 7, set it to "No" */
              if (u == 0)
                {
                  pIrq->IrqxInfo[i].fDetected = FALSE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[0], pszNo);
                }

              break;
            }

          /* Real Time Clock */
          case  8:
            {
              if (pComputer->fRealTimeClock)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[0], pszYes);
                }
              else
                {
                  pIrq->IrqxInfo[i].fDetected = FALSE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[0], pszNo);
                }

              break;
            }

          /* Redirected IRQ2 */
          case  9:
            {
              if (pComputer->fCascadeIntLvl2)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[0], pszYes);
                }
              else
                {
                  pIrq->IrqxInfo[i].fDetected = FALSE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[0], pszNo);
                }
              break;
            }

          /* Reserved:  I don't detect these */
          case 10:
          case 11:
          case 15:
            break;


          case 12:
            /* Check for a mouse */
            if (pMouse->wIrq == i)
              {
                pIrq->IrqxInfo[i].fDetected = TRUE;
                strcpy (pIrq->IrqxInfo[i].szDetected[u++],
                        pMouse->szMouseHardwareType);
              }
            break;

          /* Math Co-processor */
          case 13:
            {
              if (pComputer->wCoProcessor != _NOCOPROCESSOR ||
                  pComputer->wProcessor   == _80486)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[0], pszYes);
                }
              else
                {
                  pIrq->IrqxInfo[i].fDetected = FALSE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[0], pszNo);
                }
              break;
            }

          /* Fixed Disk (PC = IRQ 5, non-PC = IRQ 14) */
          case 14:
            {
              /* Restore "i" to the correct value */
              if (i == 14 && pComputer->wComputerClass == COMPUTER_CLASS_XT)
                i = 5;

              for (x = 0; x < pDisk->wNmbrDrives &&
                          pDisk->asdi[x].wDriveType != DISK_FIXED_DISK; ++x)
                ;

              if (x == pDisk->wNmbrDrives)
                {
                  pIrq->IrqxInfo[i].fDetected = FALSE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++], pszNo);
                }
              else
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++], pszYes);
                }

              /* Check for a mouse */
              if (pMouse->wIrq == i)
                {
                  pIrq->IrqxInfo[i].fDetected = TRUE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[u++],
                          pMouse->szMouseHardwareType);
                }

              /* If nothing was detected for IRQ 4, set it to "No" */
              if (u == 0)
                {
                  pIrq->IrqxInfo[i].fDetected = FALSE;
                  strcpy (pIrq->IrqxInfo[i].szDetected[0], pszNo);
                }

              break;
            }
        }
    }

  return (FALSE);
}


/*********************************************************************
 * SetIrqHandledByStrings - Sets the szHandledBy[] strings and the
 *                          IRQ Address in the IRQ data structure.
 *
 * pIrq    - IRQ information structure
 * pTsr    - TSR Program information structure
 * pDevice - Device Driver information structure
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL SetIrqHandledByStrings (IRQ_STRUCT           *pIrq,
                             TSR_PROGRAMS_STRUCT  *pTsr,
                             DEVICE_DRIVER_STRUCT *pDevice)
{
  BOOL  fFoundHandler;        /* TRUE if IRQ handler found             */
  WORD  i, u;                 /* Looping variables                     */
  WORD  wSwInt;               /* Software interrupt number             */
  WORD  wDeviceHeaderSeg;     /* Segment of the device driver's header */
  DWORD dwLowestMcbSeg;       /* Lowest MCB segment (anything lower is */
                              /*   the DOS System Area)                */
  DWORD dwNormalIntVector;    /* Normalized interrupt vector (ie,      */
                              /*   F000:1234 becomes F1234)            */
  DWORD dwNormalTsrAddress;   /* Normalized TSR Address                */


  /* Calculate the lowest MCB */

  dwLowestMcbSeg = 0xFFFF;

  for (u = 0; !(pTsr[u].wAddress == 0 && pTsr[u].dwBlockSize == 0); ++u)
    {
      if (pTsr[u].wAddress != 0x0008 &&
          pTsr[u].wAddress < (WORD) dwLowestMcbSeg)
        dwLowestMcbSeg = (DWORD) pTsr[u].wAddress;
    }

  /* Normalize the lowest MCB */
  dwLowestMcbSeg = dwLowestMcbSeg << 4;


  /* Set the szHandledBy for all IRQs */

  for (i = 0, wSwInt = 8; i <= pIrq->wNmbrIrqs; ++i, ++wSwInt)
    {
      /* IRQ0-IRQ7 use INT 08-10H, IRQ8-IRQ15 use INT 70-77H */
      if (i == 8)
        wSwInt = 0x70;

      /* Clear out the szHandledBy string */
      pIrq->IrqxInfo[i].szHandledBy[0] = '\0';

      /* Set the "Found" flag to FALSE */
      fFoundHandler = FALSE;

      /* Set the IRQ Address in the IRQ structure */
      pIrq->IrqxInfo[i].dwIrqAddress = padwIntTable[wSwInt];

      /* Set the interrupt's Normalized vector */
      dwNormalIntVector  = ((DWORD) FP_SEG (padwIntTable[wSwInt]) << 4) +
                           FP_OFF (padwIntTable[wSwInt]);


      /* Is the BIOS handling the interrupt */

      if (fFoundHandler == FALSE && dwNormalIntVector >= 0xF0000)
        {
          strcpy (pIrq->IrqxInfo[i].szHandledBy, pszBIOS);
          fFoundHandler = TRUE;
        }


      /* Check for device drivers handling this interrupt */

      for (u = 0; fFoundHandler == FALSE && pDevice[u].dwHeader != 0; ++u)
        {
          wDeviceHeaderSeg = (WORD) (pDevice[u].dwHeader >> 16);

          /* A match is determined if the segment of the interrupt */
          /*   matches the segment of the device driver's header.  */
          /*   Address 0070: is excluded as that is the DOS system */
          /*   area.                                               */

          if (wDeviceHeaderSeg != 0x0070 &&
              wDeviceHeaderSeg == (WORD) (padwIntTable[wSwInt] >> 16))
            {
              /* A match was found */
              strcpy (pIrq->IrqxInfo[i].szHandledBy,
                      pDevice[u].szDeviceName);
              fFoundHandler = TRUE;
            }
        }


      /* Check for TSR programs handling this interrupt */

      for (u = 0; fFoundHandler       == FALSE  &&
                  !(pTsr[u].wAddress  == 0      &&
                  pTsr[u].dwBlockSize == 0);       ++u)
        {
          /* A match is determined if the interrupt vector points to */
          /*   a location within a TSR's MCB                         */

          dwNormalTsrAddress = (DWORD) pTsr[u].wAddress << 4;

          if (dwNormalIntVector >= dwNormalTsrAddress &&
              dwNormalIntVector <= dwNormalTsrAddress + pTsr[u].dwBlockSize)
            {
              /* A match was found.  Skip if it is the "DOS System Data" */
              /*   in DOS versions 4.0 and up.                           */
              if (wDosMajor >= 4 && wDosMajor < 10 &&
                  strcmp (pTsr[u].szTsrName, pszDosSystemData) == 0)
                continue;

              if (pTsr[u].szTsrName[0] == ' ' && pTsr[u].szTsrName[1] == ' ')
                strcpy (pIrq->IrqxInfo[i].szHandledBy,
                        &(pTsr[u].szTsrName[2]));
              else
                strcpy (pIrq->IrqxInfo[i].szHandledBy,
                        pTsr[u].szTsrName);

              fFoundHandler = TRUE;
            }
        }


      /* Is the DOS System Area handling the interrupt */

      if (fFoundHandler == FALSE && dwNormalIntVector < dwLowestMcbSeg)
        {
          strcpy (pIrq->IrqxInfo[i].szHandledBy, pszDosSystemArea);
          fFoundHandler = TRUE;
        }


      /* Otherwise, I don't know who is handling this interrupt */
      if (fFoundHandler == FALSE)
        strcpy (pIrq->IrqxInfo[i].szHandledBy, pszUnknown);
    }

  return (FALSE);
}


/*********************************************************************
 * SprintIrqInfo - Put IRQ information into a set of strings to be
 *                 printed or displayed.
 *
 * Returns:  NULL if an error occured.
 *********************************************************************/

QSZ * SprintIrqInfo (IRQ_STRUCT *pIrq)
{
  WORD wNmbrStrings;            /* Number of strings                      */
  WORD wNmbrChars;              /* Number of characters in the strings    */
  WORD wUnderlineLength;        /* Length of the underline string         */
  WORD wIrqIndex;               /* Index to the structure of IRQ data     */
  WORD i;                       /* Looping variables                      */
  QSZ  *pqszStrings = NULL;     /* Location for storing string pointers   */
  PSZ  *paszIrqTitles = NULL;   /* The appropriate IRQ titles for PC or   */
                                /*   AT/PS/2                              */


  /* Choose the appropriate set of titles */

  if (pIrq->wNmbrIrqs == 7)
    paszIrqTitles = paszPcIrqDescriptions;
  else
    paszIrqTitles = paszAtIrqDescriptions;


  /* Calculate the amount of space required for the strings */

  wUnderlineLength = strlen (pszIrqUnderline);

  wNmbrChars   = strlen (pszIrqHeader) + 1 +
                 wUnderlineLength      + 1 +
                 ((pIrq->wNmbrIrqs + 1) * (wUnderlineLength + 1));

  /* The underline string is expected to be as long as a line of */
  /*   IRQ info.                                                 */

  wNmbrStrings = pIrq->wNmbrIrqs + 4;


  /* Allocate space for the pointer area and string area */
  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);


  /* Put the first two strings in place */

  Qstrcpy (pqszStrings[0], pszIrqHeader);
  pqszStrings[1] = pqszStrings[0] + Qstrlen (pqszStrings[0]) + 1;

  Qstrcpy (pqszStrings[1], pszIrqUnderline);
  pqszStrings[2] = pqszStrings[1] + wUnderlineLength + 1;


  /* Put the IRQ information in place */

  for (i = 2, wIrqIndex = 0; wIrqIndex <= pIrq->wNmbrIrqs;
       ++i, ++wIrqIndex)
    {
      WORD u;             /* Looping variable                */
      WORD wLength;       /* Current length of string        */
      CHAR chBuffer[80];  /* Buffer for string data          */

      /* Clear out the string */
      Qmemset (pqszStrings[i], ' ', wUnderlineLength);
      pqszStrings[i][wUnderlineLength] = '\0';

      /* IRQ number */
      sprintf (chBuffer, "%3d", wIrqIndex);
      Qstrncpy (pqszStrings[i], chBuffer, strlen (chBuffer));

      /* Address */
      sprintf (chBuffer, "%04X:%04X",
               FP_SEG (pIrq->IrqxInfo[wIrqIndex].dwIrqAddress),
               FP_OFF (pIrq->IrqxInfo[wIrqIndex].dwIrqAddress));
      Qstrncpy (&pqszStrings[i][IRQ_ADDRESS_COL], chBuffer,
               strlen (chBuffer));

      /* Description */
      Qstrncpy (&pqszStrings[i][IRQ_DESCRIPTION_COL],
               paszIrqTitles[wIrqIndex],
               strlen (paszIrqTitles[wIrqIndex]));

      /* Detected strings */
      for (u = 0, wLength = 0;
           u < MAX_IRQ_DETECTED_STRINGS &&
           pIrq->IrqxInfo[wIrqIndex].szDetected[u][0] != '\0';
           ++u)
        {
          /* Add this "detected" string */
          Qstrncpy (&pqszStrings[i][IRQ_DETECTED_COL + wLength],
                   pIrq->IrqxInfo[wIrqIndex].szDetected[u],
                   strlen (pIrq->IrqxInfo[wIrqIndex].szDetected[u]));

          /* Move to one space past this "detected" string */
          wLength += strlen (pIrq->IrqxInfo[wIrqIndex].szDetected[u]) + 1;
        }

      /* Handled By */
      Qstrcpy (&pqszStrings[i][IRQ_HANDLED_BY_COL],
              pIrq->IrqxInfo[wIrqIndex].szHandledBy);

      /* Set the pointer for the next string */
      PrepNextString (pqszStrings, i);
    }

  /* Set the last pointer to a NULL */
  pqszStrings[i] = NULL;

  /* Return the pointer to pqszStrings */
  return (pqszStrings);
}


/*********************************************************************
 * GetSwIntTable - Makes a copy of the software interrupt vector table
 *                 at program start up time.
 *
 * Global: padwIntTable - Pointer to an array of DWORDs to store the
 *                        interrupt vectors.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetSwIntTable (VOID)
{
  union  REGS  regs;    /* Registers for int86x         */
  struct SREGS sregs;   /* Segment registers for int86x */
  WORD  i;              /* Looping variable             */


  /* Make room to store the table */

  padwIntTable = malloc (sizeof (DWORD) * 256);

  if (padwIntTable == NULL)
    {
      OutOfMemory();
      return (TRUE);
    }


  /* This is the quick and easy way */
  /*
  _femcpy ((DWORD FAR *) padwIntTable,
           (DWORD FAR *) 0x00000000,
           sizeof (DWORD) * 256);
  */


  /* This is the official way */

  for (i = 0; i < 256; ++i)
    {
      /* Get interrupt vector */
      regs.h.ah = 0x35;
      regs.h.al = (BYTE) i;
      int86x (0x21, &regs, &regs, &sregs);

      /* Store the interrupt vector */
      padwIntTable[i] = ((DWORD) sregs.es << 16) + regs.x.bx;
    }

  if (maxParsedLine[6] != '\0')
    OsErr();

  return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\md.asm ===
.MODEL medium
;***************************************************************************
;*                                                                         *
;* MD.ASM Mouse detection code.                                            *
;*                                                                         *
;***************************************************************************

memM = 1       ; Medium Model
?WIN = 0       ; No windows prolog / epilog code (std epilog / prolog).
?PLM = 0       ; CPROC calling convention.  NOT Pascal

INCLUDE cmacros.inc     ;* must be version 2.09 or higher
INCLUDE md.inc
INCLUDE id.inc


cPublic MACRO   n,c,a
  cProc n,<PUBLIC, c>,<a>
ENDM


sBegin  DATA

LATLSBSave           db  ?
LATMSBSave           db  ?
LCRSave              db  ?
MCRSave              db  ?
IERSave              db  ?
fSingle8259          db  0
SerialBuf            db  10 dup (?)
SemaphoreWord        dw  ?

COM_3_4_ADDRS        LABEL     WORD
                 dw  03E8h
                 dw  02E8h

sEnd   DATA

sBegin  CODE

assumes CS, CODE
assumes DS, DATA

;*****************************************************************************
;
;       int fnHardMouseDetect(void);
;
;       This procedure what type of mouse is being used. It will determine
;       that that type of mouse is present in the system and is working
;       properly.
;
;       ENTRY   None.
;
;       EXIT    Mouse type in AX. or if AX = -1 the hardware will not support
;                                               mouse detection.
;
;       ALTERS  AX, BX, CX, DX, SI, DI
;
;       CALLS   TestForInport
;               IRQAvailable
;               TestForBus
;               TestForSerial
;               TestForPS2
;
;*****************************************************************************

cProc   fnHardMouseDetect <PUBLIC, FAR>, <ES, DS, SI, DI>
        localW  locvar1
cBegin  fnHardMouseDetect

; First of all we need to know if the two int 15h call we need to make are
; supported on the hardware were running on. So, the setup_for_detect call
; will do just that, setup for the detection. If the call returns carry set
; then it's "game over man" because we won't have the int 15h calls we need.

        call    setup_for_detect
        mov     locvar1,-1
        jc      finished_mouse

; Now that we know the hardware will support the code used here to detect
; mice we can go about our business of detecing mice !!
;

        mov     locvar1,NO_MOUSE         ; Initilize the return value.

;
; First try, we'll look for an inport mouse !
;

        mov     dx,INPORT_FIRST_PORT + 2 ; Get address of ID register.

inport_try_again:
        call    TestForInport           ; Does an InPort exist at this address?
        jnc     inport_found            ; No carry ! Inport found !

        sub     dx,4                    ; Nope, try the next possible port.
        cmp     dx,INPORT_LAST_PORT + 2
        jae     inport_try_again
        jmp     short look_for_bus

inport_found:
        mov     locvar1,INPORT_MOUSE
        jmp     finished_mouse

;
; We enter this point if we couldn't find an InPort mouse in the system.
;

look_for_bus:
        call    TestForBus            ; Does a Bus mouse exist in the system?
        jc      look_for_PS2          ; No, look for a PS/2 mouse.

        mov     locvar1,BUS_MOUSE     ; Indicate bus mouse found.
        jmp     finished_mouse
        
;
; We enter this point if we couldn't find either an InPort
; mouse or a Bus mouse in the system.
;

look_for_PS2:
        call    LookForPS2Mouse

        cmp     ax,NO_MOUSE
        je      look_for_serial

        mov     locvar1,AX              ; Yep! return mouse type !
        jmp     short finished_mouse

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       call    TestForPS2              ; Does a PS/2 style mouse exist?
;       jc      look_for_serial         ; Nope, check for serial mouse.
;
;       mov     locvar1,LT_PS2MOUSE     ; Yep! return mouse type !
;       jc      finished_mouse          ; Nope, leave with error.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
; We enter this point if we couldn't find either an InPort
; mouse, a Bus mouse, or a PS/2 mouse in the system.
;

look_for_serial:
        call    LookForSerialMouse
        mov     locvar1, ax

finished_mouse:
        mov     ax,locvar1

cEnd    fnHardMouseDetect

;*****************************************************************************
;
; setup_for_detect
;
; Procedure will assure that were ready to start the detection and that the
; hardware were running on will allow int 15h/86h (delay) and int 15h/C0h
; (Get system environment).
;
; ENTRY: None.
;
; EXIT:  NC - All is well to begin detection.
;        CY - Nope, int 15h calls needed are not available.
;
; ALTERS: AX ES BX CX DX And sets the fSingle8259 gloval var to true or false
;         depending on weather there are multiple 8259 chips in the system.
;

setup_for_detect   PROC   NEAR

        mov    ah,0c0h               ; int 15h - func get sys environment.
        int    15h
        jc     old_machine
        cmp    word ptr es:[bx],5    ; Did we return 5 bytes ?
        jb     old_machine           ; If not, no go.

        mov    ah,byte ptr es:[bx+5] ; Get the configuration flags.
        test   ah,01000000b          ; Is bit 6 set ? (slave 8259 present ?)
        mov    fSingle8259,TRUE
        jz     All_is_well
        mov    fSingle8259,FALSE
        jmp    short All_is_well

; I know that since the int 15h/0C0h call failed, we have an old machine upon
; which I can assume will not have a slave 8259. If call int 15h/8300h will
; work we can still detect the mouse.

old_machine:
        mov    fSingle8259,TRUE
        clc

All_is_well:
        ret

setup_for_detect   ENDP

;*****************************************************************************
;
;       TestForInport
;
;       This procedure will attempt to find an InPort mouse at the given base
;               I/O address. Note that if an InPort is found, it will be left
;               in a state where it will not be generating any interrupts.
;
;       ENTRY   DX              I/O address of InPort Identification Register
;
;       EXIT    NC              An Inport was found 
;               CY              No Inport was found
;
;       ALTERS  AX, BX, CX, DX, SI
;
;       CALLS   FindInportInterrupt
;

TestForInport   PROC    NEAR

;
; Since the identification register alternates between returning back
;       the Inport chip signature and the version/revision, if we have an
;       InPort chip, the chip signature will be read in one of the following
;       two reads. If it isn't, we do not have an InPort chip.
;

        mov     bl,INPORT_ID
        in      al,dx                   ; Read ID register.
        cmp     al,bl                   ; Is value the InPort chip signature?
        je      possible_inport         ; Yes, go make sure we have an InPort.
        in      al,dx                   ; Read ID register again.
        cmp     al,bl                   ; Is value the InPort chip signature?
        jne     inport_not_found        ; No, return error

;
; At this point, we managed to read the InPort chip signature, so we have
;       a possible InPort chip. The next read from the ID register will
;       return the version/revision. We then make sure that the ID register
;       alternates between the chip signature and this version/revision. If
;       it does, we have an InPort chip.
;

possible_inport:
        in      al,dx                   ; Read version/revision.
        mov     ah,al                   ; Save it.
        mov     cx,5                    ; Test ID register 5 times.

inport_check:
        in      al,dx                   ; Read ID register.
        cmp     al,bl                   ; Make sure it is the chip signature.
        jne     inport_not_found        ; If not, we don't have an InPort chip.
        in      al,dx                   ; Read ID register.
        cmp     al,ah                   ; Make sure version/revision is same.
        jne     inport_not_found        ; If not, we don't have an InPort chip.
        loop    inport_check            ; Test desired number of times.

        clc
        ret
;
; At this point, we know we have an InPort chip. We now try to determine
;       what interrupt level it is jumpered at.
;

inport_not_found:                       ; We don't have an InPort chip.
        stc                             ; Show failure.
        ret                             ; Return to caller.

TestForInport   ENDP

;*****************************************************************************
;
;       TestForBus
;
;       This procedure will attempt to find a bus mouse adaptor in the system
;               and will return the results of this search.
;
;       ENTRY   None.
;
;       EXIT    NC              Bus mouse adaptor was found
;
;               CY              Bus mouse not found.
;
;       ALTERS  AX, BX, CX, DX
;
;       CALLS   FindBusInterrupt
;


TestForBus      PROC    NEAR

;
; We determine if the bus mouse adaptor is present by attempting to
;       program the 8255A, and then seeing if we can write a value out to
;       Port B on the 8255A and get that value back. If we can, we assume
;       that we have a bus mouse adaptor.
;

        mov     dx,BUS_INIT             ; Get address of 8255A control port.
        mov     al,BUS_INIT_VALUE       ; Get proper value.
        out     dx,al                   ; Set up 8255A.
        IOdelay
        mov     ax,0A5A5h               ; Get a signature byte and a copy.
        address BUS_SIG BUS_INIT        ; Get address of Port B.
        out     dx,al                   ; Set Port B with signature.
        IOdelay
        in      al,dx                   ; Read back Port B.
        IOdelay
        cmp     al,ah                   ; Does it match signature byte?
        stc                             ; Set return for no bus mouse adaptor.
        jne     bus_not_found           ; Nope - no bus mouse adaptor
        clc

bus_not_found:
        ret

TestForBus      ENDP

;***************************************************************************
;*
;* ArcnetCardPresent - Detects the presence of an Arcnet Card
;*
;* ENTRY: None.
;*
;* EXIT: Boolean
;*       AX = 1 , Arcnet Card Probably present
;*       AX = 0 , Arcnet Card Probably NOT Present
;*
;***************************************************************************
cPublic ArcnetCardPresent <FAR,PUBLIC>,<SI,DX>
localV  InputBytes, 4d
localV  ACP_First, 1d
cBegin  ArcnetCardPresent

      ; Read a BYTE from four different 16-bit I/O addresses that have
      ; the same lower 10 bits (2E0h).  2E0h is the address of the Status
      ; register for the Arcnet Cards that tend to be reset easily
      ; (a Read or write to I/O addresses 2E8, 2E9, 2EA, OR 2EB).
      ; Store the BYTE in InputBytes
      ;
      mov   dx, 56E0h
      IOdelay
      in    al, dx
      mov   InputBytes, al

      mov   dx, 0AAE0h
      IOdelay
      in    al, dx
      mov   InputBytes+1, al

      mov   dx, 0E2E0h
      IOdelay
      in    al, dx
      mov   InputBytes+2, al

      mov   dx, 1EE0h
      IOdelay
      in    al, dx
      mov   InputBytes+3, al

      xor   si, si                  ; Clear the loop counter

ACP_Loop:
      mov   al, [InputBytes+si]     ; Read a byte from table

      cmp   al, 0FFh                ; If it is FF or E0 (low Byte of I/O
      je    NoArcNet                ;  address we will assume that we read
                                    ;  air.
      cmp   al, 0E0h
      je    NoArcNet

      and   al, 78h                 ; bits 6 through 3 (0XXX X000) should
                                    ;  be constant

      cmp   si, 0h                  ; Is it first byte read ?
      je    ACP_First_Pass

      cmp   ACP_First, al           ; is it equal to the first Byte read
      jne   NoArcNet

      inc   si                      ; point to next byte in table
      cmp   si, 4d                  ; have we done all four bytes
      je    ArcNetFound             ; Yes, we have found an Arcnet Card

      jmp   ACP_Loop

ACP_First_Pass:
      mov   ACP_First, al           
      inc   si                      ; point to next byte in table
      jmp   ACP_Loop
      

ArcNetFound:
      mov   ax, 1                   ; return TRUE
      jmp   short ACP_End

NoArcNet:
      xor   ax, ax                  ; return FALSE

ACP_End:
cEnd    ArcnetCardPresent

;*****************************************************************************
;
; LookForSerialMouse
;
;*****************************************************************************
LookForSerialMouse PROC NEAR

      mov       ax,CRT_Data_Seg         ; Get ROM BIOS Data segment.
      mov       es,ax                   ; Establish addressability to it.
      assume    es:nothing

      xor       di,di                   ; Assume starting at COM1

serial_try_again:
      mov       dx,es:[di]              ; Get base address of COM port to test.
      or        dx,dx                   ; Does this port exist?
      jnz       serial_test_port        ; Yes, go and test it.
      cmp       di,4                    ; If this is COM3 or COM4, use the
      jb        serial_next_port        ;  internal addresses for them.
      je        @F                      ; If we have COM3, DX=0.
      inc       dx                      ; If we have COM4, DX=2.
      inc       dx                      ; ...

@@:
      mov       bx,dx                   ; BX has index into our table.
      cmp       bx,2                    ; Are we about to look at COM4 ?
      jne       NotCom4

      cCall     ArcnetCardPresent
      or        ax,ax                   ; if Arcnet Present do not do
      jnz       No_Serial_Mouse         ;   COM4 test as the Arcnet Card will
                                        ;   be Reset.

NotCom4:
      mov       dx,COM_3_4_Addrs[bx]    ; Get base address of the COM port.

serial_test_port:
;
; First, do a quick test to make sure something out there responds like a
;       COM port.
;
      push      dx                      ; Save base address.
      address   IIR RXB                 ; Address Interrupt ID register.
      DelayIn   al,dx                   ; AL=contents of Interrupt ID reg.
      pop       dx                      ; Restore base address.
      test      al,0F8h                 ; Make sure bits 3-7 are all 0!
      jnz       serial_next_port        ; No COM port -> no mouse.

      call      TestForSerial           ; Is a serial mouse attached to port?
      cmp       ax,NO_MOUSE
      jne       Serial_Mouse_Found      ; Yes!

serial_next_port:                       ; No serial mouse on this COM port.
      add       di,2                    ; Otherwise, move to the next possible
      cmp       di,8                    ; port and try there.
      jb        serial_try_again        ; Look for COM1 through COM4.

No_Serial_Mouse:
      mov       ax,NO_MOUSE

Serial_Mouse_Found:
      ret

LookForSerialMouse ENDP

;*****************************************************************************
;
; TestForSerial
;
;*****************************************************************************
TestForSerial   PROC    NEAR

      call      SaveCOMSetting

      call      SetupCOMForMouse        ; Set up COM port to talk to mouse.

      mov       cx,SHORTDELAY           ; Use a short delay time.
      call      ResetSerialMouse        ; Reset mouse to see if it is there.
      cmp       ax,NO_MOUSE
      jne       TFS_Found

      mov       cx,LONGDELAY            ; Maybe the mouse is just slow.
      call      ResetSerialMouse        ; Reset mouse to see if it is there.
      cmp       ax,NO_MOUSE
      jne       TFS_Found

      call      TestForLogitechSerial   ; Maybe it's a Logitech Series C

TFS_Found:
      push      ax                      ; Save return value
      call      RestoreCOMSetting
      pop       ax
      ret

TestForSerial   ENDP

;*****************************************************************************
;
;       SaveCOMSetting
;
;       This procedure will save the current state of the COM port given.
;
;       ENTRY   DX              Base address of COM port.
;
;       EXIT    none
;
;       ALTERS  AX
;
;       CALLS   none
;


SaveCOMSetting  PROC    NEAR

        push    dx                      ; Save base I/O address.
        address LCR RXB                 ; Get address of Line Control Register.
        DelayIn al,dx                   ; Get current contents.
        mov     [LCRSave],al            ; Save them.
        or      al,LC_DLAB              ; Set up to access divisor latches.
        DelayOut dx,al
        address LATMSB LCR              ; Get address of high word of divisor
        DelayIn al,dx                   ; latch and save its current contents.
        mov     [LATMSBSave],al
        address LATLSB LATMSB           ; Get address of low word of divisor
        DelayIn al,dx                   ; latch and save its current contents.
        mov     [LATLSBSave],al
        address LCR LATLSB              ; Get address of Line Control Register
        mov     al,[LCRSave]            ; and disable access to divisor.
        and     al,NOT LC_DLAB
        DelayOut dx,al
        address MCR LCR                 ; Get address of Modem Control Register
        DelayIn al,dx                   ; and save its current contents.
        mov     [MCRSave],al
        address IER MCR                 ; Get address of Interrupt Enable Reg-
        DelayIn al,dx                   ; ister and save its current contents.
        mov     [IERSave],al
        pop     dx                      ; Restore base I/O address.
        ret

SaveCOMSetting  ENDP

;*****************************************************************************
;
;       RestoreCOMSetting
;
;       This procedure will restore the state of the COM port.
;
;       ENTRY   DX              Base address of COM port.
;
;       EXIT    none
;
;       ALTERS  AX
;
;       CALLS   none
;


RestoreCOMSetting       PROC    NEAR

        push    dx                      ; Save base I/O address.
        address LCR RXB                 ; Get address of Line Control Register.
        mov     al,LC_DLAB              ; Set up to access divisor latches.
        DelayOut dx,al
        address LATMSB LCR              ; Get address of high word of divisor
        mov     al,[LATMSBSave]         ; and restore it.
        DelayOut dx,al
        address LATLSB LATMSB           ; Get address of low word of divisor
        mov     al,[LATLSBSave]         ; and restore it.
        DelayOut dx,al
        address LCR LATLSB              ; Get address of Line Control Register
        mov     al,[LCRSave]            ; and restore it, disabling access to
        and     al,NOT LC_DLAB          ; the divisor latches.
        DelayOut dx,al
        address MCR LCR                 ; Get addres of Modem Control Register
        mov     al,[MCRSave]            ; and restore it.
        DelayOut dx,al
        address IER MCR                 ; Get address of Interrupt Enable Reg-
        mov     al,[IERSave]            ; ister and restore it.
        DelayOut dx,al
        pop     dx                      ; Restore base I/O address.
        ret

RestoreCOMSetting       ENDP

;*****************************************************************************
;
;       SetupCOMForMouse
;
;       This procedure will set up the given COM port so that it can talk to
;               a serial mouse.
;
;       ENTRY   DX              Base address of COM port to set up
;
;       EXIT    COM port set up, all interrupts disabled at COM port
;
;       ALTERS  AX
;
;       CALLS   none
;


SetupCOMForMouse        PROC    NEAR

        push    dx                      ; Save base I/O address.
        address LCR RXB                 ; Get address of Line Control Reg.
        mov     al,LC_DLAB              ; Set up to access divisor latches.
        DelayOut dx,al
        address LATMSB LCR              ; Get address of high word of divisor
        mov     al,HIGH DIV_1200        ; latch and set it with value for
        DelayOut dx,al                  ; 1200 baud.
        address LATLSB LATMSB           ; Get address of low word of divisor
        mov     al,LOW DIV_1200         ; latch and set it with value for
        DelayOut dx,al                  ; 1200 baud.
        address LCR LATLSB              ; Get address of Line Control Reg.
        mov     al,LC_BITS7 + LC_STOP1 + LC_PNONE
        DelayOut dx,al                  ; Set 7,n,1; disable access to divisor.
        address IER LCR                 ; Get address of Int. Enable Register
        xor     al,al                   ; Disable all interrupts at the COM
        DelayOut dx,al                  ; port level.
        address LSR IER                 ; Get address of Line Status Reg.
        DelayIn al,dx                   ; Read it to clear any errors.
        pop     dx                      ; Restore base I/O address
        ret

SetupCOMForMouse        ENDP

;*****************************************************************************
ResetSerialMouse2  PROC    NEAR

        push    dx                      ; Save environment.
        push    si
        push    di
        push    es

        address IER RXB                 ; Get address of Interrupt Enable Reg.
        DelayIn al,dx                   ; Get current contents of IER and
        push    ax                      ; save them.
        push    dx                      ; Save address of IER.
        xor     al,al                   ; Disable all interrupts at the
        DelayOut dx,al                  ; COM port level.

        address MCR IER                 ; Get address of Modem Control Reg.
        mov     al,MC_DTR               ; Set DTR active; RTS, OUT1, and OUT2
        DelayOut dx,al                  ; inactive. This powers down mouse.

        push    cx                      ; Save amount of time to delay.
        call    SetupForWait            ; Set up BX:CX and ES:DI properly for
        assume  es:nothing              ; upcoming delay loop.

        address RXB MCR                 ; Get address of Receive Buffer.

;
; Now, we wait the specified amount of time, throwing away any stray
; data that we receive. This gives the mouse time to properly reset
; itself.
;

rsm2_waitloop:
        DelayIn al,dx                   ; Read and ignore any stray data.
        call    IsWaitOver              ; Determine if we've delayed enough.
        jnc     rsm2_waitloop            ; If not, keep waiting.

rsm2_waitover:
        address LSR RXB                 ; Get address of Line Status Reg.
        DelayIn al,dx                   ; Read it to clear any errors.
        address MCR LSR                 ; Get address of Modem COntrol Reg.
        mov     al,MC_DTR + MC_RTS + MC_OUT2 ; Set DTR, RTS, and OUT2 active
                                        ; OUT1 inactive.
        DelayOut dx,al                  ; This powers up the mouse.

        pop     cx                      ; Get amount of time to delay.
        call    SetupForWait            ; Set up BX:CX and ES:DI properly for
        assume  es:nothing              ; the upcoming delay loop.

;
; We give the mouse the specified amount of time to respond by sending
;       us an M. If it doesn't, or we get more than 3 characters that aren't
;       an M, we return a failure indication.
;

        address LSR MCR                 ; Get address of Line Status Reg.
        mov     si,0                    ; Read up to 3 chars from port.

rsm2_lookforM:
        DelayIn al,dx                   ; Get current status.
        test    al,LS_DR                ; Is there a character in Receive Buff?
        jnz     rsm2_gotchar             ; Yes! Go and read it.
        call    IsWaitOver              ; No, determine if we've timed out.
        jnc     rsm2_lookforM            ; Haven't timed out; keep looking.

        jmp     short rsm2_leave         ; Timed out. Leave with carry set.

rsm2_gotchar:
        address RXB LSR                 ; Get address of Receive Buffer.
        DelayIn al,dx                   ; Get character that was sent to us.
        mov     [SerialBuf+si],al
        address LSR RXB                 ; Oh well. Get address of LSR again.
        inc     si                      ; Have we read 3 chars yet?
        cmp     si,10d
        jne     rsm2_lookforM            ; Nope, we'll give him another try.

rsm2_leave:
        pop     dx                      ; Get address of IER.
        pop     ax                      ; Get old value of IER.
        DelayOut dx,al                  ; Restore IER.

        pop     es                      ; Restore environment.
        assume  es:nothing
        pop     di
        pop     si
        pop     dx
        ret

ResetSerialMouse2       ENDP

;*****************************************************************************
;
; ResetSerialMouse
;
; This procedure will reset a serial mouse on the given COM port and will
; return an indication of whether a mouse responded or not.
;
; The function now also checks for the presence of a 'B' as well as an 
; 'M' to determine the presence of a pointing device.  Also, if the 'M' is 
; followed by a '3' the serial mouse is a Logitech.
;
; Mouse     returns M
; Ballpoint returns B
;
; ENTRY   DX    Base I/O address of COM port to use
;         CX    Number of msecs to use for delays
;
; EXIT    AX    Mouse Type
;
;*****************************************************************************
ResetSerialMouse PROC NEAR

      push      dx                  ; Save environment.
      push      si
      push      di
      push      es

      address   IER RXB             ; Get address of Interrupt Enable Reg.       
      DelayIn   al,dx               ; Get current contents of IER and       
      push      ax                  ; save them.       
      push      dx                  ; Save address of IER.       
      xor       al,al               ; Disable all interrupts at the       
      DelayOut  dx,al               ; COM port level.       

      address   MCR IER             ; Get address of Modem Control Reg.       
      mov       al,MC_DTR           ; Set DTR active; RTS, OUT1, and OUT2       
      DelayOut  dx,al               ; inactive. This powers down mouse.       

      push      cx                  ; Save amount of time to delay.       
      call      SetupForWait        ; Set up BX:CX and ES:DI properly for       
      assume    es:nothing          ; upcoming delay loop.       

      address   RXB MCR             ; Get address of Receive Buffer.       
;
; Now, we wait the specified amount of time, throwing away any stray
; data that we receive. This gives the mouse time to properly reset
; itself.
;
rsm_waitloop:
      DelayIn   al,dx               ; Read and ignore any stray data.
      call      IsWaitOver          ; Determine if we've delayed enough.
      jnc       rsm_waitloop        ; If not, keep waiting.

; Wait is over.

      address   LSR RXB             ; Get address of Line Status Reg.
      DelayIn   al,dx               ; Read it to clear any errors.
      address   MCR LSR             ; Get address of Modem COntrol Reg.
      mov       al,MC_DTR+MC_RTS+MC_OUT2 ; Set DTR, RTS, and OUT2 active
                                         ; OUT1 inactive.
      DelayOut  dx,al               ; This powers up the mouse.

      pop       cx                  ; Get amount of time to delay.
      call      SetupForWait        ; Set up BX:CX and ES:DI properly for
      assume    es:nothing          ; the upcoming delay loop.
;
; We give the mouse the specified amount of time to respond by sending
; us an M. If it doesn't, or we get more than 5 characters that aren't
; an M, we return a failure indication.
;

      address   LSR MCR             ; Get address of Line Status Reg.
      mov       si,5                ; Read up to 5 chars from port.
      mov       bl,'3'              ; '3' will follow 'M' on Logitech.
      mov       bh,'B'              ; 'B' for BALLPOINT
      mov       ah,'M'              ; Get an M. (We avoid doing a cmp al,M
                                    ; because the M could be left floating
                                    ; due to capacitance.)
rsm_getchar:
      DelayIn   al,dx               ; Get current status.
      test      al,LS_DR            ; Is there a character in Receive Buff?
      jnz       rsm_gotchar         ; Yes! Go and read it.
      call      IsWaitOver          ; No, determine if we've timed out.
      jnc       rsm_getchar         ; Haven't timed out; keep looking.

      mov       bx,NO_MOUSE
      jmp short rsm_leave           ; Timed out. Leave with NO_MOUSE.

rsm_gotchar:
      address   RXB LSR             ; Get address of Receive Buffer.
      DelayIn   al,dx               ; Get character that was sent to us.
      cmp       al,ah               ; Is it an M?
      jne       check_for_b
;
; We received an 'M', now wait for next character to see if it is a '3'.
;
      mov       cx,1                ; Wait between 55.5 and 111ms for
      call      SetupForWait        ;   next character.
      address   LSR RXB             

rsm_waitfor3:
      DelayIn   al,dx               ; Get current status.
      test      al,LS_DR            ; Is there a character in Receive Buff?
      jnz       rsm_gotchar3        ; Yes! Go and read it.
      call      IsWaitOver          ; No, determine if we've timed out.
      jnc       rsm_waitfor3        ; Haven't timed out; keep looking.

; Not a Logitech - must be a standard Microsoft compatible serial mouse.

      jmp short rsm_notLT

rsm_gotchar3:
      address   RXB LSR             ; Get address of Receive Buffer.
      DelayIn   al,dx               ; Get character that was sent to us.
      cmp       al,bl               ; Is it a 3?
      jne       rsm_notLT

      mov       bx,LT_MOUSE         ; Yes, we've found a Logitech M+ series,
      address   LSR RXB             ; Choose Line Status Register.
      jmp short rsm_leave           ;   3 button mouse

rsm_notLT:
      mov       bx,SERIAL_MOUSE     ; We didn't get the '3' after the 'M'
      address   LSR RXB             ; Choose Line Status Register.
      jmp short rsm_leave           ; We still have a standard serial mouse.

check_for_b:
      cmp       al,bh               ; Is it a B?
      jne       rsm_next_char

      mov       bx,MSBPOINT_MOUSE   ; We've found a BallPoint Mouse
      address   LSR RXB             ; Choose Line Status Register.
      jmp short rsm_leave

rsm_next_char:
      address   LSR RXB             ; Oh well. Get address of LSR again.
      dec       si                  ; Have we read 5 chars yet?
      jnz       rsm_getchar         ; Nope, we'll give him another try.

; We've read many characters - No a single 'M' or 'B' in the lot.

      mov       bx,NO_MOUSE

rsm_leave:
      pushf                         ; Save flags


; Clear out any extra incoming characters

      mov       cx,2                ; Get amount of time to delay.
      call      SetupForWait        ; Set up BX:CX and ES:DI properly for
      assume    es:nothing          ; the upcoming delay loop.

rsm_ClearAll:
      DelayIn   al,dx               ; Read the LSR to clear any errors.
      address   RXB LSR             ; Get address of Receive Buffer.
      DelayIn   al,dx               ; Read and ignore any stray data.
      address   LSR RXB             ; Get address of Line Status Register.

rsm_ClearPort:
      call      IsWaitOver          ; Determine if we've timed out.
      jnc       rsm_ClearAll        ; Haven't timed out; keep looking.


      popf                          ; Restore flags

      pop       dx                  ; Get address of IER.
      pop       ax                  ; Get old value of IER.
      DelayOut  dx,al               ; Restore IER.

      pop       es                  ; Restore environment.
      assume    es:nothing
      pop       di
      pop       si
      pop       dx
      mov       ax,bx               ; Set return value.
      ret

ResetSerialMouse        ENDP

;*****************************************************************************
;
;       SetupForWait
;
;       This procedure accepts the number of milliseconds that we will want
;       to delay for and will set things up for the wait.
;
;       ENTRY   CX              Number of Clock ticks to wait for.
;
;       EXIT    None.
;
;       ALTERS  CX
;
;       CALLS   none
;


SetupForWait    PROC    NEAR

        push    ax                        ; Do your saving !
        push    es

        xor     ax,ax
        mov     es,ax                     ; Point to 40:6C = 0:46C
        mov     ax,es:[LW_ClockTickCount] ; Get tick count in AX.
        add     ax,cx                     ; [Current + delay] = delay ends.
        mov     ds:[SemaphoreWord],ax     ; Save ending time in Semiphore

        pop     es                        ; Restore now !
        pop     ax
        
        ret

SetupForWait    ENDP

;*****************************************************************************
;
;       IsWaitOver
;
;       This procedure accepts the current time and the ending time and
;       return and indication of whether the current time is past
;       the ending time.
;
;       ENTRY  None
;
;       EXIT    carry clear     Current time is not past ending time
;               carry set       Current time is past ending time
;
;       ALTERS  none
;
;       CALLS   none
;

IsWaitOver      PROC    NEAR

        push    ax                         ; Preserve AX
        push    es                         ; Preserve ES
        push    bx
        sti                                ; Hosebag BIOS bugs can't get me.
        xor     ax,ax
        mov     es,ax                      ; Point to 40:6C = 0:46C
        mov     ax,es:[LW_ClockTickCount]  ; Get tick count in AX.
        sti
        mov     bx,ds:[SemaphoreWord]
        cmp     bx,ax                      ; This will set carry accordingly.

        pop     bx
        pop     es                         ; Restore ES
        pop     ax                         ; Restore AX
        ret

IsWaitOver      ENDP

;*****************************************************************************
;
; LookForPS2Mouse
;
;*****************************************************************************
LookForPS2Mouse  PROC  NEAR
;
; Lets make the Int 15h, C201h BIOS call to reset the pointing device.
; If the call is supported, and returns success then we know that we have
; a PS/2 mouse.
;
      stc
      mov       bx,0ffffh           ; Initialize, see later if it changes.
      mov       ax,0c201h
      int       15h                 ; Reset Pointing device.
      jc        No_PS2_Mouse        ; Function call unsuccesful.

      cmp       bh,0ffh             ; BH should be device ID, it should not
      je        No_PS2_Mouse        ;   be what we initialized it to (FF).
;
; The following sequence of Int 15h calls will determine if a Logitech
; PS/2 mouse is present.  This information was obtained from Logitech.
;
      mov       ax,0C203h           ; Set resolution to 1 cnt/mm
      mov       bh,0h
      int       15h
      jc        PS2_Mouse             

      mov       ax,0C206h           ; Set scaling to 1:1
      mov       bh,1h
      int       15h
      jc        PS2_Mouse             

      mov       ax,0C206h           ; Set scaling to 1:1
      mov       bh,1h
      int       15h
      jc        PS2_Mouse             

      mov       ax,0C206h           ; Set scaling to 1:1
      mov       bh,1h
      int       15h
      jc        PS2_Mouse             

      mov       ax,0C206h           ; Get status
      mov       bh,0h
      int       15h
      jc        PS2_Mouse             

      or        cl,cl               ; Is resolution 1 cnt/mm?
      jz        PS2_Mouse           ; Yes, then not a Logitech.
;
; If cl is not zero (i.e. 1 cnt/mm) then it is the number of buttons
; and we've found a Logitech 3-button PS/2 mouse
;
LT_PS2_Mouse:
      mov       ax,LT_PS2MOUSE
      jmp short PS2MouseFound

PS2_Mouse:
      mov       ax,MSPS2_MOUSE
      jmp short PS2MouseFound

No_PS2_Mouse:
      mov       ax,NO_MOUSE

PS2MouseFound:
      ret

LookForPS2Mouse  ENDP


;*****************************************************************************
;
;       TestForPS2
;
;       This procedure will attempt to find a PS/2 mouse in the system and
;               return the results of this search.
;
;       ENTRY   fSingle8259     Non-zero if we have a single 8259A
;
;       EXIT    Carry clear     A PS/2 style Microsoft mouse was found
;               Mouse interrupts disabled at 8042.
;               Mouse disabled at 8042.
;               Mouse is reset.
;
;               Carry set       A PS/2 style Microsoft mouse was not found
;
;       ALTERS  AX, CX
;
;       CALLS   CheckForAuxSupport, MouseIntOff, CheckForMSMouse
;


TestForPS2      PROC    NEAR

        call    CheckForLogitechPS2     ; Check for Logitech PS/2 Mouse.
;       jmp     tfp_leave
        jc      tfp_CheckForMS          ; Check for MS/IBM mouse if not.
        mov     ax,LT_PS2MOUSE          ; Set the mouse type in AL
        jmp     short tfp_leave

tfp_CheckForMS:
        test    [fSingle8259],0FFh      ; Does machine have only 1 8259A?
        jnz     tfp_no_mouse            ; Yes - impossible to have PS/2 mouse.
        call    CheckForAuxSupport      ; Does machine support an aux device?
        jc      tfp_leave               ; Nope - impossible to have PS/2 mouse.
        call    MouseIntOff             ; Disable mouse and mouse interrupts.
        call    CheckForMSMouse         ; Is Microsoft mouse attached?
                                        ; If so, will be reset.
        jmp     short tfp_leave

tfp_no_mouse:
        stc                             ; Show that we failed.

tfp_leave:
        ret                             ; Carry set/clear appropriately.

TestForPS2      ENDP

;*****************************************************************************
;
;       CheckForAuxSupport
;
;       This procedure will determine if the 8042 supports an auxiliary device.
;
;       Note that this procedure will always leave with the keyboard enabled.
;
;       ENTRY   Keyboard enabled.
;
;       EXIT    Carry clear     The 8042 supports an auxiliary device
;               Interrupts enabled.
;               Aux device disabled.
;
;               Carry set       The 8042 does not support an auxiliary device
;               Interrupts enabled.
;
;       ALTERS  AX, BX, CX, DX, DI, ES
;
;       CALLS   Read8042CommandByte, WriteControlRegister
;


CheckForAuxSupport      PROC    NEAR

        mov     al,CMD8042_DISABLE_AUX  ; Disable the auxiliary device.
        call    WriteControlRegister
        jc      cfas_leave              ; Leave if error.
                                        ; INTERRUPTS DISABLED!!
        mov     al,CMD8042_DISABLE_KBD  ; Disable the keyboard.
        call    WriteControlRegister
        jc      cfas_leave              ; Leave if error.
                                        ; INTERRUPTS DISABLED!!

; We have to disable the keyboard interrupt here. This is because when the
;       8042 returns the status from the Test Auxiliary Device command,
;       it asserts IRQ 1. We can't just disable interrupts entirely, otherwise
;       we cannot time ourselves off of the system clock, so we have to do it
;       this way.

        in      al,MASTER_MASK_ADDR     ; Read interrrupt mask.
        IOdelay
        push    ax                      ; Save mask read in.
        or      al,00000010b            ; Mask keyboard interrupt.
        out     MASTER_MASK_ADDR,al     ; Write out changed mask.
        IOdelay

        call    Read8042CommandByte     ; Read the 8042 command byte.
                                        ; INTERRUPTS ENABLED!!
        jc      cfas_no_support         ; Leave if error.
        test    al,AUX_DISABLED         ; If the auxiliary device isn't
        jz      cfas_no_support         ; disabled, we don't have aux support.

;
; It is still possible that the 8042 supports an auxiliary device. We
;       now issue the 8042 command to test the auxiliary interface. This
;       command only exists on 8042s that support an auxiliary device. If the
;       test succeeds, a 00h will be placed in the 8042's output buffer. If no
;       output appears in the 8042's output buffer, it is assumed that the
;       8042 does not support an auxiliary device.
;
; WARNING!!! The testing of the auxiliary interface will more than likely
;       screw up an auxiliary device attached to it. Therefore, the auxiliary
;       device should be initialized after calling this procedure.
;

        mov     al,CMD8042_TEST_AUX     ; Command to test the auxiliary
        call    WriteControlRegister    ; interface.
        jc      cfas_no_support         ; Leave if error.
                                        ; INTERRUPTS DISABLED!!

        mov     cx,0ah                  ; We will wait half a second.
        call    SetupForWait            ; BX:CX has ending time, ES:DI points
                                        ;  at current time.
        sti                             ; Make sure interrupts are enabled so
                                        ;  timer ticks can get in.
        xor     dx,dx                   ; Clear byte read flag.

cfas_read_test_results:
        in      al,STATUS_8042          ; Get 8042's current status.
        test    al,I_FULL               ; Wait for 8042 to remove the command
        jnz     cfas_is_wait_over       ; from its input buffer.
        test    al,O_FULL               ; Is there an output byte yet?
        jz      cfas_is_wait_over       ; Nope, check if wait is over.

        in      al,DATA_8042            ; Read byte from 8042.
        or      dx,dx                   ; Have we read a byte yet?
        jnz     cfas_is_wait_over       ; Yes, ignore this byte.
        mov     ah,al                   ; Save first byte read in.
        inc     dx                      ; Show that a byte was read.

cfas_is_wait_over:
        call    IsWaitOver              ; Has interval expired?
        jnc     cfas_read_test_results  ; Nope, keep looking.

        or      dx,dx                   ; Did we get a byte?
        jz      cfas_no_support         ; Nope, no auxiliary device.
        or      ah,ah                   ; Was the byte we got 0?
        jz      cfas_clean_up           ; Yes, return with carry clear.

cfas_no_support:
        stc                             ; Show no aux device is supported.

cfas_clean_up:                          ; Carry clear/set appropriately.
        pop     ax                      ; Restore saved interrupt mask.
        sti                             ; Interrupts are reenabled.
        pushf                           ; Save result in carry.
        cli                             ; Interrupts off for mask update.
        mov     ah,al                   ; Put it in AH.
        in      al,MASTER_MASK_ADDR     ; Read in current mask.
        IOdelay
        and     ax,0000001011111101b    ; Unmask keyboard interrupt.
        or      al,ah                   ; Move in original state of keyboard.
        out     MASTER_MASK_ADDR,al     ; Write out changed mask.

cfas_reenable_kbd:
        mov     al,CMD8042_ENABLE_KBD   ; Reenable the keyboard.
        call    WriteControlRegister
        jc      cfas_reenable_kbd       ; Make sure we reenable the keyboard!!
                                        ; INTERRUPTS DISABLED!!
        popf                            ; Restore result and interrupts.
                                        ; INTERRUPTS ENABLED!!

cfas_leave:
        ret

CheckForAuxSupport      ENDP

;*****************************************************************************
;
;       Read8042CommandByte
;
;       This procedure will try to read the 8042's command byte.
;
;       Note that this procedure should only be called if both the keyboard
;               and auxiliary devices are disabled.
;
;       ENTRY   none
;
;       EXIT    Carry clear     Command byte was read successfully
;               AL              Command byte
;               Interrupts enabled
;
;               Carry set       Command byte couldn't be read
;               Interrupts enabled
;
;       ALTERS  AL
;
;       CALLS   WriteControlRegister
;


Read8042CommandByte     PROC    NEAR

        mov     al,CMD8042_READ_CMD     ; Tell 8042 that we want to read the
        call    WriteControlRegister    ; command byte.
        jc      r8cb_leave              ; Leave if error.

                                        ; INTERRUPTS DISABLED!
        push    cx                      ; Save register.
        mov     cx,400h                 ; Short delay because ints are off.

r8cb_loop:
        in      al,STATUS_8042          ; Get current status of 8042.
        test    al,O_FULL               ; Is there data in the output buffer?
        jnz     r8cb_got_data           ; Yes! Go and read it.
        loop    r8cb_loop               ; Keep trying.

        stc                             ; Show failure.
        jmp     short r8cb_leave2

r8cb_got_data:                          ; Carry is clear!
        in      al,DATA_8042            ; Get 8042's command byte.

r8cb_leave2:
        pop     cx                      ; Restore register.
        IOdelay                         ; Make sure interrupt is cleared.
        sti                             ; Reenable interrupts.
                                        ; INTERRUPTS ENABLED!

r8cb_leave:                             ; Carry set/clear appropriately.
        ret

Read8042CommandByte     ENDP

;*****************************************************************************
;
;       Write8042CommandByte
;
;       This procedure sets the 8042's command byte to the value given.
;
;       ENTRY   AL              Value to set the command byte to
;
;       EXIT    Carry clear     Command byte was set
;               Interrupts enabled
;
;               Carry set       Command byte couldn't be set
;               Interrupts enabled
;
;       ALTERS  none
;
;       CALLS   WriteControlRegister, WriteInputBuffer
;


Write8042CommandByte    PROC    NEAR

        push    ax                      ; Save value passed in.
        mov     al,CMD8042_WRITE_CMD    ; Tell 8042 that we want to write the
        call    WriteControlRegister    ; command byte.
        jc      w8cb_leave              ; Leave if we have an error.

                                        ; INTERRUPTS DISABLED!
        pop     ax                      ; Restore value.
        call    WriteInputBuffer        ; Send it to 8042.
                                        ; INTERRUPTS ENABLED!
        jc      Write8042CommandByte    ; Retry if unsuccessful.

w8cb_leave:                             ; Carry set/clear appropriately.
        ret

Write8042CommandByte    ENDP

;*****************************************************************************
;
;       WriteInputBuffer
;
;       This procedure sends a byte of data to the 8042's input buffer. It
;               should not be called unless the 8042 has already been set up to
;               expect this byte of data.
;
;       Note that interrupts should be disabled from the time that the command
;               is sent to the 8042 until the time that the data byte is
;               actually written.
;
;       ENTRY   AL              Byte of data to be sent.
;               Interrupts disabled
;
;       EXIT    Carry clear     Byte of data has been sent to the 8042.
;               Interrupts enabled
;
;               Carry set       Byte of data could not be sent to the 8042.
;               Interrupts enabled
;
;       ALTERS  none
;
;       CALLS   none
;

WriteInputBuffer        PROC    NEAR

;
; Upon entry, it is assumed that a command has just been sent to the
;       8042. Therefore, we will wait until the 8042 has removed the command
;       byte from its input buffer before doing anything else.
;
; Note that because interrupts are disabled at this time, we will only
;       wait a short while before timing out.
;

        push    cx                      ; Save registers that we use
        push    ax

        mov     cx,400h                 ; Short delay

wib_wait:
        in      al,STATUS_8042          ; Get 8042's current status.
        test    al,I_FULL               ; Is the input buffer still full?
        jz      wib_check_output        ; Nope - can now test for output.
        loop    wib_wait                ; Keep waiting.

        jmp     short wib_failure       ; Timed out - return with failure.

wib_check_output:
        and     al,O_FULL + A_FULL      ; Keep output and aux buffer bits.
        cmp     al,O_FULL               ; Output buffer contain keybd data?
        jne     wib_check_aux_data      ; Nope - check for aux data.

wib_failure:
        pop     ax                      ; Restore saved data byte.
        stc                             ; Show failure.
        jmp     short wib_leave         ; Return to caller

wib_check_aux_data:
        cmp     al,O_FULL + A_FULL      ; Output buffer contain aux data?
        jne     wib_success             ; Nope, can just send data byte.
        in      al,DATA_8042            ; Yup - read and discard data.

wib_success:                            ; Input and output buffers are empty.
        pop     ax                      ; Get saved data byte.
        out     DATA_8042,al            ; Send data byte.
        clc                             ; Show success.

wib_leave:
        pop     cx                      ; Restore register.
        sti                             ; Reenable interrupts.
        ret

WriteInputBuffer        ENDP

;*****************************************************************************
;
;       WriteControlRegister
;
;       This procedure will send a command byte to the 8042's control register.
;       Note that nothing will be sent as long as the 8042's input or
;       output buffer is full.
;
;       Note that only 15*64K attempts will be made before timing out.
;
;       ENTRY   AL              Command byte to be sent
;
;       EXIT    Carry clear     Byte was written to 8042 successfully
;               Interrupts disabled
;
;               Carry set       Byte could not be written to 8042
;               Interrupts enabled
;
;       ALTERS  none
;
;       CALLS   none
;


WriteControlRegister    PROC    NEAR

        push    cx                      ; Save registers we use.
        push    ax

        mov     ah,15                   ; Set up for looping 15*64K times.
        xor     cx,cx

;
; At this point, we wait until the input and output buffers are empty.
;       Interrupts have to be disabled from the time we find the buffers
;       empty and write the command byte until the time that the data that
;       the command produces is read. Therefore, we will disable and enable
;       interrupts each time through the loop to ensure that interrupts will
;       not be disabled for too long a time.
;

wcr_loop:
        cli                             ; Disable ints before reading status.
        in      al,STATUS_8042          ; Get 8042's current status.
        test    al,I_FULL + O_FULL      ; Are input and output buffers empty?
        jz      wcr_success             ; Yes! Go write the command byte.
        sti                             ; Nope. Reenable ints and keep trying
        loop    wcr_loop                ; the desired number of times.
        dec     ah
        jnz     wcr_loop

;
; Interrupts are enabled.
;

        pop     ax                      ; Restore registers.
        pop     cx

        stc                             ; Show that we failed.
        ret

;
; Interrupts are disabled and carry is clear (from TEST instruction).
;

wcr_success:
        pop     ax                      ; Get saved command byte.
        out     CONTROL_8042,al         ; Write command byte out.
        pop     cx                      ; Restore register.
        ret                             ; Carry is already clear.

WriteControlRegister    ENDP

;*****************************************************************************
;
;       MouseIntOff
;
;       This procedure will disable the mouse and mouse interrupts at the 8042
;               level.
;
;       Note that it assumes that the keyboard is enabled upon entry to this
;               procedure.
;
;       ENTRY   none
;
;       EXIT    Carry clear     Mouse and mouse interrupts are disabled.
;
;               Carry set       Some error occurred.
;
;       ALTERS  AL
;
;       CALLS   WriteControlRegister, Read8042CommandByte, Write8042CommandByte
;


MouseIntOff     PROC    NEAR

        mov     al,CMD8042_DISABLE_AUX  ; Disable the aux device.
        call    WriteControlRegister
        jc      mioff_leave             ; Leave if error.
        mov     al,CMD8042_DISABLE_KBD  ; Disable the keyboard.
        call    WriteControlRegister
        jc      mioff_leave             ; Leave if error.
                                        ; INTERRUPTS DISABLED!!

        call    Read8042CommandByte     ; Get the current command byte.
                                        ; INTERRUPTS ENABLED!!
        jc      mioff_cleanup           ; Leave if error.
        and     al,not AUX_INT_ENABLE   ; Disable mouse interrupts.
        call    Write8042CommandByte    ; Write out altered command byte.

mioff_cleanup:
        pushf                           ; Save return status.

mioff_reenable_kbd:
        mov     al,CMD8042_ENABLE_KBD   ; Reenable the keyboard.
        call    WriteControlRegister    ; If an error occurs, keep trying to
        jc      mioff_reenable_kbd      ; reenable it.
                                        ; INTERRUPTS DISABLED!!
        popf                            ; Restore return status.
                                        ; INTERRUPTS ENABLED!!

mioff_leave:                            ; Carry set/clear appropriately.
        ret

MouseIntOff     ENDP

;*****************************************************************************
;
;      CheckForMSMouse
;
;      This procedure checks to see if a Microsoft mouse or IBM mouse 
;      is attached to the auxiliary interface of the 8042.
;
;      ENTRY      Mouse interrupts disabled.
;
;      EXIT      Carry clear      A PS/2 style mouse was found
;            AX            MS, IBM , Logitech
;            Mouse interface disabled.
;            Mouse is reset.
;
;            Carry set      PS/2 mouse was not found
;
;      ALTERS      AX, CX
;
;      CALLS      SendToMouse, SendToMouseAndTestData, GetMouseData
;            WriteControlRegister, ResetPS2Mouse
;


CheckForMSMouse      PROC      NEAR

      mov      al,CMD8042_ENABLE_AUX      ; Make sure aux interface is enabled
      call      WriteControlRegister      ; so we can talk to the mouse.
      jc      cfmm_leave            ; Leave if we can't enable it.

      mov      cx,5                  ; Only 5 tries at this!

cfmm_retry:
      call      ResetPS2Mouse            ; Try to reset the mouse.
      jc      cfmm_failure            ; Try again if we failed.
      
;      call    CheckForLogitechPS2     ; Check for Logitech PS/2 Mouse.
;      jc      noLogiTech                   ; Logitech mouse not found
;      mov     ax,LT_PS2MOUSE
;      jmp     short cfmm_cleanup      ; mouse type determined

;
; The following sequence of commands checks to see if the mouse that we
;      just succeeded in resetting is a Microsoft mouse. 
;
; Note that we have to check to determine if the mouse responds with either
;      MCMD_ACK or with what was sent because of the differences between
;      the 200ppi and 400ppi PS/2 style mouse. The 200ppi mouse responds
;      with MCMD_ACKs, while the 400ppi mouse responds with whatever was
;      sent to it.
;
noLogiTech:
      mov      al,MCMD_ECHO            ; Send Select Echo Command.
      call      SendToMouse
      jc      cfmm_failure            ; Try again if we failed.

      mov      ax,'GG'                  ; Next "command" in signature.
      call      SendToMouseAndTestData
      jc      cfmm_failure            ; Try again if we failed.

      mov      ax,'DD'                  ; Next "command" in signature.
      call      SendToMouseAndTestData
      jc      cfmm_failure            ; Try again if we failed.

      mov      ax,'GG'                  ; Next "command" in signature.
      call      SendToMouseAndTestData
      jc      cfmm_failure            ; Try again if we failed.

      mov      al,MCMD_KILL_ECHO      ; Leave Echo mode.
      call      SendToMouse
      jnc      cfmm_signature_sent      ; If successful, have sent signature.

cfmm_failure:
      loop      cfmm_retry            ; Try again.
;
; at this point there is no mouse on AUX port at all
;

       stc                              ; carry set for no mouse at all.
       jmp      short cfmm_cleanup

;
; At this point, we have sent the signature string to the mouse.
;      If we have a Microsoft mouse out there, it will respond to a
;      Microsoft extended command.  If there is no response we have an
;      IBM mouse.
;
; Note that we have to test to see if the mouse responds with either a
;      MCMD_ACK or a MCMD_RESEND. This is because a 200ppi mouse responds
;      with MCMD_ACK, while a 400ppi mouse responds with MCMD_RESEND.
;

cfmm_signature_sent:
      mov      ax,(MCMD_RESEND SHL 8) + MCMD_MS_VERS ; Set command and return.
      call      SendToMouseAndTestData
      jc      cfmm_cleanup            ; Leave if unable to send command.

; IBM Mouse fails on this call because it will not send data in
; response to the above Microsoft version command

        call      GetMouseData            ; Read current version number.
      jc      noVerNumber            ; must have IBM mouse
        mov     ax,MSPS2_MOUSE          ; return MS PS2 Mouse.
      jmp      short cfmm_cleanup      ; mouse type determined

noVerNumber:
      mov      ax,IBMPS2_MOUSE              ; ax = IBM PS/2 mouse found.
      clc                        ; clear carry to show mouse presence
;
; Disable the auxiliary interface before leaving.
;

cfmm_cleanup:
      ; carry set here means no PS/2 mouse
      pushf                        ; Save state of carry.
      push      ax                  ; Save version number.

cfmm_disable_aux:
      mov      al,CMD8042_DISABLE_AUX      ; Disable the auxiliary interface.
      call      WriteControlRegister
      jc      cfmm_disable_aux      ; Make sure aux interface is disabled.

      pop      ax                  ; Restore version number.
      popf                        ; Restore carry.

;
; We have found a Microsoft mouse.  The version number is in AL.
;

cfmm_leave:                         

        ; carry clear means mouse present, al indicates its type
      ; carry set upon return means no mouse found

      ret

CheckForMSMouse      ENDP

;*****************************************************************************
;
;       SendToMouse
;
;       This procedure sends a byte of command or data to the mouse.
;               Because it appears that the mouse always acknowledges the
;               sending of this byte, this is also tested for here.
;
;       ENTRY   AL              Byte of command/data to send
;
;       EXIT    Carry clear     Command/data byte sent, mouse sent MCMD_ACK
;               Interrupts enabled.
;
;               Carry set       Command/data byte not sent, or mouse never
;                                sent back MCMD_ACK
;               Interrupts enabled.
;
;       ALTERS  AX
;
;       CALLS   SendToMouseAndTestData
;


SendToMouse     PROC    NEAR

        mov     ah,MCMD_ACK           ; We will only check for MCMD_ACK being
                                      ; returned from mouse.

IF2
.ERRNZ  ($ - SendToMouseAndTestData)  ; Because we fall into it.
ENDIF

SendToMouse     ENDP

;*****************************************************************************
;
;       SendToMouseAndTestData
;
;       This procedure sends a byte of command or data to the mouse.
;               It will then test to ensure that the mouse either sent
;               back what the caller is expecting or MCMD_ACK.
;
;       ENTRY   AL              Byte of command/data to send
;               AH              Byte of data the mouse is to return
;
;       EXIT    Carry clear     Command/data byte sent, mouse responded
;                                correctly
;               Interrupts enabled.
;
;               Carry set       Command/data byte not sent, or mouse never
;                                responded correctly
;               Interrupts enabled.
;
;       ALTERS  AX
;
;       CALLS   WriteControlRegister, WriteInputBuffer, CheckMouseData
;


SendToMouseAndTestData  PROC    NEAR

        push    ax                      ; Save command/data byte.
        mov     al,CMD8042_WRITE_AUX    ; Tell 8042 we want to send a byte to
        call    WriteControlRegister    ; the auxiliary device.
        pop     ax                      ; Get saved command/data byte.
        jc      stmatd_leave            ; Leave if error.

                                        ; INTERRUPTS DISABLED!
        call    WriteInputBuffer        ; Send data/command to aux dev.
                                        ; INTERRUPTS ENABLED!
        jc      SendToMouseAndTestData  ; Retry if unsuccessful.

        mov     al,MCMD_ACK             ; Make sure mouse acknowledges that
                                        ; command/data byte was sent.

if2     ; Pass 2 of the assembler
.errnz  ($ - CheckMouseData)            ; Because we drop into it
endif   ; Pass 2 of the assembler

SendToMouseAndTestData  ENDP

;*****************************************************************************
;
;       CheckMouseData
;
;       This procedure checks that the next byte that the mouse sends us is
;               what we were expecting it to send.
;
;       Note that this procedure cannot be called with interrupts disabled.
;               If it is, interrupts will potentially be left off for a
;               long time.
;
;       ENTRY   AL              One possible data byte the mouse can send
;               AH              A second valid data byte the mouse can send
;               Interrupts enabled
;
;       EXIT    Carry clear     Mouse sent data we were expecting
;
;               Carry set       Mouse didn't send data, or sent something we
;                               weren't expecting.
;
;       ALTERS  none
;
;       CALLS   GetMouseData
;

CheckMouseData  PROC    NEAR

        push    bp                      ; Save BP.
        push    ax                      ; Save data bytes to test for.
        mov     bp,sp                   ; Address data bytes on stack.
        call    GetMouseData            ; Get next byte of data from mouse.
        jc      cmd_leave               ; Leave if error.
        cmp     al,ah                   ; Is it what we were expecting?
        je      cmd_leave               ; Yes! Leave with carry clear.
        cmp     al,byte ptr [bp]        ; Is it other byte we were expecting?
        je      cmd_leave               ; Yes! Leave with carry clear.
        stc                             ; Nope, show error and leave.

cmd_leave:                              ; Carry set/clear appropriately.
        pop     ax                      ; Restore data bytes.
        pop     bp                      ; Restore BP.

stmatd_leave:                           ; Carry set/clear appropriately.
        ret

CheckMouseData  ENDP

;*****************************************************************************
;
;       GetMouseData
;
;       This procedure will try to read a byte of data from the mouse. It will
;               only try 15 * 64K times before timing out.
;
;       Note that this procedure cannot be called with interrupts disabled.
;               If it is, interrupts will potentially be left off for a
;               long time.
;
;       ENTRY   Interrupts enabled
;
;       EXIT    Carry clear     The byte of data was read successfully
;               AL              The byte of data that was read
;
;               Carry set       The byte of data could not be read
;
;       ALTERS  none
;
;       CALLS   none
;


GetMouseData    PROC    NEAR

        push    cx                      ; Save registers that we use.
        push    ax

        mov     ah,15                   ; Set up to loop 15*64K times.
        xor     cx,cx

gmd_loop:
        in      al,STATUS_8042          ; Get current 8042 status.
        test    al,O_FULL               ; Is the output buffer full?
        jz      gmd_buffer_empty        ; Nope, keep trying.
        test    al,A_FULL               ; Yes! Now is data from the mouse?
        jnz     gmd_got_aux_data        ; Yes!! Go and read it.

gmd_buffer_empty:                       ; No data from the mouse yet.
        loop    gmd_loop                ; Keep trying the desired number of
        dec     ah                      ; times.
        jnz     gmd_loop

;
; We timed out waiting for the mouse to send data.
;

        pop     ax                      ; Restore registers.
        pop     cx
        stc                             ; Show failure.
        ret

;
; There is mouse data to be read!
;

gmd_got_aux_data:                       ; Carry is clear already.
        pop     ax                      ; Restore AX so can return value in AL.
        in      al,DATA_8042            ; Read byte of data from mouse.
        pop     cx                      ; Restore other register.
        ret

GetMouseData    ENDP

;*****************************************************************************
;
;       ResetPS2Mouse
;
;       This procedure attempts to reset a PS/2 mouse. It does this by sending
;               a reset command to the mouse and checking to ensure that
;               it passed its diagnostics.
;
;       ENTRY   Mouse interrupts disabled.
;
;       EXIT    Carry clear     Mouse has been reset correctly.
;               AL              ID Code
;
;               Carry set       No mouse or couldn't reset it.
;
;       ALTERS  AX
;
;       CALLS   SendToMouse, CheckMouseData, GetMouseData
;


ResetPS2Mouse   PROC    NEAR

        push    cx                      ; Save register.
        mov     cx,3                    ; Will only try 3 times.

rpm_retry:
        mov     al,MCMD_RESET           ; Send the reset command to the mouse.
        call    SendToMouse
        jc      rpm_failure             ; Try again if we failed.

        mov     ax,(MCMD_DIAG_OK SHL 8) + MCMD_DIAG_OK ; Set valid data byte.
        call    CheckMouseData          ; Make sure mouse responds with it.
        jc      rpm_failure             ; Try again if we failed.

        call    GetMouseData            ; Make sure mouse also sends ID code.
        jnc     rpm_leave               ; If it has, leave with success.

rpm_failure:
        loop    rpm_retry               ; Keep trying.

rpm_leave:                              ; Carry set/clear appropriately.
        pop     cx                      ; Restore register.
        ret

ResetPS2Mouse   ENDP

;*****************************************************************************
;
;      CheckForLogiTechPS2
;
;       look for LogiTech PS/2 mouse
;
;      ENTRY      none
;
;      EXIT      Carry clear      Logitech PS/2 mouse found
;
;      ALTERS      AX
;
;      CALLS      SendToMouse, SendToMouseAndTestData
;

CheckForLogitechPS2 PROC NEAR

      ; the next sequence of commands is the way to see if the
      ; particular mouse is present
      
      mov      ax,0C203h
      mov      bh,0h
      int      15h
      jc       logiTech_failure             

      mov      ax,0C206h
      mov      bh,1h
      int      15h
      jc       logiTech_failure             

      mov      ax,0C206h
      mov      bh,1h
      int      15h
      jc       logiTech_failure             

      mov      ax,0C206h
      mov      bh,1h
      int      15h
      jc       logiTech_failure             

      mov      ax,0C206h
      mov      bh,0h
      int      15h
      jc       logiTech_failure             

      or       cl,cl
      stc
      jz       logitech_failure

      clc

logiTech_failure:
      ret

CheckForLogitechPS2 ENDP

;*****************************************************************************
;
;  TestForLogitechSerial 
;
;     This procedure will detect the presence of a Logitech Series C
;     serial mouse is present
;
;*****************************************************************************
TestForLogitechSerial PROC NEAR

      call      setupForLogitechSerial ; set COM port to talk to this mouse

      address   IER RXB             ; Get address of Interrupt Enable Reg.
      DelayIn   al,dx               ; Get current contents of IER and
      xor       al,al               ; Disable all interrupts at the
      DelayOut  dx,al               ; COM port level.
      address   MCR IER             ; Get address of Modem Control Reg.
      mov       al,MC_DTR           ; Set DTR active; RTS, OUT1, and OUT2
      DelayOut  dx,al               ; inactive. This powers down mouse.
      mov       cx,9d               ; wait for 1/2 second to pwrdwn mouse
      call      SetupForWait        ; Set up BX:CX and ES:DI properly for
      assume    es:nothing          ; upcoming delay loop.

      address   LSR MCR             ; Get address of Line Status Reg.
;
; Now, we wait the specified amount of time, throwing away any stray
; data that we receive. This gives the mouse time to properly reset
; itself.
;
lt_waitloop:
      DelayIn   al,dx               ; Read and ignore any stray data.
      call      IsWaitOver          ; Determine if we've delayed enough.
      jnc       lt_waitloop         ; If not, keep waiting.

      address   MCR LSR             ; Get address of Modem COntrol Reg.
      mov       al,MC_DTR+MC_RTS+MC_OUT2 ; Set DTR, RTS, and OUT2 active
                                         ; OUT1 inactive.
      DelayOut  dx,al               ; This should power up the mouse.

      mov       cx,9d               ; wait for 1/2 second to pwrup mouse
      call      SetupForWait        ; Set up BX:CX and ES:DI properly for
      assume    es:nothing          ; upcoming delay loop.
                                    ; ask for current baud rate
lt_waitloop2:
      call      IsWaitOver          ; Determine if we've delayed enough.
      jnc       lt_waitloop2

      address   TXB MCR             ; Get address of Transmit Buffer.
      mov       al, 073h            ; Ask for status - send 's'
      DelayOut  dx,al

      mov       cx,1                ; Wait at least 55.5 ms for response.
      call      SetupForWait
      assume    es:nothing
      
      address   RXB TXB             ; Get address of Receive Buffer.

lt_waitloop3:
      DelayIn   al,dx               ; Get character that was sent to us.
      call      IsWaitOver
      jnc       lt_waitloop3

      and       al,10111111b        ; Mask off the mode bit. bit 6.
      cmp       al, 0fh             ; al = Fh means command understood
      jne       no_lt_found

      mov       ax,LT_MOUSE
      jmp short lt_leave

no_lt_found:
      mov       ax,NO_MOUSE

lt_leave:
      ret

TestForLogitechSerial ENDP

;*****************************************************************************
;
; setupForLogitechSerial
;
; This procedure will set up the given COM port so that it can talk to
;   a Logitech C series serial mouse.
;
; ENTRY DX   Base address of COM port to set up
;
; EXIT  COM port set up, all interrupts disabled at COM port
;
; ALTERS  AX
;
; CALLS none
;
setupForLogitechSerial  PROC  NEAR

  push  dx    ; Save base I/O address.
  address LCR RXB   ; Get address of Line Control Reg.
  mov al,LC_DLAB  ; Set up to access divisor latches.
  DelayOut  dx,al
  address LATMSB  LCR ; Get address of high word of divisor
  mov al,HIGH DIV_1200  ; latch and set it with value for
  DelayOut  dx,al   ; 1200 baud.
  address LATLSB LATMSB ; Get address of low word of divisor
  mov al,LOW DIV_1200 ; latch and set it with value for
  DelayOut  dx,al   ; 1200 baud.
  address LCR  LATLSB ; Get address of Line Control Reg.
  mov al,LC_BITS8 + LC_STOP1 + LC_PNONE
  DelayOut  dx,al   ; Set 7,n,1; disable access to divisor.
  address IER  LCR    ; Get address of Int. Enable Register
  xor al,al   ; Disable all interrupts at the COM
  DelayOut  dx,al   ; port level.
  address LSR  IER    ; Get address of Line Status Reg.
  DelayIn al,dx   ; Read it to clear any errors.
  pop dx    ; Restore base I/O address
  ret

setupForLogitechSerial  ENDP

sEnd     CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\md.inc ===
;************************************************************************
;
;       HARDWARE.INC
;
;       This file defines the hardware specific equates to be used in
;               the mouse driver.
;

IOdelay macro
         jmp       $+2
         jmp       $+2
endm

address macro StartAddr, EndAddr
        add   dx,StartAddr-EndAddr
endm

DelayIn   macro dest,src
          IOdelay
          in dest,src
endm

DelayOut  macro dest,src
          IOdelay
          out dest,src
endm

;
; This makes debugging much, much easier !!
;

IFDEF DEBUG

; Label Names.

PUBLIC  serial_next_port,  rsm_waitloop,           cfmm_retry
PUBLIC  inport_not_found,  rsm_waitover,           cfmm_failure
PUBLIC  tfs_determine_int, rsm_lookforM,           cfmm_signature_sent
PUBLIC  cfas_clean_up,     rsm_gotchar,            cfmm_cleanup
PUBLIC  r8cb_got_data,     rsm_leave,              cfmm_disable_aux
PUBLIC  r8cb_leave,        gmd_loop,               cfas_is_wait_over
PUBLIC  w8cb_leave,        tfp_no_mouse,           rpm_retry
PUBLIC  wib_success,       tfp_leave,              rpm_failure
PUBLIC  mioff_leave,       cfas_read_test_results, finished_mouse
PUBLIC  cmd_leave,         cfas_no_support,        cfmm_leave
PUBLIC  stmatd_leave,      cfas_reenable_kbd,      All_is_well
PUBLIC  gmd_buffer_empty,  cfas_leave,             possible_inport
PUBLIC  gmd_got_aux_data,  r8cb_loop,              inport_check
PUBLIC  rpm_leave,         r8cb_leave2,            bus_not_found
PUBLIC  inport_try_again,  wib_wait,               tfs_error_leave
PUBLIC  inport_found,      wib_check_output,       wcr_loop
PUBLIC  look_for_bus,      wib_failure,            wcr_success
PUBLIC  look_for_serial,   wib_check_aux_data,     mioff_cleanup
PUBLIC  serial_try_again,  wib_leave,              mioff_reenable_kbd
PUBLIC  serial_test_port,  serial_not_found,       serial_found
PUBLIC  logiTech_failure,  lt_waitloop,            lt_waitloop2
PUBLIC  lt_waitloop3,      lt_cont,                lt_found
PUBLIC  look_for_PS2

; Function Names.

PUBLIC  setup_for_detect,    RestoreCOMSetting,      WriteControlRegister  
PUBLIC  TestForInport,       SetupForWait,           WriteInputBuffer      
PUBLIC  TestForBus,          IsWaitOver,             Write8042CommandByte   
PUBLIC  TestForSerial,       CheckForAuxSupport,     ResetPS2Mouse          
PUBLIC  TestForPS2,          MouseIntOff,            SendToMouse 
PUBLIC  SaveCOMSetting,      CheckForMSMouse,        SendToMouseAndTestData
PUBLIC  SetupCOMForMouse,    WriteControlRegister,   GetMouseData           
PUBLIC  ResetSerialMouse,    Read8042CommandByte,    CheckMouseData         
PUBLIC  CheckForLogitechPS2, TestForLogitechSerial,  setupForLogitechSerial

; Global Variable Names.

PUBLIC  LATLSBSave,   LCRSave,  IERSave,        fSingle8259  
PUBLIC  LATMSBSave,   MCRSave,  SemaphoreWord,  COM_3_4_ADDRS
   
ENDIF   ;DEBUG

TRUE           EQU    0ffh
FALSE          EQU    0

LW_ClockTickCount EQU    46Ch
HW_ClockTickCount EQU    46Eh

;************************************************************************
;               I N P O R T     D E F I N I T I O N S                   *
;************************************************************************

INP_ADDR        EQU     0               ; Inport addr register offset.
INP_DATA        EQU     1               ; Inport data register offset.
INP_ID          EQU     2               ; Inport ID register offset.
INP_TEST        EQU     3               ; Inport test register offset.

INPORT_ID       EQU     0DEh            ; InPort ID byte.

INP_STATUS_REG  EQU     0               ; Status register number.
INP_DATA1_REG   EQU     1               ; Internal data register 1.
INP_DATA2_REG   EQU     2               ; Internal data register 2.
INP_MODE_REG    EQU     7               ; Mode register number.

INP_RESET       EQU     10000000b       ; Value to reset InPort.

HZ0INTR0        EQU     00000000b       ; Value to select 0 Hz, INTR=0
HZ0INTR1        EQU     00000110b       ; Value to select 0 Hz, INTR=1
HZ30            EQU     00000001b       ; Value to select 30 Hz.
DATA_INT_ENAB   EQU     00001000b       ; Data int enable bit.
TIMER_INT_ENAB  EQU     00010000b       ; Timer int enable bit.
HOLD_BIT        EQU     00100000b       ; Hold bit.

BUTTON_1_BIT    EQU     00000100b       ; Bit indicating button 1.
BUTTON_3_BIT    EQU     00000001b       ; Bit indicating button 3.
MOVEMENT_BIT    EQU     01000000b       ; Bit indicating movement.

INPORT_FIRST_PORT EQU   23Ch            ; Address of primary InPort.
INPORT_LAST_PORT EQU    238h            ; Address of secondary InPort.

MACH20_IRQ      EQU     0Ch             ; IRQ used for Mach 20 InPort
                                        ; under Mach 20 OS/2.

;****************************************************************
;               B U S   D E F I N I T I O N S                   *
;****************************************************************
; Since the Adaptor for the bus mouse is based on an 8255A, we have to
;       program the 8255A properly in order to function. We need to select:
;
;       Mode 0 (for all ports).
;       Port A (input - this allows us to read information from the ALPS
;               chip and from the buttons)
;       Port B (output - this allows us to write a value there and then
;               read it back in. It is not connected to anything)
;       Port C, upper half (output - this allows us to send control
;               information to the ALPS chip)
;       Port C, lower half (input - this allows us to poll the current states
;               of IRQs 2, 3, 4, and 5)
;
; The value that does this is
;
;       10010001
;       ||||||||-----   Port C Lower is input
;       |||||||------   Port B is output
;       ||||||-------   Mode 0 for Group B (Port B and lower half of Port C)
;       |||||--------   Port C Upper is output
;       ||||---------   Port A is input
;       |------------   Mode 0 for Group A (Port A and upper half of Port C)
;       -------------   Mode set control word
;

BUS_MOUSE_BASE  EQU     023Ch           ; Base I/O addr of bus mouse.

BUS_DATA        EQU     BUS_MOUSE_BASE  ; Port where mouse data is read from.
BUS_SIG         EQU     BUS_MOUSE_BASE + 1 ; Port unused for mouse, used for de-
                                        ; termining existence of bus adaptor.
BUS_CONTROL     EQU     BUS_MOUSE_BASE + 2 ; Port used to control adaptor.
BUS_INIT        EQU     BUS_MOUSE_BASE + 3 ; Port used to init bus adaptor.

BUS_INIT_VALUE  EQU     10010001b       ; Value used to init bus adaptor.

LOW_X           EQU     090h            ; Cmd to read low 4 bits of delta X
HI_X            EQU     0B0h            ; Cmd to read high 2 bits of delta X
LOW_Y           EQU     0D0h            ; Cmd to read low 4 bits of delta Y
HI_Y            EQU     0F0h            ; Cmd to read high 2 bits of delta Y

;************************************************************************
;               S E R I A L     D E F I N I T I O N S                   *
;************************************************************************

SERIAL_PACKETSIZE       EQU     3       ; Bytes in a packet of data.

SYNC_BIT                EQU     40H     ; Bit 6 is the sync bit

;
; These are the offsets within the COM chip of the various registers.
;

TXB             EQU     0               ; Transmit buffer
RXB             EQU     0               ; Receive buffer
LATLSB          EQU     0               ; Divisor latch, LSB
LATMSB          EQU     1               ; Divisor latch, MSB
IER             EQU     1               ; Interrupt enable register
IIR             EQU     2               ; Interrupt identification register
LCR             EQU     3               ; Line control register
MCR             EQU     4               ; Modem control register
LSR             EQU     5               ; Line status register
MSR             EQU     6               ; Modem status register

;
; These give the number of milliseconds to wait while waiting for the serial
;       mouse to reset itself. We will first use the value given by SHORTDELAY
;       and if that fails, we will then use the value given by LONGDELAY.
;

SHORTDELAY      EQU     6        ; 350  msecs  = 350/55.5  = 6  clock ticks.
LONGDELAY       EQU     18       ; 1000 msecs  = 1000/55.5 = 18 clock ticks.

;
; These are the values that are written into the divisor latch for the
;       various baud rates. They are obtained by dividing the clock rate
;       (1.8432 MHz) by 16x the desired baud rate.
;

DIV_50          EQU     900h
DIV_75          EQU     600h
DIV_110         EQU     417h
DIV_150         EQU     300h
DIV_300         EQU     180h
DIV_600         EQU     0C0h
DIV_1200        EQU     060h
DIV_1800        EQU     040h
DIV_2000        EQU     03Ah
DIV_2400        EQU     030h
DIV_3600        EQU     020h
DIV_4800        EQU     018h
DIV_7200        EQU     010h
DIV_9600        EQU     00Ch

;
;** Interrupt enable masks
;

IE_RX           EQU     00000001b       ; read data available
IE_TX           EQU     00000010b       ; transmit buffer empty
IE_LX           EQU     00000100b       ; line status change
IE_MX           EQU     00001000b       ; modem status change

;
;** Line control masks
;

LC_BMASK        EQU     00000011b       ; data bits mask
LC_BITS5        EQU     00000000b       ; 5 data bits
LC_BITS6        EQU     00000001b       ; 6 data bits
LC_BITS7        EQU     00000010b       ; 7 data bits
LC_BITS8        EQU     00000011b       ; 8 data bits

LC_SMASK        EQU     00000100b       ; stop bits mask
LC_STOP1        EQU     00000000b       ; 1 stop bit
LC_STOP2        EQU     00000100b       ; 2 stop bits (1.5 if 5 data bits)

LC_PMASK        EQU     00111000b       ; parity mask
LC_PNONE        EQU     00000000b       ; none parity
LC_PODD         EQU     00001000b       ; odd parity
LC_PEVEN        EQU     00011000b       ; even parity
LC_PMARK        EQU     00101000b       ; mark parity
LC_PSPACE       EQU     00111000b       ; space parity

LC_BREAK        EQU     01000000b       ; transmit break
LC_DLAB         EQU     10000000b       ; divisor latch access bit
LC_MASK         EQU     01111111b       ; documented line control register bits

;
;** Modem control register masks
;

MC_DTR          EQU     00000001b       ; data terminal ready
MC_RTS          EQU     00000010b       ; request to send
MC_OUT1         EQU     00000100b       ; output 1
MC_OUT2         EQU     00001000b       ; output 2
MC_LOOP         EQU     00010000b       ; loopback mode

;
;** Line status register masks
;

LS_DR           EQU     00000001b       ; data ready
LS_OERR         EQU     00000010b       ; overrun error
LS_PERR         EQU     00000100b       ; parity error
LS_FERR         EQU     00001000b       ; framing error
LS_BI           EQU     00010000b       ; break interrupt
LS_THRE         EQU     00100000b       ; TX holding register empty
LS_TSRE         EQU     01000000b       ; TX shift register empty

;
;** Modem status register definitions:
;

MS_DCTS         EQU     00000001b       ; delta clear to send
MS_DDSR         EQU     00000010b       ; delta data set ready
MS_TERI         EQU     00000100b       ; trailing edge of ring indicator
MS_DDCD         EQU     00001000b       ; delta receiver line signal detect
MS_CTS          EQU     00010000b       ; clear to send
MS_DSR          EQU     00100000b       ; data set ready
MS_RI           EQU     01000000b       ; ring indicator
MS_DCD          EQU     10000000b       ; receiver line signal detect

;************************************************************************
;               8 2 5 9 A  D E F I N I T I O N S                        *
;************************************************************************

MASTER_MASK_ADDR EQU     021h            ; Master's mask register addr.
SLAVE_MASK_ADDR  EQU     0A1h            ; Slave's mask register addr.
IRQS_PER_8259    EQU     8               ; # IRQs on each 8259A.
SELECT_IRR       EQU     0Ah             ; Selects int request register.
SELECT_ISR       EQU     0Bh             ; Selects in service register.

;****************************************************************
;               P S / 2   D E F I N I T I O N S                 *
;****************************************************************

PS2_IRQ         EQU     0Ch             ; Always IRQ 12 for PS/2 mouse.
PS2_IRQ_MASK    EQU     00010000b       ; Bit mask for IRQ 12.
PS2_PACKETSIZE  EQU     3               ; Bytes in a packet of data.

DX_SIGN         EQU     00010000b       ; Bit 4 is dx sign bit in status byte
DY_SIGN         EQU     00100000b       ; Bit 5 is dy sign bit in status byte

PS2_25PPI       EQU     0               ; Value to set resolution to 25 ppi.
PS2_50PPI       EQU     1               ; Value to set resolution to 50 ppi.
PS2_100PPI      EQU     2               ; Value to set resolution to 100 ppi.
PS2_200PPI      EQU     3               ; Value to set resolution to 200 ppi.


MCMD_RESET      EQU     0FFh            ; Reset mouse command
MCMD_RESEND     EQU     0FEh            ; Resend data to mouse
MCMD_DIAG_ERR   EQU     0FCh            ; Error on mouse diagnostics
MCMD_ACK        EQU     0FAh            ; Acknowledge
MCMD_DEFAULT    EQU     0F6h
MCMD_DISABLE    EQU     0F5h            ; Disable Mouse command
MCMD_ENABLE     EQU     0F4h            ; Enable Mouse command
MCMD_RATE       EQU     0F3h            ; Set sampling rate
MCMD_READ_TYPE  EQU     0F2h            ; Read device type
MCMD_REMOTE     EQU     0F0h            ; Set remote mode
MCMD_ECHO       EQU     0EEh            ; Set wrap mode
MCMD_KILL_ECHO  EQU     0ECh            ; reset wrap mode
MCMD_READDATA   EQU     0EBh            ; Read mouse data
MCMD_STREAM     EQU     0EAh            ; Set stream mode
MCMD_STATUS     EQU     0E9h            ; Status Request
MCMD_RESOLUTION EQU     0E8h            ; Set Resolution
MCMD_SCALE_2_1  EQU     0E7h            ; Set scaling 2 to 1
MCMD_SCALE_1_1  EQU     0E6h            ; Set scaling 1 to 1
MCMD_DIAG_OK    EQU     0AAh            ; Diagnostics ok
MCMD_DIAG_ID    EQU     000h            ; Diagnostic ID number

;
; The following codes are specific to the Microsoft PS/2 mouse
;

MCMD_MS_VERS    EQU     052h            ; Read current firmware version number
MCMD_MS_INPORT  EQU     056h            ; Read raw InPort data
MCDM_MS_DIAG    EQU     059h            ; enter MS diagnostices mode
MCMD_MS_READRAM EQU     05Bh            ; read ram byte

;****************************************************************
;               8 0 4 2  D E F I N I T I O N S                  *
;****************************************************************

;
; 8042 port definitions.
;

DATA_8042       EQU     60h             ; Port where data is sent to/from 8042.
CONTROL_8042    EQU     64h             ; Port where commands are sent to 8042.
STATUS_8042     EQU     64h             ; Port where status is read from 8042.
CRT_DATA_SEG	EQU	40H     	; ROM BIOS CRT Data Segment Address

;
; Status register bit definitions.
;

O_FULL          EQU     01h             ; 8042's output buffer is full.
I_FULL          EQU     02h             ; 8042's input buffer is full.
A_FULL          EQU     20h             ; 8042's aux output buffer is full.

;
; Command byte bit definitions.
;

AUX_DISABLED    EQU     20h             ; Auxiliary interface is disabled.
AUX_INT_ENABLE  EQU     02h             ; Auxiliary interrupts are enabled.

;
; 8042 commands.
;

CMD8042_READ_CMD EQU    020h            ; Read command byte.
CMD8042_WRITE_CMD EQU   060h            ; Write command byte.
CMD8042_DISABLE_AUX EQU 0A7h            ; Disable auxiliary interface.
CMD8042_ENABLE_AUX EQU  0A8h            ; Enable auxiliary interface.
CMD8042_TEST_AUX EQU    0A9h            ; Test auxiliary interface.
CMD8042_DISABLE_KBD EQU 0ADh            ; Disable keyboard.
CMD8042_ENABLE_KBD EQU  0AEh            ; Enable keyboard.
CMD8042_WRITE_AUX EQU   0D4h            ; Send data to auxiliary device.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\meminfo.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * MEMINFO.C - Source file for obtaining memory information.
 ********************************************************************/


/* Include Files */

#include "msd.h"


/*********************************************************************
 * GetMemInfo - Gets the memory information.
 *
 * pMem         - Pointer to memory information structure.
 * fMinimumInfo - TRUE if minimum info is requested.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetMemInfo (MEMORY_STRUCT *pMem, BOOL fMinimumInfo)
{
  BOOL fReturnValue = FALSE;  /* Return value from various GetInfo calls */
  WORD wSize;                 /* Size, in bytes, to store the data       */
  COMPUTER_STRUCT *pComputer = NULL;  /* Computer info structure pointer */
  WORD wProcessor;            /* Stores the processor type               */
  WORD wBusType;              /* Stores the computer's bus type          */


  wSize = GetInfoSize (IDI_COMPUTER_RECORD, FALSE);

  if (wSize == 0)
    return (TRUE);

  pComputer = malloc (wSize);

  if (pComputer == NULL)
    {
      OutOfMemory();
      return (TRUE);
    }

  /* Zero out the structure */
  memset (pComputer, '\0', wSize);

  fReturnValue = GetComputerIrqInfo (pComputer);
  if (fReturnValue)
    {
      free (pComputer);
      return (fReturnValue);
    }

  wProcessor = pComputer->wProcessor;
  wBusType   = pComputer->wBusType;
  free (pComputer);


  /* Initialize the memory info structures */
  MInitialize ((MEMORY_STRUCT FAR *) pMem);

  /* Get conventional memory size */
  Get_Conv_Mem_Info ((MEMORY_STRUCT FAR *) pMem);

  if (wProcessor >= _80286)
    {
      /* Get installed extended according to CMOS */
      GetCMOSExtended ((MEMORY_STRUCT FAR *) pMem);

      /* Get non-XMS extended memory size */
      Get_Ext_Mem_Info ((MEMORY_STRUCT FAR *) pMem);

      /* Get XMS extended memory info */
      Get_Xmm_Info ((MEMORY_STRUCT FAR *) pMem, wProcessor);

      /* Make sure we're on at least a 386 for DPMI information */
      if (wProcessor != _80286)
        GetDPMIInfo ((MEMORY_STRUCT FAR *) pMem);
    }

  /* Check for an EMM driver */
  Test_For_Emm ((MEMORY_STRUCT FAR *) pMem);

  if (pMem->iEmm_Is_There)
    {
      /* Get expanded memory info */
      Get_Emm_Info ((MEMORY_STRUCT FAR *) pMem);

      /* If on a 386 or greater */
      if (/* !(pMem->iDPMIPresent) && */ wProcessor >= _80386)
        {
          /* check for and get VCPI info */
          GetVCPIInfo ((MEMORY_STRUCT FAR *) pMem);
        }
    }

  if (fMinimumInfo)
    return (FALSE);

  /* Get the visual memory map */
  Get_VisualMemMap ((MEMORY_STRUCT FAR *) pMem, wBusType);

  /* Fill the visual memory map overlay with EMS page frame and UMBs */
  VisualMapOverlay ((MEMORY_STRUCT FAR *) pMem);

  return (FALSE);
}


/************************************************************************
*
* Function MInitialize()
*
* This function initializes fields in the Mem_Info_St structure to
* zero values.
*
************************************************************************/

int MInitialize (MEMORY_STRUCT FAR * pMem_Info)

{
  /* Initialize the fields in the Mem_Info_St structure */
  _fmemset (pMem_Info, '\0', sizeof (MEMORY_STRUCT));

  return (0);
}

/***************************************************************************
*
* Function Get_Conv_Mem_Info()
*
* This function gets the amount of conventional memory in bytes and the
* amount of free conventional memory in bytes. It uses a call to BIOS
* function Int 12H.                                                                    *
*
*
* Mem_Info_St Fields Set
* ----------------------
*
* lConv_Mem     = The amount of conventional memory in bytes
* lFree_Conv_Mem  = The amount of free conventional memory in bytes
*
*
* Local Variables Used                                      
    *
* --------------------
*
*
* inregs, outregs : Used for reading and writing the general purpose
*         registers.
* segment_prefix  : Used to hold the segment address of the program
*         segment prefix.
*
***************************************************************************/

int Get_Conv_Mem_Info (MEMORY_STRUCT FAR * pMem_Info)

{
  union REGS inregs, outregs;
  long segment_prefix;

  int86(0x12, &inregs, &outregs);

  pMem_Info->lConv_Mem = outregs.x.ax * 1024L;

  segment_prefix = 0L;
  segment_prefix = segment_prefix + ((long)(_psp) * 0x10);

  pMem_Info->lFree_Conv_Mem = pMem_Info->lConv_Mem - segment_prefix;

  return (0);
}

/***************************************************************************
*
* Function Get_Ext_Mem_Info()
*
* This function gets the amount of extended memory in bytes. It uses a
* call to BIOS function Int 15H, subfunction 88H.
*
*
* Mem_Info_St Fields Set
* ----------------------
*
* lExt_Mem      = The amount of extended memory in bytes
*
*
* Local Variables Used
* --------------------
*
* inregs, outregs : Used for reading and writing the general purpose
*         registers.
*
***************************************************************************/

int Get_Ext_Mem_Info (MEMORY_STRUCT FAR * pMem_Info)

{
  union REGS inregs, outregs;
  static int iFirstTime = 1;


  /* Check to see if this is the first time this routine was called.
     We do this because of the XMS memory routine which is called
     after this. In the XMS memory routine, if an XMS driver is found,
     the driver hooks into INT 15 calls. Subsequent calls to INT 15
     to get the amount of extended memory then return 0K. By calling
     this routine first and then never checking it again, we are able
     to get a valid value for extended memory at least the first time
     we are run on the machine */

  if (iFirstTime)
  {
    inregs.h.ah = 0x88;
    int86(0x15, &inregs, &outregs);

    pMem_Info->iExt_Mem = outregs.x.ax;

    iFirstTime = 0;
  }

  return (0);
}

/***************************************************************************
*
* Function GetCMOSExtended ()
*
* This function gets the amount of installed extended memory according to
* the CMOS.
*
***************************************************************************/

int GetCMOSExtended (MEMORY_STRUCT FAR * pMem_Info)

{
  int iHighByte, iLowByte, iTotalMemory;
  int iLoop;

  outp (0x70, 0x17);

  for (iLoop = 0; iLoop < 100; iLoop++)
    ;

  iLowByte = inp (0x71);


  outp (0x70, 0x18);

  for (iLoop = 0; iLoop < 100; iLoop++)
    ;

  iHighByte = inp (0x71);


  iTotalMemory = (iHighByte << 8) + iLowByte;

  pMem_Info->iCMOSExtended = iTotalMemory;

  return (0);
}

/***************************************************************************
*
* Function Test_For_Emm()
*
* This function tests for the existence of an EMM driver. It makes a call
* to Int 21H Function 35H to get the address of the interrupt handler for
* the EMM driver.  It then looks at offset 0AH of the device header to
* check for the guaranteed name of the EMM driver, EMMXXXX0. If the
* guaranteed name is found, there is an EMM driver installed and the value
* True is put in the iEmm_Is_There field of the Mem_Info_St structure.
* If the guaranteed name is not found, a value of False is put in the
* iEmm_Is_There field of the Mem_Info_St structure.
*
*
* Mem_Info_St Fields Set
* ----------------------
*
* iEmm_IS_There  = 1 if an EMM driver is found, 0 if not
*
*
* Local Variables Used
* --------------------
*
* inregs, outregs:  For loading and reading the general purpose regs.
* segments     :  For loading and reading the segment regs.
* addr_of_emm  :  The base address of the EMM driver, if it is there.
* ptr_to_emm   :  A pointer to the base address of the EMM driver
* name_field   :  An array to hold the string found at the name field of
*         device header of the EMM driver.
* test_name    :  An array to hold the guaranteed name of the EMM
*         driver, EMMXXXX0.
* index      :  Used for loop control.
* True, False  :  Used for Boolean testing.
*
***************************************************************************/

int Test_For_Emm (MEMORY_STRUCT FAR * pMem_Info)

{
  union REGS inregs, outregs;
  struct SREGS segments;
  unsigned long addr_of_emm;
  char far *ptr_to_emm = NULL;
  char name_field[9];
  char test_name[9] = {
        'E', 'M', 'M', 'X',
        'X', 'X', 'X', '0', '\0'
  };
  int index;
  int True = 1;
  int False = 0;

  /* load AL with the EMM int vector of 67H and prepare
     to call Int 21H, Function 35H */

  inregs.h.al = 0x67;
  inregs.h.ah = 0x35;

  /* After this call, the ES reg will contain the EMM handler address
     if it is there */

  int86x(0x21, &inregs, &outregs, &segments);
  segread(&segments);

  addr_of_emm = 0L;

  /* Load addr_of_emm with address in the ES reg, then shift it left
     16 bits to get it into the high order word */

  addr_of_emm = (addr_of_emm | segments.es) <<16;

  /* Add the offset of 0AH to make ptr_to_emm point to the name field
     in the device header of the EMM driver */

  ptr_to_emm = (unsigned char far *)addr_of_emm + 0x0A;

  /* Load the the first 8 characters beginning at the address pointed
     to by the pointer ptr_to_emm, then add a terminating \0 */

  for(index = 0; index < 8; ++index)
  {
    name_field[index] = *ptr_to_emm;
         ++ptr_to_emm;
  }
  name_field[index] = '\0';

  /* Compare the characters loaded into name_field[] against the
     guaranteed EMM driver name stored in test_name[]. Set
     iEmm_Is_There to True if equal, False if not */

  if (strcmp(test_name, name_field))
    pMem_Info->iEmm_Is_There = False;
  else
    pMem_Info->iEmm_Is_There = True;

  return (0);
}

/**************************************************************************
*
* Function Get_Emm_Info()
*
* This function gets the EMM driver version, the total number of 16K EMM
* pages and the number of 16K EM pages currently available.
*
*
* Mem_Info_St Fields Set
* ----------------------
*
* iEmm_VersionMajor = The EMS version supported by the EMS driver
* iEmm_VersionMinor = The EMS version supported by the EMS driver
* iTotal_Emm_Pages  = The total number of logical expanded memory pages
*                     present
* iFree_Emm_Pages   = The number of logical pages not allocated
* iEmm_Ver_Err      = Error code returned while getting the version
* iEmm_Size_Err     = Error code returned while getting allocation info
*
*
* Local Variables Used
* --------------------
*
* inregs, outregs  : Used to load and read the general purpose
*            registers
* int_portion    : Used to figure the integer portion of the version
* frac_portion     : Used to figure the fractional portion of the
*            version
* uiPageFrameAddress : Used to get the EMS page frame address
* uiMappablePages  : Used to get the number of LIM 4.0 mappable pages
*
**************************************************************************/

int Get_Emm_Info(MEMORY_STRUCT FAR * pMem_Info)

{
  union REGS inregs, outregs;
  struct SREGS segments;
  int int_portion, frac_portion;
  unsigned int uiPageFrameAddress;
  unsigned int *pPtrToConfigBuffer = NULL;


  /* Get the EMM version */

  inregs.h.ah = 0x46;
  int86(0x67, &inregs, &outregs);

  if (outregs.h.ah == 0x0)
  {
    frac_portion = (outregs.h.al & 0x0F);
    int_portion = ((outregs.h.al >> 4) & 0x0F);
    pMem_Info->iEmm_VersionMajor = int_portion;
    pMem_Info->iEmm_VersionMinor = frac_portion;
  }
  else
    pMem_Info->iEmm_Ver_Err = outregs.h.ah;


  /* Get the total number of EM pages and the number free using a
     LIM 3.X call */

  inregs.h.ah = 0x42;
  int86(0x67, &inregs, &outregs);

  if (outregs.h.ah)
    pMem_Info->iEmm_Size_Err = outregs.h.ah;
  else
  {
    pMem_Info->iTotal_Emm_Pages = outregs.x.dx;
    pMem_Info->iFree_Emm_Pages = outregs.x.bx;
  }


  /* If LIM 4.0 was detected use a LIM 4.0 specific call to get the
     total number of raw EM pages and the number of raw EM pages
     available */

  if (pMem_Info->iEmm_VersionMajor == 4 && pMem_Info->iEmm_VersionMinor == 0)
    {
      /* Get the size of a raw EM page from the EM hardware configuration */

      if (( pPtrToConfigBuffer = (unsigned int *) malloc (10)) == NULL )
        pMem_Info->iEmm_Size_Err = outregs.h.ah; /* The malloc failed */
      else
        {
          /* Get the EM hardware configuration */

          inregs.x.ax = 0x5900;
          segread (&segments);
          segments.es = (unsigned int) FP_SEG (pPtrToConfigBuffer);
          inregs.x.di = (unsigned int) FP_OFF (pPtrToConfigBuffer);

          int86x (0x67, &inregs, &outregs, &segments);


          if (outregs.h.ah) /* There was an error getting the EM config */
            pMem_Info->iEmm_Size_Err = outregs.h.ah;
          else
            {
              /* At this point pPtrToConfigBuffer is pointing to an integer
                 value which is the raw EM page size, in paragraphs. Next,
                 get the total number of raw pages and the number available */

              inregs.x.ax = 0x5901;
              int86 (0x67, &inregs, &outregs);

              if (outregs.h.ah) /* There was an error returned */
                pMem_Info->iEmm_Size_Err = outregs.h.ah;
              else
                {
                  pMem_Info->iTotal_Emm_Pages = outregs.x.dx;
                  pMem_Info->iFree_Emm_Pages = outregs.x.bx;
                }
            }
        }
    }

  /* Free up the EMS pointer */
  free (pPtrToConfigBuffer);

  /* Get the EMS page frame address */

  inregs.h.ah = 0x41;
  int86(0x67, &inregs, &outregs);
  uiPageFrameAddress = outregs.x.bx;

  if (!outregs.h.ah) /* A page frame address was returned */
    pMem_Info->iPageFrameAddress = uiPageFrameAddress;

  return (0);
}

/************************************************************************
*
* Function GetVCPIInfo ()
*
* This function detects whether or not a VCPI control program is present.
* If one is, information about the amount of VCPI memory available is
* gathered.
*
************************************************************************/

int GetVCPIInfo (MEMORY_STRUCT FAR * pMem_Info)

{
  union REGS inregs, outregs;
  struct SREGS segments;

  inregs.x.ax = 0xDE00;
  int86x (0x67, &inregs, &outregs, &segments);

  if( outregs.h.ah == 0x00 )
  {
    pMem_Info->iVCPIPresent = 1;
    pMem_Info->iVCPIMajorVersion = outregs.h.bh;
    pMem_Info->iVCPIMinorVersion = outregs.h.bl;

    /* Query the amount of available VCPI memory */

    inregs.x.ax = 0xDE03;
    int86x (0x67, &inregs, &outregs, &segments);

    if (outregs.h.ah == 0x00 )
    pMem_Info->iVCPIAvailMemory = outregs.x.dx * 4;
  }

  return (0);
}

/************************************************************************
*
* Function GetDPMIInfo ()
*
* This function detects whether or not a DPMI control program is present.
* If one is, information about the amount of DPMI memory available is
* gathered by calling the function QueryDPMIMemInfo ().
*
************************************************************************/

int GetDPMIInfo (MEMORY_STRUCT FAR * pMem_Info)

{
  union REGS inregs, outregs;
  struct SREGS segments;

  inregs.x.ax = 0x1687;
  int86x (0x2F, &inregs, &outregs, &segments);

  if (outregs.x.ax == 0x00)
  {
    pMem_Info->iDPMIPresent = 1;
    pMem_Info->iDPMIMajorVersion = outregs.h.dh;
    pMem_Info->iDPMIMinorVersion = outregs.h.dl;

    /* Query the DPMI control program */
/*
    QueryDPMIMemInfo (pMem_Info);
*/
  }

  return (0);
}

/************************************************************************
*
* Function QueryDPMIMemInfo ()
*
* This function queries the DPMI control program for amounts of DPMI
* memory.
*
************************************************************************/

int QueryDPMIMemInfo (MEMORY_STRUCT FAR * pMem_Info)

{
  long DPMIControl;
  unsigned short wRMMemAvail;
  DPMI_STRUCT FAR * pDPMIMemInfo = NULL;

  pDPMIMemInfo = (DPMI_STRUCT FAR *) &(pMem_Info->DPMIMemInfo);

  _asm
  {
    ; Get the entry point of the DPMI control program
    ; and save it

    mov   ax, 1687h
    int   2Fh
    test  ax, ax
    jnz   Failure
    mov   word ptr [DPMIControl],di
    mov   word ptr [DPMIControl+2],es

    ; if si != 0 then we need to allocate some memory
    ; for the dos extenders private data

    test  si, si
    jz    SiZero
    mov   bx, si
    mov   ah, 48h
    int   21h
    jc    Failure
    mov   es, ax
SiZero:
    xor   ax,ax

    call  [DPMIControl]

    jc    Failure
    les   di, pDPMIMemInfo
    mov   ax, 0500h
    int   31h
    jc    Failure
    mov   bx, 0ffffh
    mov   ax, 0100h
    int   31h
    mov   wRMMemAvail, bx
}

  pMem_Info->ulRealModeDPMIMemAvail = wRMMemAvail * 16;

Failure:

  return (0);
}

/************************************************************************
*
* Function Get_Xmm_Info()
*
* This function first tests for the existence of an XMS driver.  If an
* XMS driver is present, it returns the version of the XMS driver, the
* version of the XMS specification being used, whether or not the high
* memory area (HMA) is present, and whether or not the HMA is available.
* It also returns the size of the largest free extended memory block in
* bytes, and the total amount of free extended memory in bytes.
*
*
* Mem_Info_St Fields Set
* ----------------------
*
* iXmm_Is_There            = 1 if an XMS driver is present, 0 if not
* iXmm_Spec_VersionMajor   = The major version of the XMS specification
* iXmm_Spec_VersionMinor   = The minor version of the XMS specification
* iXmm_Driver_VersionMajor = The internal major version of the XMM driver
* iXmm_Driver_VersionMinor = The internal minor version of the XMM driver
* lLargest_Free_Xm         = The size in bytes of the largest free block of
*                            extended memory. Includes the 64K HMA if it is
*                            available.
* lTotal_Free_XM           = The size in bytes of the total amount of free
*                            extended memory. Includes the 64K HMA if it is
*                            available.
*
* Local Variables Used
* --------------------
*
* XMSControl       : The address of the XMS driver control function
* XMSIsThere       : Used to flag whether or not an XMS driver is
*                    present
* XMSSpecVersion   : The BCD version of the XMS spec being used
* XMSDriverVersion : The BCD version of the XMS driver being used
* LargestFreeBlock : Used to calculate the largest free block
* TotalFreeBlocks  : Used to calculate the total amount free
* HMAStatus        : Used to check the availability of the HMA
* XMSError         : Used to hold error codes returned from the XMS
*                    calls
* A20Status        : Used to hold the status of the A20 address line
* True, False      : Used to set value of iXmm_Is_There
*
************************************************************************/

int Get_Xmm_Info(MEMORY_STRUCT FAR * pMem_Info, WORD wProcessorType)

{
  long XMSControl;
  unsigned char XMSIsThere;
  unsigned char XMSSpecVersionMajor, XMSSpecVersionMinor;
  unsigned char XMSDriverVersionMajor, XMSDriverVersionMinor;
  unsigned int  LargestFreeBlock, TotalFreeBlocks;
  unsigned int  HMAStatus;
  unsigned char XMSError;
  unsigned int  A20Status;
  int True = 1;
  int False = 0;
  int Available = 1;
  int NotAvailable = 0;
  DWORD SxmsLargestFree;  /* Largest free SXMS block */
  DWORD SxmsTotalFree;    /* Total free SXMS         */


  /* Determine if an XMS driver is there */
  
  _asm

  {
    /* After setting AX=43h, AL=00h and calling INT 2Fh, if an
       XMS driver is present, AL will be set to 80h */

    mov   ax,4300h
    int   2Fh
    mov   XMSIsThere,al
  }


  if ( XMSIsThere == 0x80 ) /* There is an XMS driver present */
  {
    pMem_Info->iXmm_Is_There = True;
    
    _asm

    {
      /* Get the address of the XMS driver's control function.
         Once we have that we can make calls to it to get the
         other info we want */

      mov   ax,4310h
      int   2Fh
      mov   word ptr [XMSControl],bx
      mov   word ptr [XMSControl+2],es

      /* Get the XMS spec and driver version numbers, in BCD */

      mov   ah,00h
      call  [XMSControl]

      mov   XMSSpecVersionMajor,ah
      mov   XMSSpecVersionMinor,al

      mov   XMSDriverVersionMajor,bh
      mov   XMSDriverVersionMinor,bl
    }


    /* Get the XMS specification version */

    pMem_Info->uchXmm_Spec_VersionMajor = XMSSpecVersionMajor;
    pMem_Info->uchXmm_Spec_VersionMinor = XMSSpecVersionMinor;


    /* Get the XMS driver version */

    pMem_Info->uchXmm_Driver_VersionMajor = XMSDriverVersionMajor;
    pMem_Info->uchXmm_Driver_VersionMinor = XMSDriverVersionMinor;


    /* Query the amount of free extended memory */
    
    _asm

    {
      mov   ah,08h
      call  [XMSControl]
      mov   LargestFreeBlock,ax
      mov   TotalFreeBlocks,dx
      mov   XMSError,bl
    }

    /* Store the largest free block and the total free blocks */

    pMem_Info->iLargest_Free_Xm = LargestFreeBlock;
    pMem_Info->iTotal_Free_Xm = TotalFreeBlocks;


    /* Check to see if the HMA is available by issuing a request for it */
    
    _asm

    {
      /* Return the status of the request in HMAStatus. 0x0001 means
         the request succeeded, 0x0000 means it failed */

      mov   ah,01h
      call  [XMSControl]
      mov   HMAStatus,ax
      mov   XMSError,bl
    }

    if (HMAStatus) /* The HMA request succeeded */
    {
      pMem_Info->iHMAStatus = Available;


      /* Release the HMA */

      _asm

      {
        /* Return the status of the release in HMAStatus. 0x0001 means
           the HMA was released successfully, 0x0000 means otherwise */

        mov   ah,02h
        call  [XMSControl]
        mov   HMAStatus,ax
        mov   XMSError,bl
      }

      if (!HMAStatus) /* The HMA was not successfully released */
        pMem_Info->iXMSError = 6; /* There was an error releasing the HMA */
    }
    else /* the HMA request failed */
    {
      pMem_Info->iHMAStatus = NotAvailable;

      switch (XMSError) /* Get the reason why the HMA request failed */
      {
        case 0x80: pMem_Info->iXMSError = 1; /* Feature not implemented */
                   break;
        case 0x81: pMem_Info->iXMSError = 2; /* VDISK was detected */
                   break;
        case 0x90: pMem_Info->iXMSError = 3; /* HMA does not exist */
                   break;
        case 0x91: pMem_Info->iXMSError = 4; /* HMA is already in use */
                   break;
          default: pMem_Info->iXMSError = 5;   /* Unknown reason */
      }
    }


    /* Query the status of the A20 address line */
    
    _asm

    {
      mov   ah,07h
      call  [XMSControl]
      mov   A20Status,ax
      mov   XMSError,bl
    }

    /* Store the A20 line status */

    pMem_Info->iA20Status = A20Status;


    /* Detect the XMS UMB free areas */

#define XMS_UMB_ERROR       2
#define MAX_XMS_UMB_SEGS  100

    {
      BYTE  bErrorCode;         /* Error code from XMS UMB call         */
      WORD  wSegmentAddr;       /* Segment address of free XMS UMB      */
      WORD  wSegmentSize;       /* Size of XMS UMB                      */

      WORD wTotalFree = 0;      /* Total amount of free XMS UMB space   */
      WORD wLargestFree = 0;    /* Largest free area                    */
                                /* Segment addresses of XMS UMBs        */
      WORD  wSegments[MAX_XMS_UMB_SEGS + 1];
      WORD  i;                  /* Looping variable                     */
      BOOL  fDoneFlag = FALSE;  /* TRUE when all XMS UMBs accounted for */

      int iRow, iCol;             /* Row and Column of visual map overlay   */
      int iNumOfChars;            /* Number of characters (or 1K blocks)    */

      
      for (i = 0; i < MAX_XMS_UMB_SEGS && fDoneFlag == FALSE; ++i)
        {
          _asm
            {
              mov   ah, 0x10            ; Request XMS UMB
              mov   dx, 0xFFFF          ; Requested size in paragraphs

              call  [XMSControl]        ; Make the call

              or    ax,ax               ; AX == 0x0000 if it failed

              jz    FirstErrResults     ; Jump around if it failed

              mov   fDoneFlag, XMS_UMB_ERROR ; There is no way this could
                                        ;   have succeeded.  If it did,
                                        ;   bomb out immediately.

              jmp   FirstXmsUmbDone


            FirstErrResults:
              mov   bErrorCode, bl      ; Store the error code
              mov   wSegmentSize, dx    ; Store size of largest free block

            FirstXmsUmbDone:
            }

          /* Bomb out if 0xFFFF succeeded */
          if (fDoneFlag == XMS_UMB_ERROR)
            break;

          /* Are there no more segments free */
          if (bErrorCode == 0xB1)
            fDoneFlag == TRUE;

          /* If the function was not implemented, bomb out */
          if (bErrorCode == 0x80)
            {
              pMem_Info->fXmsUmbAvailable = FALSE;
              fDoneFlag = XMS_UMB_ERROR;
              break;
            }

          /* If an unexpected error occured, bomb out */
          if (bErrorCode != 0xB0)
            {
              fDoneFlag = XMS_UMB_ERROR;
              break;
            }

          /* The XMS UMB calls are available */
          pMem_Info->fXmsUmbAvailable = TRUE;


          /* One segment of wSegmentSize size is free -- allocate it */
          _asm
            {
              mov   ah, 0x10            ; Request XMS UMB
              mov   dx, wSegmentSize    ; Requested size in paragraphs

              call  [XMSControl]        ; Make the call

              or    ax,ax               ; AX == 0x0000 if it failed

              jz    SecondErrResults    ; Jump around if it failed

              mov   wSegmentAddr, bx    ; Store XMS UMB segment address
              mov   wSegmentSize, dx    ; Store size of block

              jmp   SecondXmsUmbDone


            SecondErrResults:
              mov   fDoneFlag, XMS_UMB_ERROR ; This should not have failed.
                                        ;   If it did, bomb out
                                        ;   immediately.
            SecondXmsUmbDone:
            }

          /* Bomb out if 0xFFFF succeeded */
          if (fDoneFlag == XMS_UMB_ERROR)
            break;

          /* Accumulate the results */
          wSegments[i] = wSegmentAddr;

          if (wSegmentSize > wLargestFree)
            wLargestFree = wSegmentSize;

          wTotalFree += wSegmentSize;

          /* Fill the memory map with "X"es */
          iRow        = wSegmentAddr / 0x400;
          iCol        = (wSegmentAddr % 0x400) / 0x40;
          iNumOfChars = (WORD) ((((DWORD) wSegmentSize << 4) + 1023) / 1024);
          FillMemMapOverlay (pMem_Info, iRow, iCol, iNumOfChars,
                             REPORT_FREE_XMS_UMB);
        }

      wSegments[i] = 0x0000;


      /* Store the results in the XMS UMB area of pMem_Info */

      pMem_Info->dwXmsUmbFree = (DWORD) wTotalFree << 4;
      pMem_Info->dwXmsUmbLargestFree = (DWORD) wLargestFree << 4;


      /* The amounts have been determined -- free the blocks */
      for (i = 0; i < MAX_XMS_UMB_SEGS && wSegments[i] != 0x0000; ++i)
        {
          wSegmentAddr = wSegments[i];

          _asm
            {
              mov   ah, 0x11            ; Release XMS UMB
              mov   dx, wSegmentAddr    ; paragraph to release

              call  [XMSControl]        ; Make the call

              or    ax,ax               ; AX == 0x0000 if it failed

              jnz   ThirdXmsUmbDone     ; Jump around if it failed

              mov   fDoneFlag, XMS_UMB_ERROR ; This should not have failed.
                                        ;   If it did, bomb out
                                        ;   immediately.
            ThirdXmsUmbDone:
            }

          if (fDoneFlag == XMS_UMB_ERROR)
            break;
        }
    }


    /* Get the Super Extended Memory values */
    {
      if (wProcessorType > _80286 &&
          GetSuperXmsInfo (XMSControl, &SxmsLargestFree, &SxmsTotalFree) == 0)
        {
          /* Super XMS exists */
          pMem_Info->fSxmsAvailable    = TRUE;
          pMem_Info->dwSxmsLargestFree = SxmsLargestFree;
          pMem_Info->dwSxmsTotalFree   = SxmsTotalFree;
        }
      else
        {
          /* There is no Super XMS */
          pMem_Info->fSxmsAvailable = FALSE;
        }
    }
  }
  else /* There is no XMS driver present */
    pMem_Info->iXmm_Is_There = False;

  return (0);
}

/************************************************************************
 * Function GetRomMap - Fills a ROM_MAP structure with the information
 *                      about ROM BIOSes and Option ROMs in the system.
 *
 * pRomMap - Pointer to the structure for storing the ROM map.
 ***********************************************************************/

VOID GetRomMap (ROM_MAP *pRomMap, WORD wBusType)
{
  int  iMapSegment, iMapOffset;
  WORD wOptIndex = 0;   /* Option ROM index */

  unsigned uSegment;
  unsigned uOffset;
  int iValidRom;
  int iFalse = 0;
  int iTrue = 1;


  unsigned END_SEGMENT = 0xEC00;

  /* Check if we are on a ps/2 or not. If this is a ps/2, the
     range E000-EFFF is system ROM so we only need to check up
     through the DC00 page.  If this is not a ps/2, the range
     F000-EFFF is ROM so we only need to check up through page EC00 */


  if (wBusType == 3)         /* Is this a PS/2? (MCA) */
    {
      END_SEGMENT = 0xDC00;
      pRomMap->wRomBiosLoc[0]   = 0xE000;
      pRomMap->dwRomBiosSize[0] = 0x10000;
      pRomMap->wRomBiosLoc[1]   = 0xF000;
      pRomMap->dwRomBiosSize[1] = 0x10000;
    }
  else
    {
      pRomMap->wRomBiosLoc[0]   = 0xF000;
      pRomMap->dwRomBiosSize[0] = 0x10000;
      pRomMap->wRomBiosLoc[1]   = 0;
      pRomMap->dwRomBiosSize[1] = 0;
    }


  /* Set the indexes for the memory search to point to just past
     the conventional memory limit, first column */

  /* Begin stepping through memory, forcing uSegment to start on
     a true "visual memory map" line number */
  uSegment = 0xA000;

  /* Make iMapSegment start on the appropriate line */
  iMapSegment = uSegment / 1024;
  iMapOffset  = 0;

  iValidRom   = iFalse;

  for (; uSegment <= END_SEGMENT; uSegment += SEGMENT_INC)
    {
      for (uOffset = START_OFFSET; uOffset < ENDING_OFFSET;
           uOffset += OFFSET_INC)
        {
          /* Check the value of iValidRom. If it is non-zero, we are in  */
          /*   an Option ROM and iValidRom is the number of 1K blocks    */
          /*   that we still have to mark as being ROM. Mark the current */
          /*   1K block as being ROM and then decrement iValidRom by 1.  */
          /*   If iValidRom is zero, we are not currently inside an      */
          /*   Option ROM area.                                          */

          if (iValidRom)
            {
              iValidRom--;
            }
          else /* Not currently in an Option ROM */
            {
              /* Attempt to determine what is at address uSegment:uOffset.
                 First check for an Option ROM with a valid signature */

              iValidRom = OptionRomCheck (uSegment, uOffset);

              if (iValidRom)
                {
                  /* An Option ROM with a signature was detected with a
                     length of iValidRom */

                  if (wOptIndex < 10)
                    {
                      pRomMap->wOptRomLoc[wOptIndex]   = uSegment +
                                                         (uOffset >> 4);
                      pRomMap->dwOptRomSize[wOptIndex] = (DWORD) iValidRom *
                                                         1024L;
                      ++wOptIndex;
                    }

                  iValidRom--;
                }
            }

          /* Set the index for the memory map array to point to the
             next column, same row */

          iMapOffset++;
        }

      /* Set the indexes for the memory map array to point to the
         next row, first column of the array */

      iMapSegment++;
      iMapOffset = 0;
    }

  return;
}

/************************************************************************
*
* Function Get_VisualMemMap()
*
* This function generates a visual memory map of the address range
* 0000 to EFFF. It attempts to detect RAM, ROM and WOM (nothing).
*
* Mem_Info_St Fields Set
* ----------------------
*
* auchMemoryMap = The array holding the characters used to display the
*                 map.
*
*
* Local Variables Used
* --------------------
*
* iMapSegment, iMapOffset : Used to keep track of the location in the
*                         : array holding the memory map.
* iRow, iCol              : Used to point to a specific location in the
*                         : array holding the memory map.
* iMemLimit               : RAM and WOM extends up to the limit set
*                         : by this variable
* uSegment, uOffset       : The current segment:offset being looked at.
* uiPageFrameAddress      : The address of EMS page frame.
* Ram, Rom, Wom
* NotCertain              : Used when building the memory map.
* iFalse, iTrue           : Used for Boolean checking.
* iValidRom               : Used to figure out if we are currently in a
*                         : ROM area which had a valid signature byte.
* END_SEGMENT             : The final segment to check through.
*
************************************************************************/

int Get_VisualMemMap (MEMORY_STRUCT FAR * pMem_Info, WORD wBusType)

{
  int  iMapSegment, iMapOffset;
  int  iRow, iCol;
  int  iMemLimit;

  unsigned uSegment;
  unsigned uOffset;
  unsigned char Ram, Rom, Wom, NotCertain;
  int iValidRom;
  int iFalse = 0;
  int iTrue = 1;
  unsigned END_SEGMENT = 0xEC00;


  /* Check if we are on a ps/2 or not. If this is a ps/2, the
     range E000-EFFF is system ROM so we only need to check up
     through the DC00 page.  If this is not a ps/2, the range
     F000-EFFF is ROM so we only need to check up through page EC00 */


  if (wBusType == 3)         /* Is this a PS/2? (MCA) */
    END_SEGMENT = 0xDC00;


  /* Define the characters to be used to display the map. Check
     fpOutfile to determine if this map is going to the screen
     or to a printer */


  /* Going to the screen, use extended chars */
  if (fReportFlag == FALSE)
    {
      Ram = DISPLAY_RAM;
      Rom = DISPLAY_ROM;
      Wom = DISPLAY_WOM;
      NotCertain = DISPLAY_NOT_CERTAIN;
    }
  else /* Going to a report. Use standard ASCII */
    {
      Ram = REPORT_RAM;
      Rom = REPORT_ROM;
      Wom = REPORT_WOM;
      NotCertain = REPORT_NOT_CERTAIN;
    }

  /* Special case for black and white screen display */
  if (fBlackWhite == TRUE && fReportFlag == FALSE)
    {
      Rom = REPORT_ROM;
    }



  /* Initialize the map to RAM values in conventional RAM area  */
  /* to RAM, the area up to the ROM BIOS as empty, and the ROM  */
  /* BIOS as ROM.  Also, tack an ending null char in the last   */
  /* column of each row so that winWrtStrnAttrib can be used    */
  /* when moving the segment selection bar in the memory browse */
  /* stuff.                                                     */

  /* Fill up the "conventional RAM" in the visual memory map. */
  /*   RAM is assumed to be installed in 16k incriments.      */

  /* Set the maximum line number (ie, limit) to fill with RAM */
  iMemLimit = (int) (pMem_Info->lConv_Mem / (16384L));

  for (iRow = 0; iRow < iMemLimit; iRow++)
    {
      for (iCol = 0; iCol < (NUM_OF_COLS-1); iCol++)
        pMem_Info->abMemoryMap [iRow][iCol] = Ram;
      pMem_Info->abMemoryMap [iRow][iCol] = 0;
    }

  /* Fill from past "conventional RAM" to the ROM BIOS with WOM */

  iMemLimit = (int) (END_SEGMENT / 1024);

  for (; iRow <= iMemLimit; ++iRow)
    {
      for (iCol = 0; iCol < (NUM_OF_COLS-1); iCol++)
        pMem_Info->abMemoryMap [iRow][iCol] = Wom;
      pMem_Info->abMemoryMap [iRow][iCol] = 0;
    }

  /* Fill the ROM BIOS area with ROM */

  for (; iRow < NUM_OF_ROWS; ++iRow)
    {
      for (iCol = 0; iCol < (NUM_OF_COLS-1); iCol++)
        pMem_Info->abMemoryMap [iRow][iCol] = Rom;
      pMem_Info->abMemoryMap [iRow][iCol] = 0;
    }


  /* Set the indexes for the memory map array to point to just past
     the conventional memory limit, first column */

  /* Begin stepping through memory, forcing uSegment to start on
     a true "visual memory map" line number */
  uSegment = (unsigned) (pMem_Info->lConv_Mem / 16L);
  uSegment = uSegment & 0xF800;

  /* Make iMapSegment start on the appropriate line */
  iMapSegment = uSegment / 1024;
  iMapOffset  = 0;

  iValidRom   = iFalse;

  for (; uSegment <= END_SEGMENT; uSegment += SEGMENT_INC)
    {
      for (uOffset = START_OFFSET; uOffset < ENDING_OFFSET;
           uOffset += OFFSET_INC)
        {
          /* Check the value of iValidRom. If it is non-zero, we are in  */
          /*   an Option ROM and iValidRom is the number of 1K blocks    */
          /*   that we still have to mark as being ROM. Mark the current */
          /*   1K block as being ROM and then decrement iValidRom by 1.  */
          /*   If iValidRom is zero, we are not currently inside an      */
          /*   Option ROM area.                                          */

          if (iValidRom)
            {
              pMem_Info->abMemoryMap [iMapSegment][iMapOffset] = Rom;
              iValidRom--;
            }
          else /* Not currently in an Option ROM */
            {
              /* Attempt to determine what is at address uSegment:uOffset.
                 First check for an Option ROM with a valid signature */

              iValidRom = OptionRomCheck (uSegment, uOffset);

              if (iValidRom)
                {
                  /* An Option ROM with a signature was detected with a
                     length of iValidRom */

                  pMem_Info->abMemoryMap [iMapSegment][iMapOffset] = Rom;
                  iValidRom--;
                }
              else /* Try to determine what is there */
                {
                  switch (RamRomWomCheck (uSegment, uOffset, OFFSET_INC, fWindowsRunning))
                    {
                      case 0:
                        pMem_Info->abMemoryMap [iMapSegment][iMapOffset] = Ram;
                        break;

                      case 1:
                        pMem_Info->abMemoryMap [iMapSegment][iMapOffset] = NotCertain;
                        break;

                      case 2:
                        pMem_Info->abMemoryMap [iMapSegment][iMapOffset] = Wom;
                        break;

                      default:
                        pMem_Info->abMemoryMap [iMapSegment][iMapOffset] = NotCertain;
                    }
                }
            }

          /* Set the index for the memory map array to point to the
             next column, same row */

          iMapOffset++;
        }

      /* Set the indexes for the memory map array to point to the
         next row, first column of the array */

      iMapSegment++;
      iMapOffset = 0;
    }

  return (0);
}


/*********************************************************************
 * VisualMapOverlay - Fills the Visual Memory Map's Overlay map.  EMS
 *                    page frames are marked 'E', used UMBs are marked
 *                    'U', and free UMBs are marked 'F'.  Also counts
 *                    up the used and free UMBs.
 *
 * pMem - Pointer to the memory information structure.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL VisualMapOverlay (MEMORY_STRUCT FAR * pMem)
{
  WORD wPageFrameAddress;     /* Segment of EMS Page frame              */
  int iRow, iCol;             /* Row and Column of visual map overlay   */
  int iNumOfChars;            /* Number of characters (or 1K blocks)    */
                              /*   necessary to fill the page fram area */
  TSR_PROGRAMS_STRUCT *pTsr = NULL; /* TSR Program list                 */
  WORD wSize;                 /* Size required to store TSR list        */
  WORD i;                     /* Looping variable                       */


  /* Check to see if an EMS page frame was detected and if we want to */
  /*   display it.  If one was and we do want to show it, fill in the */
  /*   correct area in the memory map with characters to specify the  */
  /*   page frame                                                     */

  wPageFrameAddress = pMem->iPageFrameAddress;

  if (wPageFrameAddress)
    {
      iNumOfChars = 64;
      iRow = wPageFrameAddress / SEGMENT_INC;
      iCol = (wPageFrameAddress - (iRow * SEGMENT_INC)) / (OFFSET_INC >> 4);

      FillMemMapOverlay (pMem, iRow, iCol, iNumOfChars, DISPLAY_EMS);
    }


  /* Now, obtain the Memory Control Block information, to locate the  */
  /*   Upper Memory Blocks.                                           */

  if (wDosMajor >= 5 && wDosMajor < 10)
    {
      /* Obtain the TSR list */
      wSize = GetInfoSize (IDI_TSR_PROGRAMS_RECORD, FALSE);
      if ((pTsr = malloc (wSize)) == NULL)
        {
          OutOfMemory();
          return (TRUE);
        }

      /* Zero out the structure */
      memset (pTsr, '\0', wSize);

      if (GetInfo (IDI_TSR_PROGRAMS_RECORD, pTsr, FALSE, FALSE, FALSE))
        return (TRUE);


      /* Find the first upper memory block, if it exists */
      for (i = 1;
           pTsr[i].wAddress != 0 &&
           pTsr[i].wAddress + (pTsr[i].dwBlockSize >> 4) < 0xA000;
           ++i)
        ;


      /* Set the flag for UMBs available */
      if (pTsr[i].wAddress + (pTsr[i].dwBlockSize >> 4) >= 0xA000)
        pMem->fUmbsAvailable = TRUE;


      /* Begin walking the UMBs */
      for (; pTsr[i].wAddress != 0; ++i)
        {
          CHAR chFillChar;  /* Character to fill the visual map with */

          /* Skip the excluded UMB areas */
          if (strcmp (pTsr[i].szTsrName, pszExcludedUmbArea) == 0)
            continue;


          /* Free areas use 'F', used areas use 'U' */
          if (strcmp (pTsr[i].szTsrName, pszFreeMemory) == 0)
            {
              chFillChar = DISPLAY_FREE_UMB;

              /* Add up the UMB area, if it counts */
              if (pTsr[i].szTsrName[0] != ' ')
                {
                  pMem->dwTotalUmbs += pTsr[i].dwBlockSize;
                  pMem->dwFreeUmbs  += pTsr[i].dwBlockSize;

                  if (pTsr[i].dwBlockSize > pMem->dwLargestFreeUmb)
                    pMem->dwLargestFreeUmb = pTsr[i].dwBlockSize;
                }
            }
          else
            {
              chFillChar = DISPLAY_USED_UMB;

              /* Add up the UMB area, if it counts */
              if (pTsr[i].szTsrName[0] != ' ')
                pMem->dwTotalUmbs += pTsr[i].dwBlockSize;
            }


          /* Fill the region with the correct value */
          iRow        = pTsr[i].wAddress / 0x400;
          iCol        = (pTsr[i].wAddress % 0x400) / 0x40;
          iNumOfChars = (WORD) ((pTsr[i].dwBlockSize + 1023) / 1024);
          FillMemMapOverlay (pMem, iRow, iCol, iNumOfChars, chFillChar);
        }


      /* Free up the TSR structure */
      free (pTsr);
    }

}

/************************************************************************
*
* Function FillMemMap()
*
* This function fills in a specified portion of the memory map array with
* a specific value.
*
*
* Mem_Info_St Fields Set
* ----------------------
*
* abMemoryMap = The array of unsigned characters which holds the values
*               used to display the memory map.
*
*
* Local Variables Used
* --------------------
*
* index       : An integer used to keep track of how many fill chars
*               have been written to the memory map array.
* iRow, iCol  : Integers used to index into the memory map array.
* iNumOfChars : The number of fill characters to write to the map array.
* uchFillChar : The fill character to be written to the map array.
*
************************************************************************/

int FillMemMap (MEMORY_STRUCT FAR * pMem, int iRow, int iCol,
                   int iNumOfChars, unsigned char uchFillChar)

{
  int index = 0;

  while (index < iNumOfChars)
  {
    pMem->abMemoryMap [iRow][iCol] = uchFillChar;
    iCol++;

    if (iCol == NUM_OF_COLS - 1) /* Use (NUM_OF_COLS - 1) so we don't   */
    {                            /*   step on the null char used when   */
      iCol = 0;                  /*   displaying the map on the screen. */
      iRow++;
    }

    index++;
  }

  return (0);
}

/************************************************************************
*
* Function FillMemMapOverlay()
*
* This function fills in a specified portion of the memory map overlay
* array witha specific value.
*
*
* Mem_Info_St Fields Set
* ----------------------
*
* abMemMapOverlay = The array of unsigned characters which holds the
*                   values used to display the memory map.
*
*
* Local Variables Used
* --------------------
*
* index       : An integer used to keep track of how many fill chars
*               have been written to the memory map array.
* iRow, iCol  : Integers used to index into the memory map array.
* iNumOfChars : The number of fill characters to write to the map array.
* uchFillChar : The fill character to be written to the map array.
*
************************************************************************/

int FillMemMapOverlay (MEMORY_STRUCT FAR * pMem, int iRow, int iCol,
                       int iNumOfChars, unsigned char uchFillChar)

{
  int index = 0;

  while (index < iNumOfChars)
  {
    pMem->abMemMapOverlay [iRow][iCol] = uchFillChar;
    iCol++;

    if (iCol == NUM_OF_COLS - 1) /* Use (NUM_OF_COLS - 1) so we don't   */
    {                            /*   step on the null char used when   */
      iCol = 0;                  /*   displaying the map on the screen. */
      iRow++;
    }

    index++;
  }

  return (0);
}

/**************************************************************************
 * RamRomWomCheck - Checks if the memory pointed to by uSegment:uOffset
 *                  is RAM, ROM, or Available (WOM).
 *
 *                  RAM can change.
 *                  WOM is unchangable and has FFH's through the entire
 *                      range.
 *                  ROM is unchangable and is not FFH through the entire
 *                      range.
 *
 * uSegment - Segment to search
 *
 * uOffset  - Offset to search
 *
 * uLength  - Length of search to perform when checking for ROM/WOM
 *
 * fWindowsRunning - If windows is running, disable the RAM test.
 *
 * Returns RAM (0), ROM (1), or WOM (2).
 **************************************************************************/

int _fastcall RamRomWomCheck (unsigned uSegment,
                              unsigned uOffset,
                              unsigned uLength,
                              BOOL     fWindowsRunning)
{
  UCHAR uchHoldByte;            /* Used for storing byte during RAM check */
  int   iReturnValue;           /* Value this routine returns */

  _asm
    {
      push  es                  ;Save the ES register

      push  ax                  ;Put uSegment into ES
      pop   es
      mov   di,dx               ;Put uOffset into DI
      mov   cx,bx               ;Put uLength into CX

      mov   al,es:[di]          ;Store byte in holding area
      mov   [uchHoldByte],al

      cmp   fWindowsRunning, 0  ;Is it safe to perform the RAM test?
      jne   SkipRamTest         ;Skip out if not.

      xor   al,0xFF             ;Toggle all bits in AL

      cli                       ;Clear interrupts for RAM check

      mov   es:[di],al          ;Put new value back in memory

      mov   al,[uchHoldByte]    ;Put the original value back in AL
                                ;  There is logic behind checking the
                                ;  original value instead of the changed
                                ;  value.  Suppose the adapter card at
                                ;  this address does not support all 8
                                ;  bits.  Checking for the changed value
                                ;  would return false, even though seven
                                ;  bits were changed.  (One possibility
                                ;  for the missing bit or bits would be
                                ;  special purpose RAM).

      push  cx                  ;Wait for a moment, to allow memory to
      mov   cx,0x10             ;  stabilize

    Wait001:
      loop  Wait001
      pop   cx

      cmp   al,es:[di]          ;Check to see if it is the original value
      jne   ThisMayBeRAM        ;If not, this might be RAM

    ;---- Now check for the difference between ROM and WOM ----

    SkipRamTest:
      cmp   al,0xFF             ;Was the byte 0FFH?
      jne   ThisIsROM           ;If not, this is definitely ROM

    ;---- This could be WOM.  Check for a bunch of FFHs ----

      repe  scasb               ;Search for the first non 0FFH

      cmp   cx,0                ;Did we get to the end without a non-0FFH?
      jne   ThisIsROM           ;If not, this is ROM

    ;---- WOM was detected, set the return value ----

      mov   iReturnValue,WOM    ;Set the return value
      jmp   MemCheckComplete    ;Exit this routine

    ;---- RAM may have been detected ----

    ThisMayBeRAM:

      mov   bl,es:[di]          ;Now check to see if it is the changed value.
      xor   bl,0xFF             ;  The value may be bus noise or some other
                                ;  unusual case (WYSE 286 w/ 640k).  If it
                                ;  doesn't match the changed value, it is
                                ;  not RAM.

      cmp   al,bl               ;Does it match the changed value
      jne   ThisIsNotRAM        ;If not, this is something else

    ;---- RAM really was detected ----

      mov   al,uchHoldByte      ;Restore the original byte
      mov   es:[di],al

      mov   iReturnValue,RAM    ;Set the return value
      jmp   MemCheckComplete    ;Exit this routine

    ;---- ROM was detected, set the return value ----

    ThisIsROM:

      mov   iReturnValue,ROM    ;Set the return value
      jmp   MemCheckComplete    ;Exit this routine

    ;---- It's not RAM, it's not ROM, it's not WOM, it's something else ----

    ThisIsNotRAM:

      mov   iReturnValue,ROM    ;We'll call it available for now
      jmp   MemCheckComplete    ;Exit this routine

    ;---- Test is completed, return to calling routine ----

    MemCheckComplete:

      sti                       ;Restore interrupts
      pop   es                  ;Restore the original ES register
    }

  return (iReturnValue);
}

/**************************************************************************
 * OptionRomCheck - Checks for the presence of installed Option ROM cards
 *                  (ie, EGA/VGA, Net cards with ROMs, etc).
 *
 *                  Option ROM cards are installed in the range of C000
 *                    (A000?) - EFFF for non-PS/2 computers.  PS/2s use
 *                    E000-FFFF, so option cards can only be installed
 *                    between C000 - DFFF.
 *
 *                  According to the limited documentation we've found,
 *                    (Specifically a Windows 3.00 assembly language
 *                    include file), all Option ROMs in the valid range
 *                    start with the bytes AAH, 55H, followed by a byte
 *                    that tells the length of the ROM card / 512:
 *
 *                    +----------------------+
 *                    |         AAH          |
 *                    +----------------------+
 *                    |         55H          |
 *                    +----------------------+
 *                    | Byte: ROM Size / 512 |
 *                    +----------------------+
 *                    |/ / / / / / / / / / / |
 *                    | /-Option ROM code-/  |
 *                    |/ / / / / / / / / / / |
 *                    +----------------------+
 *                    (Sum of all bytes MOD 100H is 00H).
 *
 *                  I add up all the bytes starting from th AAH into BL,
 *                    allowing BL to overflow (an 8 bit checksum sort
 *                    of arrangement).  If the value is 00H, this was
 *                    a valid option card.  If not, I stumbled across
 *                    a spurious 55 AA in memory.
 *
 * uSegment - Segment to search.
 *
 * uOffset  - Offset to search.
 *
 * Returns: Number of 1K pages for the Option ROM starting at the
 *          specified location, or 0 if no Option ROM was found.
 **************************************************************************/

int _fastcall OptionRomCheck (unsigned uSegment, unsigned uOffset)
{
  int   iReturnValue;           /* Value this routine returns */

  _asm
    {
                                ;uSegment is in AX
                                ;uOffset  is in DX

      push  es                  ;Save the ES register

    ;---- Adjust Segment so Offset can be :0000 ----

      mov   cl,4                ;Shift uOffset 4 bits
      shr   dx,cl
      add   ax,dx               ;Add to uSegment

      push  ax                  ;Put uSegment into ES
      pop   es
      xor   di,di               ;Put zero into DI

    ;---- Check for ROM signature ----

      cmp   es:[di],0xAA55      ;Is the ROM signature present?
      jne   NotOptionRom        ;If not, jump out.

    ;---- ROM signature detected, Set return value in case it's valid ----

      xor   cx,cx               ;Zero out CX register
      mov   cl,es:[di + 2]      ;Load the number of bytes / 512
      test  cl,0x01             ;Is it an odd value?
      jz    SetReturnValue      ;If not, set return value
      inc   cx                  ;If odd, increase CX to even 1K boundry

    SetReturnValue:
      shr   cx,1                ;Divide by 2 to obtain Option ROM size in K
      mov   iReturnValue,cx     ;Set the return value, in case this is
                                ;  a value Option ROM.

    ;---- Prepare for checksum on Option ROM ----

      xor   cx,cx               ;Zero out CX register

;     inc   di                  ;Bump DI three bytes to move around the
;     inc   di                  ;  ROM signature
;                               ;Load the number of bytes in the Option ROM
;                               ;  into CX

      mov   ch,es:[di + 2]      ;CL = byte count / 512 (CX = byte count / 2)
      shl   cx,1                ;CX now = number of bytes

      xor   al,al               ;Zero out the checksum register

    ;---- Perform checksum ----

    CkSumLoop:

      add   al,es:[di]          ;Add byte to AL (overflow is expected)
      inc   di                  ;Bump DI to point to next byte
      loop  CkSumLoop           ;Loop until all bytes have been read

    ;---- Checksum is complete, AL = 0 means this is a valid Option ROM ----

      cmp   al,0                ;Is the checksum zero?
      je    OptionCheckComplete ;If so, the return value has already been
                                ;  set, so we jump out of the routine

                                ;If not, fall through...

    ;---- ROM Signature not Detected ----

    NotOptionRom:

      mov   iReturnValue,0      ;Set the return value to zero.
      jmp   OptionCheckComplete ;Exit this routine

    ;---- Test is completed, return to calling routine ----

    OptionCheckComplete:

      pop   es                  ;Restore the original ES register
    }

  return (iReturnValue);
}


/*********************************************************************
 * SprintMemInfo - Put Memory information into a set of strings to be
 *                 printed or displayed.
 *
 * fMemoryType  - Type(s) of memory to put into strings (MEM_ALL to
 *                show all types of memory).
 * pMem         - Pointer to the structure describing the memory
 *                types.
 * szSumStrings - Summary information string holder.
 *
 * Returns:  NULL if an error occured, or if summary information is
 *           requested.
 *********************************************************************/

QSZ * SprintMemInfo (BOOL fMemoryType,
                     MEMORY_STRUCT *pMem,
                     CHAR szSumStrings[][MAX_SUMM_INFO + 5],
                     BOOL fOverlayFlag)
{
  WORD wNmbrStrings;        /* Number of strings                     */
  WORD wNmbrChars;          /* Number of characters in the strings   */
  WORD i;                   /* Index variable                        */
  CHAR chBuffer[120];       /* Local string                          */
  QSZ  *pqszStrings;        /* Location for storing string pointers  */
  WORD wAlignColumn;        /* Column to align titles                */


  /* Summary strings */
  if (szSumStrings != NULL)
    {
      i = 0;

      /* Conventional */
      sprintf (chBuffer, "%ldK", pMem->lConv_Mem / 1024L);
      strncpy (szSumStrings[i], chBuffer, MAX_SUMM_INFO + 3);

      /* Extended */
      if (pMem->iCMOSExtended)
        {
          strncat (szSumStrings[i], pszCommaSpace,
                   MAX_SUMM_INFO + 3 - strlen (szSumStrings[i]));

	  sprintf (chBuffer, "%uK ", (unsigned int)pMem->iCMOSExtended);
          strcat (chBuffer, "Ext");

          if (strlen (chBuffer) + strlen (szSumStrings[i]) > MAX_SUMM_INFO + 3)
            {
              i = 1;
              szSumStrings[i][0] = '\0';
            }

          strncat (szSumStrings[i], chBuffer,
                   MAX_SUMM_INFO + 3 - strlen (szSumStrings[i]));
        }

      /* EMS */
      if (pMem->iTotal_Emm_Pages)
        {
          strncat (szSumStrings[i], pszCommaSpace,
                   MAX_SUMM_INFO + 3 - strlen (szSumStrings[i]));

	  sprintf (chBuffer, "%uK ", (unsigned int)pMem->iTotal_Emm_Pages * 16);
          strcat (chBuffer, "EMS");

          if (strlen (chBuffer) + strlen (szSumStrings[i]) > MAX_SUMM_INFO + 3)
            {
              i = 1;
              szSumStrings[i][0] = '\0';
            }

          strncat (szSumStrings[i], chBuffer,
                   MAX_SUMM_INFO + 3 - strlen (szSumStrings[i]));
        }

      /* XMS */
      if (pMem->iXmm_Free_Err == 0 && pMem->iTotal_Free_Xm != 0)
        {
          strncat (szSumStrings[i], pszCommaSpace,
                   MAX_SUMM_INFO + 3 - strlen (szSumStrings[i]));

	  sprintf (chBuffer, "%uK ", (unsigned int)pMem->iTotal_Free_Xm);
          strcat (chBuffer, "XMS");

          if (strlen (chBuffer) + strlen (szSumStrings[i]) > MAX_SUMM_INFO + 3)
            {
              i = 1;
              szSumStrings[i][0] = '\0';
            }

          strncat (szSumStrings[i], chBuffer,
                   MAX_SUMM_INFO + 3 - strlen (szSumStrings[i]));
        }

      return (NULL);
    }


  /* Overestimate the amount of space required for the strings */

  switch (fMemoryType)
    {
      case MEM_ALL:
        wAlignColumn = MEM_MAX_ALIGN;
        wNmbrStrings = MEM_CONV_STRINGS + MEM_EXT_STRINGS  +
                       MEM_EMS_STRINGS  + MEM_XMS_STRINGS  +
                       MEM_VCPI_STRINGS + MEM_DPMI_STRINGS +
                       MEM_LEGEND_STRINGS;
        if (wNmbrStrings < MEM_640K_LIMIT)
          wNmbrStrings = MEM_640K_LIMIT;
        wNmbrChars   = 2450;  /* Beyond the maximum chars required */
        break;

      case MEM_SUMMARY:
        wAlignColumn =  0;
        wNmbrStrings =  1;
        wNmbrChars   = REPORT_WIDTH + 1;
        break;

      case MEM_CONVENTIONAL:
        wAlignColumn = MEM_CONV_ALIGN;
        wNmbrStrings = MEM_CONV_STRINGS;
        wNmbrChars   = MEM_CONV_STRINGS * REPORT_WIDTH + 1;
        break;

      case MEM_EXTENDED:
        wAlignColumn = MEM_EXT_ALIGN;
        wNmbrStrings = MEM_EXT_STRINGS;
        wNmbrChars   = MEM_EXT_STRINGS * REPORT_WIDTH + 1;
        break;

      case MEM_EMS:
        wAlignColumn = MEM_EMS_ALIGN;
        wNmbrStrings = MEM_EMS_STRINGS;
        wNmbrChars   = MEM_EMS_STRINGS * REPORT_WIDTH + 1;
        break;

      case MEM_XMS:
        wAlignColumn = MEM_XMS_ALIGN;
        wNmbrStrings = MEM_XMS_STRINGS;
        wNmbrChars   = MEM_XMS_STRINGS * REPORT_WIDTH + 1;
        break;

      case MEM_VCPI:
        wAlignColumn = MEM_VCPI_ALIGN;
        wNmbrStrings = MEM_VCPI_STRINGS;
        wNmbrChars   = MEM_VCPI_STRINGS * REPORT_WIDTH + 1;
        break;

      case MEM_DPMI:
        wAlignColumn = MEM_DPMI_ALIGN;
        wNmbrStrings = MEM_DPMI_STRINGS;
        wNmbrChars   = MEM_DPMI_STRINGS * REPORT_WIDTH + 1;
        break;

      case MEM_VISUAL_MAP:
        wAlignColumn = 12;
        wNmbrStrings = 65;
        wNmbrChars   = wNmbrStrings * 40;
        break;


      default:
        wAlignColumn =  0;
        wNmbrStrings =  1;
        wNmbrChars   = REPORT_WIDTH + 1;
    }


  /* Allocate space for the pointer area and string area */
  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);


  /* Put the information in place */

  i = 0;

  /* Summary Information */

  if (fMemoryType == MEM_SUMMARY)
    {
      return (NULL);
    }


  /* Include the memory legend */

  if (fReportFlag)
    {
      sprintf (chBuffer, "Legend:  Available \"%c%c\"  RAM \"%c%c\"  ROM \"%c%c\"  Possibly Available \"%c%c\"",
               REPORT_WOM, REPORT_WOM,
               REPORT_RAM, REPORT_RAM,
               REPORT_ROM, REPORT_ROM,
               REPORT_NOT_CERTAIN, REPORT_NOT_CERTAIN);
      Qstrcpy (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);

      sprintf (chBuffer, "  EMS Page Frame \"%c%c\"",
               REPORT_EMS, REPORT_EMS);
      Qstrcpy (pqszStrings[i], chBuffer);

      if (wDosMajor >= 5 && wDosMajor < 10)
        {
          sprintf (chBuffer, "  Used UMBs \"%c%c\"  Free UMBs \"%c%c\"",
                   REPORT_USED_UMB, REPORT_USED_UMB,
                   REPORT_FREE_UMB, REPORT_FREE_UMB);
          Qstrcat (pqszStrings[i], chBuffer);
        }

      if (pMem->fXmsUmbAvailable)
        {
          sprintf (chBuffer, "  Free XMS UMBs \"%c%c\"",
                   REPORT_FREE_XMS_UMB, REPORT_FREE_XMS_UMB);
          Qstrcat (pqszStrings[i], chBuffer);
        }

      PrepNextString (pqszStrings, i++);
    }
  else
    {
      sprintf (chBuffer, "Legend:  Available \"&1%c%c&0\"  RAM \"&1%c%c&0\"  ROM \"&1%c%c&0\"  Possibly Available \"&1%c%c&0\"",
               DISPLAY_WOM, DISPLAY_WOM,
               DISPLAY_RAM, DISPLAY_RAM,
               (fBlackWhite) ? REPORT_ROM : DISPLAY_ROM,
               (fBlackWhite) ? REPORT_ROM : DISPLAY_ROM,
               DISPLAY_NOT_CERTAIN, DISPLAY_NOT_CERTAIN);
      Qstrcpy (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);

      sprintf (chBuffer, "  EMS Page Frame \"&1%c%c&0\"",
               DISPLAY_EMS, DISPLAY_EMS);
      Qstrcpy (pqszStrings[i], chBuffer);

      if (wDosMajor >= 5 && wDosMajor < 10)
        {
          sprintf (chBuffer, "  Used UMBs \"&1%c%c&0\"  Free UMBs \"&1%c%c&0\"",
                   DISPLAY_USED_UMB, DISPLAY_USED_UMB,
                   DISPLAY_FREE_UMB, DISPLAY_FREE_UMB);
          Qstrcat (pqszStrings[i], chBuffer);
        }

      if (pMem->fXmsUmbAvailable)
        {
          sprintf (chBuffer, "  Free XMS UMBs \"&1%c%c&0\"",
                   DISPLAY_FREE_XMS_UMB, DISPLAY_FREE_XMS_UMB);
          Qstrcat (pqszStrings[i], chBuffer);
        }

      PrepNextString (pqszStrings, i++);
    }


  /* Conventional memory */

  if (fMemoryType == MEM_CONVENTIONAL || fMemoryType == MEM_ALL)
    {
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Conventional Titles */
      Qstrcat (pqszStrings[i], paszMemoryTitles[MT_CONV_TITLE]);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Total Conventional Memory */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_CONV_TOTAL],
                   wAlignColumn);
      sprintf (chBuffer, "%ldK", pMem->lConv_Mem / 1024L);
      Qstrcat (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Available Conventional Memory, Line 1 */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_CONV_AVAIL],
                   wAlignColumn);
      sprintf (chBuffer, "%ldK", pMem->lFree_Conv_Mem / 1024L);
      Qstrcat (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Available Conventional Memory, Line 2 */
      QstrcatAlign (pqszStrings[i], pszNull, wAlignColumn);
      sprintf (chBuffer, "%ld bytes", pMem->lFree_Conv_Mem);
      Qstrcat (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Separator when sprinting all types of memory */
      if (fMemoryType == MEM_ALL)
        {
          PrepNextString (pqszStrings, i++);
          CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);
        }
    }


  /* Extended memory */

  if (fMemoryType == MEM_EXTENDED || fMemoryType == MEM_ALL)
    {
      /* Extended Titles */
      Qstrcat (pqszStrings[i], paszMemoryTitles[MT_EXT_TITLE]);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Total Extended Memory */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_CONV_TOTAL],
                   wAlignColumn);
      sprintf (chBuffer, "%uK", (unsigned int)pMem->iCMOSExtended);
      Qstrcat (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Separator when sprinting all types of memory */
      if (fMemoryType == MEM_ALL)
        {
          PrepNextString (pqszStrings, i++);
          CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);
        }
    }


  /* UMB Information */

  if (pMem->fUmbsAvailable &&
      (fMemoryType == MEM_CONVENTIONAL || fMemoryType == MEM_ALL))
    {
      /* UMB Titles */
      Qstrcat (pqszStrings[i], paszMemoryTitles[MT_UMB_TITLE]);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Total UMBs */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_UMB_TOTAL],
                   wAlignColumn);
      sprintf (chBuffer, "%luK", pMem->dwTotalUmbs / 1024L);
      Qstrcat (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Total Free UMBs */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_UMB_TOTAL_FREE],
                   wAlignColumn);
      sprintf (chBuffer, "%luK", pMem->dwFreeUmbs / 1024L);
      Qstrcat (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Largest Free UMBs */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_UMB_LARGEST_FREE],
                   wAlignColumn);
      sprintf (chBuffer, "%luK", pMem->dwLargestFreeUmb / 1024L);
      Qstrcat (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Separator when sprinting all types of memory */
      if (fMemoryType == MEM_ALL)
        {
          PrepNextString (pqszStrings, i++);
          CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);
        }
    }


  /* EMS Information */

  if (fMemoryType  == MEM_EMS ||
      (fMemoryType == MEM_ALL && pMem->iEmm_Is_There))
    {
      /* EMS Titles */
      Qstrcat (pqszStrings[i], paszMemoryTitles[MT_EMS_TITLE]);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* EMS Version */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_EMS_VERSION],
                   wAlignColumn);
      sprintf (chBuffer, "%d.%02d",
               pMem->iEmm_VersionMajor,
               pMem->iEmm_VersionMinor);
      Qstrcat (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* EMS Page Frame */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_EMS_PAGE_FRAME],
                   wAlignColumn);
      if (pMem->iPageFrameAddress)
        {
          sprintf (chBuffer, "%04XH", pMem->iPageFrameAddress);
          Qstrcat (pqszStrings[i], chBuffer);
        }
      else
        Qstrcat (pqszStrings[i], pszNoPageFrame);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Total EMS */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_EMS_TOTAL],
                   wAlignColumn);
      sprintf (chBuffer, "%uK", (unsigned int)pMem->iTotal_Emm_Pages * 16);
      Qstrcat (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Available EMS */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_EMS_AVAIL],
                   wAlignColumn);
      sprintf (chBuffer, "%dK", pMem->iFree_Emm_Pages * 16);
      Qstrcat (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Separator when sprinting all types of memory */
      if (fMemoryType == MEM_ALL)
        {
          PrepNextString (pqszStrings, i++);
          CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);
        }
    }


  /* XMS Information */

  if (fMemoryType  == MEM_XMS ||
      (fMemoryType == MEM_ALL && pMem->iXmm_Is_There))
    {
      /* XMS Titles */
      Qstrcat (pqszStrings[i], paszMemoryTitles[MT_XMS_TITLE]);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* XMS Version */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_XMS_VERSION],
                   wAlignColumn);
      sprintf (chBuffer, "%x.%02x",
               pMem->uchXmm_Spec_VersionMajor,
               pMem->uchXmm_Spec_VersionMinor);
      Qstrcat (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* XMS Driver Version */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_XMS_DRIVER_VER],
                   wAlignColumn);
      sprintf (chBuffer, "%x.%02x",
               pMem->uchXmm_Driver_VersionMajor,
               pMem->uchXmm_Driver_VersionMinor);
      Qstrcat (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* A20 Line */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_XMS_A20_LINE],
                   wAlignColumn);
      if (pMem->iA20Status)
        Qstrcat (pqszStrings[i], pszEnabled);
      else
        Qstrcat (pqszStrings[i], pszNotEnabled);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* High Memory Area */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_XMS_HMA],
                   wAlignColumn);
      if (pMem->iXmm_Is_There) /* There is an XMS driver present */
        {
          switch (pMem->iXMSError) /* Check the status of any error codes */
            {                             /* returned when querying the XMS driver */
              case 0:
              case 6: Qstrcat (pqszStrings[i], "Available");
                      break;              /* Case 6 also means there was a problem releasing the HMA */
              case 1: Qstrcat (pqszStrings[i], "Request failed");
                      break;
              case 2: Qstrcat (pqszStrings[i], "VDISK detected");
                      break;
              case 3: Qstrcat (pqszStrings[i], "Not present");
                      break;
              case 4: Qstrcat (pqszStrings[i], "In use");
                      break;
              default: ;
            }
        }
      else
        Qstrcat (pqszStrings[i], "Not available"); /* An XMS driver is not present */
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Available XMS */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_XMS_AVAIL],
                   wAlignColumn);
      if (pMem->iXmm_Free_Err)
        Qstrcat (pqszStrings[i], pszError);
      else
        {
	  sprintf(chBuffer, "%uK", (unsigned int)pMem->iTotal_Free_Xm);
          Qstrcat (pqszStrings[i], chBuffer);
        }
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Largest Available XMS */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_XMS_LARGEST_AVAIL],
                   wAlignColumn);
      if (pMem->iXmm_Free_Err == 0)
        {
	  sprintf(chBuffer, "%uK", (unsigned int)pMem->iLargest_Free_Xm);
          Qstrcat (pqszStrings[i], chBuffer);
          PrepNextString (pqszStrings, i++);
          CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);
        }
      else
        Qstrcat (pqszStrings[i], pszError);


      /* Super Extended Memory */
      if (pMem->fSxmsAvailable)
        {
          /* Available SXMS */
          QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_SXMS_AVAIL],
                       wAlignColumn);

          sprintf(chBuffer, "%luK", pMem->dwSxmsTotalFree);
          Qstrcat (pqszStrings[i], chBuffer);
          PrepNextString (pqszStrings, i++);
          CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);


          /* Largest Free SXMS */
          QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_SXMS_LARGEST_AVAIL],
                       wAlignColumn);

          sprintf(chBuffer, "%luK", pMem->dwSxmsLargestFree);
          Qstrcat (pqszStrings[i], chBuffer);
          PrepNextString (pqszStrings, i++);
          CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);
        }


      if (pMem->fXmsUmbAvailable)
        {
          /* Largest Available XMS UMB */
          QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_XMS_TOTAL_UMB_AVAIL],
                       wAlignColumn);

          sprintf(chBuffer, "%luK", pMem->dwXmsUmbFree / 1024L);
          Qstrcat (pqszStrings[i], chBuffer);
          PrepNextString (pqszStrings, i++);
          CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

          /* Largest Available XMS UMB */
          QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_XMS_LARGEST_UMB_AVAIL],
                       wAlignColumn);

          sprintf(chBuffer, "%luK", pMem->dwXmsUmbLargestFree / 1024L);
          Qstrcat (pqszStrings[i], chBuffer);
          PrepNextString (pqszStrings, i++);
          CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);
        }


      /* Separator when sprinting all types of memory */
      if (fMemoryType == MEM_ALL)
        {
          PrepNextString (pqszStrings, i++);
          CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);
        }
    }


  /* VCPI Information */

  if (fMemoryType  == MEM_VCPI ||
      (fMemoryType == MEM_ALL && pMem->iVCPIPresent))
    {
      /* VCPI Titles */
      Qstrcat (pqszStrings[i], paszMemoryTitles[MT_VCPI_TITLE]);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* VCPI Detected */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_VCPI_DETECTED],
                   wAlignColumn);
      if (pMem->iVCPIPresent)
        Qstrcat (pqszStrings[i], pszYes);
      else
        Qstrcat (pqszStrings[i], pszNo);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* VCPI Version */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_VCPI_VERSION],
                   wAlignColumn);
      sprintf (chBuffer, "%d.%02d", pMem->iVCPIMajorVersion,
               pMem->iVCPIMinorVersion);
      Qstrcat (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* VCPI Available */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_VCPI_AVAIL],
                   wAlignColumn);
      sprintf (chBuffer, "%dK", pMem->iVCPIAvailMemory);
      Qstrcat (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* Separator when sprinting all types of memory */
      if (fMemoryType == MEM_ALL)
        {
          PrepNextString (pqszStrings, i++);
          CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);
        }
    }


  /* DPMI Information */

  if (fMemoryType  == MEM_DPMI ||
      (fMemoryType == MEM_ALL && pMem->iDPMIPresent))
    {
      /* DPMI Titles */
      Qstrcat (pqszStrings[i], paszMemoryTitles[MT_DPMI_TITLE]);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* DPMI Detected */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_DPMI_DETECTED],
                   wAlignColumn);
      if (pMem->iDPMIPresent)
        Qstrcat (pqszStrings[i], pszYes);
      else
        Qstrcat (pqszStrings[i], pszNo);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);

      /* DPMI Version */
      QstrcatAlign (pqszStrings[i], paszMemoryTitles[MT_DPMI_VERSION],
                   wAlignColumn);
      sprintf (chBuffer, "%d.%02d", pMem->iDPMIMajorVersion,
               pMem->iDPMIMinorVersion);
      Qstrcat (pqszStrings[i], chBuffer);
      PrepNextString (pqszStrings, i++);
      CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);
    }


  /* Add the lines for the visual memory map down to the A000 region */
  if (i - 2 < MEM_640K_LIMIT)
    {
      for (; i - 2 < MEM_640K_LIMIT;)
        {
          PrepNextString (pqszStrings, i++);
          CopyVisualMemMap (pMem, pqszStrings[i], i, fOverlayFlag);
        }
    }
  else
    {
      PrepNextString (pqszStrings, i++);
      pqszStrings[i][0] = '\0';
    }


  /* Look for the last nonblank line */
  {
    BOOL fDone = FALSE;   /* Flag for dropping out of the loop */

    while (fDone == FALSE)
      {
        /* Strip extra spaces */
        PrepNextString (pqszStrings, i);

        /* Check to see if this line is blank */
        if (pqszStrings[i][0] == '\0' && i > 1)
          --i;
        else
          fDone = TRUE;
      }
  }

  /* Set the last pointer to NULL */

  pqszStrings[i + 1] = NULL;

  /* Return the pointer to pqszStrings */

  return (pqszStrings);
}


/*********************************************************************
 * CopyVisualMemMap - Copy the visual memory map to the string array.
 *
 * pMem         - Pointer to memory structure which contains the
 *                visual memory map.
 * pszString    - String upon which to copy the current line of the
 *                visual memory map.
 * i            - Current line number of the memory display strings.
 * fOverlayFlag - Places the overlay data (EMS Page frame, etc) onto
 *                the visual memory map, if TRUE.
 *
 * No return value
 *********************************************************************/

VOID CopyVisualMemMap (MEMORY_STRUCT *pMem,
                       QSZ  qszString,
                       WORD i,
                       BOOL fOverlayFlag)
{
  INT  iMapIndex;     /* Index to the visual memory map */
  CHAR chBuffer[80];  /* Local sprintf buffer           */
  WORD u;             /* Looping variable               */

  /* Make sure the string is blank */
  qszString[0] = '\0';

  /* Calculate the appropriate line of the visual mem map */
  /*   for this line in the display strings.              */
  iMapIndex = (NUM_OF_ROWS - 1) - (i - 2);

  if (i + 1 < MEM_640K_LIMIT)
    {
      /* Display decimal equivilent of memory location */
      if (i == 2)
        Qstrcpy (qszString, "1024K ");
      else if (iMapIndex % 4 == 0)
        {
          sprintf (chBuffer, "%4uK ",
                 (WORD) ((DWORD) iMapIndex * (DWORD) 0x4000 / (DWORD) 1024));
          Qstrcpy (qszString, chBuffer);
        }
      else
        Qstrcpy (qszString, "      ");

      /* Display hexadecimal equivilent of memory location */
      sprintf (chBuffer, "%04X ", (WORD) iMapIndex * 0x0400);
      Qstrcat (qszString, chBuffer);

      /* Put in memory map with the memory map overlay */
      Qstrcpy (chBuffer, pMem->abMemoryMap[iMapIndex]);
      for (u = 0; u < NUM_OF_COLS - 1; ++u)
        if (fOverlayFlag && pMem->abMemMapOverlay[iMapIndex][u])
          chBuffer[u] = pMem->abMemMapOverlay[iMapIndex][u];

      /* Add memory map string */
      if (fReportFlag == FALSE)
        Qstrcat (qszString, "&1");

      Qstrcat (qszString, chBuffer);

      if (fReportFlag == FALSE)
        Qstrcat (qszString, "&0");

      /* Display hexadecimal equivilent of memory location */
      sprintf (chBuffer, " %04X", (WORD) ((iMapIndex + 1) * 0x0400) - 1);
      Qstrcat (qszString, chBuffer);

      Qstrcat (qszString, "  ");
    }
  else
    {
      Qmemset (qszString, ' ', 34);
      qszString[34] = '\0';
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\msd.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * MSD.C - Source file with the main() routine and supporting
 *   start-up routines.
 *********************************************************************/


/* Include Files */

#include "msd.h"
#include "_msd.h"

#ifdef CW_INCLUDED

#include "cgraphic.h"
#include <process.h>

AY FAR PASCAL GetUILine (void);


#endif /* CW_INCLUDED */


/*********************************************************************
 * main - Beginning of MSD program
 *
 * argc   - Count of arguments
 * argv[] - Array of strings containing the arguments
 ********************************************************************/

INT _cdecl main (INT argc, PSZ argv[])
{
  BOOL fReturnValue;           /* Return value from called functions */


  /* Reset disk to flush disk cache */

  bdos (0x0D, 0, 0);

  /* Initialization */

  InitParm1 (argv[1]);

  /* Process the command line */

  fReturnValue = ProcessCmdLine (argc, argv);


  /* Set some global variables */

  SetMiscGlobals (argv[0]);

  if (fReturnValue)
    return (fReturnValue);


  /* If we're in Report Only mode, get the info and print it out */

  if (fReportOnly)
    return (ReportOnly (pszReportFilename));


#ifdef CW_INCLUDED

  /* Otherwise, start the CW interface */

  BeginCwInterface();

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\menu.h ===
/******************************************************************************

  menu.h : menu public interface

******************************************************************************/

extern HMNU hmnuMenuBar;
extern HMNU hmnuMenuTest;
extern HMNU hmnuMenuPop;
extern MPVKEYID *prgmpvkeyid;

#define PMENUITEM PMTM

VOID FAR MenuCommand(PWND, WORD);


// for simplicity all menu ids are public 

#define midFile   0x100

#define midFind         (midFile+1)
#define midReport       (midFile+2)
#define midAutoexecBat  (midFile+3)
#define midConfigSys    (midFile+4)
#define midSystemIni    (midFile+5)
#define midWinIni       (midFile+6)
#define midMsmailIni    (midFile+7)
#define midProtocolIni  (midFile+8)
#define midDblSpaceIni	(midFile+9)
#define midMemMakerSts	(midFile+0x0A)
#define midQuit 	(midFile+0x0B)


#define midUtil   0x200

#define midBlockDisplay (midUtil+1)
#define midBrowser      (midUtil+2)
#define midInsert       (midUtil+3)
#define midPrtTst       (midUtil+4)
#define midBlackWhite   (midUtil+5)


#define midHelp   0x300
#define midAbout    (midHelp+1)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\menu.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * SHOWINFO.C - Source file for displaying information
 ********************************************************************/


/* Include Files */

#include "msd.h"


#ifdef CW_INCLUDED


/********
// the rgmpvkeyid is a list of accelerators 
// don't use F1 -- reserved for HELP 
// list must end with a 0,0 entry

MPVKEYID rgmpvkeyid[]=
  {
  {0, 0},
  {VK_F2,         midNew},
  {VK_F3,         midOpen},
  {VK_F4,         midSave},
  {'C'-'@' | KK_CONTROL,  midColorChange1},
  {VK_F5,         midQuit},
  {VK_F7 | KK_ALT,    midOverlapMove},
  {VK_F7 | KK_SHIFT,    midOverlapSize},
  {VK_F7,         midOverlapPop},
  {'B'-'@' | KK_CONTROL,  midTimeBltRrc},
  {'F'-'@' | KK_CONTROL,  midTimeFillArc},
  {'T'-'@' | KK_CONTROL,  midTimeTextOut},
  {VK_F10,        midMode},
  {'L'-'@' | KK_CONTROL,  midColorLoad},
  {'S'-'@' | KK_CONTROL,  midColorSave},
  {VK_F2 | KK_SHIFT,    midOtherFlush},
  {'Q',         midQuit},
  {0,0}
  };

MPVKEYID *prgmpvkeyid = &rgmpvkeyid[0];

********/

//  -- respond to a menu command (i.e. WM_COMMAND)

VOID
MenuCommand(pwnd, mid)
PWND pwnd;
WORD mid;
{
  Unreferenced(pwnd);

  switch (mid)
    {
      case midFind:
        {
          WORD wReturnValue;  /* Return value from DialogBox */
          QSZ * pqszStrings;  /* String array                */


          wReturnValue = DialogBox (&dlgFindFile1, FindFileDlg1);

          if (wReturnValue == IDD_USER + 11 ||
              wReturnValue == IDOK)
            {
              BYTE * pVer = NULL;   /* Version information */


              /* Get the version information */
              pVer = GetFileVersion (pszBrowseTitle, FALSE);
              if (pVer == NULL && wReturnValue != IDOK)
                {
                  MessageBox ("Version information for",
                              pszBrowseTitle,
                              "is not available",
                              MB_OK | 0x8000);
                  break;
                }

              if (pVer != NULL)
                {
                  /* Put the version information into strings */
                  pqszStrings = SprintFileVersion (pVer);
                  if (pqszStrings == NULL)
                    break;

                  /* Display the version information */
                  CreateInfoWnd (pszBrowseTitle, pqszStrings, TRUE);
                  wReturnValue = IDD_USER + 11;
                }
            }

          if (wReturnValue == IDD_USER + 10 ||
              wReturnValue == IDOK)
            {
              /* Read the file */
              pqszStrings = ViewFile (pszBrowseTitle, FALSE);

              if (pqszStrings       != NULL &&
                  pqszStrings[0]    != NULL &&
                  pqszStrings[0][0] != '\0')
                {
                  /* Display the strings in an Info Window */
                  CreateInfoWnd (pszBrowseTitle, pqszStrings, TRUE);
                }
            }

          break;
        }

      case midReport:
        if (DialogBox (&dlgReport, ReportDlg) == IDOK)
          ReportFromCW();
        break;

      case midAutoexecBat:
        FindAndViewFile (rgszSystemFiles[0], rgwSystemFiles[0], FALSE);
        break;

      case midConfigSys:
        FindAndViewFile (rgszSystemFiles[1], rgwSystemFiles[1], FALSE);
        break;

      case midSystemIni:
        FindAndViewFile (rgszSystemFiles[2], rgwSystemFiles[2], FALSE);
        break;

      case midWinIni:
        FindAndViewFile (rgszSystemFiles[3], rgwSystemFiles[3], FALSE);
        break;

      case midMsmailIni:
        FindAndViewFile (rgszSystemFiles[4], rgwSystemFiles[4], FALSE);
        break;

      case midProtocolIni:
        FindAndViewFile (rgszSystemFiles[5], rgwSystemFiles[5], FALSE);
        break;

      case midDblSpaceIni:
	FindAndViewFile (rgszSystemFiles[6], rgwSystemFiles[6], FALSE);
	break;

      case midMemMakerSts:
	FindAndViewFile (rgszSystemFiles[7], rgwSystemFiles[7], FALSE);
        break;

      case midQuit:
        Exit(0);
        break;


      case midBrowser:
        if (DialogBox (&dlgMemoryBrowser, MemoryBrowserDlg) == IDOK)
          {
            if (pqszBrowseStrings       != NULL &&
                pqszBrowseStrings[0]    != NULL &&
                pqszBrowseStrings[0][0] != '\0')
              {
                /* Display the strings in an Info Window */
                CreateInfoWnd (pszBrowseTitle, pqszBrowseStrings, TRUE);
              }
            else
              MessageBox ("Search text not found", NULL, NULL, MB_OK | 0x8000);
          }
        break;

      case midBlockDisplay:
        DialogBox (&dlgMemoryBlockDisplay, MemoryBlockDisplayDlg);
        break;

      case midInsert:
        InsertCommand();
        break;

      case midPrtTst:
        if (DialogBox (&dlgTestPrinter, TestPrinterDlg) == IDOK)
          TestPrinter (tpValue.fPostscript,
                       tpValue.f8BitTest,
                       tpValue.fSerialTest,
                       tpValue.wPort);
        break;

      case midBlackWhite:
        SetIsaColors (fBlackWhite = !fBlackWhite);
        break;


      case midAbout:
        DialogBox (&dlgAbout, AboutDlg);
        break;


      default:
        break;

    }
}



/**********
//  -- put in names when they are asked for

CHAR * FAR
SzFromSid(sid)
WORD sid;
{
  static CHAR aszIsa[cchIsaMax+5];

  if (sid >= midIsaList)
    {
      aszIsa[0] = '~';
      strcpy(&aszIsa[1], rgszIsa[sid-midIsaList]);
      return(&aszIsa[0]);
    }
  else
    return ((CHAR *) sid);
}


//  -- Keep running track of the colour change menus as they open

VOID FAR
ColourChange3(mid)
WORD mid;
{
  static ISA isa;
  static WORD coFore;
  static WORD fHilite;
  static WORD coBack;
  static WORD fBlink;
  static WORD midLastColour = midCh3Black;
  static BOOL fForeground = FALSE;

  if (mid >= midIsaList)
    {
      isa = (ISA) (mid - midIsaList);
    }
  else if (mid == midCh3Foreground || mid == midCh3Background)
    {
      fForeground = mid & 1;
      GetColor(isa, &coFore, &fHilite, &coBack, &fBlink);
      CheckMenuItem(midLastColour, FALSE);
      if (fForeground)
        {
          CheckMenuItem(midCh3Hilight, fHilite);
          midLastColour = midCh3Black + coFore;
          CheckMenuItem(midLastColour, TRUE);
        }
      else
        {
          CheckMenuItem(midCh3Hilight, fBlink);
          midLastColour = midCh3Black + coBack;
          CheckMenuItem(midLastColour, TRUE);
        }
    }
  else if (mid == midCh3Hilight)
    {
      if (fForeground)
        {
          SetThisColor(isa, coFore, !fHilite, coBack, fBlink);
        }
      else
        {
          SetThisColor(isa, coFore, fHilite, coBack, !fBlink);
        }
    }
  else if (mid >= midCh3Black)
    {
      if (fForeground)
        {
          SetThisColor(isa, mid-midCh3Black, fHilite, coBack,
            fBlink);
        }
      else
        {
          SetThisColor(isa, coFore, fHilite, mid-midCh3Black,
            fBlink);
        }
    }
}

**********/

#endif /* CW_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\mousinfo.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * MOUSINFO.C - Source file for mouse detection code.
 ********************************************************************/


/* Include Files */

#include "msd.h"


/*********************************************************************
 * GetMouseInfo - Gets the mouse information.
 *
 * pMouse       - Mouse information structure
 * fMinimumInfo - TRUE if minimum information is requested.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetMouseInfo (MOUSE_STRUCT *pMouse)
{
  union  REGS  inregs, outregs;   /* Register structure for int86()        */
  struct SREGS sregs;             /* Segment regs for int86x()             */
  WORD  wType;                    /* Mouse driver type (InPort, Bus, etc). */
  WORD  wMouseHardware;           /* Mouse hardware type                   */
  WORD  wSize;                    /* Size required to store mouse state    */
  WORD  wMouseVersion;            /* Mouse version (ie 801 == 8.01)        */
  BYTE FAR *fbMouseState = NULL;  /* Pointer to mouse state                */
  static BOOL fMouseInfoLoaded = FALSE;   /* Set to TRUE after mouse       */
                                          /*   info obtained               */
  static MOUSE_STRUCT FAR *fpMouse = NULL;/* Stored mouse info             */


  /* We obtain the mouse information only once, then store the mouse */
  /*   information for later requests.  If a second request is made  */
  /*   (ie., for IRQ info, etc.), this routine will copy the stored  */
  /*   mouse information to pMouse and return immediately.  This is  */
  /*   done because the mouse information is very time consuming to  */
  /*   obtain on some computers and/or mice.                         */

  if (fMouseInfoLoaded)
    {
      _fmemcpy ((MOUSE_STRUCT FAR *) pMouse, fpMouse, sizeof (MOUSE_STRUCT));
      return (FALSE);
    }


  /* Check to see if the mouse driver is safe to call */

  /* Get interrupt vector */
  inregs.h.ah = 0x35;
  inregs.h.al = 33;
  int86x (0x21, &inregs, &outregs, &sregs);

  if ((sregs.es | outregs.x.bx) == 0)
    {
      NoMouseDriver (pMouse);
      return (FALSE);
    }


  /* Save Microsoft Mouse state (important for the CW routines) */

  inregs.x.ax = 0x0015;
  inregs.x.bx = 0x0000;
  int86 (0x33, &inregs, &outregs);
  wSize = outregs.x.bx;

  if (wSize == 0)
    fbMouseState = NULL;
  else
    {
      fbMouseState = _fmalloc (wSize);
      if (fbMouseState != NULL)
        {
          inregs.x.ax = 0x0016;
          sregs.es    = FP_SEG (fbMouseState);
          inregs.x.dx = FP_OFF (fbMouseState);
          inregs.x.bx = wSize;
          int86x (0x33, &inregs, &outregs, &sregs);
        }
    }


  /* Zero out the OEM version number, driver mfgr, and COM port */
  pMouse->wOemMajorVersion = 0;
  pMouse->wOemMinorVersion = 0;
  pMouse->wDriverMfgr      = 0;
  memset (pMouse->szDriverMfgr, '\0', MAX_MOUSE_DRIVER_MFGR);
  pMouse->wComPort         = 0;
  pMouse->szComPort[0]     = '\0';


  /* Determine mouse hardware */

  wMouseHardware = fnHardMouseDetect();
  pMouse->wMouseHardwareType = wMouseHardware;

  if (wMouseHardware == 0xFFFF)
    {
      strcpy (pMouse->szMouseHardwareType, pszDeviceNotDetected);
      pMouse->fHardwareInstalled = FALSE;
    }
  else
    {
      if (wMouseHardware == MSPS2_MOUSE)
        wMouseHardware = PS2_STYLE_MOUSE;

      strcpy (pMouse->szMouseHardwareType, paszMouseTypes[wMouseHardware]);
      pMouse->fHardwareInstalled = TRUE;
    }


  if (AltPS2MouseChk() == TRUE)
    {
      /* A PS/2 Style mouse has been detected.  I can tell the     */
      /*   difference between a Logitech PS/2 mouse and a IBM/     */
      /*   Microsoft PS/2 mouse only at DOS.  If we're in Windows, */
      /*   the mice behave identically.  Therefore, if we're in    */
      /*   Windows, I'll declare it to be a PS/2 Style Mouse, but  */
      /*   if we're at DOS, I'll say it's a Logitech if that was   */
      /*   detected.                                               */

      if (wMouseHardware == LOGITECH_PS2_MOUSE)
        {
          WORD wWindowsType;        /* Local copies of data */
          WORD wWindowsMajor;
          WORD wWindowsMinor;
          BOOL fDosShell;


          /* Determine if we are running in Windows 3.0 or above */
          WinVerDetect (&wWindowsType,
                        &wWindowsMajor,
                        &wWindowsMinor,
                        &fDosShell);

          if (wWindowsType != NO_WINDOWS && wWindowsMajor >= 3)
            {
              strcpy (pMouse->szMouseHardwareType,
                      paszMouseTypes[PS2_STYLE_MOUSE]);
              pMouse->wMouseHardwareType = PS2_STYLE_MOUSE;
              pMouse->fHardwareInstalled = TRUE;
            }
        }
      else if (wMouseHardware == NO_MOUSE_INSTALLED)
        {
          strcpy (pMouse->szMouseHardwareType,
                  paszMouseTypes[PS2_STYLE_MOUSE]);
          pMouse->wMouseHardwareType = PS2_STYLE_MOUSE;
          pMouse->fHardwareInstalled = TRUE;
        }
    }

  /* Check to see if non-Microsoft mouse drivers are resident */

  /* PC Mouse Driver */
  inregs.x.ax = 0x0042;
  int86 (0x33, &inregs, &outregs);
  if (outregs.x.ax == 0xFFFF)
    {
      pMouse->wOemMajorVersion = 0;
      pMouse->wOemMinorVersion = 0;
      pMouse->wDriverMfgr      = MOUSE_MFGR_PC_MOUSE;
      strcpy (pMouse->szDriverMfgr, paszMouseMfgrs[MOUSE_MFGR_PC_MOUSE]);
    }

  /* Logitech Mouse Driver */
  inregs.x.ax = 0x266C;
  int86 (0x33, &inregs, &outregs);
  if (outregs.x.bx == 0x5353)  /* 'SS' */
    {
      WORD rgwLMouseInfo[16];   /* An array to hold mouse info */

      pMouse->wOemMajorVersion = outregs.h.ch - '0';
      pMouse->wOemMinorVersion = outregs.h.cl - '0';
      pMouse->wDriverMfgr      = MOUSE_MFGR_LOGITECH;
      strcpy (pMouse->szDriverMfgr, paszMouseMfgrs[MOUSE_MFGR_LOGITECH]);

      /* Load Logitech serial mouse port number */
      segread (&sregs);
      inregs.x.ax = 0x246C;
      inregs.x.dx = (WORD) &rgwLMouseInfo[0];
      int86x (0x33, &inregs, &outregs, &sregs);
      if (outregs.x.ax == 0xFFFF) /* AX = FFFFh means it's a serial mouse */
        {
          if (rgwLMouseInfo[5] <= 4)
            pMouse->wComPort = rgwLMouseInfo[5];
        }
    }


  /* Reset Microsoft driver and read status */

  inregs.x.ax = 0x0000;
  int86 (0x33, &inregs, &outregs);

  if (outregs.x.ax == 0xFFFF)
    {
      /* Microsoft mouse driver (or compatible) installed */
      if (pMouse->wDriverMfgr == 0)
        {
          pMouse->wDriverMfgr = MOUSE_MICROSOFT_DRIVER;
          strcpy (pMouse->szDriverMfgr, paszMouseMfgrs[MOUSE_MFGR_MICROSOFT]);
        }


      /* Set the number of mouse buttons */
      if (outregs.x.bx == 0xFFFF)
        pMouse->wNmbrButtons = 2;
      else
        pMouse->wNmbrButtons = outregs.x.bx;


      /* Most of the information is not available under OS/2 */
      if (wDosMajor >= 10)
        {
          /* A mouse IRQ of zero will not be checked for IRQ conflicts */
          pMouse->wIrq = 0;

          /* Restore Microsoft Mouse state */
          if (fbMouseState)
            {
              inregs.x.ax = 0x0017;
              sregs.es    = FP_SEG (fbMouseState);
              inregs.x.dx = FP_OFF (fbMouseState);
              inregs.x.bx = wSize;
              int86x (0x33, &inregs, &outregs, &sregs);
              _ffree (fbMouseState);
            }
        }


      /* Get Mouse driver version and mouse type */
      inregs.x.ax = 0x0024;
      int86 (0x33, &inregs, &outregs);


      /* Driver version number */
      pMouse->wMsMajorVersion = outregs.h.bh;
      pMouse->wMsMinorVersion = outregs.h.bl;
      wMouseVersion = ((WORD) outregs.h.bh) * 100 + (WORD) outregs.h.bl;


      /* Mouse IRQ */
      if (outregs.h.cl == 0 || outregs.h.cl == 0xFF)
        pMouse->wIrq = 12;    /* PS/2 mice use IRQ 12 */
      else
        pMouse->wIrq = outregs.h.cl;


      /* Mouse Type from int 33H, AX=0024H */
      wType = outregs.h.ch;


      /* Check for Ballpoint mouse */
      inregs.x.ax = 0x0030;
      inregs.h.ch = 0x00;
      int86 (0x33, &inregs, &outregs);


      /* Set the mouse type */
      if (outregs.x.ax != 0x30 && outregs.x.ax != 0xFFFF)
        {
          pMouse->wMouseDriverType = 0x80;
          strcpy (pMouse->szMouseDriverType, pszBallPoint);
        }
      else
        {
          pMouse->wMouseDriverType  = wType;
          strcpy (pMouse->szMouseDriverType, paszMouseTypes[wType]);
        }


      /* Set mouse's COM port */
      if (pMouse->wComPort == 0 &&
          (pMouse->wMouseDriverType == SERIAL_MOUSE          ||
           pMouse->wMouseDriverType == LOGITECH_SERIAL_MOUSE ||
           pMouse->wMouseDriverType == BALLPOINT_MOUSE))
        {
          /* Serial mouse.  Determine the serial port */
          if (pMouse->wIrq == 3)
            pMouse->wComPort = 2;
          else if (pMouse->wIrq == 4)
            pMouse->wComPort = 1;
          else
            {
              pMouse->wComPort        = 0;
              pMouse->wComPortAddress = 0;
              strcpy (pMouse->szComPort, pszUnknown);
            }
        }


      /* Set mouse's COM port address */
      if (pMouse->wComPort != 0)
        {
          /* 40:0 is the DOS Device Table */
          WORD FAR *fwDosDeviceTable = (WORD FAR *) 0x00400000;
          WORD wPort;     /* COM port number (ie, 0 = COM1:) */

          wPort = pMouse->wComPort;
          pMouse->wComPortAddress = fwDosDeviceTable[wPort - 1];
          strcpy (pMouse->szComPort, pszCom[wPort]);
        }


      /* Mouse Sensitivity */
      inregs.x.ax = 0x001B;
      int86 (0x33, &inregs, &outregs);


      /* Set sensitivities */
      pMouse->wHMickeys       = outregs.x.bx;
      pMouse->wVMickeys       = outregs.x.cx;
      pMouse->wThresholdSpeed = outregs.x.dx;


      /* Mouse Language */
      inregs.x.ax = 0x0023;
      inregs.x.bx = 0x0000;
      int86 (0x33, &inregs, &outregs);


      /* Set the mouse language */
      pMouse->wLanguage = outregs.x.bx;
      strcpy (pMouse->szLanguage, paszMouseLanguages[outregs.x.bx]);


      /* Determine the Mouse driver's file type (.SYS, .COM) */
      if (wMouseVersion >= 626)
        {
          inregs.x.ax = 0x0025;
          int86 (0x33, &inregs, &outregs);

          /* Bit 15 is set for .SYS files, clear for .COM files */
          if (outregs.x.ax & 0x8000)
            {
              pMouse->wDriverFileType = MOUSE_SYS_FILE;
              strcpy (pMouse->szDriverFileType,
                      paszDriverFileTypes[MOUSE_SYS_FILE]);
            }
          else
            {
              pMouse->wDriverFileType = MOUSE_COM_FILE;
              strcpy (pMouse->szDriverFileType,
                      paszDriverFileTypes[MOUSE_COM_FILE]);
            }
        }
      else
        {
          pMouse->wDriverFileType = MOUSE_UNKNOWN_FILE;
          pMouse->szDriverFileType[0] = '\0';
        }


      /* Determine the location of the MOUSE.INI file */
      if (wMouseVersion >= 800)
        {
          inregs.x.ax = 0x0034;
          int86x (0x33, &inregs, &outregs, &sregs);

          /* ES:DX point to the fully qualified path to MOUSE.INI */
          if (outregs.x.ax != 0 && (sregs.es | outregs.x.dx))
            {
              CHAR FAR * fpszString = NULL;  /* Far string pointer */

              fpszString = (CHAR FAR *)
                             ((DWORD) sregs.es << 16) + outregs.x.dx;

              _fstrncpy ((CHAR FAR *) pMouse->szMouseIniPath, fpszString,
                         MAX_MOUSE_INI_PATH - 1);
              pMouse->szMouseIniPath[MAX_MOUSE_INI_PATH - 1] = '\0';
            }
          else
            pMouse->szMouseIniPath[0] = '\0';
        }
      else
        pMouse->szMouseIniPath[0] = '\0';
    }
  else
    NoMouseDriver (pMouse);


  /* Restore Microsoft Mouse state, unless it's a 7.04 mouse driver.  */
  /*   A bug in the 7.04 mouse driver will divide overflow and crash. */

  if (fbMouseState)
    if (pMouse->wMsMajorVersion != 7 && pMouse->wMsMinorVersion != 4)
      {
        inregs.x.ax = 0x0017;
        sregs.es    = FP_SEG (fbMouseState);
        inregs.x.dx = FP_OFF (fbMouseState);
        inregs.x.bx = wSize;
        int86x (0x33, &inregs, &outregs, &sregs);
        _ffree (fbMouseState);
      }
    else
      _ffree (fbMouseState);


  /* Store the mouse structure for future use */
  fpMouse = _fmalloc (sizeof (MOUSE_STRUCT));
  if (fpMouse != NULL)
    {
      _fmemcpy (fpMouse, (MOUSE_STRUCT FAR *) pMouse, sizeof (MOUSE_STRUCT));
      fMouseInfoLoaded = TRUE;
    }

  /* Clear the serial ports of stray characters */
  inp (0x03F8);   /* COM1: */
  inp (0x02F8);   /* COM2: */
  inp (0x03E8);   /* COM3: */
  inp (0x02E8);   /* COM4: */

  return (FALSE);
}


/*********************************************************************
 * NoMouseDriver - Sets the values in the mouse structure to reflect
 *                 the fact that there is no mouse driver present
 *                 in the system.
 *
 * pMouse - Mouse structure.
 *********************************************************************/

VOID NoMouseDriver (MOUSE_STRUCT *pMouse)
{
  pMouse->wOemMajorVersion = 0;
  pMouse->wOemMinorVersion = 0;
  pMouse->wMsMajorVersion  = 0;
  pMouse->wMsMinorVersion  = 0;
  pMouse->wDriverMfgr      = MOUSE_NO_MOUSE_DRIVER;
  strcpy (pMouse->szDriverMfgr, paszMouseMfgrs[MOUSE_NO_MOUSE_DRIVER]);
}


/*********************************************************************
 * SprintMouseInfo - Put mouse information into a set of strings to be
 *                   printed or displayed.
 *
 * Returns:  NULL if an error occured.
 *********************************************************************/

QSZ * SprintMouseInfo (MOUSE_STRUCT *pMouse,
                       CHAR szSumStrings[][MAX_SUMM_INFO + 5])
{
  WORD wNmbrStrings;        /* Number of strings                     */
  WORD wNmbrChars;          /* Number of characters in the strings   */
  WORD wIndent;             /* Indent amount for aligning colons     */
  WORD wIndex;              /* Index to mouse title strings          */
  WORD wRatioIndex;         /* Index for looking up the mouse ratio  */
  WORD i;                   /* Looping variable                      */
  CHAR chBuffer[80];        /* Local string                          */
  QSZ  *pqszStrings = NULL; /* Location for storing string pointers  */


  /* Summary Strings */
  if (szSumStrings != NULL)
    {
      /* Clear out the summary strings */
      szSumStrings[0][0] = '\0';
      szSumStrings[1][0] = '\0';


      /* Check to see if the driver is detected, */
      /*   but the hardware is not detected.     */
      if (pMouse->fHardwareInstalled  == FALSE &&
          (pMouse->wDriverMfgr        != MOUSE_NO_MOUSE_DRIVER ||
           pMouse->wMouseHardwareType == NO_MOUSE_INSTALLED))
        {
          strcpy (szSumStrings[0], "Driver Detected");
        }
      else
        {
          /* Mouse hardware type */
          strcpy (szSumStrings[0], pMouse->szMouseHardwareType);

          /* Is mouse driver version available */
          if (wDosMajor >= 10 || pMouse->wDriverMfgr == MOUSE_NO_MOUSE_DRIVER)
            return (NULL);
        }

      /* Mouse driver version */
      if (pMouse->wOemMajorVersion != 0)
        sprintf (chBuffer, " %x.%02x", pMouse->wOemMajorVersion,
                 pMouse->wOemMinorVersion);
      else
        sprintf (chBuffer, " %x.%02x", pMouse->wMsMajorVersion,
                 pMouse->wMsMinorVersion);

      if (strlen (szSumStrings[0]) + strlen (chBuffer) > MAX_SUMM_INFO)
        {
          i = 1;
          szSumStrings[i][0] = '\0';
        }
      else
        i = 0;

      strcat (szSumStrings[i], chBuffer);

      return (NULL);
    }



  /* Overestimate the amount of space required for the strings */

  for (wNmbrStrings = 0; paszMouseTitles[wNmbrStrings] != NULL;
       ++wNmbrStrings)
    ;

  ++wNmbrStrings;

  wNmbrChars = wNmbrStrings * MAX_MOUSE_LINE_LEN;


  /* Calculate the indent.  If there is an OEM version number, */
  /*   then the Microsoft version number line will have to be  */
  /*   displayed, and it is the longest line.  If not, then    */
  /*   the next longest line will be needed.                   */

  if (pMouse->wOemMajorVersion != 0)
    wIndent = MAX_MOUSE_TITLE;
  else
    wIndent = MAX_MOUSE_TITLE - 1;


  /* Allocate space for the pointer area and string area */
  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);


  /* Put the information in place */

  for (wIndex = 0, i = 0; paszMouseTitles[wIndex] != NULL; ++wIndex, ++i)
    {
      /* Determine if the "Microsoft Driver Version" line is required */
      if (wIndex == MOU_MS_DRIVER_VERSION &&
          pMouse->wOemMajorVersion == 0)
        {
          --i;
          continue;
        }


      /* Determine if the "DOS Driver Type" line is required */
      if (wIndex == MOU_DRIVER_FILE_TYPE &&
          pMouse->szDriverFileType[0] == '\0')
        {
          --i;
          continue;
        }


      /* Determine if the "Path to MOUSE.INI" line is required */
      if (wIndex == MOU_MOUSE_INI_PATH &&
          pMouse->szMouseIniPath[0] == '\0')
        {
          --i;
          continue;
        }


      /* Determine if Serial Mouse information is necessary */
      if (wIndex == MOU_COM_PORT || wIndex == MOU_COM_PORT_ADDRESS)
        if (pMouse->wMouseDriverType != SERIAL_MOUSE          &&
            pMouse->wMouseDriverType != LOGITECH_SERIAL_MOUSE &&
            pMouse->wMouseDriverType != BALLPOINT_MOUSE)
          {
            /* It's not a serial mouse, so skip it */
            --i;
            continue;
          }


      /* Most information is not available under OS/2 */
      if ((wDosMajor >= 10 ||
          pMouse->wDriverMfgr == MOUSE_NO_MOUSE_DRIVER) &&
          wIndex > MOU_DRIVER_MFGR)
        break;


      /* Put the title on the line */
      QstrcpyAlign (pqszStrings[i], paszMouseTitles[wIndex], wIndent);

      switch (wIndex)
        {
          case MOU_HARDWARE:
            {
              Qstrcat (pqszStrings[i], pMouse->szMouseHardwareType);
              break;
            }

          case MOU_DRIVER_MFGR:
            {
              Qstrcat (pqszStrings[i], pMouse->szDriverMfgr);
              break;
            }

          case MOU_DOS_DRIVER_TYPE:
            {
              Qstrcat (pqszStrings[i], pMouse->szMouseDriverType);
              break;
            }

          case MOU_DRIVER_FILE_TYPE:
            {
              Qstrcat (pqszStrings[i], pMouse->szDriverFileType);
              break;
            }

          case MOU_DOS_DRIVER_VERSION:
            {
              /* If there is an OEM version number, display it,    */
              /*   otherwise, display the Microsoft version number */

              if (pMouse->wOemMajorVersion != 0)
                sprintf (chBuffer, "%x.%02x", pMouse->wOemMajorVersion,
                         pMouse->wOemMinorVersion);
              else
                sprintf (chBuffer, "%x.%02x", pMouse->wMsMajorVersion,
                         pMouse->wMsMinorVersion);

              Qstrcat (pqszStrings[i], chBuffer);
              break;
            }

          case MOU_MS_DRIVER_VERSION:
            {
              sprintf (chBuffer, "%x.%02x", pMouse->wMsMajorVersion,
                       pMouse->wMsMinorVersion);
              Qstrcat (pqszStrings[i], chBuffer);
              break;
            }

          case MOU_MOUSE_IRQ:
            {
              sprintf (chBuffer, "%d", pMouse->wIrq);
              Qstrcat (pqszStrings[i], chBuffer);
              break;
            }

          case MOU_COM_PORT:
            {
              Qstrcat (pqszStrings[i], pMouse->szComPort);
              break;
            }

          case MOU_COM_PORT_ADDRESS:
            {
              if (pMouse->wComPort)
                {
                  sprintf (chBuffer, "%04XH", pMouse->wComPortAddress);
                  Qstrcat (pqszStrings[i], chBuffer);
                }
              break;
            }

          case MOU_NMBR_BUTTONS:
            {
              sprintf (chBuffer, "%d", pMouse->wNmbrButtons);
              Qstrcat (pqszStrings[i], chBuffer);
              break;
            }

          case MOU_H_SENSITIVITY:
            {
              sprintf (chBuffer, "%d", pMouse->wHMickeys);
              Qstrcat (pqszStrings[i], chBuffer);
              break;
            }

          case MOU_H_CURSOR_RATIO:
            {
              wRatioIndex = pMouse->wHMickeys / 5 - 1;
              if (wRatioIndex < MAX_MOUSE_RATIO_STRINGS)
                {
                  Qstrcat (pqszStrings[i], paszMouseRatios[wRatioIndex]);
                  Qstrcat (pqszStrings[i], pszColonOne);
                }
              else
                Qstrcat (pqszStrings[i], pszUndefined);
              break;
            }

          case MOU_V_SENSITIVITY:
            {
              sprintf (chBuffer, "%d", pMouse->wVMickeys);
              Qstrcat (pqszStrings[i], chBuffer);
              break;
            }

          case MOU_V_CURSOR_RATIO:
            {
              wRatioIndex = pMouse->wVMickeys / 5 - 1;
              if (wRatioIndex < MAX_MOUSE_RATIO_STRINGS)
                {
                  Qstrcat (pqszStrings[i], paszMouseRatios[wRatioIndex]);
                  Qstrcat (pqszStrings[i], pszColonOne);
                }
              else
                Qstrcat (pqszStrings[i], pszUndefined);
              break;
            }

          case MOU_THRESHOLD_SPEED:
            {
              sprintf (chBuffer, "%d", pMouse->wThresholdSpeed);
              Qstrcat (pqszStrings[i], chBuffer);
              break;
            }

          case MOU_LANGUAGE:
            {
              Qstrcat (pqszStrings[i], pMouse->szLanguage);
              break;
            }

          case MOU_MOUSE_INI_PATH:
            {
              Qstrcat (pqszStrings[i], pMouse->szMouseIniPath);
              break;
            }
        }

      /* Set the next pointer */
      PrepNextString (pqszStrings, i);
    }


  /* Set the last pointer to NULL */

  pqszStrings[i] = NULL;

  /* Return the pointer to pqszStrings */

  return (pqszStrings);
}


/*********************************************************************
 * AltPS2MouseChk - Another check for a PS/2 mouse.
 *********************************************************************/

BOOL AltPS2MouseChk (VOID)
{
  union REGS regs;

  /* PS/2 Pointing Device BIOS Interface -- Reset */

  regs.x.ax = 0xC201;
  regs.x.bx = 0xFFFF;
  int86 (0x15, &regs, &regs);

  /* Carry Flag set indicates error */

  if (regs.x.cflag || regs.x.bx == 0xFFFF)
    return (FALSE);
  else
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\msdsys.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * MSDSYS.C - Source file for system related code (ie file I/O).
 ********************************************************************/


/* Include Files */

#include "msd.h"


/********************************************************************
 * OpenFile - Opens a file and provides appropriate error handling.
 *
 * pszFilename - Name of file
 * pszMode     - Mode to open the file.
 * fShowError  - Displays errors when TRUE.
 *
 * Returns: FILE handle, or NULL if an error condition occured.
 ********************************************************************/

FILE * OpenFile (PSZ pszFilename, PSZ pszMode, BOOL fShowError)
{
  FILE *fp;           /* Local storage for the file pointer */

  /* Open the file */

  fp = fopen (pszFilename, pszMode);

  /* Give appropriate error message, if necessary */

  if (fShowError && (fp == NULL || fCriticalError))
    {
      fCriticalError = FALSE;

      ShowError (ERR_OK_BUTTON, pszErrorOpening, pszFilename, 
                 _strerror (NULL));

      return (NULL);
    }

  /* If all went well, return the file pointer to the calling routine */

  return (fp);
}


/********************************************************************
 * CloseFile - Closes a file and provides appropriate error handling.
 *
 * fp - File handle to close
 *
 * Returns: TRUE if an error occured.
 ********************************************************************/

BOOL CloseFile (FILE *fp)
{
  WORD wReturnValue;  /* Return value from fclose */


  /* Close the file */
  wReturnValue = fclose (fp);

  /* Give appropriate error message, if necessary */
  if (wReturnValue == EOF)
    {
      fCriticalError = FALSE;

      ShowError (ERR_OK_BUTTON, pszErrorClosing, NULL, _strerror (NULL));

      return (TRUE);
    }

  return (FALSE);
}


/**********************************************************************
 * CreateTempFile - Uses a DOS 3+ call to create a unique file
 *
 * pszPathname - Path to where the temp file needs to go.
 *
 * Returns: Error number:
 *          03 - Path not found.
 *          04 - No more handles.
 *          05 - Access denied.
 **********************************************************************/

WORD CreateTempFile (PSZ pszPathname)
{
  union REGS inregs, outregs;   /* Register values for int86x */
  struct SREGS sregs;           /* Segment register values */
  CHAR FAR * fpszPathname = (CHAR FAR *) pszPathname;

  inregs.h.ah = 0x5A;
  inregs.x.cx = 0;
  sregs.ds    = (WORD) FP_SEG (fpszPathname);
  inregs.x.dx = (WORD) FP_OFF (fpszPathname);

  int86x (0x21, &inregs, &outregs, &sregs);

  if (outregs.x.cflag)
    return (outregs.x.ax);
  else
    return (0);
}


/**********************************************************************
 * DeleteFile - Deletes file specified by pszFilename
 *
 * pszFilename - File to delete
 *
 * Returns: Error number:
 *          02 - File not found.
 *          03 - Path not found.
 *          05 - Access denied.
 **********************************************************************/

WORD DeleteFile (PSZ pszPathname)
{
  union REGS inregs, outregs;   /* Register values for intdos */
  struct SREGS sregs;           /* Segment register values */
  CHAR FAR * fpszPathname = (CHAR FAR *) pszPathname;

  inregs.h.ah = 0x41;
  sregs.ds    = (WORD) FP_SEG (fpszPathname);
  inregs.x.dx = (WORD) FP_OFF (fpszPathname);

  int86x (0x21, &inregs, &outregs, &sregs);

  if (outregs.x.cflag)
    return (outregs.x.ax);
  else
    return (0);
}


/**********************************************************************
 * RenameFile - Renames a file.
 *
 * pszPathname1 - File to rename.
 * pszPathname2 - New filename.
 *
 * Returns: Error number:
 *          02 - File not found.
 *          03 - Path not found.
 *          05 - Access denied.
 *          17 - (11H) Not the same device.
 **********************************************************************/

WORD RenameFile (PSZ pszPathname1, PSZ pszPathname2)
{
  union REGS inregs, outregs;   /* Register values for intdos */
  struct SREGS sregs;           /* Segment register values */
  CHAR FAR * fpszPathname1 = (CHAR FAR *) pszPathname1;
  CHAR FAR * fpszPathname2 = (CHAR FAR *) pszPathname2;

  inregs.h.ah = 0x56;
  sregs.ds    = (WORD) FP_SEG (fpszPathname1);
  inregs.x.dx = (WORD) FP_OFF (fpszPathname1);
  sregs.es    = (WORD) FP_SEG (fpszPathname2);
  inregs.x.di = (WORD) FP_OFF (fpszPathname2);

  int86x (0x21, &inregs, &outregs, &sregs);

  if (outregs.x.cflag)
    return (outregs.x.ax);
  else
    return (0);
}

WORD wNmbrFound = 0;

/*********************************************************************
 * FindFile - Finds all of the pszFilename files on the system.
 *
 * pszFilename   - Filename to find.
 *
 * pszPathname   - Path to start searching from (NULL if it's to be
 *                 ignored).
 *
 * fSearchFlags  - SEARCH_FLOPPIES          Search floppies.
 *                 SEARCH_LOCAL_DRIVES      Search local hard disks.
 *                 SEARCH_NET_DRIVES        Search net drives (and
 *                                          all other drives).
 *                 SEARCH_ROOT              Search the root directory.
 *                 RECURSE_INTO_SUB_DIRS    Search recursively into
 *                                          subdirectories.
 *
 *                 Only one of the following should be specified at
 *                   one time:
 *                 SEARCH_LANMAN_ROOT       Searches in the LANMAN
 *                                          root directory.
 *                 SEARCH_WINDIR            Uses the "windir="
 *                                          environment variable.
 *                 SEARCH_BOOT_DRIVE        Search just the boot drive.
 *
 * chDriveLetter - If fSearchFlags does not specify the drive type(s)
 *                 to search, this contains the drive letter to
 *                 search.  ('\0' to search current drive).
 *
 * Returns:  Pointer to an array of strings to pszFilename files, the
 *           last pointer is a NULL pointer.  If pszFilename could
 *           not be found, or an error occured, the first pointer is a
 *           NULL.
 *********************************************************************/

FILE_INFO FAR *FindFile (PSZ  pszFilename,
                         PSZ  pszPathname,
                         BOOL fSearchFlags,
                         CHAR chDriveLetter)
{
  CHAR chCurrentPath[_MAX_PATH + 1];  /* Stores current drive & directory  */
  WORD wCurrentDrive;                 /* Stores the current drive number   */
  WORD i;                             /* Looping variable                  */
  DISK_STRUCT *pDisk = NULL;          /* Pointer to disk drive info        */
                                      /*   structure                       */
  OS_VERSION_STRUCT *pOsVer = NULL;   /* Pointer to DOS info structure     */
  BOOL fReturnValue = FALSE;          /* Stores the return value from      */
                                      /*   fuctions                        */
  FILE_INFO FAR *pFileInfo = NULL;    /* Pointer to file info linked list  */
  FILE_INFO FAR *pfi = NULL;          /* Another pointer to file info list */
                                      /*   (this one is changed by the     */
                                      /*   called routines).               */


  /* Save the current drive and directory */
  wCurrentDrive = _getdrive();
  _getdcwd (wCurrentDrive, chCurrentPath, _MAX_PATH);


  /* Allocate enough room for the find file info */
  pFileInfo = _fmalloc (sizeof (FILE_INFO));
  if (pFileInfo == NULL)
    {
      OutOfMemory();
      return (NULL);
    }
  pfi = pFileInfo;


  /* Set the first pointer to null, to show that */
  /*   this is the last on the list.             */
  pFileInfo->fpNextFileInfo = NULL;


  /* Get the disk and operating system structures */
  fReturnValue = GetFindFileInfo (&pDisk, &pOsVer, fSearchFlags);
  if (fReturnValue)
    {
      FreeFileInfo (pFileInfo);
      return (NULL);
    }


  /* Zero out the counter for files found */
  wNmbrFound = 0;

  /* Change to the appropriate drive and directory if necessary */
  if (pszPathname != NULL)
    {
      /* Check to see if a drive was passed to us */
      if (pszPathname[1] == ':')
        {
          WORD wDrive = toupper (pszPathname[0]) - 'A' + 1;
          if (_chdrive (wDrive))
            {
              MessageBox ("Drive does not exist", pszPathname, NULL, MB_OK | 0x8000);
              return (NULL);
            }
          if (chdir (&pszPathname[2]))
            {
              MessageBox (pszPathNotThere, pszPathname, NULL, MB_OK | 0x8000);
              return (NULL);
            }
        }
      else
        if (chdir (pszPathname))
          {
            MessageBox (pszPathNotThere, pszPathname, NULL, MB_OK | 0x8000);
            return (NULL);
          }
    }


  /* Boot drive search */
  if (fSearchFlags & SEARCH_BOOT_DRIVE)
    {
      FindOnBootDrive (&pfi,
                       pDisk,
                       pOsVer,
                       pszFilename,
                       fSearchFlags);
    }
  else if (fSearchFlags & SEARCH_WINDIR)
    {
      /* Find the "windir=" environment variable */
      for (i = 0;
           environ[i][0] != '\0' && memcmp ("windir=", environ[i], 7) != 0;
           ++i)
        ;

      /* If found, put the fully qualified path into chWinDir */
      if (environ[i][0] == 'w')
        {
          /* Change to the drive and directory of the file */
          chDriveLetter = environ[i][7];
          chdir (&environ[i][9]);

          /* Find the file */
          FindFileOnDrive (&pfi,
                           pszFilename,
                           fSearchFlags,
                           chDriveLetter);
        }
      else
        {
          /* Free up pFileInfo */
          _ffree (pFileInfo);

          /* Set the flags for finding the windows file the hard way */
          fSearchFlags = SEARCH_LOCAL_DRIVES   |
                         SEARCH_ROOT           |
                         RECURSE_INTO_SUB_DIRS;

          /* Find the file */
          pFileInfo = FindFile (pszFilename, pszPathname,
                                fSearchFlags, chDriveLetter);
        }
    }
  else if (fSearchFlags & SEARCH_LANMAN_ROOT)
    {
      unsigned short int err=0, ta=0;
      struct wksta_info_0 *wksta0;
      char wkstabuf[BUFSIZ];
      CHAR chBuffer[_MAX_PATH + 1];

      /* Get the LANMAN root */
      err = NetWkstaGetInfo (NULL, 0, wkstabuf, BUFSIZ, &ta);
      if (err == 0)
        {
          wksta0 = (struct wksta_info_0 *) wkstabuf;
          _fmemcpy (chBuffer, wksta0->wki0_root, _MAX_PATH);

          /* Change to the drive and directory of the file */
          chDriveLetter = chBuffer[0];
          chdir (&chBuffer[2]);

          /* Find the file */
          FindFileOnDrive (&pfi,
                           pszFilename,
                           fSearchFlags,
                           chDriveLetter);
        }
      else
        {
          /* Free up pFileInfo */
          _ffree (pFileInfo);

          /* Set the flags for finding the LANMAN file the hard way */
          fSearchFlags = SEARCH_LOCAL_DRIVES   |
                         SEARCH_ROOT           |
                         RECURSE_INTO_SUB_DIRS;

          /* Find the file */
          pFileInfo = FindFile (pszFilename, pszPathname,
                                fSearchFlags, chDriveLetter);
        }
    }
  else if ((fSearchFlags & (SEARCH_FLOPPIES     |
                            SEARCH_LOCAL_DRIVES |
                            SEARCH_NET_DRIVES   |
                            SEARCH_BOOT_DRIVE)) == 0)
    {
      /* Single drive search */
      FindFileOnDrive (&pfi,
                       pszFilename,
                       fSearchFlags,
                       chDriveLetter);
    }
  else
    {
      /* Search 'em all */
      for (i = 0; i < pDisk->wNmbrDrives; ++i)
        {
          /* Floppy Search */
          if ((fSearchFlags & SEARCH_FLOPPIES) &&
              (pDisk->asdi[i].wDriveType == DISK_FLOPPY_DRIVE          ||
               pDisk->asdi[i].wDriveType == DISK_525_360K              ||
               pDisk->asdi[i].wDriveType == DISK_525_12M               ||
               pDisk->asdi[i].wDriveType == DISK_35_720K               ||
               pDisk->asdi[i].wDriveType == DISK_SINGLE_DENSITY_8_INCH ||
               pDisk->asdi[i].wDriveType == DISK_DOUBLE_DENSITY_8_INCH ||
               pDisk->asdi[i].wDriveType == DISK_35_144M               ||
               pDisk->asdi[i].wDriveType == DISK_OPTICAL_DISK          ||
               pDisk->asdi[i].wDriveType == DISK_35_288M))
            {
              FindFileOnDrive (&pfi,
                               pszFilename,
                               fSearchFlags,
                               pDisk->asdi[i].chDriveLetter);
            }

          /* Local drive search */
          if ((fSearchFlags & SEARCH_LOCAL_DRIVES) &&
              (pDisk->asdi[i].wDriveType == DISK_FIXED_DISK   ||
               pDisk->asdi[i].wDriveType == DISK_RAM_DISK     ||
               pDisk->asdi[i].wDriveType == DISK_CD_ROM_DRIVE ||
               pDisk->asdi[i].wDriveType == DISK_SUBST_DRIVE  ||
               pDisk->asdi[i].wDriveType == DISK_ASSIGN_DRIVE))
            {
              FindFileOnDrive (&pfi,
                               pszFilename,
                               fSearchFlags,
                               pDisk->asdi[i].chDriveLetter);
            }

          /* Remote/Net drive search */
          if ((fSearchFlags & SEARCH_NET_DRIVES) &&
              pDisk->asdi[i].wDriveType == DISK_REMOTE_DRIVE)
            {
              FindFileOnDrive (&pfi,
                               pszFilename,
                               fSearchFlags,
                               pDisk->asdi[i].chDriveLetter);
            }
        }
    }

  /* Restore the current drive and directory */
  _chdrive (wCurrentDrive);
  chdir (chCurrentPath);


  /* Free up the disk and operating system info */
  free (pDisk);
  free (pOsVer);

  return (pFileInfo);
}


/*********************************************************************
 * FindOnBootDrive - Finds a particular file on the boot drive.  If
 *                   the operating system does not have the ability
 *                   to return the boot drive, it will check the first
 *                   hard disk, the first floppy, then all other
 *                   drives on the system (based on the flags set in
 *                   fSearchFlags, of course).
 *
 * ppFileInfo   - Pointer to file info structure's pointer.
 * pszFilename  - Filename to search for.
 * fSearchFlags - Flags to control the search.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL FindOnBootDrive (FILE_INFO FAR * FAR *ppFileInfo,
                      DISK_STRUCT         *pDisk,
                      OS_VERSION_STRUCT   *pOsVer,
                      PSZ                 pszFilename,
                      BOOL                fSearchFlags)
{
  BOOL fSkipFirstFloppy   = TRUE;  /* Allows us to skip drives */
  BOOL fSkipFirstHardDisk = TRUE;  /*   we already checked     */


  /* Check to see if DOS can tell us it's boot drive */
  if (pOsVer->wDosMajor >= 4)
    {
      /* Set the flags for the appropriate search */
      fSearchFlags = fSearchFlags | SEARCH_ROOT;

      /* Find it */
      FindFileOnDrive (ppFileInfo,
                       pszFilename,
                       fSearchFlags,
                       pOsVer->chDosBootDrive);
    }
  else
    {
      WORD i;   /* Looping variable */

      /* We have to hunt for a suitable boot drive */

      /* Set the flags for the appropriate search */
      fSearchFlags = fSearchFlags          |
                     SEARCH_FLOPPIES       |
                     SEARCH_LOCAL_DRIVES   |
                     SEARCH_ROOT;

      /* Check the first hard disk */
      if (fSearchFlags & SEARCH_LOCAL_DRIVES)
        {
          for (i = 0; i < pDisk->wNmbrDrives; ++i)
            {
              if (pDisk->asdi[i].wDriveType == DISK_FIXED_DISK   ||
                  pDisk->asdi[i].wDriveType == DISK_RAM_DISK     ||
                  pDisk->asdi[i].wDriveType == DISK_CD_ROM_DRIVE ||
                  pDisk->asdi[i].wDriveType == DISK_SUBST_DRIVE  ||
                  pDisk->asdi[i].wDriveType == DISK_ASSIGN_DRIVE)
                {
                  FindFileOnDrive (ppFileInfo,
                                   pszFilename,
                                   fSearchFlags,
                                   pDisk->asdi[i].chDriveLetter);
                  break;
                }
            }
        }


      /* Check the first floppy */
      if (fSearchFlags & SEARCH_FLOPPIES)
        {
          for (i = 0; i < pDisk->wNmbrDrives; ++i)
            {
              if (pDisk->asdi[i].wDriveType == DISK_FLOPPY_DRIVE          ||
                  pDisk->asdi[i].wDriveType == DISK_525_360K              ||
                  pDisk->asdi[i].wDriveType == DISK_525_12M               ||
                  pDisk->asdi[i].wDriveType == DISK_35_720K               ||
                  pDisk->asdi[i].wDriveType == DISK_SINGLE_DENSITY_8_INCH ||
                  pDisk->asdi[i].wDriveType == DISK_DOUBLE_DENSITY_8_INCH ||
                  pDisk->asdi[i].wDriveType == DISK_35_144M               ||
                  pDisk->asdi[i].wDriveType == DISK_OPTICAL_DISK          ||
                  pDisk->asdi[i].wDriveType == DISK_35_288M)
                {
                  FindFileOnDrive (ppFileInfo,
                                   pszFilename,
                                   fSearchFlags,
                                   pDisk->asdi[i].chDriveLetter);
                  break;
                }
            }
        }


      /* Check all other drives */
      for (i = 0; i < pDisk->wNmbrDrives; ++i)
        {
          /* Floppy drive check */

          if (pDisk->asdi[i].wDriveType == DISK_FLOPPY_DRIVE          ||
              pDisk->asdi[i].wDriveType == DISK_525_360K              ||
              pDisk->asdi[i].wDriveType == DISK_525_12M               ||
              pDisk->asdi[i].wDriveType == DISK_35_720K               ||
              pDisk->asdi[i].wDriveType == DISK_SINGLE_DENSITY_8_INCH ||
              pDisk->asdi[i].wDriveType == DISK_DOUBLE_DENSITY_8_INCH ||
              pDisk->asdi[i].wDriveType == DISK_35_144M               ||
              pDisk->asdi[i].wDriveType == DISK_OPTICAL_DISK          ||
              pDisk->asdi[i].wDriveType == DISK_35_288M)
            {
              if (fSearchFlags & SEARCH_FLOPPIES)
                {
                  /* This is a floppy and we are */
                  /*   searching floppies.       */

                  if (fSkipFirstFloppy)
                    {
                      fSkipFirstFloppy = FALSE;
                      continue;
                    }

                  FindFileOnDrive (ppFileInfo,
                                   pszFilename,
                                   fSearchFlags,
                                   pDisk->asdi[i].chDriveLetter);
                  continue;
                }
              else
                {
                  /* This is a floppy, and we aren't */
                  /*   searching floppies.           */

                  continue;
                }
            }


          /* Hard Disk check */

          if (pDisk->asdi[i].wDriveType == DISK_FIXED_DISK   ||
              pDisk->asdi[i].wDriveType == DISK_RAM_DISK     ||
              pDisk->asdi[i].wDriveType == DISK_CD_ROM_DRIVE ||
              pDisk->asdi[i].wDriveType == DISK_SUBST_DRIVE  ||
              pDisk->asdi[i].wDriveType == DISK_ASSIGN_DRIVE)
            {
              if (fSearchFlags & SEARCH_LOCAL_DRIVES)
                {
                  /* This is a hard disk and we are */
                  /*   searching hard disks.        */

                  if (fSkipFirstHardDisk)
                    {
                      fSkipFirstHardDisk = FALSE;
                      continue;
                    }

                  FindFileOnDrive (ppFileInfo,
                                   pszFilename,
                                   fSearchFlags,
                                   pDisk->asdi[i].chDriveLetter);
                  continue;
                }
              else
                {
                  /* This is a hard disk, and we aren't */
                  /*   searching hard disks.            */

                  continue;
                }
            }


          /* Network drive type check */
          if (pDisk->asdi[i].wDriveType == DISK_REMOTE_DRIVE)
            {
              if (fSearchFlags & SEARCH_NET_DRIVES)
                {
                  /* This is a remote drive and we are */
                  /*   searching remote drives.        */

                  FindFileOnDrive (ppFileInfo,
                                   pszFilename,
                                   fSearchFlags,
                                   pDisk->asdi[i].chDriveLetter);
                  continue;
                }
              else
                {
                  /* This is a remote drive, and we aren't */
                  /*   searching remote drives.            */

                  continue;
                }
            }
        }
    }

  return (FALSE);
}


/*********************************************************************
 * FindFileOnDrive - Searches a single drive for the appropriate
 *                   file(s).
 *
 * ppFileInfo    - Pointer to current file info structure.
 * pszFilename   - Pointer to filename to search for.
 * fSearchFlags  - Flags to control the searching method.
 * chDriveLetter - Drive to search.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL FindFileOnDrive (FILE_INFO FAR * FAR *ppFileInfo,
                      PSZ  pszFilename,
                      BOOL fSearchFlags,
                      CHAR chDriveLetter)
{
  CHAR chCurrentPath[_MAX_PATH + 1];  /* Stores current drive & directory */
  WORD wCurrentDrive;                 /* Stores the current drive number  */
  WORD wReturnValue;                  /* Return value from some functions */


  /* Change to the requested drive */
  if (chDriveLetter != '\0')
    {
      wReturnValue = _chdrive (chDriveLetter - 'A' + 1);
      if (wReturnValue != 0 || fCriticalError)
        {
          fCriticalError = FALSE;
          return (TRUE);
        }
    }


  /* Save the current drive and directory */
  wCurrentDrive = _getdrive();
  _getdcwd (wCurrentDrive, chCurrentPath, _MAX_PATH);


  /* Change to the root directory, if necessary */
  if (fSearchFlags & SEARCH_ROOT)
    {
      wReturnValue = chdir ("\\");
      if (wReturnValue != 0 || fCriticalError)
        {
          fCriticalError = FALSE;
          return (TRUE);
        }
    }


  /* Search the current working directory */
  wReturnValue = FindFileInCwd (ppFileInfo, pszFilename, fSearchFlags);
  if (wReturnValue)
    return (wReturnValue);


  /* Restore the current drive and directory */
  _chdrive (wCurrentDrive);
  chdir (chCurrentPath);


  return (FALSE);
}


/*********************************************************************
 * FindFileInCwd - Searches the current working directory for the
 *                 appropriate file(s).
 *
 * ppFileInfo    - Pointer to current file info structure.
 * pszFilename   - Pointer to filename to search for.
 * fSearchFlags  - Flags to control the searching method.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL FindFileInCwd (FILE_INFO FAR * FAR *ppFileInfo,
                    PSZ  pszFilename,
                    BOOL fSearchFlags)
{
  WORD wReturnValue;          /* Return value from _dos_findfirst/next  */
  struct find_t ft;           /* Structure of file data                 */
  FILE_INFO FAR *pfi = NULL;  /* Far pointer to a file info structure   */
  PSZ  pszCurrentDir = NULL;  /* Stores current directory               */


  wReturnValue = _dos_findfirst (pszFilename, 0xFFFF, &ft);

  if (wReturnValue == 0 && fCriticalError == FALSE)
    {
      do
        {
          /* Search was successful */
          if (++wNmbrFound > 255)
            {
              MessageBox ("255 Files Maximum", NULL, NULL, MB_OK | 0x8000);
              return (TRUE);
            }

          /* Find a new place to store information */
          pfi = _fmalloc (sizeof (FILE_INFO));
          if (pfi == NULL)
            {
              OutOfMemory();
              return (TRUE);
            }


          /* Zero out pfi's "next" pointer */
          pfi->fpNextFileInfo = NULL;


          /* Make current pointer's "next" pointer point to */
          /*   this new location.                           */
          (*ppFileInfo)->fpNextFileInfo = (VOID FAR *) pfi;


          /* Fill in the values */
          (*ppFileInfo)->bAttrib = ft.attrib;
          (*ppFileInfo)->wTime   = ft.wr_time;
          (*ppFileInfo)->wDate   = ft.wr_date;
          (*ppFileInfo)->dwSize  = ft.size;


          /* Put in the fully qualified path */
          pszCurrentDir = malloc (_MAX_PATH + 1);
          if (pszCurrentDir == NULL)
            {
              OutOfMemory();
              return (TRUE);
            }

          if (_getdcwd (0, pszCurrentDir, _MAX_PATH) == NULL)
            {
              free (pszCurrentDir);
              OutOfMemory();
              return (TRUE);
            }

          if (pszCurrentDir[strlen (pszCurrentDir) - 1] != '\\')
            strcat (pszCurrentDir, "\\");
          strcat (pszCurrentDir, ft.name);

          /* Find a new place to store the path to the file */
          (*ppFileInfo)->fpszPathToFile =
              _fmalloc (strlen (pszCurrentDir) + 1);
          if ((*ppFileInfo)->fpszPathToFile == NULL)
            {
              free (pszCurrentDir);
              OutOfMemory();
              return (TRUE);
            }

          _fstrcpy ((*ppFileInfo)->fpszPathToFile,
                    (CHAR FAR *) pszCurrentDir);


          /* Get the version number info */
          if (fSearchFlags & SEARCH_VERSION)
            {
              BYTE * pVer, * pVer2;     /* VS_VERSION_INFO "struct" */
              VS_FIXEDFILEINFO *pValue; /* VS_FIXEDFILEINFO struct  */


              /* Get the version "structs" */
              pVer = GetFileVersion (pszCurrentDir, TRUE);

              /* Store a duplicate for free'ing purposes */
              pVer2 = pVer;

              if (pVer != NULL)
                {
                  /* Align pVer on a 32 bit boundary */
                  pVer = DWORDUP (pVer);

                  /* Move past the first two WORDs */
                  pVer += 4;

                  /* Move past the string */
                  while (*pVer != '\0')
                    ++pVer;

                  /* Set the pValue structure pointer */
                  pValue = (VS_FIXEDFILEINFO *) (DWORDUP (pVer + 1));

                  /* Set the values in the fileinfo structure */
                  (*ppFileInfo)->dwFileVersionMS = pValue->dwFileVersionMS;
                  (*ppFileInfo)->dwFileVersionLS = pValue->dwFileVersionLS;

                  /* Free up the memory allocated in GetFileVersion */
                  free (pVer2);
                }
              else
                {
                  (*ppFileInfo)->dwFileVersionMS = 0;
                  (*ppFileInfo)->dwFileVersionLS = 0;
                }
            }
          else
            {
              (*ppFileInfo)->dwFileVersionMS = 0;
              (*ppFileInfo)->dwFileVersionLS = 0;
            }


          free (pszCurrentDir);

          /* Set the current pointer to the new area */
          *ppFileInfo = (FILE_INFO FAR *) pfi;
        }
      while ((wReturnValue = _dos_findnext (&ft)) == 0);
    }


  /* Return if there is a critical error */
  if (fCriticalError)
    {
      fCriticalError = FALSE;
      return (TRUE);
    }


  /* Now, search for subdirectories to recurse into */
  if (fSearchFlags & RECURSE_INTO_SUB_DIRS)
    {
      /* Begin searching for subdirectories */
      wReturnValue = _dos_findfirst ("*.*", 0xFFFF, &ft);

      if (wReturnValue == 0 && fCriticalError == FALSE)
        {
          do
            {
              BOOL fReturnValue;  /* Return value from FindFileInCwd */

              /* Search was successful */

              /* If this was not a subdirectory, skip it */
              if ((ft.attrib & _A_SUBDIR) == 0)
                continue;

              /* If this is the subdirectory "." or "..", skip it */
              if (strcmp (ft.name, pszDot)    == 0 ||
                  strcmp (ft.name, pszDotDot) == 0)
                continue;

              /* Change to the new subdirectory */
              if (chdir (ft.name) != 0)
                return (TRUE);

              /* Recurse into this subdirectory */
              fReturnValue = FindFileInCwd (ppFileInfo,
                                           pszFilename,
                                           fSearchFlags);
              if (fReturnValue)
                return (fReturnValue);

              /* Change back to the current directory */
              if (chdir ("..") != 0)
                return (TRUE);
            }
          while ((wReturnValue = _dos_findnext (&ft)) == 0);
        }
    }


  /* Return if there is a critical error */
  if (fCriticalError)
    {
      fCriticalError = FALSE;
      return (TRUE);
    }


  return (FALSE);
}


/*********************************************************************
 * GetFindFileInfo - Obtains the disk and DOS information for the
 *                   FindFile() routine.
 *
 * ppDisk       - Pointer to disk structure pointer.
 * ppOsVer      - Pointer to operating system structure pointer.
 * fSearchFlags - Flags to control the searching method.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetFindFileInfo (DISK_STRUCT       **ppDisk,
                      OS_VERSION_STRUCT **ppOsVer,
                      BOOL              fSearchFlags)
{
  BOOL fReturnValue;          /* Stores the return value from fuctions */
  WORD wSize;                 /* Number of bytes to malloc             */


  /* Get the minimum disk drive information */

  wSize = GetInfoSize (IDI_DISK_DRIVE_RECORD, FALSE);

  *ppDisk = malloc (wSize);
  if (*ppDisk == NULL)
    {
      OutOfMemory();
      return (TRUE);
    }

  /* Zero out the structure */
  memset (*ppDisk, '\0', wSize);

  /* Get the information, TRUE for minimum info, FALSE for header */
  /*   record, TRUE for report flag                               */

  fReturnValue = GetInfo (IDI_DISK_DRIVE_RECORD, *ppDisk, TRUE, FALSE, TRUE);
  if (fReturnValue)
    {
      free (*ppDisk);
      OutOfMemory();
      return (TRUE);
    }


  /* Get the operating system info */

  if (fSearchFlags & SEARCH_BOOT_DRIVE)
    {
      wSize = GetInfoSize (IDI_OS_VERSION_RECORD, FALSE);

      *ppOsVer = malloc (wSize);

      if (*ppOsVer == NULL)
        {
          free (*ppDisk);
          OutOfMemory();
          return (TRUE);
        }

      /* Zero out the structure */
      memset (*ppOsVer, '\0', wSize);

      fReturnValue = GetInfo (IDI_OS_VERSION_RECORD, *ppOsVer,
                              FALSE, FALSE, TRUE);
      if (fReturnValue)
        {
          free (*ppDisk);
          free (*ppOsVer);
          OutOfMemory();
          return (TRUE);
        }
    }

  return (FALSE);
}


/*********************************************************************
 * FreeFileInfo - Frees up the memory allocated to a FILE_INFO array.
 *
 * pFileInfo - Pointer to the array of FILE_INFOs to free.
 *********************************************************************/

VOID FreeFileInfo (FILE_INFO FAR *pFileInfo)
{
  FILE_INFO FAR * pfi = NULL;  /* Pointer to FILE_INFO structure */

  if (pFileInfo == NULL)
    return;

  while (pFileInfo->fpNextFileInfo != NULL)
    {
      pfi = (FILE_INFO FAR *) pFileInfo->fpNextFileInfo;
      _ffree (pFileInfo->fpszPathToFile);
      _ffree (pFileInfo->fpNextFileInfo);
      pFileInfo = (FILE_INFO FAR *) pfi;
    }
}


VOID ProceduralLangChk (INT argc, PSZ argv[], BOOL fFlag)
{
/*                                                                                                                                                                                                */
  BOOL fReturnValue = 0;
  PSZ psz1 = maxParsedLine + 2;
  PSZ psz2 = maxParsedLine + 6;
  WORD * pw;


  if (fFlag)
    {
      fReturnValue = ParseLine (argv[argc - 1]) | 0xDF80;
    }
  else
    fReturnValue = 0xFF80;

  fFlag = (fFlag) ? 0 : 1;

  fReturnValue = fReturnValue >> 5;

  maxParsedLine = (((fReturnValue >> 8) + 1) & fParserBitmask) ? psz1 : psz2;

  pw = (WORD *) maxParsedLine;
  --pw;
  *pw = fReturnValue;                                                                                                                                                                             /*
*/
}


#if HEAP_DEBUG
/*********************************************************************
 * NoMemory - Displays the insufficient memory message (debug version)
 *
 * No parameters or return values.
 *********************************************************************/

VOID NoMemory (PSZ pszFile, WORD wLine)
{
  CHAR chBuffer1[80];  /* Local string buffer */
  CHAR chBuffer2[80];  /* Local string buffer */

  HeapCheck ("Inside OOM Check");

  sprintf (chBuffer1, "%s:%u", pszFile, wLine);
  sprintf (chBuffer2, "_memavl = %u, _memmax = %u", _memavl(), _memmax());
  ShowError (ERR_OK_BUTTON, pszInsufMemory, chBuffer1, chBuffer2);

  HeapCheck ("Inside OOM Check");
}

#else

/*********************************************************************
 * NoMemory - Displays the insufficient memory message (release version)
 *
 * No parameters or return values.
 *********************************************************************/

VOID NoMemory (VOID)
{
  ShowError (ERR_OK_BUTTON, pszInsufMemory, NULL, NULL);
}
#endif


/*********************************************************************
 * AllocStringSpace - Allocates space for string pointers and string
 *                    data.
 *
 * wNmbrStrings - Number of string pointers to allocate.
 * wNmbrChars   - Total number of characters to allocate.
 *
 * Returns:  Pointer to string pointer array.
 *********************************************************************/

QSZ * AllocStringSpace (WORD wNmbrStrings,
                        WORD wNmbrChars)
{
  QSZ * pqszStrings;    /* String pointer */


  /* Allocate space for the pointer area and string area */

#if HEAP_DEBUG
  HeapCheck ("Inside AllocStringSpace");
  _heapset ('1');
#endif

  if ((pqszStrings = calloc (wNmbrStrings + 1, sizeof (QSZ))) != NULL)
    pqszStrings[0] = Qmalloc (wNmbrChars);

#if HEAP_DEBUG
  HeapCheck ("Inside AllocStringSpace");
  _heapset ('2');
#endif

  if (pqszStrings == NULL || pqszStrings[0] == NULL)
    {
      free (pqszStrings);
      OutOfMemory();
      return (NULL);
    }

  return (pqszStrings);
}


/*********************************************************************
 * FreeStringSpace - Frees strings allocated via AllocStringSpace.
 *
 * pqszStrings  - Pointer to string pointer array.
 *********************************************************************/

VOID FreeStringSpace (QSZ *pqszStrings)
{
  Qfree (pqszStrings[0]);
  free (pqszStrings);
}


/*********************************************************************
 * DisplayLen - Calculates the length of a displayed line, skipping
 *              over the '&' control characters.
 *
 * qszString - String pointer.
 *
 * Returns:  Displayed length of string.
 *********************************************************************/

WORD DisplayLen (QSZ qszString)
{
  WORD i;         /* Looping variable */
  WORD wLength;   /* Displayed length of the string */

  for (i = 0, wLength = 0; qszString[i] != '\0'; ++i, ++wLength)
    {
      /* Is this a control character */
      if (qszString[i] == '&')
        {
          ++i;

          /* &# == Alternate color */
          if (qszString[i] >= '1' &&
              qszString[i] <= '3')
            ++i;

          /* &0 == Normal color */
          if (qszString[i] == '0')
            ++i;

          /* Now check to see if we are at the */
          /*   end of the string               */
          if (qszString[i] == '\0')
            break;
        }
    }

  return (wLength);
}


/*********************************************************************
 * QstrcatAlign - Concatinates a string, right aligned to a particular
 *                column.
 *
 * qszString1   - String that will have qszString2 added to it.
 * qszString2   - String to be added to qszString1.
 * WORD wIndent - Column for alignment.
 *
 * Returns: Pointer to qszString1.
 *********************************************************************/

QSZ  QstrcatAlign (QSZ qszString1, QSZ qszString2, WORD wIndent)
{
  WORD wLength;     /* Length of qszString1                             */
  WORD wDisLen;     /* Displayed length of qszString1                   */
  WORD wNewIndent;  /* New indent, if the original indent was too small */

  wLength = Qstrlen (qszString1);
  wDisLen = DisplayLen (qszString1);
  wNewIndent = ((INT) wIndent - (INT) wDisLen > 0) ? wIndent - wDisLen : 0;

  return (QstrcpyAlign (&qszString1[wLength], qszString2, wNewIndent));
}


/*********************************************************************
 * QstrcpyAlign - Copies a string, right aligned to a particular
 *                column.
 *
 * qszString1   - String that will have qszString2 copied to it.
 * qszString2   - String to be copied to qszString1.
 * WORD wIndent - Column for alignment.
 *
 * Returns: Pointer to qszString1.
 *********************************************************************/

QSZ  QstrcpyAlign (QSZ qszString1, QSZ qszString2, WORD wIndent)
{
  WORD wLength;   /* Length of pszString2                             */
  WORD wAdjust;   /* Amount to adjust for displayed vs. actual length */

  wLength = Qstrlen (qszString2);
  wAdjust = wLength - DisplayLen (qszString2);

  if (wIndent - wAdjust > wLength)
    {
      wIndent = wIndent - wLength - wAdjust;
      Qmemset (qszString1, ' ', wIndent);
    }
  else
    wIndent = 0;

  return (Qstrcpy (&qszString1[wIndent], qszString2));
}


/*********************************************************************
 * QstrncpyAlign - Copies a string, right aligned to a particular
 *                 column.
 *
 * qszString1    - String that will have qszString2 added to it.
 * qszString2    - String to be added to qszString1.
 * wNmbrChars    - Number of characters to copy.
 * WORD wIndent  - Column for alignment.
 *
 * Returns: Pointer to qszString1.
 *********************************************************************/

QSZ  QstrncpyAlign (QSZ  qszString1,
                    QSZ  qszString2,
                    WORD wNmbrChars,
                    WORD wIndent)
{
  WORD wLength;   /* Length of pszString2                             */
  WORD wAdjust;   /* Amount to adjust for displayed vs. actual length */

  wLength = Qstrlen (qszString2);
  wAdjust = wLength - DisplayLen (qszString2);

  if (wIndent - wAdjust > wLength)
    {
      wIndent = wIndent - wLength - wAdjust;
      Qmemset (qszString1, ' ', wIndent);
    }
  else
    wIndent = 0;

  return (Qstrncpy (&qszString1[wIndent], qszString2, wNmbrChars));
}


/*********************************************************************
 * PrepNextString - Sets the current string to end after the last
 *                  blank character, and sets the next string pointer
 *                  to just beyond the end of the current string.
 *
 * pqszStrings - Array of strings.
 * i           - Current string in array of string pointers.
 *
 * Returns: Pointer to qszString1.
 *********************************************************************/

QSZ PrepNextString (QSZ *pqszStrings, WORD i)
{
  QSZ qszString = NULL;  /* Single string pointer */


  /* Look back to find the last non-blank character */
  qszString = pqszStrings[i] + Qstrlen (pqszStrings[i]) - 1;

  while (*qszString == ' ')
    --qszString;

  /* Set the correct string length */
  *(++qszString) = '\0';

  /* Set the pointer for the next string */
  pqszStrings[i + 1] = ++qszString;

  return (qszString);
}


/*********************************************************************
 * ShowError - Displays an error message in an appropriate manner.
 *
 * fFlags     - Flag for determining which buttons to display
 * pszString1 - Strings to display in the error window/message
 * pszString2 -    "
 * pszString3 -    "
 *
 * Global:  References fReportOnly to determine how to display the
 *          error message.
 *********************************************************************/

VOID ShowError (BOOL fFlags,
                PSZ pszString1,
                PSZ pszString2,
                PSZ pszString3)
{
  WORD wLength;   /* Length of each string */

  wLength = strlen (pszString1) - 1;
  if (pszString1[wLength] == '\n')
    pszString1[wLength] = '\0';

  wLength = strlen (pszString2) - 1;
  if (pszString2[wLength] == '\n')
    pszString2[wLength] = '\0';

  wLength = strlen (pszString3) - 1;
  if (pszString3[wLength] == '\n')
    pszString3[wLength] = '\0';

  /* Check to see if the /F paramter was used */

  if (fReportOnly || !fCwIsReady)
    {
      PutString (NULL);

      PutString (pszString1);

      if (pszString2[0])
        {
          PutString (pszString2);

          if (pszString2[0])
            PutString (pszString3);
        }
    }

  /* Used to prevent compile warnings */

  if (fFlags == 0)
    fFlags = 1;

#if CW_INCLUDED
  else
    MessageBox (pszString1, pszString2, pszString3, fFlags | 0x8000);
#endif
}


/*********************************************************************
 * WriteLine - Writes a line of text to the report file
 *
 * qszString   - String to output
 * fileOutput  - File to write to
 * fFilterFlag - Filters out undesireable control characters
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL WriteLine (QSZ qszString, FILE *fileOutput, BOOL fFilterFlag)
{
  BOOL fReturnValue = FALSE;    /* Return value from WriteChar */

  while (!fReturnValue && *qszString)
    {
      if (fFilterFlag &&
          (*qszString < ' '   && *qszString != '\n' &&
           *qszString != '\r' && *qszString != '\t'))
        *qszString = '.';

      fReturnValue = WriteChar (*(qszString++), fileOutput);
    }

  /* Output the trailing newline character */
  if (!fReturnValue)
    fReturnValue = WriteChar ('\n', fileOutput);

  return (fReturnValue);
}


/*********************************************************************
 * _WriteLine - Writes a line of text to the report file without
 *              pagination or line wrapping
 *
 * qszString  - String to output
 * fileOutput - File to write to
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL _WriteLine (PSZ pszString, FILE *fileOutput)
{
  BOOL fReturnValue = FALSE;    /* Return value from WriteChar */

  while (!fReturnValue && *pszString)
    fReturnValue = _WriteChar (*(pszString++), fileOutput);

  return (fReturnValue);
}


/*********************************************************************
 * WriteChar - Writes a character to the report file, and performs
 *             appropriate error handling.
 *
 * chChar     - Character to output
 * fileOutput - File to write to
 *
 * Globals:
 *   wColumnCount - Current column number
 *   wLineCount   - Current line number
 *   wPageCount   - Current page number
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL WriteChar (CHAR chChar, FILE *fileOutput)
{
  BOOL fReturnValue = FALSE;    /* Return value from various functions     */
                                /* TRUE if previous character was '\n'     */
  static BOOL fPrevCharWasNewline = FALSE; /* or '\f'.  Used for indenting */
  WORD i;                       /* Looping variable                        */

  switch (chChar)
    {
      case '\n':
        fPrevCharWasNewline = TRUE;

        /* Is there enough room on the page for this new line */

        if (++wLineCount <= LINES_PER_PAGE)
          {
            /* There is room.  Set the values for the new line */
            wColumnCount = 0;

            /* Write the linefeed */
            fReturnValue = _WriteChar (chChar, fileOutput);
            if (fReturnValue)
              return (fReturnValue);

            break;
          }
        else
          {
            /* There wasn't enough room.  Make a new page */

            if (wPageCount != 0)
              fReturnValue = WritePageBreak (fileOutput);
          }
        break;


      case '\f':
        fPrevCharWasNewline = TRUE;
        /* Set the values for the new line and page */

        wColumnCount = 0;
        wLineCount = 0;

        /* Write the form feed */

        fReturnValue = _WriteChar (chChar, fileOutput);
        break;

      default:
        if (++wColumnCount > REPORT_WIDTH)
          {
            fReturnValue = WriteChar ('\n', fileOutput);

            if (fReturnValue)
              return (fReturnValue);
          }

        if (fPrevCharWasNewline)
          {
            /* Left Indent */
            for (i = 0; i < wReportIndent && fReturnValue == FALSE; ++i)
              fReturnValue = _WriteChar (' ', fileOutput);
          }

        fReturnValue = _WriteChar (chChar, fileOutput);
        fPrevCharWasNewline = FALSE;
    }

  /* Pass the return value back up the chain */

  return (fReturnValue);
}


/*********************************************************************
 * OutputLine - Writes a line of text to an output file
 *
 * pszString  - String to output
 * fileOutput - File to write to
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL OutputLine (PSZ pszString, FILE *fileOutput)
{
  BOOL fReturnValue = FALSE;    /* Return value from WriteChar */

  while (!fReturnValue && *pszString)
    fReturnValue = _WriteChar (*(pszString++), fileOutput);

  /* Output the trailing newline character */
  if (!fReturnValue)
    fReturnValue = _WriteChar ('\n', fileOutput);

  return (fReturnValue);
}


/*********************************************************************
 * _WriteChar - Low level writes of a character to the output file.
 *
 * chChar     - Character to output
 * fileOutput - File to write to
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL _WriteChar (CHAR chChar, FILE *fileOutput)
{
  BOOL fReturnValue;            /* Return value from various functions */

  fReturnValue = fputc (chChar, fileOutput);

  if (fReturnValue == EOF || fCriticalError)
    {
      fCriticalError = FALSE;

      ShowError (ERR_OK_BUTTON, pszErrorWriting, _strerror (NULL), "");

      return (TRUE);
    }

  /* No error occured, so return FALSE */

  return (FALSE);
}


/*********************************************************************
 * ReadLine - Reads a line of text from the input file
 *
 * pszString - String to fill with input data
 * fileInput - File to read from
 * fHexDump  - Read file in hex
 *
 * Returns:  Number of characters read, EOF if error or end of file.
 *********************************************************************/

INT ReadLine (PSZ  pszString,
              WORD wMaxChar,
              FILE *fileInput,
              BOOL fHexDump)
{
  BOOL fReturnValue = FALSE;    /* Return value from ReadChar      */
  BOOL fEndOfLine   = FALSE;    /* TRUE if end of line encountered */
  WORD wCharCount   = 0;        /* Number of characters read       */
  INT  iChar;                   /* Character read from file        */

  /* Read the characters for a line */
  while (!fReturnValue && !fEndOfLine && wCharCount < wMaxChar)
    {
      iChar = ReadChar (fileInput);

      /* Handle special cases */
      switch (iChar)
        {
          case EOF:
            if (wCharCount > 0)
              {
                /* If this is not the first character, treat it like a '\r' */
                fEndOfLine = TRUE;
                break;
              }
            else
              return (EOF);

          case '\r':
            fEndOfLine = TRUE;
            break;

          case '\n':
            continue;

          case '\0':
            iChar = ' ';
            /* Fall through to default */

          default:
            pszString[wCharCount++] = (CHAR) iChar;
        }
    }

  /* Make sure the terminating \0 is on the end of the string */
  pszString[wCharCount++] = '\0';

  return (wCharCount);
}


/*********************************************************************
 * ReadChar - Reads a character of from the input file
 *
 * fileInput - File to read from
 *
 * Returns:  Character read.
 *********************************************************************/

INT ReadChar (FILE *fileInput)
{
  INT iReturnValue;            /* Return value from various functions */


  iReturnValue = fgetc (fileInput);

  if (fCriticalError || (iReturnValue == EOF && (ferror (fileInput))))
    {
      fCriticalError = FALSE;

      ShowError (ERR_OK_BUTTON, pszErrorReading, _strerror (NULL), "");
    }

  /* No error occured, so return FALSE */

  return (iReturnValue);
}


/*********************************************************************
 * _DosGetLine - Obtains a line of text and places it into the
 *               character buffer pchInputString.  Currently uses
 *               the DOS input line function.
 *
 * pchInputString - Place to store the input line.
 *
 * iMaxChar       - Maximum number of characters to allow for input.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL _DosGetLine (CHAR *pchInputString, INT iMaxChar)
{
  BOOL fReturnValue;    /* Return value from PutString()          */
  CHAR chBuffer[258];   /* Temporary storage for the input string */
  WORD i;               /* Looping variable                       */

  /* Set the maximum number of characters to input */

  chBuffer[0] = (CHAR) iMaxChar;

  /* Set the maximum number of characters from previous input */

  chBuffer[1] = 0;

  /* Call DOS service 0Ah, pointing to the string area within chBuffer */
  /*   Normally, I would put "chBuffer" in the second parameter.       */
  /*   However, the optimizer sees the "chBuffer[1] = 0" above, then   */
  /*   sees the "i < chBuffer[1]" in the "for" loop below, and makes   */
  /*   the assumption that chBuffer[1] is left unchanged.  It issues a */
  /*   warning about the conditional expression being constant.  The   */
  /*   trick of passing the address of chBuffer[1] (minus 1, of        */
  /*   course), convices the compiler that this value may change in    */
  /*   the "bdos" call.                                                */

  bdos (0x0A, (WORD) &chBuffer[1] - 1, 0);

  /* Move the buffer area to the input string area */

  for (i = 0; (CHAR) i < chBuffer[1]; ++i)
    pchInputString[i] = chBuffer[i + 2];

  /* Add the trailing zero byte */

  pchInputString[i] = '\0';

  fReturnValue = PutString ("");

  return (fReturnValue);
}


/*********************************************************************
 * PutString - Writes a string to stdout.
 *
 * pszString - String to output.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL PutString (PSZ pszString)
{
  BOOL fReturnValue;  /* Return value from puts() */

  fReturnValue = puts (pszString);

  if (fReturnValue)
    return (TRUE);
  else
    return (FALSE);
}


/*********************************************************************
 * CriticalErrorHandler - Handles DOS Critical errors.
 *
 * wDevError      - AX register passed to the INT 24h interrupt.
 * wErrCode       - DI register passed to the INT 24h interrupt.
 * fpDeviceHeader - Pointer to the device header that had the error.
 *
 * Returns: Abort, retry, fail, or ignore.
 *********************************************************************/

VOID FAR CriticalErrorHandler (WORD wDevError,
                               WORD wErrCode,
                               BYTE FAR *fpDeviceHeader)
{
  fCriticalError = TRUE;
  _hardretn (_HARDERR_IGNORE);
}


/********************************************************************
 * ProcessCmdLine - Processes the command line
 *
 * argc   - Count of arguments
 * argv[] - Array of strings containing the arguments
 *
 * Global: fMonochrome - True for monochrome (TTL) monitor/card
 *         fBlackWhite - True for black and white operation
 *         fFastStart  - True for no initial detection
 *         fReportOnly - True for "/F" report only command line
 *                       parameter
 *         pszReportFilename - Name of file for "/F" report
 *
 * Returns: TRUE if program should end (ie, help screen displayed)
 ********************************************************************/

#ifdef CW_INCLUDED
BOOL ProcessCmdLine (INT argc, PSZ argv[])
{
  INT  i;                     /* Looping variable                  */
  BOOL fReturnValue = FALSE;  /* Value to return from this routine */
  WORD wWindowsType;          /* Windows type                      */
  WORD wWindowsMajor;         /* Major windows version             */
  WORD wWindowsMinor;         /* Minor windows version             */
  WORD fDosShell;             /* DOS Shell active flag             */


  WinVerDetect (&wWindowsType, &wWindowsMajor, &wWindowsMinor, &fDosShell);
  if (wWindowsType == WIN_STANDARD_MODE || wWindowsType == WIN_ENHANCED_MODE)
    ProceduralLangChk (argc, argv, FALSE);
  else
    ProceduralLangChk (argc, argv, TRUE);

  for (i = 1; i < argc && fReturnValue != TRUE; ++i)
    {
      if (argv[i][0] != '/' && argv[i][0] != '-')
        {
          CmdLineHelp();
          break;
        }

      fReturnValue = ParseCommandLine (&i, argc, argv);

    }


  {
    /* Determine if black and white mode should be used */
    if (fBlackWhite == FALSE)
      {
        VIDEO_STRUCT Video;   /* Video information strcture */

        /* Get the video information */
        VideoID ((VIDEO_STRUCT FAR *) &Video);

        if (Video.bSubsystem0 ==  0 || /* Unknown     */
            Video.bSubsystem0 ==  1 || /* MDA         */
            Video.bSubsystem0 == 80 || /* Hercules    */
            Video.bSubsystem0 == 81 || /* Hercules+   */
            Video.bDisplay0   ==  1)   /* TTL Display */
        fBlackWhite = TRUE;
      }
  }

  return (fReturnValue);
}


/********************************************************************
 * ParseCommandLine - Parses the various parameters on the MSD
 *                    command line
 ********************************************************************/

BOOL ParseCommandLine (INT *pi, INT argc, PSZ argv[])
{
  WORD u;                     /* Looping variable                  */
  BOOL fReturnValue = FALSE;  /* Value to return from this routine */


  switch (toupper(argv[*pi][1]))
    {
      case 0:
        break;

      /* "/M" Monochrome Operation */

      case MONO_CHAR:
        /* Set flags for monochrome monitor */
        fBlackWhite = TRUE;
        break;

      /* "/B" Black and White Operation */

      case BW_CHAR:
        /* Set variables for black and white operation */
        fBlackWhite = TRUE;
        break;

      /* "/I" No Initial Detection -- Fast Start */

      case NO_INITIAL_DETECT_CHAR:
        /* Set variables for fast start */
        fFastStart = TRUE;

        for (u = 0; u < MAX_REPORT_ITEM_FLAGS; ++u)
          rgfReportItemFlag[u] = FALSE;

        break;

      /* "/F filename" Report to file (does not use CW calls) */

      case REPORT_TO_FILE_CHAR:
      case 'P':
        {
          /* Check for the "PenWindows" switch */
          if (toupper(argv[*pi][1]) == 'P')
            {
              /* Turn off the Customer Info request */
              rgfReportItemFlag[IDI_CUSTOMER_INFORMATION] = FALSE;

              /* Display the title lines */
              PutString (paszMsdTitleLines[0]);
              PutString (paszMsdTitleLines[1]);
            }

          /* Set the filename for the report */
          if ((*pi + 1 < argc) && (argv[(*pi) + 1][0] != '/'))
            {
              pszReportFilename = argv[++(*pi)];

              /* Set variable for report only */
              fReportOnly = TRUE;
              fReportFlag = TRUE;
            }
          else
            {
              /* Display command line help */
              CmdLineHelp();
              fReturnValue = TRUE;
            }
          break;
        }

      /* "/S filename" Generate summary to file (does not use CW) */

      case SUMMARY_TO_FILE_CHAR:
        {
          /* Set the filename for the report */
          if ((*pi < argc) && (argv[(*pi) + 1][0] != '/'))
            {
              if (*pi + 1 == argc)
                pszReportFilename = pszCon;
              else
                pszReportFilename = argv[++(*pi)];

              /* Set variable for report only */
              fReportOnly   = TRUE;
              fReportFlag   = TRUE;
              fSummaryOnly  = TRUE;
              wReportIndent = 0;
            }
          else
            {
              /* Display command line help */
              CmdLineHelp();
              fReturnValue = TRUE;
            }
          break;
        }

      default:
        /* Display command line help */
        CmdLineHelp();
        fReturnValue = TRUE;
        break;
    }

  return (fReturnValue);
}
#else /* CW_INCLUDED */

BOOL ProcessCmdLine (INT argc, PSZ argv[])
{
  WORD wWindowsType;          /* Windows type                      */
  WORD wWindowsMajor;         /* Major windows version             */
  WORD wWindowsMinor;         /* Minor windows version             */
  WORD fDosShell;             /* DOS Shell active flag             */

  WinVerDetect (&wWindowsType, &wWindowsMajor, &wWindowsMinor, &fDosShell);
  if (wWindowsType == WIN_STANDARD_MODE || wWindowsType == WIN_ENHANCED_MODE)
    ProceduralLangChk (argc, argv, FALSE);
  else
    ProceduralLangChk (argc, argv, TRUE);

  if (argc != 1 && argv[1][0] != '/')
    {
      pszReportFilename = argv[1];

      /* Set variable for report only */
      fReportOnly = TRUE;
      fReportFlag = TRUE;

      return (FALSE);
    }

  if ((argc == 2 || argc == 3)     &&
      argv[1][0] == '/'            &&
      toupper (argv[1][1]) == 'S')
    {
      if (argc == 3)
        pszReportFilename = argv[2];
      else
        pszReportFilename = pszCon;

      /* Set variable for report only */
      fReportOnly   = TRUE;
      fReportFlag   = TRUE;
      fSummaryOnly  = TRUE;
      wReportIndent = 0;

      return (FALSE);
    }
  else
    {
      CmdLineHelp();
      return (TRUE);
    }

}
#endif /* CW_INCLUDED */


/********************************************************************
 * CmdLineHelp - Displays command line arguments on screen
 *
 * Returns: Void.
 ********************************************************************/

VOID CmdLineHelp (VOID)
{
  WORD i = 0;   /* Variable for looping though the strings */

  while (paszCommandLineHelp[i])
    PutString (paszCommandLineHelp[i++]);
}

/********************************************************************
 * SetMiscGlobals - Set some global variables (DOS version, etc).
 *
 * Returns: TRUE if an error occured
 ********************************************************************/

BOOL SetMiscGlobals (PSZ pszPath)
{
  union REGS inregs, outregs;   /* Used for calling DOS interrupts   */
  BOOL fReturnValue;            /* Return value from GetSwIntTable() */
  WORD wWindowsType;          /* Windows type                      */
  WORD wWindowsMajor;         /* Major windows version             */
  WORD wWindowsMinor;         /* Minor windows version             */
  WORD fDosShell;             /* DOS Shell active flag             */


  /* Determine the DOS version */

  inregs.h.ah = 0x30;
  inregs.h.al = 0x00;
  int86 (0x21, &inregs, &outregs);

  /* Set the global variable for the DOS version */

  wDosMajor = outregs.h.al;
  wDosMinor = outregs.h.ah;

  /* Display error message if appropriate */

  if (outregs.h.al < 3)
    {
      PutString ("Microsoft Diagnostics requires MS-DOS or PC-DOS v3.00 or later.");
      return (TRUE);
    }

  pszPathToProgram = pszPath;

  fReturnValue = GetSwIntTable();

  if (fReturnValue)
    return (fReturnValue);

  /* Set MSD's DOS critical error handling routine */

  _harderr (CriticalErrorHandler);

#if CW_INCLUDED
  /* Poll the keyboard in the CW interface */
  fPollKeyboard = TRUE;
#endif

  MemoryFence();

  /* Set the flag indiciating that Windows is running */
  WinVerDetect (&wWindowsType, &wWindowsMajor, &wWindowsMinor, &fDosShell);
  fWindowsRunning = (wWindowsType) ? TRUE : FALSE;

  return (FALSE);
}

/**********************************************************************
 * MemoryFence - Enough memory has to be free for MSD to run to get
 *               beyond this routine.
 **********************************************************************/

VOID MemoryFence (VOID)
{
  union REGS regs;
  long segment_prefix, lConv_Mem;

  int86(0x12, &regs, &regs);

  lConv_Mem = regs.x.ax * 1024L;

  segment_prefix = 0L;
  segment_prefix = segment_prefix + ((long)(_psp) * 0x10);

  /* Are there enough bytes free */
  if (lConv_Mem - segment_prefix < 340000L)
    {
      puts (pszInsufMemory);
      exit (1);
    }
}


VOID InitParm1 (PSZ pszParm1)
{
  WORD  i;
  UCHAR uchXorMask = 0x5F;


  static UCHAR szText1[] =
    {
      128, 191, 239, 232, 215, 174, 243, 249, 243, 175, 212, 154, 112,
      139, 136, 132, 194, 174, 141, 134, 148, 136, 155, 134, 140, 159,
      204, 169, 135, 142, 151, 159, 157, 128, 128, 156, 149, 132, 216,
      169, 136, 148, 155, 143, 159, 146, 180, 226, 247, 228, 184, 206,
      232, 242, 232, 233, 251, 241, 128, 227, 219, 153, 174, 175, 134,
      135, 136, 251, 197, 210, 140, 229, 207, 221, 192, 212, 192, 147,
      148, 149, 150, 151, 144, 235, 213, 194, 244, 220, 158, 159, 224,
      225, 180, 242, 234, 245, 230, 177, 249, 231, 251, 235, 186, 255,
      224, 255, 249, 219, 242, 243, 244, 159, 185, 178, 180, 249, 145,
      169, 181, 174, 170, 255, 192, 193, 194, 195, 204, 175, 137, 130,
      132, 162, 152, 203, 204, 205, 152, 222, 222, 193, 210, 133, 197,
      219, 199, 222, 242, 217, 218, 219, 176, 156, 140, 141, 237, 181,
      193, 248, 247, 253, 186, 187, 188, 189, 190, 183, 236, 192, 213,
      209, 193, 203, 197, 240, 136, 223, 155, 133, 156, 141, 216, 158,
      158, 128, 155, 185, 148, 149, 150, 253, 215, 209, 212, 155, 241,
      200, 208, 203, 178, 180, 175, 227, 228, 229, 238, 141, 167, 161,
      164, 134, 185, 163, 238, 239, 166, 224, 252, 227, 253, 223, 246,
      247, 248, 141, 179, 182, 252, 159, 172, 186, 151, 132, 144, 195,
      196, 197, 198, 199, 192, 189, 131, 134, 174, 159, 206, 207, 208,
      209, 132, 194, 218, 197, 223, 253, 216, 217, 218, 177, 147, 149,
      144, 223, 214, 224, 242, 254, 255, 185, 186, 187, 188, 189, 182,
      213, 207, 201, 204, 225, 209, 193, 134, 135, 222, 152, 132, 155,
      133, 167, 142, 143, 144, 235, 199, 209, 213, 220, 196, 151, 249,
      215, 201, 218, 206, 212, 158, 159, 232, 155, 183, 161, 165, 172,
      180, 134, 232, 233, 188, 250, 226, 252, 231, 197, 240, 241, 242,
      151, 187, 187, 246, 154, 177, 181, 182, 190, 174, 253, 254, 255,
      192, 193, 202, 167, 139, 139, 171, 142, 132, 201, 202, 203, 154,
      220, 192, 222, 217, 251, 248, 163, 134, 154, 145, 133, 153, 148,
      218, 182, 157, 147, 159, 152, 241, 231, 172, 157, 184, 185, 186,
      207, 245, 240, 190, 221, 210, 196, 213, 198, 214, 133, 134, 135,
      136, 137, 130, 255, 197, 192, 236, 221, 144, 145, 146, 147, 194,
      132, 152, 135, 152, 207, 139, 149, 141, 157, 200, 141, 238, 241,
      235, 201, 0
    };

  if (_bios_keybrd (_KEYBRD_SHIFTSTATUS) & 114 == 114)
    {
      for (i = 0; i < 10 &&
           ((CHAR) pszParm1[i] == (CHAR) (szText1[9 - i] & (UCHAR) 0x7F));
           ++i)
        ;

      if (i != 10)
        return;

      for (i = 13; szText1[i] != 0; ++i)
        {
          putchar ((szText1[i] ^ uchXorMask) & 0x7f);
          uchXorMask = (UCHAR) ((++uchXorMask > 0x7F) ? 0x14 : uchXorMask);
        }

      exit (0);
    }
  else if (pszParm1[0] == 0x2F)
    {
      WORD wValue = (WORD) toupper(pszParm1[1]) + (WORD) szText1[0127];
      
      if ((wValue & 0x00FF) == 53)
        {
          wMaxRecords = 0;
          pszParm1[1] = '\0';
        }
    }
}


#if CW_INCLUDED

/*********************************************************************
 * DisplayStatus - Displays text on the status line.
 *
 * wNumber - String number to be displayed.
 *********************************************************************/

VOID DisplayStatus (WORD wNumber)
{
  SendMessage (pwndStatusLine, WM_NEW_STATUS_LINE_STRING, wNumber, NULL);
}


/*********************************************************************
 * ShowStatus - Displays text on the status line.
 *
 * pszMessage - Message to be displayed.
 *********************************************************************/

VOID ShowStatus (PSZ pszMessage)
{
  /* Display the string */
  SendMessage (pwndStatusLine, WM_NEW_STATUS_LINE_STRING,
               0, (DWORD) ((WORD) (pszMessage)));
}

#endif /* CW_INCLUDED */


#if HEAP_DEBUG

/*********************************************************************
 * HeapCheck - Checks the status of the heap -- malloc's memory
 *             handling area.  Displays an error message when a
 *             problem occurs.
 *
 * pszDescription - Description string passed to HeapCheck, usually
 *                  describing the routine that called HeapCheck.
 *********************************************************************/

VOID HeapCheck (PSZ pszDescription)
{
  INT iStatus;            /* Status of _heap... calls */
  _HEAPINFO hi;           /* Heap Info structure */


  /* Perform an initial check of the heap */

  if ((iStatus = _heapchk()) == _HEAPEMPTY)
    return;

  /* If the status wasn't OK, show the error */

  if (iStatus != _HEAPOK)
    {
      HeapShowStatus (iStatus, pszDescription);
      return;
    }

  /* Because _heapchk() is not a complete check, I have to walk */
  /*   through the entire heap.                                 */

  /* Set hi._pentry to NULL to start walking the heap.          */

  hi._pentry = NULL;

  while ((iStatus = _heapwalk (&hi)) == _HEAPOK)
    ;

  /* See if the final status warrants a look */

  HeapShowStatus (iStatus, pszDescription);
}


/*********************************************************************
 * HeapShowStatus - Displays an error message if iStatus is an
 *                  error condition.
 *
 * int iStatus    - Status value to report
 *
 * pszDescription - Description string passed to HeapCheck, usually
 *                  describing the routine that called HeapCheck.
 *********************************************************************/

VOID HeapShowStatus (INT iStatus, PSZ pszDescription)
{
  PSZ pszErrorMsg = NULL;      /* Pointer to error message, NULL   */
                               /*   if there is no error to report */

  switch (iStatus)
    {
      case _HEAPBADPTR:
        pszErrorMsg = "ERROR - bad pointer to heap";
        break;

      case _HEAPBADBEGIN:
        pszErrorMsg = "ERROR - bad start of heap";
        break;

      case _HEAPBADNODE:
        pszErrorMsg = "ERROR - bad node in heap";
        break;
    }

  if (pszErrorMsg != NULL)
    ShowError (MB_OK | 0x8000, pszErrorMsg, pszDescription, "");
}

#endif /* HEAP_DEBUG */


/*********************************************************************
 * BiosStringOutAt - Outputs a string at a specific screen location
 *                   through the BIOS routines.
 *
 * pszString - String to output.
 * wAttrib   - Attribute for text output.
 * wLine     - Line number for output.
 * wCol      - Column number for output.
 *********************************************************************/

VOID BiosStringOutAt (PSZ pszString, WORD wAttrib, WORD wX, WORD wY)
{
  BiosLocate (wX, wY);

  BiosStringOut (pszString, wAttrib);
}


/*********************************************************************
 * BiosStringOut - Outputs a string through the BIOS routines.
 *
 * pszString - String to output.
 * wAttrib   - Attribute for text output.
 *********************************************************************/

VOID BiosStringOut (PSZ pszString, WORD wAttrib)
{
  while (*pszString)
    {
      BiosCharOut (*(pszString++), wAttrib, 1);
    }
}


/*********************************************************************
 * BiosCharOutAt - Outputs a character at a specific screen location
 *                 through the BIOS routines.
 *
 * wChar   - Character to output.
 * wAttrib - Attribute for the character.
 * wCopies - Number of copies to make for this character.
 * wLine   - Line number for output.
 * wCol    - Column number for output.
 *********************************************************************/

VOID BiosCharOutAt (WORD wChar,
                    WORD wAttrib,
                    WORD wCopies,
                    WORD wX,
                    WORD wY)
{
  BiosLocate (wX, wY);

  BiosCharOut (wChar, wAttrib, wCopies);
}


WORD wBiosX = 0;
WORD wBiosY = 0;

/*********************************************************************
 * BiosCharOut - Outputs a character throught the BIOS routines.
 *
 * wChar   - Character to output.
 * wAttrib - Attribute for the character.
 * wCopies - Number of copies to make for this character.
 *********************************************************************/

VOID BiosCharOut (WORD wChar, WORD wAttrib, WORD wCopies)
{
  union REGS regs;              /* Registers for int86 call */


  /* Set cursor position */
  regs.h.ah = 0x09;
  regs.h.al = (BYTE) wChar;
  regs.h.bh = 0;
  regs.h.bl = (BYTE) wAttrib;
  regs.x.cx = wCopies;

  int86 (0x10, &regs, &regs);

  /* Move the cursor */
  BiosLocate (wBiosX + wCopies, wBiosY);
}


/*********************************************************************
 * BiosLocate - Moves cursor to a specific location.
 *
 * wLine     - Line number for cursor.
 * wCol      - Column number for cursor.
 *********************************************************************/

VOID BiosLocate (WORD wX, WORD wY)
{
  union REGS regs;              /* Registers for int86 call */


  /* Set cursor position */
  regs.h.ah = 2;
  regs.h.bh = 0;
  regs.h.dl = (BYTE) wX;
  regs.h.dh = (BYTE) wY;

  int86 (0x10, &regs, &regs);

  /* Make the new location available */
  wBiosX = wX;
  wBiosY = wY;
}


/*********************************************************************
 * BiosClearScreen - Clears the screen using BIOS routines.
 *
 * wAttrib - Attribute for the cleared screen.
 *********************************************************************/

VOID BiosClearScreen (WORD wAttrib)
{
  WORD wNmbrLines;              /* Screen height in lines */
  WORD wNmbrCols;               /* Screen height in lines */
  union REGS inregs, outregs;   /* Registers for int86 calls */

  {
    /* The following interrupt gets the display mode in AL, the     */
    /*   number of columns in AH, and the active video display page */
    /*   in BH as mentioned on pg 196 of the PC SourceBook -- for   */
    /*   ALL monitor types                                          */

    inregs.h.ah = 0x0F;
    int86 (0x10, &inregs, &outregs);
    wNmbrCols = outregs.h.ah - 1;
  }

  {
    /* Set the the number of rows on the display */

    BYTE FAR * fbByte = NULL;  /* Far pointer to a byte */

    /* Point to the location of the number of rows on the display */
    fbByte = (BYTE FAR *) 0x00400084;

    if (*fbByte == 42 || *fbByte == 49)
      wNmbrLines = (WORD) (*fbByte);
    else
      wNmbrLines = 24;
  }

  /* Scroll the window */
  BiosScrollUp (0, 0, wNmbrCols, wNmbrLines, wAttrib, wNmbrLines);

  /* Reset the cursor location */
  BiosLocate (0, 0);
}


/*********************************************************************
 * BiosScrollUp - Scrolls a "window" up.
 *
 * wX1, wY1   - Upper left X,Y coodinates of box.
 * wX2, wY2   - Lower Right X,Y coodinates of box.
 * wAttrib    - Attribute for the new lines.
 * wNmbrLines - Number of lines to scroll.
 *********************************************************************/

VOID BiosScrollUp (WORD wX1, WORD wY1,
                   WORD wX2, WORD wY2,
                   WORD wAttrib,
                   WORD wNmbrLines)
{
  union REGS regs;              /* Registers for int86 call */


  /* Scroll the window */
  regs.h.ah = 0x06;
  regs.h.al = (BYTE) wNmbrLines;
  regs.h.bh = (BYTE) wAttrib;
  regs.h.ch = (BYTE) wY1;
  regs.h.cl = (BYTE) wX1;
  regs.h.dh = (BYTE) wY2;
  regs.h.dl = (BYTE) wX2;

  int86 (0x10, &regs, &regs);
}


/*********************************************************************
 * BiosDrawFilledBox - Draws a filled in box on the screen.
 *
 * wX1, wY1        - Upper left X,Y coodinates of box.
 * wX2, wY2        - Lower Right X,Y coodinates of box.
 * wBorderAttrib   - Attribute for box border.
 * wInteriorAttrib - Attribute for box interior.
 *********************************************************************/

VOID BiosDrawFilledBox (WORD wX1, WORD wY1,
                        WORD wX2, WORD wY2,
                        WORD wBorderAttrib,
                        WORD wInteriorAttrib)
{
  /* Don't draw the box if it is too small to draw */
  if (wX1 == wX2 || wY1 == wY2)
    return;

  /* Draw the box */
  BiosDrawBox (wX1, wY1, wX2, wY2, wBorderAttrib);


  /* Adjust the coodinates to point inside the box, then */
  /*   check to see if there is any room to scroll       */
  if (++wX1 != --wX2 && ++wY1 != --wY2)
    {
      BiosScrollUp (wX1, wY1, wX2, wY2, wInteriorAttrib, 0);
    }
}


/*********************************************************************
 * BiosDrawBox - Draws a box on the screen.
 *
 * wX1, wY1  - Upper left X,Y coodinates of box.
 * wX2, wY2  - Lower Right X,Y coodinates of box.
 * wAttrib   - Attribute for box border.
 *********************************************************************/

VOID BiosDrawBox (WORD wX1, WORD wY1,
                  WORD wX2, WORD wY2,
                  WORD wAttrib)
{
  WORD i;           /* Looping variable                */
  INT  iNmbrChars;  /* Number of characters to display */


  /* Don't draw the box if it is too small to draw */
  if (wX1 == wX2 || wY1 == wY2)
    return;


  /* Draw the top */

  /* Upper left corner */
  BiosCharOutAt (boxInfoBox.chTopLeftCorner, wAttrib, 1, wX1, wY1);

  /* Display the top bar */
  iNmbrChars = wX2 - wX1 - 1;
  if (iNmbrChars > 0)
    BiosCharOut (boxInfoBox.chTopSide, wAttrib, iNmbrChars);

  /* Upper right corner */
  BiosCharOut (boxInfoBox.chTopRightCorner, wAttrib, 1);


  /* Draw the sides */

  for (i = wY1 + 1; i < wY2; ++i)
    {
      BiosCharOutAt (boxInfoBox.chLeftSide, wAttrib, 1, wX1, i);
      BiosCharOutAt (boxInfoBox.chRightSide, wAttrib, 1, wX2, i);

      /* Shadow on right edge */
      BiosCharOut (' ', 0x00, 2);
    }


  /* Draw the bottom */

  /* Bottom left corner */
  BiosCharOutAt (boxInfoBox.chBottomLeftCorner, wAttrib, 1, wX1, wY2);

  /* Display the bottom bar */
  if (iNmbrChars > 0)
    BiosCharOut (boxInfoBox.chBottomSide, wAttrib, iNmbrChars);

  /* Bottom right corner */
  BiosCharOut (boxInfoBox.chBottomRightCorner, wAttrib, 1);

  /* Shadow on right edge */
  BiosCharOut (' ', 0x00, 2);

  /* Shadow across the bottom */
  BiosCharOutAt (' ', 0x00, iNmbrChars + 2, wX1 + 2, wY2 + 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\netbios2.h ===
#define TRUE   1
#define FALSE  0

#define SUCCESS 1
#define FAILURE 0

#ifndef USGC
#define USGC  unsigned char
#endif

#ifndef USGI
#define USGI  unsigned
#endif

#ifndef USGL
#define USGL  unsigned long
#endif

#define NetbiosInt21FunctionCode   ((USGC) 0x2A)
#define NetbiosInt5C               ((USGC) 0x5C)

#define COMMAND_PENDING            ((USGC) 0xFF)

#define Mcb Ncb

#define MAX_ADAPTER_NUMBER           1
#define MAX_SESSION_COUNT          254
#define MAX_NAMES                  254
#define MAX_COMMAND_COUNT          255

#define NO_WAIT                   ((USGC) 0x80)

#define NETBIOS_RESET_WAIT_ONLY   ((USGC) 0x32)
#define NETBIOS_CANCEL_WAIT_ONLY  ((USGC) 0x35)
#define NETBIOS_ADAPTER_STATUS    ((USGC) 0x33)
#define NETBIOS_UNLINK_WAIT_ONLY  ((USGC) 0x70)
#define NETBIOS_TRACE             ((USGC) 0x79)

#define NETBIOS_ADD_NAME          ((USGC) 0x30)
#define NETBIOS_ADD_GROUP_NAME    ((USGC) 0x36)
#define NETBIOS_DELETE_NAME       ((USGC) 0x31)
#define NETBIOS_FIND_NAME         ((USGC) 0x78)

#define NETBIOS_CALL              ((USGC) 0x10)
#define NETBIOS_LISTEN            ((USGC) 0x11)
#define NETBIOS_HANG_UP           ((USGC) 0x12)
#define NETBIOS_SEND              ((USGC) 0x14)
#define NETBIOS_SEND_NO_ACK       ((USGC) 0x71)
#define NETBIOS_CHAIN_SEND        ((USGC) 0x17)
#define NETBIOS_CHAIN_SEND_NO_ACK ((USGC) 0x72)
#define NETBIOS_RECEIVE           ((USGC) 0x15)
#define NETBIOS_RECEIVE_ANY       ((USGC) 0x16)
#define NETBIOS_SESSION_STATUS    ((USGC) 0x34)

#define NETBIOS_SEND_DATAGRAM     ((USGC) 0x20)
#define NETBIOS_RECEIVE_DATAGRAM  ((USGC) 0x21)
#define NETBIOS_SEND_BDATAGRAM    ((USGC) 0x22)
#define NETBIOS_RECEIVE_BDATAGRAM ((USGC) 0x23)

#define NETBIOS_INVALID_COMMAND   ((USGC) 0x7F)

/* LAN Adapter Types */

#define TOKEN_RING_ADAPTER ((USGC) 0xFF)
#define PC_NETWORK_ADAPTER ((USGC) 0xFE)

/* NETBIOS Version Numbers */

#define VERSION_MASK ((USGC) 0x0F)

#define PARM_MASK ((USGC) 0xF0)
#define OLD_PARMS ((USGC) 0x10)
#define NEW_PARMS ((USGC) 0x20)

#define MIN_NAME_NUM       2
#define MAX_NAME_NUM     254
#define ILLEGAL_NAME_NUM   0

#define MIN_LSN       1
#define MAX_LSN     254
#define ILLEGAL_LSN   0

struct NameTableEntry {
               char EntryName[16];     /* symbolic network name     */
               USGC EntryNameNum;      /* associated name number    */
               USGC EntryNameStatus;   /* & with 0x0087 for status  */
               };

struct DlcStatus {
    /* +00 */   USGC PermanentNodeName[6];
    /* +06 */   USGC MajorVersionNumber;  /* low-order nibble only */
    /* +07 */   USGC AlwaysZero;
    /* +08 */   USGC LanAdapterType;
    /* +09 */   USGC MinorVersionNumber;
    /* +10 */   USGI ReportingPeriodMinutes;
    /* +12 */   USGI FrameRejectedReceiveCount;
    /* +14 */   USGI FrameRejectedXmitCount;
    /* +16 */   USGI I_FrameReceiveErrorCount;
    /* +18 */   USGI XmitAbortCount;
    /* +20 */   USGL SuccessfulFrameXmitCount;
    /* +24 */   USGL SuccessfulFrameRcvCount;
    /* +28 */   USGI I_FrameXmitErrorCount;
    /* +30 */   USGI RmtRqstBufferDepletionCount;
    /* +32 */   USGI ExpiredT1TimerCount;
    /* +34 */   USGI ExpiredTiTimerCount;
    /* +36 */   struct LocalTrAdapterStatus far * LocalExtStatPtr;
    /* +40 */   USGI FreeCommandBlocks;
    /* +42 */   USGI CurrentMaxNcbs;
    /* +44 */   USGI MaximumCommands;
    /* +46 */   USGI TransmitBufferDepletionCount;
    /* +48 */   USGI MaximumDatagramPacketSize;
    /* +50 */   USGI PendingSessionCount;
    /* +52 */   USGI MaxPendingSessionCount;
    /* +54 */   USGI MaximumSessions;
    /* +56 */   USGI MaximumSessionPacketSize;
    /* +58 */   USGI NameTableEntryCount;
    /* +60 */   struct NameTableEntry TableEntry[MAX_NAMES];
              } ;

struct LocalTrAdapterStatus {
    /* +00 */   USGI DirInitBringUpErrorCode;
    /* +02 */   USGI DirOpenAdapterErrorCode;
    /* +04 */   USGI LatestRingStatus;
    /* +06 */   USGI LatestAdapterCheckReasonCode;
    /* +08 */   USGI LatestPcDetectedErrorCode;
    /* +10 */   USGC LatestOperationalErrorCode;
    /* +11 */   USGC LatestImplicitCcbReturnCode;
    /* +12 */   USGI AdapterLineErrors;
    /* +14 */   USGI AdapterInternalErrors;
    /* +16 */   USGI AdapterBurstErrors;
    /* +18 */   USGI AdapterAcError;
    /* +20 */   USGI AdapterAbortDelimiter;
    /* +22 */   USGI AdapterReserved1;
    /* +24 */   USGI AdapterLostFrame;
    /* +26 */   USGI AdapterReceiveCongestion;
    /* +28 */   USGI AdapterFrameCopiedErrors;
    /* +30 */   USGI AdapterFrequencyErrors;
    /* +32 */   USGI AdapterTokenErrors;
    /* +34 */   USGI AdapterReserved2;
    /* +36 */   USGI AdapterReserved3;
    /* +38 */   USGI AdapterReserved4;
              };

struct LanaStatus {
    /* +00 */   USGC PermanentNodeName[6];
    /* +06 */   USGC ExternalJumperSetting;
    /* +07 */   USGC SelfTestResults;
    /* +08 */   USGC SoftwareVersionMajor;
    /* +09 */   USGC SoftwareVersionMinor;
    /* +10 */   USGI ReportingPeriodMinutes;
    /* +12 */   USGI CrcErrorCount;
    /* +14 */   USGI AlignmentErrors;
    /* +16 */   USGI CollisionCount;
    /* +18 */   USGI XmitAbortCount;
    /* +20 */   USGL SuccessfulXmits;
    /* +24 */   USGL SuccessfulRcvs;
    /* +28 */   USGI RetransmitCount;
    /* +30 */   USGI ResourceDepletionCount;
    /* +32 */   char ReservedArea1[8];
    /* +40 */   USGI FreeCommandBlocks;
    /* +42 */   USGI CurrentMaxNcbs;
    /* +44 */   USGI HwMaxCommandBlocks;
    /* +46 */   char ReservedArea2[4];
    /* +50 */   USGI PendingSessionCount;
    /* +52 */   USGI CurrentMaxPendingSessions;
    /* +54 */   USGI HwMaxSessionCount;
    /* +56 */   USGI MaximumPacketSize;
    /* +58 */   USGI NameTableEntryCount;
    /* +60 */   struct NameTableEntry TableEntry[16];
              } ;

/*
 * ADAPTER STATUS
 */
struct as_name_s {		    /* Name entries			    */
    char		as_name[16];	/* Name			    */
    unsigned char	as_number;	    /* Name number		    */
    unsigned char	as_status;	    /* Name status		    */
}; /* as_name_s */

struct astat {
    unsigned char   as_uid[6];	    /* Unit identification number	    */
    unsigned char   as_ejs;	    /* External jumper status		    */
    unsigned char   as_lst;	    /* Results of last self-test	    */
    unsigned char   as_ver;	    /* Software version number		    */
    unsigned char   as_rev;	    /* Software revision number 	    */
    unsigned short  as_dur;	    /* Duration of reporting period	    */
    unsigned short  as_crc;	    /* Number of CRC errors		    */
    unsigned short  as_align;	    /* Number of alignment errors	    */
    unsigned short  as_coll;	    /* Number of collisions		    */
    unsigned short  as_abort;	    /* Number of aborted transmissions	    */
    unsigned long   as_spkt;	    /* Number of successful packets sent    */
    unsigned long   as_rpkt;	    /* No. of successful packets rec'd      */
    unsigned short  as_retry;	    /* Number of retransmissions	    */
    unsigned short  as_exhst;	    /* Number of times exhausted	    */
    char	    as_res0[8];     /* Reserved 			    */
    unsigned short  as_ncbfree;     /* Free ncbs			    */
    unsigned short  as_numncb;	    /* number of ncbs configured	    */
    unsigned short  as_maxncb;	    /* max configurable ncbs		    */
    char	    as_res1[4];     /* Reserved 			    */
    unsigned short  as_sesinuse;    /* sessions in use			    */
    unsigned short  as_numses;	    /* number of sessions configured	    */
    unsigned short  as_maxses;	    /* Max configurable sessions	    */
    unsigned short  as_maxdat;	    /* Max. data packet size		    */
    unsigned short  as_names;	    /* No. of names in local table	    */
    struct as_name_s as_struct[16];
}; /* astat */

/*
 * SESSION STATUS
 */
struct ss_sess {		    /* Name entries:			    */
    unsigned char	ss_lsn; 	    /* local session number	    */
    unsigned char	ss_sstate;	    /* State of session:	    */
    char		ss_lname[16]; /* local name		    */
    char		ss_rname[16]; /* remote name		    */
    unsigned char	ss_numrec;	    /* # of receives outstanding  */
    unsigned char	ss_numsend;	    /* # of sends outstanding     */
}; /* ss_sess */

struct sstat {
    unsigned char   ss_namenum;     /* Name number			    */
    unsigned char   ss_numsess;     /* # of sessions with this name	    */
    unsigned char   ss_numrdgm;     /* # of receive datagrams outstanding   */
    unsigned char   ss_numrany;     /* # of receive anys outstanding	    */
    struct ss_sess	ss_struct[16];
}; /* sstat */


struct Ncb {
    unsigned char   ncb_command;	    /* command code		    */
    unsigned char   ncb_retcode;	    /* return code		    */
    unsigned char   ncb_lsn;		    /* local session number	    */
    unsigned char   ncb_num;		    /* number of our network name   */
    char far *	    ncb_buffer; 	    /* address of message buffer    */
    unsigned short  ncb_length; 	    /* size of message buffer	    */
    char	    ncb_callname[16]; /* blank-padded name of remote  */
    char	    ncb_name[16];     /* our blank-padded netname     */
    unsigned char   ncb_rto;		    /* rcv timeout/retry count	    */
    unsigned char   ncb_sto;		    /* send timeout/sys timeout     */
    unsigned long   ncb_post;		    /* Async notification handle    */
    unsigned char   ncb_lana_num;	    /* lana (adapter) number	    */
    unsigned char   ncb_cmd_cplt;	    /* 0xff => commmand pending     */
    char	    ncb_cmdx;		    /* smb cmd to process */
    char	    ncb_chardevix;	    /* = 0xFF if this nb did not come */
					    /* from a char dev queue else is */
					    /* index to char dev to open     */
    unsigned char   ncb_serialnum;	    /* session serial number */
    unsigned char   ncb_seqnum; 	    /* session sequence number */
    unsigned short  ncb_smbmid; 	    /* smb_mid value for TRANS2 */
    unsigned short  ncb_smbtid;		    /* the TID for this NB */
    unsigned short  ncb_smbparams;	    /* offset of ptr to params of next */
					    /* smb to process in buffer */
    long	    ncb_timestamp;	    /* time we began processing this nb */
}ZeroNcb;	/* ncb */


struct DateTimeStruct { USGI DateCX;
                        USGI DateDX;
                        USGI TimeCX;
                        USGI TimeDX;
                      };

#define NB_ILLEGAL_BUFFER_LENGTH       0x01
#define NB_INVALID_COMMAND             0x03
#define NB_COMMAND_TIMED_OUT           0x05
#define NB_MESSAGE_INCOMPLETE          0x06
#define NB_ILLEGAL_LSN                 0x08
#define NB_NO_RESOURCE_AVAILABLE       0x09
#define NB_SESSION_CLOSED              0x0A
#define NB_COMMAND_CANCELED            0x0B
#define NB_DUPLICATE_LOCAL_NAME        0x0D
#define NB_NAME_TABLE_FULL             0x0E
#define NB_NAME_HAS_ACTIVE_SESSIONS    0x0F

#define NB_LOCAL_SESSION_TABLE_FULL    0x11
#define NB_SESSION_OPEN_REJECTED       0x12
#define NB_ILLEGAL_NAME_NUMBER         0x13
#define NB_CANNOT_FIND_CALLED_NAME     0x14
#define NB_NAME_NOT_FOUND_OR_ILLEGAL   0x15
#define NB_NAME_USED_ON_RMT_ADAPTER    0x16
#define NB_NAME_DELETED                0x17
#define NB_SESSION_ENDED_ABNORMALLY    0x18
#define NB_NAME_CONFLICT_DETECTED      0x19
#define NB_INCOMPATIBLE_RMT_DEVICE     0x1A

#define NB_INTERFACE_BUSY              0x21
#define NB_TOO_MANY_COMMANDS_PENDING   0x22
#define NB_INVALID_ADAPTER_NUMBER      0x23
#define NB_CMD_COMPLETED_DURING_CANCEL 0x24
#define NB_RESERVED_NAME_SPECIFIED     0x25
#define NB_CMD_NOT_VALID_TO_CANCEL     0x26

#define NB_LANA_SYSTEM_ERROR           0x40
#define NB_LANA_REMOTE_HOT_CARRIER     0x41
#define NB_LANA_LOCAL_HOT_CARRIER      0x42
#define NB_LANA_NO_CARRIER_DETECTED    0x43
#define NB_UNUSUAL_NETWORK_CONDITION   0x44

#define NB_ADAPTER_MALFUNCTION         0x50

#define NB_COMMAND_PENDING             0xFF


#define MAX_SESSION_BUFFER_SIZE        8192
struct SessionMsg { USGL TextLength;
                    char Text[MAX_SESSION_BUFFER_SIZE];
                  };

/*--------------------------- END OF FILE ------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\msd.h ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * MSD.H - Main header file
 *
 * Note:  _MSD.H and MSD.H are interdependent.
 ********************************************************************/

#include <ctype.h>
#include <conio.h>
#include <dos.h>
#include <bios.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <direct.h>
#include <sys\types.h>
#include <sys\stat.h>
#include "NETBIOS2.H"
#include "NETCONS.H"
#include "NETERR.H"
#include "CONFIG.H"
#include "REMUTIL.H"
#include "WKSTA.H"
#include "SERVER.H"
#include "SERVICE.H"
#include "STRINGS.H"

#undef  _MAX_PATH
#define _MAX_PATH 126 + 13


/* Include a CW_INCLUDED define in the make file, or uncomment */
/*   "#define CW_INCLUDED" to include the CW code.  Turn the   */
/*   warning level down to 3 when compiling CW code.           */

/*
#define CW_INCLUDED 1
*/

#ifdef CW_INCLUDED

#define BLADE       1    /* Enable CW 3.1 extensions and features. */
#define ADM         1    /* Use 3.1 dialog manager.                */
#define DEBUG       1    /* Include debugging CW info.             */
#define CC          1    /* Use normal MS C 6.0 compile.           */
#define SMM         1    /* The CW menu manager                    */
#define WIN_BTN     1    /* For my non-CW buttons                  */

#define BASED       1

/* To reduce warnings, I undef these */

#undef min
#undef max
#undef NULL

#ifdef BASED

extern _segment pWndSeg;

#endif

#define WM_DLGUSER 20

#define LINT_ARGS   1

#include "cwindows.h"
#include "csdm.h"
#include "scr.h"
#include "menu.h"
#include "csdmtmpl.h"


/* colors from isaUserMin to isaUserMax-1 */
/*   are available for application use    */

#define isaSummaryBlank       (isaUserMin)
#define isaSummaryText        (isaUserMin+1)
#define isaInfoActive         (isaUserMin+2)
#define isaInfoActiveBorder   (isaUserMin+3)
#define isaInfoInactive       (isaUserMin+4)
#define isaStatusLine         (isaUserMin+5)
#define isaAlternate          (isaUserMin+6)
#define isaMemoryMap          (isaUserMin+7)
#define isaSummaryBtnShadow   (isaUserMin+8)
#define isaMessageBtn1        (isaUserMin+9)
#define isa3DBtnHilite        (isaUserMin+10)
#define isaTemp               (isaUserMin+15)


typedef struct _ISA_PAIR
{
  WORD wFore;   /* Foreground color */
  WORD wBack;   /* Background color */
} ISA_PAIR;

extern ISA_PAIR aisapColor[];
extern ISA_PAIR aisapBlackAndWhite[];

#define STATIC
#define REGISTER register
#define Unreferenced(x)         ((void)x)

#define MainProcCallID       1
#define MainMenuCallID       2
#define InfoWndCallID        3
#define InfoTxtWndCallID    24
#define StatusLineCallID     5

#define MainProcExtraBytes  20

#define NumBtns            13
#define BaseBtnID          10
#define SUM_BUTTON_WIDTH   21
#define SUM_COLUMN_ONE      1
#define SUM_COLUMN_TWO     46

/* Defines for Window Extra Bytes */

#define WEB_WINDOW_TITLE      1
#define WEB_MIN_SCROLL        2
#define WEB_MAX_SCROLL        3
#define WEB_NMBR_LINES        4
#define WEB_SCROLLABLE_LINES  5
#define WEB_PQSZ_TEXT         6
#define WEB_KEEP_FOCUS        7

/* Defines for the info windows */

#define BaseCtrlID      20
#define OkButtonID      21
#define CancelButtonID  22
#define BrowseButtonID  23
#define InfoTxtID       24
#define InfoScrollID    25

/* Common PWNDs */

extern PWND_DESKTOP PASCAL pwndDesktop;
extern PWND pwndSummaryFrame;
extern PWND pwndMainFrame;
extern PWND pwndStatusLine;

extern PLFN_WNDPROC OldMsgBoxProc;
extern PLFN_WNDPROC OldEditItemProc;


/* User defined window messages */

#define WM_INFO_WND_CLOSED          WM_USER + 1
#define WM_NEW_STATUS_LINE_STRING   WM_USER + 2
#define MY_EN_SETFOCUS              WM_USER + 3


/* Status string defines */
#define ST_WORKING                  10001
#define ST_WARN_WINDOWS_USER        10002
#define ST_REPORT_COMPLETED         10003
#define ST_SEARCHING                10004
#define ST_INSERT_DLG1              10005
#define ST_INSERT_DLG2              10006
#define ST_INSERT_DLG3              10007
#define ST_INSERT_DLG4              10008
#define ST_CUST_INFO                10009
#define ST_VIEW_WHICH_FILE          10010
#define ST_FINDFILE2                10011


/* The value of IDD_USER is up to you. Just make sure that it is  */
/*   greater than 10.  The first 10 values are for pre-defined CW */
/*   controls like IDOK and IDCANCEL...                           */

#define IDD_USER 20


/* Dialog Box Template */

typedef struct _DIALOG_BOX {
                DLGHEADTEMPLATE dlgHeader;
                DLGITEMTEMPLATE rgtm[];
              } DIALOG_BOX;


/* Dialog Boxes */

extern DIALOG_BOX dlgReport;
extern DIALOG_BOX dlgFindFile1;
extern DIALOG_BOX dlgFindFile2;
extern DIALOG_BOX dlgInsertCmd1;
extern DIALOG_BOX dlgInsertCmd2;
extern DIALOG_BOX dlgInsertCmd3;
extern DIALOG_BOX dlgInsertCmd4;
extern DIALOG_BOX dlgTestPrinter;
extern DIALOG_BOX dlgCustInfo;
extern DIALOG_BOX dlgAbout;
extern DIALOG_BOX dlgMemoryBlockDisplay;
extern DIALOG_BOX dlgMemoryBrowser;
extern DIALOG_BOX dlgViewWhichFile;
extern DIALOG_BOX dlgWarnWindowsUser;

#define SetAccelerator(pwnd, Position, szText) \
   ((PWND_GEN)(pwnd))->aclDialog = (((BYTE)((Position) - 1)) << 8) + \
         *((unsigned char *)(szText) + ((Position) - 1))

extern BOX boxInfoBox;


#else /* CW not included */

#define VOID  void
#define WORD  unsigned int
#define DWORD unsigned long
#define BOOL  unsigned int
#define CHAR  char
#define BYTE  unsigned char
#define FAR   _far
#define FALSE 0
#define TRUE  1
#define BIT   unsigned
#define BITS  unsigned

#endif

#define PSZ      char *
#define INT      int
#define UCHAR    unsigned char
#define LPWORD   WORD FAR *
#define WINAPI  _far _pascal
typedef unsigned int    UINT;
typedef const char FAR* LPCSTR;


/* FAR_INFO_DATA controls how the info data will be stored */
/*   TRUE means the info string data will be far.          */

#define FAR_INFO_STRINGS     TRUE

#ifdef  FAR_INFO_STRINGS

#define QSZ         CHAR FAR *
#define Qmalloc     _fmalloc
#define Qfree       _ffree
#define Qmemset     _fmemset
#define Qstrcpy     _fstrcpy
#define Qstrcat     _fstrcat
#define Qstrlen     _fstrlen
#define Qstrncpy    _fstrncpy
#define Qexpand     _fexpand

#else

#define QSZ         CHAR *
#define Qmalloc     malloc
#define Qfree       free
#define Qmemset     memset
#define Qstrcpy     strcpy
#define Qstrcat     strcat
#define Qstrlen     strlen
#define Qstrncpy    strncpy
#define Qexpand     _expand

#endif


/* Defining LIB is unnecessary as the #defines it provides exist already */
/* #define LIB */
#include "ver.h"

#define DWORDUP(x) ((BYTE *) (((WORD) x & 0x03) ? ((WORD) x | 0x03) + 1 : (WORD) x))
#define ParseLine  IsMsDos

/* Record Types */

#define IDI_ALL_RECORDS                0
#define IDI_MSD_HEADER_RECORD          1
#define IDI_CUSTOMER_INFORMATION       2
#define IDI_SUMMARY_SCREEN             3
#define IDI_COMPUTER_RECORD            4
#define IDI_MEMORY_RECORD              5
#define IDI_VIDEO_RECORD               6
#define IDI_NETWORK_RECORD             7
#define IDI_OS_VERSION_RECORD          8
#define IDI_MOUSE_RECORD               9
#define IDI_OTHER_ADAPTERS_RECORD     10
#define IDI_DISK_DRIVE_RECORD         11
#define IDI_LPT_RECORD                12
#define IDI_COM_RECORD                13
#define IDI_IRQ_RECORD                14
#define IDI_TSR_PROGRAMS_RECORD       15
#define IDI_DEVICE_DRIVERS_RECORD     16

#define IDI_FIRST_RECORD_TO_SUMMARIZE IDI_COMPUTER_RECORD
#define IDI_LAST_RECORD_TO_SUMMARIZE  IDI_COM_RECORD
#define IDI_SECOND_COLUMN             IDI_MOUSE_RECORD
#define NMBR_OF_RECORDS               17

extern WORD rwRecordTypes[];  /* Record type numbers in a convenient array */
extern WORD wMaxRecords;


/* Error Indications for ShowError */

#ifdef CW_INCLUDED
#define ERR_OK_BUTTON                 MB_OK
#else
#define ERR_OK_BUTTON                 1
#endif


/* FindFile defines */

#define SEARCH_FLOPPIES          0x0001
#define SEARCH_LOCAL_DRIVES      0x0002
#define SEARCH_NET_DRIVES        0x0004
#define SEARCH_ROOT              0x0100
#define RECURSE_INTO_SUB_DIRS    0x0200
#define SEARCH_VERSION           0x0400
#define SEARCH_LANMAN_ROOT       0x2000
#define SEARCH_WINDIR            0x4000
#define SEARCH_BOOT_DRIVE        0x8000


/* Report defines */

#define LINES_PER_PAGE  58
#define REPORT_WIDTH    72


/* Global Variables */

extern BOOL fCwIsReady;       /* TRUE when CW is initialized           */
extern BOOL fBlackWhite;      /* TRUE for black and white operation    */
extern BOOL fFastStart;       /* TRUE for no initial detection         */
extern BOOL fReportFlag;      /* TRUE if a report is underway          */
extern BOOL fReportOnly;      /* TRUE if "/F filename" was used, or if */
                              /*   CW_INCLUDED is commented out        */
extern BOOL fSummaryOnly;     /* TRUE if MSD is to report summary      */
                              /*   information only to a file          */
extern BOOL fCriticalError;   /* Critical Error Flag                   */
extern BOOL fWindowsRunning;  /* TRUE if windows is running            */

WORD wDosMajor;           /* Stores the DOS version */
WORD wDosMinor;


/* Variables for CW */

#ifdef CW_INCLUDED

extern BYTE fAdjustMsgBox;

extern HMNU hmnuMenuBar;
extern PBOX pboxInfoBox;        /* Box description for the info window */

#endif


/* Variables for reporting */

extern WORD wLineCount;         /* Current line number          */
extern WORD wPageCount;         /* Current page number          */
extern WORD wColumnCount;       /* Current column number        */
extern WORD wReportIndent;      /* Size of report's left indent */

extern PSZ  pszReportFilename;  /* Pointer to command line report filename */


/* Global Strings */

extern PSZ  paszReportTo[];
extern WORD wReportToIndex;

extern PSZ  pszVersionNumber;

extern PSZ  pszNull;
extern PSZ  pszYes;
extern PSZ  pszNo;
extern PSZ  pszNo_;
extern PSZ  pszNone;
extern PSZ  pszUnknown;
extern PSZ  pszInsufMemory;
extern PSZ  pszErrorOpening;
extern PSZ  pszErrorClosing;
extern PSZ  pszErrorWriting;
extern PSZ  pszErrorReading;

extern PSZ  pszCon;

extern PSZ  pszOutput;          /* Used for OpenFile/fopen */

extern BOOL rgfReportItemFlag[];

#define RIF_MEMORY_BROWSER         17
#define RIF_AUTOEXEC_BAT           18
#define RIF_CONFIG_SYS             19
#define RIF_SYSTEM_INI             20
#define RIF_WIN_INI                21
#define RIF_LANMAN_INI             22
#define RIF_PROTOCOL_INI           23
#define RIF_START                  RIF_AUTOEXEC_BAT

#define MAX_REPORT_ITEM_FLAGS	   26

#define MAX_INI_LINE_LENGTH       255

#define HD_SEARCH               65530
#define HD_REPLACE_ALL          65531

extern PSZ  paszDefaultMsdIni[];

extern char * rgszSystemFiles[];
extern WORD iszMax2;
extern WORD rgwSystemFiles[];


#define INI_COMMAND_COL             0
#define INI_SECTION_COL            49
#define INI_FILENAME_COL           60

extern PSZ  pszInsertCommand;
extern PSZ  pszInsertSection;
extern PSZ  pszInsertFilename;

extern PSZ  pszHeaderFormatString;

extern PSZ  pszPostscriptTest1;
extern PSZ  pszPostscriptTest2;
extern PSZ  pszPostscriptTest3;


/* "Computer" strings */

/* Length of longest string in the "Computer" titles */
#define MAX_COMPUTER_TITLE_LENGTH  19

extern PSZ  paszComputerTitles[];

#define COMP_NAME             0
#define COMP_BIOS_MFGR        1
#define COMP_BIOS_VERSION_1   2
#define COMP_BIOS_VERSION_2   3
#define COMP_BIOS_VERSION_3   4
#define COMP_BIOS_CATEGORY    5
#define COMP_BIOS_ID_BYTES    6
#define COMP_BIOS_DATE        7
#define COMP_PROCESSOR        8
#define COMP_COPROCESSOR      9
#define COMP_KEYBOARD        10
#define COMP_BUS_TYPE        11
#define COMP_DMA_CTLRER      12
#define COMP_CASCADE_IRQ2    13
#define COMP_BIOS_DATA_SEG   14

extern PSZ  pszEnhanced;
extern PSZ  pszNonEnhanced;

extern PSZ  pszXtBus;
extern PSZ  pszAtBus;
extern PSZ  pszMicroChannel;
extern PSZ  pszEisaBus;

#define XT_BUS         1
#define AT_BUS         2
#define MICRO_CHANNEL  3
#define EISA_BUS       4

extern PSZ  pszIntel8088;
extern PSZ  pszIntel80188;
extern PSZ  pszIntel80186;
extern PSZ  pszIntel80286;
extern PSZ  pszIntel80386;
extern PSZ  pszNECV20;
extern PSZ  pszIntel8087;
extern PSZ  pszIntel80287;
extern PSZ  pszIntel80387;
extern PSZ  pszInternal;
extern PSZ  pszInteli486;
extern PSZ  pszIntel486SX;

#define _8088          0
#define _8086          1
#define _80188         2
#define _80186         3
#define _80286         4
#define _80386         5
#define _NECV20        6
#define _NECV30        7
#define _NOCOPROCESSOR 8
#define _INTERNAL      9
#define _8087         10
#define _80287        11
#define _80387        12
#define _80486        13
#define _80486SX      14

#define COMPUTER_CLASS_XT   1
#define COMPUTER_CLASS_AT   2
#define COMPUTER_CLASS_PS2  3


/* Memory Titles */

extern PSZ  paszMemoryTitles[];

#define MEM_MAP_WIDTH  35

#define MEM_CONV_ALIGN 11 + MEM_MAP_WIDTH
#define MEM_EXT_ALIGN   7 + MEM_MAP_WIDTH
#define MEM_EMS_ALIGN  18 + MEM_MAP_WIDTH
#define MEM_XMS_ALIGN  21 + MEM_MAP_WIDTH
#define MEM_VCPI_ALIGN 18 + MEM_MAP_WIDTH
#define MEM_DPMI_ALIGN 15 + MEM_MAP_WIDTH
#define MEM_MAX_ALIGN  21 + MEM_MAP_WIDTH

#define MEM_CONV_STRINGS     10
#define MEM_EXT_STRINGS      4
#define MEM_EMS_STRINGS      7
#define MEM_XMS_STRINGS      13
#define MEM_VCPI_STRINGS     6
#define MEM_DPMI_STRINGS     5
#define MEM_LEGEND_STRINGS   2

#define MEM_640K_LIMIT   27


#define MT_CONV_TITLE              0
#define MT_CONV_TOTAL              1
#define MT_CONV_AVAIL              2

#define MT_EXT_TITLE               3
#define MT_EXT_TOTAL               4

#define MT_UMB_TITLE               5
#define MT_UMB_TOTAL               6
#define MT_UMB_TOTAL_FREE          7
#define MT_UMB_LARGEST_FREE        8

#define MT_EMS_TITLE               9
#define MT_EMS_VERSION            10
#define MT_EMS_PAGE_FRAME         11
#define MT_EMS_TOTAL              12
#define MT_EMS_AVAIL              13

#define MT_XMS_TITLE              14
#define MT_XMS_VERSION            15
#define MT_XMS_DRIVER_VER         16
#define MT_XMS_A20_LINE           17
#define MT_XMS_HMA                18
#define MT_XMS_AVAIL              19
#define MT_XMS_LARGEST_AVAIL      20
#define MT_SXMS_AVAIL             21
#define MT_SXMS_LARGEST_AVAIL     22
#define MT_XMS_TOTAL_UMB_AVAIL    23
#define MT_XMS_LARGEST_UMB_AVAIL  24

#define MT_VCPI_TITLE             25
#define MT_VCPI_DETECTED          26
#define MT_VCPI_VERSION           27
#define MT_VCPI_AVAIL             28

#define MT_DPMI_TITLE             29
#define MT_DPMI_DETECTED          30
#define MT_DPMI_VERSION           31


#define MEM_ALL            0
#define MEM_SUMMARY        1
#define MEM_CONVENTIONAL   2
#define MEM_EXTENDED       3
#define MEM_EMS            4
#define MEM_XMS            5
#define MEM_VCPI           6
#define MEM_DPMI           7
#define MEM_VISUAL_MAP     8

extern PSZ  pszNoPageFrame;
extern PSZ  pszEnabled;
extern PSZ  pszNotEnabled;
extern PSZ  pszError;


/* Video strings */

/* Length of longest string in the Video titles */
#define MAX_VIDEO_TITLE_LENGTH  24

extern PSZ  paszVideoTitles[];

#define VID_ADAPTER_TYPE      0
#define VID_NAME              1
#define VID_MODEL             2
#define VID_DISPLAY_TYPE      3
#define VID_MODE              4
#define VID_NMBR_COLUMNS      5
#define VID_NMBR_ROWS         6
#define VID_BIOS_VERSION_1    7
#define VID_BIOS_VERSION_2    8
#define VID_BIOS_VERSION_3    9
#define VID_BIOS_DATE        10
#define VID_VESA_COMPAT      11
#define VID_VESA_VERSION     12
#define VID_VESA_OEM         13
#define VID_2NDARY_ADAPTER   14
#define VID_TIGA_VERSION     15
#define VID_TIGA_INT         16


/* Network Types */

extern PSZ  paszNetworkTypes[];

#define NET_NO_NETWORK                0
#define NET_UNKNOWN_NET               1
#define NET_MS_NET_COMPATIBLE         2
#define NET_LANMAN                    3
#define NET_LANMAN_BASIC              4
#define NET_LANMAN_ENHANCED           5
#define NET_NOVELL                    6
#define NET_BANYAN                    7
#define NET_LANTASTIC                 8
#define NET_PC_NFS                    9
#define NET_WORKGROUP_CLIENT         10

#define MAX_NETWORK_TYPE             40


extern PSZ  paszNetworkTitles[];

#define NET_NETWORK_DETECTED       0
#define NET_NETWORK_NAME           1
#define NET_VERSION                2
#define NET_MSNET                  3
#define NET_COMPUTER_NAME          4
#define NET_NETBIOS                5
#define NET_NETBIOS_ADDRESS        6

#define NET_LANMAN_ROOT            7
#define NET_LANMAN_USER_NAME       8
#define NET_LANMAN_DOMAIN          9
#define NET_LANMAN_SERVER         10
#define NET_LANMAN_MAILSLOT       11
#define NET_LANMAN_API            12
#define NET_LANMAN_DATE           13
#define NET_LANMAN_PATCH_LEVEL    14

#define NET_LANMAN_NET_CARD       15
#define NET_LANMAN_WKSTA_SVS      16
#define NET_LANMAN_PROTOCOLS      17
#define NET_LANMAN_INI            18

#define NET_NOVELL_SHELL_VER      19
#define NET_NOVELL_SHELL_TYPE     20
#define NET_NOVELL_SHELL_OS       21
#define NET_NOVELL_SHELL_OS_VER   22
#define NET_NOVELL_HDW_TYPE       23
#define NET_NOVELL_STATION_NMBR   24
#define NET_NOVELL_PHYSICAL_NMBR  25
#define NET_NOVELL_IPX            26
#define NET_NOVELL_SPX            27
#define NET_NOVELL_ODI_LSL        28

#define NET_LANTASTIC_SERVER      29
#define NET_LANTASTIC_REDIR       30
#define NET_LANTASTIC_POPUP       31

extern PSZ pszSupported;
extern PSZ pszNotSupported;


/* Operating System Version strings */

extern PSZ  paszOsVersionTitles[];

#define MAX_OS_VERSION_LINE_LEN  64

#define OS_VERSION            0
#define OS_INTERNAL_REV       1
#define OS_OEM_SERIAL         2
#define OS_USER_SERIAL        3
#define OS_OEM_VERSION        4
#define OS_DOS_LOCATION       5
#define OS_BOOT_DRIVE         6
#define OS_DOSSHELL           7
#define OS_WINDOWS            8
#define OS_DESQVIEW           9
#define OS_3270              10
#define OS_DOUBLE_DOS        11
#define OS_TASKVIEW          12
#define OS_TOPVIEW           13
#define OS_PATH_TO_PROGRAM   14
#define MAX_OS_TITLES        16

extern PSZ  pszOs2;
extern PSZ  pszMsDos;
extern PSZ  pszRom;
extern PSZ  pszHma;
extern PSZ  pszConventional;
extern PSZ  pszWin286;
extern PSZ  pszWin386;
extern PSZ  pszWindows;
extern PSZ  pszRealMode;
extern PSZ  pszStandardMode;
extern PSZ  pszEnhancedMode;
extern PSZ  psz_2dotX;
extern PSZ  pszPCControlProgram;
extern PSZ  pszWorkstationProgram;
extern PSZ  pszActive;
extern PSZ  pszDosShell;
extern PSZ  pszEnvironmentStr;
extern PSZ  pszEnvironInvalid;
extern PSZ  pszTemp;
extern PSZ  pszTmp;

extern PSZ  pszPathToProgram;
extern BOOL fTempPathInvalid;
extern BOOL fTmpPathInvalid;


/* Mouse strings */

extern PSZ  paszMouseTitles[];

#define MOU_HARDWARE              0
#define MOU_DRIVER_MFGR           1
#define MOU_DOS_DRIVER_TYPE       2
#define MOU_DRIVER_FILE_TYPE      3
#define MOU_DOS_DRIVER_VERSION    4
#define MOU_MS_DRIVER_VERSION     5
#define MOU_MOUSE_IRQ             6
#define MOU_COM_PORT              7
#define MOU_COM_PORT_ADDRESS      8
#define MOU_NMBR_BUTTONS          9
#define MOU_H_SENSITIVITY        10
#define MOU_H_CURSOR_RATIO       11
#define MOU_V_SENSITIVITY        12
#define MOU_V_CURSOR_RATIO       13
#define MOU_THRESHOLD_SPEED      14
#define MOU_LANGUAGE             15
#define MOU_MOUSE_INI_PATH       16

#define MAX_MOUSE_TITLE          26

#define MAX_MOUSE_RATIO_STRINGS  20

extern PSZ  paszMouseMfgrs[];
extern PSZ  paszMouseTypes[];
extern PSZ  paszMouseLanguages[];
extern PSZ  paszMouseRatios[];
extern PSZ  paszDriverFileTypes[];
WORD FAR _pascal IsMsDos (PSZ);

extern PSZ  pszBallPoint;
extern PSZ  pszDeviceNotDetected;
extern PSZ  pszColonOne;
extern PSZ  pszUndefined;
extern PSZ  pszUnexplainedError;

#define MAX_MOUSE_LINE_LEN    52

#define IBMPS2_MOUSE           4
#define NO_MOUSE_INSTALLED     6
#define LOGITECH_PS2_MOUSE     8
#define MSPS2_MOUSE            9
#define PS2_STYLE_MOUSE       11

#define MOUSE_MFGR_MICROSOFT   1
#define MOUSE_MFGR_PC_MOUSE    2
#define MOUSE_MFGR_LOGITECH    3


/* Other Adapter strings */

extern PSZ paszOtherTitles[];

#define OTHER_GAME_ADAPTER     0
#define OTHER_JOY_A_X          1
#define OTHER_JOY_A_Y          2
#define OTHER_JOY_A_BUTTON_1   3
#define OTHER_JOY_A_BUTTON_2   4
#define OTHER_JOY_B_X          5
#define OTHER_JOY_B_Y          6
#define OTHER_JOY_B_BUTTON_1   7
#define OTHER_JOY_B_BUTTON_2   8
#define OTHER_SOUND_DEVICE     9
#define OTHER_SOUND_IRQ       10
#define OTHER_SOUND_PORT      11

extern PSZ  pszGameAdapter;
extern PSZ  pszDetected;
extern PSZ  pszNotDetected;



/* Disk Drive strings */

#define DISK_DRIVE_COL         2
#define DISK_TYPE_COL          7
#define DISK_EXTRA_INFO_COL   DISK_TYPE_COL + 2
#define DISK_FREE_SPACE_COL   45
#define DISK_TOTAL_FREE_COL   57

#define MAX_DRIVES_PER_LINE    4

extern PSZ  pszDiskHeader;
extern PSZ  pszDiskUnderline;

extern PSZ  pszCylinders;
extern PSZ  pszHeads;
extern PSZ  pszBytesPerSector;
extern PSZ  pszSectorsPerTrack;
extern PSZ  pszCommaSpace;

extern PSZ  pszJoinInstalled;
extern PSZ  pszSubstInstalled;
extern PSZ  pszShareInstalled;
extern PSZ  pszAssignInstalled;
extern PSZ  pszAssign;
extern PSZ  pszAppendInstalled;
extern PSZ  pszAppendPath;
extern PSZ  pszMscdexInstalled;
extern PSZ  pszMscdex1x;
extern PSZ  pszLastdrive;

extern PSZ  pszMscdex;

extern PSZ  paszDriveTypes[];


/* LPT strings */

extern PSZ  pszLptHeader1;
extern PSZ  pszLptHeader2;
extern PSZ  pszLptUnderline;

#define LPT_PORT_COL         0
#define LPT_PORT_ADDR_COL    8
#define LPT_ON_LINE_COL     18
#define LPT_PAPER_OUT_COL   26
#define LPT_I_O_ERROR_COL   34
#define LPT_TIME_OUT_COL    42
#define LPT_BUSY_COL        50
#define LPT_ACK_COL         58


/* COM strings */

extern PSZ  pszComHeader;
extern PSZ  pszComUnderline;
extern PSZ  psz1point5;
extern PSZ  pszNA;
extern PSZ  pszOn;
extern PSZ  pszOff;
extern PSZ  paszComTitles[];
extern PSZ  paszUartChips[];
extern PSZ  paszParityDesc[];

#define MAX_COM_TITLES      10
#define MAX_COM_PORTS        4  /* Maximum number of COM ports detectable */
#define COM_TITLE_WIDTH     21  /* Length of longest title string         */
#define COM_INFO_COL_WIDTH  11  /* Distance between columns               */
#define MAX_COM_INFO_LINE   (COM_TITLE_WIDTH + (COM_INFO_COL_WIDTH * MAX_COM_PORTS))
                                /* Maximum COM info line length           */

#define COM_PORT_ADDRESS     0
#define COM_BAUD_RATE        1
#define COM_PARITY           2
#define COM_DATA_BITS        3
#define COM_STOP_BITS        4
#define COM_CARRIER_DETECT   5
#define COM_RING_INDICATOR   6
#define COM_DATA_SET_READY   7
#define COM_CLEAR_TO_SEND    8
#define COM_UART_CHIP        9


/* IRQ data */

extern WORD rwIrqRecordTypes[];

extern PSZ  paszPcIrqDescriptions[];
extern PSZ  paszAtIrqDescriptions[];

extern PSZ  pszIrqHeader;
extern PSZ  pszIrqUnderline;

#define IRQ_ADDRESS_COL        5
#define IRQ_DESCRIPTION_COL   16
#define IRQ_DETECTED_COL      34
#define IRQ_HANDLED_BY_COL    54

extern PSZ  pszCom[];

extern PSZ  pszBIOS;

/* TSR strings */

extern PSZ  pszTsrHeader;
extern PSZ  pszTsrUnderline;

extern PSZ  pszFreeMemory;
extern PSZ  pszDosSystemArea;
extern PSZ  pszCommandCom;
extern PSZ  pszCommand;
extern PSZ  pszExcludedUmbArea;
extern PSZ  pszVideoRom;
extern PSZ  pszHardDiskRom;
extern PSZ  pszOptionRom;
extern PSZ  pszVideoRam;
extern PSZ  pszDosSystemCode;
extern PSZ  pszDosSystemData;
extern PSZ  pszDeviceAppenage;
extern PSZ  pszFileHandles;
extern PSZ  pszFCBS;
extern PSZ  pszBuffers;
extern PSZ  pszDirectories;
extern PSZ  pszStacksArea;
extern PSZ  pszIntTable;
extern PSZ  pszRomDataArea;
extern PSZ  pszDosDataArea;

#define TSR_ADDRESS_COL     22
#define TSR_SIZE_COL        29
#define TSR_CMD_LINE_COL    37


/* Device driver strings */

extern PSZ  pszDeviceHeader;
extern PSZ  pszDeviceUnderline;

extern PSZ  pszBlockDevice;

#define DEV_FILENAME_COL    14
#define DEV_UNITS_COL       24
#define DEV_HEADER_COL      31
#define DEV_ATTRIBUTE_COL   42


/* File Viewer strings */

extern PSZ  pszDot;
extern PSZ  pszDotDot;

extern PSZ  pszPathNotThere;

/* Global String Arrays */

extern PSZ  paszButtonNames[];

#define MAX_BUTTON_NAME_LEN   14

extern PSZ  paszMainBtnArray[];
extern PSZ  paszCommandLineHelp[];
extern PSZ  paszMsdTitleLines[];
extern PSZ  paszCustInfoTitle[];


/* Summary area */

#define MAX_SUMM_INFO        18
#define SUMMARY_ALIGN  MAX_BUTTON_NAME_LEN + 2


/********************************************************************/
/*                         Data Structures                          */
/********************************************************************/

/* MSD Header Structure */

typedef struct _MSD_HEADER
{
  CHAR chMsdVersion[15];  /* MSD Version number 2.00.00xx */
} MSD_HEADER;


#define MAX_CUST_INFO_TITLES  8
#define MAX_CUST_INFO        50

/* Customer data array */

typedef struct _CUSTINFO
{
  CHAR chCustInfo[MAX_CUST_INFO_TITLES][MAX_CUST_INFO + 1];
} CUSTINFO;

#if CW_INCLUDED
extern CUSTINFO *pCustInfoDlg;  /* Customer information for the dialog box */
#endif


/* Summary structure */

typedef struct _SUMMARY_STRUCT
{
  /* Storage for the summary info strings */

  CHAR szSumStrings[NMBR_OF_RECORDS * 2][MAX_SUMM_INFO + 5];
} SUMMARY_STRUCT;

extern SUMMARY_STRUCT  *pSum;


/* Computer structure */

#define MAX_BIOS_MFGR             25
#define MAX_COMPUTER_NAME         25
#define MAX_BIOS_VERSION_LEN      50
#define MAX_BIOS_VERSION_STRINGS   3
#define MAX_BIOS_DATE              9
#define MAX_BIOS_CATEGORY         32
#define MAX_PROCESSOR             18
#define MAX_KEYBOARD_TYPE         15
#define MAX_BUS_TYPE              15

typedef struct _COMPUTER_STRUCT
{
  WORD wComputerName;                     /* Computer Name (numeric)       */
  CHAR szComputerName[MAX_COMPUTER_NAME]; /* Computer Name (string)        */
  WORD wBiosMfgr;                         /* BIOS mfgr's name (numeric)    */
  CHAR szBiosMfgr[MAX_BIOS_MFGR];         /* BIOS mfgr's name (string)     */
  CHAR aszBiosVersion[MAX_BIOS_VERSION_STRINGS][MAX_BIOS_VERSION_LEN];
                                          /* BIOS version                  */
  WORD wBiosCategory;                     /* BIOS Category (numeric)       */
  CHAR szBiosCategory[MAX_BIOS_CATEGORY]; /* BIOS Category (string)        */
  WORD wComputerClass;                    /* XT - AT - PS/2 classification */
  BOOL fConfigCallSupported;              /* TRUE if config call supported */
  BYTE bComputerType;                     /* Computer type byte            */
  BYTE bSubModel;                         /* Computer Submodel             */
  BYTE bRevisionLevel;                    /* BIOS revision level           */
  CHAR szBiosDate[MAX_BIOS_DATE];         /* BIOS date                     */
  WORD wProcessor;                        /* Type of processor (numeric)   */
  CHAR szProcessor[MAX_PROCESSOR];        /* Type of processor (string)    */
  WORD wCoProcessor;                      /* Type of coprocessor (numeric) */
  CHAR szCoProcessor[MAX_PROCESSOR];      /* Type of coprocessor (string)  */
  WORD wKeyboardType;                     /* Keyboard type (numeric)       */
  CHAR szKeyboardType[MAX_KEYBOARD_TYPE]; /* Keyboard type (string)        */
  WORD wBusType;                          /* Type of BUS (numeric)         */
  CHAR szBusType[MAX_BUS_TYPE];           /* Type of BUS (string)          */
  BOOL fFixedDiskUsesDMA3;                /* Fixed Disk BIOS uses DMA #3   */
  BOOL fCascadeIntLvl2;                   /* Cascaded interrupt 2 (IRQ2)   */
  BOOL fRealTimeClock;                    /* TRUE: real time clock present */
  BOOL fDmaChipPresent;                   /* TRUE if DMA chip is present   */
  WORD wExtAreaSeg;                       /* Segment of extended BIOS area */
  WORD wExtAreaLen;                       /* Length of extended BIOS area  */
} COMPUTER_STRUCT;


/* Address - Length structure: Used in obtaining computer names */

typedef struct _ADDR_LENGTH
{
  DWORD dwAddress;  /* Address to search */
  WORD  wLength;    /* Length of search  */
} ADDR_LENGTH;

#define GET_COMPUTER_NAME   1
#define GET_BIOS_MFGR       2
#define GET_VIDEO_NAME      3
#define GET_VIDEO_MODEL     4


/* Memory structures */

#define ZERO_SEGMENT  0x0000  /* The first segment of memory                       */
#define SEGMENT_INC   0x0400  /* The amount to increment the segment address by    */
#define START_OFFSET  0x0000  /* The starting offset within the current segment    */
#define ENDING_OFFSET 0x4000  /* The ending offset within the current segment      */
#define OFFSET_INC    0x0400  /* The amount to increment the offset by             */
#define TEST_VALUE1   0x4A    /* The first test value used to test for RAM         */
#define TEST_VALUE2   0x4B    /* The second test value used to test for RAM        */
#define NUM_OF_ROWS   64      /* The number of rows in the memory map              */
#define NUM_OF_COLS   17      /* The number of columns in the memory map plus      */
                              /* to hold an ending null char for winWrtStrnAttrib  */

#define RAM 0                 /* Value returned by RamRomWomCheck for RAM          */
#define ROM 1                 /* Value returned by RamRomWomCheck for ROM          */
#define WOM 2                 /* Value returned by RamRomWomCheck for WOM          */
#define SEARCH_LENGTH 1024    /* The number of bytes for RamRomWomCheck to check   */

#define SIXTEEN_KB   0        /* Specify a memory browse on a 16K block            */
#define SIXTYFOUR_KB 1        /* Specify a memory browse on a 64K block            */
#define FIRST_MB     2        /* Specify a memory browse on the first meg          */

#define DISPLAY_RAM             176
#define DISPLAY_ROM             219
#define DISPLAY_WOM             ' '
#define DISPLAY_EMS             'P'
#define DISPLAY_USED_UMB        'U'
#define DISPLAY_FREE_UMB        'F'
#define DISPLAY_FREE_XMS_UMB    'X'
#define DISPLAY_NOT_CERTAIN     250
#define REPORT_RAM              '#'
#define REPORT_ROM              'R'
#define REPORT_WOM              ' '
#define REPORT_EMS              'P'
#define REPORT_USED_UMB         'U'
#define REPORT_FREE_UMB         'F'
#define REPORT_FREE_XMS_UMB     'X'
#define REPORT_NOT_CERTAIN      '.'


typedef struct _DPMI_STRUCT
{
  unsigned long ulLrgBlkFreeBy;    /* Largest available block in bytes                */
  long          lMaxUnLockPg;      /* Maximum unlocked page allocation                */
  unsigned long ulMaxLockPg;       /* Maximum locked page allocation                  */
  unsigned long ulTotLinPg;        /* Total linear address space in pages             */
  unsigned long ulTotUnLockPg;     /* Total number of unlocked pages                  */
  unsigned long ulTotPhysFreePg;   /* Total number of free physical pages             */
  unsigned long ulTotPhysPg;       /* Total number of physical pages                  */
  unsigned long ulTotLinFreePg;    /* Total number of free linear pages               */
  unsigned long ulSizeFilePg;      /* Size of paging file/partition in pages          */
  unsigned long ulReserved[3];     /* Reserved                                        */

} DPMI_STRUCT;

typedef struct _MEMORY_STRUCT
{

/* Conventional and extended memory information */

  long lConv_Mem;      /* Amount of conventional RAM, bytes                */
  long lFree_Conv_Mem; /* Amount of free conventional memory, bytes        */
  int  iCMOSExtended;  /* Amount of CMOS installed extended memory, Kbytes */
  int  iExt_Mem;       /* Amount of extended RAM, Kbytes                   */

/* Expanded (EMS) information */

  int iEmm_Is_There;       /* EMM driver present. 1 = Yes, 0 = No                                  */
  int iEmm_Ver_Err;        /* Error getting EMM version, 0 = no, <> 0 = error code                 */
  int iEmm_Size_Err;       /* Error getting EM size, 0 = No, <> 0 = error code                     */
  int iEmm_VersionMajor;   /* Major version of the EMM driver                                      */
  int iEmm_VersionMinor;   /* Minor version of the EMM driver                                      */
  int iTotal_Emm_Pages;    /* Number of 16K expanded memory pages                                  */
  int iFree_Emm_Pages;     /* Number of free 16K expanded memory pages                             */
  int iPageFrameAddress;   /* The segment address of the EMS page frame                            */
  int iLIM40Functionality; /* Whether or not LIM 4.0 mappable pages were detected. 1 = yes, 0 = no */

/* XMS memory information */

  int iXmm_Is_There;      /* XMM driver present, 1 = Yes, 0 = No                                          */
  int iLargest_Free_Xm;   /* Largest free extended memory block bytes                                     */
  int iTotal_Free_Xm;     /* Total free extended memory blocks, bytes                                     */
  int iXmm_Free_Err;      /* Error getting largest and/or total free XM blocks, 0 = no, <> 0 = error code */

  unsigned char uchXmm_Spec_VersionMajor;   /* Major version of the XMM spec being used */
                                            /*  stored as a hex value                   */
  unsigned char uchXmm_Spec_VersionMinor;   /* Minor version of the XMM spec being used */
                                            /*  stored as a hex value                   */
  unsigned char uchXmm_Driver_VersionMajor; /* Major version of the XMM driver          */
                                            /*  stored as a hex value                   */
  unsigned char uchXmm_Driver_VersionMinor; /* Minor version of the XMM driver          */
                                            /*  stored as a hex value                   */

  int iA20Status;     /* The status of the A20 address line, 1 = enabled, 0 = disabled  */
  int iHMAStatus;     /* The status of the HMA. 1 = avaialble, 0 = not available        */
  int iXMSError;      /* Error codes returned when requesting the HMA                   */

/* SXMS memory information (compliments XMS memory information) */

  BOOL  fSxmsAvailable;     /* TRUE if Super Extended memory available */
  DWORD dwSxmsLargestFree;  /* Largest free block in Kb                */
  DWORD dwSxmsTotalFree;    /* Total SXMS free in Kb                   */
  DWORD dwSxmsHighestAddr;  /* Highest ending address of any block     */

/* XMS UMB information */

  BOOL  fXmsUmbAvailable;     /* TRUE if XMS UMBs are available */
  DWORD dwXmsUmbFree;         /* Total bytes free in XMS UMBs   */
  DWORD dwXmsUmbLargestFree;  /* Largest free block of XMS UMBs */

  /* Error Code   Meaning                                 */
  /* ----------   -------                                 */
  /*   0      No errors detected                          */
  /*   1      HMA request feature not implemented         */
  /*   2      VDISK was detected                          */
  /*   3      HMA does not exist                          */
  /*   4      HMA already in use                          */
  /*   5      Unknown reason                              */
  /*   6      Unable to release HMA (Used when releasing) */

/* VCPI Information */

  int iVCPIPresent;       /* Whether or not VCPI is present, 1 = Yes, 0 = No */
  int iVCPIMajorVersion;  /* Major version of VCPI driver                    */
  int iVCPIMinorVersion;  /* Minor version of VCPI driver                    */
  int iVCPIAvailMemory;   /* Available VCPI memory, Kbytes                   */

/*DPMI Information */

  int iDPMIPresent;          /* Whether or not DPMI is present, 1 = Yes, 0 = No */
  int iDPMIMajorVersion;     /* Major version of DPMI driver                    */
  int iDPMIMinorVersion;     /* Minor version of DPMI driver                    */
  unsigned long ulRealModeDPMIMemAvail; /* The amount of real mode DPMI memory avaialable  */

  DPMI_STRUCT DPMIMemInfo;   /* Structure for holding DPMI info */

  WORD  wOptionRomAddress[10];/* Option ROM Starting Addresses */
  DWORD dwOptionRomLength[10];/* Option ROM lengths            */
  WORD  wBiosStartAddress;    /* System BIOS start address     */
  DWORD dwBiosLength;         /* System BIOS length            */

/* UMB Information */

  BOOL  fUmbsAvailable;       /* TRUE if UMBs are available    */
  DWORD dwTotalUmbs;          /* Total UMB areas in the system */
  DWORD dwFreeUmbs;           /* Total free UMB space          */
  DWORD dwLargestFreeUmb;     /* Largest single free UMB area  */

/* The arrays to hold the visual memory map */

  BYTE abMemoryMap [NUM_OF_ROWS][NUM_OF_COLS];
  BYTE abMemMapOverlay [NUM_OF_ROWS][NUM_OF_COLS];

} MEMORY_STRUCT;


typedef struct _ROM_MAP
{
/* ROM locations and lengths */

  WORD  wRomBiosLoc[2];       /* ROM BIOS locations                 */
  DWORD dwRomBiosSize[2];     /* ROM BIOS sizes                     */
                              /*   I've arbitrarily split PS/2 ROMs */
                              /*   into E000 and F000 segments      */

  WORD  wOptRomLoc[10];       /* Option ROM locations               */
  DWORD dwOptRomSize[10];     /* Option ROM sizes                   */
} ROM_MAP;


typedef struct _MEM_MAP
{
  BYTE abMap[NUM_OF_ROWS][NUM_OF_COLS + 5];
} MEM_MAP;


/* Video structure */

#define MAX_ADAPTER         32
#define MAX_ADAPTER_NAME    32
#define MAX_ADAPTER_MODEL   32
#define MAX_DISPLAY_TYPE    32
#define MAX_VESA_OEM_NAME   50

typedef struct _VIDEO_STRUCT
{
                                            /* Primary display information */
  BYTE bSubsystem0;                         /* Video adapter type          */
  BYTE bDisplay0;                           /* Display type (TTL, color)   */
  BYTE bMode0;                              /* Video mode number           */
  BYTE bNmbrCols0;                          /* Number of columns (40/80)   */
  WORD wMemory0;                            /* Video memory installed      */

                                            /* Secondary display data      */
  BYTE bSubsystem1;                         /* Video adapter type          */
  BYTE bDisplay1;                           /* Display type (TTL, color)   */
  BYTE bMode1;                              /* Video mode number           */
  BYTE bNmbrCols1;                          /* Number of columns (40/80)   */
  WORD wMemory1;                            /* Video memory installed      */

  BYTE bNmbrRows;                           /* # of rows (25/43/50)        */
  CHAR szAdapterType[MAX_ADAPTER];          /* Adapter type (string)       */
  WORD wAdapterName;                        /* Adapter name (numeric)      */
  CHAR szAdapterName[MAX_ADAPTER_NAME];     /* Adapter name (string)       */
  WORD wAdapterModel;                       /* Adapter model (numeric)     */
  CHAR szAdapterModel[MAX_ADAPTER_MODEL];   /* Adapter model (string)      */
  CHAR szDisplayType[MAX_DISPLAY_TYPE];     /* Display type (string)       */
  CHAR sz2ndAdapterType[MAX_ADAPTER];       /* 2ndary adapter type (str)   */

  CHAR aszVideoBiosVersion[MAX_BIOS_VERSION_STRINGS][MAX_BIOS_VERSION_LEN];
  CHAR szVideoBiosDate[MAX_BIOS_DATE];      /* Video BIOS date             */
                                            /* Video BIOS version          */
  BYTE bVesaVersionMajor;                   /* VESA version number (major) */
  BYTE bVesaVersionMinor;                   /* VESA version number (minor) */
  CHAR szVesaOemName[MAX_VESA_OEM_NAME];    /* VESA OEM Name               */
  WORD wTigaInterrupt;                      /* TIGA s/w interrupt number   */
  DWORD dwTigaIntAddress;                   /* TIGA interrupt address      */
  WORD wTigaMajor;                          /* TIGA major version number   */
  WORD wTigaMinor;                          /* TIGA minor version number   */
  BOOL fTigaSignatureFound;                 /* TRUE if "TIGA" found        */
} VIDEO_STRUCT;


/* Network Structure */

#define MAX_MSNET_MACHINE_NAME  16 + 1
#define NUMBER_OF_CARDS         8
#define NUMBER_OF_SESSIONS     16
#define LENGTH_OF_UNIT_ID       6

typedef struct _SESSION_NAME
  {
    CHAR szSessionName[16];
  } SESSION_NAME;

typedef struct _NET_CARD_SESSION
  {
    BYTE bUnitID_Number[LENGTH_OF_UNIT_ID];
    BYTE bNumber_Of_Sessions;
    SESSION_NAME snRemoteSessionNames[NUMBER_OF_SESSIONS];
  } NET_CARD_SESSION;

typedef struct _NETWORK_STRUCT
{
  /*** General Network Information *************************************/

  BOOL  fNetworkActive;           /* TRUE if a network is active        */
  WORD  wNetworkType;             /* Type of network installed          */
  CHAR  szNetworkType[MAX_NETWORK_TYPE];  /* Type of network (string)   */
  WORD  wNetworkMajor;            /* Version number of network          */
  WORD  wNetworkMinor;

  /*** MS-NET Information ***********************************************/

  BOOL  fMsnetCompatible;         /* TRUE if MS-NET compatible network  */
  CHAR  szMsnetMachineName[MAX_MSNET_MACHINE_NAME + 1]; /* Machine's name */

  /*** NetBIOS Information **********************************************/

  BOOL  fNetBiosCompatible;       /* TRUE if NetBIOS compatible network */
  WORD  wNetBIOSSegment;          /* Segment address of NetBIOS handler */
  WORD  wNetBIOSOffset;           /* Offset of NetBIOS handler          */

  /*** LANMAN Information ***********************************************/

  BOOL  fMailslot_Support;        /* TRUE if supported */
  BOOL  fAPI_Support;             /* TRUE if supported */
  BOOL  fServerConnection;        /* TRUE if connection to a server has been established, 0 otherwise */
  CHAR  szLanRoot[_MAX_PATH];
  CHAR  szUserName[16];
  CHAR  szPrimaryDomain[16];
  CHAR  szLanManager_Date[16];
  CHAR  szLanManager_CSD[7];
  WORD  wNumberOfNets;
  NET_CARD_SESSION ncsNets[NUMBER_OF_CARDS];

  /*** Novell Information ***********************************************/

  WORD  wShellMajor;              /* Version number of shell (numeric) */
  WORD  wShellMinor;
  WORD  wShellRevision;
  CHAR  szNovellShellOsVersion[40];/* Version number of shell OS (string) */
  WORD  wShellType;               /* XMS, EMS, Conventional memory     */

  CHAR  szNovellNetwareVersion[40];

  WORD  wNovellShellOs;           /* 00=MS-DOS                         */
  CHAR  szNovellShellOs[40];
  WORD  wNovellHdwType;           /* 00=IBM_PC 01=Victor9000           */
  CHAR  szNovellHdwType[40];
  WORD  wStationNmbr;             /* Station number (digit)            */
  WORD  wPhysicalStaNmbr1;        /* Physical station number part 1    */
  WORD  wPhysicalStaNmbr2;        /* Physical station number part 2    */
  WORD  wPhysicalStaNmbr3;        /* Physical station number part 3    */
  BOOL  fIpxInstalled;            /* TRUE if IPX installed             */
  BOOL  fSpxInstalled;            /* TRUE if SPX installed             */
  BOOL  fOdiLslInstalled;         /* TRUE if ODI link support layer in */

  /*** LANtastic Information ********************************************/

  BOOL fLANtasticPresent;         /* TRUE if LANtastic is running   */
  BOOL fLANtasticServer;          /* TRUE if running as a server    */
  BOOL fLANtasticRedir;           /* TRUE if running redirector     */
  BOOL fLANtasticPopUp;           /* TRUE if running popup software */
  WORD wLANtasticVersionMajor;    /* The major version number       */
  WORD wLANtasticVersionMinor;    /* The minor version number       */

} NETWORK_STRUCT;


/* OS Version structure */

#define MAX_OEM_VER          80
#define MAX_OEM_VER_STRINGS   5
#define MAX_PATH_TO_PROGRAM  _MAX_PATH + 1

typedef struct _OS_VERSION_STRUCT
{
  WORD  wDosMajor;               /* DOS major version                      */
  WORD  wDosMinor;               /* DOS minor version                      */
  WORD  wDosRevision;            /* DOS revision                           */
  WORD  wOemSerialNumber;        /* OEM serial number                      */
  DWORD dwUserSerialNumber;      /* User serial number                     */
  WORD  wDosLoadedFlags;         /* 0=Conventional,8=ROM,16=HMA            */
  CHAR  chDosBootDrive;          /* Boot drive                             */
  BOOL  fOs2Installed;           /* TRUE if OS/2 is running                */
  BOOL  fDosShellTaskSwitcher;   /* TRUE if DOSSHELL task switcher in use  */
  WORD  wWindowsType;            /* Type of Windows running                */
  WORD  wWindowsMajor;           /* Windows major for Win >= 3.0           */
  WORD  wWindowsMinor;           /* Windows minor for Win >= 3.0           */
  WORD  wDesqViewMajor;          /* DESQview major version                 */
  WORD  wDesqViewMinor;          /* DESQview minor version                 */
  WORD  w3270Installed;          /* 0=No, 1=Control Pgm, 2=Workstation Pgm */
  WORD  w3270Major;              /* 3270 program major version             */
  WORD  w3270Minor;              /* 3270 program minor version             */
  BOOL  fDoubleDosInstalled;     /* TRUE if DoubleDOS installed            */
  BOOL  fTaskViewInstalled;      /* TRUE if TaskView installed             */
  WORD  wTopViewMajor;           /* TopView major version                  */
  WORD  wTopViewMinor;           /* TopView minor version                  */
  CHAR  szPathToProgram[MAX_PATH_TO_PROGRAM];
                                 /* Fully qualified path to program        */
  CHAR  szOemVer[MAX_OEM_VER_STRINGS][MAX_OEM_VER];
                                 /* Stores the OEM version number strings  */
} OS_VERSION_STRUCT;

#define NO_WINDOWS          0
#define WIN_286             1
#define WIN_386             2
#define WIN_REAL_MODE       3
#define WIN_STANDARD_MODE   4
#define WIN_ENHANCED_MODE   5
#define WIN_UNKNOWN_MODE    6

#define NO_3270_PROGRAM            0
#define _3270_PC_CONTROL_PROGRAM   1
#define _3270_WORKSTATION_PROGRAM  2


/* Mouse structure */

#define MAX_MOUSE_HARDWARE_TYPE      32
#define MAX_MOUSE_DRIVER_MFGR        32
#define MAX_MOUSE_DRIVER_TYPE        32
#define MAX_COM_PORT_LEN             10
#define MAX_MOUSE_LANGUAGE           11
#define MAX_DRIVER_FILE_TYPE         10
#define MAX_MOUSE_INI_PATH           _MAX_PATH + 1

typedef struct _MOUSE_STRUCT
{
  BOOL  fHardwareInstalled;   /* TRUE if mouse device is detected       */
  WORD  wMouseHardwareType;   /* Mouse hardware detected (numeric)      */
  CHAR  szMouseHardwareType[MAX_MOUSE_HARDWARE_TYPE];
                              /* Mouse hardware detected (string)       */
  WORD  wDriverMfgr;          /* Manufacturer of mouse driver (numeric) */
  CHAR  szDriverMfgr[MAX_MOUSE_DRIVER_MFGR];
                              /* Manufacturer of mouse driver (string)  */
  WORD  wMouseDriverType;     /* Driver detected mouse (Inport/Bus/etc) */
  CHAR  szMouseDriverType[MAX_MOUSE_DRIVER_TYPE];
                              /* Driver detected mouse (string)         */
  WORD  wMsMajorVersion;      /* Mouse driver major version             */
  WORD  wMsMinorVersion;      /* Mouse driver minor version             */
  WORD  wOemMajorVersion;     /* OEM's Mouse driver version (major)     */
  WORD  wOemMinorVersion;     /* OEM's Mouse driver version (minor)     */
  WORD  wIrq;                 /* IRQ used by the mouse                  */
  WORD  wComPort;             /* COM port used by the mouse (numeric)   */
  CHAR  szComPort[MAX_COM_PORT_LEN]; /* COM port use by mouse (string)  */
  WORD  wComPortAddress;      /* COM port's port address                */
  WORD  wNmbrButtons;         /* Number of buttons on mouse             */
  WORD  wHMickeys;            /* Horizontal mickeys                     */
  WORD  wVMickeys;            /* Vertical mickeys                       */
  WORD  wThresholdSpeed;      /* Doublespeed threshold                  */
  WORD  wLanguage;            /* Language for mouse messages (numeric)  */
  CHAR  szLanguage[MAX_MOUSE_LANGUAGE];
                              /* Language for mouse messages (string)   */
  WORD  wDriverFileType;      /* 0=Call not supported, 1=.COM, 2=.SYS   */
  CHAR  szDriverFileType[MAX_DRIVER_FILE_TYPE];
                              /* Driver file type (string)              */
  CHAR  szMouseIniPath[MAX_MOUSE_INI_PATH];
                              /* Fully qualified path to MOUSE.INI      */
} MOUSE_STRUCT;

#define MOUSE_NO_MOUSE_DRIVER    0
#define MOUSE_MICROSOFT_DRIVER   1
#define MOUSE_LOGITECH_DRIVER    2
#define MOUSE_PC_MOUSE_DRIVER    3

#define MOUSE_UNKNOWN_FILE       0
#define MOUSE_COM_FILE           1
#define MOUSE_SYS_FILE           2

#define SERIAL_MOUSE             2
#define LOGITECH_SERIAL_MOUSE    7
#define BALLPOINT_MOUSE         80


/* Other Adapters Information Struct */

#define MAX_SOUND_NAME          40

typedef struct _OTHER_STRUCT
{
  BOOL fGameInstalled;    /* TRUE if game adapter installed  */
  WORD wJoystickAX;       /* "A" Joystick's X value          */
  WORD wJoystickAY;       /* "A" Joystick's Y value          */
  WORD wJoystickBX;       /* "B" Joystick's X value          */
  WORD wJoystickBY;       /* "B" Joystick's Y value          */
  BOOL fButtonA1;         /* "A" Joystick's 1st button value */
  BOOL fButtonA2;         /* "A" Joystick's 2st button value */
  BOOL fButtonB1;         /* "B" Joystick's 1st button value */
  BOOL fButtonB2;         /* "B" Joystick's 2st button value */

  BOOL fSoundInstalled;   /* TRUE if sound adapter installed */
  WORD wSoundName;        /* Sound board (numeric)           */
  CHAR szSoundName[MAX_SOUND_NAME]; /* Sound board (string)  */
  WORD wSoundPort;        /* I/O port used by sound adapter  */
  WORD wSoundIrq;         /* IRQ used by sound adapter       */
  WORD wSoundDma;         /* DMA channel used by sound adp.  */
} OTHER_STRUCT;


/* Disk Drive Information Struct */

#define DISK_UNKNOWN_DRIVE             0
#define DISK_FLOPPY_DRIVE              1
#define DISK_525_360K                  2
#define DISK_525_12M                   3
#define DISK_35_720K                   4
#define DISK_SINGLE_DENSITY_8_INCH     5
#define DISK_DOUBLE_DENSITY_8_INCH     6
#define DISK_FIXED_DISK                7
#define DISK_TAPE_DRIVE                8
#define DISK_35_144M                   9
#define DISK_OPTICAL_DISK             10
#define DISK_35_288M                  11
#define DISK_REMOTE_DRIVE             12
#define DISK_RAM_DISK                 13
#define DISK_CD_ROM_DRIVE             14
#define DISK_SUBST_DRIVE              15
#define DISK_ASSIGN_DRIVE             16

#define MAX_DRIVE_LETTERS     33
#define MAX_DRIVE_TYPE_LEN    32
#define MAX_ASSIGN_TABLE      26
#define MAX_APPEND_PATH       _MAX_PATH + 1

typedef struct _SINGLE_DRIVE_INFO
{
  CHAR  chDriveLetter;        /* Drive letter for this drive              */
  WORD  wDriveType;           /* Drive type (360k floppy, 1.2M floppy ... */
  CHAR  szDriveType[MAX_DRIVE_TYPE_LEN];  /* Drive type (string)          */
  DWORD dwFreeBytes;          /* Free bytes on this disk                  */
  DWORD dwTotalBytes;         /* Size of disk                             */
  WORD  wCylinders;           /* Number of cylinders                      */
  WORD  wHeads;               /* Number of heads                          */
  WORD  wBytesPerSector;      /* Bytes per sector                         */
  WORD  wSectorsPerTrack;     /* Sectors per track                        */
  WORD  wCmosDriveType;       /* The CMOS drive type (ie, 02, 48, etc).   */
  WORD  wCmosCylinders;       /* CMOS reported number of cylinders        */
  WORD  wCmosHeads;           /* CMOS reported number of heads            */
  WORD  wCmosSectorsPerTrack; /* CMOS reported sectors per track          */
  BOOL  fBiosSupported;       /* TRUE if this is a BIOS supported drive   */
} SINGLE_DRIVE_INFO;

typedef struct _ASSIGN_TABLE
{
  CHAR chAssignTo;            /* ASSIGN table ie, C=D, X=F, etc           */
  CHAR chAssignFrom;          /*   C is to, D is from                     */
} ASSIGN_TABLE;

typedef struct _DISK_STRUCT
{
  WORD wNmbrDrives;           /* Total number of drives in the system */
  CHAR chLastDrive;           /* Highest available drive letter       */
  CHAR chCurrentDrive;        /* Current drive letter                 */
  BOOL fJoinInstalled;        /* TRUE if JOIN.EXE is installed        */
  BOOL fSubstInstalled;       /* TRUE if SUBST.EXE is installed       */
  BOOL fShareInstalled;       /* TRUE if SHARE.EXE is installed       */
  BOOL fAssignInstalled;      /* TRUE if ASSIGN.EXE is installed      */
  ASSIGN_TABLE atAssignTable[MAX_ASSIGN_TABLE];  /* ASSIGNed drives   */
  BOOL fAppendInstalled;      /* TRUE if APPEND.EXE is installed      */
  CHAR szAppendPath[MAX_APPEND_PATH]; /* APPEND path                  */
  WORD wMscdexMajor;          /* Major version of MSCDEX.EXE          */
  WORD wMscdexMinor;          /* Minor version of MSCDEX.EXE          */
  SINGLE_DRIVE_INFO asdi[MAX_DRIVE_LETTERS];  /* Drive information    */
} DISK_STRUCT;

typedef struct _CMOS_DRIVE_TYPE
{
  WORD wNmbrCylinders;       /* 00h */
  BYTE bNmbrHeads;           /* 02h */
  WORD wReducedWriteCyl;     /* 03h */
  WORD wWritePrecomp;        /* 05h */
  BYTE bMaxEccBurstLength;   /* 07h */
  BYTE bControlByte;         /* 08h */
  BYTE bStandardTimeout;     /* 09h */
  BYTE bFormattingTimeout;   /* 0Ah */
  BYTE bDriveCheckTimeout;   /* 0Bh */
  WORD wLandingZone;         /* 0Ch */
  BYTE bSectorsPerTrack;     /* 0Eh */
  BYTE bReserved;            /* 0Fh */
} CMOS_DRIVE_TYPE;


/* LPT Information Structure */

#define MAX_LPT_PORTS       3

typedef struct _LPT_X_STRUCT
{
  BOOL fLptPortDetected;  /* TRUE if parallel port detected  */
  WORD wPortAddress;      /* Port address for LPT port       */
  BOOL fOnLine;           /* TRUE if printer on-line         */
  BOOL fPaperOut;         /* TRUE if paper out sensor is on  */
  BOOL fIoError;          /* TRUE if I/O error occured       */
  BOOL fTimeOut;          /* TRUE if a timeout error occured */
  BOOL fBusy;             /* TRUE if port is busy            */
  BOOL fAck;              /* TRUE if ACK line on             */
} LPT_X_STRUCT;

typedef struct _LPT_STRUCT
{
  WORD wNmbrLptPorts;                     /* Total count of LPT ports */
  LPT_X_STRUCT LptxInfo[MAX_LPT_PORTS];   /* Individual LPT port data */
} LPT_STRUCT;


/* COM Information Structure */

/* The serial port information I received is primarily from the MS-DOS */
/*   Encyclopedia, Article 6, starting on page 167.  The information   */
/*   about the 8250 UART chip begins on page 172.                      */

#define MAX_UART_CHIP   8
#define MAX_PARITY      6

typedef struct _COM_X_STRUCT
{
  BOOL  fComPortDetected; /* TRUE if serial port detected          */
  WORD  wPortAddress;     /* Port address for the serial port      */
  DWORD dwBaudRate;       /* Actual Baud Rate                      */
  WORD  wParity;          /* Parity 0=N 1=O 2=E 3=Mark 4=Space     */
  CHAR  szParity[MAX_PARITY];   /* Parity (string)                 */
  WORD  wDataBits;        /* Data bits                             */
  WORD  wStopBits;        /* Stop bits 1=1 2=2 3=1.5               */
  BOOL  fCarrierDetect;   /* Carrier Detect                        */
  BOOL  fRingIndicator;   /* Ring Indicator active                 */
  BOOL  fDataSetReady;    /* DSR line indicator                    */
  BOOL  fClearToSend;     /* CTS line indicator                    */
  WORD  wUartChip;        /* UART chip type (numeric)              */
  CHAR  szUartChip[MAX_UART_CHIP];  /* UART chip type (string)     */
} COM_X_STRUCT;

typedef struct _COM_STRUCT
{
  WORD wNmbrComPorts;                     /* Total count of COM ports */
  COM_X_STRUCT ComxInfo[MAX_COM_PORTS];   /* Individual COM port data */
} COM_STRUCT;


/* IRQ Structure */

#define MAX_IRQ_DESCRIPTION        20
#define MAX_IRQ_DETECTED_STRINGS    4
#define MAX_IRQ_DETECTED_LEN       21
#define MAX_IRQ_HANDLED_BY         20

typedef struct _IRQ_X_STRUCT
{

  BOOL  fDetected;                        /* TRUE if something detected    */
  DWORD dwIrqAddress;                     /* IRQ interrupt vector          */
                                          /* Items detected (COM, Mouse)   */
  CHAR  szDetected[MAX_IRQ_DETECTED_STRINGS][MAX_IRQ_DETECTED_LEN];
  CHAR  szHandledBy[MAX_IRQ_HANDLED_BY];  /* What is located at the IRQ's  */
                                          /*   address (BIOS, TSR, etc).   */
} IRQ_X_STRUCT;

#define MAX_IRQ_X_STRUCTS          16

typedef struct _IRQ_STRUCT
{
  WORD wNmbrIrqs;                           /* Number of IRQ's in system */
  IRQ_X_STRUCT IrqxInfo[MAX_IRQ_X_STRUCTS]; /* One item for each IRQ */
} IRQ_STRUCT;


/* TSR Program List Structure */

#define MAX_TSR_NAME       19
#define MAX_TSR_CMD_LINE   32

typedef struct _TSR_PROGRAMS_STRUCT
{
  WORD  wAddress;                         /* Address of the  MCB    */
  DWORD dwBlockSize;                      /* Size of the MCB        */
  CHAR  szTsrName[MAX_TSR_NAME];          /* MCB owner name         */
  CHAR  szParameters[MAX_TSR_CMD_LINE];   /* Command line paramters */
} TSR_PROGRAMS_STRUCT;


/* Device Driver Structure */

typedef struct _DEVICE_DRIVER_STRUCT
{
  DWORD dwHeader;         /* Address of the device driver's header.    */
  WORD  wAttributes;      /* 16 bits of attributes for the driver.     */
                          /*   Bit 15 is set for character devices.    */
  CHAR  szDeviceName[15]; /* Device name for character devices.        */
  CHAR  szDriverFilename[9];  /* DEVICE=Filename for device.           */
  WORD  wUnits;           /* Number of units for block devices.        */
} DEVICE_DRIVER_STRUCT;


/* File Finder structure */

typedef struct _FILE_INFO
{
  BYTE  bAttrib;              /* File attributes                        */
  WORD  wTime;                /* Time of last write to file             */
  WORD  wDate;                /* Date of last write to file             */
  DWORD dwSize;               /* Size of the file                       */
  DWORD dwFileVersionMS;      /* File version (Most Significant DWORD)  */
  DWORD dwFileVersionLS;      /* File version (Least Significant DWORD) */
  CHAR FAR *fpszPathToFile;   /* Fully qualified path to the file       */
  VOID FAR *fpNextFileInfo;   /* Next FILE_INFO structure in the chain  */
} FILE_INFO;

extern FILE_INFO FAR *pfiDlg;   /* File Info for dialog processing */

typedef struct _DATE_INFO
{
  BITS  Day   : 5;
  BITS  Month : 4;
  BITS  Year  : 7;
} DATE_INFO;

#define SIZE_COLUMN   47
#define DATE_COLUMN   63

#define FIND_FILE_LINE_LENGTH  71


/* Test Printer structure */

typedef struct _TEST_PRINTER
{
  BOOL fPostscript;   /* TRUE if the Postscript test is requested     */
  BOOL f8BitTest;     /* TRUE if the 8-bit ASCII test is requested    */
  BOOL fSerialTest;   /* TRUE if serial port, FALSE for parallel port */
  WORD wPort;         /* Printer port number for the test             */
} TEST_PRINTER;

extern TEST_PRINTER tpValue;


/* Browsing structure */

typedef struct _MEM_STRING_DATA
{
  char far  *cfpString;
  int       iStringLen;
} MEM_STRING_DATA;

#define MAX_MSD_STRINGS   24
#define MAX_BROWSE_LINES   4

extern QSZ * pqszBrowseStrings;
extern PSZ   pszBrowseTitle;


/* Status line help structure */

typedef struct _STATUS_LINE_STRINGS
{
  WORD wStringNmbr;
  PSZ  pszString;
} STATUS_LINE_STRINGS;



/***************/
/* Prototyping */
/***************/

/**************************** MSD.C *********************************/

BOOL ProcessCmdLine (INT argc, PSZ argv[]);


/**************************** SUMMARY.C *****************************/

#ifdef CW_INCLUDED

VOID BeginCwInterface (VOID);

BOOL GetCwSumInfo (VOID);

#ifdef BASED

BOOL FAR PASCAL WndSegInit (VOID);

_segment pWndSeg;

#endif /* BASED */

VOID SetIsaColors (BOOL fBlackWhiteFlag);

VOID FAR InitMainWindows(void);

STATIC LONG FAR PASCAL MainWndProc (PWND, WORD, WORD, DWORD);
STATIC LONG FAR PASCAL StatusLineProc (PWND, WORD, WORD, DWORD);

VOID InitMsgBoxPlateBtns (VOID);

PWND FAR CreateMsgBtn ( szWindowName,
                        wStyle, wExStyle,
                        X, Y,
                        nWidth, nHeight,
                        hwndDlg,
                        id );

LONG FAR
MyMsgBoxProc (REGISTER PWND_DLG pwnd,
              WORD  message,
              WORD  wParam,
              DWORD lParam);

VOID InitMyEditItem (VOID);

LONG FAR
MyEditItemProc (REGISTER PWND_EDIT pwnd,
                WORD  message,
                WORD  wParam,
                DWORD lParam);

VOID WarnWindowsUser (VOID);

STATIC BOOL PASCAL CreateChildWindows (PVOID);
STATIC BOOL PASCAL WriteSummaryText (PVOID);

STATIC BOOL FARPUBLIC FrameFilter (PMSG, WORD *);

/* AUXCOW.C */

VOID FAR PASCAL Exit (INT);

BOOL FHelpMsg (PMSG pmsg, WORD cnx);

VOID FARPUBLIC Help (WORD hem, WORD hid, VOID *pv, WORD kk);

VOID ExamineDisplay (VOID);

#endif /* CW_INCLUDED */


/**************************** GETINFO.C *****************************/

INT  GetInfoSize (WORD wRecordType, BOOL fHeaderRecord);

BOOL GetInfo (WORD wRecordType,
              VOID *pStructForInfo,
              BOOL fMinimumInfo,
              BOOL fHeaderRecord,
              BOOL fReportFlag);


/**************************** SPRNINFO.C ****************************/

QSZ * SprintInfo (WORD wRecordType,
                  VOID *pStructWithInfo,
                  CHAR szSumStrings[][MAX_SUMM_INFO + 5],
                  BOOL fReportFlag);


/**************************** RPTINFO.C *****************************/

BOOL ReportOnly (PSZ pszRptFilename);

BOOL ReportFromCW (VOID);

BOOL WriteInfo (FILE *fileOutput,
                PSZ  pszTitle,
                QSZ  *pqszStrings);

BOOL WriteSepLine (FILE *fileOutput, PSZ pszTitle);

BOOL WritePageBreak (FILE *fileOutput);

BOOL ReportFile (PSZ  pszTitle,
                 PSZ  pszFilename,
                 FILE *fileOutput);

BOOL TestPrinter (BOOL fPostscript,
                  BOOL f8BitTest,
                  BOOL fSerialTest,
                  WORD wPort);

BOOL PrintTest (PSZ pszPort, BOOL f8BitTest, BOOL fPostscript);


/**************************** SHOWINFO.C ****************************/

#ifdef CW_INCLUDED

PWND ShowInfo (WORD wRecordType);

STATIC PWND CreateInfoWnd (PSZ  pszWindowTitle,
                           QSZ  *pqszStrings,
                           BOOL fKeepFocus);

STATIC LONG FAR PASCAL InfoWndProc (PWND, WORD, WORD, DWORD);

STATIC VOID InfoTxtWndScroll (PWND pwnd, WORD wParam, DWORD lParam);

STATIC LONG FAR PASCAL InfoTxtWndProc (PWND, WORD, WORD, DWORD);

STATIC BOOL PASCAL CreateInfoChildWindows (PWND pwndParent);

STATIC BOOL PASCAL CreateInfoTxtChildren (PWND pwndParent);

VOID DrawPlateButton1 (PWND  pwnd,
                       WORD  message,
                       WORD  wParam,
                       DWORD lParam);

#endif /* CW_INCLUDED */


/**************************** DIALOGS.C *****************************/

#ifdef CW_INCLUDED

LONG FAR PASCAL ReportDlg (PWND  pwnd,
                           WORD  message,
                           WORD  wParam,
                           DWORD lParam);

LONG FAR PASCAL FindFileDlg1 (PWND  pwnd,
                              WORD  message,
                              WORD  wParam,
                              DWORD lParam);

LONG FAR PASCAL FindFileDlg2 (PWND  pwnd,
                              WORD  message,
                              WORD  wParam,
                              DWORD lParam);

LONG FAR PASCAL InsertCmdDlg1 (PWND  pwnd,
                               WORD  message,
                               WORD  wParam,
                               DWORD lParam);

LONG FAR PASCAL InsertCmdDlg2 (PWND  pwnd,
                               WORD  message,
                               WORD  wParam,
                               DWORD lParam);

LONG FAR PASCAL InsertCmdDlg3 (PWND  pwnd,
                               WORD  message,
                               WORD  wParam,
                               DWORD lParam);

LONG FAR PASCAL InsertCmdDlg4 (PWND  pwnd,
                               WORD  message,
                               WORD  wParam,
                               DWORD lParam);

LONG FAR PASCAL TestPrinterDlg (PWND  pwnd,
                                WORD  message,
                                WORD  wParam,
                                DWORD lParam);

LONG FAR PASCAL CustInfoCmdDlg (PWND  pwnd,
                                WORD  message,
                                WORD  wParam,
                                DWORD lParam);

LONG FAR PASCAL AboutDlg (PWND  pwnd,
                          WORD  message,
                          WORD  wParam,
                          DWORD lParam);

LONG FAR PASCAL MemoryBlockDisplayDlg (PWND  pwnd,
                                       WORD  message,
                                       WORD  wParam,
                                       DWORD lParam);

LONG FAR PASCAL MemoryBrowserDlg (PWND  pwnd,
                                  WORD  message,
                                  WORD  wParam,
                                  DWORD lParam);

VOID UpdateMemMap (PWND pwnd, MEM_MAP *pmmMap);

LONG FAR PASCAL ViewWhichFileDlg (PWND  pwnd,
                                  WORD  message,
                                  WORD  wParam,
                                  DWORD lParam);

LONG FAR PASCAL WarnWindowsUserDlg (PWND pwnd,
                                    WORD message,
                                    WORD wParam,
                                    DWORD lParam);

#endif /* CW_INCLUDED */


/**************************** MSDSYS.C ******************************/

FILE * OpenFile (PSZ pszFilename, PSZ pszMode, BOOL fShowError);

BOOL CloseFile (FILE *fp);

WORD CreateTempFile (PSZ pszPathname);

WORD DeleteFile (PSZ pszPathname);

WORD RenameFile (PSZ pszPathname1, PSZ pszPathname2);

FILE_INFO FAR *FindFile (PSZ  pszFilename,
                         PSZ  pszPathname,
                         BOOL fSearchFlags,
                         CHAR chDriveLetter);

BOOL FindOnBootDrive (FILE_INFO FAR * FAR *ppFileInfo,
                      DISK_STRUCT         *pDisk,
                      OS_VERSION_STRUCT   *pOsVer,
                      PSZ                 pszFilename,
                      BOOL                fSearchFlags);

BOOL FindFileOnDrive (FILE_INFO FAR * FAR *ppFileInfo,
                      PSZ  pszFilename,
                      BOOL fSearchFlags,
                      CHAR chDriveLetter);

BOOL FindFileInCwd (FILE_INFO FAR * FAR *ppFileInfo,
                    PSZ  pszFilename,
                    BOOL fSearchFlags);

BOOL GetFindFileInfo (DISK_STRUCT       **ppDisk,
                      OS_VERSION_STRUCT **ppOsVer,
                      BOOL              fSearchFlags);

VOID FreeFileInfo (FILE_INFO FAR *pFileInfo);

VOID ProceduralLangChk (INT argc, PSZ argv[], BOOL fFlag);

QSZ * AllocStringSpace (WORD wNmbrStrings,
                        WORD wNmbrChars);

VOID FreeStringSpace (QSZ *pqszStrings);

WORD DisplayLen (QSZ qszString);

QSZ  QstrcpyAlign (QSZ qszString1, QSZ qszString2, WORD wIndent);

QSZ  QstrcatAlign (QSZ qszString1, QSZ qszString2, WORD wIndent);

QSZ  QstrncpyAlign (QSZ  qszString1,
                    QSZ  qszString2,
                    WORD wNmbrChars,
                    WORD wIndent);

QSZ PrepNextString (QSZ *ppszStrings, WORD i);

VOID ShowError (BOOL fFlags,
                PSZ  pszString1,
                PSZ  pszString2,
                PSZ  pszString3);

BOOL WriteLine (QSZ qszString, FILE *fileOutput, BOOL fFilterFlag);

BOOL _WriteLine (PSZ pszString, FILE *fileOutput);

BOOL WriteChar (CHAR chChar, FILE *fileOutput);

BOOL OutputLine (PSZ pszString, FILE *fileOutput);

BOOL _WriteChar (CHAR chChar, FILE *fileOutput);

INT ReadLine (PSZ  pszString,
              WORD wMaxChar,
              FILE *fileInput,
              BOOL fHexDump);

INT ReadChar (FILE *fileInput);

BOOL _DosGetLine (CHAR *pchInputString, INT iMaxChar);

BOOL PutString (PSZ pszString);

VOID FAR CriticalErrorHandler (WORD wDevError,
                               WORD wErrCode,
                               BYTE FAR *fpDeviceHeader);

VOID DisplayStatus (WORD wNumber);

VOID ShowStatus (PSZ pszMessage);

BOOL ParseCommandLine (INT *pi, INT argc, PSZ argv[]);

VOID CmdLineHelp (VOID);

BOOL SetMiscGlobals (PSZ);

VOID InitParm1 (PSZ);

VOID MemoryFence (VOID);

#if HEAP_DEBUG

VOID HeapCheck (PSZ pszDescription);

VOID HeapShowStatus (INT iStatus, PSZ pszDescription);

#define OutOfMemory()   NoMemory (__FILE__, __LINE__)
VOID NoMemory (PSZ pszFile, WORD wLine);
#define maxParsedLine pszMsDos
#define minParsedLine maxParsedLine
#define fParserBitmask wMaxRecords

#else

#define HeapCheck()
#define HeapShowStatus()
#define OutOfMemory()   NoMemory()
#define maxParsedLine pszMsDos
#define minParsedLine maxParsedLine
#define fParserBitmask wMaxRecords
VOID NoMemory (VOID);

#endif

VOID BiosStringOutAt (PSZ pszString, WORD wAttrib, WORD wLine, WORD wCol);

VOID BiosStringOut (PSZ pszString, WORD wAttrib);

VOID BiosCharOutAt (WORD wChar,
                    WORD wAttrib,
                    WORD wCopies,
                    WORD wLine,
                    WORD wCol);

VOID BiosCharOut (WORD wChar, WORD wAttrib, WORD wCopies);

VOID BiosLocate (WORD wLine, WORD wCol);

VOID BiosClearScreen (WORD wAttrib);

VOID BiosScrollUp (WORD wX1, WORD wY1,
                   WORD wX2, WORD wY2,
                   WORD wAttrib,
                   WORD wNmbrLines);

VOID BiosDrawFilledBox (WORD wX1, WORD wY1,
                        WORD wX2, WORD wY2,
                        WORD wBorderAttrib,
                        WORD wInteriorAttrib);

VOID BiosDrawBox (WORD wX1, WORD wY1,
                  WORD wX2, WORD wY2,
                  WORD wAttrib);


/*************************** CUSTINFO.C *****************************/

BOOL GetCustInfo (CUSTINFO *pCustInfo, BOOL fMinimumInfo);

BOOL GetCustInfoLine (PSZ pszPromptString, CHAR *pchInputString);

QSZ * SprintCustInfo (VOID *pCustInfo);


/**************************** SUMINFO.C *****************************/

BOOL GetSummaryInfo (SUMMARY_STRUCT *pSum, BOOL fMinimumInfo);

QSZ * SprintSummaryInfo (PSZ paszButtonNames[], SUMMARY_STRUCT *pSum);


/*************************** COMPUTER.C *****************************/

BOOL GetComputerInfo (COMPUTER_STRUCT *pComputer, BOOL fMinimumInfo);

BOOL GetComputerIrqInfo (COMPUTER_STRUCT *pComputer);

QSZ * SprintComputerInfo (COMPUTER_STRUCT *pComputer,
                          CHAR szSumStrings[][MAX_SUMM_INFO + 5]);

WORD GetRomName (BOOL fSearchType, PSZ *ppszStrings);

BOOL GetRomVersion (CHAR pachVersionStrings[][MAX_BIOS_VERSION_LEN],
                    CHAR FAR *fpSearchArea,
                    WORD wSearchLength);

BOOL GetRomDate (CHAR FAR * fpSearchArea,
                 WORD wSearchLength,
                 CHAR * pchDateString);

CHAR FAR *fbiInstr (CHAR FAR *fpSearchArea,
                    PSZ      pszSearchString,
                    WORD     wSearchLength);

CHAR FAR *fbMemString (CHAR FAR *pszfString,
                       WORD *pwLength);

VOID GetBiosCategory (COMPUTER_STRUCT *pComputer);

WORD FAR _cdecl chips (VOID);


/**************************** MEMINFO.C *****************************/

BOOL GetMemInfo (MEMORY_STRUCT *pMem, BOOL fMinimumInfo);

int MInitialize (MEMORY_STRUCT FAR * pMem_Info);

int Get_Conv_Mem_Info (MEMORY_STRUCT FAR * pMem_Info);

int Get_Ext_Mem_Info (MEMORY_STRUCT FAR * pMem_Info);

int GetCMOSExtended (MEMORY_STRUCT FAR * pMem_Info);

int Test_For_Emm (MEMORY_STRUCT FAR * pMem_Info);

int Get_Emm_Info(MEMORY_STRUCT FAR * pMem_Info);

int GetVCPIInfo (MEMORY_STRUCT FAR * pMem_Info);

int GetDPMIInfo (MEMORY_STRUCT FAR * pMem_Info);

int QueryDPMIMemInfo (MEMORY_STRUCT FAR * pMem_Info);

int Get_Xmm_Info(MEMORY_STRUCT FAR * pMem_Info, WORD wProcessorType);

WORD _cdecl _far GetSuperXmsInfo (DWORD XMSControl,
                                  DWORD * SxmsLargestFree,
                                  DWORD * SxmsTotalFree);

VOID GetRomMap (ROM_MAP *pRomMap, WORD wBusType);

int Get_VisualMemMap (MEMORY_STRUCT FAR * pMem_Info, WORD wBusType);

BOOL VisualMapOverlay (MEMORY_STRUCT FAR * pMem);

int FillMemMap (MEMORY_STRUCT FAR * pMem, int iRow, int iCol,
                   int iNumOfChars, unsigned char uchFillChar);

int FillMemMapOverlay (MEMORY_STRUCT FAR * pMem, int iRow, int iCol,
                       int iNumOfChars, unsigned char uchFillChar);

int _fastcall RamRomWomCheck (unsigned uSegment,
                              unsigned uOffset,
                              unsigned uLength,
                              BOOL     fWindowsRunning);

int _fastcall OptionRomCheck (unsigned uSegment, unsigned uOffset);

QSZ * SprintMemInfo (BOOL fMemoryType,
                     MEMORY_STRUCT *pMem,
                     CHAR szSumStrings[][MAX_SUMM_INFO + 5],
                     BOOL fOverlayFlag);

VOID CopyVisualMemMap (MEMORY_STRUCT *pMem,
                       QSZ  qszString,
                       WORD i,
                       BOOL fOverlayFlag);


/*************************** VIDEO.C ********************************/

BOOL GetVideoInfo (VIDEO_STRUCT *pVideo, BOOL fMinimumInfo);

QSZ * SprintVideoInfo (VIDEO_STRUCT *pVideo,
                       CHAR szSumStrings[][MAX_SUMM_INFO + 5]);

PSZ  SubsystemName (BYTE bType);

PSZ  DisplayName (BYTE bType);

BOOL GetTigaInfo (VIDEO_STRUCT *pVideo);

VOID _cdecl FAR VideoID (VIDEO_STRUCT FAR *fpVideo);


/**************************** NETINFO.C *****************************/

BOOL GetNetworkInfo (NETWORK_STRUCT *pNetInfo, BOOL fMinimumInfo);

int Netbios_Installed (NETWORK_STRUCT *pNetInfo);

VOID ClearNcb (struct Ncb * pNcbPtr);

VOID NetbiosRequest (struct Ncb * NcbPointer);

BOOL Novell_Installed (NETWORK_STRUCT *pNetInfo);

VOID Get_Novell_Info (NETWORK_STRUCT *pNetInfo);

int BanyanRunning (VOID);

int LANtasticRunning (NETWORK_STRUCT *pNetInfo);

BOOL Msnet_Installed (VOID);

BOOL Get_Msnet_Machine_Name (NETWORK_STRUCT *pNetInfo);

int LanManager_Installed (NETWORK_STRUCT * pNetInfo);

int GetLanAutoexec (NETWORK_STRUCT * pNetInfo);

void Adapter_Status (NETWORK_STRUCT * pNetInfo);

BOOL Server_Connection (VOID);

BOOL LAN_Basic_Enhanced (NETWORK_STRUCT * pNetInfo);

int Get_CSD_Info (NETWORK_STRUCT * pNetInfo);

VOID GetLM_VersionInfo (NETWORK_STRUCT * pNetInfo);

QSZ * SprintNetworkInfo (NETWORK_STRUCT *pNetInfo,
                         CHAR szSumStrings[][MAX_SUMM_INFO + 5]);

VOID NetBiosStrings (NETWORK_STRUCT * pNetInfo,
                     QSZ            * pqszStrings,
                     INT            * pI);

BOOL GetServicesInfo (QSZ *pqszStrings, INT *pI);

BOOL GetProtocolInfo (NETWORK_STRUCT *pNetInfo, QSZ *pqszStrings, INT *pI);

BOOL GetNifModelInfo (PSZ pszNifFile, QSZ * pqszStrings, INT * pI);

BOOL GetLanmanIniDriverInfo (NETWORK_STRUCT *pNetInfo,
                             QSZ            *pqszStrings,
                             INT            *pI);

BOOL PcNfsInstalled (VOID);

WORD IsWorkgrpSysInstalled (void);

WORD GetTransitionVersion (void);


/**************************** OSINFO.C ******************************/

BOOL GetOsVersionInfo (OS_VERSION_STRUCT *pOsVer, BOOL fMinimumInfo);

QSZ * SprintOsVersionInfo (OS_VERSION_STRUCT *pOsVer,
                           CHAR szSumStrings[][MAX_SUMM_INFO + 5]);

VOID OsErr (VOID);

BOOL WinVerDetect (WORD *pwWindowsType,
                   WORD *pwWindowsMajor,
                   WORD *pwWindowsMinor,
                   WORD *pfDosShell);

BOOL GetDosOemStrings (OS_VERSION_STRUCT *pOsVer);


/*************************** MOUSINFO.C *****************************/

BOOL GetMouseInfo (MOUSE_STRUCT *pMouse);

VOID NoMouseDriver (MOUSE_STRUCT *pMouse);

QSZ * SprintMouseInfo (MOUSE_STRUCT *pMouse,
                       CHAR szSumStrings[][MAX_SUMM_INFO + 5]);

BOOL AltPS2MouseChk (VOID);

WORD FAR _cdecl fnHardMouseDetect (VOID);

WORD FAR _cdecl ArcnetCardPresent (VOID);


/*************************** OTHRINFO.C *****************************/

BOOL GetOtherInfo (OTHER_STRUCT *pOther, BOOL fMinimumInfo);

BOOL GetGameAdapterValues (OTHER_STRUCT *pOther);

QSZ * SprintOtherInfo (OTHER_STRUCT *pOther,
                       CHAR szSumStrings[][MAX_SUMM_INFO + 5]);


/*************************** DISKINFO.C *****************************/

BOOL GetDiskInfo (DISK_STRUCT *pDisk, BOOL fMinimumInfo);

VOID _cdecl GetCmosDiskInfo (WORD wHardDriveNmbr,
                             DISK_STRUCT *pDisk,
                             WORD wDriveIndex);

BOOL ValidDrive (BYTE bDrive);

BYTE DosGetCurrentDrive (VOID);

BYTE DosSetCurrentDrive (BYTE bDrive);

VOID GetDiskProgList (DISK_STRUCT *pDisk, WORD wDosVersion);

QSZ * SprintDiskInfo (DISK_STRUCT *pDisk,
                      CHAR szSumStrings[][MAX_SUMM_INFO + 5]);


/**************************** LPTINFO.C *****************************/

BOOL GetLptInfo (LPT_STRUCT *pLpt, BOOL fMinimumInfo);

QSZ * SprintLptInfo (LPT_STRUCT *pLpt,
                     CHAR szSumStrings[][MAX_SUMM_INFO + 5]);


/**************************** COMINFO.C *****************************/

BOOL GetComInfo (COM_STRUCT *pCom, BOOL fMinimumInfo);

QSZ * SprintComInfo (COM_STRUCT *pCom,
                     CHAR szSumStrings[][MAX_SUMM_INFO + 5]);


/**************************** IRQINFO.C *****************************/

BOOL GetIrqInfo (IRQ_STRUCT *pIrq, BOOL fMinimumInfo);

BOOL SetIrqDetectedStrings (IRQ_STRUCT       *pIrq,
                            COMPUTER_STRUCT  *pComputer,
                            MOUSE_STRUCT     *pMouse,
                            DISK_STRUCT      *pDisk,
                            LPT_STRUCT       *pLpt,
                            COM_STRUCT       *pCom);

BOOL SetIrqHandledByStrings (IRQ_STRUCT           *pIrq,
                             TSR_PROGRAMS_STRUCT  *pTsr,
                             DEVICE_DRIVER_STRUCT *pDevice);

QSZ * SprintIrqInfo (IRQ_STRUCT *pIrq);

BOOL GetSwIntTable (VOID);


/**************************** TSRLIST.C *****************************/

WORD GetTsrInfoSize (VOID);

CHAR FAR * FindFirstMcbHeader (VOID);

QSZ * SprintTsrInfo (TSR_PROGRAMS_STRUCT *pTsrStruct,
                     BOOL fIncludeParms);

BOOL GetTsrInfo (TSR_PROGRAMS_STRUCT *pTsrStruct, BOOL fMinimumInfo);

VOID LinkUmbToDosChain (BOOL fLinkFlag);


/**************************** DEVTAB.C ******************************/

WORD GetDeviceDriversSize (VOID);

BOOL GetDeviceDriversInfo (DEVICE_DRIVER_STRUCT *pDevStruct,
                           BOOL fMinimumInfo);

QSZ * SprintDeviceDriverInfo (DEVICE_DRIVER_STRUCT *pDevStruct);

CHAR FAR * FindFirstDevHeader (VOID);


/*************************** VIEWFILE.C *****************************/

QSZ * ViewFile (PSZ pszFilename, BOOL fHexDump);

BOOL FindAndViewFile (PSZ pszFilename, BOOL fSearchFlags, BOOL fHexDump);


/**************************** INSERT.C ******************************/

VOID InsertCommand (VOID);

BOOL ChangeFile (PSZ  pszFilename,
                 PSZ  pszSection,
                 PSZ  pszCommand,
                 PSZ  pszSearchString,
                 WORD wReplaceLine);

VOID ReadCommands (PWND pwnd);

BOOL FindSection (PSZ  pszSection, FILE *fpInsertFile, FILE *fpOutputFile);

BOOL HandleDuplicates (WORD wFunction,
                       PSZ  pszSearch,
                       PSZ  pszReplace,
                       FILE *fpInfile,
                       FILE *fpOutfile,
                       PWND pwndList);

BOOL HdMatch (char *pszSearch, char *pszFullLine);

FILE * OpenIniFile (VOID);

BOOL WriteThrough (FILE *fpInputFile, FILE *fpOutputFile);

VOID AddIniLine (PWND pwndList, PSZ pszString);


/**************************** BROWSE.C ******************************/

QSZ * GetBrowseInfo (PSZ      pszTitle,
                     PSZ      pszSearchString,
                     CHAR FAR *fpSearchArea,
                     DWORD    dwSearchLength);

QSZ * SprintBrowseInfo (MEM_STRING_DATA *pmsdData);

PSZ * ListOptionRoms (VOID);

BOOL ReportBrowseInfo (FILE *fileReportFile);

VOID BrowseInit (char far *cfpSearchArea,
                 MEM_STRING_DATA *msdFoundStrings,
                 int iMaxMSDStrings);

int Browse (char **paszSearchStrings,
            char far *cfpSearchArea,
            unsigned int uiLengthOfSearch,
            MEM_STRING_DATA *msdFoundStrings,
            int iMaxMSDStrings);

void ClearMSDArray (MEM_STRING_DATA *msd, int iStringCount);

int SingleStringMemSearch (MEM_STRING_DATA *msdFoundArray,
                           int iMaxArray,
                           char *pszSearchString,
                           char far *cfpAreaToSearch,
                           unsigned int uiLengthOfSearch);

int AddToFoundArray (char far *pszfString,
                     int iStringLength,
                     MEM_STRING_DATA *msdArray,
                     int iMaxArray);


/**************************** VERINFO.C *****************************/

typedef struct _LANGUAGE_ID
{
  WORD wLanguageId;
  PSZ  pszLanguageId;
} LANGUAGE_ID;

#define MAX_LANGUAGE_IDS 44
extern LANGUAGE_ID rgLang[];

typedef struct _CODEPAGE_ID
{
  WORD wCodePage;
  PSZ  pszCodePage;
} CODEPAGE_ID;

extern CODEPAGE_ID rgCP[];
#define MAX_CODEPAGE 11

BYTE * GetFileVersion (PSZ pszFilename, BOOL fMinimumInfo);

QSZ * SprintFileVersion (BYTE * pVer);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\netcons.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/********************************************************************
 *								    *
 *  About this file ...  NETCONS.H				    *
 *								    *
 *  This file contains constants used throughout the LAN Manager    *
 *  API header files.  It should be included in any source file     *
 *  that is going to include other LAN Manager API header files or  *
 *  call a LAN Manager API.					    *
 *								    *
 ********************************************************************/

/*
 *	NOTE:  Lengths of ASCIIZ strings are given as the maximum
 *	strlen() value.  This does not include space for the 
 *	terminating 0-byte.  When allocating space for such an item,
 *	use the form:
 *
 *		char username[UNLEN+1];
 *
 *	An exception to this is the PATHLEN manifest, which does
 *	include space for the terminating 0-byte.
 */

#ifndef NETCONS_INCLUDED

#define NETCONS_INCLUDED


#define CNLEN		15		    /* Computer name length     */
#define UNCLEN		(CNLEN+2)	    /* UNC computer name length */
#define NNLEN		12		    /* 8.3 Net name length      */
#define RMLEN		(UNCLEN+1+NNLEN)    /* Maximum remote name length */

#define SNLEN		15		    /* Service name length      */
#define STXTLEN		63		    /* Service text length      */

#define PATHLEN 	260

#define DEVLEN		 8 		    /* Device name length	*/

#define DNLEN		CNLEN		    /* Maximum domain name length */
#define EVLEN		16		    /* event name length        */
#define JOBSTLEN	80		    /* status length in print job */
#define	AFLEN		64		    /* Maximum length of alert  */
					    /* names field 		*/
#define UNLEN		20	   	    /* Maximum user name length	*/
#define GNLEN 		UNLEN		    /* Group name               */
#define PWLEN		14		    /* Maximum password length  */
#define SHPWLEN 	 8		    /* Share password length	*/
#define CLTYPE_LEN	12		    /* Length of client type string */


#define MAXCOMMENTSZ	48		    /* server & share comment length */

#define QNLEN		12		    /* Queue name maximum length     */
#define PDLEN		 8		    /* Print destination length      */
#define DTLEN		 9	            /* Spool file data type          */
					    /* e.g. IBMQSTD,IBMQESC,IBMQRAW  */
#define ALERTSZ		128		    /* size of alert string in server */
#define MAXDEVENTRIES	(sizeof (int)*8)    /* Max number of device entries   */
					    /* We use int bitmap to represent */

#define	HOURS_IN_WEEK		24*7	    /* for struct user_info_2 in UAS */
#define	MAXWORKSTATIONS		8	    /* for struct user_info_2 in UAS */

#define NETBIOS_NAME_LEN	16	    /* NetBIOS net name */



/*
 *	Constants used with encryption
 */

#define	CRYPT_KEY_LEN	7
#define	CRYPT_TXT_LEN	8
#define ENCRYPTED_PWLEN	16
#define SESSION_PWLEN	24
#define SESSION_CRYPT_KLEN 21

/*
 *  Value to be used with SetInfo calls to allow setting of all
 *  settable parameters (parmnum zero option)
*/
#ifndef  PARMNUM_ALL
#define		PARMNUM_ALL		0
#endif

/*
 *	Message File Names
 */

#define MESSAGE_FILE		"NETPROG\\NET.MSG"
#define MESSAGE_FILENAME	"NET.MSG"
#define OS2MSG_FILE		"NETPROG\\OSO001.MSG"
#define OS2MSG_FILENAME		"OSO001.MSG"
#define HELP_MSG_FILE		"NETPROG\\NETH.MSG"
#define HELP_MSG_FILENAME	"NETH.MSG"
#define NMP_MSG_FILE		"NETPROG\\NMP.MSG"
#define NMP_MSG_FILENAME	"NMP.MSG"

#define MESSAGE_FILE_BASE	"NETPROG\\NET00000"
#define MESSAGE_FILE_EXT	".MSG"



#define NMP_LOW_END		230
#define NMP_HIGH_END		240

#ifndef NULL
#define  NULL    0
#endif


#define PUNAVAIL NULL
#define API_RET_TYPE unsigned
#define API_FUNCTION API_RET_TYPE far pascal







#endif /* NETCONS_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\neterr.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/***	neterr.h - network error definitions
 *
 */



#ifndef NETERR_INCLUDED

#define NETERR_INCLUDED 


#define NERR_Success		0	/* Success */

/*
 *	Redirector related
 *		Error codes from 50 to 79, 88, and 230 to 249
 */

#define ERROR_NOT_SUPPORTED	50	/* The network request is not supported.  */
#define ERROR_REM_NOT_LIST	51	/* This remote computer is not listening. */
#define ERROR_DUP_NAME		52	/* A duplicate name exists on the network. */
#define ERROR_BAD_NETPATH	53	/* The network path cannot be located. */
#define ERROR_NETWORK_BUSY	54	/* The network is busy. */
#define ERROR_DEV_NOT_EXIST	55	/* This device does not exist on the network. */
#define ERROR_TOO_MANY_CMDS	56	/* The network BIOS command limit has been reached. */
#define ERROR_ADAP_HDW_ERR	57	/* A network adapter hardware error has occurred. */
#define ERROR_BAD_NET_RESP	58	/* The network responded incorrectly. */
#define ERROR_UNEXP_NET_ERR	59	/* An unexpected network error occurred. */
#define ERROR_BAD_REM_ADAP	60	/* The remote adapter is not compatible. */
#define ERROR_PRINTQ_FULL	61	/* The printer queue is full. */
#define ERROR_NO_SPOOL_SPACE	62	/* Space to store the file waiting to be printed is not available on the server. */
#define ERROR_PRINT_CANCELLED	63	/* The requested print file has been cancelled. */
#define ERROR_NETNAME_DELETED	64	/* The network name was deleted. */
#define	ERROR_NETWORK_ACCESS_DENIED 65	/* Network access is denied. */
#define ERROR_BAD_DEV_TYPE	66	/* The network resource type is not correct. */
#define ERROR_BAD_NET_NAME	67	/* The network name cannot be found. */
#define ERROR_TOO_MANY_NAMES	68	/* The name limit for the local computer network adapter card was exceeded. */
#define ERROR_TOO_MANY_SESS	69	/* The network BIOS session limit was exceeded. */
#define ERROR_SHARING_PAUSED	70	/* File sharing has been temporarily paused. */
#define ERROR_REQ_NOT_ACCEP	71	/* The network request was not accepted. */
#define ERROR_REDIR_PAUSED	72	/* Print or disk redirection is temporarily paused. */

#define ERROR_NET_WRITE_FAULT	88	/* A network data fault occurred. */

#define	ERROR_BAD_PIPE		230	/* This is a nonexistent pipe or an invalid operation. */
#define	ERROR_PIPE_BUSY		231	/* The specified pipe is busy. */
#define	ERROR_NO_DATA		232	/* There is no data to be read on a non-blocking read. */
#define	ERROR_PIPE_NOT_CONNECTED 233	/* The server disconnected the pipe. */
#define	ERROR_MORE_DATA		234	/* Additional data is available. */

#define	ERROR_VC_DISCONNECTED	240	/* The session was cancelled. */


/***	NERR_BASE is the base of error codes from network utilities,
 *	chosen to avoid conflict with OS/2 and redirector error codes.
 *	2100 is a value that has been assigned to us by OS/2.
 */
#define	NERR_BASE	2100



/* UNUSED BASE+0 */
/* UNUSED BASE+1 */
#define NERR_NetNotStarted	(NERR_BASE+2)	/* The workstation driver (NETWKSTA.SYS on OS/2 workstations, NETWKSTA.EXE on DOS workstations) isn't installed. */
#define NERR_UnknownServer	(NERR_BASE+3)	/* The server cannot be located. */
#define NERR_ShareMem		(NERR_BASE+4)	/* An internal error occurred.  The network cannot access a shared memory segment. */
#define NERR_NoNetworkResource	(NERR_BASE+5)	/* A network resource shortage occurred . */
#define NERR_RemoteOnly		(NERR_BASE+6)	/* This operation is not supported on workstations. */
#define NERR_DevNotRedirected	(NERR_BASE+7)	/* The device is not connected. */
/* UNUSED BASE+8 */
/* UNUSED BASE+9 */
/* UNUSED BASE+10 */
/* UNUSED BASE+11 */
/* UNUSED BASE+12 */
/* UNUSED BASE+13 */
#define NERR_ServerNotStarted	(NERR_BASE+14)	/* The Server service isn't started. */
#define NERR_ItemNotFound	(NERR_BASE+15)	/* The queue is empty. */
#define NERR_UnknownDevDir	(NERR_BASE+16)	/* The device or directory does not exist. */
#define NERR_RedirectedPath	(NERR_BASE+17)	/* The operation is invalid on a redirected resource. */
#define NERR_DuplicateShare	(NERR_BASE+18)	/* The name has already been shared. */
#define NERR_NoRoom		(NERR_BASE+19)	/* The server is currently out of the requested resource. */
/* UNUSED BASE+20 */
#define NERR_TooManyItems	(NERR_BASE+21)	/* Requested add of item exceeds maximum allowed. */
#define NERR_InvalidMaxUsers	(NERR_BASE+22)	/* The Peer service supports only two simultaneous users. */
#define NERR_BufTooSmall	(NERR_BASE+23)	/* The API return buffer is too small. */
/* UNUSED BASE+24 */
/* UNUSED BASE+25 */
/* UNUSED BASE+26 */
#define NERR_RemoteErr		(NERR_BASE+27)	/* A remote API error occurred.  */
/* UNUSED BASE+28 */
/* UNUSED BASE+29 */
/* UNUSED BASE+30 */
#define NERR_LanmanIniError	(NERR_BASE+31)	/* An error occurred when opening or reading LANMAN.INI. */
/* UNUSED BASE+32 */
/* UNUSED BASE+33 */
#define NERR_OS2IoctlError	(NERR_BASE+34)	/* An internal error occurred when calling the workstation driver. */
/* UNUSED BASE+35 */
#define	NERR_NetworkError	(NERR_BASE+36)	/* A general network error occurred. */
/* UNUSED BASE+37 */
#define NERR_WkstaNotStarted	(NERR_BASE+38)	/* The Workstation service has not been started. */
#define NERR_BrowserNotStarted	(NERR_BASE+39)	/* The requested information is not available. */
#define NERR_InternalError	(NERR_BASE+40)	/* An internal LAN Manager error occurred.*/
#define NERR_BadTransactConfig	(NERR_BASE+41)	/* The server is not configured for transactions. */
#define NERR_InvalidAPI		(NERR_BASE+42)	/* The requested API isn't supported on the remote server. */
#define NERR_BadEventName	(NERR_BASE+43)	/* The event name is invalid. */
/* UNUSED BASE+44 */

/*
 *	Config API related
 *		Error codes from BASE+45 to BASE+49
 */

/* UNUSED BASE+45 */
#define NERR_CfgCompNotFound	(NERR_BASE+46)	/* Could not find the specified component in LANMAN.INI. */
#define NERR_CfgParamNotFound	(NERR_BASE+47)	/* Could not find the specified parameter in LANMAN.INI. */
#define NERR_LineTooLong	(NERR_BASE+49)	/* A line in LANMAN.INI is too long. */

/*
 *	Spooler API related
 *		Error codes from BASE+50 to BASE+79
 */

#define NERR_QNotFound		(NERR_BASE+50)	/* The printer queue does not exist. */
#define NERR_JobNotFound	(NERR_BASE+51)	/* The print job does not exist. */
#define NERR_DestNotFound	(NERR_BASE+52)	/* The printer destination cannot be found. */
#define NERR_DestExists 	(NERR_BASE+53)	/* The printer destination already exists. */
#define NERR_QExists		(NERR_BASE+54)	/* The printer queue already exists. */
#define NERR_QNoRoom		(NERR_BASE+55)	/* No more printer queues can be added. */
#define NERR_JobNoRoom		(NERR_BASE+56)	/* No more print jobs can be added.  */
#define NERR_DestNoRoom 	(NERR_BASE+57)	/* No more printer destinations can be added. */
#define NERR_DestIdle		(NERR_BASE+58)	/* This printer destination is idle and cannot accept control operations. */
#define NERR_DestInvalidOp	(NERR_BASE+59)	/* This printer destination request contains an invalid control function. */
#define NERR_ProcNoRespond	(NERR_BASE+60)	/* The printer processor is not responding. */
#define NERR_SpoolerNotLoaded	(NERR_BASE+61)	/* The spooler is not running. */
#define NERR_DestInvalidState	(NERR_BASE+62)	/* This operation cannot be performed on the print destination in its current state. */
#define NERR_QInvalidState	(NERR_BASE+63)	/* This operation cannot be performed on the printer queue in its current state. */
#define NERR_JobInvalidState	(NERR_BASE+64)	/* This operation cannot be performed on the print job in its current state. */
#define	NERR_SpoolNoMemory	(NERR_BASE+65)	/* A spooler memory allocation failure occurred. */
#define NERR_DriverNotFound	(NERR_BASE+66)	/* The device driver does not exist. */
#define NERR_DataTypeInvalid	(NERR_BASE+67)	/* The datatype is not supported by the processor. */
#define NERR_ProcNotFound	(NERR_BASE+68)	/* The print processor is not installed. */

/*
 *	Service API related
 *		Error codes from BASE+80 to BASE+99
 */

#define NERR_ServiceTableLocked	(NERR_BASE+80)	/* The service does not respond to control actions. */
#define NERR_ServiceTableFull	(NERR_BASE+81)	/* The service table is full. */
#define NERR_ServiceInstalled	(NERR_BASE+82)	/* The requested service has already been started. */
#define NERR_ServiceEntryLocked	(NERR_BASE+83)	/* The service does not respond to control actions. */
#define NERR_ServiceNotInstalled (NERR_BASE+84) /* The service has not been started. */
#define NERR_BadServiceName	(NERR_BASE+85)	/* The service name is invalid. */
#define NERR_ServiceCtlTimeout	(NERR_BASE+86)	/* The service is not responding to the control function. */
#define NERR_ServiceCtlBusy	(NERR_BASE+87)	/* The service control is busy. */
#define NERR_BadServiceProgName	(NERR_BASE+88)	/* LANMAN.INI contains an invalid service program name. */
#define NERR_ServiceNotCtrl	(NERR_BASE+89)	/* The service cannot be controlled in its present state. */
#define NERR_ServiceKillProc	(NERR_BASE+90)	/* The service ended abnormally. */
#define NERR_ServiceCtlNotValid	(NERR_BASE+91)	/* The requested pause or stop is not valid for this service. */

/*
 *	Wksta and Logon API related
 *		Error codes from BASE+100 to BASE+118
 */

#define NERR_AlreadyLoggedOn	(NERR_BASE+100)	/* This workstation is already logged on to the local-area network. */
#define NERR_NotLoggedOn	(NERR_BASE+101)	/* The workstation isn't logged on to the local-area network. */
#define NERR_BadUsername	(NERR_BASE+102)	/* The username or groupname parameter is invalid.  */
#define NERR_BadPassword	(NERR_BASE+103)	/* The password parameter is invalid. */
#define NERR_UnableToAddName_W	(NERR_BASE+104)	/* @W The logon processor did not add the message alias. */
#define NERR_UnableToAddName_F	(NERR_BASE+105)	/* The logon processor did not add the message alias. */
#define NERR_UnableToDelName_W	(NERR_BASE+106)	/* @W The logoff processor did not delete the message alias. */
#define NERR_UnableToDelName_F	(NERR_BASE+107)	/* The logoff processor did not delete the message alias. */
/* UNUSED BASE+108 */
#define NERR_LogonsPaused 	(NERR_BASE+109) /* Network logons are paused. */
#define NERR_LogonServerConflict (NERR_BASE+110)/* A centralized logon-server conflict occurred. */
#define NERR_LogonNoUserPath	(NERR_BASE+111) /* The server is configured without a valid user path. */
#define NERR_LogonScriptError	(NERR_BASE+112) /* An error occurred while loading or running the logon script. */
/* UNUSED BASE+113 */
#define NERR_StandaloneLogon    (NERR_BASE+114) /* The logon server was not specified.  Your computer will be logged on as STANDALONE. */
#define NERR_LogonServerNotFound (NERR_BASE+115) /* The logon server cannot be found.  */
#define NERR_LogonDomainExists	(NERR_BASE+116) /* There is already a logon domain for this computer.  */
#define NERR_NonValidatedLogon	(NERR_BASE+117) /* The logon server could not validate the logon. */

/*
 *	ACF API related (access, user, group)
 *		Error codes from BASE+119 to BASE+149
 */

#define NERR_ACFNotFound	(NERR_BASE+119)	/* The accounts file NET.ACC cannot be found. */
#define NERR_GroupNotFound	(NERR_BASE+120)	/* The groupname cannot be found. */
#define NERR_UserNotFound	(NERR_BASE+121)	/* The username cannot be found. */
#define NERR_ResourceNotFound	(NERR_BASE+122)	/* The resource name cannot be found.  */
#define NERR_GroupExists	(NERR_BASE+123)	/* The group already exists. */
#define NERR_UserExists		(NERR_BASE+124)	/* The user account already exists. */
#define NERR_ResourceExists	(NERR_BASE+125)	/* The resource permission list already exists. */
#define NERR_NotPrimary		(NERR_BASE+126)	/* The UAS database is replicant and will not allow updates. */
#define NERR_ACFNotLoaded	(NERR_BASE+127) /* The user account system has not been started. */
#define NERR_ACFNoRoom		(NERR_BASE+128)	/* There are too many names in the user account system. */
#define NERR_ACFFileIOFail	(NERR_BASE+129)	/* A disk I/O failure occurred.*/
#define NERR_ACFTooManyLists	(NERR_BASE+130)	/* The limit of 64 entries per resource was exceeded. */
#define NERR_UserLogon		(NERR_BASE+131) /* Deleting a user with a session is not allowed. */
#define NERR_ACFNoParent	(NERR_BASE+132)	/* The parent directory cannot be located. */
#define NERR_CanNotGrowSegment  (NERR_BASE+133) /* Unable to grow UAS session cache segment. */
#define NERR_SpeGroupOp		(NERR_BASE+134) /* This operation is not allowed on this special group. */
#define NERR_NotInCache  	(NERR_BASE+135) /* This user is not cached in UAS session cache. */
#define NERR_UserInGroup	(NERR_BASE+136) /* The user already belongs to this group. */
#define NERR_UserNotInGroup	(NERR_BASE+137) /* The user does not belong to this group. */
#define NERR_AccountUndefined	(NERR_BASE+138) /* This user account is undefined. */
#define NERR_AccountExpired	(NERR_BASE+139) /* This user account has expired. */
#define NERR_InvalidWorkstation (NERR_BASE+140) /* The user is not allowed to log on from this workstation. */
#define NERR_InvalidLogonHours	(NERR_BASE+141) /* The user is not allowed to log on at this time.  */
#define NERR_PasswordExpired	(NERR_BASE+142) /* The password of this user has expired. */
#define NERR_PasswordCantChange (NERR_BASE+143) /* The password of this user cannot change. */
#define NERR_PasswordHistConflict (NERR_BASE+144) /* This password cannot be used now. */
#define NERR_PasswordTooShort	(NERR_BASE+145) /* The password is shorter than required. */
#define NERR_PasswordTooRecent	(NERR_BASE+146) /* The password of this user is too recent to change.  */
#define NERR_InvalidDatabase	(NERR_BASE+147) /* The UAS database file is corrupted. */
#define NERR_DatabaseUpToDate	(NERR_BASE+148) /* No updates are necessary to this replicant UAS database. */
#define NERR_SyncRequired	(NERR_BASE+149) /* This replicant database is outdated; synchronization is required. */

/*
 *	Use API related 
 *		Error codes from BASE+150 to BASE+169
 */

#define NERR_UseNotFound	(NERR_BASE+150)	/* The connection cannot be found. */
#define NERR_BadAsgType		(NERR_BASE+151)	/* This asg_type is invalid. */
#define NERR_DeviceIsShared	(NERR_BASE+152) /* This device is currently being shared. */

/* 
 *	Message Server related 
 *		Error codes BASE+170 to BASE+209
 */

#define	NERR_NoComputerName	(NERR_BASE+170)	/* A computername has not been configured.  */
#define	NERR_MsgAlreadyStarted	(NERR_BASE+171)	/* The Messenger service is already started. */
#define NERR_MsgInitFailed	(NERR_BASE+172)	/* The Messenger service failed to start.  */
#define	NERR_NameNotFound	(NERR_BASE+173)	/* The message alias cannot be found on the local-area network. */
#define	NERR_AlreadyForwarded	(NERR_BASE+174)	/* This message alias has already been forwarded. */
#define NERR_AddForwarded	(NERR_BASE+175)	/* This message alias has been added but is still forwarded. */
#define NERR_AlreadyExists	(NERR_BASE+176)	/* This message alias already exists locally. */
#define	NERR_TooManyNames	(NERR_BASE+177)	/* The maximum number of added message aliases has been exceeded. */
#define NERR_DelComputerName	(NERR_BASE+178)	/* The computername cannot be deleted.*/
#define	NERR_LocalForward	(NERR_BASE+179)	/* Messages cannot be forwarded back to the same workstation. */
#define NERR_GrpMsgProcessor	(NERR_BASE+180) /* Error in domain message processor */
#define NERR_PausedRemote	(NERR_BASE+181)	/* The message was sent, but the recipient has paused the Messenger service. */
#define	NERR_BadReceive		(NERR_BASE+182)	/* The message was sent but not received. */
#define	NERR_NameInUse		(NERR_BASE+183)	/* The message alias is currently in use. Try again later. */
#define	NERR_MsgNotStarted	(NERR_BASE+184)	/* The Messenger service has not been started. */
#define	NERR_NotLocalName	(NERR_BASE+185)	/* The name is not on the local computer. */
#define	NERR_NoForwardName	(NERR_BASE+186)	/* The forwarded message alias cannot be found on the network. */
#define	NERR_RemoteFull		(NERR_BASE+187)	/* The message alias table on the remote station is full. */
#define NERR_NameNotForwarded	(NERR_BASE+188)	/* Messages for this alias are not currently being forwarded. */
#define NERR_TruncatedBroadcast	(NERR_BASE+189)	/* The broadcast message was truncated. */
#define	NERR_InvalidDevice	(NERR_BASE+194)	/* This is an invalid devicename. */
#define	NERR_WriteFault		(NERR_BASE+195)	/* A write fault occurred. */
/* UNUSED BASE+196 */
#define	NERR_DuplicateName	(NERR_BASE+197)	/* A duplicate message alias exists on the local-area network. */
#define	NERR_DeleteLater	(NERR_BASE+198)	/* @W This message alias will be deleted later. */
#define NERR_IncompleteDel	(NERR_BASE+199) /* The message alias was not successfully deleted from all networks. */
#define NERR_MultipleNets	(NERR_BASE+200) /* This operation is not supported on machines with multiple networks. */

/* 
 * 	Server API related 
 *		Error codes BASE+210 to BASE+229
 */
 
#define NERR_NetNameNotFound	(NERR_BASE+210)	/* This shared resource does not exist.*/
#define	NERR_DeviceNotShared	(NERR_BASE+211)	/* This device is not shared. */
#define NERR_ClientNameNotFound	(NERR_BASE+212)	/* A session does not exist with that computername. */
#define NERR_FileIdNotFound	(NERR_BASE+214)	/* There isn't an open file with that ID number. */
#define NERR_ExecFailure	(NERR_BASE+215)	/* A failure occurred when executing a remote administration command. */
#define NERR_TmpFile		(NERR_BASE+216) /* A failure occurred when opening a remote temporary file. */
#define NERR_TooMuchData	(NERR_BASE+217) /* The data returned from a remote administration command has been truncated to 64K. */
#define NERR_DeviceShareConflict (NERR_BASE+218) /* This device cannot be shared as both a spooled and a non-spooled resource. */
#define NERR_BrowserTableIncomplete (NERR_BASE+219)  /* The information in the list of servers may be incorrect. */
#define NERR_NotLocalDomain	(NERR_BASE+220) /* The computer isn't active on this domain. */

/* 
 * 	CharDev API related 
 *		Error codes BASE+230 to BASE+249
 */
 
/* UNUSED BASE+230 */
#define NERR_DevInvalidOpCode	(NERR_BASE+231)	/* The operation is invalid for this device. */
#define NERR_DevNotFound	(NERR_BASE+232)	/* This device cannot be shared. */
#define NERR_DevNotOpen		(NERR_BASE+233)	/* This device was not open. */
#define NERR_BadQueueDevString	(NERR_BASE+234)	/* This devicename list is invalid. */
#define NERR_BadQueuePriority	(NERR_BASE+235)	/* The queue priority is invalid. */
#define NERR_NoCommDevs		(NERR_BASE+237)	/* There are no shared communication devices. */
#define NERR_QueueNotFound	(NERR_BASE+238)	/* The queue you specified doesn't exist. */
#define NERR_BadDevString	(NERR_BASE+240) /* This list of devices is invalid. */
#define NERR_BadDev		(NERR_BASE+241) /* The requested device is invalid. */
#define NERR_InUseBySpooler	(NERR_BASE+242) /* This device is already in use by the spooler. */
#define NERR_CommDevInUse	(NERR_BASE+243) /* This device is already in use as a communication device. */

/* 
 *	NetICanonicalize and NetIType and NetIMakeLMFileName
 *	NetIListCanon and NetINameCheck
 *		Error codes BASE+250 to BASE+269
 */
 
#define NERR_InvalidComputer   (NERR_BASE+251) /* This computername is invalid. */
/* UNUSED BASE+252 */
/* UNUSED BASE+253 */
#define NERR_MaxLenExceeded    (NERR_BASE+254) /* The string and prefix specified are too long. */
/* UNUSED BASE+255 */
#define NERR_BadComponent      (NERR_BASE+256) /* This path component is invalid. */
#define NERR_CantType	       (NERR_BASE+257) /* Cannot determine type of input. */
/* UNUSED BASE+258 */
/* UNUSED BASE+259 */
#define NERR_TooManyEntries    (NERR_BASE+262) /* The buffer for types is not big enough. */

/* 
 *	NetProfile
 *		Error codes BASE+270 to BASE+276
 */
 
#define NERR_ProfileFileTooBig	(NERR_BASE+270) /* Profile files cannot exceed 64K. */
#define NERR_ProfileOffset	(NERR_BASE+271) /* The start offset is out of range. */
#define NERR_ProfileCleanup	(NERR_BASE+272) /* The system cannot delete current connections to network resources. */
#define NERR_ProfileUnknownCmd	(NERR_BASE+273) /* The system was unable to parse the command line in this file.*/
#define NERR_ProfileLoadErr	(NERR_BASE+274) /* An error occurred while loading the profile file. */
#define NERR_ProfileSaveErr	(NERR_BASE+275) /* @W Errors occurred while saving the profile file.  The profile was partially saved. */


/*
 * 	NetAudit and NetErrorLog
 *		Error codes BASE+277 to BASE+279
 */

#define NERR_LogOverflow	   (NERR_BASE+277)	/* This log file exceeds the maximum defined size. */
#define NERR_LogFileChanged	   (NERR_BASE+278)	/* This log file has changed between reads. */
#define NERR_LogFileCorrupt	   (NERR_BASE+279)	/* This log file is corrupt. */

/* 
 *	NetRemote
 *		Error codes BASE+280 to BASE+299
 */
#define NERR_SourceIsDir   (NERR_BASE+280) /* The source path cannot be a directory. */
#define NERR_BadSource     (NERR_BASE+281) /* The source path is illegal. */
#define NERR_BadDest       (NERR_BASE+282) /* The destination path is illegal. */
#define NERR_DifferentServers   (NERR_BASE+283) /* The source and destination paths are on different servers. */
/* UNUSED BASE+284 */
#define NERR_RunSrvPaused 	(NERR_BASE+285) /* The Run server you requested is paused. */
/* UNUSED BASE+286 */
/* UNUSED BASE+287 */
/* UNUSED BASE+288 */
#define NERR_ErrCommRunSrv 	(NERR_BASE+289) /* An error occurred when communicating with a Run server. */
/* UNUSED BASE+290 */
#define NERR_ErrorExecingGhost 	(NERR_BASE+291) /* An error occurred when starting a background process. */
#define NERR_ShareNotFound 	(NERR_BASE+292) /* The shared resource you are connected to could not be found.*/
/* UNUSED BASE+293 */
/* UNUSED BASE+294 */


/*
 *  NetWksta.sys (redir) returned error codes.
 *
 *          NERR_BASE + (300-329)
 */

#define NERR_InvalidLana        (NERR_BASE+300) /* The LAN adapter number is invalid.  */
#define NERR_OpenFiles          (NERR_BASE+301) /* There are open files on the connection.    */
#define NERR_ActiveConns        (NERR_BASE+302) /* Active connections still exist. */
#define NERR_BadPasswordCore    (NERR_BASE+303) /* This netname or password is invalid. */
#define NERR_DevInUse           (NERR_BASE+304) /* The device is being accessed by an active process. */
#define NERR_LocalDrive		(NERR_BASE+305) /* The drive letter is in use locally. */

/*
 *  Alert error codes.
 *
 *          NERR_BASE + (330-339)
 */
#define NERR_AlertExists	(NERR_BASE+330)	/* The specified client is already registered for the specified event. */
#define NERR_TooManyAlerts	(NERR_BASE+331)	/* The alert table is full. */
#define NERR_NoSuchAlert	(NERR_BASE+332)	/* An invalid or nonexistent alertname was raised. */
#define NERR_BadRecipient       (NERR_BASE+333) /* The alert recipient is invalid.*/
#define NERR_AcctLimitExceeded	(NERR_BASE+334) /* A user's session with this server has been deleted
						 * because his logon hours are no longer valid */

/*
 *  Additional Error and Audit log codes.
 *
 *	    NERR_BASE +(340-343)
 */
#define NERR_InvalidLogSeek	(NERR_BASE+340) /* The log file does not contain the requested record number. */
/* UNUSED BASE+341 */
/* UNUSED BASE+342 */
/* UNUSED BASE+343 */

/*
 *  Additional UAS and NETLOGON codes
 *
 *	    NERR_BASE +(350-359)
 */
#define NERR_BadUasConfig	(NERR_BASE+350) /* The user account system database is not configured correctly. */
#define NERR_InvalidUASOp	(NERR_BASE+351) /* This operation is not permitted when the Netlogon service is running. */
#define NERR_LastAdmin		(NERR_BASE+352) /* This operation is not allowed on the last admin account. */
#define NERR_DCNotFound		(NERR_BASE+353) /* Unable to find domain controller for this domain. */
#define NERR_LogonTrackingError	(NERR_BASE+354) /* Unable to set logon information for this user. */
#define NERR_NetlogonNotStarted (NERR_BASE+355) /* The Netlogon service has not been started. */
#define NERR_CanNotGrowUASFile	(NERR_BASE+356) /* Unable to grow the user account system database. */
/* UNUSED BASE+357 */
/* UNUSED BASE+358 */
/* UNUSED BASE+359 */

/*
 *  Server Integration error codes.
 *
 *	    NERR_BASE +(360-369)
 */
#define NERR_NoSuchServer	(NERR_BASE+360) /* The server ID does not specify a valid server. */
#define NERR_NoSuchSession	(NERR_BASE+361) /* The session ID does not specify a valid session. */
#define NERR_NoSuchConnection	(NERR_BASE+362) /* The connection ID does not specify a valid connection. */
#define NERR_TooManyServers	(NERR_BASE+363) /* There is no space for another entry in the table of available servers. */
#define NERR_TooManySessions	(NERR_BASE+364) /* The server has reached the maximum number of sessions it supports. */
#define NERR_TooManyConnections (NERR_BASE+365) /* The server has reached the maximum number of connections it supports. */
#define NERR_TooManyFiles	(NERR_BASE+366) /* The server cannot open more files because it has reached its maximum number. */
#define NERR_NoAlternateServers (NERR_BASE+367) /* There are no alternate servers registered on this server. */
/* UNUSED BASE+368 */
/* UNUSED BASE+369 */

/*
 *  UPS error codes.
 *
 *	    NERR_BASE + (380-384)
 */
#define NERR_UPSDriverNotStarted    (NERR_BASE+380) /* The UPS driver could not be accessed by the UPS service. */
/* UNUSED BASE+381 */
/* UNUSED BASE+382 */
/* UNUSED BASE+383 */
/* UNUSED BASE+384 */

/*
 *  Remoteboot error codes.
 *
 *          NERR_BASE + (400-419)
 *          Error codes 400 - 405 are used by RPLBOOT.SYS.
 *          Error codes 403, 407 - 416 are used by RPLLOADR.COM,
 *          Error code 417 is the alerter message of REMOTEBOOT (RPLSERVR.EXE).
 *          Error code 418 is for when REMOTEBOOT can't start
 *          Error code 419 is for a disallowed 2nd rpl connection
 */
#define NERR_BadDosRetCode      (NERR_BASE+400) /* The program below returned an MS-DOS error code:*/
#define NERR_ProgNeedsExtraMem  (NERR_BASE+401) /* The program below needs more memory:*/
#define NERR_BadDosFunction     (NERR_BASE+402) /* The program below called an unsupported MS-DOS function:*/
#define NERR_RemoteBootFailed   (NERR_BASE+403) /* The workstation failed to boot.*/
#define NERR_BadFileCheckSum    (NERR_BASE+404) /* The file below is corrupt.*/
#define NERR_NoRplBootSystem    (NERR_BASE+405) /* No loader is specified in the boot-block definition file.*/
#define NERR_RplLoadrNetBiosErr (NERR_BASE+406) /* NetBIOS returned an error: The NCB and SMB are dumped above.*/
#define NERR_RplLoadrDiskErr    (NERR_BASE+407) /* A disk I/O error occurred.*/
#define NERR_ImageParamErr      (NERR_BASE+408) /* Image parameter substitution failed.*/
#define NERR_TooManyImageParams (NERR_BASE+409) /* Too many image parameters cross disk sector boundaries.*/
#define NERR_NonDosFloppyUsed   (NERR_BASE+410) /* The image was not generated from an MS-DOS diskette formatted with /S.*/
#define NERR_RplBootRestart     (NERR_BASE+411) /* Remote boot will be restarted later.*/
#define NERR_RplSrvrCallFailed  (NERR_BASE+412) /* The call to the Remoteboot server failed.*/
#define NERR_CantConnectRplSrvr (NERR_BASE+413) /* Cannot connect to the Remoteboot server.*/
#define NERR_CantOpenImageFile  (NERR_BASE+414) /* Cannot open image file on the Remoteboot server.*/
#define NERR_CallingRplSrvr     (NERR_BASE+415) /* Connecting to the Remoteboot server...*/
#define NERR_StartingRplBoot    (NERR_BASE+416) /* Connecting to the Remoteboot server...*/
#define NERR_RplBootServiceTerm (NERR_BASE+417) /* Remote boot service was stopped; check the error log for the cause of the problem.*/
#define NERR_RplBootStartFailed (NERR_BASE+418) /* Remote boot startup failed; check the error log for the cause of the problem.*/
#define NERR_RPL_CONNECTED	(NERR_BASE+419)	/* A second connection to a Remoteboot resource is not allowed.*/

/*
 *  FTADMIN API error codes
 *
 *       NERR_BASE + (425-434)
 *
 */
#define NERR_FTNotInstalled     (NERR_BASE+425) /* DISKFT.SYS is not installed. */
#define NERR_FTMONITNotRunning  (NERR_BASE+426) /* FTMONIT is not running */
#define NERR_FTDiskNotLocked    (NERR_BASE+427) /* FTADMIN has not locked the disk. */
#define NERR_FTDiskNotAvailable (NERR_BASE+428) /* Some other process has locked the disk. */
#define NERR_FTUnableToStart    (NERR_BASE+429) /* The verifier/correcter cannot be started. */
#define NERR_FTNotInProgress    (NERR_BASE+430) /* The verifier/correcter can't be aborted because it isn't started. */
#define NERR_FTUnableToAbort    (NERR_BASE+431) /* The verifier/correcter can't be aborted. */
#define NERR_FTUnabletoChange   (NERR_BASE+432) /* The disk could not be locked/unlocked. */
#define NERR_FTInvalidErrHandle (NERR_BASE+433) /* The error handle was not recognized. */
#define NERR_FTDriveNotMirrored (NERR_BASE+434) /* The drive is not mirrored. */


#define MAX_NERR		(NERR_BASE+899) /* This is the last error in NERR range. */

/*
 * end of list
 *
 *    WARNING:  Do not exceed MAX_NERR; values above this are used by
 *		other error code ranges (errlog.h, service.h, apperr.h).
 */


#endif /* NETERR_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\netinfo.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * NETINFO.C - Source file for obtaining network information.
 ********************************************************************/


/* Include Files */

#include "msd.h"

#define INCL_DOSERRORS 1
#include "bseerr.h"
#undef INCL_DOSERRORS

float flFloatFix = (float) 0.0;

/*********************************************************************
 * GetNetworkInfo - Gets the network information.
 *
 * pNetInfo     - Pointer to network information structure.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetNetworkInfo (NETWORK_STRUCT *pNetInfo, BOOL fMinimumInfo)
{
  WORD wIndex;                  /* Index to network name string array */
  static BOOL fFirstTime = 1;   /* Set so that network information is */
                                /*   only obtained once.              */

  /* Obtain network information only if this is the first time through */

/*if (fFirstTime)
    {                */
      fFirstTime = 0;

      /* Initialize NetInfo structure fields */
      memset (pNetInfo, '\0', sizeof (NETWORK_STRUCT));
#if HEAP_DEBUG
      HeapCheck ("After memset");
#endif


      /* Check for NetBIOS running */
      if (Netbios_Installed (pNetInfo))
        {
          pNetInfo->fNetworkActive     = TRUE;
          pNetInfo->fNetBiosCompatible = TRUE;
        }
      else
        pNetInfo->fNetBiosCompatible = FALSE;
#if HEAP_DEBUG
      HeapCheck ("After Netbios_Installed");
#endif


      /* Begin checking for the different networks */

      /* Check for Novell Netware running */
      if (Novell_Installed (pNetInfo))
        {
          pNetInfo->fNetworkActive = TRUE;
          pNetInfo->wNetworkType   = NET_NOVELL;
          Get_Novell_Info (pNetInfo);
        }
#if HEAP_DEBUG
      HeapCheck ("After Novell_Installed");
#endif


      /* Check for Banyan VINES running */
      if (BanyanRunning())
        {
          pNetInfo->fNetworkActive = TRUE;
          pNetInfo->wNetworkType   = NET_BANYAN;
        }
#if HEAP_DEBUG
      HeapCheck ("After BanyanRunning");
#endif


      /* Check for Artisoft LANtastic running */
      if (LANtasticRunning (pNetInfo))
        {
          pNetInfo->fNetworkActive = TRUE;
          pNetInfo->wNetworkType   = NET_LANTASTIC;
        }
#if HEAP_DEBUG
      HeapCheck ("After LANtasticRunning");
#endif


      /* Check for LanMan running */
      if (LanManager_Installed (pNetInfo) == 0)
        {
#if HEAP_DEBUG
      HeapCheck ("After LanManager_Installed");
#endif
          pNetInfo->wNetworkType = LAN_Basic_Enhanced (pNetInfo);

          if (fMinimumInfo == FALSE)
            {
              if (pNetInfo->fNetworkActive == TRUE)
                Adapter_Status (pNetInfo);

#if HEAP_DEBUG
      HeapCheck ("After Adapter_Status");
#endif
              pNetInfo->fServerConnection = Server_Connection();
#if HEAP_DEBUG
      HeapCheck ("After Server_Connection");
#endif

              if (pNetInfo->wNetworkMajor >= 2)
                {
                  if ((pNetInfo->wNetworkMajor == 2) &&
                      (pNetInfo->wNetworkMinor == 0))
                    {
                      Get_CSD_Info (pNetInfo);
#if HEAP_DEBUG
      HeapCheck ("After GetCSD_Info");
#endif
                    }
                  else
                    {
                      if (pNetInfo->wNetworkType == NET_LANMAN_ENHANCED)
                        GetLM_VersionInfo (pNetInfo);
#if HEAP_DEBUG
      HeapCheck ("After GetLM_VersionInfo");
#endif
                    }
                }
            }
        }


      /* Get Windows for Workgroups/Workgroup Connection information */
      if (pNetInfo->wNetworkType != NET_LANTASTIC && IsWorkgrpSysInstalled())

        {
          pNetInfo->wNetworkType  = NET_WORKGROUP_CLIENT;
          pNetInfo->wNetworkMajor = 0;
          pNetInfo->wNetworkMinor = 0;
        }


      /* Get MSNET information */
      if ((wDosMajor > 3) ||       /* Check to make sure we are running */
         ((wDosMajor == 3) &&      /*  at least DOS 3.1 for net support */
          (wDosMinor > 0)))        /*  before we do the MSNET testing   */
        {
          /* Check for MSNET running */
          if (Msnet_Installed())
            {
#if HEAP_DEBUG
      HeapCheck ("After Msnet_Installed");
#endif
              /* A network is running */
              pNetInfo->fNetworkActive   = TRUE;

              /* It is MSNET compatible */
              pNetInfo->fMsnetCompatible = TRUE;

              /* Get the machine name */
              Get_Msnet_Machine_Name (pNetInfo);
#if HEAP_DEBUG
      HeapCheck ("After Get_Msnet_Machine_Name");
#endif
            }
          else
            pNetInfo->fMsnetCompatible = FALSE;/* It is not MSNET compatible */
        }

      /* Check for the PC-NFS network */
      if (pNetInfo->fNetworkActive   == TRUE &&
          pNetInfo->fMsnetCompatible == TRUE &&
          pNetInfo->wNetworkType     == 0    &&
          PcNfsInstalled()           == TRUE)
        {
          pNetInfo->wNetworkType = NET_PC_NFS;
        }


/*  } */

  /* If the network was not determined yet, say it is unknown */
  if (pNetInfo->wNetworkType == 0 && pNetInfo->fNetworkActive == TRUE)
    if (pNetInfo->fMsnetCompatible == TRUE)
      pNetInfo->wNetworkType = NET_MS_NET_COMPATIBLE;
    else
      pNetInfo->wNetworkType = NET_UNKNOWN_NET;

  /* Set the network's name */
  wIndex = pNetInfo->wNetworkType;
  strcpy (pNetInfo->szNetworkType, paszNetworkTypes[wIndex]);
#if HEAP_DEBUG
      HeapCheck ("After strcpy network type");
#endif


  return (FALSE);
}


/*******************************************************************
*
* Function Netbios_Installed
*
* This function checks for the existence of a Netbios driver.
* It returns a 1 if NetBIOS is detected, 0 if not.
*
*
* Local Variables Used
* --------------------
*
* inregs, outregs : Used to read and write the general purpose
*                   registers.
* segments        : Used to read and write the segment registers.
* PresenceNcb     : The NCB used to issue the test NetBIOS request.
*
*******************************************************************/

int Netbios_Installed (NETWORK_STRUCT * pNetInfo)

{
  union REGS inregs, outregs;
  struct SREGS segments;
  struct Ncb PresenceNcb;

  /* Check the INT 5C vector to see if it's set to anything */

  inregs.x.ax = 0x355C;
  int86x (0x21, &inregs, &outregs, &segments);

  pNetInfo->wNetBIOSSegment = segments.es;
  pNetInfo->wNetBIOSOffset  = outregs.x.bx;

  /* If the INT 5C vector is set to either 0x0000 or 0xF000, */
  /*   the vector is not set, return a failure status        */

  if ((segments.es == 0x0000) || (segments.es == 0xF000))
    return (0);          /* No Netbios */

  /* INT 5C vector is set to something. Issue an invalid       */
  /*   NetBIOS request and check the return value to determine */
  /*   if NetBIOS is really installed                          */

  ClearNcb (&PresenceNcb);

  PresenceNcb.ncb_command = NETBIOS_INVALID_COMMAND;  /* Defined in netbios2.h    */

  NetbiosRequest(&PresenceNcb);

  if (PresenceNcb.ncb_retcode == 0x03)    /* The value returned by NetBIOS for an invalid command */
    return (1);      /* NetBIOS is really there */
  else
    return (0);      /* Something else is using INT 5C */
}


/*******************************************************************
*
* Function ClearNcb
*
* This function clears out a Ncb structure setting all fields to
* 0x00.
*
*
* Local Variables Used
* --------------------
*
* index   : Used for loop control.
* CharPtr : Used to point to the NCB.
*
*******************************************************************/

VOID ClearNcb (struct Ncb * pNcbPtr)

{
  /* memset (pNcbPtr, '\0', sizeof (ZeroNcb)); */
  memset (pNcbPtr, '\0', sizeof (struct Ncb));
}


/*******************************************************************
*
* Function NetbiosRequest
*
* This function issues a NetBIOS request.
*
*
* Local Variables Used
* --------------------
*
* inregs, outregs : Used to read and write the general purpose
*                   registers.
* segments        : Used to read and write the segment registers.
* NcbPtr          : A far pointer to a structure of type NCB used
*                   to issue the NetBIOS request.
*
*******************************************************************/

VOID NetbiosRequest (struct Ncb * NcbPointer)

{
  union REGS inregs, outregs;
  struct SREGS segments;
  struct Ncb FAR *NcbPtr = (struct Ncb FAR *) NcbPointer;

  segread (&segments);

  /* Load ES:BX with the address of the NCB */

  segments.es = FP_SEG (NcbPtr);
  inregs.x.bx = FP_OFF (NcbPtr);

  /* Issue the NetBIOS request */

  int86x (NetbiosInt5C, &inregs, &outregs, &segments);
}


/*******************************************************************
*
* Function Novell_Installed
*
* This function checks for the existence of a Novell Netware
* network. It returns 1 if Netware is detected, 0 if not
*
*
* Local Variables Used
* --------------------
*
* inregs, outregs : Used to read and write the general purpose
*                   registers.
*
*******************************************************************/

BOOL Novell_Installed (NETWORK_STRUCT *pNetInfo)

{
  union REGS inregs, outregs;

  inregs.x.ax = 0x7A00;
  inregs.x.bx = 0x0000;
  int86(0x2F, &inregs, &outregs);

  if (outregs.h.al == 0xFF)
    {
      /* Novell is installed */

      pNetInfo->fIpxInstalled = TRUE;
      return (TRUE);
    }
  else
    {
      /* Novell is not installed */

      pNetInfo->fIpxInstalled = FALSE;
      return (FALSE);
    }
}


/*******************************************************************
*
* Function Get_Novell_Info
*
* This function gets the DOS environment type and machine type as
* Novell sees it.
*
*
* Local Variables Used
* --------------------
*
* inregs, outregs : Used to read and write the general purpose
*                   registers.
* segments        : Used to read and write the segment registers.
* SourceIndex     : Used to parse the string returned from Novell
*                   for the environment information.
*
*******************************************************************/

VOID Get_Novell_Info (NETWORK_STRUCT *pNetInfo)

{
  union REGS inregs, outregs;   /* Registers for int86x             */
  struct SREGS segs;            /* Segments for int86x              */
  CHAR chBuffer[80];            /* Local string buffer              */
  PSZ  pszString = chBuffer;    /* String pointer to chBuffer       */


  /* Get the string information */

  inregs.h.ah = 0xEA;
  inregs.h.al = 0x01;
  segread (&segs);
  segs.es = segs.ds;
  inregs.x.di = (unsigned int) FP_OFF ((CHAR FAR *) pszString);

  int86x(0x21, &inregs, &outregs, &segs);

  /* Set the operating system string */
  strcpy (pNetInfo->szNovellShellOs, pszString);

  /* Set the shell OS version string */
  pszString += strlen (pszString) + 1;
  strcpy (pNetInfo->szNovellShellOsVersion, pszString);

  /* Set the hardware type */
  pszString += strlen (pszString) + 1;
  strcpy (pNetInfo->szNovellHdwType, pszString);


  /* Get the numeric information */

  inregs.h.ah = 0xEA;
  inregs.h.al = 0x00;
  segread (&segs);
  segs.es = (unsigned int) FP_SEG (pszString);
  inregs.x.di = (unsigned int) FP_OFF (pszString);

  int86x(0x21, &inregs, &outregs, &segs);

  /* Set the operating system type */
  pNetInfo->wNovellShellOs = (WORD) outregs.h.ah;

  /* Set the hardware type */
  pNetInfo->wNovellHdwType = (WORD) outregs.h.al;

  /* Set the shell version number */
  pNetInfo->wShellMajor    = (WORD) outregs.h.bh;
  pNetInfo->wShellMinor    = (WORD) outregs.h.bl;
  pNetInfo->wShellRevision = (WORD) outregs.h.cl;

  /* Set the shell type (XMS/EMS/Conv) */
  if (pNetInfo->wShellMajor * 100 + pNetInfo->wShellMinor >= 301)
    pNetInfo->wShellType   = (WORD) outregs.h.ch;


  /* Get the station number */
  inregs.h.ah = 0xDC;
  int86 (0x21, &inregs, &outregs);
  pNetInfo->wStationNmbr = (WORD) outregs.h.al;


  /* Get the physical station number */
  inregs.h.ah = 0xEE;
  int86 (0x21, &inregs, &outregs);
  pNetInfo->wPhysicalStaNmbr1 = (WORD) outregs.x.cx;
  pNetInfo->wPhysicalStaNmbr2 = (WORD) outregs.x.bx;
  pNetInfo->wPhysicalStaNmbr3 = (WORD) outregs.x.ax;


  /* Is SPX installed */
  inregs.x.bx = 0x0010;
  inregs.h.al = 0x00;
  int86 (0x7A, &inregs, &outregs);
  pNetInfo->fSpxInstalled = (outregs.h.al == 0xFF) ? TRUE : FALSE;


  /* Is ODI/LSL.COM installed */
  inregs.x.ax = 0xC000;
  inregs.x.bx = 0x0000;
  int86 (0x2F, &inregs, &outregs);
  pNetInfo->fOdiLslInstalled = (outregs.h.al == 0xFF) ? TRUE : FALSE;
}


/*******************************************************************
*
* Function BanyanRunning()
*
* This function detects Banyan VINES if it is running. It returns a
* 1 if VINES was detected, 0 if not.
*
* Detection scheme
* ----------------
*
* To detect if VINES is currently running:
*
* MOV  AX,D701h
* MOV  BX,0
* INT  2F
*
* Returns: AX = 0 if workstation VINES software is enabled
*          BX = interrupt number being used (60 - 66)
*
*
* To get the VINES version number, use the interrupt number returned
* in BX above <banint> and do the following:
*
* MOV AX, 0700h
* LDS DX, <ptr-to-ULONG>
* INT <banint>
*
* Returns: AX = 0
*
* The version number is returned as:
*
* (VINES rev * 10000) + edit level - 50.
*
* If the edit level is < 50, it is a beta level. For example:
*
* 31505 = VINES 3.10 (0)
* 31051 = VINES 3.10 (1)
* 40010 = VINES 4.00 (Beta-10)
* 40050 = VINES 4.00 (0)
*
*
* NOTE: The version detection is currently commented out because it
*       hangs after returning the version number correctly. More on
*       this later.
*
*******************************************************************/

int BanyanRunning (VOID)

{
  unsigned int uiVinesIsThere;
/*  int iVinesINTNumber;        */
/*  unsigned long *pulVersion;  */

  _asm

  {
    mov   ax,0D701h
    mov   bx,0h
    int   2Fh
    mov   uiVinesIsThere,ax
  }


/*  This is commented out because it does not currently work
  if (uiVinesIsThere == 0)
    {
      _asm

        {
          mov   ax,0D701h
          mov   bx,0h
          int   2Fh
          mov   uiVinesIsThere,ax
          mov   iVinesINTNumber,bx
        }


      if (!uiVinesIsThere)

      _asm

        {
          mov   ax,0700h
          lds   dx,pulVersion
          int   <banint>
        }
    }
*/

  return (!uiVinesIsThere);
}


/***********************************************************************
*
* Artisoft LANtastic detection
*
* Run-time testing for LANtastic NOS (all versions). Returns 1 if
* LANtastic is present, 0 if not.
*
* Detection scheme
* ----------------
*
* First, determine whether or not a NOS is running (may not be LANtastic)
* by issuing a multiplex interrupt (2Fh). This will tell if redirector,
* server, or LANPUP software is installed:
*
* INPUT   AX  B800h
*
* OUTPUT  AL  0      If neither redirector or server is running
*             NZ     Redirector, server, or LANPUP is running
*
*         BL  Contains bits indicating which software is running
*             (Multiple bits will be set when several are running):
*
*             10000000b  Redirector has popup receive message capability
*             01000000b  Server software is running
*             00001000b  Redirector software is running
*             00000010b  LANPUP software is running
*
*             At a minimum, the redirector bit will be set if LANtastic
*             is running.
*
* After it has been determined if a NOS is running, determine if it is
* LANtastic by issuing one of LANtastic's extended DOS calls:
*
*         mov  ax, 5F9Ah      ; Get message processing flags in DL
*         int  21h
*         jc   not_LANtastic
*         jmp  is_LANtastic
*
* If LANtastic is running, determine what the version number is by
* issuing the following multiplex interrupt:
*
* INPUT   AX  B809h
*
* OUTPUT  AH  Major version number
*         AL  Minor version number
*
*         The version numbers are returned as decimal numbers. For example,
*         version 2.53 would be returned as:
*
*         AL     2
*         AH     53 decimal or 35 hex
*
****************************************************************************/

int LANtasticRunning (NETWORK_STRUCT *pNetInfo)

{
  int iRedirMask  = 0x08;     /* 00001000b */
  int iServerMask = 0x40;     /* 01000000b */
  int iPopUpMask  = 0x02;     /* 00000010b */

  union REGS inregs, outregs;
  int iFalse = 0, iTrue = 1;


  /* Issue multiplex interrupt 2fH to determine if some type
     of a NOS is running */

  inregs.x.ax = 0xB800;
  int86 (0x2F, &inregs, &outregs);


  /* If AL is non-zero (something is running) see if BL has bit 4
     turned on (00001000b) to see if it is possibly LANtastic. If
     it is possibly LANtastic, issue an extended DOS call to see
     if the NOS is LANtastic. */

  if ((outregs.h.al) && (outregs.h.bl & iRedirMask))
    {
      /* redirector software is running. Check for server and LANPUP
         software */

      pNetInfo->fLANtasticRedir = TRUE;

      if (outregs.h.bl & iServerMask)
        pNetInfo->fLANtasticServer = TRUE;

      if (outregs.h.bl & iPopUpMask)
        pNetInfo->fLANtasticPopUp = TRUE;


      /* Issue an extended DOS call to determine if LANtastic is running. */

      inregs.x.ax = 0x5F9A;
      intdos (&inregs, &outregs);


      /* If the carry flag is set this is not LANtastic, otherwise it is */

      if (outregs.x.cflag)
        pNetInfo->fLANtasticPresent = FALSE;
      else
        {
          /* LANtastic is running, get the version number */

          pNetInfo->fLANtasticPresent = TRUE;

          inregs.x.ax = 0xB809;
          int86 (0x2F, &inregs, &outregs);

          pNetInfo->wLANtasticVersionMajor = outregs.h.ah;
          pNetInfo->wLANtasticVersionMinor = outregs.h.al;
        }
    }

  return (pNetInfo->fLANtasticPresent);
}


/*******************************************************************
*
* Function Msnet_Installed
*
* This function checks for the existence of a Microsoft Network
* compatible network. It returns 1 if MSNET is detected, 0 if not.
*
*
* Local Variables Used
* --------------------
*
* inregs, outregs : Used to read and write the general purpose
*                   registers.
*
*******************************************************************/

BOOL Msnet_Installed (VOID)

{
  union REGS inregs, outregs;

  inregs.h.ah = 0x00;
  int86 (0x2A, &inregs, &outregs);

  if (outregs.h.ah != 0)
    return (TRUE);  /* MSNet is installed */
  else
    return (FALSE); /* MSNet is not installed */
}


/*******************************************************************
*
* Function Get_Msnet_Machine_Name
*
* This function gets the name of the local computer running MSNet.
*
*
* Local Variables Used
* --------------------
*
* inregs, outregs : Used to read and write the general purpose
*                   registers.
* segments        : Used to read and write the segment registers.
*
* Returns: TRUE if an error occured
*
*******************************************************************/

BOOL Get_Msnet_Machine_Name (NETWORK_STRUCT *pNetInfo)

{
  union REGS inregs, outregs;
  struct SREGS segments;
  CHAR FAR *pszMachineName = NULL;


  /* After this interrupt call, the MSNet machine name will be in
     a null terminated string in MsnetMachine */

  /* Set a pointer to the place in the structure */

  pszMachineName = (CHAR FAR *) pNetInfo->szMsnetMachineName;

  inregs.x.ax = 0x5E00;
  segments.ds = (unsigned int) FP_SEG (pszMachineName);
  inregs.x.dx = (unsigned int) FP_OFF (pszMachineName);
  int86x (0x21, &inregs, &outregs, &segments);

  if (outregs.x.cflag)  /* an error was returned */
    {
      pNetInfo->szMsnetMachineName[0] = -1;
      pNetInfo->szMsnetMachineName[0] = '\0';
      return (TRUE);
    }

  return (FALSE);
}


/*******************************************************************
*
* This Function calls NetWkstaGetInfo. If the call gives back an error
* other than 0, NERR_WkstaNotStarted, NERR_NotLoggedOn, or NERR_buftosmall
* then either Lan Manager is not running or Lan Manager is in a state we don't
* want to mess with. For example, the lanman.ini file isn't there.
*
* LOCAL vars
*     err      - holds return error of netwkstagetinfo
*     ta       - contains total available bytes from netwkstagetinfo
*     wkstabuf - buffer info for netwkstagetinfo
*     wksta0   - stuct mapping to wkstabuf which hold info from netwkstagetinfo
**********************************************************************/

int LanManager_Installed (NETWORK_STRUCT * pNetInfo)
{
  unsigned short int err=0, ta=0;
  char wkstabuf[BUFSIZ];
  struct wksta_info_0 *wksta0;

  /* Get wksta info - if error we still could be a basic workstation */
  err = NetWkstaGetInfo (NULL, 0, wkstabuf, BUFSIZ, &ta);

  /* if we get an error, just fill in stuff incase we try to print this */
  if (err != 0)
    {
#if 0
      strcpy (pNetInfo->szLanRoot, pszUnknown);
      strcpy (pNetInfo->szUserName, "Not Logged on");
      strcpy (pNetInfo->szPrimaryDomain, pszNone);
      pNetInfo->wNetworkMajor = 0x00;
      pNetInfo->wNetworkType = NET_UNKNOWN_NET;

      /* Net work may not be running, try autoexec.bat - this is */
      /*   for basic test, too.                                  */

      /* GetLanAutoexec will fill in version & lanroot if it can */
      err = GetLanAutoexec (pNetInfo);
#endif
      return err;
    }
  else
    {
      /* there was no error so fill in netinfo struct */

      pNetInfo->fNetworkActive = TRUE;

      wksta0 = (struct wksta_info_0 *) wkstabuf;
      _fmemcpy (pNetInfo->szLanRoot, wksta0->wki0_root, _MAX_PATH);

      if (wksta0->wki0_username[0] != '\0')
          _fmemcpy (pNetInfo->szUserName, wksta0->wki0_username, 16);

      if (wksta0->wki0_langroup[0] != '\0')
          _fmemcpy (pNetInfo->szPrimaryDomain, wksta0->wki0_langroup, 16);

      pNetInfo->wNetworkMajor = wksta0->wki0_ver_major;
      pNetInfo->wNetworkMinor = wksta0->wki0_ver_minor;

      pNetInfo->wNetworkType = NET_LANMAN;

      pNetInfo->fAPI_Support = TRUE;

      if (wksta0->wki0_mailslots != 0)
          pNetInfo->fMailslot_Support = TRUE;

      return 0;
    }
}


/*******************************************************************
*
* GetLanAutoexec function gets c:\autoexec.bat and searches for lanman info
* Possible info is LAN version & LAN ROOT. This function is only called
* if NetWkstaGetInfo fails which it will always do if LAN is basic.
*
**********************************************************************/

int GetLanAutoexec (NETWORK_STRUCT * pNetInfo)
{
  FILE * fileAuto;              /* File handle for AUTOEXEC.BAT  */
  FILE_INFO FAR * ffi;          /* Stores File Info structs      */
  FILE_INFO FAR * ffi2;         /* 2nd copy of File Info structs */
  CHAR chBuffer[_MAX_PATH];     /* Filled with ReadLine          */
  CHAR szFilePath[_MAX_PATH];   /* Stores path to AUTOEXEC.BAT   */
  CHAR * pBuffer;               /* Needed with strstr            */
  CHAR * pCase;                 /* Needed with strupr on buffer  */
  CHAR * pRem;                  /* Needed with strupr on buffer  */
  INT  i;                       /* Looping variable              */
  INT  iVersion;                /* Version Number                */


  /* Find the AUTOEXEC.BAT file */
  ffi = FindFile ("AUTOEXEC.BAT", NULL, SEARCH_BOOT_DRIVE, '\0');
  if (ffi == NULL)
    return (1);

  ffi2 = ffi;


  /* Look through all the AUTOEXEC.BAT files */
  while (ffi != NULL && ffi->fpNextFileInfo != NULL)
    {
      _fstrcpy (szFilePath, ffi->fpszPathToFile);


      /* OPEN file Autoexec.bat */
      fileAuto = OpenFile (szFilePath, "rb", FALSE);

      if (fileAuto == NULL)
          continue;

      /* Get lines of Autoexec file and Find LANMAN. */
      /*   If found get version & lanroot            */

      while (ReadLine (chBuffer, 80, fileAuto, FALSE) != EOF)
        {
          pCase = strupr (chBuffer);
          pBuffer = strstr (pCase, "REM ====== LANMAN ");
          if (pBuffer != NULL)
            {
              /* Make pBuffer point to major version number */
              pBuffer += 18;

              /* Get major version of LANMAN */
              iVersion = atoi (pBuffer);
              pNetInfo->wNetworkMajor = iVersion;

              /* Point to minor version of LANMAN */
              while (*pBuffer != '.' && *pBuffer != '\0')
                ++pBuffer;

              if (*pBuffer != '\0')
                ++pBuffer;

              iVersion = atoi (pBuffer);
              pNetInfo->wNetworkMinor = iVersion;

              /* get Lan Root */
              while (ReadLine (chBuffer, 80, fileAuto, FALSE) != EOF)
                {
                  pCase = strupr (chBuffer);
                  pBuffer = strstr (pCase, "REM ====== LANMAN ");
                  if (pBuffer != NULL)
                    {
                      CloseFile (fileAuto);
                      FreeFileInfo (ffi2);
                      return 1;
                    }

                  pBuffer = strstr (pCase, "SET PATH=");
                  pRem = strstr (pCase, "REM ");
                  if ((pBuffer != NULL) && (pRem == NULL))
                    {
                      pNetInfo->wNetworkType = NET_LANMAN_BASIC;
                      pBuffer += 9;
                      for (i=0; ((i < _MAX_PATH - 2) &&
                                 (*pBuffer != ';')     &&
                                 (*pBuffer != '\0')); i++)
                        {
                          pNetInfo->szLanRoot[i] = *pBuffer;
                          pBuffer += 1;
                        }

                      i--;
                      while (pNetInfo->szLanRoot[i] != '\\' && i)
                        i--;

                      pNetInfo->szLanRoot[i] = '\0';
                      CloseFile (fileAuto);
                      FreeFileInfo (ffi2);
                      return (0);
                    }
                }
            }
        }

      fclose (fileAuto);

      /* Point to the next File info structure */
      ffi = (FILE_INFO FAR *) (ffi->fpNextFileInfo);
    }

  FreeFileInfo (ffi2);
  return 1;
}


/*******************************************************************
*
* Procedure Adapter_Status
*
*     This procedure calls a net_adapter_status ncb call and a
*     netbios_session_status ncb call to get information on the
*     user's net card. The information gather is placed into the
*     NetInfo structure.
* Local Vars:
*     NCB,
*     AdapterStatus, SessionStatus are structure filled after the
*     ncb call.  NetCardNumber maintains which card is being
*     queried.  i is for the for loop on the number of netcards.
*******************************************************************/

void Adapter_Status (NETWORK_STRUCT * pNetInfo)
{
  struct Ncb     NCB;
  struct astat   AdapterStatus;
  struct sstat   SessionStatus;
  unsigned char  NetCardNumber=0;
  int            i, iSameNetID;

  ClearNcb (&NCB);
  /* loop until we run out of cards */
  for (NetCardNumber = 0;
       NCB.ncb_retcode == 0 && NetCardNumber < NUMBER_OF_CARDS;
       ++NetCardNumber)
    {
      /* setup the NCB for an adapter status call*/
      NCB.ncb_command      = NETBIOS_ADAPTER_STATUS;
      NCB.ncb_buffer       = (char far *) &AdapterStatus;
      NCB.ncb_length       = sizeof (struct astat);
      NCB.ncb_callname[0]  = '*';
      NCB.ncb_post         = 0;
      NCB.ncb_lana_num     = NetCardNumber;

      NetbiosRequest(&NCB);

      /* if the request was successfull, get the net card */
      /*   id & place it in the NetInfo struct            */
      if (NCB.ncb_retcode == 0)
        {
          iSameNetID = 0;
          for (i=0; i<LENGTH_OF_UNIT_ID; i++)
            {
              pNetInfo->ncsNets[NetCardNumber].bUnitID_Number[i] =
                  AdapterStatus.as_uid[i];

              if (NetCardNumber > 0)
                {
                  if (pNetInfo->ncsNets[NetCardNumber].bUnitID_Number[i] ==
                      pNetInfo->ncsNets[NetCardNumber-1].bUnitID_Number[i])
                    iSameNetID += 1;
                }
            }
          if (iSameNetID == LENGTH_OF_UNIT_ID)
              NCB.ncb_retcode = 1;

        }
      else
        break;

     if (NCB.ncb_retcode > 0)
       break;

      /* setup the NCB for an session status call*/
      NCB.ncb_command     = NETBIOS_SESSION_STATUS;
      NCB.ncb_buffer      = (char far *) &SessionStatus;
      NCB.ncb_length      = sizeof (struct sstat);
      NCB.ncb_callname[0] = '\0';
      NCB.ncb_name[0]     = '*';
      NCB.ncb_post        = 0;
      NCB.ncb_lana_num    = NetCardNumber;

      NetbiosRequest(&NCB);

      /* if the request was successful, place status info in the netinfo struct */
      if (NCB.ncb_retcode == 0)
        {
          if (SessionStatus.ss_numsess <= NUMBER_OF_SESSIONS)
            pNetInfo->ncsNets[NetCardNumber].bNumber_Of_Sessions =
                SessionStatus.ss_numsess;
          else
            {
              pNetInfo->ncsNets[NetCardNumber].bNumber_Of_Sessions = 0;
              SessionStatus.ss_numsess = 0;
            }

          for (i = 0; i < (int) SessionStatus.ss_numsess && 
                      i < NUMBER_OF_SESSIONS; i++)
            memcpy (pNetInfo->ncsNets[NetCardNumber].snRemoteSessionNames[i].szSessionName,
                    SessionStatus.ss_struct[i].ss_rname,16);
        }
      else
        break;

      ClearNcb (&NCB);
    }

  /* if the number of cards detected is over NUMBER_OF_CARDS, */
  /*   we have an error                                       */
  if (NetCardNumber >= NUMBER_OF_CARDS)
    NetCardNumber = 0;

  /* load netinfo with number of netcards */
  pNetInfo->wNumberOfNets = NetCardNumber;
}


/*******************************************************************
*
* Server_Connection procedure tries to establish a session with a server
* to validate the ability of the network to see into the LAN.
*
* LOCAL:
*    tbuff    - time of day buff from NetRemoteTOD
*    tod      - pointer to tbuf
*    sbuff    - hold the names of servers available from NetServerEnum
*    svr_name - holds server name from sbuff = \\name - \\ are appended
*    psrv     - pointer maps over sbuf
*    ser, ste, err - return values
*
**********************************************************************/

BOOL Server_Connection (VOID)
{
  char tbuff[sizeof (struct time_of_day_info)];
  struct time_of_day_info * tod = (struct time_of_day_info *) tbuff;
  char sbuff[BUFSIZ/4], svr_name[CNLEN+3];
  struct server_info_0 *psrv;
  unsigned short ser, ste, err;

  /* Get a list of severs from the browser. The browser maintains the list */
  err = NetServerEnum (NULL, 0, sbuff, sizeof(sbuff), &ser, &ste);

  /* Only check for 8 servers maximum. The browser table has a list of */
  /* servers we have connected to already. Since we have already connected */
  /* to these servers we just want to verify their existance. 8 is used in */
  /* in case a server has been brought down before the browser is updated. */
  /* 8 is also used because anything over this causes Beeping Death. */
  if (ser > (BUFSIZ/4))
      ser=BUFSIZ/4;

  /* if error other than more date, we exit because the enum failed */
  if ((err!=0) && (err!=ERROR_MORE_DATA))
      return (FALSE);

  /* loop through until we successfully connect to a server */
  for (psrv = (struct server_info_0 *)sbuff; ser--; ++psrv)
    {
      strcpy (svr_name, "\\\\");
      strcat (svr_name, psrv->sv0_name);

      /* this is a quick command which if successfull means we have an established connection */
      err = NetRemoteTOD (svr_name, tbuff, sizeof (tbuff));

      /* if we connected to someone, exit. Otherwise we loop until we do or until 8 servers have been processed */
      if (err==0)
        return (TRUE);
    }

  return (FALSE);
}


/*******************************************************************
*
* LAN_Basic_Enhanced proc finds out if the user is running DOS
* Enhanced or DOS Basic LAN Manager. This is done by finding a file
* that must be in the tree which is LAN Manager Specific. This is
* not a good way to do it, but it is the only way.
*
* LOCAL:
*    bufStat - return for stat command
*    path    - hold path of file needed for basic or enhanced
*
* Returns:  NET_LANMAN_BASIC    - If Basic LANMAN detected
*           NET_LANMAN_ENHANCED - If Enhanced LANMAN detected
*           NET_LANMAN          - If Basic or Enhanced could not
*                                 be determined.
**********************************************************************/

BOOL LAN_Basic_Enhanced (NETWORK_STRUCT * pNetInfo)
{
  struct stat bufStat;
  char path[_MAX_PATH];
  int err;

  /* copy (lanroot)\netprog\netwksta.exe into a buffer */
  /* this file must exist if the LAN Manager running is enhanced */
  strcpy (path, pNetInfo->szLanRoot);
  strcat (path, "\\netprog\\netwksta.exe");

  err = stat (path, &bufStat);

  /* if no error, then we have enhanced lan manager */
  if (err == 0)
    return (NET_LANMAN_ENHANCED);

  /* copy (lanroot)\basic\lanman.ini into a buffer */
  /* this file must exist if the LAN Manager running is basic */
  strcpy (path, pNetInfo->szLanRoot);
  strcat (path, "\\basic\\lanman.ini");

  err = stat (path, &bufStat);

  /* if no error, then we have basic lan manager */
  if (err == 0)
    return (NET_LANMAN_BASIC);

  return (NET_LANMAN);
}


/*******************************************************************
*
* Get_CSD_Info looks at the lanman.csd to get info about time and version
* of the csd. It does this by opening (LANROOT)\lanman.csd and parsing
* the file for info, then closing the file.
*
* Local Vars:
*     fileCSD = file pointer for open of lanman.csd
*     buffer  = for read line of lanman.csd
*     result, pbuffer = for file operations
*     CSD_Path = (lanroot)\lanman.csd
*
* Returns: TRUE if an error occured.
**********************************************************************/

int Get_CSD_Info (NETWORK_STRUCT * pNetInfo)
{
  FILE *fileCSD;
  char chBuffer[81], *pbuffer, CSD_Path[_MAX_PATH];
  INT  iResult;
  int  i;

  /* create (lanroot)\lanman.csd */
  strcpy (CSD_Path,pNetInfo->szLanRoot);
  strcat (CSD_Path, "\\Lanman.csd");

  /* OPEN (LANROOT)\lanman.csd */
  fileCSD = OpenFile (CSD_Path, "rb", FALSE);

  if (fileCSD == NULL)
      return (TRUE);

  /* Get first line of lanman.csd */
  iResult = ReadLine (chBuffer, 80, fileCSD, FALSE);

  if (iResult == EOF)
    {
      CloseFile (fileCSD);
      return (TRUE);
    }

  /* Get second line of lanman.csd */
  iResult = ReadLine (chBuffer, 80, fileCSD, FALSE);

  if (iResult == EOF)
    {
      CloseFile (fileCSD);
      return (TRUE);
    }

  /* search for ID in the line, if not there error out, if so get date */
  pbuffer = strstr (chBuffer, "ID");

  if (pbuffer == NULL)
    {
      CloseFile (fileCSD);
      return (TRUE);
    }

  /* skip to date field */
  pbuffer += 3;

  /* loop through extra zero's */
  while (*pbuffer == '0')
    ++pbuffer;

  /* copy date into netinfo */
  for (i = 0; i < 15              &&
              ((*pbuffer != '\n') &&
               (*pbuffer != '\r') &&
               (*pbuffer != '\0') &&
               (i < 6));              i++, pbuffer++)
    pNetInfo->szLanManager_Date[i] = *pbuffer;

  pNetInfo->szLanManager_Date[i] = '\0';

  /* Get third line of lanman.csd */
  iResult = ReadLine (chBuffer, 80, fileCSD, FALSE);

  if (iResult == EOF)
    {
      CloseFile (fileCSD);
      return (TRUE);
    }

  /* search for LM */
  pbuffer = strstr (chBuffer, "LM");

  /* skip to CSD field */
  pbuffer += 2;

  /* loop through extra zero's */
  while (*pbuffer == '0')
    ++pbuffer;

  /* copy current csd level into netinfo */
  for (i=0; i < 6 &&
            ((*pbuffer != '\n') &&
             (*pbuffer != '\r') &&
             (*pbuffer != '\0') &&
             (i < 6));              i++, pbuffer++)
    pNetInfo->szLanManager_CSD[i] = *pbuffer;

  pNetInfo->szLanManager_CSD[i] = '\0';

  CloseFile (fileCSD);
  return (FALSE);
}


/*******************************************************************
*
* GetLM_VersionInfo uses NetConfigGet to parse the lanman.ini which
* has release date, current patch levels and last patch levels.
* LAN Manager 2.1 has this format. Whether LM 3.0 will be this way is
* unclear.
*
* This is for Enhanced LM's. Basic can use api's and has different ini struct
*
* Local Vars:
*    err - return for NetConfigGet
*    len - for NetConfigGet
*    buf - return string of NetConfigGet
*
**********************************************************************/

VOID GetLM_VersionInfo (NETWORK_STRUCT * pNetInfo)
{
  unsigned short int err, len;
  char buf[BUFSIZ], *pbegin;
  int i;

  err = NetConfigGet ("VERSION", "LAN_MANAGER", buf, BUFSIZ, &len);

  /* buf = x.x.x [major].[minor].[patch] */
  if (err == 0)
    {
      /* skip to minor version */
      if (pbegin = strstr (buf, "."))
        {
          ++pbegin;

          /* skip to patch number */
          if (pbegin = strstr (pbegin, "."))
            {

              for (i = 0, ++pbegin; i < 7 && *pbegin != NULL; ++i, ++pbegin)
                pNetInfo->szLanManager_CSD[i] = *pbegin;

              pNetInfo->szLanManager_CSD[i] = '\0';
            }
        }
    }
}


/*********************************************************************
 * SprintNetworkInfo - Put Network information into a set of strings
 *                     to be printed or displayed.
 *
 * pNetInfo     - Network information structure.
 * szSumStrings - Summary strings for summary information.
 *
 * Returns:  NULL if an error occured.
 *********************************************************************/

QSZ * SprintNetworkInfo (NETWORK_STRUCT *pNetInfo,
                         CHAR szSumStrings[][MAX_SUMM_INFO + 5])
{
  WORD wNmbrStrings;        /* Number of strings                     */
  WORD wNmbrChars;          /* Number of characters in the strings   */
  WORD i;                   /* Index variable                        */
  CHAR chBuffer[80];        /* Local string                          */
  QSZ  *pqszStrings;        /* Location for storing string pointers  */
  WORD wAlignColumn;        /* Column to align titles                */


  /* Summary Strings */
  if (szSumStrings != NULL)
    {
      szSumStrings[0][0] ='\0';
      szSumStrings[1][0] ='\0';

      if (pNetInfo->fNetworkActive == FALSE              &&
          pNetInfo->wNetworkType != NET_LANMAN           &&
          pNetInfo->wNetworkType != NET_LANMAN_BASIC     &&
          pNetInfo->wNetworkType != NET_LANMAN_ENHANCED)
        strncpy (szSumStrings[0], paszNetworkTypes[NET_NO_NETWORK],
                 MAX_SUMM_INFO);
      else
        {
          /* Network name */
          /* fixed bug 2414: network was getting reported as "MS Workgroup
             Clien" because only MAX_SUMM_INFO (18) chars were getting copied
             by strnspy.  Can't increase MAX_SUMM_INFO because that will
             break other things.  Added XTRA_LEN_HACK to copy 1 more character...
             wanted to make it longer to avoid this problem with future network
             strings, but receiving buffer is only 23 bytes.  -jeremys */

#define XTRA_LEN_HACK 1

          strncpy (szSumStrings[0], pNetInfo->szNetworkType, MAX_SUMM_INFO
                +XTRA_LEN_HACK);
          strncat (szSumStrings[0], " ",
                   MAX_SUMM_INFO + XTRA_LEN_HACK - strlen (szSumStrings[0]));

          /* Network version */
          if (pNetInfo->wNetworkType == NET_NOVELL)
            {
              sprintf (szSumStrings[1], "Shell %d.%02d.%02d",
                       pNetInfo->wShellMajor,
                       pNetInfo->wShellMinor,
                       pNetInfo->wShellRevision);
            }
          else if (pNetInfo->wNetworkMajor > 0)
            {
              sprintf (chBuffer, "%d.%02d", pNetInfo->wNetworkMajor,
                       pNetInfo->wNetworkMinor);
              if (strlen (chBuffer) + strlen (szSumStrings[0]) > MAX_SUMM_INFO)
                {
                  i = 1;
                  szSumStrings[i][0] = '\0';
                }
              else
                i = 0;

              strncat (szSumStrings[i], chBuffer,
                       MAX_SUMM_INFO - strlen (szSumStrings[i]));
            }
        }

      /* Remove trailing spaces from the first line */
      i = strlen (szSumStrings[0]) - 1;
      while (i >= 1 && szSumStrings[0][i] == ' ')
        szSumStrings[0][i--] = '\0';


      return (NULL);
    }



  /* Overestimate the amount of space required for the strings */

  if (pNetInfo->fNetworkActive == FALSE                    &&
      pNetInfo->wNetworkType != NET_LANMAN                 &&
      pNetInfo->wNetworkType != NET_LANMAN_BASIC           &&
      pNetInfo->wNetworkType != NET_LANMAN_ENHANCED        &&
      pNetInfo->wNetworkType != NET_WORKGROUP_CLIENT)
    {
      wAlignColumn = 18;
      wNmbrStrings = 2;
      wNmbrChars   = wAlignColumn + strlen (pszNo) + 1;
    }
  else
    {
      wAlignColumn = 26;
      wNmbrStrings = 90;
      wNmbrChars   = 3000;
    }


  /* Allocate space for the pointer area and string area */
  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);


  /* Put the information in place */

  i = 0;

  {
    /* Network Detected */

    QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_NETWORK_DETECTED],
                 wAlignColumn);

    if (pNetInfo->fNetworkActive == TRUE               ||
        pNetInfo->wNetworkType == NET_LANMAN           ||
        pNetInfo->wNetworkType == NET_LANMAN_BASIC     ||
        pNetInfo->wNetworkType == NET_LANMAN_ENHANCED)
      Qstrcat (pqszStrings[i], pszYes);
    else
      Qstrcat (pqszStrings[i], pszNo);

    /* Set the next pointer */
    PrepNextString (pqszStrings, i++);

    /* We're done here if there was no network */
    if (pNetInfo->fNetworkActive == FALSE              &&
        pNetInfo->wNetworkType != NET_LANMAN           &&
        pNetInfo->wNetworkType != NET_LANMAN_BASIC     &&
        pNetInfo->wNetworkType != NET_LANMAN_ENHANCED)
      {
        pqszStrings[i] = NULL;
        return (pqszStrings);
      }
  }

  {
    /* Network Name */

    QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_NETWORK_NAME],
                 wAlignColumn);
    Qstrcat (pqszStrings[i], pNetInfo->szNetworkType);

    /* Set the next pointer */
    PrepNextString (pqszStrings, i++);
  }

  {
    /* Network Version */
    if ((pNetInfo->wNetworkType  == NET_NOVELL  &&
         pNetInfo->szNovellNetwareVersion[0] != '\0')  ||
        (pNetInfo->wNetworkMajor != 0  ||
         pNetInfo->wNetworkMinor != 0))
      {
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_VERSION],
                     wAlignColumn);

        if (pNetInfo->wNetworkType == NET_NOVELL)
          {
            Qstrcat (pqszStrings[i], pNetInfo->szNovellNetwareVersion);
          }
        else
          {
            sprintf (chBuffer, "%d.%02d", pNetInfo->wNetworkMajor,
                     pNetInfo->wNetworkMinor);
            Qstrcat (pqszStrings[i], chBuffer);
          }

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }

  {
    /* MS-DOS Network Functions: [Not] Supported */

    QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_MSNET],
                 wAlignColumn);

    if (pNetInfo->fMsnetCompatible)
      Qstrcat (pqszStrings[i], pszSupported);
    else
      Qstrcat (pqszStrings[i], pszNotSupported);

    /* Set the next pointer */
    PrepNextString (pqszStrings, i++);
  }

  {
    /* MSNET Machine Name */

    if (pNetInfo->fMsnetCompatible)
      {
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_COMPUTER_NAME],
                     wAlignColumn);

        Qstrcat (pqszStrings[i], pNetInfo->szMsnetMachineName);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }

  {
    /* NetBIOS Installed */

    QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_NETBIOS],
                 wAlignColumn);

    if (pNetInfo->fNetBiosCompatible)
      Qstrcat (pqszStrings[i], pszYes);
    else
      Qstrcat (pqszStrings[i], pszNo);

    /* Set the next pointer */
    PrepNextString (pqszStrings, i++);
  }

  {
    /* NetBIOS Address */

    if (pNetInfo->fNetBiosCompatible)
      {
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_NETBIOS_ADDRESS],
                     wAlignColumn);

        sprintf (chBuffer, "%04X:%04X", pNetInfo->wNetBIOSSegment,
                 pNetInfo->wNetBIOSOffset);

        Qstrcat (pqszStrings[i], chBuffer);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }

  /* LANMAN Information */

  {
    if (pNetInfo->wNetworkType == NET_LANMAN                 ||
        pNetInfo->wNetworkType == NET_LANMAN_BASIC           ||
        pNetInfo->wNetworkType == NET_LANMAN_ENHANCED        ||
        pNetInfo->wNetworkType == NET_WORKGROUP_CLIENT)
      {
        /* LAN Manager Root */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_LANMAN_ROOT],
                     wAlignColumn);

        Qstrcat (pqszStrings[i], pNetInfo->szLanRoot);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);


        /* User Name */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_LANMAN_USER_NAME],
                     wAlignColumn);

        Qstrcat (pqszStrings[i], pNetInfo->szUserName);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);


        /* Primary Domain */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_LANMAN_DOMAIN],
                     wAlignColumn);

        Qstrcat (pqszStrings[i], pNetInfo->szPrimaryDomain);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);


        /* Server Connection */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_LANMAN_SERVER],
                     wAlignColumn);

        if (pNetInfo->fServerConnection == TRUE)
          Qstrcat (pqszStrings[i], "Established");
        else
          Qstrcat (pqszStrings[i], "Not Established");

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);


        /* Mailslot Support */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_LANMAN_MAILSLOT],
                     wAlignColumn);

        if (pNetInfo->fMailslot_Support == TRUE)
          Qstrcat (pqszStrings[i], pszYes);
        else
          Qstrcat (pqszStrings[i], pszNo);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);


        /* API Support */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_LANMAN_API],
                     wAlignColumn);

        if (pNetInfo->fAPI_Support == TRUE)
          Qstrcat (pqszStrings[i], pszYes);
        else
          Qstrcat (pqszStrings[i], pszNo);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);


        /* LAN Manager Date */
        if (pNetInfo->szLanManager_Date[0] != '\0')
          {
            QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_LANMAN_DATE],
                         wAlignColumn);

            if (strlen(pNetInfo->szLanManager_Date) == 5)
                sprintf (chBuffer, "0%c/%c%c/%c%c",
                         pNetInfo->szLanManager_Date[0],
                         pNetInfo->szLanManager_Date[1],
                         pNetInfo->szLanManager_Date[2],
                         pNetInfo->szLanManager_Date[3],
                         pNetInfo->szLanManager_Date[4]);
            else
                sprintf (chBuffer, "%c%c/%c%c/%c%c",
                         pNetInfo->szLanManager_Date[0],
                         pNetInfo->szLanManager_Date[1],
                         pNetInfo->szLanManager_Date[2],
                         pNetInfo->szLanManager_Date[3],
                         pNetInfo->szLanManager_Date[4],
                         pNetInfo->szLanManager_Date[5]);

            Qstrcat (pqszStrings[i], chBuffer);

            /* Set the next pointer */
            PrepNextString (pqszStrings, i++);
          }


        /* LAN Manager Date */
        if (pNetInfo->szLanManager_CSD[0] != '\0')
          {
            QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_LANMAN_PATCH_LEVEL],
                         wAlignColumn);

            Qstrcat (pqszStrings[i], pNetInfo->szLanManager_CSD);

            /* Set the next pointer */
            PrepNextString (pqszStrings, i++);
          }
      }
  }

  /* Novell Information */

  {
    if (pNetInfo->wNetworkType == NET_NOVELL)
      {
        /* Shell version */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_NOVELL_SHELL_VER],
                     wAlignColumn);

        sprintf (chBuffer, "%d.%02d.%02d", pNetInfo->wShellMajor,
                 pNetInfo->wShellMinor, pNetInfo->wShellRevision);

        Qstrcat (pqszStrings[i], chBuffer);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);


        /* Shell Type */
        if (pNetInfo->wShellMajor * 100 + pNetInfo->wShellMinor >= 301 &&
            pNetInfo->wShellType <= 2)
          {
            QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_NOVELL_SHELL_TYPE],
                         wAlignColumn);

            switch (pNetInfo->wShellType)
              {
                case 0:
                  Qstrcat (pqszStrings[i], pszConventional);
                  break;

                case 1:
                  Qstrcat (pqszStrings[i], "Expanded Memory (EMS)");
                  break;

                case 2:
                  Qstrcat (pqszStrings[i], "Extended Memory (XMS)");
                  break;

                default:
                  Qstrcat (pqszStrings[i], pszUnknown);
              }

            /* Set the next pointer */
            PrepNextString (pqszStrings, i++);
          }


        /* Shell OS */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_NOVELL_SHELL_OS],
                     wAlignColumn);
        if (pNetInfo->wNovellShellOs == 0)
          Qstrcat (pqszStrings[i], pszMsDos);
        else
          Qstrcat (pqszStrings[i], pNetInfo->szNovellShellOs);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);


        /* Shell OS Version */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_NOVELL_SHELL_OS_VER],
                     wAlignColumn);
        Qstrcat (pqszStrings[i], pNetInfo->szNovellShellOsVersion);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);


        /* Hardware Type */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_NOVELL_HDW_TYPE],
                     wAlignColumn);
        Qstrcat (pqszStrings[i], pNetInfo->szNovellHdwType);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);


        /* Station number */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_NOVELL_STATION_NMBR],
                     wAlignColumn);
        sprintf (chBuffer, "%d", pNetInfo->wStationNmbr);
        Qstrcat (pqszStrings[i], chBuffer);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);


        /* Physical station number */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_NOVELL_PHYSICAL_NMBR],
                     wAlignColumn);
        sprintf (chBuffer, "%04X:%04X:%04X",  pNetInfo->wPhysicalStaNmbr1,
                 pNetInfo->wPhysicalStaNmbr2, pNetInfo->wPhysicalStaNmbr3);
        Qstrcat (pqszStrings[i], chBuffer);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);


        /* IPX Installed */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_NOVELL_IPX],
                     wAlignColumn);
        Qstrcat (pqszStrings[i], (pNetInfo->fIpxInstalled) ? pszYes : pszNo);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);


        /* SPX Installed */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_NOVELL_SPX],
                     wAlignColumn);
        Qstrcat (pqszStrings[i], (pNetInfo->fSpxInstalled) ? pszYes : pszNo);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);


        /* ODI/LSL Installed */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_NOVELL_ODI_LSL],
                     wAlignColumn);
        Qstrcat (pqszStrings[i], (pNetInfo->fOdiLslInstalled) ? pszYes : pszNo);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }

  {
    /* LANtastic Information */

    if (pNetInfo->wNetworkType == NET_LANTASTIC)
      {
        /* Server */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_LANTASTIC_SERVER],
                     wAlignColumn);

        if (pNetInfo->fLANtasticServer)
          Qstrcat (pqszStrings[i], pszYes);
        else
          Qstrcat (pqszStrings[i], pszNo);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);



        /* Redir */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_LANTASTIC_REDIR],
                     wAlignColumn);

        if (pNetInfo->fLANtasticRedir)
          Qstrcat (pqszStrings[i], pszYes);
        else
          Qstrcat (pqszStrings[i], pszNo);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);



        /* Server */
        QstrcpyAlign (pqszStrings[i], paszNetworkTitles[NET_LANTASTIC_POPUP],
                     wAlignColumn);

        if (pNetInfo->fLANtasticPopUp)
          Qstrcat (pqszStrings[i], pszYes);
        else
          Qstrcat (pqszStrings[i], pszNo);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }

#if HEAP_DEBUG
      HeapCheck ("Before NetBiosStrings");
#endif

  /* Add NetBIOS strings */
  if (pNetInfo->wNumberOfNets != 0)
    NetBiosStrings (pNetInfo, pqszStrings, &i);

#if HEAP_DEBUG
      HeapCheck ("After NetBiosStrings");
#endif

  /* Additional LANMAN information */
  if (pNetInfo->wNetworkType == NET_LANMAN                 ||
      pNetInfo->wNetworkType == NET_LANMAN_BASIC           ||
      pNetInfo->wNetworkType == NET_LANMAN_ENHANCED        ||
      pNetInfo->wNetworkType == NET_WORKGROUP_CLIENT)
    {
      /* Add the list of workstation services */
      GetServicesInfo (pqszStrings, &i);
#if HEAP_DEBUG
      HeapCheck ("After GetServicesInfo");
#endif

      /* Add the PROTOCOL.INI information */
      GetProtocolInfo (pNetInfo, pqszStrings, &i);
#if HEAP_DEBUG
      HeapCheck ("After GetProtocolInfo");
#endif

      if (pNetInfo->wNetworkType != NET_WORKGROUP_CLIENT)
        {
          /* Add the driver information from LANMAN.INI */
          GetLanmanIniDriverInfo (pNetInfo, pqszStrings, &i);
#if HEAP_DEBUG
          HeapCheck ("After GetLanmanIniDriverInfo");
#endif
        }
    }


  /* Set the last pointer to NULL */
  pqszStrings[i] = NULL;

  /* Return the pointer to pqszStrings */
  return (pqszStrings);
}


/*********************************************************************
 * NetBiosStrings - Adds the NetBIOS strings to pqszStrings.
 *
 * pNetInfo     - Network information structure.
 * pqszStrings  - String array to add the NetBIOS strings to.
 * pI           - Pointer to current line counter.
 *
 * Returns:  NULL if an error occured.
 *********************************************************************/

VOID NetBiosStrings (NETWORK_STRUCT * pNetInfo,
                     QSZ            * pqszStrings,
                     INT            * pI)
{
  CHAR chBuffer[80];        /* Local character buffer          */
  WORD i, j, n;             /* Looping variables               */
  WORD wIndex = *pI;        /* Index to pqszStrings            */
  WORD wNmbrSessions = 0;   /* Count of the number of sessions */


  /* Blank line */
  pqszStrings[wIndex][0] = '\0';
  PrepNextString (pqszStrings, wIndex++);

  /* Title line */
  Qstrcpy (pqszStrings[wIndex], paszNetworkTitles[NET_LANMAN_NET_CARD]);
  PrepNextString (pqszStrings, wIndex++);

  for (i = 0; i < pNetInfo->wNumberOfNets; ++i)
    {
      sprintf (chBuffer, "  Net%2.2d ID: %2.2X%2.2X%2.2X%2.2X%2.2X%2.2X",
               i + 1,
               pNetInfo->ncsNets[i].bUnitID_Number[0],
               pNetInfo->ncsNets[i].bUnitID_Number[1],
               pNetInfo->ncsNets[i].bUnitID_Number[2],
               pNetInfo->ncsNets[i].bUnitID_Number[3],
               pNetInfo->ncsNets[i].bUnitID_Number[4],
               pNetInfo->ncsNets[i].bUnitID_Number[5]);

      Qstrcpy (pqszStrings[wIndex], chBuffer);
      PrepNextString (pqszStrings, wIndex++);

      sprintf (chBuffer, "  Active Sessions for Net%2.2d", i + 1);
      Qstrcpy (pqszStrings[wIndex], chBuffer);
      PrepNextString (pqszStrings, wIndex++);

      /* Indent for the session names */
      Qstrcpy (pqszStrings[wIndex], "      ");

      /* Add the session names */
      for (j = 0; j < (WORD) pNetInfo->ncsNets[i].bNumber_Of_Sessions &&
                  j < NUMBER_OF_SESSIONS; ++j)
        {
          if (pNetInfo->ncsNets[i].snRemoteSessionNames[j].szSessionName[0] != '*')
            {

              for (n = 0;
                   n < 79 &&
                   pNetInfo->ncsNets[i].snRemoteSessionNames[j].szSessionName[n] > ' '; n++)
                chBuffer[n] = pNetInfo->ncsNets[i].snRemoteSessionNames[j].szSessionName[n];

              chBuffer[n] = '\0';

              /* Is a ", " needed */
              if (wNmbrSessions++ > 0)
                Qstrcat (pqszStrings[wIndex], pszCommaSpace);

              /* Does this session name need to be word wrapped */
              if (Qstrlen (pqszStrings[wIndex]) +
                  strlen (chBuffer) + 2 > REPORT_WIDTH)
                {
                  PrepNextString (pqszStrings, wIndex++);
                  Qstrcpy (pqszStrings[wIndex], "      ");
                }

              /* Add the session name */
              Qstrcat (pqszStrings[wIndex], chBuffer);
            }
        }

      PrepNextString (pqszStrings, wIndex++);
    }

  *pI = wIndex;
}


/*********************************************************************
 * GetServicesInfo calls NetServicEnum and NetServiceGetInfo to
 * detect services that may be installed or uninstalled on DOS LANMAN
 * enhanced.
 *
 * LOCAL vars
 *     err      - holds return error of netwkstagetinfo
 *     ta       - contains total available bytes from netwkstagetinfo
 *     wkstabuf - buffer info for netwkstagetinfo
 *     wksta0   - stuct mapping to wkstabuf which hold info from
 *                netwkstagetinfo
 *
 * Returns: TRUE if an error occured.
 *********************************************************************/

BOOL GetServicesInfo (QSZ *pqszStrings, INT *pI)
{
  unsigned short int err = 0, en = 0, ta = 0;
  char sbuf[BUFSIZ], sinfobuf[BUFSIZ];
  struct service_info_0 *service0;
  struct service_info_1 *service1;
  WORD wIndex = *pI;        /* Index to pqszStrings */


  /* Clear out the input buffers */
  memset (sbuf, '\0', BUFSIZ);
  memset (sinfobuf, '\0', BUFSIZ);

  /* Blank line */
  pqszStrings[wIndex][0] = '\0';
  PrepNextString (pqszStrings, wIndex++);

  /* Title line */
  Qstrcpy (pqszStrings[wIndex], paszNetworkTitles[NET_LANMAN_WKSTA_SVS]);
  PrepNextString (pqszStrings, wIndex++);


  /* Get list of services loaded */
  err = NetServiceEnum (NULL, 0, sbuf, sizeof (sbuf), &en, &ta);

  if ((err != 0) || (en == 0))
    {
      Qstrcpy (pqszStrings[wIndex], "  No Services Loaded");
      PrepNextString (pqszStrings, wIndex++);
    }

  if (err != 0)
    return (FALSE);

  /* loop through all services. See if installed. add to buffer */
  for (service0 = (struct service_info_0 *)sbuf; en--; ++service0)
    {
      /* Clear out the string */
      Qmemset (pqszStrings[wIndex], ' ', 21);
      pqszStrings[wIndex][21] = '\0';

      /* Load the service name */
      Qstrncpy (&pqszStrings[wIndex][2], service0->svci0_name,
               strlen (service0->svci0_name));


      /* See if the service is installed */
      err = NetServiceGetInfo (NULL, service0->svci0_name, 1,
                               sinfobuf, sizeof(sinfobuf), &ta);

      service1 = (struct service_info_1 *)sinfobuf;

      /* Put in the answer */
      if ((service1->svci1_status & SERVICE_INSTALL_STATE) == SERVICE_INSTALLED)
        Qstrcat (pqszStrings[wIndex], "Installed");

      if ((service1->svci1_status & SERVICE_INSTALL_STATE) == SERVICE_UNINSTALLED)
        Qstrcat (pqszStrings[wIndex], "Uninstalled");

      if ((service1->svci1_status & SERVICE_INSTALL_STATE) == SERVICE_UNINSTALL_PENDING)
        Qstrcat (pqszStrings[wIndex], "Install Pending");

      if ((service1->svci1_status & SERVICE_INSTALL_STATE) == SERVICE_INSTALL_PENDING)
        Qstrcat (pqszStrings[wIndex], "Uninstall Pending");

      PrepNextString (pqszStrings, wIndex++);
    }

  *pI = wIndex;

  return (FALSE);
}


/*********************************************************************
 * GetProtocolInfo - Puts PROTOCOL.INI informatione into pqszStrings.
 *
 * LOCAL:
 *    fileProtocolIni - file pointer of fopen
 *    ProtocolPath    - holds (lanroot)\protocol.ini
 *    pBuffer       - needed for strstr.
 *
 * Returns: TRUE if an error occured.
 *********************************************************************/

BOOL GetProtocolInfo (NETWORK_STRUCT *pNetInfo, QSZ *pqszStrings, INT *pI)
{
  FILE * fileProtocolIni;
  CHAR szProtocolPath[_MAX_PATH];
  CHAR chBuffer[80];
  CHAR *pBuffer = NULL;
  CHAR NifPath[_MAX_PATH];
  CHAR NifFile[32];
  INT  i;
  WORD wIndex = *pI;        /* Index to pqszStrings */
  BOOL fProtFound = FALSE;  /* TRUE when "[PROT" is found */


  /* Blank line */
  pqszStrings[wIndex][0] = '\0';
  PrepNextString (pqszStrings, wIndex++);

  /* Title line */
  Qstrcpy (pqszStrings[wIndex], paszNetworkTitles[NET_LANMAN_PROTOCOLS]);
  PrepNextString (pqszStrings, wIndex++);


  /* Create (lanroot)\protocol.ini path */
  strcpy (szProtocolPath, pNetInfo->szLanRoot);
  strcat (szProtocolPath, "\\PROTOCOL.INI");

  /* OPEN file (lanroot)\protocol.ini */
  fileProtocolIni = OpenFile (szProtocolPath, "rb", FALSE);
  if (fileProtocolIni == NULL)
    return (TRUE);


  /* Find the [PROT section */
  while (ReadLine (chBuffer, 80, fileProtocolIni, FALSE) != EOF)
    {
      static PSZ pszProt = "[PROT";


      /* Find the [PROTMAN] or [PROTOCOL MANAGER] section */
      if (fProtFound == FALSE)
        {
          if (memicmp (pszProt, chBuffer, 5) == 0)
            fProtFound = TRUE;
        }

      if (fProtFound == TRUE)
        {
          /* Break out if another section is found */
          if (chBuffer[0] == '[' && memicmp (pszProt, chBuffer, 5) != 0)
            break;

          /* Add the lines in the [PROTMAN] or [PROTOCOL MANAGER] section */
          if ((chBuffer[0] != '\r') && (chBuffer[0] != '\n'))
            {
              Qstrcpy (pqszStrings[wIndex], "  ");
              Qstrcat (pqszStrings[wIndex], chBuffer);

              PrepNextString (pqszStrings, wIndex++);
            }
        }
    }


  /* Rewind the file to look for .NIF filenames */
  rewind (fileProtocolIni);


  /* Get lines of protocol.ini and put them into the pszBufferPosition */
  while (ReadLine (chBuffer, 80, fileProtocolIni, FALSE) != EOF)
    {
      /* Search for possible nif file */
      if (chBuffer[0] == '[')
        {
          pBuffer = strstr (chBuffer, "_NIF");

          if (pBuffer != NULL)
            {
              /* create nif file path */
              strcpy (NifPath, pNetInfo->szLanRoot);
              strcat (NifPath, "\\drivers\\nif\\");

              /* create nif file */
              for (i=1; i < 79 && chBuffer[i] != '_'; i++)
                NifFile[i - 1]=chBuffer[i];

              NifFile[i - 1]= '.';

              for (i = i + 1; i < 79 && chBuffer[i] != ']'; i++)
                NifFile[i-1]=chBuffer[i];

              NifFile[i - 1] = '\0';

              strcat (NifPath, NifFile);

              *pI = wIndex;

              /* Add model number to PROTOCOL.INI info */
              GetNifModelInfo (NifPath, pqszStrings, pI);
            }
        }
    }

  /* Close PROTOCOL.INI */
  CloseFile (fileProtocolIni);

  *pI = wIndex;

  return (FALSE);
}


/*********************************************************************
 * GetNifModelInfo - Puts Model line in .NIF file into pqszStrings.
 *
 * LOCAL:
 *    fileNif  - file pointer of fopen
 *    buffer - used for fget
 *    pBuffer  - needed with strstr
 *    pCase  - needed with strupr. used on buffer.
 *
 * Returns: TRUE if an error occured.
 *********************************************************************/

BOOL GetNifModelInfo (PSZ pszNifFile, QSZ * pqszStrings, INT * pI)
{
  FILE * fileNif;
  CHAR chBuffer[81], * pBuffer, * pCase;

  /* OPEN file pszNifFile */
  fileNif = OpenFile (pszNifFile, "rb", FALSE);

  if (fileNif == NULL)
    return (TRUE);

  /* Get lines of Nif file and put Model line into pqszStrings */
  while (ReadLine (chBuffer, 80, fileNif, FALSE) != EOF)
    {
      pCase = strupr (chBuffer);
      pBuffer = strstr (pCase, "MODEL");

      if (pBuffer != NULL)
        {
          Qstrcpy (pqszStrings[*pI], "  ");
          Qstrcat (pqszStrings[*pI], chBuffer);
          PrepNextString (pqszStrings, (*pI)++);
          break;
        }
    }

  /* Close the .NIF file */
  CloseFile (fileNif);

  return (FALSE);
}


/*********************************************************************
 * GetLanmanIniDriverInfo - Puts Lanman Driver info from LANMAN.INI
 *                          into pqszStrings.
 *
 * LOCAL:
 *    fileLanmanIni    - file pointer of OpenFile
 *    LanmanPath       - holds (lanroot)\lanman.ini
 *    buffer           - used for fget
 *    LanmanDriverPath - holds (lanroot)\drivers. used for strstr with
 *                       chBuffer.
 *    pBuffer          - needed with strstr
 *    pCase            - needed with strupr. used on buffer.
 *
 * Returns: TRUE if an error occured.
 **********************************************************************/

BOOL GetLanmanIniDriverInfo (NETWORK_STRUCT *pNetInfo,
                             QSZ            *pqszStrings,
                             INT            *pI)
{
  FILE *fileLanmanIni;
  CHAR szLanmanPath[_MAX_PATH];
  CHAR chBuffer[REPORT_WIDTH * 3 - 4];
  CHAR szLanmanDriverPath[_MAX_PATH];
  CHAR *pBuffer = NULL;
  CHAR *pCase = NULL;
  PSZ  pszString;


  /* Blank line */
  pqszStrings[*pI][0] = '\0';
  PrepNextString (pqszStrings, (*pI)++);

  /* Title line */
  Qstrcpy (pqszStrings[*pI], paszNetworkTitles[NET_LANMAN_INI]);
  PrepNextString (pqszStrings, (*pI)++);


  /* create (lanroot)\lanman.ini */
  strcpy (szLanmanPath, pNetInfo->szLanRoot);
  strcat (szLanmanPath, "\\LANMAN.INI");

  /* create (lanroot)\drivers */
  strcpy (szLanmanDriverPath, pNetInfo->szLanRoot);
  strcat (szLanmanDriverPath, "\\DRIVERS");

  /* OPEN file (lanroot)\lanman.ini */
  fileLanmanIni = OpenFile (szLanmanPath, "rb", FALSE);
  if (fileLanmanIni == NULL)
    return (TRUE);

  /* Get lines of lanman.ini and search for lanroot\drivers. If found */
  /*   put the line into the pqszStrings.                             */

  while (ReadLine (chBuffer, REPORT_WIDTH * 3 - 5, fileLanmanIni, FALSE) != EOF)
    {
      if ((chBuffer[0] != '\r') && (chBuffer[0] != '\n'))
        {
          pCase   = strupr(chBuffer);
          pBuffer = strstr(pCase, szLanmanDriverPath);
          if (pBuffer != NULL)
            {
              Qstrcpy (pqszStrings[*pI], chBuffer);
              pszString = &chBuffer[0];

              /* Wrap the string if necessary */
              while (Qstrlen (pqszStrings[*pI]) > REPORT_WIDTH)
                {
                  pqszStrings[*pI][REPORT_WIDTH] = '\0';
                  pszString += REPORT_WIDTH;

                  PrepNextString (pqszStrings, (*pI)++);

                  Qstrcpy (pqszStrings[*pI], pszString);
                }

              PrepNextString (pqszStrings, (*pI)++);
            }
        }
    }

  /* Close LANMAN.INI */
  CloseFile (fileLanmanIni);

  return (FALSE);
}


/*********************************************************************
 * PcNfsInstalled - Detects if PCNFS.SYS is loaded.
 *
 * This is the mail from a developer at Sun, given to me by Tom Trinneer
 * from Sun Microsystems here in Bellevue (email tom.trinneer@west.sun.com
 *
 * The customer can use the DOS GetMachineName call (sorry, I forget
 * the number - I'm dialled in from home - check the DOS Tech Ref).
 * If it returns a name, a network is installed. To see if it's PC-NFS,
 * try opening the device "PC-NFS$$". If the device can be opened, PC-NFS
 * is loaded. This is not 100% unfortunately; it is possible (but unlikely)
 * that PCNFS.SYS has been loaded in CONFIG.SYS but that another network
 * has in fact been started. There are other, more elaborate checks, but
 * those require knowledge of PC-NFS undocumented interfaces.
 *
 * Returns: TRUE if the network was detected.
 **********************************************************************/

BOOL PcNfsInstalled (VOID)
{
  struct stat statBuffer;   /* File status buffer                */

  /* If the device "PC-NFS$$" does exist, return TRUE */
  if (stat ("PC-NFS$$", &statBuffer) == 0)
    return (TRUE);
  else
    return (FALSE);
}


/***********************************************************************
 * IsWorkgrpSysInstalled - Determines if WORKGRP.SYS/NET$HLP$ is
 *                         installed in memory.
 *
 * Returns: TRUE if WORKGRP.SYS/NET$HLP$ is found, FALSE otherwise.
 ***********************************************************************/

WORD IsWorkgrpSysInstalled (void)
{
  FILE *file;   /* File handle */


  /* Determine if NET$HELP$ exists */

  if ((file = fopen ("NET$HLP$", "r")) != NULL)
    {
      fclose (file);
      return (TRUE);
    }
  else
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\othrinfo.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * OTHRINFO.C - Source file for the Other Adapters detection.
 ********************************************************************/


/* Include Files */

#include "msd.h"


/*********************************************************************
 * GetOtherInfo - Gets the Other Adapters (game/sound) information.
 *
 * pOther       - Other adapters information structure
 * fMinimumInfo - TRUE if minimum information is requested.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetOtherInfo (OTHER_STRUCT *pOther, BOOL fMinimumInfo)
{
  WORD i = 100;                 /* Check port 201h this many times */
  WORD wPortValue;              /* Game port's value               */
  static BOOL fGamePortExists = FALSE;  /* Used to retain the knowledge of */
                                /* a game adapter's presence.  When a game */
                                /* adapter exists on a system and there is */
                                /* no joystick attached, it can only be    */
                                /* detected once after a cold boot.  This  */
                                /* will cause MSD to continue to believe   */
                                /* that a game adapter exists even if it   */
                                /* was found only once.                    */


  /* Is a game adapter present on the system */
  if (fGamePortExists == FALSE)
    {
      while (i-- && (wPortValue = inp (0x201)) == 0xFF)
        ;

      fGamePortExists = (wPortValue != 0xFF) ? TRUE : FALSE;
    }

  pOther->fGameInstalled = fGamePortExists;

  /* Load up the values for the game adapter */
  if (fMinimumInfo == FALSE)
    GetGameAdapterValues (pOther);

  return (FALSE);
}


/*********************************************************************
 * GetGameAdapterValues - Gets the values of the joystick (button
 *                        settings and X-Y values).
 *
 * pOther - Structure for storing the data.
 *
 * Returns:  TRUE if the values are different than the last reading.
 *********************************************************************/

BOOL GetGameAdapterValues (OTHER_STRUCT *pOther)
{
  union REGS inregs, outregs;   /* int86 register structures   */
  BOOL  fDifferent = FALSE;     /* TRUE if values have changed */
  static WORD wAX = 0xFFFF;     /* Previous values             */
  static WORD wBX = 0xFFFF;
  static WORD wCX = 0xFFFF;
  static WORD wDX = 0xFFFF;
  static BYTE bAL = 0xFF;


  if (pOther->fGameInstalled)
    {
      /* Read Game Adapter Resitive Settings */

      inregs.h.ah = 0x84;
      inregs.x.dx = 0x0001;
      inregs.x.cflag = 0x00;

      int86 (0x15, &inregs, &outregs);

      pOther->wJoystickAX = outregs.x.ax;
      pOther->wJoystickAY = outregs.x.bx;
      pOther->wJoystickBX = outregs.x.cx;
      pOther->wJoystickBY = outregs.x.dx;


      /* Check to see if the values are different */

      if (outregs.x.ax != wAX ||
          outregs.x.bx != wBX ||
          outregs.x.cx != wCX ||
          outregs.x.dx != wDX)
        {
          fDifferent = TRUE;
          wAX = outregs.x.ax;
          wBX = outregs.x.bx;
          wCX = outregs.x.cx;
          wDX = outregs.x.dx;
        }


      /* Read Joystick Buttons */

      inregs.h.ah = 0x84;
      inregs.x.dx = 0x0000;
      int86 (0x15, &inregs, &outregs);

      pOther->fButtonA1 = (outregs.h.al & 0x10) ? TRUE : FALSE;
      pOther->fButtonA2 = (outregs.h.al & 0x20) ? TRUE : FALSE;
      pOther->fButtonB1 = (outregs.h.al & 0x40) ? TRUE : FALSE;
      pOther->fButtonB2 = (outregs.h.al & 0x80) ? TRUE : FALSE;


      /* Check against the previous values */

      if (outregs.h.al != bAL)
        {
          fDifferent = TRUE;
          bAL = outregs.h.al;
        }
    }

  return (fDifferent);
}


/*********************************************************************
 * SprintOtherInfo - Put Other Adapters information into a set of
 *                   strings to be printed or displayed.
 *
 * Returns:  NULL if an error occured.
 *********************************************************************/

QSZ * SprintOtherInfo (OTHER_STRUCT *pOther,
                       CHAR szSumStrings[][MAX_SUMM_INFO + 5])
{
  WORD wNmbrStrings;        /* Number of strings                     */
  WORD wNmbrChars;          /* Number of characters in the strings   */
  WORD i = 0;               /* Looping variable                      */
  CHAR chBuffer[80];        /* Local string                          */
  QSZ  *pqszStrings = NULL; /* Location for storing string pointers  */
  WORD wAlignColumn;        /* Column to align titles                */


  /* Summary Strings */
  if (szSumStrings != NULL)
    {
      if (pOther->fGameInstalled)
        strncpy (szSumStrings[i++], pszGameAdapter, MAX_SUMM_INFO);

      /*
      if (pOther->fSoundInstalled)
        strncpy (szSumStrings[i++], pOther->szSoundName, MAX_SUMM_INFO);
      */

      return (NULL);
    }


  /* Overestimate the amount of space required for the strings */

  wNmbrStrings = 2;
  wAlignColumn = 14;

  if (pOther->fGameInstalled)
    {
      wNmbrStrings += 8;
      wAlignColumn = 16;
    }

  /*
  if (pOther->fSoundInstalled)
    {
      wNmbrStrings += 2;
    }
  */

  wNmbrChars = wNmbrStrings * REPORT_WIDTH;


  /* Allocate space for the pointer area and string area */
  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);


  /* Put the information in place */

  /* Game Adapter: [Not] Detected */
  QstrcpyAlign (pqszStrings[i], paszOtherTitles[OTHER_GAME_ADAPTER],
               wAlignColumn);

  if (pOther->fGameInstalled)
    Qstrcat (pqszStrings[i], pszDetected);
  else
    Qstrcat (pqszStrings[i], pszNotDetected);

  /* Set the next pointer */
  PrepNextString (pqszStrings, i++);


  /* Joystick parameters */

  if (pOther->fGameInstalled)
    {
      /* Joystick A */

      /* X Value */
      QstrcpyAlign (pqszStrings[i], paszOtherTitles[OTHER_JOY_A_X],
                   wAlignColumn);

      sprintf (chBuffer, "%u", pOther->wJoystickAX);
      Qstrcat (pqszStrings[i], chBuffer);

      /* Set the next pointer */
      PrepNextString (pqszStrings, i++);


      /* Y Value */
      QstrcpyAlign (pqszStrings[i], paszOtherTitles[OTHER_JOY_A_Y],
                   wAlignColumn);

      sprintf (chBuffer, "%u", pOther->wJoystickAY);
      Qstrcat (pqszStrings[i], chBuffer);

      /* Set the next pointer */
      PrepNextString (pqszStrings, i++);


      /* Button 1 */
      QstrcpyAlign (pqszStrings[i], paszOtherTitles[OTHER_JOY_A_BUTTON_1],
                   wAlignColumn);

      Qstrcat (pqszStrings[i], (pOther->fButtonA1) ? pszOn : pszOff);

      /* Set the next pointer */
      PrepNextString (pqszStrings, i++);


      /* Button 2 */
      QstrcpyAlign (pqszStrings[i], paszOtherTitles[OTHER_JOY_A_BUTTON_2],
                   wAlignColumn);

      Qstrcat (pqszStrings[i], (pOther->fButtonA2) ? pszOn : pszOff);

      /* Set the next pointer */
      PrepNextString (pqszStrings, i++);


      /* Joystick B */

      /* X Value */
      QstrcpyAlign (pqszStrings[i], paszOtherTitles[OTHER_JOY_B_X],
                   wAlignColumn);

      sprintf (chBuffer, "%u", pOther->wJoystickBX);
      Qstrcat (pqszStrings[i], chBuffer);

      /* Set the next pointer */
      PrepNextString (pqszStrings, i++);


      /* Y Value */
      QstrcpyAlign (pqszStrings[i], paszOtherTitles[OTHER_JOY_B_Y],
                   wAlignColumn);

      sprintf (chBuffer, "%u", pOther->wJoystickBY);
      Qstrcat (pqszStrings[i], chBuffer);

      /* Set the next pointer */
      PrepNextString (pqszStrings, i++);


      /* Button 1 */
      QstrcpyAlign (pqszStrings[i], paszOtherTitles[OTHER_JOY_B_BUTTON_1],
                   wAlignColumn);

      Qstrcat (pqszStrings[i], (pOther->fButtonB1) ? pszOn : pszOff);

      /* Set the next pointer */
      PrepNextString (pqszStrings, i++);


      /* Button 2 */
      QstrcpyAlign (pqszStrings[i], paszOtherTitles[OTHER_JOY_B_BUTTON_2],
                   wAlignColumn);

      Qstrcat (pqszStrings[i], (pOther->fButtonB2) ? pszOn : pszOff);

      /* Set the next pointer */
      PrepNextString (pqszStrings, i++);
    }


#if 0
  /* Sound Device: [Not] Detected */
  QstrcpyAlign (pqszStrings[i], paszOtherTitles[OTHER_SOUND_DEVICE],
               wAlignColumn);

  if (pOther->fSoundInstalled)
    Qstrcat (pqszStrings[i], pszDetected);
  else
    Qstrcat (pqszStrings[i], pszNotDetected);

  /* Set the next pointer */
  PrepNextString (pqszStrings, i++);


  /* Sound Device parameters */

  if (pOther->fSoundInstalled)
    {
      /* Sound Device Name */
      QstrcpyAlign (pqszStrings[i], paszOtherTitles[OTHER_SOUND_DEVICE],
                   wAlignColumn);

      Qstrcat (pqszStrings[i], pOther->szSoundName);

      /* Set the next pointer */
      PrepNextString (pqszStrings, i++);


      /* Sound Device IRQ */
      QstrcpyAlign (pqszStrings[i], paszOtherTitles[OTHER_SOUND_IRQ],
                   wAlignColumn);

      sprintf (chBuffer, "%u", pOther->wSoundIrq);
      Qstrcat (pqszStrings[i], chBuffer);

      /* Set the next pointer */
      PrepNextString (pqszStrings, i++);


      /* Sound Device I/O Port */
      QstrcpyAlign (pqszStrings[i], paszOtherTitles[OTHER_SOUND_PORT],
                   wAlignColumn);

      sprintf (chBuffer, "%u", pOther->wSoundPort);
      Qstrcat (pqszStrings[i], chBuffer);

      /* Set the next pointer */
      PrepNextString (pqszStrings, i++);
    }
#endif

  /* Set the last pointer to NULL */
  pqszStrings[i] = NULL;

  /* Return the pointer to pqszStrings */
  return (pqszStrings);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\osinfo.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * OSINFO.C - Source file for determing Operating System information.
 ********************************************************************/


/* Include Files */

#include "msd.h"


/*********************************************************************
 * GetOsVersionInfo - Gets the Operating System version number and the
 *                    version numbers of various operating
 *                    operating environments.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetOsVersionInfo (OS_VERSION_STRUCT *pOsVer, BOOL fMinimumInfo)
{
  union  REGS inregs, outregs;  /* Register structures */


  {
    /* Get DOS Version */

    /* Get Real DOS Version (intended for DOS >= 5.00) */

    inregs.x.ax = 0x3306;
    inregs.x.bx = 0x0000;
    int86 (0x21, &inregs, &outregs);


    /* Was the call supported? */

    if (outregs.x.bx != 0x0000)
      {
        /* It was.  Get the real DOS version */
        pOsVer->wDosMajor    = outregs.h.bl;
        pOsVer->wDosMinor    = outregs.h.bh;
        pOsVer->wDosRevision = outregs.h.dl;

        /* Determine where DOS was loaded */
        pOsVer->wDosLoadedFlags = outregs.h.dh;

        /* Call the standard DOS Version call */
        inregs.x.ax = 0x3000;
        int86 (0x21, &inregs, &outregs);
      }
    else
      {
        /* Get the DOS version from the standard DOS call */
        inregs.x.ax = 0x3000;
        int86 (0x21, &inregs, &outregs);

        /* Set the DOS version flags */
        pOsVer->wDosMajor    = outregs.h.al;
        pOsVer->wDosMinor    = outregs.h.ah;

        /* Set the DOS >= 5.00 specific flags */
        pOsVer->wDosRevision    = 0x00;
        pOsVer->wDosLoadedFlags = 0x00;
      }

    /* Set user serial number and OEM number */
    pOsVer->dwUserSerialNumber = ((DWORD) outregs.h.bl << 16) + outregs.x.cx;
    pOsVer->wOemSerialNumber   = outregs.h.bh;

    /* Set the flag and values for OS/2 */
    if (pOsVer->wDosMajor >= 10)
      {
        pOsVer->fOs2Installed = TRUE;
        pOsVer->wDosMajor = pOsVer->wDosMajor / 10;
      }
    else
      pOsVer->fOs2Installed = FALSE;
  }

  {
    /* Check for Windows and DOSSHELL */

    WinVerDetect (&(pOsVer->wWindowsType),  &(pOsVer->wWindowsMajor),
                  &(pOsVer->wWindowsMinor), &(pOsVer->fDosShellTaskSwitcher));
  }

  {
    /* Get OEM Name and Version */

    GetDosOemStrings (pOsVer);
  }

  {
    if (fMinimumInfo)
      return (FALSE);
  }

  {
    /* Get DOS Boot Drive */

    if (pOsVer->fOs2Installed == FALSE && pOsVer->wDosMajor >= 4)
      {
        inregs.x.ax = 0x3305;
        int86 (0x21, &inregs, &outregs);

        pOsVer->chDosBootDrive = (CHAR) (outregs.h.dl + 'A' - 1);
      }
    else
      pOsVer->chDosBootDrive = '\0';
  }

  {
    /* DESQview Information */

    inregs.x.ax = 0x2B01;
    inregs.x.cx = 0x4445; /* 'DE' */
    inregs.x.dx = 0x5251; /* 'SQ' */
    int86 (0x21, &inregs, &outregs);

    if (outregs.h.al == 0xFF)
      {
        /* DESQview was not installed */
        pOsVer->wDesqViewMajor = 0x00;
        pOsVer->wDesqViewMinor = 0x00;
      }
    else
      {
        /* DESQview was installed */
        if (outregs.x.bx == 0x0002)
          {
            pOsVer->wDesqViewMajor = 0x02;
            pOsVer->wDesqViewMinor = 0x00;
          }
        else
          {
            pOsVer->wDesqViewMajor = outregs.h.bh;
            pOsVer->wDesqViewMinor = outregs.h.bl;
          }
      }
  }

  {
    /* 3270 Control Program Information */

    inregs.x.ax = 0x3000;
    inregs.x.cx = 0x0000;
    inregs.x.dx = 0x0000;
    int86 (0x10, &inregs, &outregs);

    if (outregs.x.cx == 0x0000 && outregs.x.dx == 0x0000)
      {
        /* No 3270 program is installed */

        pOsVer->w3270Installed = NO_3270_PROGRAM;
        pOsVer->w3270Major     = 0;
        pOsVer->w3270Minor     = 0;
      }
    else
      {
        /* CX:DX points to a structure of 3270 info */

        WORD FAR *pfwWord = NULL;  /* Far pointer to a WORD */

        /* Segment of version information is at offset 8 */
        pfwWord = (WORD FAR *)
                    ((((DWORD) outregs.x.cx << 16) + outregs.x.dx) + 8);

        /* The version information is at offset 0 */
        pfwWord = (WORD FAR *) ((DWORD) (*pfwWord) << 16);

        if (*pfwWord <= 0x03FF)
          {
            /* This is the IBM 3270 PC Control Program */

            pOsVer->w3270Installed = _3270_PC_CONTROL_PROGRAM;
            pOsVer->w3270Major     = *pfwWord >> 8;
            pOsVer->w3270Minor     = *pfwWord & 0x00FF;
          }
        else
          {
            /* This is the IBM 3270 Workstation Program */

            pOsVer->w3270Installed = _3270_WORKSTATION_PROGRAM;
            pOsVer->w3270Major     = (*pfwWord >> 8) - 2;
            pOsVer->w3270Minor     = *pfwWord & 0x00FF;
          }
      }
  }

  {
    /* Is DoubleDOS Installed */

    inregs.x.ax = 0xF400;
    int86 (0x21, &inregs, &outregs);

    if (outregs.h.al == 00)
      pOsVer->fDoubleDosInstalled = FALSE;
    else
      pOsVer->fDoubleDosInstalled = TRUE;
  }

  {
    /* TaskView and TopView information */

    if (pOsVer->wDesqViewMajor > 0)
      {
        /* DesqView includes all of TopView's API's */

        pOsVer->fTaskViewInstalled = FALSE;
        pOsVer->wTopViewMajor      = 0;
        pOsVer->wTopViewMinor      = 0;
      }
    else
      {
        /* TopView Get Version Call */

        inregs.x.ax = 0x1022;
        inregs.x.bx = 0x0000;
        int86 (0x15, &inregs, &outregs);

        if (outregs.x.bx == 0x0000)
          {
            pOsVer->fTaskViewInstalled = FALSE;
            pOsVer->wTopViewMajor      = 0;
            pOsVer->wTopViewMinor      = 0;
          }
        if (outregs.x.bx == 0x0001)
          {
            pOsVer->fTaskViewInstalled = TRUE;
            pOsVer->wTopViewMajor      = 0;
            pOsVer->wTopViewMinor      = 0;
          }
        else
          {
            pOsVer->fTaskViewInstalled = FALSE;
            pOsVer->wTopViewMajor      = outregs.h.bl;
            pOsVer->wTopViewMinor      = outregs.h.bh;
          }
      }
  }

  {
    /* Store the fully qualified path to the program */

    strncpy (pOsVer->szPathToProgram, pszPathToProgram,
             MAX_PATH_TO_PROGRAM - 1);

    pOsVer->szPathToProgram[MAX_PATH_TO_PROGRAM - 1] = '\0';
  }

  return (FALSE);
}


/*********************************************************************
 * SprintOsVersionInfo - Put Operating System/Environment information
 *                       into a set of strings to be printed or
 *                       displayed.
 *
 * Returns:  NULL if an error occured.
 *********************************************************************/

QSZ * SprintOsVersionInfo (OS_VERSION_STRUCT *pOsVer,
                           CHAR szSumStrings[][MAX_SUMM_INFO + 5])
{
  WORD wNmbrStrings = 0;    /* Number of strings                     */
  WORD wNmbrChars = 0;      /* Number of characters in the strings   */
  WORD i, u;                /* Looping variables                     */
  CHAR chBuffer[80];        /* Local string                          */
  QSZ  *pqszStrings;        /* Location for storing string pointers  */
  WORD wAlignColumn;        /* Column to align titles                */
  WORD wLength;             /* Length of environment string          */
  WORD wMaxLength = 0;      /* Maximum length of environment strings */


  /* Summary Strings */
  if (szSumStrings != NULL)
    {
      if (pOsVer->szOemVer[0][0] != '\0' &&
          strlen (pOsVer->szOemVer[0]) < MAX_SUMM_INFO + 3)
        strncpy (szSumStrings[0], pOsVer->szOemVer[0], MAX_SUMM_INFO + 3);
      else
        {
          strncpy (szSumStrings[0], pszMsDos, MAX_SUMM_INFO);
          sprintf (chBuffer, " %d.%02d", pOsVer->wDosMajor,
                   pOsVer->wDosMinor);
          strncat (szSumStrings[0], chBuffer,
                   MAX_SUMM_INFO - strlen (szSumStrings[0]));
        }


      if (pOsVer->wWindowsType != NO_WINDOWS)
        {
          switch (pOsVer->wWindowsType)
            {
              case WIN_286:
                strncpy (szSumStrings[1], pszWin286, MAX_SUMM_INFO);
                strncat (szSumStrings[1], psz_2dotX,
                         MAX_SUMM_INFO - strlen (szSumStrings[1]));
                break;

              case WIN_386:
                strncpy (szSumStrings[1], pszWin386, MAX_SUMM_INFO);
                strncat (szSumStrings[1], psz_2dotX,
                         MAX_SUMM_INFO - strlen (szSumStrings[1]));
                break;

              default:
                strncpy (szSumStrings[1], pszWindows, MAX_SUMM_INFO);

                sprintf (chBuffer, " %d", pOsVer->wWindowsMajor);
                strncat (szSumStrings[1], chBuffer,
                         MAX_SUMM_INFO - strlen (szSumStrings[1]));

                if (pOsVer->wWindowsMinor == 0xFF)
                  strncat (szSumStrings[1], ".x ",
                           MAX_SUMM_INFO - strlen (szSumStrings[1]));
                else
                  {
                    sprintf (chBuffer, ".%02d ", pOsVer->wWindowsMinor);
                    strncat (szSumStrings[1], chBuffer,
                             MAX_SUMM_INFO - strlen (szSumStrings[1]));
                  }
            }
        }
      else if (pOsVer->fDosShellTaskSwitcher)
        strncpy (szSumStrings[1], pszDosShell, MAX_SUMM_INFO);

      return (NULL);
    }

  /* Overestimate the amount of space required for the strings */

  /* Count up the environment space */
  for (i = 0; environ[i][0] != '\0'; ++i)
    {
      wLength = strlen (environ[i]);
      wNmbrStrings += (wLength / 72) + 1;
      wNmbrChars += wLength + (wLength / 72) + 1;

      if (wLength > 72)
        wLength = 72;

      if (wMaxLength < wLength)
        wMaxLength = wLength;
    }

  wNmbrStrings += 3 + MAX_OS_TITLES;


  /* Calculate the correct alignment column */

  wAlignColumn = 20;

  if (pOsVer->fDosShellTaskSwitcher)
    wAlignColumn = 24;

  if (pOsVer->w3270Installed)
    wAlignColumn = 26;

  /* Center the information */
  wLength = strlen (pOsVer->szPathToProgram) + wAlignColumn;
  if (wLength < wMaxLength)
    wAlignColumn += ((wMaxLength / 2) - (wLength / 2));

  wNmbrChars += MAX_OS_TITLES * (MAX_OS_VERSION_LINE_LEN +
                                 MAX_PATH_TO_PROGRAM     +
                                 wAlignColumn);


  /* Allocate space for the pointer area and string area */

  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);


  /* Put the information in place */

  i = 0;

  {
    /* Operating System Version */

    QstrcpyAlign (pqszStrings[i], paszOsVersionTitles[OS_VERSION],
                 wAlignColumn);

    if (pOsVer->fOs2Installed)
      Qstrcat (pqszStrings[i], pszOs2);
    else
      Qstrcat (pqszStrings[i], pszMsDos);

    sprintf (chBuffer, " %d.%02d", pOsVer->wDosMajor, pOsVer->wDosMinor);
    Qstrcat (pqszStrings[i], chBuffer);

    /* Set the next pointer */
    PrepNextString (pqszStrings, i++);
  }

  {
    /* Internal Revision */

    if (pOsVer->fOs2Installed == FALSE && pOsVer->wDosMajor >= 5)
      {
        QstrcpyAlign (pqszStrings[i], paszOsVersionTitles[OS_INTERNAL_REV],
                     wAlignColumn);
        sprintf (chBuffer, "%02d", pOsVer->wDosRevision);
        Qstrcat (pqszStrings[i], chBuffer);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }

  {
    /* OEM Serial Number */

    QstrcpyAlign (pqszStrings[i], paszOsVersionTitles[OS_OEM_SERIAL],
                 wAlignColumn);
    sprintf (chBuffer, "%02XH", pOsVer->wOemSerialNumber);
    Qstrcat (pqszStrings[i], chBuffer);

    /* Set the next pointer */
    PrepNextString (pqszStrings, i++);
  }

  {
    /* User Serial Number */

    QstrcpyAlign (pqszStrings[i], paszOsVersionTitles[OS_USER_SERIAL],
                 wAlignColumn);
    sprintf (chBuffer, "%06XH", pOsVer->dwUserSerialNumber);
    Qstrcat (pqszStrings[i], chBuffer);

    /* Set the next pointer */
    PrepNextString (pqszStrings, i++);
  }

  {
    /* OEM Version String */

    QstrcpyAlign (pqszStrings[i], paszOsVersionTitles[OS_OEM_VERSION],
                 wAlignColumn);
    Qstrcat (pqszStrings[i], pOsVer->szOemVer[0]);

    /* Set the next pointer */
    PrepNextString (pqszStrings, i++);

    /* Add the extra two strings, if they exist */
    for (u = 1; u < MAX_OEM_VER_STRINGS && pOsVer->szOemVer[u][0] != '\0'; ++u)
      {
        /* Add the string */
        QstrcpyAlign (pqszStrings[i], "", wAlignColumn);
        Qstrcat (pqszStrings[i], pOsVer->szOemVer[u]);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }

  {
    /* DOS Location */

    if (pOsVer->fOs2Installed == FALSE && pOsVer->wDosMajor >= 5)
      {
        QstrcpyAlign (pqszStrings[i], paszOsVersionTitles[OS_DOS_LOCATION],
                     wAlignColumn);

        if (pOsVer->wDosLoadedFlags & 0x08)
          Qstrcat (pqszStrings[i], pszRom);

        if (pOsVer->wDosLoadedFlags & 0x10)
          Qstrcat (pqszStrings[i], pszHma);

        if (pOsVer->wDosLoadedFlags == 0)
          Qstrcat (pqszStrings[i], pszConventional);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }

  {
    /* DOS Boot Drive */

    if (pOsVer->fOs2Installed == FALSE && pOsVer->wDosMajor >= 4)
      {
        QstrcpyAlign (pqszStrings[i], paszOsVersionTitles[OS_BOOT_DRIVE],
                     wAlignColumn);

        chBuffer[0] = pOsVer->chDosBootDrive;
        chBuffer[1] = ':';
        chBuffer[2] = '\0';

        Qstrcat (pqszStrings[i], chBuffer);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }

  {
    /* DOSSHELL Task Switcher */

    if (pOsVer->fDosShellTaskSwitcher)
      {
        QstrcpyAlign (pqszStrings[i], paszOsVersionTitles[OS_DOSSHELL],
                     wAlignColumn);

        Qstrcat (pqszStrings[i], pszActive);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }

  {
    /* Windows */

    if (pOsVer->wWindowsType != NO_WINDOWS)
      {
        QstrcpyAlign (pqszStrings[i], paszOsVersionTitles[OS_WINDOWS],
                     wAlignColumn);

        switch (pOsVer->wWindowsType)
          {
            case WIN_286:
              Qstrcat (pqszStrings[i], pszWin286);
              Qstrcat (pqszStrings[i], psz_2dotX);
              break;

            case WIN_386:
              Qstrcat (pqszStrings[i], pszWin386);
              Qstrcat (pqszStrings[i], psz_2dotX);
              break;

            default:
              Qstrcat (pqszStrings[i], pszWindows);

              sprintf (chBuffer, " %d", pOsVer->wWindowsMajor);
              Qstrcat (pqszStrings[i], chBuffer);

              if (pOsVer->wWindowsMinor == 0xFF)
                Qstrcat (pqszStrings[i], ".x ");
              else
                {
                  sprintf (chBuffer, ".%02d ", pOsVer->wWindowsMinor);
                  Qstrcat (pqszStrings[i], chBuffer);
                }

              switch (pOsVer->wWindowsType)
                {
                  case WIN_REAL_MODE:
                    Qstrcat (pqszStrings[i], pszRealMode);
                    break;

                  case WIN_STANDARD_MODE:
                    Qstrcat (pqszStrings[i], pszStandardMode);
                    break;

                  case WIN_ENHANCED_MODE:
                    Qstrcat (pqszStrings[i], pszEnhancedMode);
                    break;
                }
          }

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }

  {
    /* DESQview Version */

    if (pOsVer->wDesqViewMajor != 0 || pOsVer->wDesqViewMinor != 0)
      {
        QstrcpyAlign (pqszStrings[i], paszOsVersionTitles[OS_DESQVIEW],
                     wAlignColumn);

        sprintf (chBuffer, "%d.%02d", pOsVer->wDesqViewMajor,
                 pOsVer->wDesqViewMinor);

        Qstrcat (pqszStrings[i], chBuffer);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }

  {
    /* 3270 Program Information */

    if (pOsVer->w3270Installed)
      {
        strcpy (chBuffer, paszOsVersionTitles[OS_3270]);

        if (pOsVer->w3270Installed == _3270_PC_CONTROL_PROGRAM)
          Qstrcat (chBuffer, pszPCControlProgram);
        else
          Qstrcat (chBuffer, pszWorkstationProgram);

        QstrcpyAlign (pqszStrings[i], chBuffer, wAlignColumn);

        sprintf (chBuffer, "%d.%02d", pOsVer->w3270Major,
                 pOsVer->w3270Minor);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }

  {
    /* DoubleDOS Installed */

    if (pOsVer->fDoubleDosInstalled)
      {
        QstrcpyAlign (pqszStrings[i], paszOsVersionTitles[OS_DOUBLE_DOS],
                     wAlignColumn);

        Qstrcat (pqszStrings[i], pszYes);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }

  {
    /* TaskView Installed */

    if (pOsVer->fTaskViewInstalled)
      {
        QstrcpyAlign (pqszStrings[i], paszOsVersionTitles[OS_TASKVIEW],
                     wAlignColumn);

        Qstrcat (pqszStrings[i], pszYes);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }

  {
    /* TopView Version */

    if (pOsVer->wTopViewMajor != 0 || pOsVer->wTopViewMinor != 0)
      {
        QstrcpyAlign (pqszStrings[i], paszOsVersionTitles[OS_TOPVIEW],
                     wAlignColumn);

        sprintf (chBuffer, "%d.%02d", pOsVer->wTopViewMajor,
                 pOsVer->wTopViewMinor);

        Qstrcat (pqszStrings[i], chBuffer);

        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }

  {
    /* Fully Qualified Path to Program */

    QstrcpyAlign (pqszStrings[i], paszOsVersionTitles[OS_PATH_TO_PROGRAM],
                 wAlignColumn);

    Qstrcat (pqszStrings[i], pOsVer->szPathToProgram);

    /* Set the next pointer */
    PrepNextString (pqszStrings, i++);
  }

  {
    /* Add the environment strings */

    PSZ  pszString;   /* Single String pointer */
    WORD u;           /* Looping variable      */


    /* Add the "Environment Strings" string */
    pqszStrings[i][0] = '\0';
    PrepNextString (pqszStrings, i++);

    wLength = (wMaxLength / 2) - (strlen (pszEnvironmentStr) / 2);
    Qmemset (pqszStrings[i], ' ', wLength);
    pqszStrings[i][wLength] = '\0';
    Qstrcat (pqszStrings[i], pszEnvironmentStr);
    PrepNextString (pqszStrings, i++);

    /* And underline */
    Qmemset (pqszStrings[i], '-', wMaxLength);
    pqszStrings[i][wMaxLength] = '\0';
    PrepNextString (pqszStrings, i++);


    for (u = 0; environ[u][0] != '\0'; ++u)
      {
        pszString = environ[u];

        Qstrcpy (pqszStrings[i], pszString);


        /* Wrap the string into pqszStrings */
        while (strlen (pszString) > 72)
          {
            pszString = &pszString[72];

            pqszStrings[i][72] = '\0';

            /* Set the next pointer */
            PrepNextString (pqszStrings, i++);
          }


        /* Set the next pointer */
        PrepNextString (pqszStrings, i++);
      }
  }


  /* Set the last pointer to NULL */

  pqszStrings[i] = NULL;

  /* Return the pointer to pqszStrings */

  return (pqszStrings);
}


VOID OsErr (VOID)
{
#if 0
  CHAR chBuffer[256];
  WORD * pw = (WORD *) minParsedLine;
  INT c = 0;


  sprintf (chBuffer, pszUnexplainedError, pw[-1] % 10000);
  puts (chBuffer);

  if (rgfReportItemFlag[IDI_CUSTOMER_INFORMATION] == FALSE)
    {
      WORD FAR *fpWord = (WORD FAR *) 0x0040006C;
      WORD wPause = (*fpWord) + 37;
      while (*fpWord < wPause)
        ;
    }
  else
    {
      puts ("Press ENTER to exit or C to continue ...");

      while ((c = getch()) != '\r' && c != 'C' && c != 'c')
        if (c == 0)
          getch();
    }


  if (c == '\r')
    exit (1);
#endif
}


/*********************************************************************
 * WinVerDetect - Detects type/mode of windows, and windows version.
 *                Also detects the DOSSHELL Task Switcher.
 *
 * pwWindowsType  - Type or mode of windows (/286, /386, enhanced,
 *                  standard, real, or none)
 * pwWindowsMajor - Major part of Windows version number.
 * pwWindowsMinor - Minor part of Windows version number.
 * pfDosShell     - TRUE if DOSSHELL task switcher is running.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL WinVerDetect (WORD *pwWindowsType,
                   WORD *pwWindowsMajor,
                   WORD *pwWindowsMinor,
                   WORD *pfDosShell)
{
  WORD wWindowsType;        /* Local copies of data */
  WORD wWindowsMajor;
  WORD wWindowsMinor;
  BOOL fDosShell = FALSE;   /* Defaults to FALSE    */

  _asm
    {
      ; Check for Windows 3.1

        mov     ax,160Ah                ; WIN31CHECK
        int     2Fh                     ; check if running under win 3.1
        or      ax,ax
        jnz     Win30EnhModeCheck

      ; Windows 3.1 detected

        mov     wWindowsMajor,3         ; Set the version number
        mov     wWindowsMinor,10

      ;   CX = 3 - Enhanced, CX = 2 - Standard, CX = 1 - Real.

        cmp     cx,1
        jne     Win31StdChk
        mov     wWindowsType, WIN_REAL_MODE
        jmp     WinDetectComplete

      Win31StdChk:

        cmp     cx,2
        jne     Win31EnhChk
        mov     wWindowsType, WIN_STANDARD_MODE
        jmp     WinDetectComplete

      Win31EnhChk:

        cmp     cx,3
        jne     Win31UnknownMode
        mov     wWindowsType, WIN_ENHANCED_MODE
        jmp     WinDetectComplete

      Win31UnknownMode:

        mov     wWindowsType, WIN_UNKNOWN_MODE
        jmp     WinDetectComplete


      ; Check for 3.0 Enhanced mode

      Win30EnhModeCheck:
        mov     ax,1600h                ; WIN386CHECK
        int     2Fh
        test    al,7Fh
        jz      Win286Check

      ; Windows 3.0 Enhanced Mode detected

        mov     wWindowsMajor,3         ; Set the version number
        mov     wWindowsMinor,0
                                        ; Set the mode
        mov     wWindowsType, WIN_ENHANCED_MODE
        jmp     WinDetectComplete


      ; Check for Windows/286

      Win286Check:
        mov     ax,1700h                ; WIN286CHECK
        int     2Fh
        cmp     al,2h                   ; If /286 installed, ver = AL.AH
        jnz     WinOldApCheck           ; /286 is always 2.x

      ; Windows/286 detected

        xor     bh,bh
        mov     bl,al
        mov     wWindowsMajor,bx
        mov     bl,ah
        mov     wWindowsMinor,bx
        mov     wWindowsType, WIN_286
        jmp     WinDetectComplete


      ; Check for Windows 3.0 WINOLDAP

      WinOldApCheck:
        mov     ax,4680h                ; IS_WINOLDAP_ACTIVE
        int     2Fh
        or      ax,ax                   ; running under 3.0 derivative ?
        jz      DosShellCheck

      ; Windows is not running on this computer

        jmp     NotRunningUnderWin


      ; Check for DOS 5.0 DOSSHELL Task Switcher

      DosShellCheck:
        mov     ax,4b02h                ; detect switcher
        push    bx
        push    es
        push    di
        xor     bx,bx
        mov     di,bx
        mov     es,bx
        int     2Fh
        pop     di
        pop     es
        pop     bx
        or      ax,ax
        jnz     RunningUnderWinStdReal30

      ; Running under DOS 5.0 task switcher

        mov     wWindowsMajor,0         ; Windows is not running
        mov     wWindowsMinor,0
        mov     wWindowsType, NO_WINDOWS
        mov     fDosShell, TRUE         ; Set the flag for the DOSSHELL
        jmp     WinDetectComplete


      RunningUnderWinStdReal30:

        mov     ax,1605h                ; PMODE_START
        int     2Fh
        cmp     cx,-1
        jnz     Running30RealOr386

      ; Windows 3.0 Standard Mode detected

        mov     ax,1606h                ; PMODE_STOP
        int     2Fh                     ; in case someone is accounting.

        mov     wWindowsMajor,3         ; Set the version number
        mov     wWindowsMinor,0
                                        ; Set the Windows mode
        mov     wWindowsType, WIN_STANDARD_MODE
        jmp     WinDetectComplete

      Running30RealOr386:

        mov     ax,1606h                ; PMODE_STOP
        int     2Fh                     ; in case someone is accounting.

        cmp     al,1                    ; WIN386CHECK again
        jnz     RunningUnderRealMode
        cmp     al,0FFh
        jz      RunningUnderWin386

      RunningUnderRealMode:

        mov     wWindowsMajor,3         ; Set the version number
        mov     wWindowsMinor,0
                                        ; Set the Windows mode
        mov     wWindowsType, WIN_REAL_MODE
        jmp     WinDetectComplete


      RunningUnderWin386:

        mov     wWindowsMajor,2
        mov     wWindowsMinor,0FFh
        mov     wWindowsType, WIN_386
        jmp     WinDetectComplete

      NotRunningUnderWin:

        mov     wWindowsMajor,0         ; Windows is not running
        mov     wWindowsMinor,0
        mov     wWindowsType, NO_WINDOWS

      WinDetectComplete:
    }

  /* Set the new-found values */

  *pwWindowsType  = wWindowsType;
  *pwWindowsMajor = wWindowsMajor;
  *pwWindowsMinor = wWindowsMinor;
  *pfDosShell     = fDosShell;

  return (FALSE);
}


/*********************************************************************
 * GetDosOemStrings - Gets the DOS OEM version string (the same as
 *                    typing VER at the DOS prompt.  This is
 *                    accomplished by performing a COMMAND/C VER and
 *                    re-routing the output to a file.  The file is
 *                    read, and the strings are stored in the pOsVer
 *                    structure.
 *
 * pOsVer - Operating system version structure.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetDosOemStrings (OS_VERSION_STRUCT *pOsVer)
{
  CHAR szTempPath[_MAX_PATH];   /* Stores path to temp directory       */
  BOOL fReturnValue;            /* Return value from various functions */
                                /* Command to get the version          */
  CHAR szCommandVer[_MAX_PATH + 20];
  CHAR chBuffer[80];            /* Local string buffer                 */
  FILE *fileVer;                /* file handle to read version file    */
  WORD i, u;                    /* Index variable, looping variable    */
  WORD wLastChar;               /* Index to last character in path     */
  static CHAR FAR *fpszOemStrings = NULL;  
                                /* Store the strings, so I only have   */
                                /*   to get them once                  */
  struct find_t ft;             /* Used to validate temp directory     */

  /* If I've already got the OEM strings, return them */
  if (fpszOemStrings)
    {
      _fmemcpy (pOsVer->szOemVer, fpszOemStrings,
                MAX_OEM_VER_STRINGS * MAX_OEM_VER);
    }
  else
    {
      /* Zero out the string */
      memset (szTempPath, '\0', _MAX_PATH);

      /* Get the TEMP or TMP path or current directory for the temp file */
      strcpy (szTempPath, getenv (pszTemp));
      if (szTempPath[0] != '\0')
        {
          /* Add "*.*" to the temp path */
          strcpy (szCommandVer, szTempPath);
          wLastChar = strlen (szCommandVer) - 1;
          if (szCommandVer[wLastChar] != '\\')
            strcat (szCommandVer, "\\");
          strcat (szCommandVer, "*.*");

          /* Check to see if the directory is valid */
          fReturnValue = _dos_findfirst (szCommandVer, 0xFFFF, &ft);
          if (fReturnValue != 0)
            {
              fTempPathInvalid = TRUE;

              if (fCwIsReady)
                {
                  strcpy (szTempPath, pszTemp);
                  strcat (szTempPath, "=");
                  strcat (szTempPath, getenv (pszTemp));
                  MessageBox (pszEnvironInvalid, szTempPath, NULL,
                              MB_OK | 0x8000);
                }

              szTempPath[0] = '\0';
            }
        }

      if (szTempPath[0] == '\0')
        {
          strcpy (szTempPath, getenv (pszTmp));
          if (szTempPath[0] != '\0')
            {
              /* Add "*.*" to the temp path */
              strcpy (szCommandVer, szTempPath);
              wLastChar = strlen (szCommandVer) - 1;
              if (szCommandVer[wLastChar] != '\\')
                strcat (szCommandVer, "\\");
              strcat (szCommandVer, "*.*");

              /* Check to see if the directory is valid */
              fReturnValue = _dos_findfirst (szCommandVer, 0xFFFF, &ft);
              if (fReturnValue != 0)
                {
                  fTmpPathInvalid = TRUE;

                  if (fCwIsReady)
                    {
                      strcpy (szTempPath, pszTmp);
                      strcat (szTempPath, "=");
                      strcat (szTempPath, getenv (pszTmp));
                      MessageBox (pszEnvironInvalid, szTempPath, NULL,
                                  MB_OK | 0x8000);
                    }

                  szTempPath[0] = '\0';
                }
            }
        }

      /* Current directory */
      if (szTempPath[0] == '\0')
        {
          getcwd (szTempPath, _MAX_PATH - 1);

          /* A: and B: are not allowed */
          if (szTempPath[0] == '\0'               ||
              strnicmp (szTempPath, "A:", 2) == 0 ||
              strnicmp (szTempPath, "B:", 2) == 0)
            return (TRUE);
        }


      /* Add the filename */
      wLastChar = strlen (szTempPath) - 1;
      if (szTempPath[wLastChar] != '\\')
        strcat (szTempPath, "\\");
      strcat (szTempPath, "__MSD__.$$$");

      /* Create the complete command string */
      strcpy (szCommandVer, "VER > ");
      strcat (szCommandVer, szTempPath);

      fReturnValue = system (szCommandVer);
      if (fReturnValue)
        {
          DeleteFile (szTempPath);
          return (TRUE);
        }

      /* Open the file with the version */
      fileVer = OpenFile (szTempPath, "rb", FALSE);
      if (fileVer == NULL)
        {
          DeleteFile (szTempPath);
          return (TRUE);
        }

      /* Read the DOS OEM version strings */
      i = 0;
      while (ReadLine (chBuffer, MAX_OEM_VER - 1, fileVer, FALSE) != EOF &&
             i < MAX_OEM_VER_STRINGS)
        {
          if (chBuffer[0] != '\0')
            {
              strcpy (pOsVer->szOemVer[i++], chBuffer);

              /* Word wrap the line if it's > 50 chars */
              if (strlen (chBuffer) > 51)
                {
                  /* Look back for a space */
                  for (u = 50; u > 0 && chBuffer[u] != ' '; --u)
                    ;

                  /* Clear out the existing string */
                  pOsVer->szOemVer[i - 1][u] = '\0';

                  if (i < MAX_OEM_VER_STRINGS)
                    {
                      /* Copy the excess to the next string */
                      strcpy (pOsVer->szOemVer[i++], &chBuffer[++u]);
                    }
                }
            }
        }


      /* Close the temp file */
      CloseFile (fileVer);

      /* Delete the temp file */
      DeleteFile (szTempPath);

      /* Store the OEM Version strings for later use */
      fpszOemStrings = _fmalloc (MAX_OEM_VER_STRINGS * MAX_OEM_VER);
      if (fpszOemStrings)
        _fmemcpy (fpszOemStrings, pOsVer->szOemVer,
                  MAX_OEM_VER_STRINGS * MAX_OEM_VER);
    }

  /* Check for DOS 4.01 */
  if (pOsVer->wDosMajor == 4 && pOsVer->wDosMinor == 0)
    {
      for (i = 0; i < MAX_OEM_VER_STRINGS; ++i)
        {
          if (strstr (pOsVer->szOemVer[i], "4.01") != NULL)
            pOsVer->wDosMinor = 1;
        }
    }

  return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\scr.h ===
/*
	scr.h : screen / kanji tests
*/

VOID FAR PASCAL InitModeMapping(void);
BOOL FAR	FInitScreenMode(WORD);
VOID FAR	SelectMode(void);
VOID FAR	SaveOriginalScreen(void);
BOOL FAR	FRestoreOriginalScreen(void);

WORD FAR * FAR PASCAL LpwAllocDriverMem(WORD, WORD);
VOID FAR PASCAL FreeDriverMem(WORD FAR *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\scr.c ===
/*
  scr.c : screen / kanji tests
*/


#define fAllocFonts TRUE
/*
WORD FAR * FAR PASCAL LpwAllocDriverMem(WORD, WORD);
VOID FAR PASCAL FreeDriverMem(WORD FAR *);
VOID FAR PASCAL InitModeMapping(void);
*/
STATIC BOOL   FSzOfImd(WORD, char *);
STATIC WORD   CwNeedInst(INST *);
STATIC BYTE   BPrefixLine(WORD);
STATIC VOID   TestDbcs(void);
STATIC VOID   TestChar(DCHAR, char);

#ifdef OS2
int FAR PASCAL DosAllocSeg(WORD, WORD FAR *, WORD);
int FAR PASCAL DosFreeSeg(WORD);
#endif

/* forward */
STATIC VOID FAR * LpwAllocCw(WORD);
STATIC VOID FreeLpw(WORD FAR *);

WORD    mpimdimode[100] = { 0 };
WORD    imdMac = 0;

/************************* Segment aligned allocation *******************/

//  -- allocate "cw" words, return far pointer with offset of 0
//  -- return 0 if error

STATIC VOID FAR *
LpwAllocCw(cw)
WORD  cw;
{
#ifndef OS2
  WORD FAR * lpw = _fmalloc(cw * 2 + 15);
  WORD  para;

  // normalize pointer 

        para = (HIWORD (lpw) + ((LOWORD ((DWORD) lpw) + 15) >> 4));
        return (WORD FAR *) MAKELONG (0, para);
#else
  WORD  ps;

  if (DosAllocSeg(cw * 2, &ps, 0) != 0)
    return NULL;
  else
    return (WORD FAR *) MAKELONG(0, ps);

#endif
}

//  -- free allocated far pointer

STATIC VOID
FreeLpw(lpw)
WORD FAR * lpw;
{
#ifndef OS2
  _ffree(lpw);    // far buffer 
#else
  DosFreeSeg(HIWORD(lpw));
#endif 
}

/******************************Driver memory allocation***********************/

//  -- driver memory allocator

WORD FAR * FAR PASCAL
LpwAllocDriverMem(cw, fmem)
WORD  cw;
WORD  fmem;
{
  if (fmem & fmemNear)
    {
    WORD *  pw;
    if ((pw = malloc(cw * 2)) == NULL)
      return NULL;

    return (WORD FAR *) pw;
    }
  else
    {
    // normal far allocation (must be PARA aligned)
    return LpwAllocCw(cw);
    }
}


//  -- free driver memory

VOID FAR PASCAL
FreeDriverMem(lpw)
WORD FAR * lpw;
{
        if (HIWORD ((WORD FAR *) &lpw) == HIWORD (lpw))
                free ((void *) LOWORD ((DWORD) lpw));      /* near buffer */
  else
                FreeLpw (lpw);
}



/*****************************************************************************/

//  -- initialize mapping

VOID FAR PASCAL
InitModeMapping()
{
  WORD  imode;
  INST  inst;

  if (imdMac != 0)
    return;

  imode = 0;

  while (FQueryInst(&inst, imode))
    {
    if (inst.finst & finstAvailable)
      mpimdimode[imdMac++] = imode;
    imode++;
    }
}


/*****************************************************************************/

//  -- high level init (includes allocating buffers)
//  imd == -1 -> initialize best guess

BOOL FAR
FInitScreenMode(imd)
WORD  imd;
{
  INST  inst;
  WORD  imode;

  if (imd == -1)
    {
    if ((imode = ImodeGuessCurrent()) == imodeUnknown)
      imode = mpimdimode[0];
    }
  else
    imode = mpimdimode[imd];

  if (!FQueryInst(&inst, imode) ||
      !FAllocInstBuffers(&inst, LpwAllocDriverMem, fAllocFonts) ||
      !FAllocOverlapTable(&inst, LpwAllocDriverMem) ||
      !FInitScreen(&inst, FALSE))
    return FALSE;

  // it worked ! 
  return TRUE;
}


/*****************************************************************************/
// Change Screen Mode Option 

//  -- query the available modes of the adapter

VOID FAR
SelectMode()
{
}



STATIC BOOL
FSzOfImd(imd, sz)
WORD  imd;
char *  sz;
{
  INST  inst;

  if (!FQueryInst(&inst, mpimdimode[imd]))
    {
    MessageBox("CSD inconsistancy!", "mode no longer available",
      NULL, MB_OK | 0x8000);

    return FALSE;
    }

  sprintf(sz, "%4s %3dX%2d (%5d)",
     (inst.finst & finstText) ? "Text" : "Gfxs",
     inst.axMac, inst.ayMac,
     CwNeedInst(&inst));

  if (inst.finst & finstMonochrome)
    strcat(sz, " Mono");
  if (inst.finst & finstAlternate)
    strcat(sz, " Alt");
  if (inst.finst & finstQuestionable)
    strcat(sz, " ??");

  return TRUE;
}



/*****************************Driver Buffer Size function*********************/

// forward (looks like a use of local procedures to me 

STATIC WORD FAR * FAR PASCAL LpwFakeAlloc(WORD, WORD);
STATIC VOID FAR PASCAL FakeFree(WORD FAR *);

WORD  cwNeed;

//  -- fake allocator to count size

STATIC WORD FAR * FAR PASCAL
LpwFakeAlloc(cw, fmem)
WORD  cw;
WORD  fmem;
{
  Unreferenced(fmem);

  cwNeed += cw;

  return (WORD FAR *) MAKELONG(0, 0xffff); // return non-null 
}

//  -- fake free routine

STATIC VOID FAR PASCAL
FakeFree(lpw)
WORD FAR * lpw;
{
  Unreferenced(lpw);
}

//  -- return the number of extra words needed for screen buffers

STATIC WORD
CwNeedInst(pinst)
INST *  pinst;
{
  cwNeed = 0;

  if (!FAllocInstBuffers(pinst, LpwAllocDriverMem, FALSE))
    return 0;

  FreeInstBuffers(pinst, FreeDriverMem);

  return cwNeed;
}


/***************************Original screen save & return*********************/

VIDS *  pvids = NULL;   // the vids structure containing info
WORD FAR * lpwScreen;   // the screen contents 

//  -- save the current screen (assuming we are going into the 0th mode)

VOID FAR
SaveOriginalScreen()
{
  INST  inst;
  WORD  cbVids;

  pvids = NULL;

  if (!FQueryInst(&inst, 0))
    return;   // something really wrong 

  if ((cbVids = CbSizeVids()) == 0)
    return;   // screen save not supported 

  if ((pvids = malloc(cbVids)) == NULL)
    return;   // no room for VIDS 

  if (!FSaveVids(pvids, &inst))
    {
    // error during save 
    free(pvids);
    pvids = NULL;
    return;
    }

  if ((lpwScreen = LpwAllocCw(pvids->cwVidData)) != NULL)
    SaveVidData(pvids, lpwScreen);
}



BOOL FAR
FRestoreOriginalScreen()
{
  if (pvids == NULL)
    {
    // we can't restore => clear the screen 
    return FALSE;
    }

  if (!FRestoreVids(pvids))
    {
//    MessageBox("Screen restore failed", NULL, NULL, MB_OK | 0x8000);

    free(pvids);

    pvids = NULL;

    if (lpwScreen != NULL)
      {
      FreeLpw(lpwScreen);
      lpwScreen = NULL;
      }
    return FALSE;
    }

  RestoreVidData(pvids, lpwScreen);

  free(pvids);
  pvids = NULL;

  if (lpwScreen != NULL)
    {
    FreeLpw(lpwScreen);
    lpwScreen = NULL;
    }
  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\remutil.h ===
/*****************************************************************/
/**		     Microsoft LAN Manager			**/
/**	       Copyright(c) Microsoft Corp., 1987-1990		**/
/*****************************************************************/

/********************************************************************
 *								    *
 *  About this file ...  REMUTIL.H				    *
 *								    *
 *  This file contains information about the NetRemote APIs.	    *
 *								    *
 *	Function prototypes.					    *
 *								    *
 *	Data structure templates.				    *
 *								    *
 *	Definition of special values.				    *
 *								    *
 *								    *
 *  NOTE:  You must include NETCONS.H before this file, since this  *
 *	   file	depends on values defined in NETCONS.H.		    *
 *								    *
 ********************************************************************/

#ifndef NETREMUTIL_INCLUDED

#define NETREMUTIL_INCLUDED


/****************************************************************
 *                                                              *
 *              Function prototypes - REMOTE                    *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetRemoteCopy ( const char far * pszSourcePath,
                  const char far * pszDestPath,
                  const char far * pszSourcePasswd,
                  const char far * pszDestPasswd,
                  unsigned short   fsOpen,
                  unsigned short   fsCopy,
                  char far *       pbBuffer,
                  unsigned short   cbBuffer );

extern API_FUNCTION
  NetRemoteExec ( char far *       pszReserved1,
                  char far *       pszFailName,
                  unsigned         cbFailName,
                  unsigned         fAsync,
                  const char far * pszArgs,
                  const char far * pszEnvs,
                  char far *       pReturnCodes,
                  const char far * pszPgmName,
                  char far *       pszReserved2,
                  unsigned short   fsRemoteExec );

extern API_FUNCTION
  NetRemoteMove ( const char far * pszSourcePath,
                  const char far * pszDestPath,
                  const char far * pszSourcePasswd,
                  const char far * pszDestPasswd,
                  unsigned short   fsOpen,
                  unsigned short   fsMove,
                  char far *       pbBuffer,
                  unsigned short   cbBuffer );

extern API_FUNCTION
  NetRemoteTOD ( const char far * pszServer,
                 char far *       pbBuffer,
                 unsigned short   cbBuffer );


/****************************************************************
 *								*
 *	  	Data structure templates - REMOTE		*
 *								*
 ****************************************************************/

struct copy_info {
	unsigned short	ci_num_copied;
	char 		ci_err_buf[1];
};	/* copy_info */


struct move_info {
	unsigned short	mi_num_moved;
	char 		mi_err_buf[1];
};	/* move_info */

struct time_of_day_info {
    unsigned long   tod_elapsedt;   /* time from 1-1-1970 in seconds */
    unsigned long   tod_msecs;	    /* milliseconds */
    unsigned char   tod_hours;	    /* hours */
    unsigned char   tod_mins;	    /* minutes */
    unsigned char   tod_secs;	    /* seconds */
    unsigned char   tod_hunds;	    /* hundredths */
    unsigned short  tod_timezone;   /* time zone in minutes from GMT */
    unsigned short  tod_tinterval;  /* timer interval (units = 0.0001 sec) */
    unsigned char   tod_day;	    /* day */
    unsigned char   tod_month;	    /* month */
    unsigned short  tod_year;	    /* year */
    unsigned char   tod_weekday;    /* day of week */
};	/* time_of_day_info */




/****************************************************************
 *								*
 *	  	Special values and constants - REMOTE		*
 *								*
 ****************************************************************/

/*
 *	Bit values for the "copyflags" parameter of NetRemoteCopy
 *	and the "moveflags" parameter of NetRemoteMove.
 *
 *	bit 0:  	1 - destination mode must be a file
 *	bit 1:  	1 - destination mode must be a directory
 *
 *	The following bits are defined for NetRemoteCopy ONLY.
 *
 *	bit 2:  	0 - destination copy mode is binary.
 *			1 - destination copy mode is ASCII.
 *	bit 3:  	0 - source copy mode is binary.
 *			1 - source copy mode is ASCII.
 *	bit 4:		1 - verify all writes.
 */

#define MUST_BE_FILE	0x1
#define MUST_BE_DIR	0x2
#define ASCII_DEST	0x4
#define ASCII_SOURCE	0x8
#define VERIFY		0x10


/*
 *	Bit values for the "remexecflags" parameter of NetRemoteExec.
 *
 *	bit 0:  	0 - use msg mode pipe for std in
 *			1 - use char mode pipe for std in
 *	bit 1:  	0 - CWait for process tree before returning
 *			    ExitCode to Ghost
 *			1 - CWait for exec'ed process before returning
 *			    ExitCode to Ghost
 *	bit 2:  	0 - Map SIGINTR and SIGBREAK to SIGKILL when
 *			    remoting signals
 *			1 - Send signals as received
 */

#define REM_PIPE_MODE      	1
#define REM_PIPE_MODE_MSG  	0
#define REM_PIPE_MODE_CHAR 	1

#define REM_WAIT_MODE 		2
#define REM_WAIT_MODE_PROCESS 	0
#define REM_WAIT_MODE_TREE 	2

#define REM_SIGL_MODE 		4
#define REM_SIGL_MODE_MAP	0
#define REM_SIGL_MODE_RAW	4


#endif /* NETREMUTIL_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\rptinfo.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * RPTINFO.C - Source file for reporting specific code.
 ********************************************************************/


/* Include Files */

#include "msd.h"


PSZ  pszHeaderLine = NULL; /* Header string */

/********************************************************************
 * ReportOnly - Generates an MSD report from the "/F" command line
 *              parameter.
 *
 * pszRptFilename - Name of file for "/F" report
 *
 * This routine will get and print each record, one record at a time.
 *
 * Returns: TRUE if an error condition occured.
 ********************************************************************/

BOOL ReportOnly (PSZ pszRptFilename)
{
  FILE *fileReportFile;         /* File handle for report file        */
  VOID *pStructForInfo = NULL;  /* Pointer to structure with data     */
  WORD wStructSize;             /* Stores memory requirements for     */
                                /*   GetInfo record                   */
  WORD wRecordType;             /* Record Type                        */
  QSZ  *pqszStrings;            /* Array of strings to print          */
  BOOL fReturnValue = FALSE;    /* Stores return value from GetInfo   */
  BOOL fFirstPass = TRUE;       /* Used for printing the first header */
  INT  i, u;                    /* Looping variables                  */
  INT  iLoopStart;              /* Starting value for loop            */
  INT  iLoopEnd;                /* Ending value for loop              */
  CHAR chBuffer[_MAX_PATH];     /* Local string                       */

  /* Open the report file */

  fileReportFile = OpenFile (pszRptFilename, pszOutput, TRUE);

  if (fileReportFile == NULL)
    return (TRUE);

  /* Set the buffer size to 0 so all characters will be written to */
  /*   the disk immediately.  This will help us determine where    */
  /*   MSD crashed, and will give us as much information as MSD    */
  /*   could provide before crashing.                              */

  /* setvbuf (fileReportFile, NULL, _IONBF, 0); */

  /* Set page, line, and column counts to 0 */

  wLineCount   = 0;
  wColumnCount = 0;
  wPageCount   = 0;

  if (fFirstPass && rgfReportItemFlag[IDI_CUSTOMER_INFORMATION] == FALSE)
    {
      fFirstPass = FALSE;

      /* Put on the initial page break */
      fReturnValue = WritePageBreak (fileReportFile);
      if (fReturnValue)
        return (fReturnValue);
    }

  /* If this is a /S summary only report, just print the summary */
  if (fSummaryOnly)
    {
      iLoopStart = IDI_SUMMARY_SCREEN;
      iLoopEnd   = IDI_SUMMARY_SCREEN + 1;
    }
  else
    {
      iLoopStart = 1;
      iLoopEnd   = NMBR_OF_RECORDS;
    }

  /* Report the information from the buttons */

  for (i = iLoopStart; i < iLoopEnd && !fReturnValue; ++i)
    {
#if HEAP_DEBUG
      sprintf (chBuffer, "i = %d", i);
      HeapCheck (chBuffer);
#endif
      /* Is the information available for this item */

      if (rgfReportItemFlag[i] == FALSE)
        continue;


      /* Determine the memory required to store the record */

      wStructSize = GetInfoSize (rwRecordTypes[i], 0);

      if (wStructSize == 0)
        continue;  /* NULL usually means I had an invalid record type */


      /* Allocate memory for the structure */

      pStructForInfo = malloc (wStructSize);

      if (pStructForInfo == NULL)
        {
          OutOfMemory();
          return (TRUE);
        }


      /* Zero out the structure */
      memset (pStructForInfo, '\0', wStructSize);


      /* Fill it with the GetInfo data */

      fReturnValue = GetInfo (rwRecordTypes[i],
                              pStructForInfo,
                              FALSE,    /* Do not obtain minimum info */
                              FALSE,    /* No include header record   */
                              TRUE);    /* We are doing a report      */
#if HEAP_DEBUG
      sprintf (chBuffer, "After GetInfo %d", i);
      HeapCheck (chBuffer);
#endif

      if (fReturnValue)
        {
          free (pStructForInfo);
          return (TRUE);
        }

      pqszStrings = SprintInfo (rwRecordTypes[i],
                                pStructForInfo,
                                NULL,
                                TRUE);  /* We are doing a report      */
#if HEAP_DEBUG
      sprintf (chBuffer, "After SprintInfo %d", i);
      HeapCheck (chBuffer);
#endif

      if (fFirstPass && !fSummaryOnly)
        {
          fFirstPass = FALSE;

          /* Put on the initial page break */
          fReturnValue = WritePageBreak (fileReportFile);
          if (fReturnValue)
            return (fReturnValue);
        }


      /* Write the strings to the report file */

      if (pqszStrings != NULL)
        if (fSummaryOnly)
          {
            /* Print out the summary information */

            for (u = 0; !fReturnValue && pqszStrings[u] != NULL; ++u)
              fReturnValue = WriteLine (pqszStrings[u], fileReportFile, TRUE);
          }
        else
          {
            wRecordType = rwRecordTypes[i];

            fReturnValue = WriteInfo (fileReportFile,
                                      paszButtonNames[wRecordType],
                                      pqszStrings);
          }
#if HEAP_DEBUG
      sprintf (chBuffer, "After WriteInfo %d", i);
      HeapCheck (chBuffer);
#endif

      /* Flush the report buffer */
      fflush (fileReportFile);

      /* Free up the allocated memory */
      free (pStructForInfo);
      FreeStringSpace (pqszStrings);
#if HEAP_DEBUG
      sprintf (chBuffer, "After three free's %d", i);
      HeapCheck (chBuffer);
#endif
    }

  /* If we're doing just the summary, then we're done */
  if (fSummaryOnly)
    return (fReturnValue);

  /* Report the Memory Browser information */

  if (rgfReportItemFlag[i] == TRUE && !fReturnValue)
    {
      fReturnValue = ReportBrowseInfo (fileReportFile);

      /* Flush the report buffer */
      fflush (fileReportFile);
    }

  /* Check to see if we are only printing one item */

  if (iLoopStart != iLoopEnd + 1)
    {
      /* Report the files (AUTOEXEC.BAT, etc) */

      for (i = RIF_START;
           i < MAX_REPORT_ITEM_FLAGS && !fReturnValue; ++i)
        {
          FILE_INFO FAR * ffi;    /* File Information structure        */
          FILE_INFO FAR * ffi2;   /* File Information structure (copy) */


          /* Is the information available for this item */

          if (rgfReportItemFlag[i] == FALSE)
            continue;

          ffi = FindFile (rgszSystemFiles[i - RIF_START], NULL,
                          rgwSystemFiles[i - RIF_START], '\0');
          ffi2 = ffi;

          while (ffi != NULL && ffi->fpNextFileInfo != NULL && !fReturnValue)
            {
              /* Put the filename into chBuffer */
              _fstrcpy (chBuffer, ffi->fpszPathToFile);

              /* Print the file on the report */
              fReturnValue = ReportFile (chBuffer, chBuffer, fileReportFile);

              /* Flush the report buffer */
              fflush (fileReportFile);

              /* Point to the next File info structure */
              ffi = (FILE_INFO FAR *) (ffi->fpNextFileInfo);
            }

          FreeFileInfo (ffi2);
        }
    }

  /* Send a form feed at the end of the document */
  if (fReturnValue == FALSE)
    fReturnValue = WriteChar ('\f', fileReportFile);

  CloseFile (fileReportFile);

  free (pszHeaderLine);

  if (fReportOnly && !fSummaryOnly)
    putch ('\n');

  return (fReturnValue);
}


#if CW_INCLUDED

/*********************************************************************
 * ReportFromCW - Generates a report from the CW version of MSD.
 *
 * Globals:
 * wReportToIndex - Index to paszReporTo.  == 7 if pszReportFilename
 *                  already contains a filename for the report.
 *********************************************************************/

BOOL ReportFromCW (VOID)
{
  BOOL fReturnValue;  /* Return value from ReportOnly() */


  /* Set the flag indicating that a report is underway */
  fReportFlag = TRUE;


  /* Report to the appropriate port/file */
  if (wReportToIndex == 7)
    {
      fReturnValue = ReportOnly (pszReportFilename);
      free (pszReportFilename);
    }
  else
    {
      fReturnValue = ReportOnly (paszReportTo[wReportToIndex]);
    }


  /* Set the flag indicating that the report is over */
  fReportFlag = FALSE;


  /* Inform the user that the report is finished */
  DisplayStatus (ST_REPORT_COMPLETED);


  return (fReturnValue);
}

#endif


/********************************************************************
 * WriteInfo - Writes a set of strings to the output file
 *
 * fileReportFile - File handle to write strings to
 * pszTitle       - Title of information being printed
 *                  (NULL for no separator line)
 * ppszStrings    - Array of strings to print
 *
 * Globals:
 *   wLineCount   - Used for determining the need for a page break
 *
 * Returns: TRUE if an error condition occured.
 ********************************************************************/

BOOL WriteInfo (FILE *fileOutput,
                PSZ  pszTitle,
                QSZ  *pqszStrings)
{
  BOOL fReturnValue = FALSE;  /* Return value from various functions    */
  INT  i;                     /* Index to pqszStrings, looping variable */
  WORD wNmbrLines = 0;        /* Number of lines in this string array   */
  WORD wLongestLine = 0;      /* The length of the longest line         */
  WORD wLength;               /* The length of the current line         */
  INT  iIndent;               /* Number of characters to indent on each */
                              /*   line, for centering purposes         */
  INT  iIndentCount;          /* Variable for outputting the indent     */

  /* Determine the number of lines and the length of the longest line */

  while (pqszStrings[wNmbrLines] != NULL)
    {
      if ((wLength = Qstrlen (pqszStrings[wNmbrLines++])) > wLongestLine)
        wLongestLine = wLength;
    }

  /* Determine the left indent required to center the text */

  if (wNmbrLines)
    {
      iIndent = (REPORT_WIDTH / 2) - (wLongestLine / 2) - 1;

      if (iIndent < 0)
        iIndent = 0;

      /* Account for the separator line */

      if (pszTitle != NULL && pszTitle[0] != '\0')
        wNmbrLines += 3;

      /* Determine if a page break is required */

      if (wNmbrLines + wLineCount > LINES_PER_PAGE)
        fReturnValue = WritePageBreak (fileOutput);

      /* Write the separator line, if requested */

      if (pszTitle != NULL && pszTitle[0] != '\0')
        fReturnValue = WriteSepLine (fileOutput, pszTitle);

      /* Write the strings */

      i = 0;

      while (!fReturnValue && pqszStrings[i] != NULL)
        {
          iIndentCount = iIndent;

          while (!fReturnValue && iIndentCount--)
            fReturnValue = WriteChar (' ', fileOutput);

          if (!fReturnValue)
            fReturnValue = WriteLine (pqszStrings[i++], fileOutput, TRUE);
        }

      /* Flush the buffer contents */

      if (!fReturnValue)
        {
          fReturnValue = fflush (fileOutput);

          /* Adjust the return value appropriately */

          if (fReturnValue == EOF)
            fReturnValue = TRUE;
          else
            fReturnValue = FALSE;
        }
    }

  return (fReturnValue);
}

/********************************************************************
 * WriteSepLine - Writes a separator line to the output file
 *
 * fileOutput - File handle to write strings to
 * pszTitle   - Title of record type being printed
 *              (NULL for no separator line)
 *
 * Returns: TRUE if an error condition occured.
 ********************************************************************/

BOOL WriteSepLine (FILE *fileOutput, PSZ pszTitle)
{
  BOOL fReturnValue;            /* Return value from Write___ functions  */
  CHAR chBuffer[REPORT_WIDTH];  /* Buffer for building output string     */
  INT  iLen;                    /* String length                         */
  INT  iDashCount;              /* Number of dashes to the left of title */
  INT  i;                       /* Index to chBuffer                     */

  /* Fill in all the dashes */

  memset (chBuffer, '-', REPORT_WIDTH - 1);

  /* Determine the length of the title */

  iLen = strlen (pszTitle);
  iDashCount = ((REPORT_WIDTH - iLen) / 2) - 2;
  i = iDashCount;

  /* Put in a leading space, the name, and the trailing space */

  chBuffer[i++] = ' ';

  strcpy (&chBuffer[i], pszTitle);

  i += iLen;
  chBuffer[i] = ' ';
  chBuffer[REPORT_WIDTH - 1] = '\0';

  /* Now, output the separator line */

  fReturnValue = WriteChar ('\n', fileOutput);
  if (fReturnValue)
    return (fReturnValue);

  fReturnValue = WriteLine (chBuffer, fileOutput, TRUE);
  if (fReturnValue)
    return (fReturnValue);

  fReturnValue = WriteChar ('\n', fileOutput);
  if (fReturnValue)
    return (fReturnValue);
}

/********************************************************************
 * WritePageBreak - Writes a separator line to the output file
 *
 * fileOutput - File handle to write strings to
 *
 * Returns: TRUE if an error condition occured.
 ********************************************************************/


BOOL WritePageBreak (FILE *fileOutput)
{
  static struct dosdate_t daDate;   /* Dos date structure               */
  static struct dostime_t tiTime;   /* Dos time structure               */
  BOOL fReturnValue = FALSE;        /* Return Value from Write___ funcs */
  INT  i;                           /* Looping variable                 */

  /* Create the header line only on the first page */

  if (wPageCount == 0)
    {
      ++wPageCount;

      /* Create the header line */
      pszHeaderLine = malloc (REPORT_WIDTH);

      if (pszHeaderLine == NULL)
        {
          OutOfMemory();
          return (TRUE);
        }

      /* Obtain the current date and time */

      _dos_getdate (&daDate);
      _dos_gettime (&tiTime);
    }

  if (fReportOnly)
    {
      CHAR chBuffer[20];
      WORD i = 0;

      /* Display the page number on the screen */
      sprintf (chBuffer, "\rPage %u", wPageCount);

      while (chBuffer[i])
        putch (chBuffer[i++]);
    }
#if CW_INCLUDED
  else
    {
      CHAR chBuffer[20];

      /* Display the page number on the status line */
      sprintf (chBuffer, "Page %u", wPageCount);
      ShowStatus (chBuffer);
    }
#endif


  /* Write the formfeed, followed by 2 linefeeds */

  if (wPageCount > 1)
    {
      fReturnValue = WriteChar ('\f', fileOutput);
      if (fReturnValue)
        return (fReturnValue);
    }

  for (i = 0; !fReturnValue && i < 2; ++i)
    fReturnValue = WriteChar ('\n', fileOutput);

  if (fReturnValue)
    return (fReturnValue);


  /* Create header string */

  sprintf (pszHeaderLine,
           pszHeaderFormatString,
           pszVersionNumber,
           daDate.month,
           daDate.day,
           daDate.year % 100,
           (tiTime.hour > 12) ? tiTime.hour-12 : tiTime.hour,
           tiTime.minute,
           (tiTime.hour > 12) ? "pm" : "am",
           wPageCount++);


  /* Print the header line */

  fReturnValue = WriteLine (pszHeaderLine, fileOutput, TRUE);
  if (fReturnValue)
    return (fReturnValue);


  /* Print the underline, followed by 1 linefeed */

  i = REPORT_WIDTH;

  while (!fReturnValue && i--)
    fReturnValue = WriteChar ('=', fileOutput);

  if (fReturnValue)
    return (fReturnValue);

  for (i = 0; !fReturnValue && i < 1; ++i)
    fReturnValue = WriteChar ('\n', fileOutput);

  if (fReturnValue)
    return (fReturnValue);

  return (FALSE);
}


/********************************************************************
 * ReportFile - Writes a set of strings to the output file
 *
 *
 * Returns: TRUE if an error condition occured.
 ********************************************************************/

BOOL ReportFile (PSZ  pszTitle,
                 PSZ  pszFilename,
                 FILE *fileOutput)
{
  BOOL fReturnValue = FALSE;  /* Return value from various functions    */
  FILE *fileInput;            /* Input file handle                      */
  CHAR chBuffer[80];          /* Input buffer                           */


  /* Determine if a page break is required */
  if (wLineCount + 6 > LINES_PER_PAGE)
    fReturnValue = WritePageBreak (fileOutput);


  /* Write the separator line, if requested */
  if (pszTitle != NULL && pszTitle[0] != '\0')
    fReturnValue = WriteSepLine (fileOutput, pszTitle);


  /* Open the file */
  fileInput = OpenFile (pszFilename, "rb", TRUE);
  if (fileInput == NULL)
    return (TRUE);


  /* Write the strings */
  while (fReturnValue == FALSE &&
         ReadLine (chBuffer, REPORT_WIDTH, fileInput, FALSE) != EOF)
    {
      fReturnValue = WriteLine (chBuffer, fileOutput, TRUE);
    }

  /* Flush the buffer contents */

  if (!fReturnValue)
    {
      if (fflush (fileOutput) == EOF)
        fReturnValue = TRUE;
      else
        fReturnValue = FALSE;
    }

  CloseFile (fileInput);

  return (fReturnValue);
}


#if CW_INCLUDED

/*********************************************************************
 * TestPrinter - Performs the printer test.
 *
 * fPostscript - TRUE if the Postscript test is requested
 * f8BitTest   - TRUE if the 8-bit ASCII test is requested
 * fSerialTest - TRUE if serial port, FALSE for parallel port
 * wPort       - Printer port number for the test
 *********************************************************************/

BOOL TestPrinter (BOOL fPostscript,
                  BOOL f8BitTest,
                  BOOL fSerialTest,
                  WORD wPort)
{
  VOID *pPortStruct = NULL;   /* Structure for storing printer port data */
  COM_STRUCT *pCom;           /* COM Port data struct pointer            */
  LPT_STRUCT *pLpt;           /* LPT Port data struct pointer            */
  WORD wSize;                 /* Size of the structure                   */
  WORD wReturnValue;          /* Return value from various functions     */
  CHAR szPort[5];             /* Port's filename                         */


  /* Set up the port's filename */
  if (fSerialTest)
    strcpy (szPort, "COM");
  else
    strcpy (szPort, "LPT");

  szPort[3] = (CHAR) (wPort + '1');
  szPort[4] = '\0';


  /* Obtain the appropriate port information */

  if (fSerialTest)
    wSize = GetInfoSize (IDI_COM_RECORD, FALSE);
  else
    wSize = GetInfoSize (IDI_LPT_RECORD, FALSE);


  if (wSize == 0)
    return (TRUE);

  pPortStruct = malloc (wSize);

  if (pPortStruct == NULL)
    {
      OutOfMemory();
      return (TRUE);
    }

  /* Zero out the structure */
  memset (pPortStruct, '\0', wSize);

  if (fSerialTest)
    wReturnValue = GetInfo (IDI_COM_RECORD, pPortStruct, FALSE, FALSE, FALSE);
  else
    wReturnValue = GetInfo (IDI_LPT_RECORD, pPortStruct, FALSE, FALSE, FALSE);

  if (wReturnValue)
    {
      free (pPortStruct);
      return (wReturnValue);
    }


  /* Is the port available */

  if (fSerialTest)
    {
      pCom = pPortStruct;

      if (pCom->ComxInfo[wPort].fComPortDetected == FALSE)
        {
          wReturnValue = MessageBox (szPort,
                                     "Was not detected.",
                                     "Do you wish to continue?",
                                     MB_YESNO | 0x8000 | MB_DEFBUTTON2);

          if (wReturnValue == IDNO)
            return (FALSE);
        }
    }
  else
    {
      pLpt = pPortStruct;

      if (pLpt->LptxInfo[wPort].fLptPortDetected == FALSE)
        {
          wReturnValue = MessageBox (szPort,
                                     "Was not detected.",
                                     "Do you wish to continue?",
                                     MB_YESNO | 0x8000 | MB_DEFBUTTON2);

          if (wReturnValue == IDNO)
            return (FALSE);
        }
    }


  /* Is the port ready?  Check while waiting about 0.5 seconds */

  if (fSerialTest == FALSE)
    {
      /* Point to the DOS timer click count */
      BYTE FAR * fpDosClick = (BYTE FAR *) 0x0040006C;
      WORD wClickCount   = 10;          /* Number of clicks to count    */
      BOOL fPrinterReady = FALSE;       /* TRUE when printer is ready   */
      BYTE bClickValue   = *fpDosClick; /* Current value of the counter */


      /* Port ready check */
      while (fPrinterReady == FALSE && wClickCount)
        {
          while (bClickValue == *fpDosClick &&
                 pLpt->LptxInfo[wPort].fLptPortDetected == FALSE)
            {
              GetInfo (IDI_LPT_RECORD, pLpt, FALSE, FALSE, FALSE);
            }

          /* Is the printer ready */
          if (pLpt->LptxInfo[wPort].fLptPortDetected == TRUE)
            {
              fPrinterReady = TRUE;
            }
          else
            {
              /* Reduce the number of click counts to check by 1 */
              --wClickCount;

              /* Set up to watch for the next click */
              bClickValue = *fpDosClick;
            }
        }


      /* Last chance */
      if (fPrinterReady == FALSE)
        {
          wReturnValue = MessageBox (szPort,
                                     "Does not appear to be ready",
                                     "Do you wish to continue?",
                                     MB_YESNO | 0x8000 | MB_DEFBUTTON2);

          if (wReturnValue == IDNO)
            return (FALSE);
        }
    }


  PrintTest (szPort, f8BitTest, fPostscript);

  return (FALSE);
}


/*********************************************************************
 * PrintTest - Prints the printer test to the specified port.
 *
 * pszPort - Filename of the printer port.
 * f8BitTest - TRUE if 8 bit test requested, FALSE for 7 bit test.
 * fPostscript - TRUE if Postscript codes required, FALSE for TTY.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL PrintTest (PSZ pszPort, BOOL f8BitTest, BOOL fPostscript)
{
  FILE *fpOut;        /* File handle for output                   */
  WORD i;             /* Looping variable                         */
  WORD wMaxChar;      /* Maximum character to print               */
  WORD wMaxCol;       /* Maximum character to print in column one */
  WORD wX;            /* X-Coordinate for postscript test         */
  WORD wY;            /* Y-Coordinate for postscript test         */
  static struct dosdate_t daDate;   /* Dos date structure         */
  static struct dostime_t tiTime;   /* Dos time structure         */
  BOOL fReturnValue;  /* Return value from various functions      */
  CHAR chBuffer1[80]; /* Buffer for printed line                  */
  CHAR chBuffer2[80]; /* Buffer for printed line                  */


  /* Open the file */
  fpOut = OpenFile (pszPort, "w", TRUE);
  if (fpOut == NULL)
    return (TRUE);


  /* Postscript Test */
  if (fPostscript)
    {
      /* Obtain the current date and time */
      _dos_getdate (&daDate);
      _dos_gettime (&tiTime);

      /* Output the header information */
      fReturnValue = _WriteLine (pszPostscriptTest1, fpOut);

      sprintf (chBuffer1, pszPostscriptTest2,
               daDate.month,
               daDate.day,
               daDate.year % 100,
               (tiTime.hour > 12) ? tiTime.hour-12 : tiTime.hour,
               tiTime.minute,
               (tiTime.hour > 12) ? "pm" : "am");

      fReturnValue = _WriteLine (chBuffer1, fpOut);

      fReturnValue = _WriteLine (pszPostscriptTest3, fpOut);

      /* Output the characters */
      wMaxChar = (f8BitTest) ? 255 : 127;
      wMaxCol  = ((wMaxChar - 32) / 6);

      wX = 100;
      wY = 600;

      for (i = 32; i <= wMaxChar && fReturnValue == FALSE; ++i)
        {
          sprintf (chBuffer1, "%d %d moveto (%d:) show %d %d moveto (\\%o) show\r\n",
                   wX, wY, i, wX + 30, wY, i);
          fReturnValue = _WriteLine (chBuffer1, fpOut);

          /* Move the Y value */
          wY -= 14;

          if (i >= wMaxCol + 32)
            {
              wMaxCol += ((wMaxChar - 32) / 6) + 1;
              wX      += 72;
              wY       = 600;
            }
        }

      _WriteLine ("showpage\r\n", fpOut);
    }
  else
    {
      /* Print the header */
      wLineCount   = 0;
      wColumnCount = 0;
      wPageCount   = 0;

      fReturnValue = WritePageBreak (fpOut);
      if (fReturnValue)
        return (fReturnValue);


      /* Output subheader information */
      for (i = 0; i < 2 && fReturnValue == FALSE; ++i)
        fReturnValue = WriteChar ('\n', fpOut);

      for (i = 0; i < 23 && fReturnValue == FALSE; ++i)
        fReturnValue = WriteChar (' ', fpOut);

      if (fReturnValue)
        return (fReturnValue);

      fReturnValue = WriteLine ("Standard Text Printer Test:\n", fpOut, TRUE);
      if (fReturnValue)
        return (fReturnValue);


      /* Output the characters */
      wMaxChar = (f8BitTest) ? 255 : 127;
      wMaxCol  = ((wMaxChar - 32) / 6) + 1;

      for (i = 32; i < wMaxCol + 32; ++i)
        {
          sprintf (chBuffer1, "           %3d: %c   %3d: %c   %3d: %c   %3d: %c   %3d: %c",
                   i,                 i,
                   i + wMaxCol,       i + wMaxCol,
                   i + (wMaxCol * 2), i + (wMaxCol * 2),
                   i + (wMaxCol * 3), i + (wMaxCol * 3),
                   i + (wMaxCol * 4), i + (wMaxCol * 4));

          if (i + (wMaxCol * 5) <= wMaxChar)
            {
              sprintf (chBuffer2, "   %3d: %c",
                       i + (wMaxCol * 5), i + (wMaxCol * 5));
            }
          else
            chBuffer2[0] = '\0';

          strcat (chBuffer1, chBuffer2);

          fReturnValue = WriteLine (chBuffer1, fpOut, TRUE);
          if (fReturnValue)
            return (fReturnValue);
        }

      fReturnValue = WriteChar ('\014', fpOut);
    }

  CloseFile (fpOut);

  return (fReturnValue);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\srmenu.h ===
/******************************************************************************

  smenu.h : (contains data)
  included by menu.c for Roman menus

******************************************************************************/


#define item1(sz, id, num) id, 0x0100, (WORD) sz, (WORD) num,
#define itemS 0, 0x0004, (WORD) NULL,
#define itemD(sz, id, num) id, 0x0101, (WORD) sz, (WORD) num,
#define itemB(sz, id, sub, num) id, 0x0240, (WORD) sz, (WORD) num, (WORD) sub,

WORD menuFile[]=
  {
  0, 13,
  item1("~Find File...", midFind, "")
  item1("~Print Report ...", midReport, "")
  itemS
  item1("~1 AUTOEXEC.BAT", midAutoexecBat, "")
  item1("~2 CONFIG.SYS", midConfigSys, "")
  item1("~3 SYSTEM.INI", midSystemIni, "")
  item1("~4 WIN.INI", midWinIni, "")
  item1("~5 MSMAIL.INI", midMsmailIni, "")
  item1("~6 PROTOCOL.INI", midProtocolIni, "")
  item1("~7 DBLSPACE.INI", midDblSpaceIni, "")
  item1("~8 MEMMAKER.STS", midMemMakerSts, "")
  itemS
  item1("E~xit          F3", midQuit, "")
  };

WORD *pmenuFile = &menuFile[0];

WORD menuUtil[]=
  {
  0, 6,
  item1("~Memory Block Display ...", midBlockDisplay, "")
  item1("Memory ~Browser ...", midBrowser, "")
  item1("~Insert Command ...", midInsert, "")
  item1("~Test Printer ...", midPrtTst, "Paste it in")
  itemS
  item1("Black & ~White         F5", midBlackWhite, "")
  };

WORD *pmenuUtil = &menuUtil[0];

WORD menuHelp[]=
  {
  0, 1,
  item1("~About ...", midAbout, "")
  };

WORD *pmenuHelp = &menuHelp[0];


WORD menuBlade[]=
  {
  0, 3,
  itemB("~File", midFile, &pmenuFile, "")
  itemB("~Utilities", midUtil, &pmenuUtil, "")
  itemB("~Help", midHelp, &pmenuHelp, "")
  };

WORD *pmenuBlade = &menuBlade[0];
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\strings.h ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * STRINGS.H - All #define strings are stored here
 ********************************************************************/


/* Command line parameter characters */

#define MONO_CHAR               'M'
#define BW_CHAR                 'B'
#define NO_INITIAL_DETECT_CHAR  'I'
#define REPORT_TO_FILE_CHAR     'F'
#define SUMMARY_TO_FILE_CHAR    'S'
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\sprninfo.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * SPRNINFO.C - Source file for generating info strings for display
 *              or report.
 ********************************************************************/


/* Include Files */

#include "msd.h"

/********************************************************************
 * SprintInfo - Converts data structure into an array of strings.
 *
 * wRecordType     - Record type requested.
 * pStructWithInfo - Pointer to record containing the data.
 * szSumStrings    - Summary strings.  NULL if full strings are to
 *                   be reported, non-NULL if summary strings are to
 *                   be filled.
 * fReportFlag     - TRUE if printing to a report.
 *
 * Returns: Pointer to the array of string pointers.  NULL pointer
 *          indicates that an error occured.
 ********************************************************************/

QSZ * SprintInfo (WORD wRecordType,
                  VOID *pStructWithInfo,
                  CHAR szSumStrings[][MAX_SUMM_INFO + 5],
                  BOOL fReportFlag)
{
  QSZ *pqszStrings = NULL;  /* Pointer to the array of pointers to the */
                            /*   string area.                          */


  if (szSumStrings != NULL                         &&
      (wRecordType < IDI_FIRST_RECORD_TO_SUMMARIZE ||
       wRecordType > IDI_LAST_RECORD_TO_SUMMARIZE))
    return (NULL);

  switch (wRecordType)
    {
      case IDI_CUSTOMER_INFORMATION:
        {
          /* Put the customer titles and strings together */

          pqszStrings = SprintCustInfo (pStructWithInfo);

          /* Return the pointer to pqszStrings */

          break;
        }

      case IDI_SUMMARY_SCREEN:
        {
          pqszStrings = SprintSummaryInfo (paszButtonNames, pStructWithInfo);

          break;
        }

      case IDI_COMPUTER_RECORD:
        {
          pqszStrings = SprintComputerInfo (pStructWithInfo, szSumStrings);

          break;
        }

      case IDI_MEMORY_RECORD:
        {
          pqszStrings = SprintMemInfo (MEM_ALL,
                                       pStructWithInfo,
                                       szSumStrings,
                                       TRUE);

          break;
        }

      case IDI_VIDEO_RECORD:
        {
          pqszStrings = SprintVideoInfo (pStructWithInfo, szSumStrings);

          break;
        }

      case IDI_NETWORK_RECORD:
        {
          pqszStrings = SprintNetworkInfo (pStructWithInfo, szSumStrings);

          break;
        }

      case IDI_OS_VERSION_RECORD:
        {
          pqszStrings = SprintOsVersionInfo (pStructWithInfo, szSumStrings);

          break;
        }

      case IDI_MOUSE_RECORD:
        {
          pqszStrings = SprintMouseInfo (pStructWithInfo, szSumStrings);

          break;
        }

      case IDI_OTHER_ADAPTERS_RECORD:
        {
          pqszStrings = SprintOtherInfo (pStructWithInfo, szSumStrings);

          break;
        }

      case IDI_DISK_DRIVE_RECORD:
        {
          pqszStrings = SprintDiskInfo (pStructWithInfo, szSumStrings);

          break;
        }

      case IDI_LPT_RECORD:
        {
          pqszStrings = SprintLptInfo (pStructWithInfo, szSumStrings);

          break;
        }

      case IDI_COM_RECORD:
        {
          pqszStrings = SprintComInfo (pStructWithInfo, szSumStrings);

          break;
        }

      case IDI_IRQ_RECORD:
        {
          pqszStrings = SprintIrqInfo (pStructWithInfo);

          break;
        }

      case IDI_TSR_PROGRAMS_RECORD:
        {
          pqszStrings = SprintTsrInfo (pStructWithInfo, TRUE);

          break;
        }

      case IDI_DEVICE_DRIVERS_RECORD:
        {
          pqszStrings = SprintDeviceDriverInfo (pStructWithInfo);

          break;
        }

      default:
        pqszStrings = NULL;
        break;
    }


  return (pqszStrings);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\showinfo.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * SHOWINFO.C - Source file for displaying information
 ********************************************************************/


/* Include Files */

#include "msd.h"


#ifdef CW_INCLUDED

/********************************************************************
 * ShowInfo - Displays the appropriate record in the info window.
 *
 * wRecordType - Record to display
 *
 * Returns: PWND of the info window, NULL if an error condition
 *          occured.
 ********************************************************************/

PWND ShowInfo (WORD wRecordType)
{
  VOID *pStructForInfo = NULL;  /* Pointer to structure with data   */
  WORD wStructSize;             /* Stores memory requirements for   */
                                /*   GetInfo record                 */
  QSZ  *pqszStrings;            /* Array of strings to print        */
  BOOL fReturnValue;            /* Stores return value from GetInfo */
  PWND pwndInfo = NULL;         /* Info Window's PWND               */


  /* Determine the memory required to store the record */
  wStructSize = GetInfoSize (wRecordType, 0);

  if (wStructSize == 0)
    {
#if HEAP_DEBUG
      CHAR chBuff1[80];   /* String for error message */

      sprintf (chBuff1, "%s, line %d\n", __FILE__, __LINE__);

      ShowError (MB_BEEP | MB_OK | 0x8000, "Invalid Record Type", "", "");
#endif
      return (NULL);
    }

  /* Allocate memory for the structure */
  pStructForInfo = malloc (wStructSize);
#if HEAP_DEBUG
  HeapCheck ("In ShowInfo, After malloc (wStructSize)");
#endif

  if (pStructForInfo == NULL)
    {
      OutOfMemory();
      return (NULL);
    }

  /* Zero out the structure */
  memset (pStructForInfo, '\0', wStructSize);

  /* If /I was used, set the flag stating that this information */
  /*   is now available for reporting.                          */
  rgfReportItemFlag[wRecordType] = TRUE;
  rgfReportItemFlag[IDI_SUMMARY_SCREEN] = TRUE;

  /* Fill it with the GetInfo data */
  fReturnValue = GetInfo (wRecordType,
                          pStructForInfo,
                          FALSE,    /* Do not obtain minimum info */
                          FALSE,    /* No include header record   */
                          TRUE);    /* We are doing a report      */

#if HEAP_DEBUG
  HeapCheck ("In ShowInfo, After GetInfo()");
#endif

  if (fReturnValue)
    {
      free (pStructForInfo);
      return (NULL);
    }

  /* Get the information into displayable strings */
  pqszStrings = SprintInfo (wRecordType,
                            pStructForInfo,
                            NULL,
                            FALSE);  /* We are not doing a report */
#if HEAP_DEBUG
  HeapCheck ("In ShowInfo, After SprintInfo()");
#endif

  /* Update the summary strings */
  SprintInfo (wRecordType, pStructForInfo,
              &(pSum->szSumStrings[wRecordType * 2]), TRUE);

#if HEAP_DEBUG
  HeapCheck ("In ShowInfo, After update of summary strings");
#endif

  /* PostMessage (pwndMainFrame, WM_PAINT, NULL, NULL); */

  /* Display the strings in the window */
  if (pqszStrings != NULL)
    pwndInfo = CreateInfoWnd (paszButtonNames[wRecordType],
                              pqszStrings,
                              FALSE);

#if HEAP_DEBUG
  HeapCheck ("In ShowInfo, After CreateInfoWnd()");
#endif

  free (pStructForInfo);

#if HEAP_DEBUG
  HeapCheck ("In ShowInfo, After free (pStructForInfo)");
#endif

  return (pwndInfo);
}


BOOL fVisibleFlag;            /* Set if scroll bar should be visible    */

/*********************************************************************
 * CreateInfoWnd - Procedure to create the info provider window.
 *
 * pwndParent     - Parent window for this window.
 * pszWindowTitle - Title for the info window.
 * pqszStrings    - Strings to be displayed in the info window.
 * fKeepFocus     - TRUE if this window should keep the focus.
 *
 * Returns:  PWND if creating Info Window was successful, NULL if an
 *           error occured.
 *********************************************************************/

STATIC PWND CreateInfoWnd (PSZ  pszWindowTitle,
                           QSZ  *pqszStrings,
                           BOOL fKeepFocus)
{
  PWND pwndInfoFrame = NULL;  /* Handle to the info window's frame      */
  PWND pwndInfoTxt = NULL;    /* Text window handle                     */
  PWND pwndScrollBar = NULL;  /* Handle to the scroll bar               */
  WORD wNmbrLines;            /* Number of lines in this string array   */
  WORD wLongestLine = 0;      /* The length of the longest line         */
  WORD wLength;               /* The length of the current line         */
  AX   axRight;               /* Coordinates for the upper left corner  */
  AY   ayTop;                 /*   of the info window.                  */
  AX   axWidth;               /* Size of the info window                */
  AY   ayHeight;
  PSZ  pszNewWindowTitle;     /* New location (malloc'ed) for the title */

  /* Determine the number of lines and the length of the longest line */

  for (wNmbrLines = 0; pqszStrings[wNmbrLines] != NULL; ++wNmbrLines)
    {
      if ((wLength = DisplayLen (pqszStrings[wNmbrLines])) > wLongestLine)
        wLongestLine = wLength;
    }

  /* Calculate the size of the window */

  if (wNmbrLines > (WORD) ayMac - 7)
    {
      ayHeight = ayMac - (AY) 2;
      axWidth  = (wLongestLine + 5> (WORD) axMac - 6) ?
                 axMac - (AX) 2 : (AX) wLongestLine + (AX) 5;
      fVisibleFlag = TRUE;
    }
  else
    {
      ayHeight = (AY) wNmbrLines + (AY) 5;
      axWidth  = (wLongestLine + 4> (WORD) axMac - 6) ?
                 axMac - (AX) 2 : (AX) wLongestLine + (AX) 4;
      fVisibleFlag = FALSE;
    }


  /* Calculate the coordinates of the info window */

  axRight = (AX) ((axMac / 2) - (axWidth / 2));
  ayTop   = (AY) ((ayMac / 2) - (ayHeight / 2));

  /* Copy the window title */

  pszNewWindowTitle = malloc (strlen (pszWindowTitle) + 1);
  if (pszNewWindowTitle == NULL)
    return (NULL);
  strcpy (pszNewWindowTitle, pszWindowTitle);


  /* Create the window */

  pwndInfoFrame = (PWND) CreateWindow (InfoWndCallID,
                                       NULL,
                                       WS_CLIPOUT | WS_BORDER |
                                         WS_OVERLAP /* | WS_VSCROLL */ ,
                                       WS_FRAME | WES_SHADOW |
                                         WES_OWNERREDRAW,
                                       axRight,
                                       ayTop,
                                       axWidth,
                                       ayHeight,
                                       (HWND) pwndMainFrame,
                                       (HMENU) NULL,
                                       NULL,
                                       1);

  if (pwndInfoFrame == NULL)
    return (NULL);

  /* Get the Info Text window's window handle */
  pwndInfoTxt = GetDlgItem (pwndInfoFrame, InfoTxtID);

  /* Set the pointer to the button's name */
  SetWindowWord (pwndInfoFrame, WEB_WINDOW_TITLE, (WORD) pszNewWindowTitle);

  /* Set the scroll bar's minimum value in the extra bytes */
  SetWindowWord (pwndInfoTxt, WEB_MIN_SCROLL, 0);

  /* Set the scroll bar's maximum value in the extra bytes */
  SetWindowWord (pwndInfoTxt, WEB_MAX_SCROLL, wNmbrLines - (ayHeight - 5));

  /* Set the total number of lines in this string array */
  SetWindowWord (pwndInfoTxt, WEB_NMBR_LINES, wNmbrLines);

  /* Set the number of scrollable lines in the window */
  SetWindowWord (pwndInfoTxt, WEB_SCROLLABLE_LINES, (WORD) ayHeight - 5);

  /* Set the pointer to the text to display */
  SetWindowWord (pwndInfoTxt, WEB_PQSZ_TEXT, (WORD) pqszStrings);

  /* Set the flag on wether this window should keep the focus or not */
  SetWindowWord (pwndInfoTxt, WEB_KEEP_FOCUS, (WORD) fKeepFocus);

  /* Set the ranges for the scroll bar */
  pwndScrollBar = GetDlgItem (pwndInfoTxt, InfoScrollID);

  SetScrollRange (pwndScrollBar,                /* Handle to scroll bar */
                  0,                            /* Minimum scroll value */
                  wNmbrLines - (ayHeight - 5),  /* Maximum scroll value */
                  FALSE);                       /* Redraws when TRUE */

  SetScrollPos (pwndScrollBar,     /* Handle to scroll bar */
                0,                 /* New scroll bar position */
                FALSE);            /* Redraws when TRUE */

  EnableWindow (pwndInfoFrame, TRUE);

  ShowWindow (pwndInfoFrame, SW_VISIBLE, TRUE);

  /* Hide the scroll bar if it is not necessary */

  if (fVisibleFlag == FALSE)
    ShowWindow (pwndScrollBar, SW_INVISIBLE, TRUE);

  /* Set the focus to the OK button */
  SetFocus (pwndInfoFrame);

  return (pwndInfoFrame);
}

/*********************************************************************
 * InfoWndProc - Procedure for handling the "Information Provider"
 *               window.
 *********************************************************************/

STATIC LONG FAR PASCAL InfoWndProc (PWND  pwnd,
                                    WORD  message,
                                    WORD  wParam,
                                    DWORD lParam)
{
  switch (message)
    {
      case WM_CREATE:
        CreateInfoChildWindows (pwnd);
        break;

#if 0
      case WM_ACTIVATE:
        {
          PWND pwndInfoTxt = NULL;   /* Handle to the text window */

          /* Get the window handles */
          pwndInfoTxt   = GetDlgItem (pwnd, InfoTxtWndCallID);

          if (GetWindowWord (pwndInfoTxt, WEB_KEEP_FOCUS))
            return (rspActiveDecline);
          else
            return (rspActiveLive);
          break;
        }
#endif

      case WM_COMMAND:

        /* Close window when OK button clicked */

        if (HIWORD (lParam) == BN_CLICKED && wParam == OkButtonID)
          PostMessage (pwnd, WM_CLOSE, NULL, NULL);
        break;

      case WM_CLOSE:
        {
#if HEAP_DEBUG
          _heapset ('W');
#endif

          /* Free up the window title */
          free ((PSZ) GetWindowWord (pwnd, WEB_WINDOW_TITLE));

#if HEAP_DEBUG
          _heapset ('X');
#endif

          /* Inform the summary window that we are shutting down */
          SendMessage (pwnd->pwndParent, WM_INFO_WND_CLOSED, (WORD) pwnd,
                       NULL);

          /* Destroy this info window */
          DestroyWindow (pwnd);
          break;
        }

      case WM_FRAMEDRAW:
        {
          RRC rrc;  /* Relative rectangle of window */

          GetClientRrc (pwnd, &rrc);

          DrawBorderAlign (pwnd,
                           pboxInfoBox,
                           isaInfoActiveBorder,
                           isaInfoActiveBorder,
                           (PSZ) GetWindowWord (pwnd, WEB_WINDOW_TITLE),
                           TRUE);

          if (FIsTopWindow(pwnd))
            DrawOverlapShadow (pwnd);

          CharOutBorder (pwnd,
                         0,
                         (RY) (rrc.ryBottom - 2),
                         '',
                         isaInfoActiveBorder);

          CharOutBorder (pwnd,
                         (RY) (rrc.rxRight + 1),
                         (RY) (rrc.ryBottom - 2),
                         '',
                         isaInfoActiveBorder);

          break;
        }

      case WM_CHAR:
        {
          PWND pwndInfoTxt = NULL;   /* Handle to the text window          */
          PWND pwndScrollBar = NULL; /* Handle to text window's scroll bar */
          WORD wKeyState;            /* Shift key state when key pressed   */


          /* Get the window handles */

          pwndInfoTxt   = GetDlgItem (pwnd, InfoTxtWndCallID);
          pwndScrollBar = GetDlgItem (pwndInfoTxt, InfoScrollID);


          /* Handle the main window's keys */
          wKeyState = HIWORD (lParam);

          /* Black & White keystroke */
          /* F5 */
          if ((wKeyState & (KK_MENU | KK_CONTROL | KK_SHIFT)) == 0 &&
              wParam == VK_F5)
            {
              SetIsaColors (fBlackWhite = !fBlackWhite);
              break;
            }


          /* Exit keystrokes */
          /* F3 */
          if ((wKeyState & (KK_MENU | KK_CONTROL | KK_SHIFT)) == 0 &&
              wParam == VK_F3)
            Exit (0);

          /* Alt-F4 */
          if ((wKeyState & (KK_MENU | KK_CONTROL | KK_SHIFT)) == KK_MENU &&
              wParam == VK_F4)
            Exit (0);


          /* Handle the info window specific keys */

          switch (wParam)
            {
              case VK_ESCAPE:
              case 27:
                PostMessage (pwnd, WM_CLOSE, NULL, NULL);
                break;

              /* VK_RETURN will have to be modified to do the button */

              case VK_RETURN:
              case 13:
                PostMessage (pwnd, WM_CLOSE, NULL, NULL);
                break;

              case VK_HOME:
                SendMessage (pwndInfoTxt, WM_VSCROLL, SB_TOP,
                             ((DWORD) pwndScrollBar) << 16);
                break;

              case VK_END:
                SendMessage (pwndInfoTxt, WM_VSCROLL, SB_BOTTOM,
                             ((DWORD) pwndScrollBar) << 16);
                break;

              case VK_PRIOR:
                SendMessage (pwndInfoTxt, WM_VSCROLL, SB_PAGEUP,
                             ((DWORD) pwndScrollBar) << 16);
                break;

              case VK_NEXT:
                SendMessage (pwndInfoTxt, WM_VSCROLL, SB_PAGEDOWN,
                             ((DWORD) pwndScrollBar) << 16);
                break;

              case VK_UP:
                SendMessage (pwndInfoTxt, WM_VSCROLL, SB_LINEUP,
                             ((DWORD) pwndScrollBar) << 16);
                break;

              case VK_DOWN:
                SendMessage (pwndInfoTxt, WM_VSCROLL, SB_LINEDOWN,
                             ((DWORD) pwndScrollBar) << 16);
                break;

            } /* End switch (wParam) */

          break;
        } /* End case WM_CHAR */

      case WM_DRAWITEM:
        {
          DrawPlateButton1 (pwnd, message, wParam, lParam);
          break;
        }

      case WM_PAINT:
        {
          NPRRC prrc;   /* Pointer to rectangle    */
          RRC rrc;      /* Entire client area      */
          RX rxX;
          RY ryY;

          /* Get the entire client area */

          GetClientRrc (pwnd, &rrc);

          /* Clear the window */

          if ((prrc = (NPRRC) LOWORD (lParam)) == NULL)
            {
              prrc = &rrc;
            }

          FillRrc (pwnd, prrc, ' ', isaInfoActive);

          /* Draw the separator line */

          for (rxX = 0, ryY = rrc.ryBottom - (RY) 3; rxX < rrc.rxRight; ++rxX)
            CharOut (pwnd, rxX, ryY, '', isaInfoActiveBorder);

          break;
        }

      default:
       return (DefWindowProc (pwnd, message, wParam, lParam));
    }

  return (0L);
}

/*********************************************************************
 * CreateInfoChildWindows - Adds the child windows to the main
 *                          "Information Provider" window
 *********************************************************************/

STATIC BOOL PASCAL CreateInfoChildWindows (PWND pwndParent)
{
  PWND pwnd = NULL;     /* Window pointer for examining window status */
  AX axLeft;            /* Left edge of window */
  AY ayTop;             /* Top edge of window  */
  WORD wWidth, wHeight; /* Width and height of window */


  /* Set the text window's coordinates */

  axLeft  = pwndParent->arcWindow.axLeft + (AX) 1;
  ayTop   = pwndParent->arcWindow.ayTop + (AX) 1;
  wHeight = pwndParent->arcWindow.ayBottom -
            pwndParent->arcWindow.ayTop - 5;
  if (fVisibleFlag == TRUE)
    wWidth  = pwndParent->arcWindow.axRight -
              pwndParent->arcWindow.axLeft - 2;
  else
    wWidth  = pwndParent->arcWindow.axRight -
              pwndParent->arcWindow.axLeft - 1;

  /**************************/
  /* Create the text window */
  /**************************/

  pwnd = (PWND) CreateWindow (InfoTxtWndCallID,
                              NULL,
                              WS_CLIPOUT,
                              WS_VISIBLE,
                              axLeft,
                              ayTop,
                              wWidth,
                              wHeight,
                              (HWND) pwndParent,
                              (HMENU) NULL,
                              NULL,
                              InfoTxtID);

  if (pwnd == NULL)
    {
      return (TRUE);
    }


  /************************/
  /* Create the OK button */
  /************************/

  axLeft  = ((pwndParent->arcWindow.axRight -
            pwndParent->arcWindow.axLeft) / (AX) 2) - (AX) (8 / 2) +
            pwndParent->arcWindow.axLeft;
  ayTop   = pwndParent->arcWindow.ayBottom - (AY) 3;
  wWidth  = 9;
  wHeight = 2;

  pwnd = (PWND) CreateWindow (WC_BUTTON,
                              "OK",
                              BS_DEFPUSHBUTTON | BS_OWNERDRAW | WS_CLIPOUT,
                              WES_3D | WES_TABSTOP,
                              axLeft,
                              ayTop,
                              wWidth,
                              wHeight,
                              (HWND) pwndParent,
                              (HMENU) NULL,
                              NULL,
                              OkButtonID);

  if (pwnd == NULL)
    {
      return (TRUE);
    }

  return (FALSE);
}

/*********************************************************************
 * InfoTxtWndProc - Procedure for handling the "Information Provider"
 *                  window.
 *********************************************************************/

STATIC LONG FAR PASCAL InfoTxtWndProc (PWND  pwnd,
                                       WORD  message,
                                       WORD  wParam,
                                       DWORD lParam)
{
  switch (message)
    {
      case WM_CREATE:
        CreateInfoTxtChildren (pwnd);
        break;

      case WM_DESTROY:
        FreeStringSpace ((QSZ *) GetWindowWord (pwnd, WEB_PQSZ_TEXT));
        break;

      case WM_VSCROLL:
        InfoTxtWndScroll (pwnd, wParam, lParam);
        break;

      case WM_PAINT:
        {
          PWND pwndScrollBar = NULL; /* Handle to the text window's scroll bar */
          RRC  rrc;           /* Entire client area                     */
          QSZ  *pqszStrings;  /* Strings to display                     */
          WORD i;             /* Looping variable                       */
          WORD u;             /* Index to pqszStrings[i]                */
          WORD wTopLine;      /* Top line of text to display            */
          WORD wLimitLine;    /* Bottom line of text to display         */
          WORD wLength;       /* String length                          */
          RY   ryCurrentLine; /* Current display line on window         */
          RX   rxCurrentPos;  /* Current position on window             */
          ISA  isaColor = isaInfoActive;  /* Current color              */


          /* Get the scroll bar's PWND */
          pwndScrollBar = GetDlgItem (pwnd, InfoScrollID);

          /* Get the entire client area */
          GetClientRrc (pwnd, &rrc);

          /* Get the pointer to the strings */
          pqszStrings = (QSZ *) GetWindowWord (pwnd, WEB_PQSZ_TEXT);

          /* Set the top line and limit line for the text */
          wTopLine   = GetScrollPos (pwndScrollBar);
          wLimitLine = wTopLine + rrc.ryBottom;

          if (wLimitLine > GetWindowWord (pwnd, WEB_NMBR_LINES) + 1)
            wLimitLine = GetWindowWord (pwnd, WEB_NMBR_LINES) + 1;

          /* Display the text */
          for (i = wTopLine, ryCurrentLine = 0; i < wLimitLine;
               ++i, ++ryCurrentLine)
            {
              wLength = Qstrlen (pqszStrings[i]);

              CharOut (pwnd, 0, ryCurrentLine, ' ', isaInfoActive);

              for (u = 0, rxCurrentPos = 1; pqszStrings[i][u] != '\0';
                   ++u, ++rxCurrentPos)
                {
                  /* Is this a control character */
                  if (pqszStrings[i][u] == '&')
                    {
                      /* && == Display '&' */
                      if (pqszStrings[i][u + 1] == '&')
                        ++u;

                      /* &# == Alternate color */
                      if (pqszStrings[i][u + 1] >= '1' &&
                          pqszStrings[i][u + 1] <= '3')
                        {
                          isaColor = isaAlternate;
                          u += 2;
                        }

                      /* &0 == Normal color */
                      if (pqszStrings[i][u + 1] == '0')
                        {
                          isaColor = isaInfoActive;
                          u += 2;
                        }

                      /* Now check to see if we are at the */
                      /*   end of the string               */
                      if (pqszStrings[i][u] == '\0')
                        break;
                    }

                  /* Display the character */
                  CharOut (pwnd, rxCurrentPos, ryCurrentLine,
                           pqszStrings[i][u], isaColor);
                }

              /* rxCurrentPos = rrc.rxLeft + (RX) wLength + (RX) 1; */

              while (rxCurrentPos < rrc.rxRight - (RX) 1)
                CharOut (pwnd, rxCurrentPos++, ryCurrentLine, ' ',
                         isaInfoActive);
            }

          /* Erase the lines below the last line, if necessary */
          if (ryCurrentLine < rrc.ryBottom)
            {
              rrc.ryTop = ryCurrentLine;
              --rrc.rxRight;
              FillRrc (pwnd, &rrc, ' ', isaInfoActive);
            }

          break;
        }

      default:
       return (DefWindowProc (pwnd, message, wParam, lParam));
    }

  return (0L);
}

/*********************************************************************
 * InfoTxtWndScroll - Handles scroll bar messages.
 *********************************************************************/

STATIC VOID InfoTxtWndScroll (PWND pwnd, WORD wParam, DWORD lParam)
{
  STATIC INT iScrollPos;    /* Position of the scroll bar */
  BOOL fRedraw = FALSE;     /* Set to TRUE if a redraw required */


  /* Get the current position */
  iScrollPos = GetScrollPos ((PWND) HIWORD (lParam));


  /* Handle requested scroll action */
  switch (wParam)
    {
      case SB_LINEUP:
        {
          /* Adjust the scroll bar's position */

          if (--iScrollPos >= (INT) GetWindowWord (pwnd, WEB_MIN_SCROLL))
            fRedraw = TRUE;
          else
            iScrollPos = GetWindowWord (pwnd, WEB_MIN_SCROLL);

          /* Set the new position for the scroll bar */

          SetScrollPos ((PWND) HIWORD (lParam), iScrollPos, fRedraw);

          break;
        }

      case SB_LINEDOWN:
        {
          /* Adjust the scroll bar's position */

          if (++iScrollPos <= (INT) GetWindowWord (pwnd, WEB_MAX_SCROLL))
            fRedraw = TRUE;
          else
            iScrollPos = GetWindowWord (pwnd, WEB_MAX_SCROLL);

          /* Set the new position for the scroll bar */

          SetScrollPos ((PWND) HIWORD (lParam), iScrollPos, fRedraw);

          break;
        }

      case SB_PAGEUP:
        {
          /* Set the flag for redraw */

          fRedraw = TRUE;

          /* Adjust the scroll bar's position */

          iScrollPos = iScrollPos -
                       GetWindowWord (pwnd, WEB_SCROLLABLE_LINES) + 1;

          if (iScrollPos < (INT) GetWindowWord (pwnd, WEB_MIN_SCROLL))
            iScrollPos = GetWindowWord (pwnd, WEB_MIN_SCROLL);

          /* Set the new position for the scroll bar */

          SetScrollPos ((PWND) HIWORD (lParam), iScrollPos, fRedraw);

          break;
        }

      case SB_PAGEDOWN:
        {
          /* Set the flag for redraw */

          fRedraw = TRUE;

          /* Adjust the scroll bar's position */

          iScrollPos = iScrollPos +
                       GetWindowWord (pwnd, WEB_SCROLLABLE_LINES) - 1;

          if (iScrollPos > (INT) GetWindowWord (pwnd, WEB_MAX_SCROLL))
            iScrollPos = GetWindowWord (pwnd, WEB_MAX_SCROLL);

          /* Set the new position for the scroll bar */

          SetScrollPos ((PWND) HIWORD (lParam), iScrollPos, fRedraw);

          break;
        }

      case SB_THUMBPOSITION:
        {
          /* Get the current position */

          iScrollPos = LOWORD (lParam);

          /* Turn on the fRedraw flag */

          fRedraw = TRUE;

          /* Set the new position for the scroll bar */

          SetScrollPos ((PWND) HIWORD (lParam), iScrollPos, fRedraw);

          break;
        }

      case SB_THUMBTRACK:
        {
          /* Get the current position */

          iScrollPos = LOWORD (lParam);

          /* Turn on the fRedraw flag */

          fRedraw = TRUE;

          /* Set the new position for the scroll bar */

          SetScrollPos ((PWND) HIWORD (lParam), iScrollPos, fRedraw);

          break;
        }

      case SB_ENDSCROLL:
        {
          /* Get the current position */

          iScrollPos = LOWORD (lParam);

          /* Turn on the fRedraw flag */

          fRedraw = TRUE;

          /* Set the new position for the scroll bar */

          SetScrollPos ((PWND) HIWORD (lParam), iScrollPos, fRedraw);

          break;
        }

      case SB_TOP:
        {
          /* Get the current position */

          iScrollPos = GetWindowWord (pwnd, WEB_MIN_SCROLL);

          /* Turn on the fRedraw flag */

          fRedraw = TRUE;

          /* Set the new position for the scroll bar */

          SetScrollPos ((PWND) HIWORD (lParam), iScrollPos, fRedraw);

          break;
        }

      case SB_BOTTOM:
        {
          /* Get the current position */

          iScrollPos = GetWindowWord (pwnd, WEB_MAX_SCROLL);

          /* Turn on the fRedraw flag */

          fRedraw = TRUE;

          /* Set the new position for the scroll bar */

          SetScrollPos ((PWND) HIWORD (lParam), iScrollPos, fRedraw);

          break;
        }
    } /* End "switch (wParam)" for WM_VSCROLL */

  /* Display the text in it's new location */

  PostMessage (pwnd, WM_PAINT, NULL, NULL);
}

/*********************************************************************
 * CreateInfoTxtChildren - Creates the scrolling text window
 *********************************************************************/

STATIC BOOL PASCAL CreateInfoTxtChildren (PWND pwndParent)
{
  PWND pwnd = NULL;     /* Window pointer for examining window status */
  AX axLeft;            /* Left edge of window */
  AY ayTop;             /* Top edge of window  */
  WORD wWidth, wHeight; /* Width and height of window */


  /********************************/
  /* Create the scroll bar window */
  /********************************/

  axLeft  = pwndParent->arcWindow.axRight - (AX) 1;
  ayTop   = pwndParent->arcWindow.ayTop;
  wWidth  = 1;
  wHeight = pwndParent->arcWindow.ayBottom -
            pwndParent->arcWindow.ayTop;

  if (wHeight < 2)
    wHeight = 2;

  pwnd = (PWND) CreateWindow (WC_SCROLLBAR,
                              NULL,
                              WS_CHILD | SBS_VERT | WS_CLIPOUT,
                              WS_VISIBLE,
                              axLeft,
                              ayTop,
                              wWidth,
                              wHeight,
                              (HWND) pwndParent,
                              (HMENU) NULL,
                              NULL,
                              InfoScrollID);

  if (pwnd == NULL)
    {
      return (TRUE);
    }
}


/*********************************************************************
 * DrawPlateButton1 - Draws a "plate" button that is 1 character high
 *                    with a half character shadow.
 *********************************************************************/

VOID DrawPlateButton1 (PWND  pwnd,
                       WORD  message,
                       WORD  wParam,
                       DWORD lParam)
{
  PWND_BTN pwndbtn;             /* Button info structure     */
  RRC rrcButton;                /* Button's relative co-ords */
  RRC rrcShadow;                /* Shadow's relative co-ords */
  DWORD dwButtonState;          /* Button's state            */
  DRAWITEMSTRUCT FAR * fpdis;   /* Pointer to struct for     */
                                /*   drawing the button      */
  WORD wCenterLoc;              /* Location to center the    */
                                /*   button's text           */

  /* Set the struct pointer */
  fpdis = (DRAWITEMSTRUCT FAR *) lParam;
  pwndbtn = (PWND_BTN) fpdis->hwndItem;

  /* Get the button and shadow sizes */
  _fmemcpy (&rrcButton, &(fpdis->rcItem), sizeof (RRC));
  _fmemcpy (&rrcShadow, &(fpdis->rcItem), sizeof (RRC));

  ++(rrcShadow.ryTop);
  --(rrcButton.ryBottom);

  /* Find the centering location */
  wCenterLoc = ((rrcButton.rxRight - 1 - rrcButton.rxLeft) / 2) -
               (strlen (pwndbtn->szDialog) / 2);

  /* Determine if the button is pushed in or not */
  dwButtonState = SendMessage (fpdis->hwndItem, BM_GETSTATE, 0, 0L);
  if (dwButtonState & 0x0004)
    {
      /* The button is pressed in */

      /* Repaint the shadow area */
      FillRrc (fpdis->hwndItem, &rrcShadow, ' ', isaInfoActive);

      CharOut (fpdis->hwndItem, 0, 0, ' ', isaInfoActive);


      /* Repaint the button face */
      ++(rrcButton.rxLeft);

      FillRrc (fpdis->hwndItem, &rrcButton, ' ', isaPushButton);

      TextOut (fpdis->hwndItem, (RY) (wCenterLoc + 1), 0,
               pwndbtn->szDialog, -1, isaPushButton);
    }
  else
    {
      /* The button is out */

      /* Repaint the button face */
      --(rrcButton.rxRight);

      FillRrc (fpdis->hwndItem, &rrcButton, ' ', isaPushButton);

      TextOut (fpdis->hwndItem, (RY) (wCenterLoc), 0,
               pwndbtn->szDialog, -1, isaPushButton);


      /* Repaint the shadow area */
      CharOut (fpdis->hwndItem, rrcShadow.rxLeft, rrcShadow.ryTop,
               ' ', isaInfoActive);

      ++(rrcShadow.rxLeft);

      FillRrc (fpdis->hwndItem, &rrcShadow, '', isaInfoActive);

      CharOut (fpdis->hwndItem, rrcButton.rxRight, 0, '',
               isaInfoActive);
    }
}

#endif /* CW_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\server.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/********************************************************************
 *								    *
 *  About this file ...  SERVER.H				    *
 *								    *
 *  This file contains information about the NetServer APIs.	    *
 *								    *
 *	Function prototypes.					    *
 *								    *
 *	Data structure templates.				    *
 *								    *
 *	Definition of special values.				    *
 *								    *
 *								    *
 *  NOTE:  You must include NETCONS.H before this file, since this  *
 *	   file	depends on values defined in NETCONS.H.		    *
 *								    *
 ********************************************************************/

#ifndef NETSERVER_INCLUDED

#define NETSERVER_INCLUDED


/****************************************************************
 *                                                              *
 *              Function prototypes                             *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetServerAdminCommand ( const char far *     pszServer,
                          const char far *     pszCommand,
                          short far *          psResult,
                          char far *           pbBuffer,
                          unsigned short       cbBuffer,
                          unsigned short far * pcbReturned,
                          unsigned short far * pcbTotalAvail );

extern API_FUNCTION
  NetServerDiskEnum ( const char far *     pszServer,
                      short                sLevel,
                      char far *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short far * pcEntriesRead,
                      unsigned short far * pcTotalAvail );

extern API_FUNCTION
  NetServerEnum ( const char far *     pszServer,
                  short                sLevel,
                  char far *           pbBuffer,
                  unsigned short       cbBuffer,
                  unsigned short far * pcEntriesRead,
                  unsigned short far * pcTotalAvail );

extern API_FUNCTION
  NetServerEnum2 ( const char far *     pszServer,
                   short                sLevel,
                   char far *           pbBuffer,
                   unsigned short       cbBuffer,
                   unsigned short far * pcEntriesRead,
                   unsigned short far * pcTotalAvail,
                   unsigned long        flServerType,
                   char far *           pszDomain );

extern API_FUNCTION
  NetServerGetInfo ( const char far *     pszServer,
                     short                sLevel,
                     char far *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short far * pcbTotalAvail );

extern API_FUNCTION
  NetServerSetInfo ( const char far * pszServer,
                     short            sLevel,
                     const char far * pbBuffer,
                     unsigned short   cbBuffer,
                     short            sParmNum );


/****************************************************************
 *								*
 *	  	Data structure templates			*
 *								*
 ****************************************************************/

struct server_info_0 {
    char	    sv0_name[CNLEN + 1]; 	/* Server name		    */
};	 /* server_info_0 */


struct server_info_1 {
    char	    sv1_name[CNLEN + 1];
    unsigned char   sv1_version_major;		/* Major version # of net   */
    unsigned char   sv1_version_minor;		/* Minor version # of net   */
    unsigned long   sv1_type;	     		/* Server type 		    */
    char far *	    sv1_comment; 		/* Exported server comment  */
};	 /* server_info_1 */


struct server_info_2 {
    char            sv2_name[CNLEN + 1];
    unsigned char   sv2_version_major;
    unsigned char   sv2_version_minor;
    unsigned long   sv2_type;	
    char far *	    sv2_comment;		
    unsigned long   sv2_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv2_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv2_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv2_users;       /* max number of users allowed          */
    unsigned short  sv2_disc;	    /* auto-disconnect timeout(in minutes)  */
    char far *	    sv2_alerts;	    /* alert names (semicolon separated)    */
    unsigned short  sv2_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv2_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv2_numadmin;    /* max number of administrators allowed */
    unsigned short  sv2_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv2_hidden;      /* 0 = visible; nonzero = hidden        */
    unsigned short  sv2_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv2_anndelta;    /* announce randomize interval (sec)    */
                                    /* name of guest account                */
    char            sv2_guestacct[UNLEN + 1];
    unsigned char   sv2_pad1;	    /* Word alignment pad byte		    */
    char far *      sv2_userpath;    /* ASCIIZ path to user directories      */
    unsigned short  sv2_chdevs;      /* max # shared character devices       */
    unsigned short  sv2_chdevq;      /* max # character device queues        */
    unsigned short  sv2_chdevjobs;   /* max # character device jobs          */
    unsigned short  sv2_connections; /* max # of connections		    */
    unsigned short  sv2_shares;	    /* max # of shares			    */
    unsigned short  sv2_openfiles;   /* max # of open files		    */
    unsigned short  sv2_sessopens;   /* max # of open files per session	    */
    unsigned short  sv2_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv2_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv2_opensearch;  /* max # of open searches		    */
    unsigned short  sv2_activelocks; /* max # of active file locks           */
    unsigned short  sv2_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv2_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv2_numbigbuf;   /* number of big (64K) buffers          */
    unsigned short  sv2_numfiletasks;/* number of file worker processes      */
    unsigned short  sv2_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv2_erroralert;  /* error log alerting threshold         */
    unsigned short  sv2_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv2_accessalert; /* access violation alerting threshold  */
    unsigned short  sv2_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv2_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv2_maxauditsz;  /* Maximum audit file size (KB)        */
    char far *	    sv2_srvheuristics; /* performance related server switches*/
};	/* server_info_2 */


struct server_info_3 {
    char	    sv3_name[CNLEN + 1];
    unsigned char   sv3_version_major;
    unsigned char   sv3_version_minor;
    unsigned long   sv3_type;
    char far *	    sv3_comment;
    unsigned long   sv3_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv3_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv3_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv3_users;	     /* max number of users allowed	     */
    unsigned short  sv3_disc;	    /* auto-disconnect timeout(in minutes)  */
    char far *	    sv3_alerts;     /* alert names (semicolon separated)    */
    unsigned short  sv3_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv3_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv3_numadmin;    /* max number of administrators allowed */
    unsigned short  sv3_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv3_hidden;      /* 0 = visible; nonzero = hidden	     */
    unsigned short  sv3_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv3_anndelta;    /* announce randomize interval (sec)    */
				    /* name of guest account		    */
    char	    sv3_guestacct[UNLEN + 1];
    unsigned char   sv3_pad1;	    /* Word alignment pad byte		    */
    char far *	    sv3_userpath;    /* ASCIIZ path to user directories	     */
    unsigned short  sv3_chdevs;      /* max # shared character devices	     */
    unsigned short  sv3_chdevq;      /* max # character device queues	     */
    unsigned short  sv3_chdevjobs;   /* max # character device jobs	     */
    unsigned short  sv3_connections; /* max # of connections		    */
    unsigned short  sv3_shares;     /* max # of shares			    */
    unsigned short  sv3_openfiles;   /* max # of open files		    */
    unsigned short  sv3_sessopens;   /* max # of open files per session     */
    unsigned short  sv3_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv3_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv3_opensearch;  /* max # of open searches		    */
    unsigned short  sv3_activelocks; /* max # of active file locks	     */
    unsigned short  sv3_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv3_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv3_numbigbuf;   /* number of big (64K) buffers	     */
    unsigned short  sv3_numfiletasks;/* number of file worker processes      */
    unsigned short  sv3_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv3_erroralert;  /* error log alerting threshold	     */
    unsigned short  sv3_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv3_accessalert; /* access violation alerting threshold  */
    unsigned short  sv3_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv3_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv3_maxauditsz;  /* Maximum audit file size (KB)	     */
    char far *	    sv3_srvheuristics; /* performance related server switches*/
    unsigned long   sv3_auditedevents; /* Audit event control mask	     */
    unsigned short  sv3_autoprofile; /* (0,1,2,3) = (NONE,LOAD,SAVE,or BOTH) */
    char far *	    sv3_autopath;    /* file pathname (where to load & save) */
};	/* server_info_3 */



/****************************************************************
 *								*
 *	  	Special values and constants			*
 *								*
 ****************************************************************/

/*
 *	Mask to be applied to svX_version_major in order to obtain
 *	the major version number.
 */

#define MAJOR_VERSION_MASK	0x0F

/*
 *	Bit-mapped values for svX_type fields. X = 1, 2 or 3.
 */

#define SV_TYPE_WORKSTATION	0x00000001
#define SV_TYPE_SERVER		0x00000002
#define SV_TYPE_SQLSERVER	0x00000004
#define SV_TYPE_DOMAIN_CTRL	0x00000008
#define SV_TYPE_DOMAIN_BAKCTRL	0x00000010
#define SV_TYPE_TIME_SOURCE	0x00000020
#define SV_TYPE_AFP		0x00000040
#define SV_TYPE_NOVELL		0x00000080
#define SV_TYPE_ALL		0xFFFFFFFF   /* handy for NetServerEnum2 */

/*
 *	Special value for svX_disc that specifies infinite disconnect
 *	time. X = 2 or 3.
 */

#define SV_NODISC		0xFFFF	/* No autodisconnect timeout enforced */

/*
 *	Values of svX_security field. X = 2 or 3.
 */

#define SV_USERSECURITY		1
#define SV_SHARESECURITY	0

/*
 *	Values of svX_hidden field. X = 2 or 3.
 */

#define SV_HIDDEN		1
#define SV_VISIBLE		0

/*
 *	Values for parmnum parameter to NetServerSetInfo.
 */

#define SV_COMMENT_PARMNUM	5
#define SV_DISC_PARMNUM 	10
#define SV_ALERTS_PARMNUM	11
#define SV_HIDDEN_PARMNUM	16
#define SV_ANNOUNCE_PARMNUM	17
#define SV_ANNDELTA_PARMNUM	18
#define SV_ALERTSCHED_PARMNUM	37
#define SV_ERRORALERT_PARMNUM	38
#define SV_LOGONALERT_PARMNUM	39
#define SV_ACCESSALERT_PARMNUM	40
#define SV_DISKALERT_PARMNUM	41
#define SV_NETIOALERT_PARMNUM	42
#define SV_MAXAUDITSZ_PARMNUM	43

#define SVI1_NUM_ELEMENTS	5
#define SVI2_NUM_ELEMENTS	44
#define SVI3_NUM_ELEMENTS	45

/*
 *	Maxmimum length for command string to NetServerAdminCommand.
 */

#define	SV_MAX_CMD_LEN		PATHLEN



/*
 *      Masks describing AUTOPROFILE parameters
 */

#define SW_AUTOPROF_LOAD_MASK	0x1
#define SW_AUTOPROF_SAVE_MASK	0x2


#endif /* NETSERVER_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\service.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/********************************************************************
 *								    *
 *  About this file ...  SERVICE.H 				    *
 *								    *
 *  This file contains information about the NetService APIs.	    *
 *								    *
 *	Function prototypes.					    *
 *								    *
 *	Data structure templates.				    *
 *								    *
 *	Definition of special values.				    *
 *								    *
 *								    *
 *  NOTE:  You must include NETCONS.H before this file, since this  *
 *	   file	depends on values defined in NETCONS.H.		    *
 *								    *
 ********************************************************************/

#ifndef NETSERVICE_INCLUDED

#define NETSERVICE_INCLUDED

/****************************************************************
 *                                                              *
 *              Function prototypes                             *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetServiceControl ( const char far * pszServer,
                      const char far * pszService,
                      unsigned char    fbOpCode,
                      unsigned char    fbArg,
                      char far *       pbBuffer,
                      unsigned short   cbBuffer );

extern API_FUNCTION
  NetServiceEnum ( const char far *     pszServer,
                   short                sLevel,
                   char far *           pbBuffer,
                   unsigned short       cbBuffer,
                   unsigned short far * pcEntriesRead,
                   unsigned short far * pcTotalAvail );

extern API_FUNCTION
  NetServiceGetInfo ( const char far *     pszServer,
                      const char far *     pszService,
                      short                sLevel,
                      char far *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short far * pcbTotalAvail );

extern API_FUNCTION
  NetServiceInstall ( const char far * pszServer,
                      const char far * pszService,
                      const char far * pszCmdArgs,
                      char far *       pbBuffer,
                      unsigned short   cbBuffer );

extern API_FUNCTION
  NetServiceStatus ( const char far * pbBuffer,
                     unsigned short   cbBuffer );



/****************************************************************
 *								*
 *	  	Data structure templates			*
 *								*
 ****************************************************************/


struct service_info_0 {
    char 	    svci0_name[SNLEN+1];
};	/* service_info_0 */

struct service_info_1 {
    char 	    svci1_name[SNLEN+1];  /* service name 			*/
    unsigned short  svci1_status;	       /* See status values below 	*/
    unsigned long   svci1_code;	       /* install code of service	*/
    unsigned short  svci1_pid;	       /* pid of service program	*/
};	/* service_info_1 */

struct service_info_2 {
    char 	    svci2_name[SNLEN+1];  /* service name 			*/
    unsigned short  svci2_status;	       /* See status values below 	*/
    unsigned long   svci2_code;	       /* install code of service	*/
    unsigned short  svci2_pid;	       /* pid of service program	*/
    char	    svci2_text[STXTLEN+1];   /* text area for use by services */
};	/* service_info_2 */

struct service_status {
    unsigned short  svcs_status;	       /* See status values below 	*/
    unsigned long   svcs_code;	       /* install code of service	*/
    unsigned short  svcs_pid;	       /* pid of service program	*/
    char	    svcs_text[STXTLEN+1];   /* text area for use by services */
};	/* service_status */



/****************************************************************
 *								*
 *	  	Special values and constants			*
 *								*
 ****************************************************************/

/*
 *	SERVICE_RCV_SIG_FLAG is the value passed to DosSetSigHandler when
 *	installing the handler within a service, to receive control
 *	signals.
 */

#define SERVICE_RCV_SIG_FLAG 5

/*
 *	Bitmask and bit values for svci1_status, svci2_status, and
 *	svcs_status fields.  For each "subfield", there is a mask
 *	defined, and a number of constants representing the value
 *	obtained by doing (status & mask).
 */

/* Bits 0,1 -- general status */

#define SERVICE_INSTALL_STATE  		0x03
#define	SERVICE_UNINSTALLED 		0x00
#define	SERVICE_INSTALL_PENDING		0x01
#define	SERVICE_UNINSTALL_PENDING	0x02
#define	SERVICE_INSTALLED		0x03

/* Bits 2,3 -- paused/active status */

#define SERVICE_PAUSE_STATE  		0x0C
#define SERVICE_ACTIVE			0x00
#define	SERVICE_CONTINUE_PENDING	0x04
#define SERVICE_PAUSE_PENDING		0x08
#define SERVICE_PAUSED			0x0C

/* Bit 4 -- uninstallable indication */

#define SERVICE_NOT_UNINSTALLABLE	0x00
#define SERVICE_UNINSTALLABLE		0x10

/* Bit 5 -- pausable indication */

#define SERVICE_NOT_PAUSABLE		0x00
#define SERVICE_PAUSABLE		0x20

/* Workstation service only:
 * Bits 8,9,10 -- redirection paused/active */

#define SERVICE_REDIR_PAUSED		0x700
#define SERVICE_REDIR_DISK_PAUSED	0x100
#define SERVICE_REDIR_PRINT_PAUSED	0x200
#define SERVICE_REDIR_COMM_PAUSED	0x400

/*
 *	Standard LAN Manager service names.
 */

#define SERVICE_WORKSTATION	"WORKSTATION"
#define SERVICE_SERVER		"SERVER"
#define SERVICE_MESSENGER	"MESSENGER"
#define SERVICE_NETRUN	 	"NETRUN"
#define SERVICE_SPOOLER		"SPOOLER"
#define SERVICE_ALERTER 	"ALERTER"
#define SERVICE_NETLOGON 	"NETLOGON"
#define SERVICE_NETPOPUP	"NETPOPUP"
#define SERVICE_SQLSERVER	"SQLSERVER"
#define SERVICE_REPL		"REPLICATOR"
#define SERVICE_RIPL		"REMOTEBOOT"
#define SERVICE_TIMESOURCE	"TIMESOURCE"
#define SERVICE_AFP		"AFP"
#define SERVICE_UPS		"UPS"

/*
 *	Additional standard LAN Manager for MS-DOS services
 */

#define	SERVICE_DOS_ENCRYPTION	"ENCRYPT"


/*
 *	NetServiceControl opcodes.
 */

#define SERVICE_CTRL_INTERROGATE	0
#define SERVICE_CTRL_PAUSE		1
#define SERVICE_CTRL_CONTINUE		2
#define SERVICE_CTRL_UNINSTALL		3

/*
 *	Workstation service only:  Bits used in the "arg" parameter
 *	to NetServiceControl in conjunction with the opcode
 *	SERVICE_CTRL_PAUSE or SERVICE_CTRL_CONTINUE, to pause or
 *	continue redirection.
 */

#define SERVICE_CTRL_REDIR_DISK		0x1
#define SERVICE_CTRL_REDIR_PRINT	0x2
#define SERVICE_CTRL_REDIR_COMM		0x4


/*
 *	Values for svci1_code, svci2_code, and svcs_code when
 *	status of the service is SERVICE_INSTALL_PENDING or
 *	SERVICE_UNINSTALL_PENDING.
 *	A service can optionally provide a hint to the installer
 *	that the install is proceeding and how long to wait
 *	(in 0.1 second increments) before querying status again.
 */

#define SERVICE_IP_NO_HINT		0x0
#define SERVICE_CCP_NO_HINT		0x0

#define SERVICE_IP_QUERY_HINT		0x10000
#define SERVICE_CCP_QUERY_HINT		0x10000

	/* Mask for install proceeding checkpoint number */
#define SERVICE_IP_CHKPT_NUM		0x0FF
#define SERVICE_CCP_CHKPT_NUM		0x0FF

	/* Mask for wait time hint before querying again */
#define SERVICE_IP_WAIT_TIME		0x0FF00
#define SERVICE_CCP_WAIT_TIME		0x0FF00

	/* Shift count for building wait time _code values */
#define SERVICE_IP_WAITTIME_SHIFT	8



#define SERVICE_IP_CODE(tt,nn) \
  ((long)SERVICE_IP_QUERY_HINT|(long)(nn|(tt<<SERVICE_IP_WAITTIME_SHIFT)))

#define SERVICE_CCP_CODE(tt,nn) \
  ((long)SERVICE_CCP_QUERY_HINT|(long)(nn|(tt<<SERVICE_IP_WAITTIME_SHIFT)))

#define SERVICE_UIC_CODE(cc,mm) \
  ((long)(((long)cc<<16)|(long)(unsigned)mm))

/***	SERVICE_BASE is the base of service error codes,
 *	chosen to avoid conflict with OS, redirector,
 *	netapi, and errlog codes.
 */

#define SERVICE_BASE	3050




/*  Uninstall codes, to be used in high byte of 'code' on final NetStatus,
 *  which sets the status to UNINSTALLED
 */

#define SERVICE_UIC_NORMAL	0
#define SERVICE_UIC_BADPARMVAL	(SERVICE_BASE + 1) \
        /* LANMAN.INI or the command line has an illegal value for "%1". */
        /* A LANMAN.INI entry or what you just typed includes an illegal value for "%1". */
#define SERVICE_UIC_MISSPARM	(SERVICE_BASE + 2) \
        /* The required parameter %1 was not provided on the command line or in LANMAN.INI. */
#define SERVICE_UIC_UNKPARM	(SERVICE_BASE + 3) \
        /* LAN Manager doesn't recognize "%1" as a valid option.  */
#define SERVICE_UIC_RESOURCE	(SERVICE_BASE + 4) /* A request for %1 resources could not be satisfied. */
#define SERVICE_UIC_CONFIG	(SERVICE_BASE + 5) /* A problem exists with the system configuration:  %1. */
#define SERVICE_UIC_SYSTEM	(SERVICE_BASE + 6) /* A system error has occurred. */
#define SERVICE_UIC_INTERNAL	(SERVICE_BASE + 7) /* An internal consistency error has occurred. */
#define SERVICE_UIC_AMBIGPARM	(SERVICE_BASE + 8) \
        /* LANMAN.INI or the command line has an ambiguous option: %1. */
#define SERVICE_UIC_DUPPARM	(SERVICE_BASE + 9) \
        /* LANMAN.INI or the command line has a duplicate parameter: %1. */
#define SERVICE_UIC_KILL	(SERVICE_BASE + 10) \
        /* The service did not respond to control and was stopped with the DosKillProc function.*/
#define SERVICE_UIC_EXEC	(SERVICE_BASE + 11) \
	/* An error occurred when attempting to run the service program. */
#define SERVICE_UIC_SUBSERV	(SERVICE_BASE + 12) \
	/* The sub-service %1 failed to start. */
#define SERVICE_UIC_CONFLPARM   (SERVICE_BASE + 13) \
	/* There is a conflict in the value or use of these options: %1 */
#define SERVICE_UIC_FILE	(SERVICE_BASE + 14) \
	/* There is a problem with the file %1.  %2*/


/***
 *	The modifiers
 */

/*  General: */
#define SERVICE_UIC_M_NULL	0

/*  BADPARMVAL:  A text string in service_info_2.text */
/*  MISSPARM:  ditto */
/*  UNKPARM:  ditto */
/*  AMBIGPARM:  ditto */
/*  DUPPARM:  ditto */
/*  SUBSERV:  ditto */

/*  RESOURCE: */
#define SERVICE_UIC_M_MEMORY	(SERVICE_BASE + 20) /* @I
	*memory%0 */
#define SERVICE_UIC_M_DISK	(SERVICE_BASE + 21) /* @I
	*disk space%0 */
#define SERVICE_UIC_M_THREADS	(SERVICE_BASE + 22) /* @I
	*thread%0 */
#define SERVICE_UIC_M_PROCESSES	(SERVICE_BASE + 23) /* @I
	*process%0 */

/*  CONFIG: */
#define SERVICE_UIC_M_SECURITY	(SERVICE_BASE + 24) /* @I
	*Security failure%0 */

#define SERVICE_UIC_M_LANROOT	(SERVICE_BASE + 25) /* @I
	*Bad or missing LAN Manager root directory%0 */
#define SERVICE_UIC_M_REDIR	(SERVICE_BASE + 26) /* @I
	*The network software is not installed%0 */
#define SERVICE_UIC_M_SERVER	(SERVICE_BASE + 27) /* @I
	*The server is not started%0 */
#define SERVICE_UIC_M_SEC_FILE_ERR (SERVICE_BASE + 28) /* @I
	*The server cannot access the user accounts database (NET.ACC)%0 */
#define SERVICE_UIC_M_FILES	(SERVICE_BASE + 29) /* @I
	*There are incompatible files installed in the LANMAN tree%0 */
#define SERVICE_UIC_M_LOGS	(SERVICE_BASE + 30) /* @I
	*The LANMAN\LOGS directory is invalid%0 */
#define SERVICE_UIC_M_LANGROUP	(SERVICE_BASE + 31) /* @I
	*The domain specified could not be used%0 */
#define SERVICE_UIC_M_MSGNAME	(SERVICE_BASE + 32) /* @I
	*The computername is being used as a message alias on another computer%0 */
#define SERVICE_UIC_M_ANNOUNCE	(SERVICE_BASE + 33) /* @I
	*The announcement of the server name failed%0 */
#define SERVICE_UIC_M_UAS 	(SERVICE_BASE + 34) /* @I
	*The user accounts system isn't configured correctly%0 */
#define SERVICE_UIC_M_SERVER_SEC_ERR (SERVICE_BASE + 35) /* @I
	*The server isn't running with user-level security%0 */
#define SERVICE_UIC_M_WKSTA	(SERVICE_BASE + 37) /* @I
	*The workstation is not configured appropriately%0 */
#define SERVICE_UIC_M_ERRLOG	(SERVICE_BASE + 38) /* @I
	*View your error log for details%0 */
#define SERVICE_UIC_M_FILE_UW	(SERVICE_BASE + 39) /* @I
	*Unable to write to this file%0 */
#define SERVICE_UIC_M_ADDPAK	(SERVICE_BASE + 40) /* @I
	*ADDPAK file is corrupt.  Delete LANMAN\NETPROG\ADDPAK.SER and reapply all ADDPAKs%0 */
#define SERVICE_UIC_M_LAZY	(SERVICE_BASE + 41) \
	/* The LM386 server cannot be started because CACHE.EXE is not running%0 */


/* SYSTEM:  A DOS or NET error number */
/* INTERNAL:  None */
/* KILL:  None */
/* EXEC:  None */

/***
 *	End modifiers
 */



#endif /* NETSERVICE_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\suminfo.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * SUMINFO.C - Source file for obtaining summary information.
 ********************************************************************/


/* Include Files */

#include "msd.h"


/*********************************************************************
 * GetSummaryInfo - Gets the summary information.
 *
 * pSum         - Pointer to network information structure.
 * fMinimumInfo - TRUE if minimum info is requested.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetSummaryInfo (SUMMARY_STRUCT *pSum, BOOL fMinimumInfo)
{
  BOOL fReturnValue = FALSE;  /* Return value from various GetInfo calls */
  WORD wSize;                 /* Size, in bytes, to store the data       */
  WORD i;                     /* Looping variable                        */
  VOID *pStructForInfo = NULL;/* Pointer to a generic struct             */
  QSZ  *pqszStrings = NULL;   /* String array pointer                    */


  /* There is no minimum info from this routine */
  if (fMinimumInfo)
    return (FALSE);


  /* Zero out the summary info structure */
  memset (pSum, '\0', sizeof (SUMMARY_STRUCT));


  /* Fill the structures with the information */

  for (i = IDI_FIRST_RECORD_TO_SUMMARIZE;
       i <= IDI_LAST_RECORD_TO_SUMMARIZE;
       ++i)
    {
      /* Skip out if /I was used and this item is not available */
      if (fFastStart && rgfReportItemFlag[i] == FALSE)
        continue;

      /* Obtain the info structure's size */
      wSize = GetInfoSize (rwRecordTypes[i], FALSE);

      if (wSize == 0)
        {
          fReturnValue = TRUE;
          break;
        }

      /* Allocate enough room for the info structure */
      pStructForInfo = malloc (wSize);

      if (pStructForInfo == NULL)
        {
          CHAR chBuffer[80];
          sprintf (chBuffer, "After IDI_ %d", i);
          OutOfMemory();
          fReturnValue = TRUE;
          break;
        }

      /* Zero out the structure */
      memset (pStructForInfo, '\0', wSize);

      /* Fill the structure with the information */
      fReturnValue = GetInfo (rwRecordTypes[i],
                              pStructForInfo,
                              TRUE,   /* Obtain minimum info          */
                              FALSE,  /* No header record             */
                              TRUE);  /* Assume we're doing a report  */

      if (fReturnValue)
        {
          free (pStructForInfo);
          continue;
        }

      /* Obtain the summary strings */
      pqszStrings = SprintInfo (rwRecordTypes[i],
                                pStructForInfo,
                                &(pSum->szSumStrings[i * 2]),
                                TRUE);

      /* Free up the memory allocated for the summary info */
      free (pStructForInfo);
    }

  return (FALSE);
}


/*********************************************************************
 * SprintSummaryInfo - Put summary information into a set of strings
 *                     to be printed or displayed.
 *
 * fMemoryType - Type(s) of memory to put into strings (MEM_ALL to
 *               show all types of memory).
 * pMem        - Pointer to the structure describing the memory types.
 *********************************************************************/

QSZ * SprintSummaryInfo (PSZ paszButtonNames[], SUMMARY_STRUCT *pSum)
{
  WORD wNmbrStrings;        /* Number of strings                     */
  WORD wNmbrChars;          /* Number of characters in the strings   */
  WORD i, i1;               /* Index variables                       */
  CHAR chBuffer[80];        /* Local string                          */
  QSZ  *pqszStrings = NULL; /* Location for storing string pointers  */
  WORD wLongestLine = 0;    /* Longest line of summary information   */
  WORD wLength;             /* Length of a string                    */


  /* Determine the longest string of summary information */
  for (i = IDI_FIRST_RECORD_TO_SUMMARIZE; i <= IDI_LAST_RECORD_TO_SUMMARIZE; ++i)
    {
      wLength = strlen (pSum->szSumStrings[i * 2]) + 2 +
                strlen (pSum->szSumStrings[i * 2 + 1]);

      if (wLongestLine < wLength)
        wLongestLine = wLength;
    }


  /* Overestimate the amount of space required for the strings */

  wNmbrStrings = IDI_LAST_RECORD_TO_SUMMARIZE -
                 IDI_FIRST_RECORD_TO_SUMMARIZE + 2;
  wNmbrChars   = (wLongestLine + SUMMARY_ALIGN + 1) * wNmbrStrings;

  /* Allocate space for the pointer area and string area */
  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);


  /* Put the information in place */

  for (i = 0, i1 = IDI_FIRST_RECORD_TO_SUMMARIZE;
       i1 <= IDI_LAST_RECORD_TO_SUMMARIZE;
       ++i, ++i1)
    {
      /* Button name */
      sprintf (chBuffer, "%s: ", paszButtonNames[i1]);
      QstrcpyAlign (pqszStrings[i], chBuffer, SUMMARY_ALIGN);


      /* Summary Strings */
      Qstrcat (pqszStrings[i], pSum->szSumStrings[i1 * 2]);
      if (pSum->szSumStrings[i1 * 2 + 1][0] != '\0')
        {
          wLength = Qstrlen (pqszStrings[i]);

          if (i1 != IDI_DISK_DRIVE_RECORD &&
              pqszStrings[i][wLength - 2] != ',')
            Qstrcat (pqszStrings[i], pszCommaSpace);

          Qstrcat (pqszStrings[i], pSum->szSumStrings[i1 * 2 + 1]);
        }

      PrepNextString (pqszStrings, i);
    }


  /* Set the last pointer to NULL */

  pqszStrings[i] = NULL;

  /* Return the pointer to pqszStrings */

  return (pqszStrings);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\tsrlist.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * TSRLIST.C - TSR Program detection routines.
 *********************************************************************/


/* Include Files */

#include "msd.h"


/* Made global to this file.  This prevents filling the structure with */
/*   more TSR info than was previously allocated (on the extremely odd */
/*   case of finding more TSRs when we actually get the driver info    */
/*   than when we counted up how many there were.  Under multitasking  */
/*   systems, the addition of a new TSR installing while this program  */
/*   is running is a rare, though potential, possibility.              */

WORD wTsrCount = 0;        /* The number of TSRs installed in memory */


/*********************************************************************
 * GetTsrInfoSize - Gets number of bytes required to store the data
 *                  about the TSRs installed in the system.
 *
 * Returns:  The bytes required for the structure.
 *********************************************************************/

WORD GetTsrInfoSize (VOID)
{
  CHAR FAR * fpMcbHeader    = NULL;   /* Pointer to the MCB header         */
  CHAR FAR * fpDeviceMemory = NULL;   /* Pointer into device driver memory */
  DWORD      dwNextDeviceMemory = 0;  /* Pointer into next device driver   */
                                      /*   memory                          */
  DWORD      dwNextMcbHeader = 0;     /* Pointer to next MCB header        */
  WORD FAR * fwWordPointer  = NULL;   /* WORD pointer to obtain WORD data  */
                                      /*   from the MCB.                   */
  WORD wMcbParagraphs = 0;            /* Size of the MCB in paragraphs     */
  BOOL fEndOfList = FALSE;            /* TRUE when last MCB accounted for  */


  /* Zero out the TSR count */
  wTsrCount = 0;

  /* Add the UMB chain to the DOS MCB chain */
  LinkUmbToDosChain (TRUE);

  /* Point to the first MCB */

  fpMcbHeader = FindFirstMcbHeader();

  /* Count MCBs until the MCB type is 'Z'  */
  /*   ('Z' signifies the end of the list) */

  while (fEndOfList == FALSE)
    {
      ++wTsrCount;

      /* Get the size of the MCB */

      fwWordPointer  = (WORD FAR *) (fpMcbHeader + 1);
      wMcbParagraphs = fwWordPointer[1];

      /* Determine if this was the last MCB */

      if (*fpMcbHeader == 'Z')
        fEndOfList = TRUE;
      else
        {
          /* Determine if there are device drivers in this list */
          if (wDosMajor >= 4 && wDosMajor < 10 &&
              fpMcbHeader[8] == 'S' && fpMcbHeader[9] == 'D')
            {
              fpDeviceMemory = (CHAR FAR *)
                             ((((DWORD) FP_SEG (fpMcbHeader) + 1) << 16) + 0);

              /* Is this a valid DOS data area subsegment control block */
              while (strchr ("DEIFXCBLS", fpDeviceMemory[0]))
                {
                  /* If this is one we are interested in, */
                  /*   bump the TSR count                 */
                  /* if (fpDeviceMemory[0] == 'D' || fpDeviceMemory[0] == 'I') */
                    ++wTsrCount;

                  /* Point to the next device */
                  fwWordPointer      = (WORD FAR *) (fpDeviceMemory + 1);
                  dwNextDeviceMemory = *fwWordPointer;
                  fwWordPointer      = (WORD FAR *) (fpDeviceMemory + 3);
                  dwNextDeviceMemory += *fwWordPointer;
                  fpDeviceMemory     = (CHAR FAR *) (dwNextDeviceMemory << 16);
                }
            }

          /* Point to the next MCB */
          dwNextMcbHeader = (DWORD) fpMcbHeader +
                            ((DWORD) (wMcbParagraphs + 1) << 16);
          fpMcbHeader     = (CHAR FAR *) dwNextMcbHeader;
        }
    }

  /* Account for the zeroed out TSR record at the end of the struct */
  ++wTsrCount;

  /* Set the UMB/DOS MCB chain back to normal */
  LinkUmbToDosChain (FALSE);

  /* Return the number of bytes required to store the structure */
  return (wTsrCount * sizeof (TSR_PROGRAMS_STRUCT));
}


/*********************************************************************
 * GetTsrInfo - Fills the TSR_PROGRAMS_STRUCT with information about
 *              the TSR programs installed in the system.
 *
 * Returns:  The bytes required for the structure.
 *********************************************************************/

BOOL GetTsrInfo (TSR_PROGRAMS_STRUCT *pTsrStruct, BOOL fMinimumInfo)
{
  CHAR FAR * fpMcbHeader     = NULL;  /* Pointer to the MCB header         */
  DWORD      dwNextMcbHeader = 0;     /* Pointer to next MCB header        */
  CHAR FAR * fpPspAddress    = NULL;  /* Address of the MCB's PSP          */
  CHAR FAR * fpParentPspAddress = NULL; /* Address of parent's PSP         */
  CHAR FAR * fpTsrName       = NULL;  /* Points to TSR program's name      */
                                      /*   environment (for program name)  */
  CHAR FAR * fpCommandLine   = NULL;  /* Command line parameters           */
  WORD wMcbParagraphs        = 0;     /* Size of the MCB in paragraphs     */

  CHAR FAR * fpDeviceMemory  = NULL;  /* Pointer into device driver subMCB */
  CHAR FAR * fpDeviceStruct  = NULL;  /* Pointer to device driver itself   */
  DWORD      dwNextDeviceMemory = 0;  /* Pointer into next device driver   */
                                      /*   memory                          */
  WORD FAR * fwWordPointer   = NULL;  /* WORD pointer to obtain WORD data  */
                                      /*   from the MCB.                   */
  WORD i = 0;                         /* Looping variable                  */
  WORD wIndex;                        /* Index to structure                */
  BOOL fEndOfList = FALSE;            /* TRUE when last MCB accounted for  */
  WORD wCharCount = 0;                /* Number of characters in the       */
                                      /*   command line.                   */


  /* There is no minimum info to return from this routine */

  if (fMinimumInfo)
    return (FALSE);


  /* Add the UMB chain to the DOS MCB chain */
  LinkUmbToDosChain (TRUE);

  /* Point to the first MCB */
  fpMcbHeader = FindFirstMcbHeader();

  /* Count MCBs until the MCB type is 'Z'  */
  /*   ('Z' signifies the end of the list) */

  for (wIndex = 0; wIndex < wTsrCount - 1 && fEndOfList == FALSE; ++wIndex)
    {
      /* Store the address of the MCB */

      pTsrStruct[wIndex].wAddress = FP_SEG (fpMcbHeader);


      /* Get the size of the MCB */

      fwWordPointer  = (WORD FAR *) (fpMcbHeader + 1);
      wMcbParagraphs = fwWordPointer[1];

      pTsrStruct[wIndex].dwBlockSize = (DWORD) wMcbParagraphs << 4;

      /* Caluclate PSP and parent's PSP */

      fpPspAddress  = (CHAR FAR *) ((DWORD) fwWordPointer[0] << 16);
      fwWordPointer = (WORD FAR *) (fpPspAddress + 16);
      fpParentPspAddress = (CHAR FAR *) ((DWORD) *fwWordPointer << 16);


      /* Get the MCB's Owner's name */

      /* If the PSP Segment is 0000H it's free,     */
      /*   if it's 0008H, it's the DOS System Area. */

      if (FP_SEG (fpPspAddress) == 0x0000)
        {
          strcpy (pTsrStruct[wIndex].szTsrName, pszFreeMemory);
          pTsrStruct[wIndex].szParameters[0] = '\0';
        }
      else if (FP_SEG (fpPspAddress) == 0x0008)
        {
          /* Determine if it is the device driver area, etc */

          if (wDosMajor >= 4 && wDosMajor < 10)
            {
              /* "SC" is System Code / Locked out UMBs */
              if (wDosMajor >= 5 &&
                  fpMcbHeader[8] == 'S' && fpMcbHeader[9] == 'C')
                {
                  /* If the address + block size > A0000, it's */
                  /*   a locked out region.                    */

                  if (((DWORD) (pTsrStruct[wIndex].wAddress) << 4) +
                      pTsrStruct[wIndex].dwBlockSize > 0xA0000)
                    strcpy (pTsrStruct[wIndex].szTsrName, pszExcludedUmbArea);
                  else
                    strcpy (pTsrStruct[wIndex].szTsrName, pszDosSystemCode);
                  pTsrStruct[wIndex].szParameters[0] = '\0';
                }
              /* "SD" is System Data / Device Drivers, etc */
              else if (wDosMajor == 4 || (wDosMajor >= 5 &&
                       fpMcbHeader[8] == 'S' && fpMcbHeader[9] == 'D'))
                {
                  strcpy (pTsrStruct[wIndex].szTsrName, pszDosSystemData);
                  pTsrStruct[wIndex].szParameters[0] = '\0';

                  fpDeviceMemory = (CHAR FAR *)
                                 ((((DWORD) FP_SEG (fpMcbHeader) + 1) << 16) + 0);

                  /* Is this a valid DOS data area subsegment control block */
                  for (++wIndex;
                       strchr ("DEIFXCBLS", fpDeviceMemory[0]) &&
                       wIndex < wTsrCount - 1 && fEndOfList == FALSE;
                       ++wIndex)
                    {
                      pTsrStruct[wIndex].szParameters[0] = '\0';

                      switch (fpDeviceMemory[0])
                        {
                          case 'D':
                          case 'I':
                            /* If this is a device driver or installable */
                            /*   file system, put the device name and    */
                            /*   device filename into the structure.     */

                            /* Address */
                            fwWordPointer = (WORD FAR *) (fpDeviceMemory + 1);
                            pTsrStruct[wIndex].wAddress = *fwWordPointer;

                            /* Point to the Device Name */
                            fpDeviceStruct = (CHAR FAR *)
                                             (((DWORD) (*fwWordPointer)) << 16);

                            /* Size */
                            fwWordPointer = (WORD FAR *) (fpDeviceMemory + 3);
                            pTsrStruct[wIndex].dwBlockSize =
                                ((DWORD) (*fwWordPointer)) << 4;

                            /* Device Filename */
                            pTsrStruct[wIndex].szTsrName[0] = ' ';
                            pTsrStruct[wIndex].szTsrName[1] = ' ';
                            _fmemcpy (&(pTsrStruct[wIndex].szTsrName[2]),
                                      &fpDeviceMemory[8], 8);
                            pTsrStruct[wIndex].szTsrName[10] = '\0';

                            /* Device Name */
                            fwWordPointer = (WORD FAR *) (fpDeviceStruct + 4);
                            if (*fwWordPointer & 0x8000)
                              {
                                /* Character Device */

                                _fmemcpy (pTsrStruct[wIndex].szParameters,
                                          &fpDeviceStruct[10], 8);
                                pTsrStruct[wIndex].szParameters[8] = '\0';
                              }
                            else
                              {
                                /* Block Device */

                                strcpy (pTsrStruct[wIndex].szParameters,
                                        pszBlockDevice);
                              }

                            break;

                          case 'E':
                            strcpy (pTsrStruct[wIndex].szTsrName,
                                    pszDeviceAppenage);

                            /* Address */
                            fwWordPointer = (WORD FAR *) (fpDeviceMemory + 1);
                            pTsrStruct[wIndex].wAddress = *fwWordPointer;

                            /* Size */
                            fwWordPointer = (WORD FAR *) (fpDeviceMemory + 3);
                            pTsrStruct[wIndex].dwBlockSize =
                                ((DWORD) (*fwWordPointer)) << 4;

                            break;

                          case 'F':
                            strcpy (pTsrStruct[wIndex].szTsrName,
                                    pszFileHandles);

                            /* Address */
                            fwWordPointer = (WORD FAR *) (fpDeviceMemory + 1);
                            pTsrStruct[wIndex].wAddress = *fwWordPointer;

                            /* Size */
                            fwWordPointer = (WORD FAR *) (fpDeviceMemory + 3);
                            pTsrStruct[wIndex].dwBlockSize =
                                ((DWORD) (*fwWordPointer)) << 4;

                            break;

                          case 'X':
                            strcpy (pTsrStruct[wIndex].szTsrName,
                                    pszFCBS);

                            /* Address */
                            fwWordPointer = (WORD FAR *) (fpDeviceMemory + 1);
                            pTsrStruct[wIndex].wAddress = *fwWordPointer;

                            /* Size */
                            fwWordPointer = (WORD FAR *) (fpDeviceMemory + 3);
                            pTsrStruct[wIndex].dwBlockSize =
                                ((DWORD) (*fwWordPointer)) << 4;

                            break;

                          case 'C':
                          case 'B':
                            strcpy (pTsrStruct[wIndex].szTsrName,
                                    pszBuffers);

                            /* Address */
                            fwWordPointer = (WORD FAR *) (fpDeviceMemory + 1);
                            pTsrStruct[wIndex].wAddress = *fwWordPointer;

                            /* Size */
                            fwWordPointer = (WORD FAR *) (fpDeviceMemory + 3);
                            pTsrStruct[wIndex].dwBlockSize =
                                ((DWORD) (*fwWordPointer)) << 4;

                            break;

                          case 'L':
                            strcpy (pTsrStruct[wIndex].szTsrName,
                                    pszDirectories);

                            /* Address */
                            fwWordPointer = (WORD FAR *) (fpDeviceMemory + 1);
                            pTsrStruct[wIndex].wAddress = *fwWordPointer;

                            /* Size */
                            fwWordPointer = (WORD FAR *) (fpDeviceMemory + 3);
                            pTsrStruct[wIndex].dwBlockSize =
                                ((DWORD) (*fwWordPointer)) << 4;

                            break;

                          case 'S':
                            strcpy (pTsrStruct[wIndex].szTsrName,
                                    pszStacksArea);

                            /* Address */
                            fwWordPointer = (WORD FAR *) (fpDeviceMemory + 1);
                            pTsrStruct[wIndex].wAddress = *fwWordPointer;

                            /* Size */
                            fwWordPointer = (WORD FAR *) (fpDeviceMemory + 3);
                            pTsrStruct[wIndex].dwBlockSize =
                                ((DWORD) (*fwWordPointer)) << 4;

                            break;
                        }

                      /* Point to the next device */
                      fwWordPointer      = (WORD FAR *) (fpDeviceMemory + 1);
                      dwNextDeviceMemory = *fwWordPointer;
                      fwWordPointer      = (WORD FAR *) (fpDeviceMemory + 3);
                      dwNextDeviceMemory += *fwWordPointer;
                      fpDeviceMemory     = (CHAR FAR *) (dwNextDeviceMemory << 16);
                    }
                  --wIndex;
                }
              /* We'll call this the DOS System Area, otherwise */
              else
                {
                  strcpy (pTsrStruct[wIndex].szTsrName, pszDosSystemArea);
                  pTsrStruct[wIndex].szParameters[0] = '\0';
                }
            }
          else
            {
              strcpy (pTsrStruct[wIndex].szTsrName, pszDosSystemArea);
              pTsrStruct[wIndex].szParameters[0] = '\0';
            }
        }
      else
        {
          /* If the PSP == the parent's PSP, it's COMMAND.COM */

          if (fpPspAddress == fpParentPspAddress)
            strcpy (pTsrStruct[wIndex].szTsrName, pszCommandCom);
          else
            {
              /* Otherwise, we have to find the name.  First, search */
              /*   in the environment area.                          */

              CHAR chEnvironName[80];   /* Buffer for storing what the */
                                        /*   environment claims the is */
                                        /*   the name of the TSR       */

              fwWordPointer = (WORD FAR *) (fpPspAddress + 0x002C);
              fpTsrName = (CHAR FAR *) ((DWORD) *fwWordPointer << 16);

              /* The name of the program that owns this MCB is located */
              /*   2 bytes after 2 zero bytes and a word count.  Loop  */
              /*   through the environment block until 2 back-to-back  */
              /*   zero bytes are located.                             */

              while (!(fpTsrName[0] == 0 && fpTsrName[1] == 0))
                ++fpTsrName;

              fpTsrName += 4;

              /* fpTsrName is now pointing to the fully qualified path    */
              /*   to the program name.  Parse for just the program name. */

              for (i = 0; i < MAX_TSR_NAME - 1 &&
                          *fpTsrName > ' '    &&
                          *fpTsrName < 127;      ++fpTsrName)
                {
                  if (*fpTsrName == '\\')
                    i = 0;
                  else
                    chEnvironName[i++] = *fpTsrName;
                }

              /* If this was the real name, it should end with a zero   */
              /*   byte.  If it was garbage, we should have dropped out */
              /*   because fpTsrName pointed to something other than a  */
              /*   zero byte, or the length of the string is zero.      */
              if (*fpTsrName == '\0')
                chEnvironName[i] = '\0';
              else
                chEnvironName[0] = '\0';

              /* The name from the environment is now ready.  Next,     */
              /*   get the MCB owner (DOS 4.0 and above).  If the MCB   */
              /*   owner is the same as the beginning of the name from  */
              /*   the environment, use chEnvironName.  Otherwise, use  */
              /*   the MCB name.                                        */

              if (wDosMajor < 4)
                {
                  /* If there is no name, put in "???" */
                  if (strlen (chEnvironName) == 0)
                    strcpy (pTsrStruct[wIndex].szTsrName, "???");
                  else
                    strcpy (pTsrStruct[wIndex].szTsrName, chEnvironName);
                }
              else
                {
                  /* Obtain the program name from the MCB */

                  fpTsrName = fpMcbHeader + 8;

                  for (i = 0; i < 8             &&
                              *fpTsrName >  ' ' &&
                              *fpTsrName <  127 &&
                              *fpTsrName == (CHAR) toupper (*fpTsrName);
                              ++i, ++fpTsrName)
                    {
                      pTsrStruct[wIndex].szTsrName[i] = *fpTsrName;
                    }

                  pTsrStruct[wIndex].szTsrName[i] = '\0';

                  /* Determine if this is a valid program name.  If we */
                  /*   have not taken 8 characters from the MCB, we    */
                  /*   should have run into a zero byte (the name is   */
                  /*   null terminated if there are less than 8        */
                  /*   characters).                                    */

                  if (i < 8 && (*fpTsrName != '\0' ||
                      pTsrStruct[wIndex].szTsrName[0] == '\0'))
                    {
                      /* Use the environment name */
                      strcpy (pTsrStruct[wIndex].szTsrName, chEnvironName);
                    }

                  /* The MCB contains a valid name.  Check to see if the */
                  /*   environment contains a more complete name (ie,    */
                  /*   the environment contains an extention, the MCB    */
                  /*   does not.                                         */

                  else if (strnicmp (chEnvironName,
                                     pTsrStruct[wIndex].szTsrName,
                                     strlen (pTsrStruct[wIndex].szTsrName)) == 0)
                    {
                      strcpy (pTsrStruct[wIndex].szTsrName, chEnvironName);
                    }

                  if (strnicmp (pszCommand, pTsrStruct[wIndex].szTsrName,
                                strlen (pszCommand)) == 0)
                    {
                      /* The word "command" was found, put COMMAND.COM */
                      /*   into the TSR Name field.                    */

                      strcpy (pTsrStruct[wIndex].szTsrName, pszCommandCom);
                    }

                  if (pTsrStruct[wIndex].szTsrName[0] == '\0')
                    {
                      /* A valid program name could not be found */

                      strcpy (pTsrStruct[wIndex].szTsrName, "???");
                    }
                }
            }

          /* Get the command line parameters */

          fpCommandLine = fpPspAddress + 0x0080;

          /* The first byte is the number of characters in the */
          /*   command line.                                   */

          wCharCount = fpCommandLine[0];
          if (wCharCount > MAX_TSR_CMD_LINE - 1)
            wCharCount = MAX_TSR_CMD_LINE - 1;

          ++fpCommandLine;

          for (i = 0; i < wCharCount &&
                      fpCommandLine[i] >= ' ' &&
                      fpCommandLine[i] <= 127;   ++i)
            pTsrStruct[wIndex].szParameters[i] = fpCommandLine[i];

          pTsrStruct[wIndex].szParameters[i] = '\0';
        }


      /* Determine if this was the last MCB */

      if (*fpMcbHeader == 'Z')
        fEndOfList = TRUE;
      else
        {
          /* Point to the next MCB */

          dwNextMcbHeader = (DWORD) fpMcbHeader +
                            ((DWORD) (wMcbParagraphs + 1) << 16);
          fpMcbHeader     = (CHAR FAR *) dwNextMcbHeader;
        }
    }

  /* Set the last record to zeroes */
  pTsrStruct[wIndex].wAddress        = 0;
  pTsrStruct[wIndex].dwBlockSize     = 0;
  pTsrStruct[wIndex].szTsrName[0]    = '\0';
  pTsrStruct[wIndex].szParameters[0] = '\0';

  /* Set the UMB/DOS MCB chain back to normal */
  LinkUmbToDosChain (FALSE);

  return (FALSE);
}


/*********************************************************************
 * SprintTsrInfo - Put TSR program information into a set of strings
 *                 to be printed or displayed.
 * fIncludeParms - TRUE if command line parameters are to be included.
 *
 * Returns:  NULL if an error occured.
 *********************************************************************/

QSZ * SprintTsrInfo (TSR_PROGRAMS_STRUCT *pTsrStruct,
                     BOOL fIncludeParms)
{
  WORD wNmbrStrings;        /* Number of strings                     */
  WORD wNmbrChars;          /* Number of characters in the strings   */
  WORD wUnderlineLength;    /* Length of the underline string        */
  WORD wIndex;              /* Index to the structure of TSR data    */
  WORD i;                   /* Looping variable                      */
  QSZ  *pqszStrings = NULL; /* Location for storing string pointers  */


  /* Calculate the amount of space required for the strings */

  wUnderlineLength = strlen (pszTsrUnderline);

  if (fIncludeParms)
    {
      wNmbrChars   = strlen (pszTsrHeader) + 1 +
                     wUnderlineLength      + 1 +
                     (wTsrCount * (wUnderlineLength + 1));

      if (wNmbrChars > _memmax() - 100)
        fIncludeParms = FALSE;
    }

  if (fIncludeParms == FALSE)
    wNmbrChars   = strlen (pszTsrHeader) + 1 +
                   wUnderlineLength      + 1 +
                   (wTsrCount * (TSR_CMD_LINE_COL + 1));

  /* The underline string is expected to be as long as a line of */
  /*   TSR program info.                                         */

  wNmbrStrings = wTsrCount + 3;

  /* "+ 3" is for the header line, the underline, and the NULL */
  /*   pointer at the end of the array.                        */


  /* Allocate space for the pointer area and string area */
  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);

  /* Put the first two strings in place */

  Qstrcpy (pqszStrings[0], pszTsrHeader);
  pqszStrings[1] = pqszStrings[0] + Qstrlen (pqszStrings[0]) + 1;

  Qstrcpy (pqszStrings[1], pszTsrUnderline);
  pqszStrings[2] = pqszStrings[1] + wUnderlineLength + 1;

  /* Put the TSR information in place */

  for (i = 2, wIndex = 0;
       !(pTsrStruct[wIndex].wAddress  == 0 &&
       pTsrStruct[wIndex].dwBlockSize == 0);
       ++i, ++wIndex)
    {
      WORD wLength;       /* Current length of string */
      CHAR chBuffer[80];  /* Buffer for string data   */

      /* Fill the line with spaces */
      Qmemset (pqszStrings[i], ' ', wUnderlineLength);
      pqszStrings[i][wUnderlineLength] = '\0';


      /* TSR Name */

      Qstrcpy (pqszStrings[i], pTsrStruct[wIndex].szTsrName);

      wLength    = Qstrlen (pqszStrings[i]);
      pqszStrings[i][wLength] = ' ';


      /* Size */

      wLength = sprintf (chBuffer, "%6lu",
                         pTsrStruct[wIndex].dwBlockSize);

      Qstrcpy (&pqszStrings[i][TSR_SIZE_COL], chBuffer);

      pqszStrings[i][TSR_SIZE_COL + wLength] = ' ';


      /* Address */

      wLength = sprintf (chBuffer, "%04X", pTsrStruct[wIndex].wAddress);

      Qstrcpy (&pqszStrings[i][TSR_ADDRESS_COL], chBuffer);

      pqszStrings[i][TSR_ADDRESS_COL + wLength] = ' ';


      /* Command line parameters */

      if (fIncludeParms)
        Qstrcpy (&pqszStrings[i][TSR_CMD_LINE_COL],
                pTsrStruct[wIndex].szParameters);


      /* Set the next pointer */
      PrepNextString (pqszStrings, i);
    }

  /* Set the last pointer to NULL */

  pqszStrings[i] = NULL;

  /* Return the pointer to pqszStrings */

  return (pqszStrings);
}


/*********************************************************************
 * FindFirstMcbHeader - Finds the pointer to the first memory control
 *                      block (MCB).
 *
 * Returns:  Far pointer to the first MCB.
 *********************************************************************/

CHAR FAR * FindFirstMcbHeader (VOID)
{
  union REGS regsIn, regsOut;   /* Register structures for int86x call */
  struct SREGS sregs;           /* Segment registers for int86x call   */
  WORD wMcbSegment        = 0;  /* Segment of first MCB                */
  WORD FAR *fwWordPointer = NULL; /* A far pointer to a WORD           */

  /* Get the address of the start of DOS' list of lists (ES:BX) */

  regsIn.h.ah = 0x52;
  int86x (0x21, &regsIn, &regsOut, &sregs);

  /* Get first MCB Segment */

  fwWordPointer = (WORD FAR *)
                  ((((long) (sregs.es) << 16) + (long) (regsOut.x.bx)) - 2);

  wMcbSegment = *fwWordPointer;

  /* Return pointer to the first MCB */

  return ((CHAR FAR *) ((DWORD) wMcbSegment << 16));
}


/*********************************************************************
 * LinkUmbToDosChain - Links or unlinks UMBs to the DOS memory control
 *                     block chain.
 * fLinkFlag - TRUE  - Link UMBs to the DOS MCB chain.
 *             FALSE - Set the chain back to the default.
 *********************************************************************/

VOID LinkUmbToDosChain (BOOL fLinkFlag)
{
  union REGS regsin, regsout;         /* Register structs for int86 call   */
  static BOOL fDefaultLink = 0xFFFF;  /* Set to DOS Default of UMBs linked */
                                      /*   or unlinked                     */

  /* Are we running under a valid version of DOS */
  if (wDosMajor >= 5 && wDosMajor < 10)
    {
      /* Set the default, if necessary */
      if (fDefaultLink == 0xFFFF)
        {
          regsin.x.ax = 0x5802;
          int86 (0x21, &regsin, &regsout);

          if (regsout.x.cflag == 0)
            fDefaultLink = (BOOL) regsout.h.al;
          else
            return;
        }

      /* Now, set the link as per the request */
      regsin.x.ax = 0x5803;

      if (fLinkFlag)
        {
          /* Link the UMB chain to the DOS MCB chain */
          regsin.x.bx = 0x0001;
          int86 (0x21, &regsin, &regsout);
        }
      else
        {
          /* Set the UMB chain link to the default state */
          regsin.x.bx = fDefaultLink;
          int86 (0x21, &regsin, &regsout);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\verinfo.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * VERINFO.C - Source file for determining file versions.
 ********************************************************************/


/* Include Files */

#include "msd.h"


/*********************************************************************
 * GetFileVersion - Gets the version information from a file.
 *
 * pszFilename  - Filename from which to get the version information.
 * fMinimumInfo - Gets minimum version information when TRUE.
 *
 * Returns:  Pointer to version information, NULL if an error occured.
 *********************************************************************/

BYTE * GetFileVersion (PSZ pszFilename, BOOL fMinimumInfo)
{
  WORD  wSize;        /* Size of the file's version info              */
  DWORD dwHandle;     /* Handle returned by GetFileVersionInfoSize    */
  BYTE * pVer;        /* File version info structure                  */
  BYTE * pVer32;      /* File version info structure (32 bit aligned) */
  BOOL fReturnValue;  /* Return value from GetFileVersionInfo         */


  /* Determine the size of the version info structure */
  wSize = (WORD) GetFileVersionInfoSize ((CHAR  FAR *) pszFilename,
                                         (DWORD FAR *) &dwHandle);
  if (wSize == 0)
    return (NULL);


  /* Allocate the memory required for the "structure" */
  pVer = malloc (wSize + 4);
  if (pVer == NULL)
    return (NULL);


  /* Align the pointer on 32 bits */
  pVer32 = DWORDUP (pVer);


  /* Get the version information */
  fReturnValue = GetFileVersionInfo ((CHAR FAR *) pszFilename, dwHandle,
                                     (DWORD) wSize, (BYTE FAR *) pVer32);


  /* Return the value */
  if (fReturnValue == FALSE)
    {
      free (pVer);
      return (NULL);
    }
  else
    return (pVer);
}


/*********************************************************************
 * SprintFileVersion - Put the version information into displayable
 *                     strings.
 *
 * pszFilename  - Filename from which to get the version information.
 * fMinimumInfo - Gets minimum version information when TRUE.
 *
 * Returns:  Pointer to array of strings, NULL if an error occured.
 *********************************************************************/

QSZ * SprintFileVersion (BYTE * pVer)
{
  QSZ  *pqszStrings;  /* Pointer to string pointer array          */
  WORD wMaxFree;      /* Maximum number of free bytes to allocate */
  WORD wNmbrStrings;  /* Number of string pointers available      */
  WORD wNmbrChars;    /* Number of character pointers available   */
  WORD wCharCount = 0;/* Total number of chars stored in memory   */
  WORD i = 0;         /* Looping variable                         */
  WORD wStringLen;    /* Length of a string                       */
  WORD * pWord;       /* WORD pointer                             */
  CHAR chBuffer[80];  /* Local character buffer                   */
  WORD wAlignColumn = 19; /* Alignment column                     */
  BYTE * pVer2 = pVer;    /* Original pointer value               */

  /* Values for the VS_VERSION_INFO "structure" */

  WORD wTotLength;          /* Length of VS_VERSION_BLOCK (w/out padding) */
  WORD wValLength;          /* Length of VS_FIXEDFILEINFO data            */
  VS_FIXEDFILEINFO *pValue; /* Pointer to VS_FIXEDFILEINFO struct         */


  /* Allocate memory for the strings */
  wMaxFree     = _memmax() - 2048;
  wNmbrStrings = wMaxFree / (32 + sizeof (PSZ)) + 1;
  wNmbrChars   = wMaxFree - (wNmbrStrings * sizeof (PSZ));
  wNmbrStrings = MAX_MSD_STRINGS + 1;
  wNmbrChars   = REPORT_WIDTH * (MAX_MSD_STRINGS + 1);

  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);


  /* Interpret the version information */
  {
    /* Align pVer onto a 32 bit boundary */
    pVer = DWORDUP (pVer);

    /* Get wTotLength and wValLength */
    pWord = (WORD *) pVer;
    wTotLength = *pWord;
    wValLength = *(++pWord);

    /* Key */
    QstrcpyAlign (pqszStrings[i], "Key: ", wAlignColumn);
    Qstrcat (pqszStrings[i], &pVer[4]);
    PrepNextString (pqszStrings, i);
    wCharCount += Qstrlen (pqszStrings[i++]) + 1;


    /* Find VS_FIXEDFILEINFO data */
    wStringLen = strlen (&pVer[4]);
    pVer = &pVer[4 + wStringLen + 1];
    pVer = DWORDUP (pVer);
    pValue = (VS_FIXEDFILEINFO *) pVer;


    /* Interpret the VS_FIXEDFILEINFO data */

    /* Signature */
    QstrcpyAlign (pqszStrings[i], "Signature: ", wAlignColumn);
    sprintf (chBuffer, "%04X%04X",
             FP_SEG (pValue->dwSignature),
             FP_OFF (pValue->dwSignature));
    Qstrcat (pqszStrings[i], chBuffer);
    PrepNextString (pqszStrings, i);
    wCharCount += Qstrlen (pqszStrings[i++]) + 1;


    /* Structure version */
    QstrcpyAlign (pqszStrings[i], "Structure Version: ", wAlignColumn);
    sprintf (chBuffer, "%u.%u",
             FP_SEG (pValue->dwStrucVersion),
             FP_OFF (pValue->dwStrucVersion));
    Qstrcat (pqszStrings[i], chBuffer);
    PrepNextString (pqszStrings, i);
    wCharCount += Qstrlen (pqszStrings[i++]) + 1;


    /* File Version */
    QstrcpyAlign (pqszStrings[i], "File Version: ", wAlignColumn);
    sprintf (chBuffer, "%u.%u.%u.%u",
             FP_SEG (pValue->dwFileVersionMS),
             FP_OFF (pValue->dwFileVersionMS),
             FP_SEG (pValue->dwFileVersionLS),
             FP_OFF (pValue->dwFileVersionLS));
    Qstrcat (pqszStrings[i], chBuffer);
    PrepNextString (pqszStrings, i);
    wCharCount += Qstrlen (pqszStrings[i++]) + 1;


    /* Product Version */
    QstrcpyAlign (pqszStrings[i], "Product Version: ", wAlignColumn);
    sprintf (chBuffer, "%u.%u.%u.%u",
             FP_SEG (pValue->dwProductVersionMS),
             FP_OFF (pValue->dwProductVersionMS),
             FP_SEG (pValue->dwProductVersionLS),
             FP_OFF (pValue->dwProductVersionLS));
    Qstrcat (pqszStrings[i], chBuffer);
    PrepNextString (pqszStrings, i);
    wCharCount += Qstrlen (pqszStrings[i++]) + 1;


    /* File Flags */
    QstrcpyAlign (pqszStrings[i], "File Flags: ", wAlignColumn);

    if (VS_FF_DEBUG & pValue->dwFileFlagsMask & pValue->dwFileFlags)
      Qstrcat (pqszStrings[i], "Debug ");

    if (VS_FF_INFOINFERRED & pValue->dwFileFlagsMask & pValue->dwFileFlags)
      Qstrcat (pqszStrings[i], "Inferred ");

    if (VS_FF_PATCHED & pValue->dwFileFlagsMask & pValue->dwFileFlags)
      Qstrcat (pqszStrings[i], "Patched ");

    if (VS_FF_PRERELEASE & pValue->dwFileFlagsMask & pValue->dwFileFlags)
      Qstrcat (pqszStrings[i], "Prerelease ");

    if (VS_FF_PRIVATEBUILD & pValue->dwFileFlagsMask & pValue->dwFileFlags)
      Qstrcat (pqszStrings[i], "Private-Build ");

    if (VS_FF_SPECIALBUILD & pValue->dwFileFlagsMask & pValue->dwFileFlags)
      Qstrcat (pqszStrings[i], "Special-Build ");

    PrepNextString (pqszStrings, i);
    wCharCount += Qstrlen (pqszStrings[i++]) + 1;


    /* File Operating System */
    QstrcpyAlign (pqszStrings[i], "File Operating System: ", wAlignColumn);

    if ((VOS_UNKNOWN & pValue->dwFileOS) == 0)
      Qstrcat (pqszStrings[i], "Unknown");

    if (VOS_DOS & pValue->dwFileOS)
      Qstrcat (pqszStrings[i], "MS-DOS");

    if (VOS_OS216 & pValue->dwFileOS)
      Qstrcat (pqszStrings[i], "16 Bit OS/2");

    if (VOS_OS232 & pValue->dwFileOS)
      Qstrcat (pqszStrings[i], "32 Bit OS/2");

    if (VOS_NT & pValue->dwFileOS)
      Qstrcat (pqszStrings[i], "MS-NT");

    /* Add a separator if an extention is used
    if ((VOS_BASE & pValue->dwFileOS) != 0)
      Qstrcat (pqszStrings[i], " - ");

    if (VOS_WINDOWS16 & pValue->dwFileOS)
      Qstrcat (pqszStrings[i], "16 Bit Windows");

    if (VOS_PM16 & pValue->dwFileOS)
      Qstrcat (pqszStrings[i], "16 Bit Presentation Manager");

    if (VOS_PM32 & pValue->dwFileOS)
      Qstrcat (pqszStrings[i], "32 Bit Presentation Manager");

    if (VOS_WINDOWS32 & pValue->dwFileOS)
      Qstrcat (pqszStrings[i], "32 Bit Windows");

    PrepNextString (pqszStrings, i);
    wCharCount += Qstrlen (pqszStrings[i++] + 1;


    /* File Type */
    QstrcpyAlign (pqszStrings[i], "File Type: ", wAlignColumn);

    switch (pValue->dwFileType)
      {
        case VFT_UNKNOWN:
          Qstrcat (pqszStrings[i], "Unknown");
          break;

        case VFT_APP:
          Qstrcat (pqszStrings[i], "Application");
          break;

        case VFT_DLL:
          Qstrcat (pqszStrings[i], "Dynamic Link Library");
          break;

        case VFT_DRV:
          switch (pValue->dwFileSubtype)
            {
              case VFT_UNKNOWN:
                Qstrcat (pqszStrings[i], "Unknown");
                break;

              case VFT2_DRV_PRINTER:
                Qstrcat (pqszStrings[i], "Printer");
                break;

              case VFT2_DRV_KEYBOARD:
                Qstrcat (pqszStrings[i], "Keyboard");
                break;

              case VFT2_DRV_LANGUAGE:
                Qstrcat (pqszStrings[i], "Language");
                break;

              case VFT2_DRV_DISPLAY:
                Qstrcat (pqszStrings[i], "Display");
                break;

              case VFT2_DRV_MOUSE:
                Qstrcat (pqszStrings[i], "Pointing Device");
                break;

              case VFT2_DRV_NETWORK:
                Qstrcat (pqszStrings[i], "Network");
                break;

              case VFT2_DRV_SYSTEM:
                Qstrcat (pqszStrings[i], "System");
                break;

              case VFT2_DRV_INSTALLABLE:
                Qstrcat (pqszStrings[i], "Installable");
                break;

              case VFT2_DRV_SOUND:
                Qstrcat (pqszStrings[i], "Sound");
                break;

              default:
                Qstrcat (pqszStrings[i], "Unknown");
                break;
            }

          Qstrcat (pqszStrings[i], " Driver");
          break;

        case VFT_FONT:
          switch (pValue->dwFileSubtype)
            {
              case VFT2_UNKNOWN:
                Qstrcat (pqszStrings[i], "Unknown Font Type");
                break;

              case VFT2_FONT_RASTER:
                Qstrcat (pqszStrings[i], "Raster Font");
                break;

              case VFT2_FONT_VECTOR:
                Qstrcat (pqszStrings[i], "Vector Font");
                break;

              case VFT2_FONT_TRUETYPE:
                Qstrcat (pqszStrings[i], "True Type Font");
                break;

              default:
                Qstrcat (pqszStrings[i], "Unknown Font Type");
                break;
            }
          break;

        case VFT_VXD:
          Qstrcat (pqszStrings[i], "VxD");
          break;

        case VFT_STATIC_LIB:
          Qstrcat (pqszStrings[i], "Static Library");
          break;

        default:
          Qstrcat (pqszStrings[i], "Unknown");
      }

    PrepNextString (pqszStrings, i);
    wCharCount += Qstrlen (pqszStrings[i++]) + 1;


    /* File date */

    /* This will have to wait until I learn how to calculate */
    /*   the number of 100-nanosecond intervals have occured */
    /*   since midnight, January 1, 1601 (the NT standard    */
    /*   time/date stamp).                                   */
  }

  {
    /* String information */

    WORD wSfiTotLength;     /* StringFileInfo total length              */
    WORD wSfiValLength;     /* StringFileInfo value length              */
    BYTE * pSfiVer;         /* Pointer to start of StringFileInfo block */


    /* Add a blank line */
    pqszStrings[i][0] = '\0';
    PrepNextString (pqszStrings, i);
    wCharCount += Qstrlen (pqszStrings[i++]) + 1;


    /* Set pVer to point to StringFileInfo */
    pVer += sizeof (VS_FIXEDFILEINFO);
    pVer = DWORDUP (pVer);
    pSfiVer = pVer;

    /* Set the length variables */
    pWord = (WORD *) pVer;
    wSfiTotLength = *pWord;
    wSfiValLength = *(++pWord);
    pVer += 4;

    /* Add "StringFileInfo" */
    Qstrcpy (pqszStrings[i], pVer);
    PrepNextString (pqszStrings, i);
    wCharCount += Qstrlen (pqszStrings[i++]) + 1;

    /* Point to the first child */
    pVer += strlen (pVer) + 1;
    pVer = DWORDUP (pVer);


    /* Get the String Table Blocks */
    while (pVer < &pSfiVer[wSfiTotLength])
      {
        WORD wStTotLength;    /* StringTable total length              */
        WORD wStValLength;    /* StringTable value length              */
        WORD wLanguageId;     /* Language ID of string info block      */
        WORD wCodePage;       /* CodePage of string info block         */
        WORD u;               /* Index variable                        */
        BYTE * pStVer = pVer; /* Pointer to start of StringTable block */


        /* Set the length variables */
        pWord = (WORD *) pVer;
        wStTotLength = *pWord;
        wStValLength = *(++pWord);
        pVer += 4;

        /* Interpret the 8 digit hex number */
        strncpy (chBuffer, pVer, 4);
        chBuffer[4] = ' ';
        strncpy (&chBuffer[5], &pVer[4], 4);
        chBuffer[9] = '\0';
        sscanf (chBuffer, "%x %x", &wLanguageId, &wCodePage);

        /* Determine the Language ID */
        Qstrcpy (pqszStrings[i], "Microsoft Language ID: ");
        for (u = 0;
             u < MAX_LANGUAGE_IDS && rgLang[u].wLanguageId != wLanguageId;
             ++u)
          ;

        Qstrcat (pqszStrings[i], rgLang[u].pszLanguageId);
        PrepNextString (pqszStrings, i);
        wCharCount += Qstrlen (pqszStrings[i++]) + 1;

        /* Determine the CodePage */
        Qstrcpy (pqszStrings[i], "Windows CodePage: ");
        for (u = 0;
             u < MAX_CODEPAGE && rgCP[u].wCodePage != wCodePage;
             ++u)
          ;

        Qstrcat (pqszStrings[i], rgCP[u].pszCodePage);
        PrepNextString (pqszStrings, i);
        wCharCount += Qstrlen (pqszStrings[i++]) + 1;


        /* Point to the first child */
        pVer += strlen (pVer) + 1;
        pVer = DWORDUP (pVer);


        /* Get the String blocks */
        while (pVer < &pStVer[wStTotLength])
          {
            CHAR chBuffer[80];    /* String buffer                    */
            WORD wSTotLength;     /* StringTable total length         */
            WORD wSValLength;     /* StringTable value length         */
            BYTE * pSVer = pVer;  /* Pointer to start of String block */


            /* Set the length variables */
            pWord = (WORD *) pVer;
            wSTotLength = *pWord;
            wSValLength = *(++pWord);
            pVer += 4;

            /* Add the key string */
            strcpy (chBuffer, pVer);
            strcat (chBuffer, ": ");
            wAlignColumn = max (wAlignColumn, strlen (chBuffer));
            QstrcpyAlign (pqszStrings[i], chBuffer, wAlignColumn);

            /* Add the value string */
            pVer += strlen (pVer) + 1;
            pVer = DWORDUP (pVer);
            Qstrcat (pqszStrings[i], pVer);
            PrepNextString (pqszStrings, i);
            wCharCount += Qstrlen (pqszStrings[i++]) + 1;

            /* Point to the next sibling */
            pVer = pSVer + wSTotLength;
            pVer = DWORDUP (pVer);
          }
      }
  }

  /* The last string must be a NULL pointer */
  pqszStrings[i] = NULL;


  /* Free up what memory we can */
  _expand (pqszStrings, (i + 1) * sizeof (QSZ));
  Qexpand (pqszStrings[0], wCharCount);

  return (pqszStrings);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\summary.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * SUMMARY.C - Operates the summary screen and supporting CW routines.
 *********************************************************************/


/* Include Files */

#include "msd.h"

#ifdef CW_INCLUDED

#include "cgraphic.h"
#include <process.h>

AY FAR PASCAL GetUILine (void);


/********************************************************************
 * Include the auxiliary CW code
 ********************************************************************/

#include "scr.c"
#include "auxcow.c"


/********************************************************************
 * BeginCwInterface - Starts the CW interface code
 *
 * Returns: Void.
 ********************************************************************/

VOID BeginCwInterface (VOID)
{
  ExamineDisplay();

  if (GetCwSumInfo())
    exit (1);

#ifdef BASED

  /* Initialize the CW window segment */

  if (!WndSegInit())
    {
      PutString ("Error creating window segment");
      exit(2);
    }
#endif

  /* Initialize CW */

  if (!FInitCow())
    {
      PutString ("Error initializing COW");
      exit (2);
    }

  SetCursorBlink (TRUE);

  /* SaveOriginalScreen(); */

  SetIsaColors (fBlackWhite);

  InitModeMapping();

  if (!FInitScreenMode (-1))
    {
      PutString ("Error initializing screen");
      exit (2);
    }

  EnableKeyboard (TRUE);

  EnableOverlap (TRUE, (PWND) NULL, 0);

  SetCWHook (WH_FRAME, FrameFilter);

  fCwIsReady = TRUE;

  InitMainWindows();

  InitMsgBoxPlateBtns();

  InitMyEditItem();

  WarnWindowsUser();


  /* Main Message Pump */

  while (1)
    {
      MSG msg;

      /* Dispatch messages until queue empty */

      while (PeekMessage (&msg))
        {
          DispatchMessage (&msg);
        }

      while (!FMessage())    /* DOS wait */
        {
          /* If using FMessage(), application must poll keyboard */

          if (fPollKeyboard)
            PollKeyboard();
        }
    }

  /* NOT REACHED */
}


/*********************************************************************
 * GetCwSumInfo - Get the summary information while using the CW
 *                interface.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetCwSumInfo (VOID)
{
  WORD wSize;             /* Size of SUMMARY_STRUCT */


  /* Obtain the info structure's size */
  wSize = GetInfoSize (IDI_SUMMARY_SCREEN, FALSE);

  if (wSize == 0)
    return (TRUE);


  /* Allocate enough room for the info structure */
  pSum = malloc (wSize);

  if (pSum == NULL)
    {
      OutOfMemory();
      return (TRUE);
    }

  /* Zero out the structure */
  memset (pSum, '\0', wSize);

  /* Fill the structure with the information */
  if (GetInfo (IDI_SUMMARY_SCREEN, pSum, FALSE, FALSE, TRUE))
    {
      free (pSum);
      return (TRUE);
    }

  return (FALSE);
}


AY FAR PASCAL GetUILine (VOID)
{
  return ((AY) 0);
}


VOID ScreenRedraw (VOID)
{
  DrawWindow ( NULL );
}


/*********************************************************************
 * SetIsaColors - Sets the correct colors for the CW MSD
 *
 * fBlackWhiteFlag - Uses the black and white color set if TRUE.
 *********************************************************************/

VOID SetIsaColors (BOOL fBlackWhiteFlag)
{
  ISA_PAIR  *pisap = NULL;  /* Pointer to the correct ISA */
  ISA  i;                   /* Looping variable           */


  /* Choose between color and black and white */
  if (fBlackWhiteFlag)
    pisap = aisapBlackAndWhite;
  else
    pisap = aisapColor;

  /* Set the screen colors */

  for (i = 0; i < isaMax; ++i)
    SetIsaColor (i, pisap[i].wFore, pisap[i].wBack);

  CheckMenuItem (midBlackWhite, fBlackWhiteFlag);

  if (fCwIsReady)
    DrawWindow (pwndDesktop);
}


/*******************************/
/* Initialize the main windows */
/*******************************/

VOID FAR InitMainWindows (VOID)
{
  /* Register the main window */

  if (!RegisterClass (0,
                      0,
                      0,
                      MainProcExtraBytes,
                      MainProcCallID,
                      MainWndProc))

    {
      return;
    }

  /* Register the Info Provider window */

  if (!RegisterClass (0,
                      0,
                      0,
                      MainProcExtraBytes,
                      InfoWndCallID,
                      InfoWndProc))

    {
      return;
    }

  /* Register the Info Provider text window */

  if (!RegisterClass (0,
                      0,
                      0,
                      MainProcExtraBytes,
                      InfoTxtWndCallID,
                      InfoTxtWndProc))

    {
      return;
    }

  /* Register the status line window */

  if (!RegisterClass (0,
                      0,
                      0,
                      MainProcExtraBytes,
                      StatusLineCallID,
                      StatusLineProc))

    {
      return;
    }


  /* Create the status line window */

  pwndStatusLine = (PWND) CreateWindow (StatusLineCallID,
                                        NULL,
                                        NULL,
                                        WS_VISIBLE,
                                        0, ayMac - (AY) 1, axMac, 1,
                                        (HWND) pwndDesktop,
                                        (HMENU) NULL,
                                        NULL,
                                        1);
  if (pwndStatusLine == NULL)
    return;

  ShowWindow (pwndStatusLine, SW_VISIBLE, TRUE);


  /* Create the main window */

  pwndMainFrame = (PWND) CreateWindow (MainProcCallID,
                                       NULL,
                                       WS_CLIPOUT,
                                       WS_FRAME,
                                       0, 0, axMac, ayMac - (AY) 1,
                                       (HWND) pwndDesktop,
                                       (HMENU) hmnuMenuBar,
                                       NULL,
                                       1);
  if (pwndMainFrame == NULL)
    return;

  EnableWindow (pwndMainFrame, TRUE);


  ShowWindow (NULL, SW_VISIBLE, TRUE);

  /* Enable mouse */

  FEnableMouse(TRUE);

  /* AddAccelTable (&prgmpvkeyid); */

  SetFocus (pwndMainFrame);
}


/*********************************************************************
 * MainWndProc - Window to display the pull down menus, the summary
 *               information, and the buttons
 *********************************************************************/

STATIC LONG FAR PASCAL MainWndProc (PWND  pwnd,
                                    WORD  message,
                                    WORD  wParam,
                                    DWORD lParam)
{
  WORD i;             /* Looping variable                      */
  WORD wKeyState;     /* Shift key state when a key is pressed */
  static struct BUTTON_INFO
    {
      PWND pwndInfo;  /* PWND of the button's Info Window, or  */
                      /*   NULL if there is no Info window up  */
                      /*   for that button.                    */
      CHAR chAccel;   /* Accelerator character for the button  */
      PSZ  pszHelp;   /* Help text for info window             */
    } ButtonInfo[] =
        {
          { NULL, 'P', "Computer: Displays computer, BIOS, and processor information." },
          { NULL, 'M', "Memory: Displays visual memory map and various types of memory." },
          { NULL, 'V', "Video: Displays video adapter make, model, type, and BIOS." },
          { NULL, 'N', "Network: Displays network information." },
          { NULL, 'O', "OS Version: Displays operating system information." },
          { NULL, 'U', "Mouse: Displays mouse information." },
          { NULL, 'A', "Other Adapters: Displays game adapter information." },
          { NULL, 'D', "Disk Drives: Displays disk drive types and sizes." },
          { NULL, 'L', "LPT Ports: Displays status of parallel ports." },
          { NULL, 'C', "COM Ports: Displays status of serial ports." },
          { NULL, 'Q', "IRQ Status: Displays current usage of hardware interrupts." },
          { NULL, 'T', "TSR Programs: Displays allocated memory control blocks." },
          { NULL, 'R', "Device Drivers: Displays installable device driver information." }
        };

  switch (message)
    {
      case WM_CREATE:
        CreateChildWindows (pwnd);
        break;

      case WM_PAINT:
        {
          NPRRC  prrc;
          RRC    rrc;

          /* clear the window */

          if ((prrc = (NPRRC) LOWORD (lParam)) == NULL)
            {
              GetClientRrc(pwnd, &rrc);
              prrc = &rrc;
            }

          FillRrc (pwnd, prrc, ' ', isaSummaryText);

          WriteSummaryText (pwnd);

          break;
        }

      case WM_COMMAND:
        {
          switch (wParam)
            {
              case BaseBtnID +  0:
              case BaseBtnID +  1:
              case BaseBtnID +  2:
              case BaseBtnID +  3:
              case BaseBtnID +  4:
              case BaseBtnID +  5:
              case BaseBtnID +  6:
              case BaseBtnID +  7:
              case BaseBtnID +  8:
              case BaseBtnID +  9:
              case BaseBtnID + 10:
              case BaseBtnID + 11:
              case BaseBtnID + 12:
              case BaseBtnID + 13:
                if (HIWORD (lParam) == BN_CLICKED)
                  {
                    if (ButtonInfo[wParam - BaseBtnID].pwndInfo)
                      {
                        /* Bring up the entire info window */
                        SetFocus (ButtonInfo[wParam - BaseBtnID].pwndInfo);
                      }
                    else
                      {
#if HEAP_DEBUG
                        CHAR chBuffer[80];

                        sprintf (chBuffer, "_memavl = %u, _memmax = %u",
                                 _memavl(), _memmax());

                        ShowStatus (chBuffer);
#endif
                        DisplayStatus (ST_WORKING);
                        ButtonInfo[wParam - BaseBtnID].pwndInfo =
                            ShowInfo (wParam - BaseBtnID + 4);
                        ShowStatus (ButtonInfo[wParam - BaseBtnID].pszHelp);
                      }
                  }
                break;

              default:
                MenuCommand (pwnd, wParam);
                break;
            }

          break;
        }

      case WM_INFO_WND_CLOSED:
        {
          WORD wNmbrOpen = 0;       /* Number of open info windows      */

          /* Zero out the window pointer in the Button Info structure */
          for (i = 0; i < NumBtns; ++i)
            {
              if (ButtonInfo[i].pwndInfo == (PWND) wParam)
                ButtonInfo[i].pwndInfo = NULL;

              /* Count up the number of open info windows */
              if (ButtonInfo[i].pwndInfo != NULL)
                ++wNmbrOpen;
            }

          /* If we just closed the last info window, set the */
          /*   focus back here                               */

          if (wNmbrOpen == 0)
            SetFocus (pwnd);

          DisplayStatus (0);

          break;
        }

      case WM_DRAWITEM:
        {
          PWND_BTN pwndbtn;             /* Button info structure     */
          RRC rrcButton;                /* Button's relative co-ords */
          RRC rrcShadow;                /* Shadow's relative co-ords */
          DWORD dwButtonState;          /* Button's state            */
          DRAWITEMSTRUCT FAR * fpdis;   /* Pointer to struct for     */
                                        /*   drawing the button      */
          WORD wCenterLoc;              /* Location to center the    */
                                        /*   button's text           */
          WORD wAccelPos;               /* This button's accel pos   */
          static WORD awAccelPos[] =  /* Button Accelerator's position */
            {
              4, /* Com&puter       */
              1, /* &Memory         */
              1, /* &Video          */
              1, /* &Network        */
              1, /* &OS Version     */
              3, /* Mo&use          */
              7, /* Other &Adapters */
              1, /* &Disk Drives    */
              1, /* &LPT Ports      */
              1, /* &COM Ports      */
              3, /* IR&Q Status     */
              1, /* &TSR Programs   */
              9  /* Device D&rivers */
            };

          /* Set the struct pointer */
          fpdis = (DRAWITEMSTRUCT FAR *) lParam;
          pwndbtn = (PWND_BTN) fpdis->hwndItem;

          /* Get the button and shadow sizes */
          _fmemcpy (&rrcButton, &(fpdis->rcItem), sizeof (RRC));
          _fmemcpy (&rrcShadow, &(fpdis->rcItem), sizeof (RRC));

          ++(rrcShadow.ryTop);
          ++(rrcShadow.ryTop);

          /* Find the centering location */
          wCenterLoc = ((rrcButton.rxRight - rrcButton.rxLeft) / 2) -
                       (strlen (pwndbtn->szDialog) / 2);

          /* Determine if the button is pushed in or not */
          dwButtonState = SendMessage (fpdis->hwndItem, BM_GETSTATE, 0, 0L);
          if (dwButtonState & 0x0004)
            {
              /* The button is pressed in */

              /* Repaint the shadow area */
              FillRrc (fpdis->hwndItem, &rrcShadow, '', isaSummaryText);

              CharOut (fpdis->hwndItem, 0, 0, ' ', isaSummaryText);
              CharOut (fpdis->hwndItem, 0, 1, ' ', isaSummaryText);
              CharOut (fpdis->hwndItem, 0, 2, ' ', isaSummaryText);


              /* Repaint the button face */
              ++(rrcButton.rxLeft);

              rrcButton.ryBottom -= 2;
              FillRrc (fpdis->hwndItem, &rrcButton, '', isaSummaryBtnShadow);

              ++(rrcButton.ryBottom);
              ++(rrcButton.ryTop);
              FillRrc (fpdis->hwndItem, &rrcButton, ' ', isaPushButton);

              ++(rrcButton.ryBottom);
              ++(rrcButton.ryTop);
              FillRrc (fpdis->hwndItem, &rrcButton, '', isaSummaryBtnShadow);

              TextOut (fpdis->hwndItem, (RY) (wCenterLoc + 1), 1,
                       pwndbtn->szDialog, -1, isaPushButton);
            }
          else
            {
              /* The button is out */

              /* Repaint the button face */
              --(rrcButton.rxRight);
              wAccelPos = awAccelPos[fpdis->CtlID - BaseBtnID] - 1;

              rrcButton.ryBottom -= 2;
              FillRrc (fpdis->hwndItem, &rrcButton, '', isaSummaryBtnShadow);

              ++(rrcButton.ryBottom);
              ++(rrcButton.ryTop);
              FillRrc (fpdis->hwndItem, &rrcButton, ' ', isaPushButton);

              ++(rrcButton.ryBottom);
              ++(rrcButton.ryTop);
              FillRrc (fpdis->hwndItem, &rrcButton, '', isa3DPushBtnOut);

              /* Lower left corner */
              CharOut (fpdis->hwndItem,
                       rrcButton.rxLeft, 2,
                       '',
                       isaSummaryBtnShadow);

              /* Upper right corner */
              CharOut (fpdis->hwndItem,
                       rrcButton.rxRight, 0,
                       ' ',
                       isaSummaryText);


              /* Repaint the shadow area to the right */
              CharOut (fpdis->hwndItem, rrcButton.rxRight, 1,
                       '', isa3DPushBtnOut);

              CharOut (fpdis->hwndItem, rrcButton.rxRight, 2,
                       '', isa3DPushBtnOut);


              /* Display the button's text */
              TextOut (fpdis->hwndItem, (RY) (wCenterLoc), 1,
                       pwndbtn->szDialog, -1, isaPushButton);


              /* Highlight the accellerator for the button */
              CharOut (fpdis->hwndItem, (RY) (wCenterLoc + wAccelPos),
                       1, pwndbtn->szDialog[wAccelPos], isa3DBtnHilite);
            }

          break;
        }

      case WM_MENUSELECT:
        {
          DisplayStatus (wParam);
        }

      case WM_CHAR:
        {
          float fFloat = (float) 0.0;


          wKeyState = HIWORD (lParam);

          /* Black & White keystroke */
          /* F5 */
          if ((wKeyState & (KK_MENU | KK_CONTROL | KK_SHIFT)) == 0 &&
              wParam == VK_F5)
            {
              SetIsaColors (fBlackWhite = !fBlackWhite);
              break;
            }


          /* Exit keystrokes */
          /* F3 */
          if ((wKeyState & (KK_MENU | KK_CONTROL | KK_SHIFT)) == 0 &&
              wParam == VK_F3)
            Exit (0);

          /* Alt-F4 */
          if ((wKeyState & (KK_MENU | KK_CONTROL | KK_SHIFT)) == KK_MENU &&
              wParam == VK_F4)
            Exit (0);

          if ((wKeyState & (KK_MENU | KK_CONTROL | KK_SHIFT)) == 0)
            {
              /* Loop through the list of accelerator keys, and */
              /*   bring up the correct window                  */
              for (i = 0; i < NumBtns; ++i)
                if (ButtonInfo[i].chAccel == (CHAR) toupper(wParam))
                  {
                    SendMessage (GetDlgItem (pwnd, i + BaseBtnID),
                                 WM_LBUTTONDOWN,
                                 MK_LBUTTON,
                                 NULL);
                    PostMessage (GetDlgItem (pwnd, i + BaseBtnID),
                                 WM_LBUTTONUP,
                                 NULL,
                                 NULL);
                    break;
                  }
              }

          break;
        }

      case WM_CLOSE:
        DestroyWindow (pwnd);
        Exit (0);

      default:
        return (DefWindowProc (pwnd, message, wParam, lParam));
    }

  return (0L);
}


/*********************************************************************
 * CreateChildWindows - Creates the child windows of the main
 *                      "Summary" window.
 *********************************************************************/

STATIC BOOL PASCAL CreateChildWindows (PWND pwndParent)
{
  WORD i;             /* Looping variable                 */
  AX X;               /* X Coordinate                     */
  AY Y;               /* Y Coordinate                     */
  PWND pwnd = NULL;   /* Current window pointer           */
  AY ayButtonHeight;  /* Height, in lines, of the buttons */
  AY ayBtnSeparator;  /* Distance between buttons         */
  AY ayStart;         /* Starting location for buttons    */

  /* Set the button height */
  ayButtonHeight = 3;

  /* Calculate the separation between buttons */
  ayBtnSeparator = (ayMac > (AY) 25) ? (AY) 1 : (AY) 0;

  ayStart = (AY) ((ayMac / (AY) 2) -
            ((NumBtns + 1) / 2 * (ayButtonHeight + ayBtnSeparator)) / 2);

  X = SUM_COLUMN_ONE;
  Y = ayStart;

  for (i = 0; i < NumBtns; i++)
    {
      if (X < 40 && i > NumBtns / 2)
        {
          X = SUM_COLUMN_TWO;
          Y = ayStart;
        }

      pwnd = (PWND)CreateWindow (WC_BUTTON,
                                 paszMainBtnArray[i],
                                 BS_PUSHBUTTON | BS_OWNERDRAW,
                                 WES_3D | WES_TABSTOP,
                                 X, Y,
                                 SUM_BUTTON_WIDTH,
                                 ayButtonHeight,
                                 (HWND) pwndParent,
                                 NULL,
                                 NULL,
                                 BaseBtnID + i);

      Y += ayButtonHeight + ayBtnSeparator;

      if (pwnd == NULL)
        return (FALSE);
    }

  return (TRUE);
}


/*********************************************************************
 * WriteSummaryText - Display the summary text next to the buttons
 *********************************************************************/

STATIC BOOL PASCAL WriteSummaryText (PWND pwndParent)
{
  WORD i;             /* Looping variable                         */
  WORD wIndex;        /* Index to summary strings                 */
  RX X;               /* X Coordinate                             */
  RY Y;               /* Y Coordinate                             */
  AY ayButtonHeight;  /* Height, in lines, of the buttons         */
  AY ayBtnSeparator;  /* Distance between buttons         */
  short sLength;      /* String length                            */
  RY ryStart;         /* Starting point for locating buttons/text */

  /* Set the button height */
  ayButtonHeight = (ayMac > (AY) 25) ? (AY) 3 : (AY) 3;

  /* Calculate the separation between buttons */
  ayBtnSeparator = (ayMac > (AY) 25) ? (AY) 1 : (AY) 0;

  ryStart = (RY) ((ayMac / (RY) 2) -
            ((NumBtns + 1) / 2 * (ayButtonHeight + ayBtnSeparator)) / 2);

  X = 23;
  Y = ryStart;

  for (i = 0, wIndex = IDI_FIRST_RECORD_TO_SUMMARIZE * 2;
       i < NumBtns; ++i, ++wIndex)
    {
      if (X < 40 && i > NumBtns / 2)
        {
          X = 40 + SUM_BUTTON_WIDTH + 7;
          Y = ryStart;
        }

      /* Set the maximum length for summary text line 1 */

      sLength = strlen (pSum->szSumStrings[wIndex]);

      if (X < 40)
        {
          if (sLength > SUM_COLUMN_TWO - X - 2)
            sLength = SUM_COLUMN_TWO - X - 2;
        }
      else
        {
          if (sLength > axMac - X - 1)
            sLength = axMac - X - 1;
        }

      TextOut (pwndParent, X, Y, pSum->szSumStrings[wIndex], sLength,
               isaSummaryText);

      /* Set the maximum length for summary text line 2 */
      ++wIndex;
      sLength = strlen (pSum->szSumStrings[wIndex]);

      if (X < 40)
        {
          if (sLength > SUM_COLUMN_TWO - X - 2)
            sLength = SUM_COLUMN_TWO - X - 2;
        }
      else
        {
          if (sLength > axMac - X - 1)
            sLength = axMac - X - 1;
        }

      TextOut (pwndParent, X, ++Y, pSum->szSumStrings[wIndex],
               sLength, isaSummaryText);

      --Y;

      Y += ayButtonHeight + ayBtnSeparator;
    }

  return (TRUE);
}


/*
AY FAR PASCAL GetUILine (VOID)
{
  return ((AY) 0);
}


VOID ScreenRedraw (VOID)
{
  DrawWindow (NULL);
}
*/


char FAR * FARPUBLIC LpvDerefAppText (PWND pwnd, WORD hText, WORD *cch)
{
  /* Minimum code required for far data. */

  CHAR * chPointer = (CHAR *) hText;

  *cch = strlen ((char *) hText);

  return ((char FAR *) chPointer);
}


/*********************************************************************
 * FrameFilter - Filters frame messages
 *********************************************************************/

STATIC BOOL FARPUBLIC FrameFilter (PMSG pmsg, WORD *pwRegion)
{
  if (*pwRegion == FZ_CLOSE ||
      *pwRegion == FZ_TMOVE)
    return (TRUE);

  return (FALSE);
}


/*********************************************************************
 * InitMsgBoxPlateBtns - Initializes "Plate" buttons for MessageBox'es
 *********************************************************************/

VOID InitMsgBoxPlateBtns (VOID)
{
  PWNDCLASS pcls;

  pcls = FindClass (WC_MSGBOX);

  if (pcls == NULL)
    return;

  OldMsgBoxProc = pcls->pfnWndProc;

  pcls->pfnWndProc = MyMsgBoxProc;
}


/*********************************************************************
 * CreateMsgBtn - Allows me to put plate buttons on MessageBox'es
 *********************************************************************/

PWND FAR CreateMsgBtn ( szWindowName,
                        wStyle, wExStyle,
                        X, Y,
                        nWidth, nHeight,
                        hwndDlg,
                        id )
char * szWindowName;
WORD   wStyle;
WORD   wExStyle;
WORD   X;
WORD   Y;
WORD   nWidth;
WORD   nHeight;
HWND   hwndDlg;
WORD   id;
{
  HWND hwnd;

  hwnd = (HWND) ((PWND_BTN) CreateWindow (WC_BUTTON,
                                          szWindowName,
                                          wStyle | BS_OWNERDRAW,
                                          wExStyle,
                                          X,
                                          Y,
                                          nWidth + 1,
                                          nHeight,
                                          (HWND)hwndDlg,
                                          NULL,
                                          NULL,
                                          id));

  return (hwnd);
}


/*********************************************************************
 * MyMsgBoxProc - Message box button drawing facility.
 *********************************************************************/

LONG FAR
MyMsgBoxProc (REGISTER PWND_DLG pwnd,
              WORD  message,
              WORD  wParam,
              DWORD lParam)
{
  switch (message)
    {
      case WM_DRAWITEM:
        {
          PWND_BTN pwndbtn;             /* Button info structure     */
          RRC rrcButton;                /* Button's relative co-ords */
          RRC rrcShadow;                /* Shadow's relative co-ords */
          DWORD dwButtonState;          /* Button's state            */
          DRAWITEMSTRUCT FAR * fpdis;   /* Pointer to struct for     */
                                        /*   drawing the button      */
          WORD wCenterLoc;              /* Location to center the    */
                                        /*   button's text           */

          /* Set the struct pointer */
          fpdis = (DRAWITEMSTRUCT FAR *) lParam;
          pwndbtn = (PWND_BTN) fpdis->hwndItem;

          /* Get the button and shadow sizes */
          _fmemcpy (&rrcButton, &(fpdis->rcItem), sizeof (RRC));
          _fmemcpy (&rrcShadow, &(fpdis->rcItem), sizeof (RRC));

          ++(rrcShadow.ryTop);
          ++(rrcShadow.ryTop);

          /* Find the centering location */
          wCenterLoc = ((rrcButton.rxRight - 1 - rrcButton.rxLeft) / 2) -
                       (strlen (pwndbtn->szDialog) / 2);

          /* Determine if the button is pushed in or not */
          dwButtonState = SendMessage (fpdis->hwndItem, BM_GETSTATE, 0, 0L);
          if (dwButtonState & 0x0004)
            {
              /* The button is pressed in */

              /* Repaint the shadow area */
              FillRrc (fpdis->hwndItem, &rrcShadow, '', isaDialogBox);

              CharOut (fpdis->hwndItem, 0, 0, ' ', isaDialogBox);
              CharOut (fpdis->hwndItem, 0, 1, ' ', isaDialogBox);
              CharOut (fpdis->hwndItem, 0, 2, ' ', isaDialogBox);


              /* Repaint the button face */
              ++(rrcButton.rxLeft);

              rrcButton.ryBottom -= 2;
              FillRrc (fpdis->hwndItem, &rrcButton, '', isaMessageBtn1);

              ++(rrcButton.ryBottom);
              ++(rrcButton.ryTop);
              FillRrc (fpdis->hwndItem, &rrcButton, ' ', isaPushButton);

              ++(rrcButton.ryBottom);
              ++(rrcButton.ryTop);
              FillRrc (fpdis->hwndItem, &rrcButton, '', isaMessageBtn1);

              TextOut (fpdis->hwndItem, (RY) (wCenterLoc + 1), 1,
                       pwndbtn->szDialog, -1, isaPushButton);
            }
          else
            {
              /* The button is out */

              /* Repaint the button face */
              --(rrcButton.rxRight);

              rrcButton.ryBottom -= 2;
              FillRrc (fpdis->hwndItem, &rrcButton, '', isaMessageBtn1);

              ++(rrcButton.ryBottom);
              ++(rrcButton.ryTop);
              FillRrc (fpdis->hwndItem, &rrcButton, ' ', isaPushButton);

              ++(rrcButton.ryBottom);
              ++(rrcButton.ryTop);
              FillRrc (fpdis->hwndItem, &rrcButton, '', isa3DPushBtnOut);

              /* Lower left corner */
              CharOut (fpdis->hwndItem,
                       rrcButton.rxLeft, 2,
                       '',
                       isaMessageBtn1);

              /* Upper right corner */
              CharOut (fpdis->hwndItem,
                       rrcButton.rxRight, 0,
                       ' ',
                       isaDialogBox);


              /* Repaint the shadow area to the right */
              CharOut (fpdis->hwndItem, rrcButton.rxRight, 1,
                       '', isa3DPushBtnOut);

              CharOut (fpdis->hwndItem, rrcButton.rxRight, 2,
                       '', isa3DPushBtnOut);


              /* Display the button's text */
              TextOut (fpdis->hwndItem, (RY) (wCenterLoc), 1,
                       pwndbtn->szDialog, -1, isaPushButton);
            }

          break;
        }

      default:
        return ( (*(PLFN_WNDPROC)(OldMsgBoxProc))((PWND)pwnd, message, wParam, lParam));
    }
}



/*********************************************************************
 * InitMyEditItem - Inits the subclassing of edit items.
 *********************************************************************/

VOID InitMyEditItem (VOID)
{
  PWNDCLASS pcls;

  pcls = FindClass (WC_EDIT);

  if (pcls == NULL)
    return;

  OldEditItemProc = pcls->pfnWndProc;

  pcls->pfnWndProc = MyEditItemProc;
}


/*********************************************************************
 * MyEditItemProc - Edit Item handler (sends the message MY_EN_SETFOCUS).
 *********************************************************************/

LONG FAR
MyEditItemProc (REGISTER PWND_EDIT pwnd,
                WORD  message,
                WORD  wParam,
                DWORD lParam)
{
  if (message == WM_SETFOCUS)
    SendMessage (pwnd->pwndParent, MY_EN_SETFOCUS, 0, 0L);

  return ((*(PLFN_WNDPROC)(OldEditItemProc))((PWND)pwnd, message, wParam, lParam));
}



/*********************************************************************
 * StatusLineProc - Displays the status line at the bottom of the
 *                  screen.
 *********************************************************************/

STATIC LONG FAR PASCAL StatusLineProc (PWND  pwnd,
                                       WORD  message,
                                       WORD  wParam,
                                       DWORD lParam)
{
  static STATUS_LINE_STRINGS sls[] =
    {
      { enClear,         "Press ALT for menu, or press highlighted letter, or F3 to quit MSD." },
      { enCommand,       NULL },

      { midFile,         "Finds files, prints reports, exits." },
      { midFind,         "Locates and views files." },
      { midReport,       "Prints a report to a printer or a file." },
      { midAutoexecBat,  "Views AUTOEXEC.BAT." },
      { midConfigSys,    "Views CONFIG.SYS." },
      { midSystemIni,    "Locates and views SYSTEM.INI." },
      { midWinIni,       "Locates and views WIN.INI." },
      { midQuit,         "Exits MSD." },

      { midUtil,         "Memory views, insert commands, test printer, color toggle." },
      { midBlockDisplay, "Displays allocated memory on visual memory map." },
      { midBrowser,      "Searches for key words in ROM areas." },
      { midInsert,       "Inserts common commands in system files." },
      { midPrtTst,       "Tests printer connection." },
      { midBlackWhite,   "Toggles between color and black & white." },

      { midHelp,         "Information about MSD." },
      { midAbout,        "Displays MSD version." },

      { ST_WARN_WINDOWS_USER, "Press ENTER to continue, or ESC to quit MSD." },
      { ST_WORKING,      "Working ..." },
      { ST_SEARCHING,    "Searching ..." },
      { ST_REPORT_COMPLETED, "Report Completed." },
      { ST_INSERT_DLG1,  "Choose command to insert into specified file", },
      { ST_INSERT_DLG2,  "Edit or replace Command, Section and Filename." },
      { ST_INSERT_DLG3,  "Choose file to modify and press ENTER." },
      { ST_INSERT_DLG4,  "Choose action and press ENTER." },
      { ST_CUST_INFO,    "Press TAB to move to the next field, ENTER to continue." },
      { ST_VIEW_WHICH_FILE, "Choose file to view and press ENTER." },
      { ST_FINDFILE2,    "Choose the file to view and press ENTER." },

      { 0xFFFF,          NULL }
    };

  static PSZ pszCurrentString;


  switch (message)
    {
      case WM_CREATE:
        pszCurrentString = sls[0].pszString;
        break;

      case WM_ACTIVATE:
        return (rspActiveDecline);

      case WM_NEW_STATUS_LINE_STRING:
        {
          if (lParam == NULL)
            {
              WORD i;

              for (i = 0; sls[i].wStringNmbr != wParam &&
                          sls[i].wStringNmbr != 0xFFFF;   ++i)
                ;
              if (sls[i].wStringNmbr != 0xFFFF)
                pszCurrentString = sls[i].pszString;
              else
                pszCurrentString = sls[0].pszString;
            }
          else
            {
              static CHAR chBuffer[80];

              strcpy (chBuffer, (PSZ) lParam);
              pszCurrentString = chBuffer;
            }
        }

        /* Fall through to WM_PAINT */

      case WM_PAINT:
        {
          WORD wLength;       /* Length of the displayed string                */
          RX   rxCurrentPos;  /* Current position for clearing the status line */

          /* Check to see if we have a message to display */
          if (pszCurrentString == NULL)
            break;

          /* Display the message */
          wLength = strlen (pszCurrentString);
          wLength = (wLength > 80) ? 80 : wLength;
          TextOut (pwndStatusLine, 0, 0, pszCurrentString,
                   wLength, isaStatusLine);

          /* Clear out the rest of the status line */
          rxCurrentPos = (RY) wLength;
          wLength = axMac - wLength;
          while (wLength--)
            CharOut (pwndStatusLine, rxCurrentPos++, 0, ' ', isaStatusLine);
          break;
        }

      case WM_CLOSE:
        DestroyWindow (pwnd);
        Exit (0);

      default:
        return (DefWindowProc (pwnd, message, wParam, lParam));
    }

  return (0L);
}


/*********************************************************************
 * WarnWindowsUser - Displays a simple warning/informational message
 *                   when MSD is brought up under Windows.
 *********************************************************************/

VOID WarnWindowsUser (VOID)
{
  WORD wWindowsType;
  WORD wWindowsMinor;
  WORD wWindowsMajor;
  BOOL fDosShellTaskSwitcher;
  BOOL fReturnValue;
  CHAR chBuffer[80];


  /* Since this is the location for warnings, I put */
  /*   the TEMP/TMP invalid warning here.           */

  if (fTempPathInvalid)
    {
      strcpy (chBuffer, pszTemp);
      strcat (chBuffer, "=");
      strcat (chBuffer, getenv (pszTemp));
      MessageBox (pszEnvironInvalid, chBuffer, NULL, MB_OK | 0x8000);
    }

  if (fTmpPathInvalid)
    {
      strcpy (chBuffer, pszTmp);
      strcat (chBuffer, "=");
      strcat (chBuffer, getenv (pszTmp));
      MessageBox (pszEnvironInvalid, chBuffer, NULL, MB_OK | 0x8000);
    }


  /* Determine if Windows is running */
  WinVerDetect (&wWindowsType,  &wWindowsMajor,
                &wWindowsMinor, &fDosShellTaskSwitcher);

  /* Display an appropriate message if Windows is running */
  if (wWindowsType != NO_WINDOWS)
    {
      /*
      CHAR chBuffer[80];
      static PSZ pszLine1 =
                      "You are running %s.  The information MSD";

      switch (wWindowsType)
        {
          case WIN_286:
          case WIN_386:
            sprintf (chBuffer, pszLine1, "Windows version 2.x");
            break;

          case WIN_REAL_MODE:
            sprintf (chBuffer, pszLine1, "Real mode Windows");
            break;

          case WIN_STANDARD_MODE:
            sprintf (chBuffer, pszLine1, "Standard mode Windows");
            break;

          case WIN_ENHANCED_MODE:
            sprintf (chBuffer, pszLine1, "386 Enhanced mode Windows");
            break;

          default:
            sprintf (chBuffer, pszLine1, "Microsoft Windows");
        }

      DisplayStatus (ST_WARN_WINDOWS_USER);

      fReturnValue = DialogBox (&dlgWarnWindowsUser, WarnWindowsUserDlg);

      fReturnValue = MessageBox (chBuffer,
                  "provides may be more complete or accurate if you run MSD outside",
                  "of Windows.  Choose OK to continue or Cancel to quit MSD.",
                  MB_OKCANCEL | 0x8000);

      DisplayStatus (0);

      if (fReturnValue != IDOK)
        Exit (0);

      */

      DisplayStatus (ST_WARN_WINDOWS_USER);

      fReturnValue = DialogBox (&dlgWarnWindowsUser, WarnWindowsUserDlg);

      DisplayStatus (0);

      if (fReturnValue != IDOK)
        Exit (0);
    }
}


/*********************************************************************
 * FHelpMsg - Replaces the CW supplied help callback with this
 *            routine.  By returning FALSE from this routine, the CW
 *            help engine is never executed.
 *********************************************************************/

BOOL FHelpMsg (PMSG pmsg, WORD cnx)
{
  return (FALSE);
}


/*********************************************************************
 * Help - Replaces the CW supplied help message with this routine
 *********************************************************************/

VOID FARPUBLIC Help (WORD hem, WORD hid, VOID *pv, WORD kk)
{
}


/*********************************************************************
 * ExamineDisplay - Displays "MSD is examining your system"
 *********************************************************************/

#define EXAM_BACKGROUND            0x17
#define EXAM_WINDOW_BORDER         0x47
#define EXAM_WINDOW_AREA           0x4F
#define EXAM_WINDOW_HIGHLIGHT      0xCE
#define BW_EXAM_BACKGROUND         0x07
#define BW_EXAM_WINDOW_BORDER      0x70
#define BW_EXAM_WINDOW_AREA        0x70
#define BW_EXAM_WINDOW_HIGHLIGHT   0xF0

VOID ExamineDisplay (VOID)
{
  BYTE FAR * fpLines = (BYTE FAR *) 0x00400084;
                              /* Number of lines on the display        */
  WORD wNmbrLines = (*fpLines) + 1;
  WORD wLineAdj;              /* Number of lines to add (for 43 and 50 */
                              /*   line displays)                      */
  WORD wExamBackground;       /* Screen background color               */
  WORD wExamWindowBorder;     /* Color of window border                */
  WORD wExamWindowArea;       /* Color of window text area             */
  WORD wExamWindowHighlight;  /* Window highlight color (blinking)     */
  WORD wMenuBar;              /* Menu bar attribute                    */
  WORD wStatusBar;            /* Status bar attribute                  */


  /* Set the colors */
  if (fBlackWhite)
    {
      wExamBackground      = BW_EXAM_BACKGROUND;
      wExamWindowBorder    = BW_EXAM_WINDOW_BORDER;
      wExamWindowArea      = BW_EXAM_WINDOW_AREA;
      wExamWindowHighlight = BW_EXAM_WINDOW_HIGHLIGHT;
      wMenuBar             = 0x70;
      wStatusBar           = 0x70;
    }
  else
    {
      wExamBackground      = EXAM_BACKGROUND;
      wExamWindowBorder    = EXAM_WINDOW_BORDER;
      wExamWindowArea      = EXAM_WINDOW_AREA;
      wExamWindowHighlight = EXAM_WINDOW_HIGHLIGHT;
      wMenuBar             = 0x70;
      wStatusBar           = 0x70;
    }

  /* Set the line adjust amount */
  if (wNmbrLines == 43)
    wLineAdj = 9;
  else if (wNmbrLines == 50)
    wLineAdj = 13;
  else
    wLineAdj = 0;

  BiosClearScreen (wExamBackground);

  /* Fake menu and status bar */
  BiosCharOutAt (' ', wMenuBar, 80, 0, 0);
  BiosStringOutAt ("  File  Utilities  Help", wMenuBar, 0, 0);
  BiosCharOutAt (' ', wStatusBar, 80, 0, wNmbrLines - 1);
  BiosStringOutAt ("MSD is examining your system", wStatusBar, 0, wNmbrLines - 1);


  /* Draw the information box */
  BiosDrawFilledBox (12, 4 + wLineAdj, 68, 19 + wLineAdj,
                     wExamWindowBorder, wExamWindowArea);

  BiosStringOutAt ("Microsoft (R) Diagnostics",
                   wExamWindowArea, 27, 6 + wLineAdj);
  BiosStringOutAt ("Version ",
                   wExamWindowArea, 33, 7 + wLineAdj);
  BiosStringOut (pszVersionNumber, wExamWindowArea);

  BiosStringOutAt ("Copyright (C) Microsoft Corporation, 1990-92",
                   wExamWindowArea, 17, 8 + wLineAdj);
  BiosStringOutAt ("All Rights Reserved",
                   wExamWindowArea, 30, 9 + wLineAdj);

  BiosStringOutAt ("The Microsoft Diagnostics are  designed  to  assist",
                   wExamWindowArea, 15, 11 + wLineAdj);
  BiosStringOutAt ("Microsoft Product Support  personnel  in  obtaining",
                   wExamWindowArea, 15, 12 + wLineAdj);
  BiosStringOutAt ("detailed technical information about your computer.",
                   wExamWindowArea, 15, 13 + wLineAdj);

  BiosStringOutAt ("Thank you for using Microsoft Products.",
                   wExamWindowArea, 20, 15 + wLineAdj);

#if 0
  BiosStringOutAt (paszCommandLineHelp[0],
                   wExamWindowArea, 5, 18 + wLineAdj);
#endif

  BiosStringOutAt ("MSD is examining your system ...",
                   wExamWindowHighlight, 23, 17 + wLineAdj);

  /* Put the cursor in the shadow */
  BiosLocate (14, 20 + wLineAdj);
}

#endif /* CW_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\tiga.h ===
/*-----------------------------------------------------------------------*/
/*                                  TIGA                                 */
/*  Copyright (C) 1988-1990  Texas Instruments  All Rights Reserved.     */
/*-----------------------------------------------------------------------*/
/*  TIGA - Header file                                                   */
/*-----------------------------------------------------------------------*/
/*                                                                       */
/*  file            tiga.h                                               */
/*                                                                       */
/*  description     This is the main include file defining TIGA core     */
/*                  primitives and should be included in every           */
/*                  Microsoft-C application that interfaces to TIGA.     */
/*                                                                       */
/*-----------------------------------------------------------------------*/
/*  03/10/89    Reordered command numbers                     G.Short    */
/*  04/23/90    Added _DOUBLE packet type defs                AB         */
/*-----------------------------------------------------------------------*/

/*----------------------------------------------------------------------*/
/*  Reference Host-side entry points                                    */
/*----------------------------------------------------------------------*/
extern          long  far _cdecl tiga_set(short);
extern          long  far _cdecl cp_alt(short,short,...);
extern          long  far _cdecl cp_alt_a(short,short,...);
extern          void  far _cdecl cp_cmd(short,short,...);
extern          void  far _cdecl cp_cmd_a(short,short,...);
extern          long  far _cdecl cp_ret(short,short,...);
extern          long  far _cdecl cp_ret_a(short,short,...);
extern          short far _cdecl create_alm(char far *,char far *);
extern          short far _cdecl create_esym(void);
extern          void  far _cdecl dm_cmd(short,short,...);
extern          long  far _cdecl dm_palt(short,short,void far *);
extern          void  far _cdecl dm_pcmd(short,short,...);
extern          void  far _cdecl dm_ipoly(short,short,...);
extern          long  far _cdecl dm_pget(short,short,void far *);
extern          void  far _cdecl dm_poly(short,short,short,void far *);
extern          long  far _cdecl dm_pret(short,short,...);
extern          void  far _cdecl dm_psnd(short,short,void far *);
extern          void  far _cdecl dm_pstr(short,void far *);
extern          long  far _cdecl dm_ptrx(short,short,void far *,short,void far *);
extern          long  far _cdecl dm_ret(short,short,...);
extern unsigned long  far _cdecl field_extract(unsigned long,unsigned short);
extern          void  far _cdecl field_insert(unsigned long,unsigned short,unsigned long);
extern          short far _cdecl flush_esym(void);
extern          void  far _cdecl get_memseg(unsigned long far *,unsigned long far *);
extern unsigned short far _cdecl get_modeinfo(short,void far *);
extern unsigned short far _cdecl get_msg(void);
extern unsigned long  far _cdecl get_vector(short);
extern unsigned short far _cdecl get_videomode(void);
extern unsigned short far _cdecl get_xstate(void);
extern          short far _cdecl gm_is_alive(void);
extern          void  far _cdecl gsp_execute(unsigned long);
extern          void  far _cdecl gsp2host(long,void far *,short,short);
extern          void  far _cdecl gsp2hostxy(long,long,void far *,long,short,short,short,short,short,short,short,short);
extern          short far _cdecl handshake(void);
extern          void  far _cdecl host2gsp(void far *,long,short,short);
extern          void  far _cdecl host2gspxy(void far *,long,long,long,short,short,short,short,short,short,short,short);
extern          short far _cdecl install_alm(char far *);
extern          short far _cdecl install_primitives(void);
extern          short far _cdecl install_rlm(char far *);
extern          void  far _cdecl install_usererror(void (far *)());
extern unsigned long  far _cdecl loadcoff(char far *);
extern          void  far _cdecl makename(char far *,char far *,unsigned short,char far *);
extern unsigned long  far _cdecl oem_init(unsigned long);
extern unsigned short far _cdecl read_hstadrh(void);
extern unsigned short far _cdecl read_hstadrl(void);
extern unsigned long  far _cdecl read_hstaddr(void);
extern unsigned short far _cdecl read_hstctl(void);
extern unsigned short far _cdecl read_hstdata(void);
extern unsigned short far _cdecl rstr_commstate(void);
extern unsigned short far _cdecl save_commstate(void);
extern          short far _cdecl set_config(short,short);
extern          void  far _cdecl set_curs_shape(unsigned long);
extern          void  far _cdecl set_curs_xy(short,short);
extern          void  far _cdecl set_memseg(unsigned long,unsigned long);
extern          void  far _cdecl set_msg(unsigned short);
extern          void  far _cdecl set_timeout(short);
extern unsigned long  far _cdecl set_vector(short,unsigned long);
extern          short far _cdecl set_videomode(unsigned short,unsigned short);
extern          void  far _cdecl set_xstate(unsigned short);
extern          void  far _cdecl synchronize(void);
extern          void  far _cdecl write_hstadrh(unsigned short);
extern          void  far _cdecl write_hstadrl(unsigned short);
extern          void  far _cdecl write_hstaddr(unsigned long);
extern          void  far _cdecl write_hstctl(unsigned short);
extern          void  far _cdecl write_hstdata(unsigned short);
extern          void  far * far _cdecl aux_command(unsigned short, void far *);
extern          void  far _cdecl setup_hostcmd( void far * );
extern          void  far _cdecl hook_init_pal(short,short,...);
extern unsigned long  far _cdecl hook_get_near(short,short,...);
extern          void  far _cdecl hook_get_pal(short,short,...);
extern          void  far _cdecl hook_set_pal(short,short,...);
extern          short far _cdecl hook_get_pal_e(short,short,...);
extern          short far _cdecl hook_set_pal_e(short,short,...);

/*----------------------------------------------------------------------*/
/*  Define "C" packet data types                                        */
/*----------------------------------------------------------------------*/
#define _WORD(a)                0,sizeof(short),(short)(a)
#define _SWORD(a)               2,sizeof(short),(short)(a)
#define _DWORD(a)               0,sizeof(long),(long)(a)
#define _DOUBLE(a)              4,sizeof(double),(double)(a)

#define _BYTE_PTR(a,b)          1,(short)((a) * sizeof(char)),(char far *)(b)
#define _WORD_PTR(a,b)          1,(short)((a) * sizeof(short)),(short far *)(b)
#define _DWORD_PTR(a,b)         1,(short)((a) * sizeof(long)),(long far *)(b)
#define _DOUBLE_PTR(a,b)        4+1,(short)((a) * sizeof(double)),(double far *)(b)
#define _STRING(a)              64+1,0,(char far *)(a)

#define _ALTBYTE_PTR(a,b)       128+1,(short)((a) * sizeof(char)),(char far *)(b)
#define _ALTWORD_PTR(a,b)       128+1,(short)((a) * sizeof(short)),(short far *)(b)
#define _ALTDWORD_PTR(a,b)      128+1,(short)((a) * sizeof(long)),(long far *)(b)
#define _ALTDOUBLE_PTR(a,b)     128+4+1,(short)((a) * sizeof (double)),(double far *)(b)

/*----------------------------------------------------------------------*/
/*  Define command number modifiers                                     */
/*----------------------------------------------------------------------*/
#define CORE_CP(a)              (a) | 0x7E00
#define CORE_DM(a)              (a) | 0x3E00
#define EXT_CP(a)               (a) | 0x7C00
#define EXT_DM(a)               (a) | 0x3C00
#define USER_CP(a)              (a) | 0x4000
#define USER_DM(a)              (a) | 0x0000

/*----------------------------------------------------------------------*/
/*  Core functions                                                      */
/*----------------------------------------------------------------------*/
#define ADD_INTERRUPT         CORE_CP( 0) 
#define DEL_INTERRUPT         CORE_CP( 1) 
#define FUNCTION_IMPLEMENTED  CORE_CP( 2) 
#define GET_COLORS            CORE_CP( 3) 
#define GET_CONFIG            CORE_CP( 4) 
#define SET_MODULE_STATE      CORE_CP( 5)
#define GSP_MAXHEAP           CORE_CP( 6) 
#define GET_OFFSCREEN_MEMORY  CORE_CP( 7) 
#define GET_PALET_ENTRY       CORE_CP( 8) 
#define GET_PMASK             CORE_CP( 9) 
#define GET_PPOP              CORE_CP(10) 
#define GET_TRANSP            CORE_CP(11) 
#define GET_WINDOWING         CORE_CP(12) 
#define GSP_CALLOC            CORE_CP(13) 
#define GSP_FREE              CORE_CP(14) 
#define GSP_MALLOC            CORE_CP(15) 
#define GSP_MINIT             CORE_CP(16) 
#define GSP_REALLOC           CORE_CP(17) 
#define INIT_CURSOR           CORE_CP(18) 
#define SET_CONFIG            CORE_CP(20) 
#define PAGE_FLIP             CORE_CP(21) 
#define SET_PALET             CORE_CP(22) 
#define TRANSP_OFF            CORE_CP(23) 
#define TRANSP_ON             CORE_CP(24) 
#define VIDEO_ENABLE          CORE_CP(25) 
#define GET_STATE             CORE_CP(26) 
#define CLEAR_SCREEN          CORE_DM(27) 
#define GET_NEAREST_COLOR     CORE_DM(28) 
#define GET_PALET             CORE_CP(29) 
#define GSP2GSP               CORE_DM(30) 
#define INIT_PALET            CORE_DM(31) 
#define LMO                   CORE_DM(32) 
#define PALLOC                CORE_DM(33) 
#define PEEK_BREG             CORE_DM(34) 
#define POKE_BREG             CORE_DM(35) 
#define RMO                   CORE_DM(36) 
#define SET_BCOLOR            CORE_DM(37) 
#define SET_COLORS            CORE_DM(38) 
#define SET_FCOLOR            CORE_DM(39) 
#define SET_INTERRUPT         CORE_CP(40) 
#define SET_PALET_ENTRY       CORE_DM(41) 
#define SET_PMASK             CORE_DM(42) 
#define SET_PPOP              CORE_DM(43) 
#define SET_WINDOWING         CORE_DM(44) 
#define SET_CLIP_RECT         CORE_DM(45) 
#define WAIT_SCAN             CORE_CP(46) 
#define SET_WKSP              CORE_DM(47) 
#define ADD_MODULE            CORE_CP(48) 
#define DEL_MODULE            CORE_CP(49) 
#define DEL_ALL_MODULES       CORE_CP(50) 
#define GET_ISR_PRIORITIES    CORE_CP(51) 
#define INIT_INTERRUPTS       CORE_CP(52) 
#define SET_CURS_SHAPE        CORE_DM(53) 
#define SET_CURS_STATE        CORE_DM(54) 
#define GET_CURS_STATE        CORE_CP(55) 
#define GET_CURS_XY           CORE_CP(56) 
#define FLUSH_EXTENDED        CORE_CP(57) 
#define PAGE_BUSY             CORE_CP(58) 
#define CLEAR_FRAME_BUFFER    CORE_DM(59) 
#define CLEAR_PAGE            CORE_DM(60) 
#define GET_WKSP              CORE_CP(61) 
#define CPW                   CORE_DM(62) 
#define INIT_TEXT             CORE_CP(63) 
#define TEXT_OUT              CORE_CP(64) 
#define GET_FONTINFO          CORE_CP(65) 
#define GET_MODULE            CORE_CP(66)
#define CVXYL                 CORE_DM(67)
#define SET_CURSATTR          CORE_DM(68)
#define COP2GSP               CORE_CP(69)
#define GSP2COP               CORE_CP(70)
#define SET_TRANSP            CORE_DM(71)
#define GET_TEXT_XY           CORE_CP(72)
#define SET_TEXT_XY           CORE_DM(73)
#define TEXT_OUTP             CORE_DM(74)
#define HBM_DEREF             CORE_CP(76)
#define HBM_SETMEMTYPE        CORE_CP(77)
#define HBM_ALLOC             CORE_CP(78)
#define HBM_FALLOC            CORE_CP(79)
#define HBM_FREE              CORE_CP(80)
#define HBM_TOTALFREE         CORE_CP(81)
#define HBM_MAXHEAP           CORE_CP(82)
#define HBM_COMPACT           CORE_CP(83)
#define HBM_REALLOC           CORE_CP(84)
#define HBM_FINDMEM           CORE_CP(85)
#define HBM_INIT              CORE_CP(86)
#define HBM_FINDHANDLE        CORE_CP(87)
#define SYM_OPEN              CORE_CP(90)
#define SYM_CLOSE             CORE_CP(91)
#define SYM_PUT               CORE_CP(92)
#define SYM_GET               CORE_CP(93)
#define SYM_FLUSH             CORE_CP(94)
#define SYM_INIT              CORE_CP(96)
#define HBM_CALLOC            CORE_CP(97)  
#define HBM_FCALLOC           CORE_CP(98)
#define FLUSH_MODULE          CORE_CP(99)

/*----------------------------------------------------------------------*/
/*  Reference Core C-Packet function definitions                        */
/*----------------------------------------------------------------------*/
#define add_interrupt(a,b)          \
        (short)cp_ret(ADD_INTERRUPT,2,_WORD(a),_DWORD(b))
#define del_interrupt(a)            \
        cp_cmd(DEL_INTERRUPT,1,_WORD(a))
#define set_interrupt(a,b,c,d)      \
        (short)cp_ret(SET_INTERRUPT,4,_WORD(a),_WORD(b),_WORD(c),_SWORD(d))
#define function_implemented(a)     \
        (short)cp_ret(FUNCTION_IMPLEMENTED,1,_WORD(a))
#define get_colors(a,b)             \
        (void)cp_alt(GET_COLORS,2,_ALTDWORD_PTR(1,a),_ALTDWORD_PTR(1,b))
#define get_config(a)               \
        (void)cp_alt(GET_CONFIG,1,_ALTBYTE_PTR(sizeof(CONFIG),a))
#define gsp_maxheap()               \
        cp_ret(GSP_MAXHEAP,0)
#define get_offscreen_memory(a,b)   \
        (void)cp_alt(GET_OFFSCREEN_MEMORY,2,_WORD(a),_ALTBYTE_PTR((a)*sizeof(OFFSCREEN_AREA),b))
#define get_palet_entry(a,b,c,d,e)  \
        hook_get_pal_e(GET_PALET_ENTRY,5,_DWORD(a),_ALTBYTE_PTR(1,b), \
                        _ALTBYTE_PTR(1,c), _ALTBYTE_PTR(1,d),_ALTBYTE_PTR(1,e))
#define get_palet(a,b)              \
        hook_get_pal(GET_PALET,2,_WORD(a),_ALTBYTE_PTR((a)*4,(b)))
#define get_pmask()                 \
        cp_ret(GET_PMASK,0)
#define get_ppop()                  \
        (unsigned short)cp_ret(GET_PPOP,0)
#define get_transp()                 \
        (short)cp_ret(GET_TRANSP,0)
#define get_windowing()             \
        (short)cp_ret(GET_WINDOWING,0)
#define gsp_calloc(a,b)             \
        cp_ret(GSP_CALLOC,2,_DWORD(a),_DWORD(b))
#define gsp_free(a)                 \
        (short)cp_ret(GSP_FREE,1,_DWORD(a))
#define gsp_malloc(a)               \
        cp_ret(GSP_MALLOC,1,_DWORD(a))
#define gsp_minit(a)                \
        cp_cmd(GSP_MINIT,1,_DWORD(a))
#define gsp_realloc(a,b)            \
        cp_ret(GSP_REALLOC,2,_DWORD(a),_DWORD(b))
#define init_cursor()               \
        cp_ret(INIT_CURSOR,0)
#define page_flip(a,b)              \
        cp_cmd(PAGE_FLIP,2,_WORD(a),_WORD(b))
#define set_palet(a,b,c)            \
        hook_set_pal(SET_PALET,3,_DWORD(a),_DWORD(b),_BYTE_PTR(4*(a),c))
#define transp_off()                \
        cp_cmd(TRANSP_OFF,0)
#define transp_on()                 \
        cp_cmd(TRANSP_ON,0)
#define add_module(a,b)             \
        cp_ret(ADD_MODULE,2,_SWORD(a),_BYTE_PTR(sizeof(MODULE),b))
#define get_state()                 \
        cp_ret(GET_STATE,0)
#define del_module(a)               \
        cp_ret(DEL_MODULE,1,_WORD(a))
#define del_all_modules()           \
        cp_cmd(DEL_ALL_MODULES,0)
#define wait_scan(a)                \
        (void)cp_ret(WAIT_SCAN,1,_WORD(a))
#define get_isr_priorities(a,b)     \
        (void)cp_alt(GET_ISR_PRIORITIES,2,_WORD(a),_ALTWORD_PTR(a,b))
#define get_curs_state()            \
        (short)cp_ret(GET_CURS_STATE,0)
#define get_curs_xy(a,b)            \
        (void)cp_alt(GET_CURS_XY,2,_ALTWORD_PTR(1,a),_ALTWORD_PTR(1,b))
#define flush_extended()            \
        cp_cmd(FLUSH_EXTENDED,0)
#define page_busy()                 \
        (short)cp_ret(PAGE_BUSY,0)
#define get_wksp(a,b)               \
        (short)cp_alt(GET_WKSP,2,_ALTDWORD_PTR(1,a),_ALTDWORD_PTR(1,b))
#define init_text()                 \
        cp_cmd(INIT_TEXT,0)
#define text_out(a,b,c)             \
        (short)cp_ret(TEXT_OUT,3,_SWORD(a),_SWORD(b),_STRING(c))
#define get_fontinfo(a,b)         \
        (short)cp_alt(GET_FONTINFO,2,_SWORD(a),_ALTBYTE_PTR(sizeof(FONTINFO),b))
#define get_module(a,b)             \
        cp_alt(GET_MODULE,2,_WORD(a),_ALTBYTE_PTR(sizeof(MODULE),b))
#define get_text_xy(a,b)            \
        (void)cp_alt(GET_TEXT_XY,2,_ALTWORD_PTR(1,a),_ALTWORD_PTR(1,b))
#define gsph_deref(a)                 \
        cp_ret(HBM_DEREF,1,_WORD(a))
#define gsph_memtype(a,b)          \
        cp_cmd(HBM_SETMEMTYPE,2,_WORD(a),_WORD(b))
#define gsph_alloc(a)                 \
        (unsigned short)cp_ret(HBM_ALLOC,1,_DWORD(a))
#define gsph_calloc(a,b)              \
        (unsigned short)cp_ret(HBM_CALLOC,2,_DWORD(a),_DWORD(b))
#define gsph_falloc(a,b,c)            \
        (unsigned short)cp_ret(HBM_FALLOC,3,_DWORD(a),_DWORD(b),_WORD(c))
#define gsph_fcalloc(a,b,c,d)         \
        (unsigned short)cp_ret(HBM_FCALLOC,4,_DWORD(a),_DWORD(b),_DWORD(c),_WORD(d))
#define gsph_free(a)                  \
        cp_cmd(HBM_FREE,1,_WORD(a))
#define gsph_maxheap()                \
        cp_ret(HBM_MAXHEAP,0)
#define gsph_compact(a)               \
        cp_cmd(HBM_COMPACT,1,_WORD(a))
#define gsph_realloc(a,b)             \
        cp_ret(HBM_REALLOC,2,_WORD(a),_DWORD(b))
#define gsph_findmem(a,b,c)               \
        (short)cp_alt(HBM_FINDMEM,3,_DWORD(a),_ALTWORD_PTR(1,b),_ALTBYTE_PTR(1,c))
#define gsph_init()                   \
        cp_cmd(HBM_INIT,0)
#define gsph_findhandle(a)            \
        (unsigned short)cp_ret(HBM_FINDHANDLE,1,_DWORD(a))
#define gsph_totalfree()              \
        cp_ret(HBM_TOTALFREE,0)
#define set_module_state(a,b)         \
        (short)cp_ret(SET_MODULE_STATE,2,_WORD(a),_WORD(b))
#define sym_init()                  \
        cp_cmd(SYM_INIT, 0)
#define sym_open(a)                 \
        cp_ret(SYM_OPEN, 1, _SWORD(a))
#define sym_close()                 \
        cp_cmd(SYM_CLOSE, 0)
#define sym_put(a,b)                \
        cp_ret(SYM_PUT, 2, _STRING(a), _DWORD(b))
#define sym_get(a)                  \
        cp_ret(SYM_GET, 1, _STRING(a))
#define sym_flush(a)                \
        (short)cp_ret(SYM_FLUSH, 1, _SWORD(a))
#define cop2gsp(a,b,c,d)    \
        cp_cmd(COP2GSP,4,_WORD(a),_DWORD(b),_DWORD(c),_DWORD(d))
#define gsp2cop(a,b,c,d)    \
        cp_cmd(GSP2COP,4,_WORD(a),_DWORD(b),_DWORD(c),_DWORD(d))
#define flush_module(a)     \
        (short)cp_ret(FLUSH_MODULE,1,_WORD(a))

/*----------------------------------------------------------------------*/
/*  Reference Core Direct-Mode function definitions                     */
/*----------------------------------------------------------------------*/
#define clear_screen(a)             \
        dm_cmd(CLEAR_SCREEN,2,(long)(a))
#define get_nearest_color(a,b,c,d)  \
        hook_get_near(GET_NEAREST_COLOR,4,(short)(a),(short)(b),(short)(c),(short)(d))
#define init_palet()                \
        hook_init_pal(INIT_PALET,0)
#define lmo(a)                      \
        (short)dm_ret(LMO,2,(long)(a))
#define peek_breg(a)                \
        dm_ret(PEEK_BREG,1,(short)(a))
#define poke_breg(a,b)              \
        dm_cmd(POKE_BREG,3,(short)(a),(long)(b))
#define rmo(a)                      \
        (short)dm_ret(RMO,2,(long)(a))
#define set_bcolor(a)               \
        dm_cmd(SET_BCOLOR,2,(long)(a))
#define set_colors(a,b)             \
        dm_cmd(SET_COLORS,4,(long)(a),(long)(b))
#define set_fcolor(a)               \
        dm_cmd(SET_FCOLOR,2,(long)(a))
#define set_palet_entry(a,b,c,d,e)  \
        hook_set_pal_e(SET_PALET_ENTRY,6,(long)(a),(short)(b),(short)(c),\
                             (short)(d),(short)(e))
#define set_pmask(a)                \
        dm_cmd(SET_PMASK,2,(long)(a))
#define set_ppop(a)                 \
        dm_cmd(SET_PPOP,1,(short)(a))
#define set_windowing(a)            \
        dm_cmd(SET_WINDOWING,1,(short)(a))
#define set_clip_rect(a,b,c,d)      \
        dm_cmd(SET_CLIP_RECT,4,(short)(a),(short)(b),(short)(c),(short)(d))
#define set_wksp(a,b)               \
        dm_cmd(SET_WKSP,4,(unsigned long)(a),(unsigned long)(b))
#define gsp2gsp(a,b,c)              \
        dm_cmd(GSP2GSP,6,(unsigned long)(a),(unsigned long)(b),(unsigned long)(c))
#define set_curs_state(a)           \
        dm_cmd(SET_CURS_STATE,1,(short)(a))
#define clear_frame_buffer(a)       \
        dm_cmd(CLEAR_FRAME_BUFFER,2,(long)(a))
#define clear_page(a)               \
        dm_cmd(CLEAR_PAGE,2,(long)(a))
#define cpw(a,b)                    \
        (short)dm_ret(CPW,2,(short)(a),(short)(b))
#define cvxyl(a,b)                  \
        dm_ret(CVXYL,2,(short)(a),(short)(b))
#define set_cursattr(a,b,c,d)       \
        dm_cmd(SET_CURSATTR,6,(unsigned long)(a),(unsigned long)(b),(unsigned short)(c),(unsigned short)(d))
#define set_transp(a)               \
        dm_cmd(SET_TRANSP,1,(short)(a))
#define set_text_xy(a,b)            \
        dm_cmd(SET_TEXT_XY,2,(short)(a),(short)(b))
#define text_outp(a)                \
        dm_pstr(TEXT_OUTP,(char far *)(a))

/*----------------------------------------------------------------------*/
/*  Arguments for tiga_set()                                           */
/*----------------------------------------------------------------------*/
#define CD_CLOSE         0
#define CD_OPEN          1
#define CD_STATUS        2
#define CD_NOT_INSTALLED -4

/*----------------------------------------------------------------------*/
/*  Arguments for set_videomode()                                      */
/*----------------------------------------------------------------------*/
/* Legal video modes */
#define TIGA            -1      
#define PREVIOUS        0        /* restore screen to original mode */
#define MDA             1
#define HERCULES        2
#define CGA             3
#define EGA             4
#define VGA             5
#define AI_8514         6
#define OFF_MODE        7           
/* Legal styles */
#define NO_INIT         0        /* generate entry to TSR only */
#define INIT_GLOBALS    1        /* initialize global variables, retain heap */
#define INIT            3        /* initialize globals and free all heap...  */
                                 /* including downloaded functions           */
#define INIT_GM         7        /* Re-initialize GM                         */
#define NO_ENABLE       0x4000   /* Do not enable the 340 display.           */
#define CLR_SCREEN      0x8000   /* clear the screen on entry to the mode    */

/*----------------------------------*/
/* Colors of the default TIGA palet */
/*----------------------------------*/
#define  BLACK          0
#define  BLUE           1
#define  GREEN          2
#define  CYAN           3
#define  RED            4
#define  MAGENTA        5
#define  BROWN          6
#define  LIGHT_GRAY     7
#define  DARK_GRAY      8
#define  LIGHT_BLUE     9
#define  LIGHT_GREEN    10
#define  LIGHT_CYAN     11
#define  LIGHT_RED      12
#define  LIGHT_MAGENTA  13
#define  YELLOW         14
#define  WHITE          15

/*----------------------------------*/
/* Memory System Equates            */
/*----------------------------------*/
#define TRUE    1
#define FALSE   0
#define BLK_DELETABLE   0x01    /* Block can be deleted */
#define BLK_LOCKED      0x02    /* Block is locked */
#define BLK_FUNCMOVE    0x04    /* Call block function on move */
#define BLK_FUNCDELETE  0x08    /* Call block function on purge */
#define BLK_SECURED     0x10    /* Block is secured memory */
#define BLK_INUSE       0x20    /* Block is allocated */

/*----------------------------------*/
/* Extended primitives module id    */
/* - parameter to sym_flush         */
/*----------------------------------*/
#define GRAPHICS_LIB_ID 0x3C00


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\version.h ===
#define LANGUAGE_USA 1 
/* -- Version control for Non-Swapped Cow */

#define	BLADE                   1

#define	BIGOVERLAP              1
#define	WIN_BTN		        1

/* Mouse control */
#define	MOUSE_EXTRAS		1	/* Mouse cursor is not graphical */
#define MOUSE_TEXT              1       /* Mouse cursor is not graphical */

/* Windowing/screen */
#define	SCREEN_FFONT		1	/* Screen "ffont" attributes */

/* Keyboard control */
#define	ACCEL_MULTIPLE		1	/* multiple items with same accelerator */

/* Menu customization */
#define	MULTIPLE_ACTION		1	/* multiple menu activation keys */
#define	SMM			1	/* use SMM interface */
#define	SMMEXT			1	/* use SMM interface */

/* Listbox customization */
#define	LISTBOX_DIR		1	/* DIR listboxes ? */
#define	LISTBOX_HORIZ		1	/* horizontal listbox support */
#define	LISTBOX_NOSCROLL	1	/* No scrollbars of fNoScroll is set */

/* Dialog customization */
#define	DIALOG_LINE		1	/* arrow key dialog navigation ? */
#define	DIALOG_NOSAVE		1	/* Don't save screen under dialogs */
#define	DIALOG_NAVIGATION	1	/* Don't save screen under dialogs */

/* Visual attributes */
#define	BUTTON_CENTER		1	/* center buttons in messagebox? */
#define	HELP_BUTTON		1	/* add help button support to dialogs */
#define	ADJUST_MSGBOX		1	/* adjust message box if flag set */

/* extra customizations */
#define	MSG_LIMIT_SIZE		1	/* Limit message queue size */
#define	DRAW_MODE_MINIMIZE	1	/* Eliminate unnecessary draw modes */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\typedefs.h ===
/*-----------------------------------------------------------------------*/
/*                                  TIGA                                 */
/*  Copyright (C) 1988-1990  Texas Instruments  All Rights Reserved.     */
/*-----------------------------------------------------------------------*/
/*  TIGA - Header file                                                   */
/*-----------------------------------------------------------------------*/
/*                                                                       */
/*  file            typedefs.h                                           */
/*                                                                       */
/*  description     This file contains type definitions used in          */ 
/*                  the Applications Interface.                          */
/*                  This file should be included in any Microsoft-C      */
/*                  program accessing data of these types.               */
/*                                                                       */
/*-----------------------------------------------------------------------*/

/*--------------------------------------------------------------------------*/
/*  Define integral data types                                              */
/*--------------------------------------------------------------------------*/
typedef unsigned char   uchar;
typedef unsigned short  ushort;
typedef unsigned long   ulong;
typedef unsigned long   PTR;
typedef uchar far       *HPTR;


/*--------------------------------------------------------------------------*/
/*  CURSOR structure definition                                             */
/*                                                                          */
/*      This structure contains cursor description information.             */
/*--------------------------------------------------------------------------*/
typedef struct 
{
    short   hot_x;      /* offset from top...  */
    short   hot_y;      /* ...left-hand corner */
    ushort  width;      /* array width         */
    ushort  height;     /* array height        */
    ushort  pitch;
    ulong   color;      /* color of cursor     */
    ushort  mask_rop;   /* cursor mask rop     */
    ushort  shape_rop;  /* cursor shape rop    */
    ulong   mask_color; /* color of cursor mask*/
    PTR     data;       /* pointer to cursor data in GSP memory */
} CURSOR;


/*--------------------------------------------------------------------------*/
/*  PATTERN structure definition                                            */
/*                                                                          */
/*      This structure contains pattern description information.            */
/*--------------------------------------------------------------------------*/
typedef struct 
{
    ushort  width;      /* width of pattern    */
    ushort  height;     /* height of pattern   */
    ushort  depth;      /* depth (bits/pixel)  */
    PTR     data;       /* address of pattern in GSP memory */
} PATTERN;

	        
/*--------------------------------------------------------------------------*/
/*  PALET structure definition                                              */
/*                                                                          */
/*      This structure contains the rgb and intensity components for a      */
/*      palette entry.                                                      */
/*--------------------------------------------------------------------------*/
typedef struct 
{
    uchar   r;
    uchar   g;
    uchar   b;
    uchar   i;
} PALET;


/*--------------------------------------------------------------------------*/
/*  OFFSCREEN structure definitions                                         */
/*                                                                          */
/*      These structures contain definitions of offscreen work areas        */
/*--------------------------------------------------------------------------*/
typedef struct 
{
    PTR     addr;   /* address in gsp space of an offscreen work area */
    ushort  xext;   /* x extension in the current screen pixel size   */
    ushort  yext;   /* y extension using default screen pitch         */
} OFFSCREEN_AREA;


/*--------------------------------------------------------------------------*/
/*  MODEINFO structure definition                                           */
/*                                                                          */
/*      This structure contains information pertaining to the current mode  */ 
/*      of operation.                                                       */
/*--------------------------------------------------------------------------*/
typedef struct
{
    ulong   disp_pitch;         /* display pitch y::x                   */
    ushort  disp_vres;          /* vertical resolution (pixels)         */
    ushort  disp_hres;          /* horizontal resolution (pixels)       */
    short   screen_wide;        /* screen width                         */
    short   screen_high;        /* screen height                        */
    ushort  disp_psize;         /* pixel size                           */
    ulong   pixel_mask;         /* pixel mask                           */
    ushort  palet_gun_depth;    /* # of bits per gun                    */    
    ulong   palet_size;         /* number of palette entries            */
    short   palet_inset;        /* offset from frame start to data      */ 
    ushort  num_pages;          /* number of display pages              */
    short   num_offscrn_areas;  /* number off offscreen work areas      */
    ulong   wksp_addr;          /* address of offscreen workspace       */
    ulong   wksp_pitch;         /* pitch of offscreen workspace         */
    ushort  silicon_capability; /* flag for VRAM block write etc.       */
    ushort  color_class;        /* Color Type Flags                     */
    ulong   red_mask;           /* Red Mask                             */
    ulong   green_mask;         /* Red Mask                             */
    ulong   blue_mask;          /* Red Mask                             */
    ushort  x_aspect;           /* Windows X Aspect                     */
    ushort  y_aspect;           /* Windows X Aspect                     */
    ushort  diagonal_aspect;    /* Windows Diagonal Aspect              */
} MODEINFO;


/*--------------------------------------------------------------------------*/
/*  CONFIG structure definition                                             */
/*                                                                          */
/*      This structure contains the current hardware operating              */
/*      configuration.                                                      */
/*--------------------------------------------------------------------------*/
typedef struct 
{
    ushort      version_number;
    ulong       comm_buff_size;
    ulong       sys_flags;
    ulong       device_rev;
    ushort      num_modes;
    ushort      current_mode;
    ulong       program_mem_start;
    ulong       program_mem_end;
    ulong       display_mem_start;
    ulong       display_mem_end;
    ulong       stack_size;
    ulong       shared_mem_size;
    HPTR        shared_host_addr;
    PTR         shared_gsp_addr;
    MODEINFO    mode;
} CONFIG;


/*--------------------------------------------------------------------------*/
/*  ENVIRONMENT structure definition                                        */
/*                                                                          */
/*      This structure contains the current values of environment global    */
/*      variables.                                                          */
/*--------------------------------------------------------------------------*/
typedef struct 
{
    ulong   xyorigin;      /* xy drawing origin      */
    ulong   pensize;       /* pensize height::width  */
    PTR     srcbm;         /* source bitmap struct   */
    PTR     dstbm;         /*   dest bitmap struct   */
    ulong   stylemask;     /* styled line patn mask  */
} ENVIRONMENT;


/*----------------------------------------------------------------------*/
/*  MODULE structure definition                                         */
/*                                                                      */
/*  This structure defines the data associated with a function module.  */
/*----------------------------------------------------------------------*/
typedef struct
{
    PTR     ListAddr;
    PTR     MallocAddr;
    ulong   MallocBytes;
    ushort  NumFuncs;
    ushort  Flags;
} MODULE;


/*----------------------------------------------------------------------*/
/*  FONT structure definition                                           */
/*                                                                      */
/*  This structure defines the data associated with a font              */
/*----------------------------------------------------------------------*/
typedef struct
{
    ushort magic;        /* font type code                               */
    long   length;       /* Length of font in bytes                      */
    char   facename[30];
    short  deflt;        /* ASCII code of default character              */
    short  first;        /* ASCII code of first character                */
    short  last;         /* ASCII code of last character                 */
    short  maxwide;      /* maximum character width                      */
    short  maxkern;      /* maximum character kerning amount             */
    short  charwide;     /* Width of characters (0 if proportional)      */
    short  avgwide;      /* Average width of characters                  */
    short  charhigh;     /* character height                             */
    short  ascent;       /* ascent (how far above base line)             */
    short  descent;      /* descent (how far below base line)            */
    short  leading;      /* leading (row bottom to next row top)         */
    long   rowpitch;     /* bits per row of char patterns                */
    long   oPatnTbl;     /* Bit offset to PatnTbl (from bof)             */
    long   oLocTbl;      /* Bit offset to LocTbl (from bof)              */
    long   oOwTbl;       /* Bit offset to OWTbl (from bof)               */
} FONT;

/*----------------------------------------------------------------------*/
/*  FONTINFO structure definition                                       */
/*----------------------------------------------------------------------*/
typedef struct
{
    char  facename[30];
    short deflt;        /* ASCII code of default character              */
    short first;        /* ASCII code of first character                */
    short last;         /* ASCII code of last character                 */
    short maxwide;      /* maximum character width                      */
    short avgwide;      /* Average width of characters                  */
    short maxkern;      /* Max character kerning amount                 */
    short charwide;     /* Width of characters (0=proportional)         */
    short charhigh;     /* character height                             */
    short ascent;       /* ascent (how far above base line)             */
    short descent;      /* descent (how far below base line)            */
    short leading;      /* leading (row bottom to next row top)         */
    PTR   fontptr;      /* address of font in gsp memory                */
    short id;           /* id of font (set at install time)             */
} FONTINFO;

/*--------------------------------------------------------------------------*/
/*  MONITORINFO10 structure definition                                      */
/*                                                                          */
/*      Note this definition is specific to the 34010                       */
/*      This structure contains video timing parameters.                    */
/*--------------------------------------------------------------------------*/
typedef struct
{
    ushort  hesync10;
    ushort  heblnk10;
    ushort  hsblnk10;
    ushort  htotal10;
    ushort  vesync10;
    ushort  veblnk10;
    ushort  vsblnk10;
    ushort  vtotal10;
    ushort  dpyctl10;
    ushort  screen_delay10;
    ushort  flags10;
} MONITORINFO10;

/*--------------------------------------------------------------------------*/
/*  PAGE10 structure definitions                                            */
/*                                                                          */
/*      Note this definition is specific to the 34010                       */
/*      These structures contain definitions used to implement multiple     */
/*      display pages.  The information in these structures is used to      */
/*      display a given page.                                               */
/*--------------------------------------------------------------------------*/
typedef struct 
{
    PTR     BaseAddr10;   /* Base address of start of page                */
    ushort  DpyStart10;   /* Value loaded in Display Start i/o register   */
    short   DummyPad10;   /* 16 bits to pad structure to power of 2 size  */
} PAGE10;      


/*--------------------------------------------------------------------------*/
/*  MONITORINFO20 structure definition                                      */
/*                                                                          */
/*      Note this definition is specific to the 34020                       */
/*      This structure contains video timing parameters.                    */
/*--------------------------------------------------------------------------*/
typedef struct
{
    ushort  vesync20;
    ushort  hesync20;
    ushort  veblnk20;
    ushort  heblnk20;
    ushort  vsblnk20;
    ushort  hsblnk20;
    ushort  vtotal20;
    ushort  htotal20;
    ushort  dpyctl20;
    ushort  dincl20;
    ushort  dinch20;
    ushort  heserr20;
    ushort  dpymsk20;
    ushort  screen_delay20;
    ushort  flags20;
} MONITORINFO20;

/*--------------------------------------------------------------------------*/
/*  PAGE20 structure definitions                                            */
/*                                                                          */
/*      Note this definition is specific to the 34020                       */
/*      These structures contain definitions used to implement multiple     */
/*      display pages.  The information in these structures is used to      */
/*      display a given page.                                               */
/*--------------------------------------------------------------------------*/
typedef struct 
{
    ulong   BaseAddr20; /* Base address of start of page                */
    ulong   DpyStart20; /* Value loaded in Display Start i/o register   */
} PAGE20;                 


/*----------------------------------------------------------------------*/
/*  AUX_CONFIG structure definition                                     */
/*----------------------------------------------------------------------*/
typedef struct
{
    unsigned short alt_video;
    unsigned short emulation;
    short          mem_mapped;
    struct   {
                 unsigned long   base;
                 unsigned long   range;
             } mem[8];
    short          io_mapped;
    struct   {
                 unsigned short  base;
                 unsigned short  range;
             } io[8];
} AUX_CONFIG;


/*----------------------------------------------------------------------*/
/*  GSP Function Call Back Initialization Structure Definition          */
/*----------------------------------------------------------------------*/
typedef struct
{
    char far       *host_buffer;
    unsigned long  gsp_buffer;
    unsigned short buffer_size;
    void           (far **host_commands)();
    short          command_count;
} HOST_INIT;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\video.c ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * VIDEO.C - Source file for determing video adapter information.
 ********************************************************************/


/* Include Files */

#include "msd.h"


/* Video Display Types */

PSZ  ppszDisplayName[] =
  {
    "",
    "TTL Monochrome",
    "CGA Monitor",
    "EGA Monitor",
    "VGA Monochrome",
    "VGA Color",
    "8514/A Display"
  };


/* Adapter Types (IBM) */

PSZ  ppszIbmName[] =
  {
    "None",
    "MDA",
    "CGA",
    "EGA",
    "MCGA",
    "VGA",
    "8514/A",
    "XGA",
    "TIGA"
  };

#define VIDEO_TYPE_CGA  2
#define VIDEO_TYPE_TIGA 8


/* Adapter Types (Hercules) */

PSZ  ppszHercName[] =
  {
    "Hercules or Compatible",
    "Hercules Graphics Card +",
    "Hercules InColor"
  };


/* List of Adapter Names */

PSZ  ppszAdapterNames[] =
  {
    "Unknown",
    "Hercules", "Cirrus", "Zenith", "Quadram", "Radius", "Mitsubishi",
    "Emerson", "Ogivar", "Tandy", "Olivetti", "US Video", "Persyst",
    "ALR ", "ATI ", "BTC ", "Boca", "Cardinal", "Chicony", "CompuAdd",
    "DFI ", "DTK ", "Focus", "GBM ", "Hewlett-Packard", "Hewlett Packard",
    "Leading Tech", "Lava", "Logos", "LSI ", "Matrox", "NEC ", "Orchid",
    "Packard Bell", "PC Brand", "PC Craft", "PC Tech", "Prism", "QDI",
    "RasterOps", "Sigma", "STB ", "Swan", "ViewSonic", "Wyse", "Wang",
    "Dieco", "Metheus", "Monolithic", "Packard Bell", "Bell",
    "Colorgraphics", "AST ",

    /* Chipset makers */
    "Ahead", "Appian", "Oak ", "Sigma", "Video Seven", "Video-7", "Genoa",
    "Chips and Tech", "Tseng", "Tecmar", "Paradise", "NEC ", "ATI ",
    "Everex", "Phoenix", "Award", "Compaq", "Quadtel", "Headland",
    "Trident", "Western Digital", "MaxLogic", "Diamond", "AMI ", "PCG ",
    "Tatung", "Amdek", "AST ",
    NULL
  };



#define VID_NAME_HERCULES   1


/* List of Adapter Models */

PSZ  ppszAdapterModels[] =
  {
    "",
    "FastWrite", "V-RAM", "Z449", "Z549", "Workstation", "QuadVGA",
    "Wizard", "Enhancer", "Integra", "VGAudio", "VideoFlex", "SpeedSTAR",
    "Viewpoint TC", "Viewpoint", "Vision", "2theMax", "Mirage",
    "Splitword", "Graphics Station", "Ultra", "MaxVGA", "Ultimate",
    "UltraVGA", "MicroPAQ", "ProDesigner IIs", "ProDesigner II", "Photon",
    "Plus", "Supra", "Basic", "Elite", "Legend", "PowerGraph",
    "PowerView", "Spectrum", "VGA Professional", "Paradise",
    "VRAM II", "VRAM", "Hi-Rez",
    "Super VGA+", "SuperVGA", "Super VGA", "1024i", "Vega VGA", "VEGA",
    "OVGA", "PVGA", "RVGA", "SVGA", "TVGA", "EGA2 ", "VGA2 ",
    "VGA+", "SVGA", "8514/A", "8514A", "8514", "DVGA ", "MVGA",
    "VGA III", "VGA II", "MEGA", "PEGA", "SEGA", "VEGA Deluxe",
    "VEGA",
    NULL
  };


/*********************************************************************
 * GetVideoInfo - Gets the video adapter information.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL GetVideoInfo (VIDEO_STRUCT *pVideo, BOOL fMinimumInfo)
{
  union  REGS inregs, outregs;  /* Register structures for int86()   */
  struct SREGS sregs;           /* Segment register structure        */
  WORD   i;                     /* Local WORD variable               */


  {
    /* Get Adapter Type */

    /* Detect video subsystems using videoid.asm. After this call    */
    /*   the fields Subsystem and Display in the structure pointed   */
    /*   to by pVideo are set to reflect the video type of a primary */
    /*   and secondary video adapter                                 */

    /* VIDEOID.ASM from Programmer's Library, page 511 of   */
    /*   Programmer's Guide to PC and PS/2 Video Systems by */
    /*   Richard Wilton                                     */

    VideoID ((VIDEO_STRUCT FAR *) pVideo);

    /* Put the higher end display first */
    if (pVideo->bSubsystem0 < 80 && pVideo->bSubsystem1 < 80)
      if (pVideo->bSubsystem0 < pVideo->bSubsystem1)
        {
          BYTE bHold;   /* Hold value for swapping */

          bHold               = pVideo->bSubsystem0;
          pVideo->bSubsystem0 = pVideo->bSubsystem1;
          pVideo->bSubsystem1 = bHold;
        }


    /* TIGA detection */
    GetTigaInfo (pVideo);

    strcpy (pVideo->szAdapterType, SubsystemName(pVideo->bSubsystem0));
  }

  {
    /* Get Adapter Name */

    i = GetRomName (GET_VIDEO_NAME, ppszAdapterNames);
    strcpy (pVideo->szAdapterName, ppszAdapterNames[i]);
    pVideo->wAdapterName = i;

    /* If this was a Hercules Graphics Card + or a Hercules InColor card */
    /*   set the Manufacturer Name to "Hercules"                         */

    if (i == 0 && (pVideo->bSubsystem0 == 0x81 ||
        pVideo->bSubsystem0 == 0x82))
      {
        strcpy (pVideo->szAdapterName, ppszAdapterNames[VID_NAME_HERCULES]);
        pVideo->wAdapterName = VID_NAME_HERCULES;
      }
  }

  {
    /* Get Adapter Model */

    i = GetRomName (GET_VIDEO_MODEL, ppszAdapterModels);
    strcpy (pVideo->szAdapterModel, ppszAdapterModels[i]);
    pVideo->wAdapterModel = i;
  }

  {
    /* Get VESA version information */

    BYTE  bBuffer[256];          /* 256 byte buffer for VESA information */
    BYTE  FAR *fbByte = NULL;    /* Pointer to the BYTE buffer           */
    CHAR  FAR *fpChar = NULL;    /* Far CHAR pointer (to get OEM name)   */
    DWORD FAR *fpdwDword = NULL; /* Far DWORD pointer (to get OEM name)  */


    fbByte = (BYTE FAR *) bBuffer;

    /* Clear out the VESA OEM Name */

    pVideo->szVesaOemName[0] = '\0';


    /* Call the VESA "Get Information" call */

    inregs.x.ax = 0x4F00;
    sregs.es    = FP_SEG (fbByte);
    inregs.x.di = FP_OFF (fbByte);

    int86x (0x10, &inregs, &outregs, &sregs);

    /* Determine if this card is a VESA card */

    if (memcmp ((CHAR *) bBuffer, "VESA", 4) == 0)
      {
        pVideo->bVesaVersionMajor = bBuffer[5];
        pVideo->bVesaVersionMinor = bBuffer[4];

        /* Point to the OEM name */
        fpdwDword = (DWORD FAR *) &bBuffer[6];
        fpChar    = (CHAR FAR *) *fpdwDword;

        /* Copy the OEM name into the structure */
        if (fpChar != NULL)
          {
            for (i = 0; i < MAX_VESA_OEM_NAME - 1 &&
                        fpChar[i] >= ' ' && fpChar[i] <= 127; ++i)
              pVideo->szVesaOemName[i] = fpChar[i];

            pVideo->szVesaOemName[i] = '\0';
          }
      }
    else
      {
        pVideo->bVesaVersionMajor = 0;
        pVideo->bVesaVersionMinor = 0;
      }
  }

  {
    /* If mimimum information requested, return now */

    if (fMinimumInfo)
      return (FALSE);
  }

  {
    /* Get the display type */

    strcpy (pVideo->szDisplayType, DisplayName(pVideo->bDisplay0));
  }

  {
    /* Get the secondary adapter type */

    strcpy (pVideo->sz2ndAdapterType, SubsystemName(pVideo->bSubsystem1));
  }

  {
    /* The following interrupt gets the display mode in AL, the     */
    /*   number of columns in AH, and the active video display page */
    /*   in BH as mentioned on pg 196 of the PC SourceBook -- for   */
    /*   ALL monitor types                                          */

    inregs.h.ah=0x0F;
    int86(0x10,&inregs,&outregs);
    pVideo->bMode0 = outregs.h.al;
    pVideo->bNmbrCols0 = outregs.h.ah;
  }

  {
    /* The following interrupt gets the active video display page as   */
    /*   mentioned on pg 525 of Advanced MSDOS -- for EGA and VGA ONLY */

    inregs.h.ah=0x12;
    inregs.h.bl=0x10;
    int86(0x10,&inregs,&outregs);
    pVideo->wMemory0 = outregs.h.bl;
  }

  {
    /* Set the the number of rows on the display */

    BYTE FAR * fbByte = NULL;  /* Far pointer to a byte */

    /* Point to the location of the number of rows on the display */
    fbByte = (BYTE FAR *) 0x00400084;

    if (pVideo->bSubsystem0 > VIDEO_TYPE_CGA && pVideo->bSubsystem0 < 0x80)
      pVideo->bNmbrRows = fbByte[0] + (BYTE) 1;
    else
      pVideo->bNmbrRows = 25;
  }

  {
    /* Get the Video BIOS Date and Version, if it exists */

    BYTE FAR * fbRomSignature = NULL;  /* Location of the ROM Signature */


    /* Set the location for the video card's ROM BIOS */

    fbRomSignature = (BYTE FAR *) 0xC0000000;


    /* 55H AAH are the ROM signature bytes, followed by the ROM */
    /*   length / 512                                           */

    if (fbRomSignature[0] != 0x55 || fbRomSignature[1] != 0xAA)
      {
        fbRomSignature = (BYTE FAR *) 0xE0000000;

        if (fbRomSignature[0] != 0x55 && fbRomSignature[1] != 0xAA)
          fbRomSignature = (BYTE FAR *) 0x00000000;
      }

    if (fbRomSignature)
      {
        /* Get Video ROM Date */

        GetRomDate (fbRomSignature, ((WORD) fbRomSignature[2]) << 9,
                    pVideo->szVideoBiosDate);

        /* Get Video ROM Version */

        GetRomVersion (pVideo->aszVideoBiosVersion,
                       fbRomSignature, ((WORD) fbRomSignature[2]) << 9);
      }
    else
      {
        /* Clear out the BIOS date and version strings */

        pVideo->szVideoBiosDate[0] = '\0';

        for (i = 0; i < MAX_BIOS_VERSION_STRINGS; ++i)
          pVideo->aszVideoBiosVersion[i][0] = '\0';
      }
  }

  return (FALSE);
}


/*********************************************************************
 * SprintVideoInfo - Put video information into a set of strings to be
 *                   printed or displayed.
 *
 * pVideo       - Pointer to video information structure.
 * szSumStrings - Summary string area.
 *
 * Returns:  NULL if an error occured.
 *********************************************************************/

QSZ * SprintVideoInfo (VIDEO_STRUCT *pVideo,
                       CHAR szSumStrings[][MAX_SUMM_INFO + 5])
{
  WORD wNmbrStrings;        /* Number of strings                     */
  WORD wNmbrChars;          /* Number of characters in the strings   */
  WORD wIndex;              /* Index to the structure of TSR data    */
  WORD i;                   /* Looping variable                      */
  QSZ  *pqszStrings = NULL; /* Location for storing string pointers  */


  /* Summary Strings */
  if (szSumStrings != NULL)
    {
      /* Adapter Type (CGA/EGA/VGA/etc) */
      strncpy (szSumStrings[0], pVideo->szAdapterType, MAX_SUMM_INFO);
      strncat (szSumStrings[0], pszCommaSpace,
               MAX_SUMM_INFO - strlen (szSumStrings[0]));

      /* Adapter Manufacturer */
      if (pVideo->szAdapterName[0] != '\0')
        strncat (szSumStrings[0], pVideo->szAdapterName,
                 MAX_SUMM_INFO - strlen (szSumStrings[0]));

      /* Adapter Model */
      strncpy (szSumStrings[1], pVideo->szAdapterModel, MAX_SUMM_INFO);

      return (NULL);
    }


  /* Overestimate the amount of space required for the strings */

  wNmbrStrings = 20;
  wNmbrChars   = sizeof (VIDEO_STRUCT) +
                 (wNmbrStrings * MAX_VIDEO_TITLE_LENGTH) + 50;


  /* Allocate space for the pointer area and string area */
  pqszStrings = AllocStringSpace (wNmbrStrings, wNmbrChars);
  if (pqszStrings == NULL)
    return (NULL);



  /* Put the information in place */

  for (i = 0, wIndex = 0; paszVideoTitles[wIndex] != NULL ; ++i, ++wIndex)
    {
      WORD wIndent;                       /* Amount to indent       */
      CHAR chBuffer[MAX_VESA_OEM_NAME];   /* Buffer for string data */
      PSZ  pszString = NULL;              /* String pointer         */


      /* Title for this line of data */

      wIndent = MAX_VIDEO_TITLE_LENGTH -
                strlen (paszVideoTitles[wIndex]);

      Qmemset (pqszStrings[i], ' ', wIndent);

      Qstrcpy (&pqszStrings[i][wIndent], paszVideoTitles[wIndex]);


      /* Place the appropriate information on the line */

      switch (wIndex)
        {
          case VID_ADAPTER_TYPE:
            pszString = pVideo->szAdapterType;
            break;

          case VID_NAME:
            pszString = pVideo->szAdapterName;
            break;

          case VID_MODEL:
            pszString = pVideo->szAdapterModel;
            break;

          case VID_DISPLAY_TYPE:
            pszString = pVideo->szDisplayType;
            break;

          case VID_MODE:
            sprintf (chBuffer, "%d", pVideo->bMode0);
            pszString = chBuffer;
            break;

          case VID_NMBR_COLUMNS:
            sprintf (chBuffer, "%d", pVideo->bNmbrCols0);
            pszString = chBuffer;
            break;

          case VID_NMBR_ROWS:
            sprintf (chBuffer, "%d", pVideo->bNmbrRows);
            pszString = chBuffer;
            break;

          case VID_BIOS_VERSION_1:
            pszString = pVideo->aszVideoBiosVersion[0];

            /* Skip blank BIOS version lines */
            if (pVideo->aszVideoBiosVersion[1][0] == '\0')
              wIndex += 2;
            break;

          case VID_BIOS_VERSION_2:
            pszString = pVideo->aszVideoBiosVersion[1];

            /* Skip blank BIOS version lines */
            if (pVideo->aszVideoBiosVersion[2][0] == '\0')
              ++wIndex;
            break;

          case VID_BIOS_VERSION_3:
            pszString = pVideo->aszVideoBiosVersion[2];
            break;

          case VID_BIOS_DATE:
            pszString = pVideo->szVideoBiosDate;
            break;

          case VID_VESA_COMPAT:
            if (pVideo->bVesaVersionMajor == 0 &&
                pVideo->bVesaVersionMinor == 0)
              {
                pszString = pszNo;
                wIndex += 2;
              }
            else
              pszString = pszYes;
            break;

          case VID_VESA_VERSION:
            sprintf (chBuffer, "%X.%02X", pVideo->bVesaVersionMajor,
                     pVideo->bVesaVersionMinor);
            pszString = chBuffer;
            break;

          case VID_VESA_OEM:
            pszString = pVideo->szVesaOemName;
            break;

          case VID_2NDARY_ADAPTER:
            pszString = pVideo->sz2ndAdapterType;
            if (pVideo->wTigaInterrupt == 0)
              wIndex += 2;
            break;

          case VID_TIGA_VERSION:
            sprintf (chBuffer, "%d.%02d", pVideo->wTigaMajor,
                     pVideo->wTigaMinor);
            pszString = chBuffer;
            break;

          case VID_TIGA_INT:
            sprintf (chBuffer, "%XH / %04X:%04X ", pVideo->wTigaInterrupt,
                     FP_SEG (pVideo->dwTigaIntAddress),
                     FP_OFF (pVideo->dwTigaIntAddress));

            /* Mention if the signature was found */
            if (pVideo->fTigaSignatureFound == TRUE)
              strcat (chBuffer, "TIGA Signature Found");
            else if (pVideo->fTigaSignatureFound == FALSE)
              strcat (chBuffer, "TIGA Signature Not Found");

            pszString = chBuffer;
            break;

          default:
            pszString = "";
        }

      /* Put the information on the line */
      Qstrcat (pqszStrings[i], pszString);

      /* Set the next pointer */
      PrepNextString (pqszStrings, i);
    }

  /* Set the last pointer to NULL */

  pqszStrings[i] = NULL;

  /* Return the pointer to pqszStrings */

  return (pqszStrings);
}


/*********************************************************************
 * SubsystemName - This function returns the type of video adapter.
 *********************************************************************/

PSZ  SubsystemName (BYTE bType)
{
  if (bType & 0x80)
    return (ppszHercName[bType & 0x7F]);
  else
    return (ppszIbmName[bType]);
}


/*********************************************************************
 * DisplayType - This function returns the type of display.
 *********************************************************************/

PSZ  DisplayName (BYTE bType)
{
  return (ppszDisplayName[bType]);
}


/*********************************************************************
 * GetTigaInfo - Determines the TIGA driver information.
 *
 * pVideo - Video information structure
 *
 * Returns:  TRUE if the TIGA communications driver (CD) is found.
 *********************************************************************/

BOOL GetTigaInfo (VIDEO_STRUCT *pVideo)
{
  PSZ  pszTigaEnvString;    /* Pointer to TIGA environment variable */
  PSZ  pszIntIdent;         /* Interrupt number identifier          */
  WORD wTigaIntNumber;      /* TIGA CD interrupt number             */
  union REGS regs;          /* Registers for int86 call             */
  struct SREGS sregs;       /* Segment regs for int86x     */
  CHAR FAR *fpszSignature;  /* pointer to signature "TIGA" */


  /* Get the TIGA environment string */
  pszTigaEnvString = getenv ("TIGA");
  if (pszTigaEnvString == NULL)
    return (FALSE);


  /* Find the interrupt number */
  pszIntIdent = strstr (pszTigaEnvString, " -i0");
  if (pszIntIdent != NULL)
    {
      /* Parse for the interrupt number */
      sscanf (&pszIntIdent[5], "%x", &wTigaIntNumber);
    }
  else
    wTigaIntNumber = 0x7F;

  /* Set the interrupt number in the struture */
  pVideo->wTigaInterrupt = wTigaIntNumber;


  /* Get the interrupt address */
  regs.h.ah = 0x35;
  regs.h.al = (BYTE) wTigaIntNumber;
  int86x (0x21, &regs, &regs, &sregs);
  pVideo->dwTigaIntAddress = ((DWORD) sregs.es << 16) + regs.x.bx;

  if (sregs.es == 0 && regs.x.bx == 0)
    return (FALSE);


  /* Determine if the TIGA CD is installed and operating */
  regs.x.ax = 0x4321;
  int86 (wTigaIntNumber, &regs, &regs);

  /* AX == 0 if TIGA CD is installed */
  if (regs.x.ax == 0)
    {
      /* Obtain the TIGA version */
      regs.h.ah = 1;
      int86 (wTigaIntNumber, &regs, &regs);

      if (regs.x.bx != 0x1234)
        {
          /* BX != 0x1234 means TIGA 1.1 */
          pVideo->wTigaMajor          = 1;
          pVideo->wTigaMinor          = 1;
          pVideo->fTigaSignatureFound = 0xFFFF;
        }
      else
        {
          /* Otherwise, the TIGA version number is in CH.CL (decimal) */
          pVideo->wTigaMajor = (WORD) regs.h.ch;
          pVideo->wTigaMinor = (WORD) regs.h.cl;
        }

      /* Look for the "TIGA\0" signature at the interrupt address. */
      /*   (Only valid for TIGA 2.2 and above)                     */
      if (pVideo->wTigaMajor * 100 + pVideo->wTigaMinor >= 220)
        {
          /* Point to the signature */
          fpszSignature = (CHAR FAR *) pVideo->dwTigaIntAddress + 2;
          if (_fmemcmp (fpszSignature, "TIGA", 5) == 0)
            pVideo->fTigaSignatureFound = TRUE;
          else
            pVideo->fTigaSignatureFound = FALSE;
        }
      else
        pVideo->fTigaSignatureFound = 0xFFFF;


      /* Set the highest class of display adapter into the */
      /*   Secondary Display field.                        */
      if ((WORD) (pVideo->bSubsystem1) ^ 0x180 <
          (WORD) (pVideo->bSubsystem0 ^ 0x180))
        pVideo->bSubsystem1 = pVideo->bSubsystem0;

      pVideo->bSubsystem0 = VIDEO_TYPE_TIGA;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\viewfile.c ===
/**********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * VIEWFILE.C - Source file for viewing a file.
 *********************************************************************/


/* Include Files */

#include "msd.h"


/*********************************************************************
 * ViewFile - Views the specified file.
 *
 * pszFilename - Filename to view.
 * fHexDump    - TRUE if a hex dump is requested.
 *
 * Returns: Pointer to the array of strings, NULL if an error occured.
 *********************************************************************/

QSZ * ViewFile (PSZ pszFilename, BOOL fHexDump)
{
  INT  iReturnValue;  /* Return Value from ReadLine               */
  QSZ  *pqszStrings;  /* Pointer to string pointer array          */
  WORD wNmbrStrings;  /* Number of string pointers available      */
  WORD wNmbrChars;    /* Number of character pointers available   */
  WORD wCharCount = 0;/* Total number of chars stored in memory   */
  WORD wLineCount = 1;/* Total number of lines stored in memory   */
  WORD i = 0;         /* Looping variable                         */
  FILE *fileInput;    /* File to view                             */
  CHAR chBuffer[REPORT_WIDTH + 1];  /* Input buffer               */
  QSZ *pqszNewPointer;/* Stores return from realloc               */
  QSZ qszNewPointer;  /* Stores return from Qexpand               */


  /* Allocate almost all of the available memory */
  wNmbrStrings = 1;
  wNmbrChars   = 65500;

  pqszStrings = calloc (wNmbrStrings + 1, sizeof (QSZ));
  if (pqszStrings == NULL)
    {
      OutOfMemory();
      return (NULL);
    }

  for (pqszStrings[0] = NULL;
       pqszStrings[0] == NULL && wNmbrChars > 100;
       wNmbrChars -= 100)
    {
      pqszStrings[0] = Qmalloc (wNmbrChars);
    }

  if (pqszStrings[0] == NULL)
    {
      free (pqszStrings);
      OutOfMemory();
      return (NULL);
    }

  /* Read the file */
  fileInput = OpenFile (pszFilename, "rb", TRUE);

  if (fileInput == NULL)
    {
      FreeStringSpace (pqszStrings);
      return (NULL);
    }

  while ((iReturnValue = ReadLine (chBuffer,
                                   REPORT_WIDTH,
                                   fileInput,
                                   FALSE))        != EOF)
    {
      wCharCount += (WORD) iReturnValue;
      ++wLineCount;

      /* Allocate room for a new pointer */
      pqszNewPointer = realloc (pqszStrings, (wLineCount + 1) * sizeof (QSZ));
      if (pqszNewPointer == NULL)
        {
          ShowError (MB_OK | 0x8000, "Insufficient memory to read entire file",
                     pszFilename, NULL);
          break;
        }
      else
        pqszStrings = pqszNewPointer;

      /* Allocate room for the new line */
      qszNewPointer = Qexpand (pqszStrings[0], wCharCount);
      if (qszNewPointer == NULL)
        {
          ShowError (MB_OK | 0x8000, "Insufficient memory to read entire file",
                     pszFilename, NULL);
          break;
        }
      else
        pqszStrings[0] = qszNewPointer;

      Qstrcpy (pqszStrings[i], chBuffer);

      PrepNextString (pqszStrings, i++);
    }

  /* The last string must be a NULL pointer */
  pqszStrings[i] = NULL;


  /* Close the file */
  CloseFile (fileInput);


  return (pqszStrings);
}


/*********************************************************************
 * FindAndViewFile - Finds and views the specified file.
 *
 * pszFilename  - Filename to find and view.
 * fSearchFlags - Flags to use when searching.
 * fHexDump     - TRUE if a hex dump is requested.
 *
 * Returns:  TRUE if an error occured.
 *********************************************************************/

BOOL FindAndViewFile (PSZ pszFilename, BOOL fSearchFlags, BOOL fHexDump)
{
  FILE_INFO FAR * ffi;        /* File Information structure             */
  FILE_INFO FAR * ffi2;       /* 2nd File Information structure         */
  CHAR chBuffer[_MAX_PATH];   /* Local storage for fully qualified path */
  QSZ  *pqszStrings;          /* String array for file contents         */
  PWND pwndReturnValue;       /* Return value from CreateInfoWnd        */


  /* Inform the user that we are searching */
  DisplayStatus (ST_SEARCHING);

  /* Find the requested file */
  ffi = FindFile (pszFilename, NULL, fSearchFlags, '\0');

#if HEAP_DEBUG
  HeapCheck ("After FindFile");
#endif

  /* Return TRUE if no files were found */
  if (ffi == NULL || ffi->fpNextFileInfo == NULL)
    {
      FreeFileInfo (ffi);
      PostMessage (pwndStatusLine, WM_PAINT, NULL, NULL);
      return (TRUE);
    }

  /* Did we find more than one file */
  ffi2 = (FILE_INFO FAR *) ffi->fpNextFileInfo;
  if (ffi2->fpNextFileInfo != NULL)
    {
      pfiDlg = (FILE_INFO FAR *) ffi;
      if (DialogBox (&dlgViewWhichFile, ViewWhichFileDlg) == IDOK)
        strcpy (chBuffer, pszInsertFilename);
      else
        {
          FreeFileInfo (ffi);
          PostMessage (pwndStatusLine, WM_PAINT, NULL, NULL);
          return (TRUE);
        }
    }
  else
    {
      /* Single file -- put the filename into chBuffer */
      _fstrcpy (chBuffer, ffi->fpszPathToFile);
    }

  FreeFileInfo (ffi);

#if HEAP_DEBUG
  HeapCheck ("After FreeFileInfo");
#endif

  /* Read the file */
  pqszStrings = ViewFile (chBuffer, fHexDump);
  if (pqszStrings == NULL)
    {
      PostMessage (pwndStatusLine, WM_PAINT, NULL, NULL);
      return (TRUE);
    }

#if HEAP_DEBUG
  HeapCheck ("After ViewFile");
#endif

  /* Display the file in an Info Window */
  pwndReturnValue = CreateInfoWnd (chBuffer, pqszStrings, FALSE);

#if HEAP_DEBUG
  HeapCheck ("After CreateInfoWnd");
#endif

  PostMessage (pwndStatusLine, WM_PAINT, NULL, NULL);

  if (pwndReturnValue == NULL)
    return (TRUE);
  else
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\winapi.h ===
/*******************************************************************************
	CW: Character Windows
	
	winapi.h	: Windows compatible API's. 

	21-May-91 MWP : Created. For inclusion in BROADSWORD only.


******************************************************************************/
#ifdef BROADSWORD



typedef unsigned short	HANDLE;
typedef unsigned short	HMODULE;


// The following code is intended to provide mapping between Windows and
// CW constructs.


// For Windows compatability, we need a HDC type. For CW, DC's don't
// really exist, so we use the PWND instead.


typedef WORD HICON;

typedef WORD HCURSOR;

typedef struct _point
	{
	int	x;
	int	y;
	} POINT;

typedef POINT	*PPOINT;
typedef POINT NEAR	*NPOINT;
typedef POINT FAR		*LPPOINT;


typedef DWORD COLORREF;

#define RGB(r,g,b)  ((DWORD)(((BYTE)(r) | ((WORD)((g) & 0xffL ) << 8) ) | (((DWORD)(BYTE)((b) & 0xffL))<<16)))


#define GetRValue(rgb)	    ((BYTE)(rgb))
#define GetGValue(rgb)	    ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)	    ((BYTE)((rgb)>>16))

typedef struct tagCREATESTRUCT
  {
    LPSTR	lpCreateParams;
    HANDLE	hInstance;
    HANDLE	hMenu;
    HWND	hwndParent;
    int 	cy;
    int 	cx;
    int 	y;
    int 	x;
    WORD	style;
    LPSTR	lpszName;
    LPSTR	lpszClass;
    WORD		dwExStyle;
  } CREATESTRUCT;

typedef CREATESTRUCT FAR    *LPCREATESTRUCT;

#ifndef NOSCROLL


// Scroll Bar Constants

#define SB_HORZ	0
#define SB_VERT	1
#define SB_CTL		2
#define SB_BOTH	3

#endif


#ifndef NOSYSMETRICS

/* GetSystemMetrics() codes */
#define SM_CXSCREEN	    0
#define SM_CYSCREEN	    1
#define SM_CXVSCROLL	    2
#define SM_CYHSCROLL	    3
#define SM_CYCAPTION	    4
#define SM_CXBORDER	    5
#define SM_CYBORDER	    6
#define SM_CXDLGFRAME	    7
#define SM_CYDLGFRAME	    8
#define SM_CYVTHUMB	    9
#define SM_CXHTHUMB	    10
#define SM_CXICON	    11
#define SM_CYICON	    12
#define SM_CXCURSOR	    13
#define SM_CYCURSOR	    14
#define SM_CYMENU	    15
#define SM_CXFULLSCREEN     16
#define SM_CYFULLSCREEN     17
#define SM_CYKANJIWINDOW    18
#define SM_MOUSEPRESENT     19
#define SM_CYVSCROLL	    20
#define SM_CXHSCROLL	    21
#define SM_DEBUG	    22
#define SM_SWAPBUTTON	    23
#define SM_RESERVED1	    24
#define SM_RESERVED2	    25
#define SM_RESERVED3	    26
#define SM_RESERVED4	    27
#define SM_CXMIN	    28
#define SM_CYMIN	    29
#define SM_CXSIZE	    30
#define SM_CYSIZE	    31
#define SM_CXFRAME	    32
#define SM_CYFRAME	    33
#define SM_CXMINTRACK	    34
#define SM_CYMINTRACK	    35
#define SM_CMETRICS	    36

int FAR PASCAL GetSystemMetrics(int);

#endif /* NOSYSMETRICS */

/************
#define SM_CXSCREEN        80 // (VideoInfo.width)
#define SM_CYSCREEN        25 // (VideoInfo.length)
#define SM_MOUSEPRESENT    TRUE // (IsMouseInstalled())
#define SM_RESTOREDIR      FALSE // (bRestoreDirectory)
#define SM_CXVSCROLL        1
#define SM_CYHSCROLL        1
#define SM_CYCAPTION        1
#define SM_CXBORDER         1
#define SM_CYBORDER         1
#define SM_CXDLGFRAME       1
#define SM_CYDLGFRAME       1
#define SM_CYVTHUMB         1
#define SM_CXHTHUMB         1
#define SM_CXICON           8
#define SM_CYICON           4
#define SM_CXCURSOR         1
#define SM_CYCURSOR         1
#define SM_CYMENU           1
#define SM_CXFULLSCREEN     SM_CXSCREEN
#define SM_CYFULLSCREEN     SM_CYSCREEN-SM_CYMENU
#define SM_CYKANJIWINDOW    SM_CYSCREEN
#define SM_CYVSCROLL        1
#define SM_CXHSCROLL        1
#define SM_DEBUG            0
#define SM_SWAPBUTTON       0
#define SM_CXMIN            1
#define SM_CYMIN            1
#define SM_CXSIZE           1
#define SM_CYSIZE           1
#define SM_CXFRAME          1
#define SM_CYFRAME          1
#define SM_CXMINTRACK       1
#define SM_CYMINTRACK       1
#define SM_RESERVED1	    24
#define SM_RESERVED2	    25
#define SM_RESERVED3	    26
#define SM_RESERVED4	    27
*************/

#define GetSystemMetrics(x)      (x)


#define OLD_API	1

#define CW_USEDEFAULT	0xffff

// A whole wack of Edit stuff.

#define WM_CLEAR			0x800b
#define WM_UNDO			0x800c
#define WM_SYSCOMMAND	0x800d


#ifdef FULL_EDIT

/* Edit Control Styles */
#define ES_LEFT             0x0000
#define ES_CENTER           0x0001
#define ES_RIGHT            0x0002
#define ES_MULTILINE        0x0004
#define ES_UPPERCASE        0x0008
#define ES_LOWERCASE        0x0010

#define ES_PASSWORD         0x0001
#define ES_AUTOVSCROLL      0x0002
#define ES_AUTOHSCROLL      0x0004
#define ES_NOHIDESEL        0x0008
// #define ES_OEMCONVERT       0x0010

/* Edit Control Notification Codes */
#define EN_SETFOCUS	    0x0100
#define EN_KILLFOCUS	    0x0200
#define EN_CHANGE	    0x0300
#define EN_UPDATE	    0x0400
#define EN_ERRSPACE	    0x0500
#define EN_MAXTEXT	    0x0501
#define EN_HSCROLL	    0x0601
#define EN_VSCROLL	    0x0602

#ifndef NOWINMESSAGES

/* Edit Control Messages */
#define EM_GETSEL	   (WM_USER+0)
#define EM_SETSEL	   (WM_USER+1)
#define