
    delete pObject;
    return FALSE;
}

//***************************************************************************
//
//  <as_alias> ::= TOK_AS <alias>;
//  <as_alias> ::= <>;
//
//***************************************************************************
BOOL CMofParser::as_alias(OUT LPWSTR& wszAlias)
{
    if (m_nToken == TOK_AS)
    {
        NextToken();
        return alias(wszAlias);
    }
    
    wszAlias = NULL;
    return TRUE;
}

//***************************************************************************
//
//  <alias> ::= TOK_DOLLAR_SIGN TOK_SIMPLE_IDENT;
//
//
//***************************************************************************

BOOL CMofParser::alias(OUT LPWSTR& wszAlias)
{
    if (m_nToken != TOK_DOLLAR_SIGN)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_DOLLAR;
        return FALSE;
    }
    NextToken(true);

    if (m_nToken != TOK_SIMPLE_IDENT)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_ALIAS_NAME;
        return FALSE;
    }

    // Set the alias in the object
    // ===========================

    wszAlias = Macro_CloneStr(m_Lexer.GetText());
    if(wszAlias == NULL)
    {
        m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
        return FALSE;
    }
    if(m_Output.IsAliasInUse(wszAlias))
    {
        m_nErrorContext = WBEMMOF_E_MULTIPLE_ALIASES;
        return FALSE;
    }

    NextToken();
    return TRUE;
}

//***************************************************************************
//
//  <prop_init_list> ::= <prop_init><prop_init_list>;
//  <prop_init_list> ::= <>;
//
//***************************************************************************
// v1.10

BOOL CMofParser::prop_init_list(MODIFY CMObject* pObject)
{
    while (m_nToken == TOK_OPEN_BRACKET ||
           m_nToken == TOK_SIMPLE_IDENT )
    {
        CValueProperty* pProp = new CValueProperty(NULL, m_pDbg);
        if (pProp == NULL || !prop_init(*pProp))
            return FALSE;

        if(!pObject->AddProperty(pProp))
        {
            // Duplicate property
            // ==================

            m_nErrorContext = WBEMMOF_E_DUPLICATE_PROPERTY;
            return FALSE;
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  <prop_init> ::= <qualifier_decl> <ident> TOK_EQUALS <initializer> TOK_SEMI;
//
//***************************************************************************
BOOL CMofParser::prop_init(OUT CMoProperty& Prop)
{
    // Get the qualifiers
    // ==================

    CMoQualifierArray* paQualifiers = new CMoQualifierArray(m_pDbg);

    if (paQualifiers == NULL || !qualifier_decl(*paQualifiers,false, PROPMETH_SCOPE))
        return FALSE;
    Prop.SetQualifiers(paQualifiers); // acquired

    // Now get the property name.
    // ==========================

    if (m_nToken != TOK_SIMPLE_IDENT)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_PROPERTY_NAME;
        return FALSE;
    }

    if(FAILED(Prop.SetPropName((wchar_t *) m_Lexer.GetText())))
        return FALSE;
    NextToken();

    // Get the default value and assign it to the property.
    // ====================================================

    CMoType Type(m_pDbg);
    if (!default_value(Type, Prop.AccessValue()))
        return FALSE;

    // Check closing semicolon.
    // ========================

    m_nErrorContext = WBEMMOF_E_EXPECTED_SEMI;

    if (m_nToken != TOK_SEMI)
        return FALSE;

    NextToken();

    if(m_bDoScopeCheck && (FALSE == CheckScopes(IN_PROPERTY, paQualifiers, &Prop)))
        return FALSE;

    return TRUE;
}

//***************************************************************************
//
//	<flavor_param>    ::= TOK_COLON TOK_OPEN_PAREN <flavor_list> TOK_CLOSE_PAREN;
//	<flavor_param>    ::= <>;
//
//***************************************************************************

BOOL CMofParser::flavor_param(OUT CMoQualifier& Qual, bool bDefaultQual)
{
	if(m_nToken == TOK_COLON)
	{
		NextToken();

		if(!flavor_list(Qual))
			return FALSE;
	}
	return TRUE;
}

//***************************************************************************
//
//	<flavor_list> ::= <flavor_value> <flavor_list_rest>;
//
//***************************************************************************

BOOL CMofParser::flavor_list(OUT CMoQualifier& Qual)
{
	if(!flavor_value(Qual))
		return FALSE;
	else 
		return flavor_list_rest(Qual);
}

//***************************************************************************
//
//	<flavor_list_rest> ::= <FLAVOR_VALUE> <flavor_list_rest>;
//	<flavor_list_rest> ::= <>;
//
//***************************************************************************

BOOL CMofParser::flavor_list_rest(CMoQualifier& Qual)
{

	if(m_nToken == TOK_COMMA || m_nToken == TOK_CLOSE_BRACKET || m_nToken == TOK_SEMI)
        return TRUE;
    else

	{
		if(!flavor_value(Qual))
			return FALSE;
		return flavor_list_rest(Qual);
	}
	return TRUE;
}

//***************************************************************************
//
//	<def_flavor_list> ::= <flavor_value> <flavor_list_rest>;
//
//***************************************************************************

BOOL CMofParser::def_flavor_list(OUT CMoQualifier& Qual)
{
	if(!flavor_value(Qual))
		return FALSE;
	else 
		return def_flavor_list_rest(Qual);
}

//***************************************************************************
//
//	<def_flavor_list_rest> ::= <FLAVOR_VALUE> <def_flavor_list_rest>;
//	<def_flavor_list_rest> ::= <>;
//
//***************************************************************************

BOOL CMofParser::def_flavor_list_rest(CMoQualifier& Qual)
{
	if(m_nToken == TOK_CLOSE_PAREN)
        return TRUE;
    else

	{
        if(m_nToken != TOK_COMMA)
            return FALSE;
        NextToken();

		if(!flavor_value(Qual))
			return FALSE;
		return def_flavor_list_rest(Qual);
	}
	return TRUE;
    
}

//***************************************************************************
//
//	<flavor_value> ::= TOK_TOINSTANCE;
//	<flavor_value> ::= TOK_TOSUBCLASS;
//	<flavor_value> ::= TOK_ENABLEOVERRIDE;
//	<flavor_value> ::= TOK_DISABLEOVERRIDE;
//	<flavor_value> ::= TOK_NOTTOINSTANCE;
//	<flavor_value> ::= TOK_AMENDED;
//	<flavor_value> ::= TOK_NOTTOSUBCLASS;
//	<flavor_value> ::= TOK_RESTRICTED;
//
//***************************************************************************

BOOL CMofParser::flavor_value(CMoQualifier& Qual)
{
	SCODE sc = Qual.SetFlag(m_nToken, m_Lexer.GetText());
    if(sc != S_OK)
    {
	    m_nErrorContext = sc;
		return FALSE;
    }
	NextToken();
	return TRUE;
}

//***************************************************************************
//
// <qualifier_default> ::= TOK_QUALIFIER TOK_SIMPLE_IDENT TOK_COLON  <finish_qualifier_default>;
//
//***************************************************************************

BOOL CMofParser::qualifier_default()
{
    // Verify header
    // =============

    CHECK(TOK_QUALIFIER);

    m_nErrorContext = WBEMMOF_E_EXPECTED_QUALIFIER_NAME;
    if(m_nToken != TOK_SIMPLE_IDENT)
        return FALSE;

    // Store qualifier name
    // ====================

    CMoQualifier* pDefault = new CMoQualifier(m_pDbg);
    if(pDefault == NULL)
        return FALSE;
    if(FAILED(pDefault->SetQualName(m_Lexer.GetText())))
    {
        delete pDefault;
        return FALSE;
    }
    NextToken();

	// check for chase where its just Qualifier Name ;

    if(m_nToken == TOK_SEMI)
    {
        m_Output.SetQualifierDefault(pDefault);
	    NextToken();
        return TRUE;
    }

    // Make sure there is a colon

    if(m_nToken != TOK_COLON)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_SEMI;
        delete pDefault;
        return FALSE;
    }

    // Get the flavor
    // ==============

    if(!finish_qualifier_default(*pDefault))
    {
        delete pDefault;
        return FALSE;
    }

    m_nErrorContext = WBEMMOF_E_EXPECTED_SEMI;
    if(m_nToken != TOK_SEMI)
    {
        delete pDefault;
        return FALSE;
    }
    NextToken();
    return TRUE;
}


//***************************************************************************
//
// <finish_qualifier_default> ::= <flavor_list>;
// <finish_qualifier_default> ::= <type> TOK_EQUALS <default_value> TOK_COMMA TOK_SCOPE TOK_OPEN_PAREN <scope_list> TOK_CLOSE_PAREN <finish_qualifier_end>
//
//***************************************************************************

BOOL CMofParser::finish_qualifier_default(CMoQualifier& Qual)
{
    // Determine if it is of the simple (flavor only type) or the more complex

    NextToken();
	SCODE sc = Qual.SetFlag(m_nToken, m_Lexer.GetText());
    if(sc == S_OK)
    {
        BOOL bRet = flavor_list(Qual);
        if(bRet)
            m_Output.SetQualifierDefault(&Qual);
        return bRet;
    }

    m_nErrorContext = WBEMMOF_E_INVALID_QUALIFIER_SYNTAX;
    Qual.SetCimDefault(true);

    // assume that we have the long (cim version)

    // Get the type

    CMoType Type(m_pDbg);

    if (!type(Type))
    {
        return FALSE;
    }

    // optional array indication
    if(m_nToken == TOK_OPEN_BRACKET)
    {
        NextToken();
        if(m_nToken != TOK_CLOSE_BRACKET)
            return FALSE;
        Type.SetIsArray(TRUE);
        NextToken();
    }
    else
        Type.SetIsArray(FALSE);


    VARTYPE vt = Type.GetCIMType();
    if(vt == VT_ERROR)
        return FALSE;
    Qual.SetType(vt);

    // optional TOK_EQUALS

    if(m_nToken == TOK_EQUALS)
    {
 
        // TOK_SIMPLE_VALUE

        NextToken();
	    CMoValue & Value = Qual.AccessValue();

        if (!simple_initializer(Type, Value, true))
                return FALSE;
    }

    // look for comma

    if(m_nToken != TOK_COMMA)
        return FALSE;

    // TOK_SCOPE 

    NextToken();
    if(m_nToken != TOK_SIMPLE_IDENT || wbem_wcsicmp(L"SCOPE", m_Lexer.GetText()))
        return FALSE;
    
    // TOK_OPEN_PAREN 

    NextToken();
    if(m_nToken != TOK_OPEN_PAREN)
        return FALSE;
    
    // <scope_list> and close paren

    if(!scope_list(Qual))
        return FALSE;

    return finish_qualifier_end(Qual);
}

//***************************************************************************
//
//  <finish_qualifier_end> ::= TOK_COMMA TOK_FLAVOR OK_OPEN_PAREN <flavor_list> TOK_CLOSE_PAREN;
//  <finish_qualifier_end> ::= <>;
//
//***************************************************************************

BOOL CMofParser::finish_qualifier_end(CMoQualifier& Qual)
{
    
    // TOK_COMMA 

    NextToken();
    if(m_nToken == TOK_SEMI)
        return TRUE;

    if(m_nToken != TOK_COMMA)
        return FALSE;

    // TOK_FLAVOR 
    
    NextToken();
    if(m_nToken != TOK_SIMPLE_IDENT || wbem_wcsicmp(L"FLAVOR", m_Lexer.GetText()))
        return FALSE;

    // TOK_OPEN_PAREN 

    NextToken();
    if(m_nToken != TOK_OPEN_PAREN)
        return FALSE;
    
    // <flavor_list> 

    NextToken();
    if(!def_flavor_list(Qual))
        return FALSE;
    
    // TOK_CLOSE_PAREN

    if(m_nToken != TOK_CLOSE_PAREN)
        return FALSE;
    
    m_Output.SetQualifierDefault(&Qual);
    NextToken();

    return TRUE;
}

//***************************************************************************
//
//	<scope_list> ::= <scope_value> <scope_list_rest>;
//
//***************************************************************************

BOOL CMofParser::scope_list(OUT CMoQualifier& Qual)
{
    NextToken();
	if(!scope_value(Qual))
		return FALSE;
	else 
		return scope_list_rest(Qual);
}

//***************************************************************************
//
//	<scope_list_rest> ::= <SCOPE_VALUE> <scope_list_rest>;
//	<scope_list_rest> ::= <>;
//
//***************************************************************************

BOOL CMofParser::scope_list_rest(CMoQualifier& Qual)
{
	if(m_nToken == TOK_CLOSE_PAREN)
        return TRUE;
    else

	{
        if(m_nToken != TOK_COMMA)
            return FALSE;
        NextToken();
		if(!scope_value(Qual))
			return FALSE;
		return scope_list_rest(Qual);
	}
	return TRUE;
}

//***************************************************************************
//
//	<scope_value> ::= TOK_CLASS;
//	<scope_value> ::= TOK_INSTANCE;
//
//***************************************************************************

BOOL CMofParser::scope_value(CMoQualifier& Qual)
{
	BOOL bRet = Qual.SetScope(m_nToken, m_Lexer.GetText());   
    if(!bRet)
		return FALSE;
	NextToken();
	return TRUE;
}

BOOL CMofParser::CheckScopes(SCOPE_CHECK scope_check, CMoQualifierArray* paQualifiers, 
                             CMoProperty * pProperty)
{
    m_nErrorContext = WBEMMOF_E_QUALIFIER_USED_OUTSIDE_SCOPE;
    bool bAssociation = false;
    bool bReference = false;
    int iDef;

    // if this is a class, check determine if it is an association 

    if(scope_check == IN_CLASS)
    {
		CMoValue * pValue = paQualifiers->Find(L"ASSOCIATION");
		if(pValue)
		{
            VARIANT& var = pValue->AccessVariant();
			if(var.vt == VT_BOOL && var.boolVal == VARIANT_TRUE)
                bAssociation=true;
        }
    }

    // if it is a property, determine if it is a reference

    if((scope_check == IN_PROPERTY || scope_check == IN_PARAM) && 
        pProperty && (pProperty->GetType() == CIM_REFERENCE))
        bReference = true;

    // For each qualifier in my list, look at the globals look for a match

    int iNumTest =  paQualifiers->GetSize();
    int iNumDef = m_Output.GetNumDefaultQuals();
    for(int iTest = 0; iTest < iNumTest; iTest++)
    {
        // Get the qualifier to test

        CMoQualifier* pTest = paQualifiers->GetAt(iTest);
        
        // look for the qualifier in the default list
        
        CMoQualifier* pDefault = NULL;
        for(iDef = 0; iDef < iNumDef; iDef++)
        {
            CMoQualifier* pDefault = m_Output.GetDefaultQual(iDef);
            if(wbem_wcsicmp(pDefault->GetName(), pTest->GetName()) == 0)
            {
                bool bInScope = false;
                DWORD dwScope = pDefault->GetScope();
                if(dwScope == 0)
                    bInScope = true;
                if((dwScope & SCOPE_ASSOCIATION) && bAssociation)
                    bInScope = true;
                if((dwScope & SCOPE_REFERENCE) && bReference)
                    bInScope = true;

                // got a match
                switch (scope_check)
                {
                case IN_CLASS:
                    if(dwScope & SCOPE_CLASS)
                        bInScope = true;
                    break;
                case IN_INSTANCE:
                    if(dwScope & SCOPE_INSTANCE)
                        bInScope = true;
                    break;
                case IN_PROPERTY:
                    if(dwScope & SCOPE_PROPERTY)
                        bInScope = true;
                    break;
                case IN_PARAM:
                    if(dwScope & SCOPE_PARAMETER)
                        bInScope = true;
                    break;
                case IN_METHOD:
                    if(dwScope & SCOPE_METHOD)
                        bInScope = true;
                    break;
                }
                if(!bInScope)
                    return false;
                break;
            }
        }

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_tool\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#include <comdef.h>

#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\preproc.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PREPROC.H

Abstract:

	Implementation for the preprocessor.

History:

	a-davj      6-april-99   Created.

--*/

#ifndef _PREPROC_H_
#define _PREPROC_H_

#define TEST_SIZE 20

bool IsBMOFBuffer(byte * pTest, DWORD & dwCompressedSize, DWORD & dwExpandedSize);
void WriteLineAndFilePragma(FILE * pFile, const char * pFileName, int iLine);
void WriteLine(FILE * pFile, WCHAR * pLine);
HRESULT WriteFileToTemp(const TCHAR * pFileName, FILE * pTempFile, CFlexArray & sofar, PDBG pDbg, CMofLexer*);
void CheckForUnicodeEndian(FILE * fp, bool * punicode, bool * pbigendian);
WCHAR * ReadLine(FILE * pFilebool,bool unicode, bool bigendian);
WCHAR GetNextChar(FILE * pFile, bool unicode, bool bigendian);

HRESULT IsInclude(WCHAR * pLine, TCHAR * cFileNameBuff, bool & bReturn);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\strings.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STRINGS.H

Abstract:

	Resource definitions

History:

--*/


#define PARSING_MSG     0
#define ERROR_SYNTAX    PARSING_MSG+1
#define SUCCESS         ERROR_SYNTAX+1
#define SYNTAX_CHECK_COMPLETE  SUCCESS+1
#define STORING_BMOF          SYNTAX_CHECK_COMPLETE+1
#define STORING_DATA          STORING_BMOF+1
#define CANT_FIND_CLASS_NAME  STORING_DATA+1
#define INVALID_AUTORECOVER   CANT_FIND_CLASS_NAME + 1

#define SAFE_ARRAY_ERROR      50
#define UNEXPECTED_EOF        SAFE_ARRAY_ERROR+1
#define COMMENT_ERROR         UNEXPECTED_EOF+1
#define PREPROCESSOR          COMMENT_ERROR+1
#define NO_TYPEDEFS           PREPROCESSOR+1
#define ALIAS_PROP_ERROR      NO_TYPEDEFS+1
#define BAD_PROP_TYPE         ALIAS_PROP_ERROR+1
#define FILE_CREATE_FAILED    BAD_PROP_TYPE+1
#define FILE_WRITE_FAILED     FILE_CREATE_FAILED+1
#define ERROR_FORMAT          FILE_WRITE_FAILED+1
#define CR					  ERROR_FORMAT+1
#define WMI_LAUNCH_ERROR      CR+1
#define COMPRESSION_FAILED     WMI_LAUNCH_ERROR+1
#define ERROR_FORMATEX        COMPRESSION_FAILED+1
#define ERROR_FORMAT_LONG     ERROR_FORMATEX+1
#define INVALID_BMOF_OBJECT_TYPE ERROR_FORMAT_LONG+1


#define ERROR_INCLUDING_BINARY          158
#define ERROR_INCLUDING_ABSENT          159
#define ERROR_RECURSIVE_INCLUDE         160

#define ERROR_OPENING                   150
#define ERROR_OPENING_NO_LINES          151
#define ERROR_CREATING                  152
#define ERROR_CREATING_NO_LINES         153
#define ERROR_STORING                   154
#define ERROR_STORING_NO_LINES          155
#define ERROR_RESOLVING                 156
#define ERROR_RESOLVING_NO_LINES        157
#define ERRCTX_INVALID_DELETECLASS_SYNTAX         170
#define BMOF_INCOMPATIBLE                         171
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\preproc.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PREPROC.CPP

Abstract:

    Implementation for the preprocessor.

History:

    a-davj      6-april-99   Created.

--*/

#include "precomp.h"
#include <arrtempl.h>
#include "trace.h"
#include "moflex.h"
#include "preproc.h"
#include <wbemcli.h>
#include <io.h>
#include "bmof.h"
#include "strings.h"

#define  HR_LASTERR  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError() )

//***************************************************************************
//
//  WriteLineAndFilePragma
//
//  DESCRIPTION:
//
//  Write the line into the temp file which indicates what file and line number
//  is to follow.
//
//***************************************************************************

#define MAX_PRAGMA_BUFF (2*MAX_PATH + 23)
void WriteLineAndFilePragma(FILE * pFile, const TCHAR * pFileName, int iLine)
{
    WCHAR wTemp[MAX_PRAGMA_BUFF];
    WCHAR * pTo;
    const WCHAR * pFr;
    StringCchPrintfW (wTemp, MAX_PRAGMA_BUFF, L"#line %d \"", iLine);
    int iLen = wcslen(wTemp);
    for(pFr = pFileName, pTo = wTemp+iLen; *pFr && iLen < MAX_PRAGMA_BUFF-5; pFr++, pTo++, iLen++)
    {
        *pTo = *pFr;
        if(*pFr == L'\\')
        {
            pTo++;
            *pTo = L'\\';
            iLen++;
        }
    }
    *pTo = 0;
    StringCchCatW(wTemp, MAX_PRAGMA_BUFF, L"\"\r\n");
    WriteLine(pFile, wTemp);
}

//***************************************************************************
//
//  WriteLine(FILE * pFile, WCHAR * pLine)
//
//  DESCRIPTION:
//
//  Writes a single line out to the temporary file.
//
//***************************************************************************

void WriteLine(FILE * pFile, WCHAR * pLine)
{
    fwrite(pLine, 2, wcslen(pLine), pFile);
}

//***************************************************************************
//
//  IsBMOFBuffer
//
//  DESCRIPTION:
//
//  Used to check if a buffer is the start of a binary mof.
//
//***************************************************************************

bool IsBMOFBuffer(byte * pTest, DWORD & dwCompressedSize, DWORD & dwExpandedSize)
{
    DWORD dwSig = BMOF_SIG;
    if(0 == memcmp(pTest, &dwSig, sizeof(DWORD)))
    {
        // ignore the compression type, and the Compressed Size
        
        pTest += 2*sizeof(DWORD);
        memcpy(&dwCompressedSize, pTest, sizeof(DWORD));
        pTest += sizeof(DWORD);
        memcpy(&dwExpandedSize, pTest, sizeof(DWORD));
        return true;        
    }
    return false;
}

//***************************************************************************
//
//  IsBinaryFile
//
//  DESCRIPTION:
//
//  returns true if the file contains a binary mof.
//
//***************************************************************************

#ifdef USE_MMF_APPROACH
bool IsBinaryFile(BYTE  * pData,DWORD dwSize)
{

    if(dwSize < TEST_SIZE)
    {
        // if we cant read even the header, it must not be a BMOF
        return false;
    }

    DWORD dwCompressedSize, dwExpandedSize;
    // Test if the mof is binary

    if(!IsBMOFBuffer(pData, dwCompressedSize, dwExpandedSize))
    {
        // not a binary mof.  This is the typical case
        return false;
    }
    return true;
}
#else
bool IsBinaryFile(FILE * fp)
{

    // read the first 20 bytes

    BYTE Test[TEST_SIZE];
    int iRet = fread(Test, 1, TEST_SIZE, fp);
    
    if( fseek(fp, 0, SEEK_SET) ) return false;

    if(iRet != TEST_SIZE)
    {
        // if we cant read even the header, it must not be a BMOF
        return false;
    }

    DWORD dwCompressedSize, dwExpandedSize;

    // Test if the mof is binary

    if(!IsBMOFBuffer(Test, dwCompressedSize, dwExpandedSize))
    {
        // not a binary mof.  This is the typical case
        return false;
    }
    return true;
}
#endif

//***************************************************************************
//
//  CheckForUnicodeEndian
//
//  DESCRIPTION:
//
//  Examines the first couple of bytes in a file and determines if the file
//  is in unicode and if so, if it is big endian.  It is assumed that the
//  file is pointing to the start and if the file is unicode, the pointer 
//  is left at the first actual data byte.
//
//***************************************************************************

#ifdef USE_MMF_APPROACH
void CheckForUnicodeEndian(BYTE * &pData, bool * punicode, bool * pbigendian)
{

    // Check for UNICODE source file.
    // ==============================

    BYTE * UnicodeSignature = pData;

    if (UnicodeSignature[0] == 0xFF && UnicodeSignature[1] == 0xFE)
    {
        *punicode = TRUE;
        *pbigendian = FALSE;
        pData+=2;
    }
    else if (UnicodeSignature[0] == 0xFE && UnicodeSignature[1] == 0xFF)
    {
        *punicode = TRUE;
        *pbigendian = TRUE;
        pData+=2;        
    }
    else    // ANSI/DBCS.  Move back to start of file.
    {
        *punicode = false;
    }

}
#else
void CheckForUnicodeEndian(FILE * fp, bool * punicode, bool * pbigendian)
{

    // Check for UNICODE source file.
    // ==============================

    BYTE UnicodeSignature[2];
    if (fread(UnicodeSignature, sizeof(BYTE), 2, fp) != 2)
    {
        *punicode = false;
        fseek(fp, 0, SEEK_SET);
        return ;
    }

    if (UnicodeSignature[0] == 0xFF && UnicodeSignature[1] == 0xFE)
    {
        *punicode = TRUE;
        *pbigendian = FALSE;
    }
    else if (UnicodeSignature[0] == 0xFE && UnicodeSignature[1] == 0xFF)
    {
        *punicode = TRUE;
        *pbigendian = TRUE;
    }
    else    // ANSI/DBCS.  Move back to start of file.
    {
        *punicode = false;
        fseek(fp, 0, SEEK_SET);
    }

}

#endif

//***************************************************************************
//
//  GetNextChar
//
//  DESCRIPTION:
//
//  Gets the next WCHAR from the file.
//
//***************************************************************************

#ifdef USE_MMF_APPROACH
WCHAR GetNextChar(BYTE * & pData, BYTE * pEnd, bool unicode, bool bigendian)
{

    if(unicode)      // unicode file
    {
        if ( (ULONG_PTR)pData >= (ULONG_PTR)pEnd) return 0;

        WCHAR wc = *(WCHAR *)pData;
        pData+=sizeof(WCHAR);
            
        if(bigendian)
        {
            wc = ((wc & 0xff) << 8) | ((wc & 0xff00) >> 8);
        }
        return wc;
    }
    else                    // single character file
    {
        if ( (ULONG_PTR)pData >= (ULONG_PTR)pEnd) return 0;
        char temp = (char)*pData;
        pData++;
        if(temp == 0x1a) return 0;       // EOF for ascii files!

        WCHAR wRet[2];
        MultiByteToWideChar(CP_ACP,0,&temp,1,wRet,2);
        return wRet[0];
    }
    return 0;
}
#else
WCHAR GetNextChar(FILE * fp, bool unicode, bool bigendian)
{
    WCHAR wRet[2];
    if(unicode)      // unicode file
    {
        if (fread(wRet, sizeof(wchar_t), 1, fp) == 0)
            return 0;
        if(bigendian)
        {
            wRet[0] = ((wRet[0] & 0xff) << 8) | ((wRet[0] & 0xff00) >> 8);
        }
    }
    else                    // single character file
    {
        char temp;
        if (fread(&temp, sizeof(char), 1, fp) == 0)
            return 0;
        if(temp == 0x1a)
            return 0;       // EOF for ascii files!
        StringCchPrintfW (wRet, 2, L"%C", temp);
    }
    return wRet[0];
}

#endif

//***************************************************************************
//
//  IsInclude
//
//  DESCRIPTION:
//
//  Looks at a line and determines if it is a #include line.  This is 
//  probably temporary since later we might have a preprocessor parser should
//  we start to add a lot of preprocessor features.
//
//***************************************************************************

HRESULT IsInclude(WCHAR * pLine, TCHAR * cFileNameBuff, bool & bReturn)
{

    bReturn = false;
    
    // Do a quick check to see if this could be a #include or #pragma include

    int iNumNonBlank = 0;
    WCHAR * pTemp;
    
    for(pTemp = pLine; *pTemp; pTemp++)
    {
        if(*pTemp != L' ')
        {
            iNumNonBlank++;
            if(iNumNonBlank == 1 && *pTemp != L'#')
                return false;
            if(iNumNonBlank == 2 && towupper(*pTemp) != L'I' && 
                                    towupper(*pTemp) != L'P')
                return S_OK;
            
            // we have established that the first two non blank characters are #I
            // or #p, therefore we continue on...

            if(iNumNonBlank > 1)
                break;
        }
    }

    // Create a version of the line with no blanks in front of the first quote

    WCHAR *wTemp = new WCHAR[wcslen(pLine) + 1];
    if(wTemp == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<WCHAR> dm(wTemp);
    WCHAR *pTo;
    BOOL bFoundQuote = FALSE;
    for(pTo = wTemp, pTemp = pLine; *pTemp; pTemp++)
    {
        if(*pTemp == L'"')
            bFoundQuote = TRUE;
        if(*pTemp != L' ' || bFoundQuote)
        {
            *pTo = *pTemp;
            pTo++;
        }
    }
    *pTo = 0;

    // Verify that the line starts with #include(" or #pragma include

    WCHAR * pTest;
    if(wbem_wcsnicmp(wTemp, L"#pragma", 7) == 0)
        pTest = wTemp+7;
    else
        pTest = wTemp+1;

    if(wbem_wcsnicmp(pTest, L"include(\"", 9) || wcslen(pTest) < 12)
        return S_OK;

    // Count back from the end to find the previous "

    WCHAR *Last;
    for(Last = pTo-1; *Last && Last > wTemp+9 && *Last != L'"'; Last--);

    if(*Last != L'"')
        return S_OK;

    *Last = 0;

    CopyOrConvert(cFileNameBuff, pTest+9, MAX_PATH);
    bReturn =  true;
    return S_OK;
   
}

#if defined(_AMD64_)

//***************************************************************************
//
//  ReadLineFast
//
//  DESCRIPTION:
//
//  Reads a single line from a file.
//
//  The ReadLine() function (below) is painfully slow.  For each character
//  in a line, the following routines are performed:
//
//      fread()
//      swprintf()
//
//  Neither of which are fast.  Then, when the length of the line is
//  determined, each character in the line is processed *again*.  The files
//  being processed are not small, either... greater than a megabyte is
//  not uncommon.
//
//  This routine is an attempt to speed things up.  Right now this is done
//  for AMD64 because we're running on a simulator, however someone should
//  consider enabling this routine for all platforms.
//
//  RETURN:
//
//  NULL if end of file, or error, other wise this is a pointer to a WCHAR
//  string which MUST BE FREED BY THE CALLER.
//
//***************************************************************************

WCHAR * ReadLineFast(FILE * pFile, bool unicode, bool bigendian)
{
    #define TMP_BUF_CHARS 256

    CHAR asciiBuffer[TMP_BUF_CHARS];
    WCHAR unicodeBuffer[TMP_BUF_CHARS];
    PWCHAR returnBuffer;
    int unicodeChars;
    int currentFilePosition;

    //
    // This routine does not handle the bigendian case.
    // 

    if (bigendian != FALSE) {
        return NULL;
    }

    //
    // Remember the current file position.  If an error is encountered,
    // the file position must be restored for the slower ReadLine()
    // routine.
    // 

    currentFilePosition = ftell(pFile);

    if (unicode == FALSE) {

        //
        // Read the next line into asciiBuffer, and convert it to
        // unicodeBuffer.  If any problems (buffer overrun, etc.) are
        // encountered, fail the call.
        // 

        asciiBuffer[TMP_BUF_CHARS-1] = '\0';
        if (NULL == fgets(asciiBuffer,TMP_BUF_CHARS,pFile)) {
            goto exitError;
        }

        if (asciiBuffer[TMP_BUF_CHARS-1] != '\0') {
            goto exitError;
        }

        if (FAILED(StringCchPrintfW (unicodeBuffer, TMP_BUF_CHARS, L"%S", asciiBuffer)))
           goto exitError;

	unicodeChars = wcslen(unicodeBuffer);

    } else {

        //
        // Read the next line into unicodeBuffer.  If any problems (buffer
        // overrun, etc.) are encountered, fail the call.
        //

        unicodeBuffer[TMP_BUF_CHARS-1] = L'\0';
        if (NULL == fgetws(unicodeBuffer,TMP_BUF_CHARS,pFile)) {
            goto exitError;
        }

        if (unicodeBuffer[TMP_BUF_CHARS-1] != L'\0') {
            goto exitError;
        }

        unicodeChars = wcslen(unicodeBuffer);
    }

    //
    // Allocate the buffer to return to the caller, copy the unicode
    // string into it, and return to the caller.
    // 

    returnBuffer = new WCHAR[unicodeChars + 1];
    if (returnBuffer == NULL) {
        goto exitError;
    }

    RtlCopyMemory(returnBuffer,unicodeBuffer,unicodeChars * sizeof(WCHAR));
    returnBuffer[unicodeChars] = L'\0';

    return returnBuffer;

exitError:
    fseek(pFile, currentFilePosition, SEEK_SET);
    return NULL;
}

#endif  // _AMD64_


#ifdef USE_MMF_APPROACH
WCHAR * FindWCharOrEnd(WCHAR  * pStart, WCHAR * pEnd,WCHAR wc)
{
    while ((ULONG_PTR)pStart < (ULONG_PTR)pEnd)
    {
        if (wc == *pStart) break;
        pStart++;
    }
    return pStart; 
}

BYTE * FindCharOrEnd(BYTE * pStart, BYTE * pEnd,BYTE c)
{
    while ((ULONG_PTR)pStart < (ULONG_PTR)pEnd)
    {
        if (c == *pStart) break;
        pStart++;
    }
    return pStart; 
}

//***************************************************************************
//
//  ReadLine
//
//  DESCRIPTION:
//
//  Reads a single line from a file.
//
//  RETURN:
//
//  NULL if end of file, or error, other wise this is a pointer to a WCHAR
//  string which MUST BE FREED BY THE CALLER.
//
//***************************************************************************

WCHAR * ReadLine(BYTE * & pData,BYTE * pEnd, bool unicode, bool bigendian)
{
   if (unicode)
   {
        if ((ULONG_PTR)pData >= (ULONG_PTR)pEnd) return NULL;        
        WCHAR * pFound = FindWCharOrEnd((WCHAR *)pData,(WCHAR *)pEnd,L'\n');
        
        ULONG_PTR iNumChar = (ULONG_PTR)pFound-(ULONG_PTR)pData;
        WCHAR * pRet = new WCHAR[2 + (iNumChar/sizeof(WCHAR))];
        if (NULL == pRet) return NULL;
        
        memcpy(pRet,pData,iNumChar);
        
        pRet[iNumChar/sizeof(WCHAR)] = L'\n';
        pRet[iNumChar/sizeof(WCHAR)+1] = 0;
        
        pData = (BYTE *)(pFound + 1);
        
        return pRet;
   }
   else
   {
        if ((ULONG_PTR)pData >= (ULONG_PTR)pEnd) return NULL;
        
        BYTE * pFound = FindCharOrEnd(pData,pEnd,'\n');        
        ULONG_PTR iNumChar = (ULONG_PTR)pFound-(ULONG_PTR)pData;
        
        WCHAR * pRet = new WCHAR[2 + (iNumChar)];
        if (NULL == pRet) return NULL;

        MultiByteToWideChar(CP_ACP,0,(LPCSTR)pData,iNumChar,pRet,iNumChar);
        
        pRet[iNumChar] = L'\n';
        pRet[iNumChar + 1] = 0;

        pData = pFound + 1;
        
        return pRet;    
   }
}

HRESULT WriteFileToTemp(const TCHAR * pFileName, FILE * pTempFile, CFlexArray & sofar, PDBG pDbg,CMofLexer* pLex)
{

    SCODE sc = S_OK;
    int iSoFarPos = -1;

    // Make sure the file isnt on the list already.  If it is, then fail since we would
    // be in a loop.  If it isnt, add it to the list.

    for(int iCnt = 0; iCnt < sofar.Size(); iCnt++)
    {
        TCHAR * pTemp = (TCHAR * )sofar.GetAt(iCnt);
        if(lstrcmpi(pTemp, pFileName) == 0)
        {
            Trace(true, pDbg, ERROR_RECURSIVE_INCLUDE, pFileName);
            return WBEM_E_FAILED;
        }
    }

    DWORD dwLen = lstrlen(pFileName) + 1;
    TCHAR * pNew = new TCHAR[dwLen];
    if(pNew)
    {
        StringCchCopyW(pNew, dwLen, pFileName);
        sofar.Add((void *)pNew);
        iSoFarPos = sofar.Size()-1;
    }
    else
        return WBEM_E_OUT_OF_MEMORY;
        
    // Write the file and line number out

    WriteLineAndFilePragma(pTempFile, pFileName, 1);


    HANDLE hSrcFile = CreateFile(pFileName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0,NULL);
    if (INVALID_HANDLE_VALUE == hSrcFile) return HR_LASTERR;
    OnDelete<HANDLE,BOOL(*)(HANDLE),CloseHandle> cmSrc(hSrcFile);

    DWORD dwSize = GetFileSize(hSrcFile,NULL);
    HANDLE hFileMapSrc = CreateFileMapping(hSrcFile,
                                       NULL,
                                       PAGE_READONLY,
                                       0,0,  // the entire file
                                       NULL);
    if (NULL == hFileMapSrc) return HR_LASTERR;
    OnDelete<HANDLE,BOOL(*)(HANDLE),CloseHandle> cmMapSrc(hFileMapSrc);

    VOID * pData = MapViewOfFile(hFileMapSrc,FILE_MAP_READ,0,0,0);
    if (NULL == pData) return HR_LASTERR;
    OnDelete<PVOID,BOOL(*)(LPCVOID),UnmapViewOfFile> UnMap(pData);
    
    // Make sure the file isnt binary

    if(IsBinaryFile((BYTE *)pData,dwSize))
    {
        Trace(true, pDbg, ERROR_INCLUDING_ABSENT, pFileName);
        return WBEM_E_FAILED;
    }

    // Determine if the file is unicode and bigendian

    BYTE * pMovedData = (BYTE *)pData;
    BYTE * pEnd = pMovedData + dwSize;
    bool unicode, bigendian;
    CheckForUnicodeEndian(pMovedData, &unicode, &bigendian);

    // Go through each line of the file, if it is another include, then recursively call this guy.
   
    WCHAR * pLine = NULL;
    for(int iLine = 1; pLine = ReadLine(pMovedData,pEnd, unicode, bigendian);)
    {
        CDeleteMe<WCHAR> dm(pLine);
        TCHAR cFileName[MAX_PATH+1];
        bool bInclude;
        HRESULT hr = IsInclude(pLine, cFileName, bInclude);
        if(FAILED(hr))
            return hr;
        if(bInclude)
        {
            TCHAR szExpandedFilename[MAX_PATH+1];
            DWORD nRes = ExpandEnvironmentStrings(cFileName,
                                                szExpandedFilename,
                                                FILENAME_MAX);
            if (nRes == 0)
            {
                //That failed!
                StringCchCopyW(szExpandedFilename, MAX_PATH+1, cFileName);
            }

            if (_waccess(szExpandedFilename,0))
            {
               // Included file not found, look in same directory as parent MOF file
 
               TCHAR cSrcPath[_MAX_PATH+1] = L"";
               TCHAR cSrcDrive[_MAX_DRIVE] = L"";
               TCHAR cSrcDir[_MAX_DIR] = L"";
 
               // Get drive and directory information of parent MOF file
 
               if (_wfullpath( cSrcPath, pFileName, _MAX_PATH ) != NULL)
               {
                  _wsplitpath(cSrcPath, cSrcDrive, cSrcDir, NULL, NULL);
               }
 
               // Copy original included MOF file information to cSrcPath
 
               StringCchCopyW(cSrcPath, _MAX_PATH+1, szExpandedFilename);
 
               // Build up new full path of included MOF using the 
               // path of the parent MOF. 
               // Note: Intentionally did not use _makepath here. 
 
               StringCchCopyW(szExpandedFilename, MAX_PATH+1, L"");         // flush string
               StringCchCatW(szExpandedFilename, MAX_PATH+1, cSrcDrive);  // add drive info
               StringCchCatW(szExpandedFilename, MAX_PATH+1, cSrcDir);    // add directory info
               StringCchCatW(szExpandedFilename, MAX_PATH+1, cSrcPath);   // add original specified path and filename
            }

            if (_waccess(szExpandedFilename,0))
            {
                // still dont have the file.  Must be invalid include.  Set the name back and report the error 

                DWORD nRes = ExpandEnvironmentStrings(cFileName,
                                                    szExpandedFilename,
                                                    FILENAME_MAX);
                if (nRes == 0)
                {
                    //That failed!
                    StringCchCopyW(szExpandedFilename, MAX_PATH+1, cFileName);
                }
                Trace(true, pDbg, ERROR_INCLUDING_ABSENT, szExpandedFilename);
                pLex->SetError(CMofLexer::invalid_include_file);
                return WBEM_E_FAILED;
            }

            sc = WriteFileToTemp(szExpandedFilename, pTempFile, sofar, pDbg, pLex);
            WriteLineAndFilePragma(pTempFile, pFileName, 1);
            if(sc != S_OK)
                break;
        }
        else
        {
            iLine++;
            WriteLine(pTempFile, pLine);
        }
    }

    // remove the entry so that the file can be included more than once at the same level

    if(iSoFarPos != -1)
    {
        TCHAR * pTemp = (TCHAR * )sofar.GetAt(iSoFarPos);
        if(pTemp)
        {
            delete pTemp;
            sofar.RemoveAt(iSoFarPos);
        }
    }
    return sc;
}


#else

//***************************************************************************
//
//  ReadLine
//
//  DESCRIPTION:
//
//  Reads a single line from a file.
//
//  RETURN:
//
//  NULL if end of file, or error, other wise this is a pointer to a WCHAR
//  string which MUST BE FREED BY THE CALLER.
//
//***************************************************************************
WCHAR * ReadLine(FILE * pFile, bool unicode, bool bigendian)
{

    WCHAR * pRet;

#if defined(_AMD64_)

    pRet = ReadLineFast(pFile,unicode,bigendian);
    if (pRet != NULL) {
        return pRet;
    }

#endif

    // Get the current position

    int iCurrPos = ftell(pFile);

    // count the number of characters in the line

    WCHAR wCurr;
    int iNumChar = 0;
    for(iNumChar = 0; wCurr = GetNextChar(pFile, unicode, bigendian); iNumChar++)
        if(wCurr == L'\n')
            break;
    if(iNumChar == 0 && wCurr == 0)
        return NULL;
    iNumChar+= 2;

    // move the file pointer back

    if( fseek(pFile, iCurrPos, SEEK_SET) ) return NULL;

    // allocate the buffer

    pRet = new WCHAR[iNumChar+1];
    if(pRet == NULL)
        return NULL;

    // move the characters into the buffer

    WCHAR * pNext = pRet;
    for(iNumChar = 0; wCurr = GetNextChar(pFile, unicode, bigendian); pNext++)
    {
        *pNext = wCurr;
        if(wCurr == L'\n')
        {
           pNext++;
           break;
        }
    }
    *pNext = 0;
    return pRet;
}

//***************************************************************************
//
//  WriteFileToTemp
//
//  DESCRIPTION:
//
//  Writes the contests of a file to the temporay file.  The temporary file
//  will always be little endian unicode.  This will be called recursively
//  should an include be encountered.
//
//***************************************************************************


HRESULT WriteFileToTemp(const TCHAR * pFileName, FILE * pTempFile, CFlexArray & sofar, PDBG pDbg,CMofLexer* pLex)
{

    SCODE sc = S_OK;
    int iSoFarPos = -1;

    // Make sure the file isnt on the list already.  If it is, then fail since we would
    // be in a loop.  If it isnt, add it to the list.

    for(int iCnt = 0; iCnt < sofar.Size(); iCnt++)
    {
        TCHAR * pTemp = (TCHAR * )sofar.GetAt(iCnt);
        if(lstrcmpi(pTemp, pFileName) == 0)
        {
            Trace(true, pDbg, ERROR_RECURSIVE_INCLUDE, pFileName);
            return WBEM_E_FAILED;
        }
    }

    DWORD dwLen = lstrlen(pFileName) + 1;
    TCHAR * pNew = new TCHAR[dwLen];
    if(pNew)
    {
        StringCchCopyW(pNew, dwLen, pFileName);
        sofar.Add((void *)pNew);
        iSoFarPos = sofar.Size()-1;
    }
    else
        return WBEM_E_OUT_OF_MEMORY;
        
    // Write the file and line number out

    WriteLineAndFilePragma(pTempFile, pFileName, 1);

    // Open the file

    FILE *fp;
#ifdef UNICODE
    fp = _wfopen(pFileName, L"rb");
#else
    fp = fopen(pFileName, "rb");
#endif
    if(fp == NULL)
    {
        Trace(true, pDbg, ERROR_INCLUDING_ABSENT, pFileName);
        pLex->SetError(CMofLexer::invalid_include_file);
        return WBEM_E_FAILED;
    }

    CfcloseMe cm(fp);

    // Make sure the file isnt binary

    if(IsBinaryFile(fp))
    {
        Trace(true, pDbg, ERROR_INCLUDING_ABSENT, pFileName);
        return WBEM_E_FAILED;
    }

    // Determine if the file is unicode and bigendian

    bool unicode, bigendian;
    CheckForUnicodeEndian(fp, &unicode, &bigendian);

    // Go through each line of the file, if it is another include, then recursively call this guy.
   
    WCHAR * pLine = NULL;
    for(int iLine = 1; pLine = ReadLine(fp, unicode, bigendian);)
    {
        CDeleteMe<WCHAR> dm(pLine);
        TCHAR cFileName[MAX_PATH+1];
        bool bInclude;
        HRESULT hr = IsInclude(pLine, cFileName, bInclude);
        if(FAILED(hr))
            return hr;
        if(bInclude)
        {
            TCHAR szExpandedFilename[MAX_PATH+1];
            DWORD nRes = ExpandEnvironmentStrings(cFileName,
                                                szExpandedFilename,
                                                FILENAME_MAX);
            if (nRes == 0)
            {
                //That failed!
                StringCchCopyW(szExpandedFilename, MAX_PATH+1, cFileName);
            }

            if (_waccess(szExpandedFilename,0))
            {
               // Included file not found, look in same directory as parent MOF file
 
               TCHAR cSrcPath[_MAX_PATH+1] = L"";
               TCHAR cSrcDrive[_MAX_DRIVE] = L"";
               TCHAR cSrcDir[_MAX_DIR] = L"";
 
               // Get drive and directory information of parent MOF file
 
               if (_wfullpath( cSrcPath, pFileName, _MAX_PATH ) != NULL)
               {
                  _wsplitpath(cSrcPath, cSrcDrive, cSrcDir, NULL, NULL);
               }
 
               // Copy original included MOF file information to cSrcPath
 
               StringCchCopyW(cSrcPath, _MAX_PATH+1, szExpandedFilename);
 
               // Build up new full path of included MOF using the 
               // path of the parent MOF. 
               // Note: Intentionally did not use _makepath here. 
 
               StringCchCopyW(szExpandedFilename, MAX_PATH+1, L"");         // flush string
               StringCchCatW(szExpandedFilename, MAX_PATH+1, cSrcDrive);  // add drive info
               StringCchCatW(szExpandedFilename, MAX_PATH+1, cSrcDir);    // add directory info
               StringCchCatW(szExpandedFilename, MAX_PATH+1, cSrcPath);   // add original specified path and filename
            }

            if (_waccess(szExpandedFilename,0))
            {
                // still dont have the file.  Must be invalid include.  Set the name back and report the error 

                DWORD nRes = ExpandEnvironmentStrings(cFileName,
                                                    szExpandedFilename,
                                                    FILENAME_MAX);
                if (nRes == 0)
                {
                    //That failed!
                    StringCchCopyW(szExpandedFilename, MAX_PATH+1, cFileName);
                }
                Trace(true, pDbg, ERROR_INCLUDING_ABSENT, szExpandedFilename);
                pLex->SetError(CMofLexer::invalid_include_file);
                return WBEM_E_FAILED;
            }

            sc = WriteFileToTemp(szExpandedFilename, pTempFile, sofar, pDbg, pLex);
            WriteLineAndFilePragma(pTempFile, pFileName, 1);
            if(sc != S_OK)
                break;
        }
        else
        {
            iLine++;
            WriteLine(pTempFile, pLine);
        }
    }

    // remove the entry so that the file can be included more than once at the same level

    if(iSoFarPos != -1)
    {
        TCHAR * pTemp = (TCHAR * )sofar.GetAt(iSoFarPos);
        if(pTemp)
        {
            delete pTemp;
            sofar.RemoveAt(iSoFarPos);
        }
    }
    return sc;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\trace.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    TRACE.CPP

Abstract:

    Support of trace output and internationalized strings.

History:

    a-davj  13-July-97   Created.

--*/

#include "precomp.h"
#include <wbemcli.h>
#include "trace.h"
#include <autoptr.h>

extern HINSTANCE ghModule; 


TCHAR JustInCase = 0;

BSTR GetFromStdErrorFacility(HRESULT hres)
{

	HRESULT hTemp = hres;
	
	// Certain strings are obtained from the standard facility rather
	// than the local string table.

	if(hres == WBEM_E_NOT_FOUND || hres == WBEM_E_TYPE_MISMATCH || hres == WBEM_E_OVERRIDE_NOT_ALLOWED ||
		hres == WBEM_E_PROPAGATED_QUALIFIER || hres == WBEM_E_VALUE_OUT_OF_RANGE)
		return NULL;

	// we are only interested in 0x8004xxxx values.

	hTemp &= 0xffff0000;
	if(hTemp != 0x80040000)
		return NULL;

	// attempt to read the string from the usual place
	IWbemStatusCodeText * pStatus = NULL;
	SCODE sc = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
										IID_IWbemStatusCodeText, (LPVOID *) &pStatus);

	if(FAILED(sc))
		return NULL;
	BSTR bstrError = 0;
	sc = pStatus->GetErrorCodeText(hres, 0, 0, &bstrError);
	pStatus->Release();
	if(sc == S_OK)
		return bstrError;
	else
		return NULL;
}

IntString::IntString(DWORD dwID)
{
    DWORD dwSize, dwRet, dwLen = 0;

    // see if the message can be obtained for the standard place
    
    BSTR bstrErrMsg = GetFromStdErrorFacility((HRESULT)dwID);
    if(bstrErrMsg)
    {
        dwLen = lstrlen(bstrErrMsg)+1;
        m_pString = new TCHAR[dwLen];
        if(m_pString == NULL)
        {
            SysFreeString(bstrErrMsg);
            m_pString = &JustInCase;     // should never happen!
            return; 
        }
        StringCchCopyW(m_pString, dwLen, bstrErrMsg);
        SysFreeString(bstrErrMsg);
        return; 
    }

	// Get the message from the string table.

    m_pString = &JustInCase;
    for(dwSize = 128; dwSize < 4096; dwSize *= 2)
    {

        wmilib::auto_buffer<TCHAR> p(new TCHAR[dwSize]);
        if(NULL == p.get())
        {
            return; 
        }
        dwRet = LoadString( ghModule, dwID, p.get(), dwSize);

        // Check for failure to load

        if(dwRet == 0)
        {
            return; 
        }
        // Check for the case where the buffer was too small

        if((dwRet + 1) >= dwSize)
        {
            //overrun, just loop
        }
        else
        {
            m_pString = p.release(); 
            return;             // all is well!
        }                   
    }
}

IntString::~IntString()
{
    if(m_pString != &JustInCase)
        delete(m_pString);
}
 
void CopyOrConvert(TCHAR * pTo, WCHAR * pFrom, int iLen)
{ 
#ifdef UNICODE
    wcsncpy(pTo, pFrom,iLen);
#else
    wcstombs(pTo, pFrom, iLen);
#endif
    pTo[iLen-1] = 0;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\trace.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    TRACE.H

Abstract:

	Declares the Trace functions.

History:

	a-davj  13-July-97   Created.

--*/

#ifndef __TRACE__H_
#define __TRACE__H_

class DebugInfo
{
public:
	bool m_bPrint;
	WCHAR m_wcError[100];
	HRESULT hresError;
	void SetString(WCHAR * pIn){ wcsncpy(m_wcError, pIn, 99);};
	DebugInfo(bool bPrint) {m_bPrint = bPrint; m_wcError[0] = 0;m_wcError[99] = 0;hresError=0;};
	WCHAR * GetString(){return m_wcError;};
};

typedef DebugInfo * PDBG;

int Trace(bool bError, PDBG pDbg, DWORD dwID, ...);

class IntString
{
    TCHAR *m_pString;
public:
	 IntString(DWORD dwID);
	~IntString();
    operator TCHAR *() { return m_pString; } 
};

void CopyOrConvert(TCHAR * pTo, WCHAR * pFrom, int iLen);

class ParseState
{
public:
    int m_iPos;
    int m_nToken;
    ParseState(){ m_iPos=0; m_nToken= 0;};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\typehelp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TYPEHELP.H

Abstract:

History:

--*/

#include "parmdefs.h"

WCHAR * Macro_CloneStr(LPCWSTR pFr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_tool\mofcomp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MOFCOMP.CPP

Abstract:

    Entry points for the WBEM MOF compiler.

History:

    a-davj  12-April-97   Added WMI support.

--*/

#include "precomp.h"
#include <stdio.h>
#include <locale.h>
#include <initguid.h>
#include <wbemidl.h>
#include <winver.h>
#include <cominit.h>
#include <wbemutil.h>
#include <wbemcli.h>
#include <mofcomp.h>
#include <cominit.h>
#include <objidl.h>
#include <dllcalls.h>
#include "mofutils.h"
#include "strings.h"
char cFileName[MAX_PATH];
WCHAR wFileName[MAX_PATH];
WCHAR wBMOFFileName[MAX_PATH];

int __cdecl main(int argc, char** argv)
{ 
    cFileName[0] = 0;
    wFileName[0] = 0;
    wBMOFFileName[0]= 0;
    bool bBmofSet = false;

    // Set locale so that strings are correctly processed.
    // ===================================================
    setlocale(LC_ALL, "");    

    HRESULT hres;
    SCODE sc;

    // Parse command line arguments
    // ============================
    WCHAR UserName[MAX_PATH];
    WCHAR Password[MAX_PATH];
    WCHAR * pPassword = NULL;
    WCHAR Authority[MAX_PATH];
    WCHAR wszDefault[MAX_PATH];

    TCHAR pVersion[100];
    BOOL bRet = GetVerInfo(TEXT("ProductVersion"), pVersion, 100); 
    if(bRet)
    Trace(false, LONGVERSION, pVersion);
    else
    Trace(false, SHORTVERSION);
    Trace(false, COPYRIGHT);
    if(argc < 2)
    {
        PrintUsage();
        return 1;
    }

    // Set locale so that strings are correctly processed.
    // ===================================================
    setlocale(LC_ALL, "");    

    // Init buffers for command line args.
    // ===================================
    UserName[0] = 0;
    Password[0] = 0;
    Authority[0] = 0;
    wszDefault[0] = 0;
    long lLoginFlags = 0;

    // This scope is defined so that the local variables, such as the PARSE 
    // object are destroyed before CoUninitialize is called.

    char cBMOFOutputName[MAX_PATH] = "";

    // Parse command line arguments
    // ============================

    bool bClassFlagsHardcoded = false;
    bool bInstanceFlagsHardcoded = false;
    long lClassFlags = 0;
    long lInstanceFlags = 0;
    long lOptionFlags = WBEM_FLAG_CONSOLE_PRINT;

    for(int i = 1; i < argc-1; i++)
    {
        char *pcCurrArg = argv[i] + 1; 
        if(argv[i][0] != '-' && argv[i][0] != '/')
        {
            PrintUsage();
            return 1;
        }
        if(!wbem_stricmp(pcCurrArg, "check"))
        {
            lOptionFlags |= WBEM_FLAG_CHECK_ONLY;
        }
        else if(!wbem_stricmp(pcCurrArg, "AUTORECOVER"))
        {
            lOptionFlags |= WBEM_FLAG_AUTORECOVER;
        }
        else if(!wbem_stricmp(pcCurrArg, "WMI"))
        {
            HINSTANCE hLib  = LoadLibraryEx(TEXT("wmimofck.exe"), NULL, LOAD_LIBRARY_AS_DATAFILE);
            if(hLib == NULL)
            {
                Trace(true, WMI_NOT_SETUP);
                return 1;
            }
            else FreeLibrary(hLib);
            lOptionFlags |= WBEM_FLAG_WMI_CHECK;
        }
        else if(!wbem_stricmp(pcCurrArg, "class:updateonly"))
        {
            lClassFlags |= WBEM_FLAG_UPDATE_ONLY;
        }
        else if(!wbem_stricmp(pcCurrArg, "class:createonly"))
        {
            lClassFlags |= WBEM_FLAG_CREATE_ONLY;
        }
        else if(!wbem_stricmp(pcCurrArg, "class:safeupdate"))
        {
            lClassFlags |= WBEM_FLAG_UPDATE_SAFE_MODE;
        }
        else if(!wbem_stricmp(pcCurrArg, "class:forceupdate"))
        {
            lClassFlags |= WBEM_FLAG_UPDATE_FORCE_MODE;
        }
        else if(!wbem_stricmp(pcCurrArg, "instance:updateonly"))
        {
            if(lInstanceFlags != 0)
            {
            PrintUsage();
            return 1;
            }
            lInstanceFlags = WBEM_FLAG_UPDATE_ONLY;
        }
        else if(!wbem_stricmp(pcCurrArg, "instance:createonly"))
        {
            if(lInstanceFlags != 0)
            {
            PrintUsage();
            return 1;
            }
            lInstanceFlags = WBEM_FLAG_CREATE_ONLY;
        }
        else if(!wbem_strnicmp(pcCurrArg, "Amendment:", 10))
        {
            if(strlen(pcCurrArg) <=10)
            {
                PrintUsage();
                return 1;
            }
            strcat(cBMOFOutputName, ",a");
            strcat(cBMOFOutputName, pcCurrArg+10);
            mbstowcs(wBMOFFileName, cBMOFOutputName, MAX_PATH);
            lOptionFlags |= WBEM_FLAG_SPLIT_FILES;
        }
        else if(!wbem_strnicmp(pcCurrArg, "mof:", 4))
        {
            if(strlen(pcCurrArg) <=4)
            {
                PrintUsage();
                return 1;
            }
            strcat(cBMOFOutputName, ",n");
            strcat(cBMOFOutputName, pcCurrArg+4);
            mbstowcs(wBMOFFileName, cBMOFOutputName, MAX_PATH);
            lOptionFlags |= WBEM_FLAG_SPLIT_FILES;
        }
        else if(!wbem_strnicmp(pcCurrArg, "mfl:", 4))
        {
            if(strlen(pcCurrArg) <=4)
            {
                PrintUsage();
                return 1;
            }
            strcat(cBMOFOutputName, ",l");
            strcat(cBMOFOutputName, pcCurrArg+4);
            mbstowcs(wBMOFFileName, cBMOFOutputName, MAX_PATH);
            lOptionFlags |= WBEM_FLAG_SPLIT_FILES;
        }
        else if(toupper(pcCurrArg[0]) == 'C' && pcCurrArg[1] == ':')
        {
            if(lClassFlags != 0)
            {
            PrintUsage();
            return 1;
            }
                bClassFlagsHardcoded = true;
            lClassFlags = atol(&pcCurrArg[2]);
        }
        else if(toupper(pcCurrArg[0]) == 'I' && pcCurrArg[1] == ':')
        {
            if(lInstanceFlags != 0)
            {
            PrintUsage();
            return 1;
            }
                bInstanceFlagsHardcoded = true;
            lInstanceFlags = atol(&pcCurrArg[2]);
        }
        else if(toupper(*pcCurrArg) == 'N')
        {
            if(!bGetString(argv[i]+2, wszDefault))
            return 1;
        }
        else if(toupper(*pcCurrArg) == 'B')
        {
            if(strlen(argv[i]) <=3 || argv[i][2] != ':' || wcslen(wBMOFFileName))
            {
                PrintUsage();
                return 1;
            }
            strcpy(cBMOFOutputName, argv[i]+3);
            mbstowcs(wBMOFFileName, cBMOFOutputName, MAX_PATH);
            bBmofSet = true;
        }
        else if(toupper(*pcCurrArg) == 'U')
        {
            if(!bGetString(argv[i]+2, UserName))
            return 1;
        }
        else if(toupper(*pcCurrArg) == 'P')
        {
            // Allow for blank password
    
            char * pArg = argv[i];
            if(pArg[2] != ':' || pArg[3] != 0)         // Dont use bGetString for empty password case
            if(!bGetString(argv[i]+2, Password))
                return 1;
            pPassword = Password;
        }
        else if(toupper(*pcCurrArg) == 'A')
        {
            if(!bGetString(argv[i]+2, Authority))
            return 1;
        }

        else
        {
            PrintUsage();
            return 1;
        }
    }


    // Do a sanity check of the flags chosen

    if((bClassFlagsHardcoded == false && !ValidFlags(true, lClassFlags)) || 
       (bInstanceFlagsHardcoded == false && !ValidFlags(false, lInstanceFlags)))
    {
        PrintUsage();
        return 1;
    }

    if((lOptionFlags & WBEM_FLAG_WMI_CHECK) && strlen(cBMOFOutputName) < 1)
    {
        Trace(true, WMI_ARG_ERROR);
        return 1;
    }

    if(strcmp(argv[argc-1], "-?") == 0 || strcmp(argv[argc-1], "/?") == 0)
    {
        PrintUsage();
        return 1;
    }
    if((lOptionFlags & WBEM_FLAG_SPLIT_FILES) && bBmofSet)
    {
        PrintUsage();
        return 1;
    }
    

    // display the file name and make sure it is a valid file

    strcpy(cFileName, argv[argc-1]);
    mbstowcs(wFileName, argv[argc-1], MAX_PATH);
#ifdef UNICODE
    if(GetFileAttributes(wFileName) == 0xFFFFFFFF)
#else
    if(GetFileAttributes(cFileName) == 0xFFFFFFFF)
#endif
    {
        Trace(true, FILE_NOT_FOUND, cFileName);
        return 1;
    }


    hres = InitializeCom();
    if(hres)
    {
        Trace(true, COMINIT_ERROR, hres);
        return 3;
    }

    WBEM_COMPILE_STATUS_INFO info;
    hres = InitializeSecurity(NULL, -1, NULL, NULL, 
                                RPC_C_AUTHN_LEVEL_CONNECT, 
                                RPC_C_IMP_LEVEL_IDENTIFY, 
                                NULL, EOAC_NONE, 0);

    if(strlen(cBMOFOutputName) > 0)
        sc = CreateBMOFViaDLL( wFileName, wBMOFFileName, wszDefault,
                    lOptionFlags, lClassFlags,
                        lInstanceFlags, &info);
    else
        sc = CompileFileViaDLL(wFileName, wszDefault, UserName, 
                        Authority, pPassword, lOptionFlags, lClassFlags,
                        lInstanceFlags, &info);
    if(sc != S_OK)
        Trace(true, COMPILER_ERROR, info.hRes);


    CoUninitialize();

    if(sc == S_OK)
    {
        Trace(true, DONE);
        return 0;
    }
    else
        return info.lPhaseError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_tool\mofutils.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MOFUTILS.H

Abstract:

	Declares the MOFUTILS functions.

History:

	a-davj  13-July-97   Created.

--*/

#ifndef __MOFUTILS__H_
#define __MOFUTILS__H_


int Trace(bool bError, DWORD dwID, ...);
void PrintUsage();
BOOL GetVerInfo(TCHAR * pResStringName, TCHAR * pRes, DWORD dwResSize);
BOOL bGetString(char * pIn, WCHAR * pOut);
bool ValidFlags(bool bClass, long lFlags);

class IntString
{
    TCHAR *m_pString;
public:
	 IntString(DWORD dwID);
	~IntString();
    operator TCHAR *() { return m_pString; } 
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_tool\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_tool\mofutils.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MOFUTILSD.CPP

Abstract:

    Support of trace output and internationalized strings.

History:

    a-davj  13-July-97   Created.

--*/

#include "precomp.h"
#include <reg.h>
#include "strings.h"
#include <stdio.h>
#include <stdarg.h>
#include <wbemutil.h>
#include <wbemcli.h>
#include "mofutils.h"

TCHAR JustInCase = 0;
 
//***************************************************************************
//
//  int Trace
//
//  DESCRIPTION:
//
//  Allows for the output function (printf in this case) to be overridden.
//
//  PARAMETERS:
//
//  *fmt                format string.  Ex "%s hello %d"
//  ...                 argument list.  Ex cpTest, 23
//
//  RETURN VALUE:
//
//  size of output in characters.
//***************************************************************************

int Trace(bool bError, DWORD dwID, ...)
{

    IntString is(dwID);
    TCHAR * fmt = is;

    TCHAR *buffer = new TCHAR[2048];
    if(buffer == NULL)
        return 0;
    char *buffer2 = new char[4096];
    if(buffer2 == NULL)
    {
        delete buffer;
        return 0;
    }

    va_list argptr;
    int cnt;
    va_start(argptr, dwID);

#ifdef UNICODE
    cnt = _vsnwprintf(buffer, 2048, fmt, argptr);
#else
    cnt = _vsnprintf(buffer, 2048, fmt, argptr);
#endif
    va_end(argptr);
    CharToOem(buffer, buffer2);

    printf("%s", buffer2);
    if(bError)
        ERRORTRACE((LOG_MOFCOMP,"%s", buffer2));
    else
        DEBUGTRACE((LOG_MOFCOMP,"%s", buffer2));

    delete buffer;
    delete buffer2;
    return cnt;
}

void PrintUsage()
{
    Trace(false, USAGE1);
    Trace(false, USAGE1A);
    Trace(false, USAGE1B);
    Trace(false, USAGE1C);
    Trace(false, USAGE1D);
    Trace(false, USAGE1E);
    Trace(false, USAGE1F);
    Trace(false, USAGE2);
    Trace(false, USAGE3);
    Trace(false, USAGE4);
    Trace(false, USAGE4a);
    Trace(false, USAGE4b);
    Trace(false, USAGE5);
    Trace(false, USAGE6);
    Trace(false, USAGE7);
    Trace(false, USAGE8);
    Trace(false, USAGE9);
    Trace(false, USAGE10);
    Trace(false, USAGE11);
    Trace(false, USAGE12);
    Trace(false, USAGE12A);
    Trace(false, USAGE12B);
    Trace(false, USAGE12C);
    Trace(false, USAGE12D);
    Trace(false, USAGE12E);
    Trace(false, USAGE13);
    Trace(false, USAGE14);
}
//******************************************************************************
//
//  See GETVER.H for documentation
//
//******************************************************************************
BOOL GetVerInfo(TCHAR * pResStringName, 
                        TCHAR * pRes, DWORD dwResSize)
{
    // Extract Version informatio

    DWORD dwTemp, dwSize = MAX_PATH;
    TCHAR cName[MAX_PATH];
    BOOL bRet = FALSE;
    HINSTANCE hInst = GetModuleHandle(NULL);
    long lSize = GetModuleFileName(hInst, cName, MAX_PATH); 
    if(lSize == 0)
        return FALSE;
    lSize = GetFileVersionInfoSize(cName, &dwTemp);
    if(lSize < 1)
        return FALSE;
    
    TCHAR * pBlock = new TCHAR[lSize];
    if(pBlock != NULL)
    {
        bRet = GetFileVersionInfo(cName, NULL, lSize, pBlock);

        if(bRet)
        {
            TCHAR lpSubBlock[MAX_PATH];
            TCHAR * lpBuffer = NULL;
            UINT wBuffSize = MAX_PATH;

            short * piStuff; 
            bRet = VerQueryValue(pBlock, TEXT("\\VarFileInfo\\Translation") , (void**)&piStuff, &wBuffSize);
            if(bRet)
            {
                wsprintf(lpSubBlock,TEXT("\\StringFileInfo\\%04x%04x\\%s"),piStuff[0], piStuff[1],"ProductVersion");
                bRet = VerQueryValue(pBlock, lpSubBlock, (void**)&lpBuffer, &wBuffSize);
            }
            if(bRet == FALSE)
            {
                // Try again in english
                wsprintf(lpSubBlock,TEXT("\\StringFileInfo\\040904E4\\%s"),pResStringName);                        
                bRet = VerQueryValue(pBlock, lpSubBlock,(void**)&lpBuffer, &wBuffSize);
            }
            if(bRet)
                lstrcpyn(pRes, lpBuffer, dwResSize);
        }

        delete pBlock;
    }
    return bRet;
}


IntString::IntString(DWORD dwID)
{
    DWORD dwSize, dwRet;

    for(dwSize = 128; dwSize < 4096; dwSize *= 2)
    {
        m_pString = new TCHAR[dwSize];
        if(m_pString == NULL)
        {
            m_pString = &JustInCase;     // should never happen!
            return; 
        }
        dwRet = LoadString( GetModuleHandle(NULL), dwID, m_pString, dwSize);

        // Check for failure to load

        if(dwRet == 0)
        {
            m_pString = &JustInCase;     // should never happen!
            return; 
        }
        // Check for the case where the buffer was too small

        if((dwRet + 1) >= dwSize)
            delete m_pString;
        else
            return;             // all is well!
    }
}

IntString::~IntString()
{
    if(m_pString != &JustInCase)
        delete(m_pString);
}
 
//***************************************************************************
//
//  BOOL bGetString
//
//  DESCRIPTION:
//
//  Converts a command line argument into a WCHAR string.  Note that the arugment is 
//  of the form /X:stuff.  This is passed a pointer to the colon.
//
//  PARAMETERS:
//
//  pArg                Input, pointer to the colon
//  pOut                Points the the output buffer where the data is to be copied.
//                      IT IS ASSUMED THAT pOut points to a buffer of MAX_PATH length
//
//
//  RETURN VALUE:
//
//  TRUE if OK
//
//***************************************************************************

BOOL bGetString(char * pIn, WCHAR * pOut)
{
    if(pIn == NULL)
        return FALSE;
    if(*pIn != ':')
    {
        PrintUsage();
        return FALSE;
    }
    pIn++;          // skip passed the colon
    int iLen = mbstowcs(NULL, pIn, strlen(pIn)+1);
    if(iLen > MAX_PATH-1)
    {
        PrintUsage();
        return FALSE;
    }
    
    int iRet = mbstowcs(pOut, pIn, MAX_PATH-1);
    if(iRet < 1)
    {
        PrintUsage();
        return FALSE;
    }
    return TRUE;
}
//***************************************************************************
//
//  ValidFlags.
//
//***************************************************************************

bool ValidFlags(bool bClass, long lFlags)
{
    if(bClass)
        return  ((lFlags == WBEM_FLAG_CREATE_OR_UPDATE) ||
             (lFlags == WBEM_FLAG_UPDATE_ONLY) ||
             (lFlags == WBEM_FLAG_CREATE_ONLY) ||
             (lFlags == WBEM_FLAG_UPDATE_SAFE_MODE) ||
             (lFlags == WBEM_FLAG_UPDATE_FORCE_MODE) ||
             (lFlags == (WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_SAFE_MODE)) ||
             (lFlags == (WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_FORCE_MODE)));
    else
        return 
        ((lFlags == WBEM_FLAG_CREATE_OR_UPDATE) ||
             (lFlags == WBEM_FLAG_UPDATE_ONLY) ||
             (lFlags == WBEM_FLAG_CREATE_ONLY));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_tool\strings.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    STRINGS.H

Abstract:

	Resource definitions

History:

--*/


#define USAGE1 0
#define USAGE1A USAGE1+1
#define USAGE1B USAGE1A+1
#define USAGE1C USAGE1B+1
#define USAGE1D USAGE1C+1
#define USAGE1E USAGE1D+1
#define USAGE1F  USAGE1E+1
#define USAGE2  USAGE1F+1
#define USAGE3  USAGE2+1
#define USAGE4  USAGE3+1
#define USAGE4a  USAGE4+1
#define USAGE4b  USAGE4a+1
#define USAGE5  USAGE4b+1
#define USAGE6  USAGE5+1
#define USAGE7  USAGE6+1
#define USAGE8  USAGE7+1
#define USAGE9  USAGE8+1
#define USAGE10 USAGE9+1
#define USAGE11 USAGE10+1
#define USAGE12  USAGE11+1
#define USAGE12A  USAGE12+1
#define USAGE12B  USAGE12A+1
#define USAGE12C  USAGE12B+1
#define USAGE12D  USAGE12C+1
#define USAGE12E  USAGE12D+1

#define USAGE13  USAGE12E+1
#define USAGE14  USAGE13+1
#define WMI_ARG_ERROR  USAGE14+1
#define PARSING_MSG     WMI_ARG_ERROR+1
#define FILE_NOT_FOUND  PARSING_MSG+1
#define WMI_NOT_SETUP FILE_NOT_FOUND+1

#define  SUCCESS WMI_NOT_SETUP+1
#define  DONE SUCCESS+1
#define  WMI_LAUNCH_ERROR DONE+1
#define LONGVERSION WMI_LAUNCH_ERROR+1
#define SHORTVERSION LONGVERSION+1
#define COPYRIGHT SHORTVERSION+1
#define CCI_ERROR   COPYRIGHT+1
#define COMINIT_ERROR CCI_ERROR+1
#define COMPILER_ERROR COMINIT_ERROR+1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\msgmain.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <commain.h>
#include <clsfac.h>
#include "msgsvc.h"
#include "multsend.h"
#include "smrtmrsh.h"
#include "rpcsend.h"
#include "rpcrecv.h"

class CMsgServer : public CComServer
{
    HRESULT Initialize()
    {
        ENTER_API_CALL

        BOOL bRes;
        HRESULT hr;
        CWbemPtr<CUnkInternal> pFactory;

        pFactory = new CSingletonClassFactory<CMsgServiceNT>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiMessageService, 
                           pFactory,
                           TEXT("Message Service"), 
                           TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }
        
        pFactory = new CSimpleClassFactory<CMsgRpcSender>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiMessageRpcSender, 
                           pFactory,
                           TEXT("Rpc Message Sender"), 
                           TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }

        pFactory = new CSimpleClassFactory<CMsgRpcReceiver>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiMessageRpcReceiver, 
                           pFactory,
                           TEXT("Rpc Message Receiver"), 
                           TRUE );
        
        if ( FAILED(hr) )
        {
            return hr;
        }

        pFactory = new CSimpleClassFactory<CMsgMultiSendReceive>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiMessageMultiSendReceive, 
                           pFactory,
                           TEXT("Message Multi SendReceive"), 
                           TRUE );
        
        if ( FAILED(hr) )
        {
            return hr;
        }

        pFactory= new CSimpleClassFactory<CSmartObjectMarshaler>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiSmartObjectMarshal,
                           pFactory,
                           TEXT("Smart Object Marshaler"), 
                           TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }

        pFactory= new CSimpleClassFactory<CSmartObjectUnmarshaler>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiSmartObjectUnmarshal,
                           pFactory,
                           TEXT("Smart Object Marshaler"), 
                           TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }

        return hr;

        EXIT_API_CALL
    }

    void UnInitialize()
    {
    }

    void Register( )
    {
    }

    void Unregister( )
    {
    }

} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\localloc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <arena.h>

static class WbemComnInitializer
{
public:

    WbemComnInitializer()
    {
        CWin32DefaultArena::WbemHeapInitialize( GetProcessHeap() );
    }

} g_WbemComnInitializer;

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\msgsvc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <assert.h>
#include <comutl.h>
#include <wbemcli.h>
#include "msgsvc.h"

/**************************************************************************
  CMsgServiceRecord - hold sink given to the msg service on Add().
***************************************************************************/

class CMsgServiceRecord : public OVERLAPPED
{
    CCritSec m_cs;
    long m_cRefs;
    CWbemPtr<IWmiMessageReceiverSink> m_pSink;

public:

    CMsgServiceRecord() : m_cRefs(0) { }

    void SetSink( IWmiMessageReceiverSink* pSink )
    {
        CInCritSec ics(&m_cs);
        m_pSink = pSink;
    }

    void AddRef()
    {
        InterlockedIncrement( &m_cRefs );
    }

    void Release()
    {
        if ( InterlockedDecrement( &m_cRefs ) == 0 )
        {
            delete this;
        }
    }
        
    HRESULT Receive()
    {
        CInCritSec ics(&m_cs);
        
        if ( m_pSink == NULL )
        {
            return WBEM_E_SHUTTING_DOWN;
        }

        return m_pSink->Receive( this );
    }

    HRESULT Notify()
    {
        CInCritSec ics(&m_cs);
        
        if ( m_pSink == NULL )
        {
            return WBEM_E_SHUTTING_DOWN;
        }
        
        return m_pSink->Notify( this );
    }
};

/*****************************************************************************
  CMsgService
******************************************************************************/

ULONG CMsgService::SyncServiceFunc( void* pCtx )
{
    HRESULT hr;

    CMsgServiceRecord* pRecord = (CMsgServiceRecord*)pCtx;

    do 
    {
        hr = pRecord->Receive();

    } while( SUCCEEDED(hr) );

    //
    // Since the record will no longer be serviced, give up our ref
    // count on it.
    //
    pRecord->Release();

    return hr;
}

ULONG CMsgService::AsyncServiceFunc( void* pCtx )
{
    HRESULT hr;

    CMsgServiceRecord* pRecord;
    CMsgService* pSvc = (CMsgService*)pCtx;

    do 
    {
        hr = pSvc->AsyncWaitForCompletion( INFINITE, &pRecord );

        if ( FAILED(hr) )
        {
            //
            // exit loop. hr will describe whether it was normal or not. 
            //
            break;
        }

        if ( hr == S_OK ) 
        {
            //
            // hr can be S_FALSE as well.  this occurrs when the 
            // first submit is performed.  In this case, we don't do 
            // the notify.
            //
            hr = pRecord->Notify();
        }

        if ( SUCCEEDED(hr) ) 
        {
            hr = pSvc->AsyncReceive( pRecord );
        }

        if ( FAILED(hr) ) 
        {
            //
            // Since the record will no longer be serviced, give up our ref
            // count on it.
            //
            pRecord->Release();
        }

    } while ( 1 );
        
    return hr;
}

/*********************************************************************
  CMsgService 
**********************************************************************/

CMsgService::CMsgService( CLifeControl* pControl )
 : m_XService( this ), CUnkInternal( pControl ),
   m_hThread( INVALID_HANDLE_VALUE ), m_cSvcRefs( 0 ), m_bAsyncInit( FALSE )
{
    
}

void* CMsgService::GetInterface( REFIID riid )
{
    if ( riid == IID_IWmiMessageService )
    {
        return &m_XService;
    }
    return NULL;
}

CMsgService::~CMsgService()
{
    if ( m_bAsyncInit )
    {
        //
        // wait for async thread to complete. TODO: print error here if 
        // WaitForSingleObject times out.  
        //
        WaitForSingleObject( m_hThread, 5000 );
        CloseHandle( m_hThread );
    }
} 

HRESULT CMsgService::EnsureService( BOOL bAsync )
{
    HRESULT hr;

    if ( !bAsync )
    {
        return S_OK;
    }

    CInCritSec ics( &m_cs );

    if ( m_bAsyncInit )
    {
        return S_OK;
    }

    assert( m_hThread == INVALID_HANDLE_VALUE );

    //
    // must make sure that all async initialization is performed  
    // before starting the async thread(s).
    //

    hr = AsyncInitialize();

    if ( FAILED(hr) )
    {
        return hr;
    }

    m_hThread = CreateThread( NULL, 
                              0, 
                              AsyncServiceFunc, 
                              this,  
                              0, 
                              NULL ); 

    if ( m_hThread == INVALID_HANDLE_VALUE )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    m_bAsyncInit = TRUE;

    return S_OK;
}

HRESULT CMsgService::Remove( void* pHdl )
{
    CMsgServiceRecord* pRecord = (CMsgServiceRecord*)pHdl;
    
    //
    // setting the sink to null will ensure that no callbacks 
    // will occur.
    //    
    pRecord->SetSink( NULL );

    //
    // the client will not be using the record anymore so release its ref.
    //
    pRecord->Release();

    return S_OK;
}

HRESULT CMsgService::Add( CMsgServiceRecord* pRecord,
                          HANDLE hFileOverlapped,
                          DWORD dwFlags )
{
    HRESULT hr;

    hr = EnsureService( TRUE );
        
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = AsyncAddOverlappedFile( hFileOverlapped, pRecord );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CMsgService::Add( CMsgServiceRecord* pRec, DWORD dwFlags )
{
    HRESULT hr;

    hr = EnsureService( FALSE );

    HANDLE hThread = CreateThread( NULL, 0, SyncServiceFunc, pRec, 0, NULL );
 
    if ( hThread == INVALID_HANDLE_VALUE )
    {
         return HRESULT_FROM_WIN32( GetLastError() );
    }

    CloseHandle( hThread );

    return WBEM_S_NO_ERROR;
}  

HRESULT CMsgService::XService::Add( IWmiMessageReceiverSink* pSink, 
                                    HANDLE* phFileOverlapped,
                                    DWORD dwFlags,
                                    void** ppHdl )
{
    ENTER_API_CALL
   
    HRESULT hr;

    *ppHdl = NULL;

    //
    // create the msg service record for this sink.
    //

    CWbemPtr<CMsgServiceRecord> pRecord = new CMsgServiceRecord;
    
    if ( pRecord == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pRecord->SetSink( pSink );

    //
    // initialize for async or sync operation
    //

    if ( phFileOverlapped )
    {
        hr = m_pObject->Add( pRecord, *phFileOverlapped, dwFlags );
    }
    else
    {
        hr = m_pObject->Add( pRecord, dwFlags );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // the msg service keeps a ref count now on the record until its sure 
    // that it is no longer being serviced.  
    //
    pRecord->AddRef();

    //
    // caller now owns a ref as well.  This will be released in Remove().
    //
    pRecord->AddRef();
    *ppHdl = pRecord;

    return WBEM_S_NO_ERROR;

    EXIT_API_CALL
}
 
HRESULT CMsgService::XService::Remove( void* pHdl )
{
    ENTER_API_CALL
    return m_pObject->Remove( pHdl );
    EXIT_API_CALL
}

/*************************************************************************
  CMessageServiceNT
**************************************************************************/

#define SHUTDOWN_COMPLETION_KEY 0xfffffffe
#define INITRECV_COMPLETION_KEY 0xfffffffd

CMsgServiceNT::CMsgServiceNT( CLifeControl* pControl ) 
 : CMsgService( pControl ), m_hPort( INVALID_HANDLE_VALUE )
{
    
}

CMsgServiceNT::~CMsgServiceNT()
{
    if ( m_hPort != INVALID_HANDLE_VALUE )
    {
        CloseHandle( m_hPort );
    }
}

HRESULT CMsgServiceNT::AsyncAddOverlappedFile( HANDLE hOverlappedFile,
                                               CMsgServiceRecord* pRec )
{
    //
    // add the file handle that was given to us to the completion port.
    // when the receiver closes this file handle, it will be removed from 
    // the completion port automatically.
    //

    HANDLE hPort = CreateIoCompletionPort( hOverlappedFile, m_hPort, 0, 0 );

    if ( hPort == INVALID_HANDLE_VALUE )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    assert( hPort == m_hPort );

    //
    // now perform the first receive on the record.  We cannot do it on this
    // thread because overlapped i/o cancels requests if the thread that 
    // issued them is brought down before the i/o completes.  To work around 
    // this, we post a request to the completion port and wait for it
    // to be received.
    // 

    if ( !PostQueuedCompletionStatus( m_hPort, 
                                      0, 
                                      INITRECV_COMPLETION_KEY, 
                                      pRec ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return S_OK;
}

//
// assumes already locked.
//

HRESULT CMsgServiceNT::AsyncInitialize()
{
    if ( m_hPort != INVALID_HANDLE_VALUE )
    {
        return S_OK;
    }

    m_hPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE, 
                                      NULL, 
                                      NULL, 
                                      0 );
    
    if ( m_hPort == INVALID_HANDLE_VALUE )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    return S_OK;
}

HRESULT CMsgServiceNT::AsyncShutdown( DWORD cThreads )
{
    //
    // this method has the responsibility breaking the async thread(s) out
    // of their svc loop.
    //

    assert( m_hPort != INVALID_HANDLE_VALUE );

    for( DWORD i=0; i < cThreads; i++ )
    {
        PostQueuedCompletionStatus( m_hPort, 0, SHUTDOWN_COMPLETION_KEY, NULL);
    }

    return S_OK;
}

HRESULT CMsgServiceNT::AsyncReceive( CMsgServiceRecord* pRecord )
{
    ZeroMemory( pRecord, sizeof(OVERLAPPED) );
    return pRecord->Receive();        
}

HRESULT CMsgServiceNT::AsyncWaitForCompletion( DWORD dwTimeout,
                                               CMsgServiceRecord** ppRecord)
{
    BOOL bRes;
    ULONG dwBytesTransferred;
    ULONG_PTR dwCompletionKey;   
    LPOVERLAPPED lpOverlapped;
    *ppRecord = NULL;

    bRes = GetQueuedCompletionStatus( m_hPort,
                                      &dwBytesTransferred,
                                      &dwCompletionKey,
                                      &lpOverlapped,
                                      dwTimeout );

    if ( bRes )
    {
        if ( dwCompletionKey == SHUTDOWN_COMPLETION_KEY )
        {
            return WBEM_E_SHUTTING_DOWN;
        }
    }
    else if ( lpOverlapped == NULL )
    {
        //
        // usually happens when the operation times out. HR will tell caller
        // if this is the case.
        //
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // if we're here, then this means that we've sucessfully dequeued a 
    // completion packet.  However, the i/o operation may have failed 
    // ( bRes is FALSE ).  In this case the overlapped structure will 
    // contain the needed error information.  
    //

    *ppRecord = (CMsgServiceRecord*)lpOverlapped;

    //
    // we must also handle the case where this is an initial receive 
    // completion.  This happens when a receiver is first added.  Since
    // we can't issue a receive on the adding thread, we must do it on our 
    // worker threads.  In this case, we return S_FALSE to signal to the 
    // Async handling routine that there was no prior submit and a notify
    // should NOT be formed.  
    //
    return dwCompletionKey != INITRECV_COMPLETION_KEY ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <ole2.h>
#include <windows.h>
#include <wincrypt.h>
#include <transact.h>
#include <mq.h>
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\msgsvc.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef __MSGSVC_H__
#define __MSGSVC_H__

#include <wmimsg.h>
#include <unk.h>
#include <sync.h>

class CMsgServiceRecord;

/*********************************************************************
  CMsgService 
**********************************************************************/

class CMsgService : public CUnkInternal // will be singleton
{
    class XService : CImpl<IWmiMessageService, CMsgService>
    {
    public:

        STDMETHOD(Add)( IWmiMessageReceiverSink* pSink, 
                        HANDLE* phFileOverlapped,
                        DWORD dwFlags,
                        void** ppHdl );

        STDMETHOD(Remove)( void* pHdl );

        XService( CMsgService* pObj ) 
         : CImpl<IWmiMessageService, CMsgService> ( pObj ) { }

    } m_XService;

    CCritSec m_cs;
    long m_cSvcRefs;
    HANDLE m_hThread;
    BOOL m_bAsyncInit;

    static ULONG WINAPI AsyncServiceFunc( void* pCtx );
    static ULONG WINAPI SyncServiceFunc( void* pCtx );
    
    HRESULT EnsureService( BOOL bAsync );
    HRESULT CheckShutdown();
    
protected:

    virtual HRESULT AsyncInitialize() = 0;

    //
    // This call notifies the overlapped impl that it is must take care
    // of the first receive on the message service record.  It also 
    // gives the overlapped impl a chance to do something with the 
    // the file handle associated with overlapped i/o.  For example, 
    // completion port impl will add the file handle to the port.
    //  
    virtual HRESULT AsyncAddOverlappedFile( HANDLE hOverlapped,
                                            CMsgServiceRecord* pRecord ) = 0;
        
    //
    // responsible for causing all threads to break out of their svc loop. 
    // returns S_OK if it was successful.
    //
    virtual HRESULT AsyncShutdown( DWORD cThreads ) = 0;
   
    //
    // initializes overlapped struct and calls sink's receive(). 
    // passes result from sink's receive back.
    //
    virtual HRESULT AsyncReceive( CMsgServiceRecord* pRecord ) = 0;
    
    //
    // returns S_FALSE if a notify should not be performed by worker thread
    // returns S_OK if a notify should be performed by worker thread
    //
    virtual HRESULT AsyncWaitForCompletion( DWORD dwTimeout, 
                                            CMsgServiceRecord** ppRec) = 0;

public:
    
    CMsgService( CLifeControl* pControl );
    virtual ~CMsgService();

    void* GetInterface( REFIID riid );

    HRESULT Add( CMsgServiceRecord* pRec, HANDLE hFileOvrlapd, DWORD dwFlags );

    HRESULT Add( CMsgServiceRecord* pRec, DWORD dwFlags );

    HRESULT Remove( void* pHdl );
};

/***************************************************************************
  CMsgServiceNT - implements async part of MsgService using Completion ports.
****************************************************************************/

class CMsgServiceNT : public CMsgService
{
    HANDLE m_hPort;
    
public:

    CMsgServiceNT( CLifeControl* pControl );
    ~CMsgServiceNT();

    HRESULT AsyncAddOverlappedFile( HANDLE hOverlappedFile, 
                                    CMsgServiceRecord* pRecord );
    HRESULT AsyncInitialize();
    HRESULT AsyncShutdown( DWORD cThreads );
    HRESULT AsyncReceive( CMsgServiceRecord* pRecord );
    HRESULT AsyncWaitForCompletion(DWORD dwTimeout, CMsgServiceRecord** ppRec);
};

#endif __MSGSVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\multsend.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __MULTSEND_H__
#define __MULTSEND_H__

#include <sync.h>
#include <unk.h>
#include <comutl.h>
#include <wmimsg.h>

class CMsgMultiSendReceive 
: public CUnkBase<IWmiMessageMultiSendReceive,&IID_IWmiMessageMultiSendReceive>
{
    struct SenderNode
    {
        SenderNode* m_pNext;
        CWbemPtr<IWmiMessageSendReceive> m_pVal;
        BOOL m_bTermSender;

    }* m_pTail; // tail can move as we send.

    SenderNode* m_pPrimary; // always points to the first one added.

    CCritSec m_cs;

public:

    CMsgMultiSendReceive( CLifeControl* pCtl )
      : CUnkBase< IWmiMessageMultiSendReceive,
                  &IID_IWmiMessageMultiSendReceive >(pCtl), 
       m_pTail( NULL ), m_pPrimary( NULL )
    { 
    }

    ~CMsgMultiSendReceive();

    STDMETHOD(Add)( DWORD dwFlags, 
                    IWmiMessageSendReceive* pSndRcv );
    
    STDMETHOD(SendReceive)( PBYTE pData, 
                            ULONG cData, 
                            PBYTE pAuxData,
                            ULONG cAuxData,
                            DWORD dwFlagsStatus,
                            IUnknown* pCtx );
};

#endif // __MULTSEND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\multsend.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <assert.h>
#include "multsend.h"

/*****************************************************************
  CMsgMultiSendReceive - Implements the list of senders using a circular
  list.  This allows us to easily advance the current sender when 
  encountering failures.  MultiSendReceive remembers the last good sender.
  It will keep using this until it has a problem with it. 
******************************************************************/

CMsgMultiSendReceive::~CMsgMultiSendReceive()
{
    if ( m_pTail == NULL )
    {
        return;
    }

    SenderNode* pCurr = m_pTail->m_pNext;

    while( pCurr != m_pTail )
    {
        SenderNode* pTmp = pCurr->m_pNext;
        delete pCurr;
        pCurr = pTmp;
    }

    delete m_pTail;
}

//
// Later, we could support flags that tell us where to add the sender.
// for now, we always add to the end of the list.
//
HRESULT CMsgMultiSendReceive::Add( DWORD dwFlags, 
                                   IWmiMessageSendReceive* pSndRcv) 
{
    ENTER_API_CALL

    HRESULT hr;

    SenderNode* pNew = new SenderNode;

    if ( pNew == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pNew->m_pVal = pSndRcv;
    
    CInCritSec ics(&m_cs);
    
    if ( m_pTail != NULL )
    {
        pNew->m_pNext = m_pTail->m_pNext;
        m_pTail->m_pNext = pNew;
    }
    else
    { 
        m_pPrimary = pNew;
        pNew->m_pNext = pNew;      
    }

    //
    // if the sender is also a multi sender, we handle things differently 
    // in the send logic.
    //
    if ( dwFlags & WMIMSG_FLAG_MULTISEND_TERMINATING_SENDER )
    {
        pNew->m_bTermSender = TRUE;
    }
    else
    {
        pNew->m_bTermSender = FALSE;
    }

    m_pTail = pNew;

    return S_OK;

    EXIT_API_CALL
}


//
// returns S_FALSE when succeeded but primary is not used.
//
HRESULT CMsgMultiSendReceive::SendReceive( PBYTE pData, 
                                           ULONG cData, 
                                           PBYTE pAuxData,
                                           ULONG cAuxData,
                                           DWORD dwFlags,
                                           IUnknown* pCtx )
{
    ENTER_API_CALL

    HRESULT hr;

    CInCritSec ics( &m_cs );

    if ( m_pTail == NULL )
    {
        return S_OK;
    }

    HRESULT hrReturn = S_OK;

    SenderNode* pCurr = m_pTail;
    SenderNode* pTerm = m_pTail;

    do 
    {
        pCurr = pCurr->m_pNext;

        hr = pCurr->m_pVal->SendReceive( pData, 
                                         cData, 
                                         pAuxData, 
                                         cAuxData, 
                                         dwFlags, 
                                         pCtx );

        //
        // on error we only observe the 'return immediately' flag if we are not
        // calling another multi sender.  This allows all the terminal primary
        // senders to be tried first, before resorting to alternates.  
        //

        if( SUCCEEDED(hr) || 
            pCurr->m_bTermSender && 
            dwFlags & WMIMSG_FLAG_MULTISEND_RETURN_IMMEDIATELY ) 
        {
            hrReturn = hr;
            break;
        }
        else
        {
            m_pTail = m_pTail->m_pNext;
            hrReturn = hr;
        }

    } while( pCurr != pTerm );

    if ( hrReturn != S_OK )
    {
        return hrReturn;
    }

    return m_pTail->m_pNext == m_pPrimary ? S_OK : S_FALSE;

    EXIT_API_CALL
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\rpcctx.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __RPCCTX_H__
#define __RPCCTX_H__

#include <wmimsg.h>
#include <comutl.h>
#include "rpchdr.h"

/*************************************************************************
  CMsgRpcRcvrCtx
**************************************************************************/

class CMsgRpcRcvrCtx : public IWmiMessageReceiverContext
{
    CMsgRpcHdr* m_pHdr;
    RPC_BINDING_HANDLE m_hClient;

public:

    CMsgRpcRcvrCtx( CMsgRpcHdr* pHdr, RPC_BINDING_HANDLE hClient )
    : m_pHdr(pHdr), m_hClient(hClient) {}

    STDMETHOD_(ULONG,AddRef)() { return 1; }
    STDMETHOD_(ULONG,Release)() { return 1; }
    STDMETHOD(QueryInterface)( REFIID riid, void** ppv )
    {
        if ( riid == IID_IUnknown || riid == IID_IWmiMessageReceiverContext )
        {
            *ppv = (IWmiMessageReceiverContext*)this;
            return S_OK;
        }
        return E_NOINTERFACE;
    }

    STDMETHOD(GetTimeSent)( SYSTEMTIME* pTime );

    STDMETHOD(GetSendingMachine)( WCHAR* awchMachine, 
                                  ULONG cMachine,
                                  ULONG* pcMachine );

    STDMETHOD(GetTarget)( WCHAR* awchTarget, 
                          ULONG cTarget,
                          ULONG* pcTarget );

    STDMETHOD(GetSenderId)( PBYTE achSenderId, 
                            ULONG cSenderId,
                            ULONG* pcSenderId );

    STDMETHOD(IsSenderAuthenticated)();
    STDMETHOD(ImpersonateSender)();
    STDMETHOD(RevertToSelf)();
};

#endif // __RPCCTX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\rpchdr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <time.h>
#include <wmimsg.h>
#include "rpchdr.h"

const DWORD g_dwSig = 0x6d696d77;
const BYTE g_chVersionMajor = 1;
const BYTE g_chVersionMinor = 0;

/****************************************************************************
  CMsgRpcHdr
*****************************************************************************/

CMsgRpcHdr::CMsgRpcHdr( LPCWSTR wszSource, ULONG cAuxData )
: m_wszSource( wszSource ), m_cAuxData( cAuxData ) 
{
    GetSystemTime( &m_Time );
}

HRESULT CMsgRpcHdr::Unpersist( CBuffer& rStrm )
{
    HRESULT hr;

    DWORD dwSig;
    BYTE chVersionMajor, chVersionMinor;

    //
    // read and verify signature.
    //

    hr = rStrm.Read( &dwSig, sizeof(DWORD), NULL );

    if ( hr != S_OK || dwSig != g_dwSig )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read and check version major (currently no check).
    //

    hr = rStrm.Read( &chVersionMajor, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    // 
    // read and check version minor (currently no check).
    //

    hr = rStrm.Read( &chVersionMinor, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read reserved
    //

    DWORD dwReserved;

    hr = rStrm.Read( &dwReserved, sizeof(DWORD), NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }
    
    //
    // read source machine.
    //

    hr = rStrm.ReadLPWSTR( m_wszSource );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read sent time.
    //

    hr = rStrm.Read( &m_Time, sizeof(SYSTEMTIME), NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read user header size.
    //

    hr = rStrm.Read( &m_cAuxData, sizeof(DWORD), NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT CMsgRpcHdr::Persist( CBuffer& rStrm )
{
    HRESULT hr;

    hr = rStrm.Write( &g_dwSig, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write version major.
    //

    hr = rStrm.Write( &g_chVersionMajor, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    // 
    // write version minor.
    //

    hr = rStrm.Write( &g_chVersionMinor, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write reserved flags ( currently not used ).
    //

    DWORD dwReserved = 0;
    
    hr = rStrm.Write( &dwReserved, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write source machine
    //

    hr = rStrm.WriteLPWSTR( m_wszSource );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write time sent.
    //

    hr = rStrm.Write( &m_Time, sizeof(SYSTEMTIME), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write user hdr size.
    //

    return rStrm.Write( &m_cAuxData, sizeof(DWORD), NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\rpcctx.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <sspi.h>
#include <secext.h>
#include <wmimsg.h>
#include <comutl.h>
#include "rpcctx.h"

HRESULT RpcResToWmiRes(  RPC_STATUS stat, HRESULT hrDefault )
{
    //
    // override the default error code here if a more specific one can be 
    // determined
    //

    switch( stat )
    {
    case EPT_S_NOT_REGISTERED :
        return WMIMSG_E_TARGETNOTLISTENING;

    case ERROR_ACCESS_DENIED :
        return WBEM_E_ACCESS_DENIED;
    };

    return hrDefault == S_OK ? HRESULT_FROM_WIN32(stat) : hrDefault;
}

/******************************************************/
/*         MIDL allocate and free                     */
/******************************************************/
 
void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return( new BYTE[len] );
}
 
void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    delete [] ptr;
}

/***************************************************************************
  CMsgRpcRcvrCtx
****************************************************************************/

STDMETHODIMP CMsgRpcRcvrCtx::GetTimeSent( SYSTEMTIME* pTime )
{
    *pTime = *m_pHdr->GetTimeSent();
    return S_OK;
}

STDMETHODIMP CMsgRpcRcvrCtx::GetSendingMachine( WCHAR* awchMachine, 
                                                ULONG cMachine,
                                                ULONG* pcMachine )
{ 
    LPCWSTR wszSource = m_pHdr->GetSendingMachine();

    *pcMachine = wcslen( wszSource ) + 1;

    if ( *pcMachine > cMachine )
    {
        return S_FALSE;
    }

    StringCchCopyW( awchMachine, cMachine, wszSource );

    return S_OK;
}

STDMETHODIMP CMsgRpcRcvrCtx::GetTarget( WCHAR* awchTarget, 
                                        ULONG cTarget,
                                        ULONG* pcTarget )
{
    *pcTarget = 0;
    return WBEM_E_NOT_SUPPORTED;
}

STDMETHODIMP CMsgRpcRcvrCtx::IsSenderAuthenticated()
{
    HRESULT hr;
    DWORD dwAuthn;
    DWORD dwLevel;
    RPC_STATUS stat;

    stat = RpcBindingInqAuthClient( m_hClient,
                                    NULL,
                                    NULL,
                                    &dwLevel,
                                    &dwAuthn,
                                    NULL );
    
    if ( stat == RPC_S_OK &&
         dwAuthn != RPC_C_AUTHN_NONE && 
         dwLevel >= RPC_C_AUTHN_LEVEL_PKT_INTEGRITY )
    {
        hr = WBEM_S_NO_ERROR; 
    }
    else
    {
        hr = WBEM_S_FALSE;
    }

    return hr;
}

STDMETHODIMP CMsgRpcRcvrCtx::ImpersonateSender()
{
    HRESULT hr;
    RPC_STATUS stat = RpcImpersonateClient( m_hClient );

    if ( stat == RPC_S_OK )
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = RpcResToWmiRes( stat, S_OK );
    }

    return hr;
}

STDMETHODIMP CMsgRpcRcvrCtx::RevertToSelf()
{
    HRESULT hr;
    RPC_STATUS stat = RpcRevertToSelf();

    if ( stat == RPC_S_OK )
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = RpcResToWmiRes( stat, S_OK );
    }

    return hr;
}

STDMETHODIMP CMsgRpcRcvrCtx::GetSenderId( PBYTE pchSenderId, 
                                          ULONG cSenderId,
                                          ULONG* pcSenderId )
{
    HRESULT hr;
    RPC_STATUS stat;
  
    *pcSenderId = 0;

    stat = RpcImpersonateClient( m_hClient );

    if ( stat == RPC_S_OK )
    {
        HANDLE hToken;

        if ( OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken) )
        {
            //
            // use the passed in buffer to get the SID_AND_ATTRIBUTES
            //

            DWORD dwLen;

            if ( GetTokenInformation( hToken,
                                      TokenUser,
                                      pchSenderId,
                                      cSenderId,
                                      &dwLen ) )
            {
                //
                // move the sid to the beginning of the buffer.
                //

                PSID pSid = PSID_AND_ATTRIBUTES(pchSenderId)->Sid;
                *pcSenderId = GetLengthSid( pSid );
                memmove( pchSenderId, pSid, *pcSenderId );

                hr = WBEM_S_NO_ERROR;
            }
            else
            {
                DWORD dwRes = GetLastError();

                if ( dwRes == ERROR_MORE_DATA )
                {
                    *pcSenderId = dwLen;
                    hr = WBEM_S_FALSE;
                }
                else
                {
                    hr = WMIMSG_E_AUTHFAILURE;
                }
            }

            CloseHandle( hToken );
        }
        else
        {
            hr = WMIMSG_E_AUTHFAILURE;
        }

        RpcRevertToSelf();
    }
    else
    {
        hr = RpcResToWmiRes( stat, S_OK );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\rpcrecv.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __RPCRECV_H__
#define __RPCRECV_H__

#include <unk.h>
#include <wmimsg.h>
#include <comutl.h>
#include "rpcmsg.h"

/**************************************************************************
  CMsgRpcReceiver
***************************************************************************/

class CMsgRpcReceiver 
: public CUnkBase< IWmiMessageReceiver, &IID_IWmiMessageReceiver >
{          
public:

    CMsgRpcReceiver( CLifeControl* pCtl ) : 
     CUnkBase<IWmiMessageReceiver,&IID_IWmiMessageReceiver>( pCtl ) { }

    ~CMsgRpcReceiver() { Close(); }

    STDMETHOD(Open)( LPCWSTR wszEndpoint,
                     DWORD dwFlags,
                     WMIMSG_RCVR_AUTH_INFOP pAuthInfo,
                     IWmiMessageSendReceive* pRcv );
    
    STDMETHOD(Close)();
};


#endif // __RPCRECV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\rpchdr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __RPCHDR_H__
#define __RPCHDR_H__

#include <buffer.h>
#include <wmimsg.h>

/**********************************************************************
  CMsgRpcHdr
***********************************************************************/

class CMsgRpcHdr
{
    SYSTEMTIME m_Time;
    LPCWSTR m_wszSource;
    ULONG m_cAuxData;

public:

    CMsgRpcHdr() { ZeroMemory( this, sizeof(CMsgRpcHdr) ); }
    
    CMsgRpcHdr( LPCWSTR wszSource, ULONG cUserAuxData );

    ULONG GetAuxDataLength() { return m_cAuxData; }
    SYSTEMTIME* GetTimeSent() { return &m_Time; }
    LPCWSTR GetSendingMachine() { return m_wszSource; }

    HRESULT Unpersist( CBuffer& rStrm );
    HRESULT Persist( CBuffer& rStrm );
};


#endif // __RPCHDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\rpcsend.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <assert.h>
#include <comutl.h>
#include "rpchdr.h"
#include "rpcsend.h"
#include "rpcmsg.h"

extern HRESULT RpcResToWmiRes( RPC_STATUS stat, HRESULT hrDefault );

/*****************************************************************
  CMsgRpcSender
******************************************************************/

HRESULT CMsgRpcSender::Open( LPCWSTR wszTarget, 
                             DWORD dwFlags,
                             WMIMSG_SNDR_AUTH_INFOP pAuthInfo,
                             LPCWSTR wszResponse,
                             IWmiMessageTraceSink* pTraceSink,
                             IWmiMessageSendReceive** ppSend )
{
    HRESULT hr;

    ENTER_API_CALL

    CWbemPtr<CMsgRpcSend> pSend;

    pSend = new CMsgRpcSend( m_pControl,
                             wszTarget, 
                             dwFlags, 
                             pAuthInfo,
                             wszResponse,
                             pTraceSink );

    if ( (dwFlags & WMIMSG_FLAG_SNDR_LAZY_INIT) == 0 )
    {
        hr = pSend->EnsureSender();

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    return pSend->QueryInterface(IID_IWmiMessageSendReceive, (void**)ppSend);

    EXIT_API_CALL
}

/*****************************************************************
  CMsgRpcSend
******************************************************************/

CMsgRpcSend::CMsgRpcSend( CLifeControl* pCtl, 
                          LPCWSTR wszTarget,
                          DWORD dwFlags,
                          WMIMSG_SNDR_AUTH_INFOP pAuthInfo,
                          LPCWSTR wszResponse,
                          IWmiMessageTraceSink* pTraceSink )
 : CUnkBase<IWmiMessageSendReceive,&IID_IWmiMessageSendReceive>(pCtl), 
   m_dwFlags(dwFlags), m_pTraceSink( pTraceSink ),
   m_hBinding(NULL), m_bInit(FALSE)
{ 
    //
    // save our computer name.
    //

    TCHAR achComputer[MAX_COMPUTERNAME_LENGTH+1];
    ULONG ulSize = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerName( achComputer, &ulSize );
    m_wsComputer = achComputer;

    //
    // if the target is NULL, then we use our computer name as the target.
    //

    if ( wszTarget != NULL && *wszTarget != '\0' )
    { 
        m_wsTarget = wszTarget;
    }
    else
    {
        m_wsTarget = m_wsComputer;
    }

    if ( pAuthInfo != NULL )
    {
        if ( pAuthInfo->wszTargetPrincipal != NULL )
        {
            m_wsTargetPrincipal = pAuthInfo->wszTargetPrincipal;
        }
    }
} 

CMsgRpcSend::~CMsgRpcSend() 
{ 
    Clear(); 
}

HRESULT CMsgRpcSend::HandleTrace( HRESULT hr, 
                                  LPCWSTR wszTrace, 
                                  IUnknown* pCtx )
{
    //
    // we use the error sink approach instead of just returning an error 
    // because sometimes multiple senders are used in one send operation 
    // ( when using the multi send impl ) and we need to be able to
    // distinguish which one failed.  
    // 

    if ( m_pTraceSink != NULL )
    {
        m_pTraceSink->Notify( hr, CLSID_WmiMessageRpcSender, wszTrace, pCtx );
    }

    return hr;
}

void CMsgRpcSend::Clear()
{
    if ( m_hBinding != NULL )
    {
        RpcBindingFree( &m_hBinding );
        m_hBinding = NULL;
    }
    m_bInit = FALSE;
}

HRESULT CMsgRpcSend::EnsureSender()
{
    HRESULT hr = S_OK;
    RPC_STATUS stat;

    CInCritSec ics(&m_cs);

    if ( m_bInit )
    {
        return WBEM_S_NO_ERROR;
    }

    Clear();

    //
    // connect to the stub at the target.
    //

    stat = RpcBindingFromStringBinding( m_wsTarget, &m_hBinding );

    if ( stat != RPC_S_OK )
    {
        return RpcResToWmiRes( stat, WMIMSG_E_INVALIDADDRESS );
    }

    //
    // binding may be dynamic, so we may have to resolve it.
    //

    stat = RpcEpResolveBinding( m_hBinding,
                                IWmiMessageRemoteSendReceive_v1_0_c_ifspec );
    
    if ( stat != RPC_S_OK )
    {
        return RpcResToWmiRes( stat, WMIMSG_E_TARGETNOTFOUND );
    }
    
    //
    // set binding auth info based on auth and encryption flags.
    //

    RPC_SECURITY_QOS qos;
    DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel;

    LPWSTR wszPrincipal = NULL;

    if ( m_wsTargetPrincipal.Length() > 0 )
    {
        wszPrincipal = m_wsTargetPrincipal;
    }

    qos.Version = RPC_C_SECURITY_QOS_VERSION;
    qos.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;

    if ( m_dwFlags & WMIMSG_FLAG_SNDR_ENCRYPT )
    {
        dwAuthnSvc = RPC_C_AUTHN_GSS_NEGOTIATE;
        dwAuthzSvc = RPC_C_AUTHZ_DEFAULT;    
        dwAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
        qos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
        qos.ImpersonationType = RPC_C_IMP_LEVEL_IDENTIFY;
    }
    else if ( m_dwFlags & WMIMSG_FLAG_SNDR_AUTHENTICATE )
    {
        dwAuthnSvc = RPC_C_AUTHN_GSS_NEGOTIATE;
        dwAuthzSvc = RPC_C_AUTHZ_DEFAULT;    
        qos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
        qos.ImpersonationType = RPC_C_IMP_LEVEL_IDENTIFY;
        dwAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
    }
    else 
    {
        dwAuthnSvc = RPC_C_AUTHN_NONE;
        dwAuthzSvc = RPC_C_AUTHZ_NONE;
        qos.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
        qos.ImpersonationType = RPC_C_IMP_LEVEL_ANONYMOUS;
        dwAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;
    }

    stat = RpcBindingSetAuthInfoEx( m_hBinding,
                                    wszPrincipal,
                                    dwAuthnLevel,
                                    dwAuthnSvc,
                                    NULL,
                                    dwAuthzSvc,
                                    &qos );

    if ( stat != RPC_S_OK )
    {         
        return RpcResToWmiRes( stat, WMIMSG_E_AUTHFAILURE );
    }
    
    m_bInit = TRUE;

    return hr;
}

HRESULT CMsgRpcSend::PerformSend( PBYTE pData, 
                                  ULONG cData, 
                                  PBYTE pAuxData,
                                  ULONG cAuxData )
{
    HRESULT hr;

    RpcTryExcept  
    {
        hr = ::SendReceive( m_hBinding,
                            pData, 
                            cData, 
                            pAuxData,
                            cAuxData );
    } 
    RpcExcept(1) 
    {
        hr = RpcResToWmiRes( RpcExceptionCode(), S_OK );
    }
    RpcEndExcept

    return hr;
}    

HRESULT CMsgRpcSend::SendReceive( PBYTE pData, 
                                  ULONG cData,
                                  PBYTE pAuxData,
                                  ULONG cAuxData,
                                  DWORD dwFlagStatus,
                                  IUnknown* pCtx ) 
{
    HRESULT hr;

    BYTE achHdr[512];
    CBuffer HdrStrm( achHdr, 512, FALSE );
    CMsgRpcHdr RpcHdr( m_wsComputer, cAuxData );

    ENTER_API_CALL

    hr = EnsureSender();

    if ( FAILED(hr) )
    {
        return HandleTrace( hr, m_wsTarget, pCtx );
    }

    //
    // create our Rpc hdr and prepend it to the user's hdr data.
    //

    hr = RpcHdr.Persist( HdrStrm );

    if ( FAILED(hr) )
    {
        return HandleTrace( hr, m_wsTarget, pCtx );
    }

    hr = HdrStrm.Write( pAuxData, cAuxData, NULL );

    if ( FAILED(hr) )
    {
        return HandleTrace( hr, m_wsTarget, pCtx );
    }

    hr = PerformSend( pData, 
                      cData,
                      HdrStrm.GetRawData(), 
                      HdrStrm.GetIndex() );  
     
    if ( FAILED(hr) )
    {
        //
        // this is so the next call will reset us.
        //
        Clear();

        hr = RpcResToWmiRes( hr, S_OK );
    }

    HandleTrace( hr, m_wsTarget, pCtx );

    EXIT_API_CALL

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\rpcsend.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __RPCSEND_H__
#define __RPCSEND_H__

#include <unk.h>
#include <comutl.h>
#include <wstring.h>
#include <sync.h>
#include "wmimsg.h"

/**************************************************************************
  CMsgRpcSender
***************************************************************************/

class CMsgRpcSender 
: public CUnkBase<IWmiMessageSender,&IID_IWmiMessageSender>
{

public:

    CMsgRpcSender( CLifeControl* pCtl )
    : CUnkBase<IWmiMessageSender,&IID_IWmiMessageSender>( pCtl ) { }

    STDMETHOD(Open)( LPCWSTR wszTarget, 
                     DWORD dwFlags,
                     WMIMSG_SNDR_AUTH_INFOP pAuthInfo,
                     LPCWSTR wszResponse,
                     IWmiMessageTraceSink* pTraceSink,
                     IWmiMessageSendReceive** ppSend );
};

/**************************************************************************
  CMsgRpcSend
***************************************************************************/

class CMsgRpcSend 
: public CUnkBase<IWmiMessageSendReceive,&IID_IWmiMessageSendReceive>
{
    CCritSec m_cs;
    WString m_wsTarget;
    WString m_wsComputer;
    WString m_wsTargetPrincipal;
    DWORD m_dwFlags;
    BOOL m_bInit;
    RPC_BINDING_HANDLE m_hBinding;
    CWbemPtr<IWmiMessageTraceSink> m_pTraceSink;
   
    void Clear();
    
    HRESULT PerformSend( PBYTE pData,
                         ULONG cData, 
                         PBYTE pAuxData, 
                         ULONG cAuxData );
 
    HRESULT HandleTrace( HRESULT hRes, LPCWSTR wszTrace, IUnknown* pCtx );

public: 

    CMsgRpcSend( CLifeControl* pCtl, 
                 LPCWSTR wszTarget,
                 DWORD dwFlags,
                 WMIMSG_SNDR_AUTH_INFOP pAuthInfo,
                 LPCWSTR wszResponse,
                 IWmiMessageTraceSink* pTraceSink );
     
    STDMETHOD(SendReceive)( PBYTE pData, 
                            ULONG cData, 
                            PBYTE pAuxData,
                            ULONG cAuxData,
                            DWORD dwFlagStatus,
                            IUnknown* pContext );

    virtual ~CMsgRpcSend();

    HRESULT EnsureSender();
};

#endif // __RPCSEND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\rpcrecv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <assert.h>
#include <wbemcli.h>
#include <wbemutil.h>
#include <arrtempl.h>
#include <statsync.h>
#include "rpcrecv.h"
#include "rpcmsg.h"
#include "rpchdr.h"
#include "rpcctx.h"

extern HRESULT RpcResToWmiRes(  RPC_STATUS stat, HRESULT hrDefault );

//
// this implementation maintains a single RPC receiver per process.  The
// interface, however, implies that there could be multiple receivers.  This
// means that we must ensure that only one instance of this interface is 
// serviced at any one time.  We do this by maintaining an owner variable that
// contains the instance that owns the RPC receiver.  Once Open() is called
// on an instance, it assumes ownership of the global RPC receiver, closing 
// any existing RPC receiver.  If Close() is called on an instance that 
// does not own the Receiver, then we do nothing.
// 

CStaticCritSec g_csOpenClose;
IWmiMessageSendReceive* g_pRcv = NULL;
PSECURITY_DESCRIPTOR g_pSD = NULL;
CMsgRpcReceiver* g_pLastOwner = NULL;
 
RPC_STATUS RPC_ENTRY RpcAuthCallback( RPC_IF_HANDLE Interface, void *Context )
{
    RPC_STATUS stat;

    _DBG_ASSERT( g_pSD != NULL );

    stat = RpcImpersonateClient( Context );

    if ( stat == RPC_S_OK )
    {
        HANDLE hToken;

        if( OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken ) )
        {
            GENERIC_MAPPING map;
            ZeroMemory( &map, sizeof(GENERIC_MAPPING) );
            PRIVILEGE_SET ps;
            DWORD dwPrivLength = sizeof(ps);
            BOOL bStatus;
            DWORD dwGranted;

            if ( ::AccessCheck( g_pSD, 
                                hToken,
                                1,
                                &map, 
                                &ps,
                                &dwPrivLength, 
                                &dwGranted, 
                                &bStatus ) )
            {
                stat = bStatus ? RPC_S_OK : RPC_S_ACCESS_DENIED; 
            }
            else
            {
                stat = RPC_S_ACCESS_DENIED;
            }

            CloseHandle( hToken );
        }
        else
        {
            stat = RPC_S_ACCESS_DENIED;
        }

        RpcRevertToSelf();
    }

    return stat;
}

long RcvrSendReceive( RPC_BINDING_HANDLE hClient,
                      PBYTE pData, 
                      ULONG cData, 
                      PBYTE pAuxData, 
                      ULONG cAuxData )
{
    HRESULT hr;

    ENTER_API_CALL

    CBuffer HdrStrm( pAuxData, cAuxData, FALSE );

    CMsgRpcHdr Hdr;

    hr = Hdr.Unpersist( HdrStrm );

    if ( FAILED(hr) )
    {
        return hr;
    }

    PBYTE pUserAuxData = HdrStrm.GetRawData() + HdrStrm.GetIndex();

    CMsgRpcRcvrCtx Ctx( &Hdr, hClient );

    hr = g_pRcv->SendReceive( pData, 
                              cData, 
                              pUserAuxData, 
                              Hdr.GetAuxDataLength(), 
                              0, 
                              &Ctx );    
    EXIT_API_CALL

    return hr;
}

HRESULT CreateAuthOnlySecurityDescriptor( PSECURITY_DESCRIPTOR* ppSD )
{
    HRESULT hr;

    //
    // obtain the sid from the process token to use for owner and 
    // group fields of SD.
    //

    HANDLE hProcessToken;

    if ( !OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hProcessToken ))
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    CCloseMe cm( hProcessToken );

    DWORD dwSize;
    GetTokenInformation( hProcessToken, TokenOwner, NULL, 0, &dwSize );
    
    if ( GetLastError() != ERROR_MORE_DATA && 
         GetLastError() != ERROR_INSUFFICIENT_BUFFER )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
        
    TOKEN_OWNER* pOwner = (TOKEN_OWNER*) new BYTE[dwSize];

    if ( pOwner == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CVectorDeleteMe<BYTE> vdm( (BYTE*)pOwner );

    if ( !GetTokenInformation( hProcessToken, 
                               TokenOwner, 
                               (BYTE*)pOwner, 
                               dwSize, 
                               &dwSize ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // create a DACL that allows only authenticated users access.
    //

    SID AuthenticatedUsers;
    SID_IDENTIFIER_AUTHORITY idAuth = SECURITY_NT_AUTHORITY; 
    InitializeSid( &AuthenticatedUsers, &idAuth, 1 );
    PDWORD pdwSubAuth = GetSidSubAuthority( &AuthenticatedUsers, 0 );
    *pdwSubAuth = SECURITY_AUTHENTICATED_USER_RID;
    _DBG_ASSERT( IsValidSid( &AuthenticatedUsers ) );

    dwSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - 4 +
                 GetLengthSid(&AuthenticatedUsers);
    
    PACL pAuthOnlyAcl = (PACL) new BYTE[dwSize];

    if ( pAuthOnlyAcl == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CVectorDeleteMe<BYTE> vdm2( (BYTE*)pAuthOnlyAcl );

    InitializeAcl( pAuthOnlyAcl, dwSize, ACL_REVISION );
    AddAccessAllowedAce( pAuthOnlyAcl, ACL_REVISION, 1, &AuthenticatedUsers );

    //
    // create and initialize SD
    //

    SECURITY_DESCRIPTOR AuthOnlySD;
    InitializeSecurityDescriptor( &AuthOnlySD, SECURITY_DESCRIPTOR_REVISION );

    SetSecurityDescriptorOwner( &AuthOnlySD, pOwner->Owner, TRUE );
    SetSecurityDescriptorGroup( &AuthOnlySD, pOwner->Owner, TRUE );
    SetSecurityDescriptorDacl( &AuthOnlySD, TRUE, pAuthOnlyAcl, FALSE );

    dwSize = 0;
    MakeSelfRelativeSD( &AuthOnlySD, NULL, &dwSize );

    if ( GetLastError() != ERROR_MORE_DATA &&
         GetLastError() != ERROR_INSUFFICIENT_BUFFER )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    *ppSD = new BYTE[dwSize];

    if ( *ppSD == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    if ( !MakeSelfRelativeSD( &AuthOnlySD, *ppSD, &dwSize ) )
    {
        delete [] *ppSD;
        *ppSD = NULL;
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return WBEM_S_NO_ERROR;
}

//
// for now only one rpc receiver can be registered for the process.  later 
// make the global state be the instance state for CMsgRpcReceiver.
//

STDMETHODIMP CMsgRpcReceiver::Open( LPCWSTR wszBinding,
                                    DWORD dwFlags,
                                    WMIMSG_RCVR_AUTH_INFOP pAuthInfo,
                                    IWmiMessageSendReceive* pRcv )
{
    HRESULT hr;
    RPC_STATUS stat;

    CInCritSec ics( &g_csOpenClose );
    g_pLastOwner = this;

    hr = Close();

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    //
    // first parse the binding string.
    //

    LPWSTR wszProtSeq, wszEndpoint;

    stat = RpcStringBindingParse( (LPWSTR)wszBinding, 
                                  NULL, 
                                  &wszProtSeq,
                                  NULL,
                                  &wszEndpoint,
                                  NULL );
    if ( stat != RPC_S_OK )
    {
        return RpcResToWmiRes( stat, S_OK );
    }
    
    //
    // init the protocol sequence
    //

    if ( *wszEndpoint == '\0' )
    {
        stat = RpcServerUseProtseq( wszProtSeq,
                                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT, 
                                    NULL );
        if ( stat == RPC_S_OK )
        {
            RPC_BINDING_VECTOR* pBindingVector;

            stat = RpcServerInqBindings( &pBindingVector );

            if ( stat == RPC_S_OK )
            {
                stat = RpcEpRegisterNoReplace( 
                           RcvrIWmiMessageRemoteSendReceive_v1_0_s_ifspec,
                           pBindingVector,
                           NULL,
                           NULL );

                RpcBindingVectorFree( &pBindingVector );
            }
        }
    }
    else
    {
        stat = RpcServerUseProtseqEp( wszProtSeq,
                                      RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                      wszEndpoint,
                                      NULL );
    }

    RpcStringFree( &wszProtSeq );
    RpcStringFree( &wszEndpoint );
    
    if ( stat != RPC_S_OK )
    {
        return RpcResToWmiRes( stat, S_OK );
    }

    //
    // enable negotiate authentication service ( negotiates between NTLM 
    // and kerberos )
    // 

    if ( pAuthInfo != NULL )
    {
        for( int i=0; i < pAuthInfo->cwszPrincipal; i++ )
        {
            stat = RpcServerRegisterAuthInfo( 
                                         (LPWSTR)pAuthInfo->awszPrincipal[i],
                                         RPC_C_AUTHN_GSS_NEGOTIATE, 
                                         NULL, 
                                         NULL );
            if ( stat != RPC_S_OK )
            {
                return RpcResToWmiRes( stat, S_OK );
            }
        }
    }
    else
    {       
        LPWSTR wszPrincipal;

        stat = RpcServerInqDefaultPrincName( RPC_C_AUTHN_GSS_NEGOTIATE,
                                             &wszPrincipal );
        if ( stat != RPC_S_OK )
        {
            return RpcResToWmiRes( stat, S_OK );
        }
        
        stat = RpcServerRegisterAuthInfo( wszPrincipal,
                                          RPC_C_AUTHN_GSS_NEGOTIATE, 
                                          NULL, 
                                          NULL );
        RpcStringFree( &wszPrincipal );

        if ( stat != RPC_S_OK )
        {
            return RpcResToWmiRes( stat, S_OK );
        }
    }

    RPC_IF_CALLBACK_FN* pAuthCallback = NULL;

    if ( dwFlags & WMIMSG_FLAG_RCVR_SECURE_ONLY )
    {
        PSECURITY_DESCRIPTOR pAuthOnlySD;

        hr = CreateAuthOnlySecurityDescriptor( &pAuthOnlySD );

        if ( FAILED(hr) )
        {
            return hr;
        }

        _DBG_ASSERT( g_pSD == NULL );           
        g_pSD = pAuthOnlySD;
        
        pAuthCallback = RpcAuthCallback;
    }

    //
    // g_pRcv must be set before registering the interface, since a call
    // could arrive on that interface before returning from the register.
    // The call requires that g_pRcv be set.
    //

    _DBG_ASSERT( g_pRcv == NULL );
    pRcv->AddRef();
    g_pRcv = pRcv;

    //
    // register the interface 
    // 

    DWORD dwRpcFlags = RPC_IF_AUTOLISTEN;

    stat = RpcServerRegisterIfEx( 
                               RcvrIWmiMessageRemoteSendReceive_v1_0_s_ifspec,
                               NULL,
                               NULL,
                               dwRpcFlags,
                               RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                               pAuthCallback );

    if ( stat != RPC_S_OK )
    {
        return RpcResToWmiRes( stat, S_OK );
    }

    return WBEM_S_NO_ERROR;
}
    
STDMETHODIMP CMsgRpcReceiver::Close()
{
    CInCritSec ics(&g_csOpenClose);

    if ( g_pLastOwner != this )
        return S_FALSE;

    RPC_STATUS stat;

    stat = RpcServerUnregisterIf( 
                           RcvrIWmiMessageRemoteSendReceive_v1_0_s_ifspec,
                           NULL,
                           1 );

    RPC_BINDING_VECTOR* pBindingVector;
    stat = RpcServerInqBindings( &pBindingVector );

    if ( stat == RPC_S_OK )
    {
        stat = RpcEpUnregister(
                           RcvrIWmiMessageRemoteSendReceive_v1_0_s_ifspec,
                           pBindingVector,
                           NULL );

        RpcBindingVectorFree( &pBindingVector );
    }

    if ( g_pRcv != NULL )
    {
        g_pRcv->Release();
        g_pRcv = NULL;
    }

    if ( g_pSD != NULL )
    {
        delete [] g_pSD;
        g_pSD = NULL;
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\smrtmrsh.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <wbemint.h>
#include <wbemutil.h>
#include <md5wbem.h>
#include <arrtempl.h>
#include "smrtmrsh.h"
#include "buffer.h"


static DWORD g_dwSignature = 0xabcdefab;
static WORD g_dwVersion = 0;

enum { e_ClassIdNone=0,
       e_ClassIdHash,
       e_ClassIdHashAndPath } ClassIdType_e;

enum { e_DataPartial=0,
       e_DataFull } DataType_e;
       
/****
         
  Packed Object Format 
  
  - 4 byte magic number 
  - 2 byte version number 
  - 1 byte class id type
  - 4 byte class id len
  - N byte class id
  - 1 byte data type
  - 4 byte data len
  - N byte data 
  
  *****/
       
#define HDRSIZE  16 // size of msg w/o variable length data.
#define HASHSIZE 16 


/**************************************************************************
  CWbemObjectWrapper - smooths out differences between Nova and Whistler 
***************************************************************************/

class CWbemObjectWrapper
{
    CWbemPtr<_IWmiObject> m_pWmiObj;
    CWbemPtr<IWbemObjectAccess> m_pObjAccess;
//    CWbemPtr<IWbemObjectInternals> m_pObjInt;

public:

    HRESULT SetPointer( IWbemClassObject* pObj )
    {
        HRESULT hr;

        hr = pObj->QueryInterface( IID__IWmiObject, (void**)&m_pWmiObj );

        if ( FAILED(hr) )
        {
            hr = pObj->QueryInterface( IID_IWbemObjectAccess, 
                                       (void**)&m_pObjAccess );

            if ( SUCCEEDED(hr) )
            {
             //   hr = pObj->QueryInterface( IID_IWbemObjectInternals, 
             //                              (void**)&m_pObjInt );
            }
        }

        return hr;
    }

    operator IWbemObjectAccess* ()
    {
        IWbemObjectAccess* pAccess;
        
        if ( m_pWmiObj != NULL )
        {
            pAccess = m_pWmiObj;
        }
        else
        {
            pAccess = m_pObjAccess;
        }
        
        return pAccess;
    }

    BOOL IsValid()
    {
        return m_pWmiObj != NULL || m_pObjAccess != NULL;
    }

    HRESULT SetObjectParts( LPVOID pMem, 
                            DWORD dwDestBufSize, 
                            DWORD dwParts )
    {
        HRESULT hr;

        if ( m_pWmiObj != NULL )
        {
            hr = m_pWmiObj->SetObjectParts( pMem, dwDestBufSize, dwParts );
        }
        else
        {
            hr = WBEM_E_NOT_SUPPORTED;
        }

        return hr;
    }

    HRESULT GetObjectParts( LPVOID pDestination,
                            DWORD dwDestBufSize,
                            DWORD dwParts,
                            DWORD *pdwUsed )
    {
        HRESULT hr;

        if ( m_pWmiObj != NULL )
        {
            hr = m_pWmiObj->GetObjectParts( pDestination, 
                                            dwDestBufSize, 
                                            dwParts,
                                            pdwUsed );
        }
        else
        {
            hr = WBEM_E_NOT_SUPPORTED;
        }

        return hr;
    }

    HRESULT MergeClassPart( IWbemClassObject* pObj )
    {
        HRESULT hr;

        if ( m_pWmiObj != NULL )
        {
            hr = m_pWmiObj->MergeClassPart( pObj );
        }
        else
        {
            hr = WBEM_E_NOT_SUPPORTED;
        }

        return hr;
    }   
};

HRESULT GetClassPath( IWbemClassObject* pObj,
                      LPCWSTR wszNamespace,
                      PBYTE pBuff, 
                      ULONG cBuff,
                      ULONG* pcUsed )
{
    HRESULT hr;
    *pcUsed = 0;

    CPropVar vNamespace, vClass;

    //
    // before trying to optimize the property access, realize that 
    // class objects do not support handle access to the __Namespace prop.
    //  

    hr = pObj->Get( L"__NAMESPACE", 0, &vNamespace, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pObj->Get( L"__CLASS", 0, &vClass, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( V_VT(&vNamespace) == VT_BSTR )
    {
        wszNamespace = V_BSTR(&vNamespace);
    }

    if ( wszNamespace == NULL )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    if ( V_VT(&vClass) != VT_BSTR )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    ULONG cNamespace = wcslen(wszNamespace)*2;
    ULONG cClass = wcslen(V_BSTR(&vClass))*2;

    //
    // add 4 for the two null terminators
    //

    *pcUsed = cNamespace + cClass + 4;

    if ( cBuff < *pcUsed )
    {
        return WBEM_E_BUFFER_TOO_SMALL;
    }

    ULONG iBuff = 0;

    memcpy( pBuff+iBuff, wszNamespace, cNamespace );
    iBuff += cNamespace;

    *(WCHAR*)(pBuff+iBuff) = ':';
    iBuff+= 2;

    memcpy( pBuff+iBuff, V_BSTR(&vClass), cClass );
    iBuff += cClass;

    *(WCHAR*)(pBuff+iBuff) = '\0';
    iBuff+= 2;
    
    _DBG_ASSERT( iBuff == *pcUsed );

    return hr;
}

HRESULT GetClassPartHash( CWbemObjectWrapper& rWrap, 
                          PBYTE pClassPartHash,
                          ULONG cClassPartHash )
{
    HRESULT hr;

    //
    // Too bad we have to perform a copy here, but no other way.  This 
    // function requires the passed in buffer be big enough to hold both 
    // the class part and the hash.  This is not really too limiting because 
    // in most cases where this function is used, the caller already has 
    // enough memory allocated to use here as a workarea.
    //

    DWORD dwSize;

    if ( cClassPartHash >= HASHSIZE )
    {
        hr = rWrap.GetObjectParts( pClassPartHash+HASHSIZE,
                                   cClassPartHash-HASHSIZE,
                                   WBEM_OBJ_CLASS_PART,
                                   &dwSize );
        if ( SUCCEEDED(hr) )
        {
            MD5::Transform( pClassPartHash+HASHSIZE, dwSize, pClassPartHash );
        }
    }
    else
    {
        hr = WBEM_E_BUFFER_TOO_SMALL;
    }

    return hr;
}
      
/***************************************************************************
  CSmartObjectMarshaler
****************************************************************************/

HRESULT CSmartObjectMarshaler::GetMaxMarshalSize( IWbemClassObject* pObj,
                                                  LPCWSTR wszNamespace,
                                                  DWORD dwFlags,
                                                  ULONG* pulSize )
{
    HRESULT hr;

    if ( pObj == NULL || wszNamespace == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    CWbemPtr<IMarshal> pMrsh;
    hr = pObj->QueryInterface( IID_IMarshal, (void**)&pMrsh );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // user is requesting the required size to pack object. For now,
    // we always use the size of the entire object blob.  However, the
    // actual size of the object may be much smaller. 
    //

    DWORD dwSize;

    hr = pMrsh->GetMarshalSizeMax( IID_IWbemClassObject, 
                                   pObj,
                                   MSHCTX_INPROC,
                                   NULL,
                                   0,
                                   &dwSize );
    if ( FAILED(hr) )
    {
        return hr;
    }

    *pulSize = dwSize + HDRSIZE + HASHSIZE;

    if ( dwFlags == WMIMSG_FLAG_MRSH_PARTIAL )
    {
        hr = GetClassPath( pObj, wszNamespace, NULL, 0, &dwSize );

        if ( hr == WBEM_E_BUFFER_TOO_SMALL )
        {
            *pulSize += dwSize;
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            _DBG_ASSERT( FAILED(hr) );
        }
    }

    return hr;
}


HRESULT CSmartObjectMarshaler::InternalPack( IWbemClassObject* pObj,
                                             LPCWSTR wszNamespace,
                                             DWORD dwFlags,
                                             ULONG cBuff, 
                                             BYTE* pBuff, 
                                             ULONG* pcUsed )
{
    HRESULT hr;
    *pcUsed = 0;

    //
    // make sure we have enough room for at least the header data.
    //

    if ( cBuff < HDRSIZE )
    {
        return WBEM_E_BUFFER_TOO_SMALL;
    }

    ULONG iBuff = 0;

    memcpy( pBuff + iBuff, &g_dwSignature, 4 );
    iBuff += 4;
    
    memcpy( pBuff + iBuff, &g_dwVersion, 2 );
    iBuff += 2;

    //
    // write class information 
    // 

    DWORD dwSize;
    BOOL bPartialData;

    CWbemObjectWrapper ObjWrap;
    PBYTE pClassPartHash = NULL;

    if ( dwFlags == WMIMSG_FLAG_MRSH_FULL_ONCE )
    {
        hr = ObjWrap.SetPointer( pObj );

        if ( FAILED(hr) )
        {
            return hr;
        }

        //
        // send class part hash for class info
        //

        *(pBuff+iBuff) = char(e_ClassIdHash);
        iBuff++;

        dwSize = HASHSIZE;
        memcpy( pBuff+iBuff, &dwSize, 4 );
        iBuff += 4;

        hr = GetClassPartHash( ObjWrap, pBuff+iBuff, cBuff-iBuff );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
        
        pClassPartHash = pBuff+iBuff;
        iBuff += HASHSIZE;

        //
        // see if we've sent the class part before
        // 

        CInCritSec ics( &m_cs );
        bPartialData = m_SentMap[pClassPartHash];
    }
    else if ( dwFlags == WMIMSG_FLAG_MRSH_PARTIAL )
    {
        hr = ObjWrap.SetPointer( pObj );

        if ( FAILED(hr) )
        {
            return hr;
        }

        //
        // send class path and class part hash for class info
        //

        *(pBuff+iBuff) = char(e_ClassIdHashAndPath);
        iBuff++;
        
        PBYTE pLen = pBuff+iBuff;
        iBuff+= 4; // leave room for class info size

        hr = GetClassPartHash( ObjWrap, pBuff+iBuff, cBuff-iBuff );
        
        if ( FAILED(hr) )
        {
            return hr;
        }

        iBuff += HASHSIZE;
        
        hr = GetClassPath( pObj, 
                           wszNamespace, 
                           pBuff+iBuff, 
                           cBuff-iBuff, 
                           &dwSize );

        if ( FAILED(hr) )
        {
            return hr;
        }

        iBuff += dwSize;

        dwSize += HASHSIZE; // size if both hash and path

        memcpy( pLen, &dwSize, 4 );

        bPartialData = TRUE;
    }
    else if ( dwFlags == WMIMSG_FLAG_MRSH_FULL )
    {
        //
        // no class information
        //

        *(pBuff+iBuff) = char(e_ClassIdNone);
        iBuff++;

        memset( pBuff + iBuff, 0, 4 );
        iBuff += 4;

        bPartialData = FALSE;
    }
    else
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // write data
    //

    if ( bPartialData )
    {
        *(pBuff+iBuff) = char(e_DataPartial);
        iBuff++;

        PBYTE pLen = pBuff+iBuff;

        iBuff += 4; // fill in length afterwords.

        //
        // now get instance part
        //

        _DBG_ASSERT( ObjWrap.IsValid() );

        hr = ObjWrap.GetObjectParts( pBuff+iBuff, 
                                     cBuff-iBuff, 
                                     WBEM_OBJ_DECORATION_PART | 
                                     WBEM_OBJ_INSTANCE_PART,
                                     &dwSize ); 

        if ( FAILED(hr) )
        {
            return hr;
        }

        iBuff += dwSize;

        //
        // go back and set length .. 
        // 

        memcpy( pLen, &dwSize, 4 );
    }
    else
    {
        *(pBuff+iBuff) = char(e_DataFull);

        iBuff++;

        PBYTE pLen = pBuff+iBuff;
        
        iBuff += 4; // fill in length afterwords.

        //
        // for now, use MarshalInterface() to marshal object.  The reason
        // for this is because SetObjectMemory() has a bug where
        // it assumes ownership of the memory ( even though the client 
        // doesn't have access to the allocator used to free it ).  
        //

        CBuffer Strm( pBuff+iBuff, cBuff-iBuff, FALSE );
        
        CWbemPtr<IMarshal> pMrsh;
        hr = pObj->QueryInterface( IID_IMarshal, (void**)&pMrsh );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = pMrsh->MarshalInterface( &Strm, 
                                      IID_IWbemClassObject, 
                                      pObj, 
                                      MSHCTX_INPROC, 
                                      NULL, 
                                      0 );
        if ( FAILED(hr) )
        {
            return hr;
        }

        //
        // check if we read more data than we can fit into our buffer.  We 
        // can tell this if the buffer is no longer the one we passed in.
        //

        if ( Strm.GetRawData() != pBuff+iBuff )
        {
            return WBEM_E_BUFFER_TOO_SMALL;
        }

        dwSize = Strm.GetIndex();

        iBuff += dwSize;

        //
        // go back and set length of the data.
        //

        memcpy( pLen, &dwSize, 4 );

        if ( dwFlags == WMIMSG_FLAG_MRSH_FULL_ONCE )
        {
            //
            // mark that we've successfully packed the class part once.
            // 
            _DBG_ASSERT( pClassPartHash != NULL );
            CInCritSec ics(&m_cs);
            m_SentMap[pClassPartHash] = TRUE;
        }
    }

    *pcUsed = iBuff;

    return WBEM_S_NO_ERROR;
}


STDMETHODIMP CSmartObjectMarshaler::Pack( IWbemClassObject* pObj,
                                          LPCWSTR wszNamespace,
                                          DWORD dwFlags,
                                          ULONG cBuff,
                                          BYTE* pBuff,
                                          ULONG* pcUsed )
{
    HRESULT hr;
    
    ENTER_API_CALL

    hr = InternalPack( pObj, wszNamespace, dwFlags, cBuff, pBuff, pcUsed );

    if ( hr == WBEM_E_BUFFER_TOO_SMALL )
    {
        HRESULT hr2;

        hr2 = GetMaxMarshalSize( pObj, wszNamespace, dwFlags, pcUsed );

        if ( FAILED(hr2) )
        {
            hr = hr2;
        }
    }

    EXIT_API_CALL

    return hr;
}

STDMETHODIMP CSmartObjectMarshaler::Flush()
{
    CInCritSec ics(&m_cs);
    m_SentMap.clear();
    return S_OK;
}

/***************************************************************************
  CSmartObjectUnmarshaler
****************************************************************************/

HRESULT CSmartObjectUnmarshaler::EnsureInitialized()
{
    HRESULT hr;

    CInCritSec ics( &m_cs );

    if ( m_pEmptyClass != NULL )
    {
        return WBEM_S_NO_ERROR;
    }
    
    //
    // allocate a template class object which we can use for spawning
    // 'empty' instances from.  
    //

    CWbemPtr<IWbemClassObject> pEmptyClass;

    hr = CoCreateInstance( CLSID_WbemClassObject,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWbemClassObject,
                           (void**)&pEmptyClass );
    if ( FAILED(hr) )
    {
        return hr;
    }

    VARIANT vName;
    V_VT(&vName) = VT_BSTR;
    V_BSTR(&vName) = L"__DummyClass";

    hr = pEmptyClass->Put( L"__CLASS", 0, &vName, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // allocate a locator to access namespaces for obtaining class definitions.
    // 

    CWbemPtr<IWbemLocator> pLocator;

    hr = CoCreateInstance( CLSID_WbemLocator,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWbemLocator,
                           (void**)&pLocator );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Allocate a full object unmarshaler.  This is used to create classes 
    // or instances that were sent in full. 
    //

    hr = CoCreateInstance( CLSID_WbemClassObjectProxy,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IMarshal,
                           (void**)&m_pUnmrsh );
    if ( FAILED(hr) )
    {
        return hr;
    }

    m_pEmptyClass = pEmptyClass;
    m_pLocator = pLocator;

    return WBEM_S_NO_ERROR;
}

void CSmartObjectUnmarshaler::MakeRoomInCache( DWORD dwSize )
{
    while ( !m_Cache.empty() && dwSize + m_ulCacheSize > m_ulMaxCacheSize )
    {
        DWORD dwLeastRecentTime = 0xffffffff;
        ClassPartMap::iterator it, itLeastRecent;

        for( it = m_Cache.begin(); it != m_Cache.end(); it++ )
        {
            CacheRecord& rCurrent = it->second;

            if ( rCurrent.m_dwLastUsedTime <= dwLeastRecentTime )
            {
                itLeastRecent = it;
                dwLeastRecentTime = rCurrent.m_dwLastUsedTime;
            }
        }

        _DBG_ASSERT( m_ulCacheSize >= itLeastRecent->second.m_dwClassSize );
        m_ulCacheSize -= itLeastRecent->second.m_dwClassSize;
        m_Cache.erase( itLeastRecent );
    }
}


HRESULT CSmartObjectUnmarshaler::CacheClassPart( PBYTE pClassHash,
                                                 DWORD dwSize,
                                                 IWbemClassObject* pClassPart )
{
    HRESULT hr;

    CInCritSec ics(&m_cs);

    ClassPartMap::iterator it = m_Cache.find( pClassHash );

    if ( it == m_Cache.end() )
    {
        MakeRoomInCache( dwSize );

        if ( dwSize + m_ulCacheSize < m_ulMaxCacheSize )
        {
            //
            // create the record and add to cache.
            //
            
            CacheRecord Record;
            
            Record.m_dwClassSize = dwSize;
            Record.m_pClassPart = pClassPart;
            Record.m_dwLastUsedTime = GetTickCount();                    
            
            m_Cache[pClassHash] = Record;
            m_ulCacheSize += dwSize;
            
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            //
            // the class part size is too big to store in the cache.
            //
            hr = WBEM_S_FALSE;
        }
    }
    else
    {
        //
        // already in the cache.
        //
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}

HRESULT CSmartObjectUnmarshaler::FindClassPart( PBYTE pClassPartHash, 
                                                LPCWSTR wszClassPath, 
                                                IWbemClassObject** ppClassPart)
{
    HRESULT hr;

    //
    // first try the cache ...
    // 

    ClassPartMap::iterator it;

    {
        CInCritSec ics(&m_cs);
        it = m_Cache.find( pClassPartHash );

        if ( it != m_Cache.end() )
        {
            it->second.m_dwLastUsedTime = GetTickCount();
            
            *ppClassPart = it->second.m_pClassPart;
            (*ppClassPart)->AddRef();

//            DEBUGTRACE((LOG_ESS,
//                      "MRSH: Cache Hit !!! %d bytes saved in transmission\n",
//                       it->second.m_dwClassSize ));
            
            return WBEM_S_NO_ERROR;
        }
    }

    //
    // expensive route ... fetch the class object from wmi 
    // 
    
    if ( wszClassPath == NULL )
    {
        //
        // there's nothing we can do. 
        //
        return WBEM_E_NOT_FOUND;
    }

    CWbemPtr<IWbemServices> pSvc;

    CWbemBSTR bsNamespace = wszClassPath;
    WCHAR* pch = wcschr( bsNamespace, ':' );

    if ( pch == NULL )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    *pch++ = '\0';

    hr = m_pLocator->ConnectServer( bsNamespace, NULL, NULL, 
                                   NULL, 0, NULL, NULL, &pSvc );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    CWbemBSTR bsRelpath = pch;

    CWbemPtr<IWbemClassObject> pClass;

    hr = pSvc->GetObject( bsRelpath, 0, NULL, &pClass, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<IWbemClassObject> pClassPart;

    hr = pClass->SpawnInstance( 0, &pClassPart );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // now we have to verify that hash of the class part and the 
    // hash sent in the message are the same.
    // 
    
    CWbemObjectWrapper ObjWrap;

    hr = ObjWrap.SetPointer( pClassPart );

    if ( FAILED(hr) )
    {
        return hr;
    }

    DWORD dwSize;

    hr = ObjWrap.GetObjectParts( NULL, 0, WBEM_OBJ_CLASS_PART, &dwSize );

    if ( hr != WBEM_E_BUFFER_TOO_SMALL )
    {
        _DBG_ASSERT( FAILED(hr) );
        return hr;
    }

    PBYTE pBuff = new BYTE[dwSize+HASHSIZE];

    if ( pBuff == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CVectorDeleteMe<BYTE> tdm( pBuff );
    
    hr = GetClassPartHash( ObjWrap, pBuff, dwSize+HASHSIZE );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( memcmp( pBuff, pClassPartHash, HASHSIZE ) == 0 )
    {
        //
        // things look good so cache the class part.
        // 

        hr = CacheClassPart( pClassPartHash, dwSize, pClassPart );

        if ( FAILED(hr) )
        {
            return hr;
        }

        *ppClassPart = pClassPart;
        (*ppClassPart)->AddRef();
    }
    else
    {
        //
        // class parts don't match up, nothing else we can do.
        //

        hr = WBEM_E_NOT_FOUND;
    }   

    return hr;
}

STDMETHODIMP CSmartObjectUnmarshaler::Unpack( ULONG cBuff,
                                              PBYTE pBuff, 
                                              DWORD dwFlags,
                                              IWbemClassObject** ppObj,
                                              ULONG* pcUsed ) 
{
    HRESULT hr;

    ENTER_API_CALL

    *pcUsed = 0;
    *ppObj = NULL;

    hr = EnsureInitialized();

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( cBuff < HDRSIZE )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // verify signature and version info 
    //

    DWORD dw;
    ULONG iBuff = 0;

    memcpy( &dw, pBuff + iBuff, 4 );

    iBuff += 6; // version info is not currently used;

    if ( dw != g_dwSignature )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // obtain the class id type 
    // 

    char chClassIdType = *(pBuff + iBuff);
    iBuff++;

    memcpy( &dw, pBuff + iBuff, 4 );
    iBuff += 4;

    if ( cBuff - iBuff - 5 < dw ) // 5 is for what's left in the hdr to read
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // obtain the class information associated with the data
    //

    PBYTE pClassPartHash = NULL;
    LPCWSTR wszClassPath = NULL;

    if ( chClassIdType == e_ClassIdHash )
    {
        pClassPartHash = pBuff+iBuff; 
    }
    else if ( chClassIdType == e_ClassIdHashAndPath )
    {
        pClassPartHash = pBuff+iBuff;
        wszClassPath = LPWSTR(pBuff+iBuff+HASHSIZE);

        if ( *(WCHAR*)(pBuff+iBuff+dw-2) != '\0' )
        {
            return WMIMSG_E_INVALIDMESSAGE;
        }
    }
    else if ( chClassIdType == e_ClassIdNone ) 
    {
        if ( dw != 0 )
        {
            return WMIMSG_E_INVALIDMESSAGE;
        }
    }
    else 
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    iBuff += dw;

    //
    // get data part info
    //

    char chDataType = *(pBuff+iBuff);
    iBuff++;

    memcpy( &dw, pBuff+iBuff, 4 );
    iBuff += 4;

    if ( dw > cBuff-iBuff )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    CWbemPtr<IWbemClassObject> pObj;

    if ( chDataType == e_DataFull )
    {
        CBuffer Strm( pBuff+iBuff, cBuff-iBuff, FALSE );

        hr = m_pUnmrsh->UnmarshalInterface( &Strm, 
                                            IID_IWbemClassObject, 
                                            (void**)&pObj );
        if ( FAILED(hr) )
        {
            return WMIMSG_E_INVALIDMESSAGE;
        }

        dw = Strm.GetIndex();

        //
        // if there is an associated hash we need to store the class part 
        // of the unmarshaled object in our cache.
        //

        if ( pClassPartHash != NULL )
        {
            //
            // create an empty version of the instance to store in the 
            // cache. All we're interested in storing is the class part.
            //
            
            CWbemPtr<IWbemClassObject> pClassPart;
            hr = pObj->SpawnInstance( 0, &pClassPart );
            
            if ( FAILED(hr) )
            {
                return hr;
            }

            CWbemObjectWrapper ObjWrap;

            hr = ObjWrap.SetPointer( pClassPart );

            if ( FAILED(hr) )
            {
                return hr;
            }

            DWORD dwSize;

            hr = ObjWrap.GetObjectParts( NULL,
                                         0,
                                         WBEM_OBJ_CLASS_PART,
                                         &dwSize );

            if ( hr != WBEM_E_BUFFER_TOO_SMALL )
            {
                _DBG_ASSERT( FAILED(hr) );
                return hr;
            }

            hr = CacheClassPart( pClassPartHash, dwSize, pClassPart );

            if ( FAILED(hr) )
            {
                return hr;
            }
        }
    }
    else if ( chDataType == e_DataPartial )
    {
        CWbemPtr<IWbemClassObject> pClassPart;

        _DBG_ASSERT( pClassPartHash != NULL );

        hr = FindClassPart( pClassPartHash, wszClassPath, &pClassPart );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = m_pEmptyClass->SpawnInstance( 0, &pObj );

        if ( FAILED(hr) )
        {
            return hr;
        }

        CWbemObjectWrapper ObjWrap;

        hr = ObjWrap.SetPointer( pObj );

        if ( FAILED(hr) )
        {
            return hr;
        }

        //
        // aquires ownership of the memory -- must be CoTaskMemAlloc-ed
        // kind of unfortunate - but the memory has to be allocated and 
        // copied sometime so guess its not that big of a deal.
        // 
        
        PVOID pInstData = CoTaskMemAlloc( dw );

        if ( NULL == pInstData )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        memcpy( pInstData, pBuff+iBuff, dw );

        hr = ObjWrap.SetObjectParts( pInstData,
                                     dw,
                                     WBEM_OBJ_DECORATION_PART |
                                     WBEM_OBJ_INSTANCE_PART );
        if ( FAILED(hr) )
        {
            CoTaskMemFree( pInstData );
            return hr;
        }

        hr = ObjWrap.MergeClassPart( pClassPart );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    iBuff += dw; // advance the index to account for the data part

    pObj->AddRef();
    *ppObj = pObj;
    *pcUsed = iBuff;

    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}
                    
STDMETHODIMP CSmartObjectUnmarshaler::Flush()
{
    CInCritSec ics(&m_cs);
    m_Cache.clear();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\smrtmrsh.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __SMRTMRSH_H__
#define __SMRTMRSH_H__

#include <wbemcli.h>
#include <wstlallc.h>
#include <wmimsg.h>
#include <comutl.h>
#include <sync.h>
#include <unk.h>
#include <map>

#define HASHSIZE 16
 
class CHash
{ 
    BYTE m_achHash[HASHSIZE];

public:

    CHash( PBYTE pHash ) { memcpy( m_achHash, pHash, HASHSIZE ); } 

    bool operator < ( const CHash& rHash ) const
    {
        return memcmp( m_achHash, rHash.m_achHash, HASHSIZE ) < 0;
    }

};


/***************************************************************************
  CSmartObjectMarshaler
****************************************************************************/

class CSmartObjectMarshaler 
: public CUnkBase< IWmiObjectMarshal, &IID_IWmiObjectMarshal >
{
    CCritSec m_cs;
    std::map<CHash, BOOL, std::less<CHash>, wbem_allocator<BOOL> > m_SentMap;

    HRESULT GetMaxMarshalSize( IWbemClassObject* pObj,
                               LPCWSTR wszNamespace,
                               DWORD dwFlags,
                               ULONG* pulSize );

    HRESULT InternalPack( IWbemClassObject* pObj,
                          LPCWSTR wszNamespace,
                          DWORD dwFlags,
                          ULONG cBuff,   
                          PBYTE pBuff,
                          ULONG* pcUsed );
public:

    CSmartObjectMarshaler( CLifeControl* pCtl, IUnknown* pUnk = NULL )
     : CUnkBase< IWmiObjectMarshal, &IID_IWmiObjectMarshal >( pCtl )
     {
     }

    STDMETHOD(Pack)( IWbemClassObject* pObj,
                     LPCWSTR wszNamespace,
                     DWORD dwFlags,
                     ULONG cBuff,   
                     PBYTE pBuff,
                     ULONG* pcUsed );

    STDMETHOD(Unpack)( ULONG cBuff,       
                       PBYTE pBuff,
                       DWORD dwFlags, 
                       IWbemClassObject** pObj,
                       ULONG* pcUsed )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(Flush)();
};

/***************************************************************************
  CSmartObjectUnmarshaler
****************************************************************************/

class CSmartObjectUnmarshaler 
: public CUnkBase< IWmiObjectMarshal, &IID_IWmiObjectMarshal >
{
    CCritSec m_cs;

    ULONG m_ulMaxCacheSize;
    ULONG m_ulCacheSize;

    CWbemPtr<IMarshal> m_pUnmrsh;
    CWbemPtr<IWbemLocator> m_pLocator;
    CWbemPtr<IWbemClassObject> m_pEmptyClass;

    struct CacheRecord
    {
        DWORD m_dwClassSize;
        DWORD m_dwLastUsedTime;
        CWbemPtr<IWbemClassObject> m_pClassPart;
    };

    typedef std::map< CHash,
                      CacheRecord,
                      std::less<CHash>,
                      wbem_allocator<CacheRecord> > ClassPartMap;

    ClassPartMap m_Cache;

    void MakeRoomInCache( DWORD dwSize );

    HRESULT EnsureInitialized();

    HRESULT CacheClassPart(PBYTE pHash, DWORD dwSize, IWbemClassObject* pInst);

    HRESULT FindClassPart( PBYTE pClassPartHash, 
                           LPCWSTR wszClassPath,
                           IWbemClassObject** ppClassPart );

public:

    CSmartObjectUnmarshaler( CLifeControl* pCtl, IUnknown* pUnk = NULL )
     : CUnkBase< IWmiObjectMarshal, &IID_IWmiObjectMarshal >( pCtl ), 
       m_ulMaxCacheSize(0x500000), m_ulCacheSize(0) { }

    STDMETHOD(Pack)( IWbemClassObject* pObj,
                     LPCWSTR wszNamespace,
                     DWORD dwFlags,
                     ULONG cBuff,   
                     PBYTE pBuff,
                     ULONG* pcUsed )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(Unpack)( ULONG cBuff,       
                       PBYTE pBuff,
                       DWORD dwFlags, 
                       IWbemClassObject** pObj,
                       ULONG* pcUsed );

    STDMETHOD(Flush)();
};

#endif __SMRTMRSH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\test\acctest\acctest.cpp ===
#include <wbemcli.h>
#include <wmimsg.h>
#include <comutl.h>
#include <stdio.h>
#include <arrtempl.h>
#include <flexarry.h>
#include <wstring.h>

IWbemServices* g_pSvc;
IWmiObjectAccessFactory* g_pAccessFactory;

HRESULT RecurseProps( IWbemClassObject* pInst,
                      LPCWSTR wszPropPrefix,
                      CFlexArray& aPropHandles,
                      CFlexArray& aEmbeddedPropHandles )
{
    HRESULT hr;

    hr = pInst->BeginEnumeration( WBEM_FLAG_NONSYSTEM_ONLY );

    if ( FAILED(hr) )
    {
        return hr;
    }

    BSTR bstrName;
    VARIANT v;
    CIMTYPE ct;

    while( (hr = pInst->Next( 0, &bstrName, &v, &ct, NULL )) == S_OK )
    {
        CSysFreeMe sfm( bstrName ); 
        CClearMe cmv( &v );

        WString wsPropName = wszPropPrefix;
        wsPropName += bstrName;
        
        LPVOID pvHdl;
        hr = g_pAccessFactory->GetPropHandle( wsPropName, 0, &pvHdl ); 

        if ( SUCCEEDED(hr) )
        {
            if ( ct == CIM_OBJECT && V_VT(&v) == VT_UNKNOWN )
            {
                wsPropName += L".";

                CWbemPtr<IWbemClassObject> pEmbedded;

                V_UNKNOWN(&v)->QueryInterface( IID_IWbemClassObject, 
                                               (void**)&pEmbedded );
                
                aEmbeddedPropHandles.Add( pvHdl );

                hr = RecurseProps( pEmbedded, 
                                   wsPropName, 
                                   aPropHandles,
                                   aEmbeddedPropHandles );
            }
            else
            {
                //
                // don't need to add embedded objects to the list since 
                // we have them covered by recursing their properties.
                //
                aPropHandles.Add( pvHdl );
            }
        }

        if ( FAILED(hr) )
        {
            break;
        }
    }

    pInst->EndEnumeration();

    return hr;
}

HRESULT DeepCopyTest( IWbemClassObject* pClass,
                      IWbemClassObject* pInstance,
                      IWbemClassObject* pTemplate )
{
    HRESULT hr;

    //
    // if a template, then set it on the access factory.
    //

    if ( pTemplate != NULL )
    {
        hr = g_pAccessFactory->SetObjectTemplate( pTemplate );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // enumerate all the properties of this object and those of all 
    // nested objects.  As we enumerate, get the access handles.
    //

    CFlexArray aPropHandles;
    CFlexArray aEmbeddedPropHandles;

    hr = RecurseProps( pInstance, NULL, aPropHandles, aEmbeddedPropHandles );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // spawn a new instance to copy into
    // 

    CWbemPtr<IWbemClassObject> pCopy;

    hr = pClass->SpawnInstance( 0, &pCopy );

    //
    // grab accessors for the original and target objects.
    // 

    CWbemPtr<IWmiObjectAccess> pOrigAccess, pCopyAccess;

    hr = g_pAccessFactory->GetObjectAccess( &pOrigAccess );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = g_pAccessFactory->GetObjectAccess( &pCopyAccess );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pOrigAccess->SetObject( pInstance ); 

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pCopyAccess->SetObject( pCopy ); 

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // first need to spawn any contained instances and set them on the new 
    // object before we can copy the props.
    // 

    for( int i=0; i < aEmbeddedPropHandles.Size(); i++ )
    {
        CPropVar v;
        CIMTYPE ct;

        hr = pOrigAccess->GetProp( aEmbeddedPropHandles[i], 0, &v, &ct );

        if ( FAILED(hr) )
        {
            return hr;
        }

        if ( V_VT(&v) != VT_UNKNOWN )
        {
            return WBEM_E_CRITICAL_ERROR;
        }

        //
        // spawn a new instance from the class of the object.
        // 

        CWbemPtr<IWbemClassObject> pEmbedded;

        hr = V_UNKNOWN(&v)->QueryInterface( IID_IWbemClassObject, 
                                            (void**)&pEmbedded );

        if ( FAILED(hr) )
        {
            return hr;
        }

        CPropVar vClass;

        hr = pEmbedded->Get( L"__CLASS", 0, &vClass, NULL, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }
        
        CWbemPtr<IWbemClassObject> pEmbeddedClass;

        hr = g_pSvc->GetObject( V_BSTR(&vClass),
                                0, 
                                NULL, 
                                &pEmbeddedClass, 
                                NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }

        CWbemPtr<IWbemClassObject> pNewEmbedded;

        hr = pEmbeddedClass->SpawnInstance( 0, &pNewEmbedded );

        if ( FAILED(hr) )
        {
            return hr;
        }

        VARIANT vEmbedded;
        V_VT(&vEmbedded) = VT_UNKNOWN;
        V_UNKNOWN(&vEmbedded) = pNewEmbedded;
        
        hr = pCopyAccess->PutProp( aEmbeddedPropHandles[i], 0, &vEmbedded, ct);

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    hr = pCopyAccess->CommitChanges();

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // copy all the properties to the new object.
    //

    for( int i=0; i < aPropHandles.Size(); i++ )
    {
        CPropVar v;
        CIMTYPE ct;

        hr = pOrigAccess->GetProp( aPropHandles[i], 0, &v, &ct );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = pCopyAccess->PutProp( aPropHandles[i], 0, &v, ct );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    hr = pCopyAccess->CommitChanges();

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    //
    // compare objects. should be same
    //

    CWbemBSTR bsOrigText, bsCopyText;

    pInstance->GetObjectText( 0, &bsOrigText );
    pCopy->GetObjectText( 0, &bsCopyText );

    printf("Original instance looks like ... %S\n", bsOrigText );
    printf("Copied instance looks like ... %S\n", bsCopyText );

    hr = pCopy->CompareTo( 0, pInstance );

    if ( FAILED(hr) )
    {
        return hr;
    }
    else if ( hr == WBEM_S_DIFFERENT )
    {
        return WBEM_E_FAILED;
    }

    return WBEM_S_NO_ERROR;
}
                      

int TestMain( LPCWSTR wszInstancePath, LPCWSTR wszTemplatePath )
{
    HRESULT hr;

    CWbemPtr<IWbemLocator> pLocator;

    hr = CoCreateInstance( CLSID_WbemLocator, 
                           NULL, 
                           CLSCTX_SERVER,
                           IID_IWbemLocator, 
                           (void**)&pLocator );
    if ( FAILED(hr) )
    {
        printf("ERROR CoCIing WbemLocator : hr = 0x%x\n",hr);
        return 1;
    }

    CWbemPtr<IWbemServices> pSvc;

    hr = pLocator->ConnectServer( L"root\\default",
                                  NULL, 
                                  NULL,
                                  NULL, 
                                  0, 
                                  NULL, 
                                  NULL, 
                                  &pSvc );
    if ( FAILED(hr) )
    {
        wprintf( L"ERROR Connecting to root\\default namespace : hr=0x%x\n",hr);
        return 1;
    } 

    g_pSvc = pSvc;

    CWbemPtr<IWbemClassObject> pInst;

    hr = pSvc->GetObject( CWbemBSTR(wszInstancePath), 
                          0, 
                          NULL, 
                          &pInst, 
                          NULL );
    if ( FAILED(hr) )
    {
        printf( "Failed getting test accessor instance : hr=0x%x\n", hr );
        return 1;
    }

    CWbemPtr<IWbemClassObject> pTemplate;

    if ( wszTemplatePath != NULL )
    {
        //
        // test object to use for template.
        // 
        
        hr = pSvc->GetObject( CWbemBSTR(wszTemplatePath), 
                              0, 
                              NULL, 
                              &pTemplate, 
                              NULL );
        if ( FAILED(hr) )
        {
            printf( "Failed getting test accessor template : hr=0x%x\n", hr );
            return 1;
        }
    }

    //
    // get the class object for the instance to use to spawn instances.
    // 

    CPropVar vClass;
    CWbemPtr<IWbemClassObject> pClass;

    hr = pInst->Get( L"__CLASS", 0, &vClass, NULL, NULL );

    if ( SUCCEEDED(hr) )
    {
        hr = pSvc->GetObject( V_BSTR(&vClass), 0, NULL, &pClass, NULL );
    }

    if ( FAILED(hr) )
    {
        printf("Couldn't get class object for test accessor instance "
               ": hr=0x%x\n", hr );
        return hr;
    }

    //
    // create the accessor factory
    //

    CWbemPtr<IWmiObjectAccessFactory> pAccessFactory;

    hr = CoCreateInstance( CLSID_WmiSmartObjectAccessFactory, 
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiObjectAccessFactory,
                           (void**)&pAccessFactory );
    if ( FAILED(hr) )
    {
        printf("Failed CoCIing WmiSmartObjectAccessFactory. HR = 0x%x\n", hr);
        return 1;
    }

    g_pAccessFactory = pAccessFactory;

    hr = DeepCopyTest( pClass, pInst, pTemplate );

    if ( SUCCEEDED(hr) )
    {
        printf( "Successful Deep Copy Test for instance.\n" ); 
    }
    else
    {
        printf( "Failed Deep Copy Test for instance. HR=0x%x\n", hr );
    }

    return 0;
}

extern "C" int __cdecl wmain( int argc, WCHAR** argv )
{ 
    if ( argc < 2 )
    {
        printf( "Usage: acctest <instancepath> [<templatepath>]\n" );
        return 1;
    }

    CoInitialize( NULL );

    TestMain( argv[1], argc < 3 ? NULL : argv[2] );

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\test\mrshtest\mrshtest.cpp ===
#include <wbemcli.h>
#include <wmimsg.h>
#include <comutl.h>
#include <stdio.h>

BOOL MarshalTest( IWmiObjectMarshal* pMrsh,
                  IWmiObjectMarshal* pUnmrsh,
                  IWbemClassObject* pObj, 
                  DWORD dwFlags )
{
    HRESULT hr;

    //
    // pack original object into buffer 
    //

    ULONG cLen;

    hr = pMrsh->Pack( pObj, NULL, dwFlags, 0, NULL, &cLen );

    if ( FAILED(hr) && hr != WBEM_E_BUFFER_TOO_SMALL )
    {
        return FALSE;
    }

    PBYTE pBuff = new BYTE[cLen];

    if ( pBuff == NULL )
    {
        return FALSE;
    }

    ULONG cUsed;

    hr = pMrsh->Pack( pObj, NULL, dwFlags, cLen, pBuff, &cUsed );

    if ( FAILED(hr) )
    {
        delete [] pBuff;
        return FALSE;
    }

    ULONG cPacked = cUsed;

    //
    // unpack buffer into new object 
    // 

    CWbemPtr<IWbemClassObject> pNewObj;

    hr = pUnmrsh->Unpack( cLen, pBuff, dwFlags, &pNewObj, &cUsed );

//    delete [] pBuff;

    if ( FAILED(hr) || cUsed != cPacked )
    {
        return FALSE;
    }

    //
    // compare original and new objects
    //

    hr = pNewObj->CompareTo( WBEM_FLAG_IGNORE_OBJECT_SOURCE, pObj );    

    if ( hr != WBEM_S_SAME )
    {
        return FALSE;
    }

    delete [] pBuff;

    return TRUE;
}

int TestMain()
{
    HRESULT hr;

    CWbemPtr<IWbemLocator> pLocator;

    hr = CoCreateInstance( CLSID_WbemLocator, 
                           NULL, 
                           CLSCTX_SERVER,
                           IID_IWbemLocator, 
                           (void**)&pLocator );
    if ( FAILED(hr) )
    {
        printf("ERROR CoCIing WbemLocator : hr = 0x%x\n",hr);
        return 1;
    }

    CWbemPtr<IWbemServices> pSvc;

    hr = pLocator->ConnectServer( L"root\\default",
                                  NULL, 
                                  NULL,
                                  NULL, 
                                  0, 
                                  NULL, 
                                  NULL, 
                                  &pSvc );
    if ( FAILED(hr) )
    {
        wprintf( L"ERROR Connecting to root\\default namespace : hr=0x%x\n",hr);
        return 1;
    } 

    CWbemPtr<IWbemClassObject> pClass;

    hr = pSvc->GetObject( CWbemBSTR(L"TestMarshalClass"), 
                          0, 
                          NULL, 
                          &pClass, 
                          NULL );
    if ( FAILED(hr) )
    {
        printf( "Failed getting test marshal class : hr=0x%x\n", hr );
        return 1;
    }

    CWbemPtr<IWbemClassObject> pObj;

    hr = pSvc->GetObject( CWbemBSTR(L"TestMarshalClass='BasicObject'"), 
                          0, 
                          NULL, 
                          &pObj, 
                          NULL );
    if ( FAILED(hr) )
    {
        printf( "Failed getting test marshal object : hr=0x%x\n", hr );
        return 1;
    }

    CWbemPtr<IWmiObjectMarshal> pMrsh, pUnmrsh;

    hr = CoCreateInstance( CLSID_WmiSmartObjectMarshal, 
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiObjectMarshal,
                           (void**)&pMrsh );

    hr = CoCreateInstance( CLSID_WmiSmartObjectUnmarshal, 
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiObjectMarshal,
                           (void**)&pUnmrsh );

    if ( FAILED(hr) )
    {
        printf("Failed CoCIing WmiSmartObjectMarshal. HR = 0x%x\n", hr);
        return 1;
    }
                              
    if ( MarshalTest( pMrsh, pUnmrsh, pClass, WMIMSG_FLAG_MRSH_FULL ) )
    {
        printf( "Successful Marshal Test w/ Class Object and FULL Flag\n" ); 
    }
    else
    {
        printf( "Failed Marshal Test w/ Class Object and FULL Flag\n" );
    }

    if ( MarshalTest( pMrsh, pUnmrsh, pObj, WMIMSG_FLAG_MRSH_FULL ) )
    {
        printf( "Successful Marshal Test w/ Instance and FULL Flag\n" ); 
    }
    else
    {
        printf( "Failed Marshal Test w/ Instance and FULL Flag\n" );
    }

    if ( MarshalTest( pMrsh, pUnmrsh, pObj, WMIMSG_FLAG_MRSH_PARTIAL ) )
    {
        printf( "Successful Marshal Test w/ Instance and PARTIAL Flag\n" ); 
    }
    else
    {
        printf( "Failed Marshal Test w/ Instance and PARTIAL Flag\n" );
    }

    if ( MarshalTest( pMrsh, pUnmrsh, pObj, WMIMSG_FLAG_MRSH_PARTIAL ) )
    {
        printf( "Successful Repeated Marshal Test w/ Instance and PARTIAL Flag\n" ); 
    }
    else
    {
        printf( "Failed Repeated Marshal Test w/ Instance and PARTIAL Flag\n" );
    }

    if ( MarshalTest( pMrsh, pUnmrsh, pObj, WMIMSG_FLAG_MRSH_FULL_ONCE ) )
    {
        printf( "Successful Marshal Test w/ Instance and FULL_ONCE Flag\n" ); 
    }
    else
    {
        printf( "Failed Marshal Test w/ Instance and FULL_ONCE Flag\n" );
    }

    if ( MarshalTest( pMrsh, pUnmrsh, pObj, WMIMSG_FLAG_MRSH_FULL_ONCE ) )
    {
        printf( "Successful Repeated Marshal Test w/ Instance and FULL_ONCE Flag\n" ); 
    }
    else
    {
        printf( "Failed Repeated Marshal Test w/ Instance and FULL_ONCE Flag\n" );
    }

    return 0;
}

extern "C" int __cdecl wmain( int argc, WCHAR** argv )
{ 
    CoInitialize( NULL );

    TestMain();

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\test\msgqueue\msgqueue.cpp ===
#include <windows.h>
#include <wmimsg.h>
#include <comutl.h>
#include "stdio.h"

LPWSTR g_wszQueue;
DWORD g_dwNumQueues = 1;
DWORD g_dwQuota = 0xffffffff;
DWORD g_dwQos = WMIMSG_FLAG_QOS_EXPRESS;

BOOL g_bAuth = FALSE;
BOOL g_bDestroy = FALSE;
BOOL g_bCreate = FALSE;
BOOL g_bVerbose = FALSE;
GUID g_guidType = { 0x5b6ef4a4, 0x931, 0x46a4, 
                   {0xa5,0xa9,0x8e,0x4,0xfc,0xcd,0xb0,0xd5} };

BOOL ParseArg( LPWSTR wszArg )
{
    WCHAR* pCurr = wszArg;
        
    if ( *pCurr != '/' && *pCurr != '-' )
    {
        g_wszQueue = pCurr;
        return TRUE;
    }

    pCurr++; // remove the / or -
    
    if ( wbem_wcsicmp( pCurr, L"auth" ) == 0 )
    {
        g_bAuth = TRUE;
    }
    else if ( wbem_wcsicmp( pCurr, L"create" ) == 0 )
    {
        g_bCreate = TRUE;
    }
    else if ( wbem_wcsicmp( pCurr, L"destroy" ) == 0 )
    {
        g_bDestroy = TRUE;
    }
    else if ( wbem_wcsicmp( pCurr, L"txn" ) == 0 )
    {
        g_dwQos = WMIMSG_FLAG_QOS_XACT;
    }
    else if ( wbem_wcsicmp( pCurr, L"express" ) == 0 )
    {
        g_dwQos = WMIMSG_FLAG_QOS_EXPRESS;
    }
    else if ( wbem_wcsicmp( pCurr, L"guaranteed" ) == 0 )
    {
        g_dwQos = WMIMSG_FLAG_QOS_GUARANTEED;
    }
    else if ( wbem_wcsicmp( pCurr, L"verbose") == 0 )
    {
        g_bVerbose = TRUE;
    }
    else if ( wbem_wcsnicmp( pCurr, L"quota", 5 ) == 0 )
    {
        pCurr += 5;
        
        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }

        g_dwQuota = _wtol( pCurr );
    }
    else if ( wbem_wcsnicmp( pCurr, L"numqueues", 9 ) == 0 )
    {
        pCurr += 9;
        
        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }

        g_dwNumQueues = _wtol( pCurr );
    }
    else if ( wbem_wcsnicmp( pCurr, L"type", 4 ) == 0 )
    {
        pCurr += 4;
        
        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }

        if ( FAILED( CLSIDFromString( pCurr, &g_guidType ) ) )
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }
    return TRUE;
}

BOOL ParseArgs( int nArgs, LPWSTR* awszArgs )
{
    if ( nArgs < 1 )
    {
        return FALSE;
    }

    for( int i=1; i < nArgs; i++ )
    {
        if ( !ParseArg( awszArgs[i] ) )
        {
            return FALSE;
        }
    }

    if ( (g_bCreate || g_bDestroy) && g_wszQueue == NULL )
    {
        return FALSE;
    }

    return TRUE;
}

int TestMain()
{
    HRESULT hr;
    
    CWbemPtr<IWmiMessageQueueManager> pQueueMgr;

    hr = CoCreateInstance( CLSID_WmiMessageQueueManager, 
                           NULL, 
                           CLSCTX_INPROC, 
                           IID_IWmiMessageQueueManager,
                           (void**)&pQueueMgr );

    if ( FAILED(hr) )
    {
        printf( "Failed Obtaining Queue Object. HR = 0x%x\n", hr );
        return 1;
    }

    WCHAR awchQueue[256];    
    
    SYSTEMTIME Start, End;

    GetSystemTime( &Start );

    if ( g_bCreate )
    {
        wcscpy( awchQueue, g_wszQueue );

        hr = pQueueMgr->Create( awchQueue, 
                                g_guidType,
                                g_bAuth,
                                g_dwQos,
                                g_dwQuota,
                                NULL );
    
        for( DWORD i=1; i < g_dwNumQueues && SUCCEEDED(hr); i ++ )
        {
            swprintf( awchQueue, L"%s%d", g_wszQueue, i );
            
            hr = pQueueMgr->Create( awchQueue,
                                    g_guidType,
                                    g_bAuth,
                                    g_dwQos,
                                    g_dwQuota,
                                    NULL );
        }

        if ( FAILED(hr) )
        {
            wprintf( L"Failed Creating Queue with name %s. HR = 0x%x\n",
                     awchQueue, hr );
            return 1;
        }
    }

    if ( g_bDestroy )
    {
        wcscpy( awchQueue, g_wszQueue );

        hr = pQueueMgr->Destroy( awchQueue );
    
        if ( FAILED(hr) )
        {
            wprintf( L"Failed Destroying Queue with name %s. HR = 0x%x\n",
                     awchQueue, hr );
        }

        for( ULONG i=1; i < g_dwNumQueues; i ++ )
        {
            swprintf( awchQueue, L"%s%d", g_wszQueue, i );            
            
            hr = pQueueMgr->Destroy( awchQueue );
            
            if ( FAILED(hr) )
            {
                wprintf( L"Failed Destroying Queue with name %s. HR = 0x%x\n",
                         awchQueue, hr );
            }
        }
    }

    if ( g_bVerbose )
    {
        WCHAR achType[256];
        StringFromGUID2( g_guidType, achType, 256 ); 

        wprintf( L"Getting all Names for Type : %s\n", achType );

        LPWSTR* pwszNames;
        ULONG cwszNames;

        hr = pQueueMgr->GetAllNames(g_guidType, TRUE, &pwszNames, &cwszNames );

        if ( FAILED(hr) )
        {
            wprintf( L"Failed Getting All Queue Names. HR = 0x%x\n" );
            return 1;
        }

        for( ULONG i=0; i < cwszNames; i++ )
        {
            wprintf( L"    %s\n", pwszNames[i] );
            CoTaskMemFree( pwszNames[i] );
        }
        
        CoTaskMemFree( pwszNames );
    }

    GetSystemTime( &End );

    __int64 i64Start, i64End;
    DWORD dwElapsed;
    SystemTimeToFileTime( &Start, PFILETIME(&i64Start) );
    SystemTimeToFileTime( &End, PFILETIME(&i64End) );
    dwElapsed = DWORD(i64End - i64Start) / 10000;
    
    printf("Test Completed in %d msec!\n", dwElapsed );

    return 0;
}

extern "C" int __cdecl wmain( int argc, wchar_t** argv )
{
    CoInitialize( NULL );

    if ( !ParseArgs( argc, argv ) )
    {
        wprintf( L"Usage : msgqueue [-express|-guaranteed|-txn] \n"
                 L"                 [-auth] [-numqueues:#] [-quota:#]\n"
                 L"                 [-create] [-destroy] [-verbose]\n"
                 L"                 [-type:clsid] <queuename>\n");   
        return 1;
    }

    int ret = TestMain();

    CoUninitialize();

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\test\msgrecv\msgrecv.cpp ===
#include <windows.h>
#include <assert.h>
#include <wmimsg.h>
#include <rcvtest.h>
#include <rcvtest_i.c>
#include <stdio.h>

BOOL g_bVerbose = FALSE;
ULONG g_ulNumMsgs = 1;
LPCWSTR g_wszTarget = NULL;
LPCWSTR g_wszPrincipal = NULL;
DWORD g_dwFlags = 0;
BOOL g_bKill = FALSE;

BOOL ParseArg( LPWSTR wszArg )
{
    WCHAR* pCurr = wszArg;
    
    if ( *pCurr != '/' && *pCurr != '-' )
    {
        g_wszTarget = pCurr;
        return TRUE;
    }

    pCurr++; // remove the / or -

    if ( wbem_wcsicmp( pCurr, L"txn" ) == 0 )
    {
        g_dwFlags &= ~WMIMSG_MASK_QOS;
        g_dwFlags |= WMIMSG_FLAG_QOS_XACT;
    }
    else if ( wbem_wcsicmp( pCurr, L"express" ) == 0 )
    {
        g_dwFlags &= ~WMIMSG_MASK_QOS;
        g_dwFlags |= WMIMSG_FLAG_QOS_EXPRESS;
    }
    else if ( wbem_wcsicmp( pCurr, L"guaranteed" ) == 0 )
    {
        g_dwFlags &= ~WMIMSG_MASK_QOS;
        g_dwFlags |= WMIMSG_FLAG_QOS_GUARANTEED;
    }
    else if ( wbem_wcsicmp( pCurr, L"sync" ) == 0 )
    {
        g_dwFlags &= ~WMIMSG_MASK_QOS;
        g_dwFlags |= WMIMSG_FLAG_QOS_SYNCHRONOUS;
    }
    else if ( wbem_wcsicmp( pCurr, L"ack" ) == 0 )
    {
        g_dwFlags |= WMIMSG_FLAG_RCVR_ACK;
    }
    else if ( wbem_wcsicmp( pCurr, L"verify" ) == 0 )
    {
        g_dwFlags |= WMIMSG_FLAG_RCVR_PRIV_VERIFY;
    }
    else if ( wbem_wcsicmp( pCurr, L"secure" ) == 0 )
    {
        g_dwFlags |= WMIMSG_FLAG_RCVR_SECURE_ONLY;
    }
    else if ( wbem_wcsnicmp( pCurr, L"nummsgs", 7 ) == 0 )
    {
        pCurr += 7;

        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }
        
        g_ulNumMsgs = _wtol( pCurr );
    }
    else if ( wbem_wcsnicmp( pCurr, L"svrprinc", 8 ) == 0 )
    {
        pCurr += 8;

        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }
        
        g_wszPrincipal = pCurr;
    }
    else if ( wbem_wcsicmp( pCurr, L"verbose" ) == 0 )
    {
        g_bVerbose = TRUE;
    }
    else if ( wbem_wcsicmp( pCurr, L"kill" ) == 0 )
    {
        g_bKill = TRUE;
    }
    else
    {
        return FALSE;
    }
    return TRUE;
}

BOOL ParseArgs( int nArgs, LPWSTR* awszArgs )
{
    if ( nArgs < 2 )
    {
        return FALSE;
    }

    for( int i=1; i < nArgs; i++ )
    {
        if ( !ParseArg( awszArgs[i] ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}

extern "C" int __cdecl wmain( int argc, wchar_t* argv[] )
{
    if ( !ParseArgs( argc, argv ) )
    {
        wprintf( L"Usage: msgrcv [-sync|-express|-guaranteed|-txn] \n"
                 L"             [-nummsgs:#] [-ack] [-verify] \n"
                 L"             [-verbose] [-svrprinc:principal] endpoint\n" );
        return 1;
    }

    HRESULT hr;

    CoInitialize( NULL );

    IReceiveTest* pRcvTest;

    hr = CoCreateInstance( CLSID_ReceiveTest,
                           NULL,
                           CLSCTX_LOCAL_SERVER,
                           IID_IReceiveTest,
                           (void**)&pRcvTest );

    if ( FAILED(hr) )
    {
        printf( "Could not CoCI MsgSvr obj. HR = 0x%x\n", hr );
        return 1;
    }

    if ( g_bKill )
    {
        hr = pRcvTest->Kill();

        if ( FAILED(hr) )
        {
            printf("Failed to Kill MsgSvr. HR = 0x%x\n", hr );
            return 1;
        }

        printf("Killed MsgSvr\n");
        return 0;
    }

    ULONG ulElapsed;

    hr = pRcvTest->RunTest( g_wszTarget, 
                            g_dwFlags, 
                            g_wszPrincipal, 
                            g_ulNumMsgs, 
                            &ulElapsed );
    pRcvTest->Release();

    if ( FAILED(hr) )
    {
        printf( "Test Failed. HR = 0x%x\n", hr );
        return 1;
    }

    printf( "Test Succeeded in %d msec.\n", ulElapsed );
    printf( "Rate is %f msg/sec\n", g_ulNumMsgs * 1000.0 / ulElapsed ); 

    CoUninitialize();
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\test\msgsvr\msgsvr.cpp ===
#include <windows.h>
#include <wmimsg.h>
#include <comutl.h>
#include <rcvtest.h>
#include <rcvtest_i.c>
#include <stdio.h>

FILE* g_pfLogFile;
    
class CReceiveTest : public IReceiveTest, public IClassFactory
{
public:

    STDMETHOD_(ULONG,AddRef)() { return 1; }
    STDMETHOD_(ULONG,Release)() { return 1; }
    STDMETHOD(QueryInterface)( REFIID riid , void** ppv )
    {
        if ( riid == IID_IUnknown || riid == IID_IReceiveTest )
        {
            *ppv = (IReceiveTest*)this;
        }
        else if ( riid == IID_IClassFactory )
        {
            *ppv = (IClassFactory*)this;
        }
        else
        {
            return E_NOINTERFACE;
        }
        return S_OK;
    }
    
    STDMETHOD(CreateInstance)( IUnknown* pOuter, REFIID riid, void** ppv )
    {
        return QueryInterface( riid, ppv );
    }

    STDMETHOD(LockServer) (BOOL bLock ) { return S_OK; }

    STDMETHOD(RunTest)( LPCWSTR wszTarget, 
                        DWORD dwFlags, 
                        LPCWSTR wszPrincipal,
                        ULONG cMsgs, 
                        ULONG* pultime );    
    
    STDMETHOD(Kill)() 
    {
        PostThreadMessage( GetCurrentThreadId(), WM_QUIT, 0, 0 );
        return S_OK;
    }
};

struct CTestMsgHandler : public IWmiMessageTraceSink, 
                         public IWmiMessageSendReceive
{
    HRESULT m_hr;
    HANDLE m_hEvent;
    long m_cCurrentMsgs;
    long m_cExpectedMsgs;
    SYSTEMTIME m_Start;

    CTestMsgHandler( long cExpectedMsgs, HANDLE hEvent )
    : m_cExpectedMsgs( cExpectedMsgs ), m_cCurrentMsgs(0), 
      m_hEvent( hEvent ), m_hr( S_OK )
    {
    }

    ~CTestMsgHandler()
    {
        CloseHandle( m_hEvent );
    }

    HRESULT GetResult() { return m_hr; }

    STDMETHOD_(ULONG,AddRef)() { return 1; }
    STDMETHOD_(ULONG,Release)() { return 1; }

    STDMETHOD(QueryInterface)( REFIID riid , void** ppv ) 
    { 
        if ( riid == IID_IWmiMessageTraceSink || 
             riid == IID_IUnknown )
        {
            *ppv = (IWmiMessageTraceSink*)this;
        }
        else if ( riid == IID_IWmiMessageSendReceive )
        {
            *ppv = (IWmiMessageSendReceive*)this;
        }
        if ( *ppv == NULL )
        {
            return E_NOINTERFACE;
        }
        return S_OK;
    }

    void LogMessage( PBYTE pMsg, 
                     ULONG cMsg,
                     PBYTE pAuxData,
                     ULONG cAuxData,
                     DWORD dwFlagStatus,
                     IUnknown* pCtx )
    {
        if ( g_pfLogFile == NULL )
        {
            return;
        }

        IWmiMessageReceiverContext* pRecvCtx;

        pCtx->QueryInterface( IID_IWmiMessageReceiverContext, 
                              (void**)&pRecvCtx );

        SYSTEMTIME st;
        WCHAR awchTime[64];
        pRecvCtx->GetTimeSent( &st );
        swprintf( awchTime, L"%d:%d:%d:%d", st.wHour, 
                 st.wMinute, 
                 st.wSecond, 
                 st.wMilliseconds );
        
        WCHAR awchTarget[256];
        ULONG cTarget;

        pRecvCtx->GetTarget( awchTarget, 256, &cTarget );

        WCHAR awchSource[256];
        ULONG cSource;

        pRecvCtx->GetSendingMachine( awchSource, 256, &cSource );

        WCHAR awchSenderId[256];
        ULONG cSenderId;

        pRecvCtx->GetSenderId( awchSenderId, 256, &cSenderId );

        awchSource[cSource] = '\0';
        awchSenderId[cSenderId] = '\0';
        awchTarget[cTarget] = '\0';

        BOOL bAuth;

        bAuth = pRecvCtx->IsSenderAuthenticated() == S_OK ? TRUE : FALSE;

        fwprintf( g_pfLogFile, L"MSG - #%d, Len:%d, AuxLen:%d, Status:%d, "
                  L"Time:%s, Source:%s, Target:%s, SenderId:%s, Auth:%d\n",   
                  m_cCurrentMsgs, cMsg, cAuxData, dwFlagStatus, 
                  awchTime, awchSource, awchTarget, awchSenderId, bAuth );  
        
        fflush( g_pfLogFile );
    }

    STDMETHOD(Notify)( HRESULT hRes, 
                       GUID guidSource, 
                       LPCWSTR wszError,  
                       IUnknown* pCtx )
    {
        if ( g_pfLogFile != NULL )
        {
            fwprintf( g_pfLogFile, L"Notify : HR=0x%x, ErrorStr : %s\n", 
                      hRes, wszError );
        }

        if ( SUCCEEDED(m_hr) )
        {
            m_hr = hRes;
            SetEvent( m_hEvent );
        }
        return S_OK;
    }

    STDMETHOD(SendReceive)( PBYTE pMsg, 
                            ULONG cMsg,
                            PBYTE pAuxData,
                            ULONG cAuxData,
                            DWORD dwFlagStatus,
                            IUnknown* pCtx )
    {
        LogMessage( pMsg, cMsg, pAuxData, cAuxData, dwFlagStatus, pCtx );

        long cCurrentMsgs = InterlockedIncrement( &m_cCurrentMsgs );

        if ( cCurrentMsgs == 1 )
        {
            GetSystemTime( &m_Start );
        }
        
        if ( cCurrentMsgs >= m_cExpectedMsgs )
        {
            SetEvent( m_hEvent );
        }

        return S_OK;
    }
};

static HANDLE g_hShutdown;

HRESULT CReceiveTest::RunTest( LPCWSTR wszTarget, 
                               DWORD dwFlags, 
                               LPCWSTR wszPrincipal,
                               ULONG cMsgs,
                               ULONG* pulTime )
{
    HRESULT hr;

    CLSID clsidReceiver;

    *pulTime = 0;

    if ( ( dwFlags & WMIMSG_MASK_QOS) != WMIMSG_FLAG_QOS_SYNCHRONOUS )
    {
        clsidReceiver = CLSID_WmiMessageMsmqReceiver;
    }
    else
    {
        clsidReceiver = CLSID_WmiMessageRpcReceiver;
    }        

    CWbemPtr<IWmiMessageReceiver> pReceiver;
    
    hr = CoCreateInstance( clsidReceiver,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiMessageReceiver,
                           (void**)&pReceiver );
    if ( FAILED(hr) )
    {
        return hr;
    }

    HANDLE hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

    CTestMsgHandler TestHndlr = CTestMsgHandler( cMsgs, hEvent );
     
    WMIMSG_RCVR_AUTH_INFO AuthInfo;

    if ( wszPrincipal != NULL )
    {
        AuthInfo.awszPrincipal = &wszPrincipal;
        AuthInfo.cwszPrincipal = 1;
        hr = pReceiver->Open( wszTarget, dwFlags, &AuthInfo, &TestHndlr );
    }
    else
    {
        hr = pReceiver->Open( wszTarget, dwFlags, NULL, &TestHndlr );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    SYSTEMTIME Start, End;

    WaitForSingleObject( hEvent, INFINITE );

    if ( FAILED( TestHndlr.m_hr ) )
    {
        return TestHndlr.m_hr;
    }

    Start = TestHndlr.m_Start;

    GetSystemTime( &End );

    __int64 i64Start, i64End;
    DWORD dwElapsed;
    SystemTimeToFileTime( &Start, PFILETIME(&i64Start) );
    SystemTimeToFileTime( &End, PFILETIME(&i64End) );
    dwElapsed = DWORD(i64End - i64Start) / 10000;

    *pulTime = dwElapsed;

    return S_OK;
};

extern "C" int __cdecl main( int argc, char* argv[] )
{
    if ( argc > 1 )
    {            
        LPCSTR szLogFile = argv[1];

        g_pfLogFile = fopen( szLogFile, "w" );

        if ( g_pfLogFile == NULL )
        {
            printf( "Could not open LogFile %s", szLogFile );
            return 1;
        }
    }

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    CoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                          RPC_C_IMP_LEVEL_IDENTIFY, NULL, EOAC_NONE, NULL );

    g_hShutdown = CreateEvent( NULL, TRUE, FALSE, NULL );

    CReceiveTest RcvTest;
    
    HRESULT hr;
    DWORD dwReg;

    hr = CoRegisterClassObject( CLSID_ReceiveTest, 
                                (IClassFactory*)&RcvTest,
                                CLSCTX_LOCAL_SERVER,
                                REGCLS_MULTIPLEUSE,
                                &dwReg );
    if ( FAILED(hr) )
    {
        return 1;
    }

    WaitForSingleObject( g_hShutdown, INFINITE );

    if ( g_pfLogFile != NULL )
    {
        fclose( g_pfLogFile );
    }

    CoRevokeClassObject( dwReg );

    CoUninitialize();
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\msg\test\msgsend\msgsend.cpp ===
#include <windows.h>
#include <wmimsg.h>
#include <comutl.h>
#include "stdio.h"

ULONG g_cTargets = 0;
LPWSTR g_awszTargets[256];
LPWSTR g_wszAckTarget = NULL;
LPWSTR g_wszTargetPrincipal = NULL;
DWORD g_dwFlags = 0;
ULONG g_ulNumMsgs = 1;
ULONG g_ulSizeMsg = 256;
BOOL g_bVerbose = FALSE;

class CTestErrorSink : public IWmiMessageTraceSink
{
public:
    STDMETHOD_(ULONG,AddRef)() { return 1; }
    STDMETHOD_(ULONG,Release)() { return 1; }
    STDMETHOD(QueryInterface)( REFIID, void** ) { return E_NOINTERFACE; }
    STDMETHOD(Notify)( HRESULT hRes, 
                       GUID guidSource, 
                       LPCWSTR wszTrace, 
                       IUnknown* pCtx )
    {
        if ( FAILED(hRes) )
        {
            wprintf(L"Error: %s, HR: 0x%x\n", wszTrace, hRes );
        }
        else if ( g_bVerbose ) 
        {
            wprintf(L"Trace: %s, HR: 0x%x\n", wszTrace, hRes );
        }

        return S_OK;
    }
};

BOOL ParseArg( LPWSTR wszArg )
{
    WCHAR* pCurr = wszArg;
        
    if ( *pCurr != '/' && *pCurr != '-' )
    {
        g_awszTargets[g_cTargets++] = pCurr;
        return TRUE;
    }

    pCurr++; // remove the / or -
    
    if ( wbem_wcsicmp( pCurr, L"auth" ) == 0 )
    {
        g_dwFlags |= WMIMSG_FLAG_SNDR_AUTHENTICATE;
    }
    else if ( wbem_wcsicmp( pCurr, L"encrypt" ) == 0 )
    {
        g_dwFlags |= WMIMSG_FLAG_SNDR_ENCRYPT;
    }
    else if ( wbem_wcsicmp( pCurr, L"txn" ) == 0 )
    {
        g_dwFlags &= ~WMIMSG_MASK_QOS;
        g_dwFlags |= WMIMSG_FLAG_QOS_XACT;
    }
    else if ( wbem_wcsicmp( pCurr, L"express" ) == 0 )
    {
        g_dwFlags &= ~WMIMSG_MASK_QOS;
        g_dwFlags |= WMIMSG_FLAG_QOS_EXPRESS;
    }
    else if ( wbem_wcsicmp( pCurr, L"guaranteed" ) == 0 )
    {
        g_dwFlags &= ~WMIMSG_MASK_QOS;
        g_dwFlags |= WMIMSG_FLAG_QOS_GUARANTEED;
    }
    else if ( wbem_wcsicmp( pCurr, L"sync" ) == 0 )
    {
        g_dwFlags &= ~WMIMSG_MASK_QOS;
        g_dwFlags |= WMIMSG_FLAG_QOS_SYNCHRONOUS;
    }
    else if ( wbem_wcsicmp( pCurr, L"verbose") == 0 )
    {
        g_bVerbose = TRUE;
    }
    else if ( wbem_wcsicmp( pCurr, L"sign") == 0 )
    {
        g_dwFlags |= WMIMSG_FLAG_SNDR_PRIV_SIGN;
    }
    else if ( wbem_wcsnicmp( pCurr, L"ack", 3 ) == 0 )
    {
        pCurr += 3;
        
        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }

        g_wszAckTarget = pCurr;
    }
    else if ( wbem_wcsnicmp( pCurr, L"tgtprinc", 8 ) == 0 )
    {
        pCurr += 8;
        
        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }

        g_wszTargetPrincipal = pCurr;
    }
    else if ( wbem_wcsnicmp( pCurr, L"nummsgs", 7 ) == 0 )
    {
        pCurr += 7;
        
        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }

        g_ulNumMsgs = _wtol( pCurr );
    }
    else if ( wbem_wcsnicmp( pCurr, L"msgsize", 7 ) == 0 )
    {
        pCurr += 7;
        
        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }

        g_ulSizeMsg = _wtol( pCurr );
    }
    else
    {
        return FALSE;
    }
    return TRUE;
}

BOOL ParseArgs( int nArgs, LPWSTR* awszArgs )
{
    if ( nArgs < 2 )
    {
        return FALSE;
    }

    for( int i=1; i < nArgs; i++ )
    {
        if ( !ParseArg( awszArgs[i] ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}

int TestMain( CLSID ClsidSender )
{
    HRESULT hr;
    
    CWbemPtr<IWmiMessageSender> pSender;

    hr = CoCreateInstance( ClsidSender, 
                           NULL, 
                           CLSCTX_INPROC, 
                           IID_IWmiMessageSender,
                           (void**)&pSender );

    if ( FAILED(hr) )
    {
        printf( "Failed Creating Sender. HR = 0x%x\n", hr );
        return 1;
    }

    CWbemPtr<IWmiMessageMultiSendReceive> pMultiSend;

    hr = CoCreateInstance( CLSID_WmiMessageMultiSendReceive, 
                           NULL, 
                           CLSCTX_INPROC, 
                           IID_IWmiMessageMultiSendReceive,
                           (void**)&pMultiSend );

    if ( FAILED(hr) )
    {
        printf( "Failed Creating Multi Send. HR = 0x%x\n", hr );
        return 1;
    }

    CTestErrorSink ErrorSink;

    for( ULONG i=0; i < g_cTargets; i++ )
    {
        CWbemPtr<IWmiMessageSendReceive> pSend;

        WMIMSG_SNDR_AUTH_INFO AuthInfo;
        ZeroMemory( &AuthInfo, sizeof(WMIMSG_SNDR_AUTH_INFO) );

        AuthInfo.wszTargetPrincipal = g_wszTargetPrincipal;

        hr = pSender->Open( g_awszTargets[i],
                            g_dwFlags,
                            &AuthInfo,
                            g_wszAckTarget,
                            &ErrorSink,
                            &pSend );
        if ( FAILED(hr) )
        {
            printf( "Failed Opening Sender. HR = 0x%x\n", hr );
            return 1;
        }

        hr = pMultiSend->Add( 0, pSend );

        if ( FAILED(hr) )
        {
            printf( "Failed Adding to Multi Send. HR = 0x%x\n", hr );
            return 1;
        }
    }

    BYTE* pMsg = new BYTE[g_ulSizeMsg];
    BYTE achAuxMsg[256];

    for( i=0; i < g_ulNumMsgs; i++ )
    {
        hr = pMultiSend->SendReceive( pMsg, g_ulSizeMsg, achAuxMsg, 256, 0, NULL );

        if ( FAILED(hr) )
        {
            printf( "Failed sending message. HR = 0x%x\n", hr );
            return 1;
        }
    }

    printf("Test Complete!\n");

    return 0;
}

extern "C" int __cdecl wmain( int argc, wchar_t** argv )
{
    CoInitialize( NULL );

    if ( !ParseArgs( argc, argv ) )
    {
        wprintf( L"Usage : msgsend [-sync|-express|-guaranteed|-txn] \n"
                 L"                [-auth] [-encrypt] [-ack:target] \n"
                 L"                [-nummsgs:#] [-msgsize:#] [-sign]\n"
                 L"                [-verbose] [-tgtprinc:princname] \n"
                 L"                target1 target2..\n"); 
                        
        return 1;
    }

    DWORD dwQos = g_dwFlags & WMIMSG_MASK_QOS;

    if ( g_bVerbose )
    {
        if (g_dwFlags & WMIMSG_FLAG_SNDR_AUTHENTICATE) printf( "-Authenticate\n" );
        if ( g_dwFlags & WMIMSG_FLAG_SNDR_ENCRYPT ) printf( "-Encryption\n" );
        if ( dwQos == WMIMSG_FLAG_QOS_SYNCHRONOUS  ) printf( "-Sync QoS\n" );
        if ( dwQos == WMIMSG_FLAG_QOS_EXPRESS ) printf( "-Express QoS\n" );
        if ( dwQos == WMIMSG_FLAG_QOS_GUARANTEED ) printf("-Guaranteed QoS\n");
        if ( dwQos == WMIMSG_FLAG_QOS_XACT ) printf( "-Xact QoS\n" );

        if ( g_wszAckTarget != NULL )
        {
            wprintf( L"-Ack Target: %s \n", g_wszAckTarget );
        }
        
        if ( g_wszTargetPrincipal != NULL )
        {
            wprintf( L"-Target Principal: %s \n", g_wszTargetPrincipal );
        }

        for( ULONG i=0; i < g_cTargets; i++ )
        {
            wprintf( L"-Target: %s \n", g_awszTargets[i] );
        }

        printf( "---------------------------------\n\n" );
    }

    CLSID ClsidSender;

    if ( dwQos == WMIMSG_FLAG_QOS_SYNCHRONOUS )
    {
        ClsidSender = CLSID_WmiMessageRpcSender;
    }
    else
    {
        ClsidSender = CLSID_WmiMessageMsmqSender;
    }

    int ret = TestMain( ClsidSender );

    CoUninitialize();

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ntperfshell\ntperf.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  NTPERF.CPP
//  
//  Sample NT5 Perf Counter Provider
//
//  raymcc      02-Dec-97   Created        
//  raymcc      20-Feb-98   Updated to use new initializer
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>

#include <wbemidl.h>

#include <wbemint.h>

#include "ntperf.h"

//***************************************************************************
//
//  CNt5Refresher constructor
//
//***************************************************************************
// ok

CNt5Refresher::CNt5Refresher()
{
    m_lRef = 0;     // COM Ref Count
    
    // Set the instance cache to all zeros.
    // As objects are added to the refresher
    // we simply put them in unused slots in the array.
    // ================================================
    
    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        m_aInstances[i] = 0;
    }

    // Set the values of the property handles to zero.
    // ===============================================

    m_hName     = 0;
    m_hCounter1 = 0;
    m_hCounter2 = 0;
    m_hCounter3 = 0;
}

//***************************************************************************
//
//  CNt5Refresher destructor
//
//***************************************************************************
// ok

CNt5Refresher::~CNt5Refresher()
{
    // Release the cached IWbemObjectAccess instances.
    // ===============================================
    
    for (DWORD i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        if (m_aInstances[i])
            m_aInstances[i]->Release();
    }            
}

//***************************************************************************
//
//  CNt5Refresher::Refresh
//
//  Executed to refresh a set of instances bound to the particular 
//  refresher.
//
//***************************************************************************
// ok

HRESULT CNt5Refresher::Refresh(/* [in] */ long lFlags)
{
    // Zip through all the objects and increment the values.
    // =====================================================
    
    for (DWORD i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        // Get the object at this location.
        // ================================

        IWbemObjectAccess *pAccess = m_aInstances[i];

        // If there is no object in this array slot (a NULL pointer)
        // there is nothing to refresh.
        // =========================================================

        if (pAccess == 0)       
            continue;

        // Increment all the counter values to simulate an update.
        // The client already has a pointer to this object, so
        // all we have to do is update the values.
        // =======================================================
                        
        DWORD dwVal;
        pAccess->ReadDWORD(m_hCounter1, &dwVal);
        dwVal++;
        pAccess->WriteDWORD(m_hCounter1, dwVal);
        
        pAccess->ReadDWORD(m_hCounter3, &dwVal); 
        dwVal++;       
        pAccess->WriteDWORD(m_hCounter3, dwVal);

        unsigned __int64 qwVal;
        pAccess->ReadQWORD(m_hCounter2, &qwVal);
        qwVal++;
        pAccess->WriteQWORD(m_hCounter2, qwVal);
    }        

    return NO_ERROR;
}

//***************************************************************************
//
//  CNt5Refresher::TransferPropHandles
//
//  This is a private mechanism used by CNt5PerfProvider.
//  It is used to copy the property handles from the
//  hi-perf provider object to the refresher.  We need these handles to 
//  quickly access the properties in each instance.  The same handles are 
//  used for all instances.
//
//***************************************************************************
// ok

void CNt5Refresher::TransferPropHandles(CNt5PerfProvider *pSrc)
{
    m_hName     = pSrc->m_hName;
    m_hCounter1 = pSrc->m_hCounter1;
    m_hCounter2 = pSrc->m_hCounter2;
    m_hCounter3 = pSrc->m_hCounter3;
}

//***************************************************************************
//
//  CNt5Refresher::AddRef
//
//  Standard COM AddRef().
//
//***************************************************************************
// ok
ULONG CNt5Refresher::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CNt5Refresher::Release
//
//  Standard COM Release().
//
//***************************************************************************
// ok
ULONG CNt5Refresher::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CNt5Refresher::QueryInterface
//
//  Standard COM QueryInterface().
//
//***************************************************************************
// ok

HRESULT CNt5Refresher::QueryInterface(REFIID riid, void** ppv)
{
    if (riid == IID_IUnknown || riid == IID_IWbemRefresher)
    {
        *ppv = (IWbemRefresher *) this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

//***************************************************************************
//
//  CNt5Refresher::AddObject
//
//  Adds an object to the refresher.   This is a private mechanism
//  used by CNt5PerfProvider and not part of the COM interface.
//
//  The ID we return for future identification is simply
//  the array index.
//
//***************************************************************************
// ok

BOOL CNt5Refresher::AddObject(
    IWbemObjectAccess *pObj, 
    LONG *plId
    )
{
    for (DWORD i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        if (m_aInstances[i] == 0)
        {
            pObj->AddRef();
            m_aInstances[i] = pObj;
            
            // The ID we return for future identification is simply
            // the array index.
            // ====================================================
            *plId = i;
            return TRUE;
        }
    }        

    return FALSE;
}


//***************************************************************************
//
//  CNt5Refresher::RemoveObject
//
//  This is a private mechanism used by CNt5PerfProvider and not 
//  part of the COM interface.
//
//  Removes an object from the refresher by ID.   In our case, the ID
//  is actually the array index we used internally, so it is simple
//  to locate and remove the object.
//
//***************************************************************************

BOOL CNt5Refresher::RemoveObject(LONG lId)
{
    if (m_aInstances[lId] == 0)
        return FALSE;
        
    m_aInstances[lId]->Release();
    m_aInstances[lId] = 0;
    
    return TRUE;        
}



//***************************************************************************
//
//  CNt5PerfProvider constructor
//
//***************************************************************************
// ok

CNt5PerfProvider::CNt5PerfProvider()
{
    m_lRef = 0;
    m_pSampleClass = 0;

    // All the instances we work with are cached internally.
    // =====================================================
    
    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
        m_aInstances[i] = 0;

    // Property value handles.
    // =======================

    m_hName    = 0;         // "Name" property in the MOF
    m_hCounter1 = 0;        // "Counter1" in the MOF
    m_hCounter2 = 0;        // "Counter2" in the MOF
    m_hCounter3 = 0;        // "Counter3" in the MOF
}

//***************************************************************************
//
//  CNt5PerfProvider destructor
//
//***************************************************************************
// ok

CNt5PerfProvider::~CNt5PerfProvider()
{
    // Release all the objects which have been added to the array.
    // ===========================================================

    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
        if (m_aInstances[i])
            m_aInstances[i]->Release();
        
    if (m_pSampleClass)
        m_pSampleClass->Release();        
}


//***************************************************************************
//
//  CNt5Refresher::AddRef
//
//  Standard COM AddRef().
//
//***************************************************************************
// ok

ULONG CNt5PerfProvider::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CNt5Refresher::Release
//
//  Standard COM Release().
//
//***************************************************************************
// ok

ULONG CNt5PerfProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CNt5Refresher::QueryInterface
//
//  Standard COM QueryInterface().  We have to support two interfaces,
//  the IWbemHiPerfProvider interface itself to provide the objects and
//  the IWbemProviderInit interface to initialize the provider.
//
//***************************************************************************
// ok

HRESULT CNt5PerfProvider::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemHiPerfProvider)
    {
        *ppv = (IWbemHiPerfProvider*) this;
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IWbemProviderInit)
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}


//***************************************************************************
//
//  CNt5Refresher::Initialize
//
//  Called once during startup.  Insdicates to the provider which
//  namespace it is being invoked for and which User.  It also supplies
//  a back pointer to WINMGMT so that class definitions can be retrieved.
//
//  We perform any one-time initialization in this routine. The
//  final call to Release() is for any cleanup.
//
//  <wszUser>           The current user.
//  <lFlags>            Reserved.
//  <wszNamespace>      The namespace for which we are being activated.
//  <wszLocale>         The locale under which we are to be running.
//  <pNamespace>        An active pointer back into the current namespace
//                      from which we can retrieve schema objects.
//  <pCtx>              The user's context object.  We simply reuse this
//                      during any reentrant operations into WINMGMT.
//  <pInitSink>         The sink to which we indicate our readiness.
//
//***************************************************************************
// ok

HRESULT CNt5PerfProvider::Initialize( 
    /* [unique][in] */  LPWSTR wszUser,
    /* [in] */          LONG lFlags,
    /* [in] */          LPWSTR wszNamespace,
    /* [unique][in] */  LPWSTR wszLocale,
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemProviderInitSink __RPC_FAR *pInitSink
    )
{
    BSTR PropName = 0;
    IWbemObjectAccess *pAccess = 0;
        
    // Get a copy of our sample class def so that we can create & maintain
    // instances of it.
    // ===================================================================

    HRESULT hRes = pNamespace->GetObject(BSTR(L"Win32_Nt5PerfTest"), 
        0, pCtx, &m_pSampleClass, 0
        );

    if (hRes)
        return hRes;

    // Precreate 10 instances, and set them up in an array which
    // is a member of this C++ class.
    //
    // We only store the IWbemObjectAccess pointers, since
    // we are updating 'well-known' properties and already 
    // know their names.
    // ==========================================================

    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        IWbemClassObject *pInst = 0;
        m_pSampleClass->SpawnInstance(0, &pInst);

        // Write out the instance name.
        // ============================

        wchar_t buf[128];
        swprintf(buf, L"Inst_%d", i);

        VARIANT vName;
        VariantInit(&vName);
        V_BSTR(&vName) = SysAllocString(buf);
        V_VT(&vName) = VT_BSTR;

        BSTR PropName = SysAllocString(L"Name");
        pInst->Put(PropName, 0, &vName, 0);
        SysFreeString(PropName);
        VariantClear(&vName);
                        
        pInst->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pAccess);
        
        m_aInstances[i] = pAccess;
        pInst->Release();
    }


    // Get the property handles for the well-known properties in
    // this counter type.  We cache the property handles
    // for each property so that we can transfer them to the
    // refresher later on.
    // =========================================================    

    m_pSampleClass->QueryInterface(IID_IWbemObjectAccess, 
        (LPVOID *) &pAccess);


    PropName = SysAllocString(L"Name");
    hRes = pAccess->GetPropertyHandle(PropName, 0, &m_hName);
    SysFreeString(PropName);

    PropName = SysAllocString(L"Counter1");
    hRes = pAccess->GetPropertyHandle(PropName, 0, &m_hCounter1);
    SysFreeString(PropName);

    PropName = SysAllocString(L"Counter2");    
    hRes = pAccess->GetPropertyHandle(PropName, 0, &m_hCounter2);
    SysFreeString(PropName);
    
    PropName = SysAllocString(L"Counter3");    
    hRes = pAccess->GetPropertyHandle(PropName, 0, &m_hCounter3);
    SysFreeString(PropName);

    pAccess->Release();

    // Now let's set all the instance to some default values.
    // ======================================================
    
    for (i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        IWbemObjectAccess *pAccess = m_aInstances[i];

        hRes = pAccess->WriteDWORD(m_hCounter1, DWORD(i));
        hRes = pAccess->WriteQWORD(m_hCounter2, (_int64) + 100 + i);
        hRes = pAccess->WriteDWORD(m_hCounter3, DWORD(i + 1000));        
    }
    

    // We now have all the instances ready to go and all the 
    // property handles cached.   Tell WINMGMT that we're
    // ready to start 'providing'.
    // =====================================================

    pInitSink->SetStatus(0, WBEM_S_INITIALIZED);

    return NO_ERROR;
}
    

//***************************************************************************
//
//  CNt5Refresher::QueryInstances
//
//  Called whenever a complete, fresh list of instances for a given
//  class is required.   The objects are constructed and sent back to the
//  caller through the sink.  The sink can be used in-line as here, or
//  the call can return and a separate thread could be used to deliver
//  the instances to the sink.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  This
//                      should not be AddRef'ed.
//  <wszClass>          The class name for which instances are required.
//  <lFlags>            Reserved.
//  <pCtx>              The user-supplied context (not used here).
//  <pSink>             The sink to which to deliver the objects.  The objects
//                      can be delivered synchronously through the duration
//                      of this call or asynchronously (assuming we
//                      had a separate thread).  A IWbemObjectSink::SetStatus
//                      call is required at the end of the sequence.
//
//***************************************************************************
// ok
        
HRESULT CNt5PerfProvider::QueryInstances( 
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [string][in] */  WCHAR __RPC_FAR *wszClass,
    /* [in] */          long lFlags,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemObjectSink __RPC_FAR *pSink
    )
{
    if (pNamespace == 0 || wszClass == 0 || pSink == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Quickly zip through the instances and update the values before 
    // returning them.  This is just a dummy operation to make it
    // look like the instances are continually changing like real
    // perf counters.
    // ==============================================================

    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        IWbemObjectAccess *pAccess = m_aInstances[i];
        
        // Every object can be access one of two ways.  In this case
        // we get the 'other' (primary) interface to this same object.
        // ===========================================================
        
        IWbemClassObject *pOtherFormat = 0;
        pAccess->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pOtherFormat);
        
        
        // Send a copy back to the caller.
        // ===============================
        
        pSink->Indicate(1, &pOtherFormat);

        pOtherFormat->Release();    // Don't need this any more
    }
    
    // Tell WINMGMT we are all finished supplying objects.
    // =================================================

    pSink->SetStatus(0, WBEM_NO_ERROR, 0, 0);

    return NO_ERROR;
}    


//***************************************************************************
//
//  CNt5Refresher::CreateRefresher
//
//  Called whenever a new refresher is needed by the client.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  Not used.
//  <lFlags>            Not used.
//  <ppRefresher>       Receives the requested refresher.
//
//***************************************************************************        
// ok

HRESULT CNt5PerfProvider::CreateRefresher( 
     /* [in] */ IWbemServices __RPC_FAR *pNamespace,
     /* [in] */ long lFlags,
     /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher
     )
{
    if (pNamespace == 0 || ppRefresher == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Construct a new empty refresher.
    // ================================        

    CNt5Refresher *pNewRefresher = new CNt5Refresher();

    // Move copies of the property handles to the refresher
    // so that it can quickly update property values during
    // a refresh operation.
    // ====================================================
    
    pNewRefresher->TransferPropHandles(this);
    
    // Follow COM rules and AddRef() the thing before sending it back.
    // ===============================================================
    
    pNewRefresher->AddRef();
    *ppRefresher = pNewRefresher;
    
    return NO_ERROR;
}

//***************************************************************************
//
//  CNt5Refresher::CreateRefreshableObject
//
//  Called whenever a user wants to include an object in a refresher.
//     
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace in WINMGMT.
//  <pTemplate>         A pointer to a copy of the object which is to be
//                      added.  This object itself cannot be used, as
//                      it not owned locally.        
//  <pRefresher>        The refresher to which to add the object.
//  <lFlags>            Not used.
//  <pContext>          Not used here.
//  <ppRefreshable>     A pointer to the internal object which was added
//                      to the refresher.
//  <plId>              The Object Id (for identification during removal).        
//
//***************************************************************************        
// ok

HRESULT CNt5PerfProvider::CreateRefreshableObject( 
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [out] */ long __RPC_FAR *plId
    )
{
    // The object supplied by <pTemplate> must not be copied.
    // Instead, we want to find out which object the caller is after
    // and return a pointer to *our* own private instance which is 
    // already set up internally.  This value will be sent back to the
    // caller so that everyone is sharing the same exact instance
    // in memory.
    // ===============================================================

    // Find out which object is being requested for addition.
    // ======================================================
    
    wchar_t buf[128];
    *buf = 0;
    LONG lNameLength = 0;    
    pTemplate->ReadPropertyValue(m_hName, 128, &lNameLength, LPBYTE(buf));
    
    // Scan out the index from the instance name.  We only do this
    // because the instance name is a string.
    // ===========================================================

    DWORD dwIndex = 0;    
    swscanf(buf, L"Inst_%u", &dwIndex);
    // Now we know which object is desired.
    // ====================================
    
    IWbemObjectAccess *pOurCopy = m_aInstances[dwIndex];

    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
    // =========================================================
        
    CNt5Refresher *pOurRefresher = (CNt5Refresher *) pRefresher;

    pOurRefresher->AddObject(pOurCopy, plId);

    // Return a copy of the internal object.
    // =====================================
        
    pOurCopy->AddRef();
    *ppRefreshable = pOurCopy;
    *plId = LONG(dwIndex);

    return NO_ERROR;
}
    

//***************************************************************************
//
//  CNt5Refresher::StopRefreshing
//
//  Called whenever a user wants to remove an object from a refresher.
//     
//  Parameters:
//  <pRefresher>            The refresher object from which we are to 
//                          remove the perf object.
//  <lId>                   The ID of the object.
//  <lFlags>                Not used.
//  
//***************************************************************************        
// ok
        
HRESULT CNt5PerfProvider::StopRefreshing( 
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lId,
    /* [in] */ long lFlags
    )
{
    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
    // =========================================================
        
    CNt5Refresher *pOurRefresher = (CNt5Refresher *) pRefresher;

    pOurRefresher->RemoveObject(lId);

    return NO_ERROR;
}
    
//***************************************************************************
//
//  CNt5Refresher::CreateRefreshableEnum
//
//  Called whenever a user wants to create an enumeration in a refresher.
//     
//  Parameters:
//  <pNamespace>            The namespace this is for
//  <wszClass>              Name of the class we are enumerating
//  <pRefresher>            The refresher object from which we are to 
//                          remove the perf object.
//  <lFlags>                Not used.
//  <pContext>              Wbem Context object
//  <pHiPerfEnum>           Enumerator object into which refresher should place
//                          its results
//  <plId>                  The enum id (for identification during removal)
//  
//***************************************************************************        
// ok
HRESULT CNt5PerfProvider::CreateRefreshableEnum( 
    /* [in] */ IWbemServices* pNamespace,
    /* [in, string] */ LPCWSTR wszClass,
    /* [in] */ IWbemRefresher* pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext* pContext,
    /* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
    /* [out] */ long* plId )
{
    // Just a placeholder for now
    return E_NOTIMPL;
}

//***************************************************************************
//
//  CNt5Refresher::CreateRefreshableEnum
//
//  Called whenever a user wants to create an enumeration in a refresher.
//     
//  Parameters:
//  <pNamespace>            The namespace this is for
//  <lNumObjects>           Number of objects in the array
//  <apObj>                 Objects to retrieve (keys are set)
//  <lFlags>                Not used.
//  <pContext>              Wbem Context object
//  <pHiPerfEnum>           Enumerator object into which refresher should place
//                          its results
//  <plId>                  The enum id (for identification during removal)
//  
//***************************************************************************        
// ok
HRESULT CNt5PerfProvider::GetObjects( 
    /* [in] */ IWbemServices* pNamespace,
    /* [in] */ long lNumObjects,
    /* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext* pContext)
{
    // Just a placeholder for now
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ntperfshell\ntperf.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  NTPERF.H
//  
//  NT5 Perf Counter Provider
//
//  raymcc      02-Dec-97       
//
//***************************************************************************

#ifndef _NTPERF_H_
#define _NTPERF_H_

#define NUM_SAMPLE_INSTANCES   10

class CNt5PerfProvider;


class CNt5Refresher : public IWbemRefresher
{
    LONG m_lRef;

    IWbemObjectAccess *m_aInstances[NUM_SAMPLE_INSTANCES];

    LONG m_hName;
    LONG m_hCounter1;
    LONG m_hCounter2;
    LONG m_hCounter3;

public:
    CNt5Refresher();
   ~CNt5Refresher();

    void TransferPropHandles(CNt5PerfProvider *);

    BOOL AddObject(IWbemObjectAccess *pObj, LONG *plId);
    BOOL RemoveObject(LONG lId);

    // Interface members.
    // ==================

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);

    virtual HRESULT STDMETHODCALLTYPE Refresh(/* [in] */ long lFlags);
};


class CNt5PerfProvider : public IWbemHiPerfProvider, public IWbemProviderInit
{
    LONG m_lRef;
    IWbemClassObject  *m_pSampleClass;
    IWbemObjectAccess *m_aInstances[NUM_SAMPLE_INSTANCES];

    LONG m_hName;
    LONG m_hCounter1;
    LONG m_hCounter2;
    LONG m_hCounter3;

    friend class CNt5Refresher;
    
public:
    CNt5PerfProvider();
   ~CNt5PerfProvider();

    // Interface members.
    // ==================

        ULONG STDMETHODCALLTYPE AddRef();
        ULONG STDMETHODCALLTYPE Release();
        STDMETHODIMP QueryInterface(REFIID riid, void** ppv);


    // IWbemHiPerfProvider methods.
    // ============================
            
        virtual HRESULT STDMETHODCALLTYPE QueryInstances( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [string][in] */ WCHAR __RPC_FAR *wszClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateRefresher( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ long lFlags,
            /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateRefreshableObject( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
            /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pContext,
            /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
            /* [out] */ long __RPC_FAR *plId
            );
        
        virtual HRESULT STDMETHODCALLTYPE StopRefreshing( 
            /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
            /* [in] */ long lId,
            /* [in] */ long lFlags
            );

		virtual HRESULT STDMETHODCALLTYPE CreateRefreshableEnum(
			/* [in] */ IWbemServices* pNamespace,
			/* [in, string] */ LPCWSTR wszClass,
			/* [in] */ IWbemRefresher* pRefresher,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext* pContext,
			/* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
			/* [out] */ long* plId
			);

		virtual HRESULT STDMETHODCALLTYPE GetObjects(
            /* [in] */ IWbemServices* pNamespace,
			/* [in] */ long lNumObjects,
			/* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pContext);
		
        // IWbemProviderInit method.
        // =========================
            
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [unique][in] */ LPWSTR wszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR wszNamespace,
            /* [unique][in] */ LPWSTR wszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
            );
  
};

void ObjectCreated();
void ObjectDestroyed();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ntperfshell\server.cpp ===
//***************************************************************************
//
//  Copyright (c) 1996-2001, Microsoft Corporation, All rights reserved
//
//  SERVER.CPP
//
//  Generic COM server framework, adapted for the NT perf counter sample
//
//  This module contains nothing specific to the NT perf counter provider
//  except what is defined in the section bracketed by the CLSID SPECIFIC
//  comments below.
//
//  History:
//  raymcc        25-Nov-97     Created.
//  raymcc        18-Feb-98     Updated for NT5 Beta 2 version.
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <initguid.h>


/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

#include <wbemidl.h>
#include <wbemint.h>
#include <ntperf.h>


// {C93F65F2-BA02-11d1-AEB6-00C04FB68820}
DEFINE_GUID(CLSID_Nt5PerProvider_v1,
0xc93f65f2, 0xba02, 0x11d1, 0xae, 0xb6, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20);


#define IMPLEMENTED_CLSID           CLSID_Nt5PerProvider_v1
#define SERVER_REGISTRY_COMMENT     L"WBEM NT5 Base Perf Provider"
#define CPP_CLASS_NAME              CNt5PerfProvider
#define INTERFACE_CAST              (IWbemHiPerfProvider *)

//
//  END CLSID SPECIFIC SECTION
//
/////////////////////////////////////////////////////////////////////////////




HINSTANCE g_hInstance;
static ULONG g_cLock = 0;

void ObjectCreated()    { g_cLock++; }
void ObjectDestroyed() { g_cLock--; }


//***************************************************************************
//
//  class CFactory
//
//  Generic implementation of IClassFactory for CWbemLocator.
//
//***************************************************************************

class CFactory : public IClassFactory
{
    ULONG           m_cRef;
    CLSID           m_ClsId;

public:
    CFactory(const CLSID & ClsId);
    ~CFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
};




//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hinstDLL;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
    }

    return TRUE;
}



//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CFactory *pFactory;

    //
    //  Verify the caller is asking for our type of object.
    //
    if (IMPLEMENTED_CLSID != rclsid) 
            return ResultFromScode(E_FAIL);

    //
    // Check that we can provide the interface.
    //
    if (IID_IUnknown != riid && IID_IClassFactory != riid)
        return ResultFromScode(E_NOINTERFACE);

    //
    // Get a new class factory.
    //
    pFactory = new CFactory(rclsid);

    if (!pFactory)
        return ResultFromScode(E_OUTOFMEMORY);

    //
    // Verify we can get an instance.
    //
    HRESULT hRes = pFactory->QueryInterface(riid, ppv);

    if (FAILED(hRes))
        delete pFactory;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllCanUnloadNow(void)
{
    SCODE sc = TRUE;

    if (g_cLock)
        sc = S_FALSE;

    return sc;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    // Where are we?
    // =============
    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    // ========================

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    // ==============================================================

    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, "InprocServer32", &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    // =============================
    LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    // Delete CLSID GUID key.
    // ======================

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}




//***************************************************************************
//
//  CFactory::CFactory
//
//  Constructs the class factory given the CLSID of the objects it is supposed
//  to create.
//
//  PARAMETERS:
//
//      const CLSID & ClsId     The CLSID. 
//
//***************************************************************************
CFactory::CFactory(const CLSID & ClsId)
{
    m_cRef = 0;
    ObjectCreated();
    m_ClsId = ClsId;
}

//***************************************************************************
//
//  CFactory::~CFactory
//
//  Destructor.
//
//***************************************************************************
CFactory::~CFactory()
{
    ObjectDestroyed();
}

//***************************************************************************
//
//  CFactory::QueryInterface, AddRef and Release
//
//  Standard IUnknown methods.
//
//***************************************************************************
STDMETHODIMP CFactory::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


ULONG CFactory::AddRef()
{
    return ++m_cRef;
}


ULONG CFactory::Release()
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  CFactory::CreateInstance
//
//  PARAMETERS:
//
//      LPUNKNOWN pUnkOuter     IUnknown of the aggregator. Must be NULL.
//      REFIID riid             Interface ID required.
//      LPVOID * ppvObj         Destination for the interface pointer.
//
//  RETURN VALUES:
//
//      S_OK                        Success
//      CLASS_E_NOAGGREGATION       pUnkOuter must be NULL
//      E_NOINTERFACE               No such interface supported.
//      
//***************************************************************************

STDMETHODIMP CFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj)
{
    IUnknown* pObj;
    HRESULT  hr;

    //
    //  Defaults
    //
    *ppvObj=NULL;
    hr = ResultFromScode(E_OUTOFMEMORY);

    //
    // We aren't supporting aggregation.
    //
    if (pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    if (m_ClsId == IMPLEMENTED_CLSID)
    {
        pObj = INTERFACE_CAST new CPP_CLASS_NAME;
    }

    if (!pObj)
        return hr;

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //
    hr = pObj->QueryInterface(riid, ppvObj);

    //
    // Kill the object if initial creation or Init failed.
    //
    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  CFactory::LockServer
//
//  Increments or decrements the lock count of the server. The DLL will not
//  unload while the lock count is positive.
//
//  PARAMETERS:
//
//      BOOL fLock      If TRUE, locks; otherwise, unlocks.
//
//  RETURN VALUES:
//
//      S_OK
//
//***************************************************************************
STDMETHODIMP CFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *) &g_cLock);
    else
        InterlockedDecrement((LONG *) &g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\common\makefile.inc ===
!include $(_NTDRIVE)$(_NTROOT)\ADMIN\WMI\WBEM\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\common\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Precomp.h

Abstract:


History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
#include <ntpsapi.h>
#include <ntexapi.h>

#define _WINNT_	// have what is needed from above

#include <ole2.h>
#include <windows.h>

#include <corepol.h>

#ifdef USE_POLARITY
    #ifdef BUILDING_DLL
        #define COREPROX_POLARITY __declspec( dllexport )
    #else 
       #define COREPROX_POLARITY __declspec( dllimport )
    #endif
#else
    #define COREPROX_POLARITY
#endif
#include <strsafe.h>
#include <strutils.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\common\datetime.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  DATETIME.CPP
//
//  alanbos  20-Jan-00   Created.
//
//  Defines the implementation of ISWbemDateTime
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <sys/timeb.h>
#include <math.h>
#include <time.h> 
#include <float.h>
#include <wbemint.h>
#include "DateTime.h"


#define ISWILD(c)		(L'*' == c)
#define ISINTERVAL(c)	(L':' == c)
#define ISMINUS(c)		(L'-' == c)
#define ISPLUS(c)		(L'+' == c)
#define	ISDOT(c)		(L'.' == c)

#define	WILD2			L"**"
#define	WILD3			L"***"
#define	WILD4			L"****"
#define	WILD6			L"******"

#define ASSERT_BREAK 

//***************************************************************************
//
//  CWbemDateTime::CWbemDateTime
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CWbemDateTime::CWbemDateTime() :
		m_bYearSpecified (VARIANT_TRUE),
		m_bMonthSpecified (VARIANT_TRUE),
		m_bDaySpecified (VARIANT_TRUE),
		m_bHoursSpecified (VARIANT_TRUE),
		m_bMinutesSpecified (VARIANT_TRUE),
		m_bSecondsSpecified (VARIANT_TRUE),
		m_bMicrosecondsSpecified (VARIANT_TRUE),
		m_bUTCSpecified (VARIANT_TRUE),
		m_bIsInterval (VARIANT_FALSE),
		m_iYear (0),
		m_iMonth (1),
		m_iDay (1),
		m_iHours (0),
		m_iMinutes (0),
		m_iSeconds (0),
		m_iMicroseconds (0),
		m_iUTC (0)
{
}

//***************************************************************************
//
//  CWbemDateTime::~CWbemDateTime
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CWbemDateTime::~CWbemDateTime(void)
{
}

// These are here rather than wbemtime.h so we don't have to doc/support
#define INVALID_TIME_ARITHMETIC 0
#define BAD_TIMEZONE 0

static int CompareSYSTEMTIME(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2)
{
    FILETIME ft1, ft2;

    SystemTimeToFileTime(pst1, &ft1);
    SystemTimeToFileTime(pst2, &ft2);

    return CompareFileTime(&ft1, &ft2);
}

//***************************************************************************
//
//  SCODE CWbemDateTime::get_Value
//
//  DESCRIPTION:
//
//  Retrieve the DMTF datetime value
//
//  PARAMETERS:
//
//		pbsValue		pointer to BSTR to hold value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
HRESULT CWbemDateTime :: GetValue ( BSTR *pbsValue) 
{
	HRESULT hr = WBEM_E_FAILED;

	if (NULL == pbsValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		wchar_t	dmtfValue [WBEMDT_DMTF_LEN + 1];
		int dmtfLength = sizeof dmtfValue / sizeof dmtfValue[0];
		dmtfValue [WBEMDT_DMTF_LEN] = NULL;

		if (m_bIsInterval)
		{
			// Intervals are easy
			hr = StringCchPrintf (dmtfValue, dmtfLength , L"%08d%02d%02d%02d.%06d:000", m_iDay, 
						m_iHours, m_iMinutes, m_iSeconds, m_iMicroseconds);
		}
		else
		{
			if (m_bYearSpecified)
				hr = StringCchPrintf(dmtfValue, dmtfLength , L"%04d", m_iYear);
			else
				hr = StringCchCopyW (dmtfValue, dmtfLength, WILD4);

			if (m_bMonthSpecified)
				hr = StringCchPrintf (dmtfValue + 4, dmtfLength-4, L"%02d", m_iMonth);
			else
				hr = StringCchCatW (dmtfValue + 4, dmtfLength-4, WILD2);

			if (m_bDaySpecified)
				hr = StringCchPrintf (dmtfValue + 6, dmtfLength-6, L"%02d", m_iDay);
			else
				hr = StringCchCatW (dmtfValue + 6, dmtfLength-6, WILD2);

			if (m_bHoursSpecified)
				hr = StringCchPrintf (dmtfValue + 8, dmtfLength-8, L"%02d", m_iHours);
			else
				hr = StringCchCatW (dmtfValue + 8, dmtfLength-8, WILD2);

			if (m_bMinutesSpecified)
				hr = StringCchPrintf (dmtfValue + 10, dmtfLength - 10, L"%02d", m_iMinutes);
			else
				hr = StringCchCatW (dmtfValue + 10, dmtfLength-10, WILD2);

			if (m_bSecondsSpecified)
				hr = StringCchPrintf (dmtfValue + 12, dmtfLength-12, L"%02d.", m_iSeconds);
			else
			{
				hr = StringCchCatW (dmtfValue + 12, dmtfLength-12, WILD2);
				hr = StringCchCatW (dmtfValue + 14, dmtfLength-14, L".");
			}

			if (m_bMicrosecondsSpecified)
				hr = StringCchPrintf (dmtfValue + 15, dmtfLength - 15, L"%06d", m_iMicroseconds);
			else
				hr = StringCchCatW (dmtfValue + 15, dmtfLength-15, WILD6);

			if (m_bUTCSpecified)
				hr = StringCchPrintf (dmtfValue + 21, dmtfLength-21, L"%C%03d", (0 <= m_iUTC) ? L'+' : L'-', 
							(0 <= m_iUTC) ? m_iUTC : -m_iUTC);
			else
			{
				hr = StringCchCatW (dmtfValue + 21, dmtfLength-21, L"+");
				hr = StringCchCatW (dmtfValue + 22, dmtfLength-22, WILD3);
			}
		}
		if (SUCCEEDED(hr))
		{
			*pbsValue = SysAllocString (dmtfValue);
			if ( *pbsValue == NULL )
			{
				hr = WBEM_E_OUT_OF_MEMORY ;
			}
			else
			{
				hr = WBEM_S_NO_ERROR;
			}
		}
	}
	return hr;
}


//***************************************************************************
//
//  SCODE CWbemDateTime::put_Value
//
//  DESCRIPTION:
//
//  Retrieve the DMTF datetime value
//
//  PARAMETERS:
//
//		bsValue		new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemDateTime::PutValue( BSTR bsValue) 
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;

	// First check that the value is the right length
	if (bsValue && (WBEMDT_DMTF_LEN == wcslen (bsValue)))
	{
		bool err = false;
		long iYear = 0, iMonth = 1, iDay = 1, iHours = 0, iMinutes = 0, 
		iSeconds = 0, iMicroseconds = 0, iUTC = 0;
		VARIANT_BOOL bYearSpecified = VARIANT_TRUE, 
		bMonthSpecified = VARIANT_TRUE, 
		bDaySpecified = VARIANT_TRUE, 
		bHoursSpecified = VARIANT_TRUE, 
		bMinutesSpecified = VARIANT_TRUE, 
		bSecondsSpecified = VARIANT_TRUE, 
		bMicrosecondsSpecified = VARIANT_TRUE, 
		bUTCSpecified = VARIANT_TRUE, 
		bIsInterval = VARIANT_TRUE;

		LPWSTR pValue = (LPWSTR) bsValue;
		
		// Check whether its an interval
		if (ISINTERVAL(pValue [WBEMDT_DMTF_UPOS]))
		{
			// Years and months are as nothing to us in interval land
			bYearSpecified = VARIANT_FALSE;
			bMonthSpecified = VARIANT_FALSE;

			// Check that everything is a digit apart from
			// the interval separator
			for (int i = 0; i < WBEMDT_DMTF_LEN; i++)
			{
				if ((WBEMDT_DMTF_UPOS != i) && 
					(WBEMDT_DMTF_SPOS != i) && !wbem_iswdigit (pValue [i]))
				{
					err = true;
					break;
				}
			}

			if (!err)
			{
				// Now check all is within bounds
				err = !(CheckField (pValue, 8, bDaySpecified, iDay, WBEMDT_MAX_DAYINT, WBEMDT_MIN_DAYINT) &&
					(VARIANT_TRUE == bDaySpecified) &&
					CheckField (pValue+8, 2, bHoursSpecified, iHours, WBEMDT_MAX_HOURS, WBEMDT_MIN_HOURS) &&
					(VARIANT_TRUE == bHoursSpecified) &&
					CheckField (pValue+10, 2, bMinutesSpecified, iMinutes, WBEMDT_MAX_MINUTES, WBEMDT_MIN_MINUTES) &&
					(VARIANT_TRUE == bMinutesSpecified) &&
					CheckField (pValue+12, 2, bSecondsSpecified, iSeconds, WBEMDT_MAX_SECONDS, WBEMDT_MIN_SECONDS) &&
					(VARIANT_TRUE == bSecondsSpecified) &&
					(ISDOT(pValue [WBEMDT_DMTF_SPOS])) &&
					CheckField (pValue+15, 6, bMicrosecondsSpecified, iMicroseconds, WBEMDT_MAX_MICROSEC, WBEMDT_MIN_MICROSEC) &&
					(VARIANT_TRUE == bMicrosecondsSpecified) &&
					CheckUTC (pValue+21, bUTCSpecified, iUTC, false));
				
			}
		}
		else
		{
			// assume it's a datetime
			bIsInterval = VARIANT_FALSE;

			err = !(CheckField (pValue, 4, bYearSpecified, iYear, WBEMDT_MAX_YEAR, WBEMDT_MIN_YEAR) &&
				CheckField (pValue+4, 2, bMonthSpecified, iMonth, WBEMDT_MAX_MONTH, WBEMDT_MIN_MONTH) &&
				CheckField (pValue+6, 2, bDaySpecified, iDay, WBEMDT_MAX_DAY, WBEMDT_MIN_DAY) &&
				CheckField (pValue+8, 2, bHoursSpecified, iHours, WBEMDT_MAX_HOURS, WBEMDT_MIN_HOURS) &&
				CheckField (pValue+10, 2, bMinutesSpecified, iMinutes, WBEMDT_MAX_MINUTES, WBEMDT_MIN_MINUTES) &&
				CheckField (pValue+12, 2, bSecondsSpecified, iSeconds, WBEMDT_MAX_SECONDS, WBEMDT_MIN_SECONDS) &&
				(ISDOT(pValue [WBEMDT_DMTF_SPOS])) &&
				CheckField (pValue+15, 6, bMicrosecondsSpecified, iMicroseconds, WBEMDT_MAX_MICROSEC, WBEMDT_MIN_MICROSEC) &&
				CheckUTC (pValue+21, bUTCSpecified, iUTC));
		}

		if (!err)
		{
			m_iYear = iYear;
			m_iMonth = iMonth;
			m_iDay = iDay;
			m_iHours = iHours;
			m_iMinutes = iMinutes;
			m_iSeconds = iSeconds;
			m_iMicroseconds = iMicroseconds;
			m_iUTC = iUTC;
			m_bYearSpecified = bYearSpecified;
			m_bMonthSpecified = bMonthSpecified;
			m_bDaySpecified = bDaySpecified;
			m_bHoursSpecified = bHoursSpecified;
			m_bMinutesSpecified = bMinutesSpecified;
			m_bSecondsSpecified = bSecondsSpecified;
			m_bMicrosecondsSpecified = bMicrosecondsSpecified;
			m_bUTCSpecified = bUTCSpecified;
			m_bIsInterval = bIsInterval;
			hr = S_OK;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemDateTime::CheckField
//
//  DESCRIPTION:
//
//  Check a string-based datetime field for correctness
//
//  PARAMETERS:
//
//		pValue			pointer to the value to check
//		len				number of characters in the value
//		bIsSpecified	on return defines whether value is wildcard
//		iValue			on return specifies integer value (if not wildcard)
//		maxValue		maximum numeric value allowed for this field
//		minValue		minimum numeric value allowed for this field
//
//  RETURN VALUES:
//
//		true if value parsed ok, false otherwise
//
//***************************************************************************
bool CWbemDateTime::CheckField (
		LPWSTR			pValue,
		ULONG			len,
		VARIANT_BOOL	&bIsSpecified,
		long			&iValue,
		long			maxValue,
		long			minValue
	)
{
	bool status = true;
	bIsSpecified = VARIANT_FALSE;

	for (ULONG i = 0; i < len; i++)
	{
		if (ISWILD(pValue [i]))
		{
			if (VARIANT_TRUE == bIsSpecified)
			{
				status = false;
				break;
			}
		}
		else if (!wbem_iswdigit (pValue [i]))
		{
			status = false;
			break;
		}
		else
			bIsSpecified = VARIANT_TRUE;
	}

	if (status)
	{
		if (VARIANT_TRUE == bIsSpecified)
		{
			wchar_t *dummy = NULL;
			wchar_t temp [ 12 ] ;
			
			if ( len > ( ( sizeof ( temp ) / sizeof ( wchar_t ) ) - 1 ) )
			{
				return false ;
			}

			if ( FAILED ( StringCchCopyNW ( temp , ( sizeof ( temp ) / sizeof ( wchar_t ) ) , pValue, len ) ) )
			{
				return false ;
			}

			temp [ len ] = NULL ;

			iValue = wcstol ( temp , &dummy , 10 ) ;
		}
	}
	
	return status;
}

//***************************************************************************
//
//  SCODE CWbemDateTime::CheckUTC
//
//  DESCRIPTION:
//
//  Check a string-based UTC field for correctness
//
//  PARAMETERS:
//
//		pValue			pointer to the value to check
//		bIsSpecified	on return defines whether value is wildcard
//		iValue			on return specifies integer value (if not wildcard)
//		bParseSign		whether first character should be a sign (+/-) or
//						a : (for intervals)
//
//  RETURN VALUES:
//
//		true if value parsed ok, false otherwise
//
//***************************************************************************
bool CWbemDateTime::CheckUTC (
		LPWSTR			pValue,
		VARIANT_BOOL	&bIsSpecified,
		long			&iValue,
		bool			bParseSign
	)
{
	bool status = true;
	bool lessThanZero = false;
	bIsSpecified = VARIANT_FALSE;

	// Check if we have a signed offset
	if (bParseSign)
	{
		if (ISMINUS(pValue [0]))
			lessThanZero = true;
		else if (!ISPLUS(pValue [0]))
			status = false;
	}
	else
	{
		if (!ISINTERVAL(pValue[0]))
			status = false;
	}

	if (status)
	{
		// Check remaining are digits or wildcars
		for (int i = 1; i < 4; i++)
		{
			if (ISWILD(pValue [i]))
			{
				if (VARIANT_TRUE == bIsSpecified)
				{
					status = false;
					break;
				}
			}
			else if (!wbem_iswdigit (pValue [i]))
			{
				status = false;
				break;
			}
			else
				bIsSpecified = VARIANT_TRUE;
		}
	}

	if (status)
	{
		if (VARIANT_TRUE == bIsSpecified)
		{
			wchar_t *dummy = NULL;
			wchar_t temp [4];
			
			wcsncpy (temp, pValue+1, 3);
			temp [3] = NULL;
			iValue = wcstol (temp, &dummy, 10);

			if (lessThanZero)
				iValue = -iValue;
		}
	}
	
	return status;
}

BOOL CWbemDateTime::Preceeds ( CWbemDateTime &a_Time )
{
	BOOL t_Truth = TRUE ;

	SYSTEMTIME t_ThisTime ;
	t_ThisTime.wYear = ( WORD ) m_iYear;
	t_ThisTime.wMonth = ( WORD ) m_iMonth;
	t_ThisTime.wDay = ( WORD ) m_iDay;
	t_ThisTime.wHour = ( WORD ) m_iHours;
	t_ThisTime.wMinute = ( WORD ) m_iMinutes;
	t_ThisTime.wSecond = ( WORD ) m_iSeconds;
	t_ThisTime.wMilliseconds = ( WORD ) ( m_iMicroseconds/1000 ) ;
		
	SYSTEMTIME t_ArgTime ;
	t_ArgTime.wYear = ( WORD ) a_Time.m_iYear;
	t_ArgTime.wMonth = ( WORD ) a_Time.m_iMonth;
	t_ArgTime.wDay = ( WORD ) a_Time.m_iDay;
	t_ArgTime.wHour = ( WORD ) a_Time.m_iHours;
	t_ArgTime.wMinute = ( WORD ) a_Time.m_iMinutes;
	t_ArgTime.wSecond = ( WORD ) a_Time.m_iSeconds;
	t_ArgTime.wMilliseconds = ( WORD ) ( a_Time.m_iMicroseconds/1000 ) ;

	t_Truth = CompareSYSTEMTIME ( & t_ThisTime , & t_ArgTime ) < 0 ;

	return t_Truth ;
}

HRESULT CWbemDateTime::GetSystemTimeDate (

	SYSTEMTIME &fSystemTime
)
{
	ZeroMemory ( & fSystemTime , sizeof ( fSystemTime ) ) ;

	fSystemTime.wYear = ( WORD ) m_iYear;
	fSystemTime.wMonth = ( WORD ) m_iMonth;
	fSystemTime.wDay = ( WORD ) m_iDay;
	fSystemTime.wHour = ( WORD ) m_iHours;
	fSystemTime.wMinute = ( WORD ) m_iMinutes;
	fSystemTime.wSecond = ( WORD ) m_iSeconds;
	fSystemTime.wMilliseconds = ( WORD ) ( m_iMicroseconds/1000 ) ;

	return S_OK ;
}

HRESULT CWbemDateTime::GetFileTimeDate (

	FILETIME &fFileTime
)
{
	SYSTEMTIME fSystemTime ;
	ZeroMemory ( & fSystemTime , sizeof ( fSystemTime ) ) ;

	fSystemTime.wYear = ( WORD ) m_iYear;
	fSystemTime.wMonth = ( WORD ) m_iMonth;
	fSystemTime.wDay = ( WORD ) m_iDay;
	fSystemTime.wHour = ( WORD ) m_iHours;
	fSystemTime.wMinute = ( WORD ) m_iMinutes;
	fSystemTime.wSecond = ( WORD ) m_iSeconds;
	fSystemTime.wMilliseconds = ( WORD ) ( m_iMicroseconds/1000 ) ;

	if ( FileTimeToSystemTime ( & fFileTime , & fSystemTime ) ) 
	{
		return S_OK ;
	}
	else
	{
		return WBEM_E_FAILED ;
	}
}

static void FileTimeToui64(const FILETIME *pft, ULONGLONG *p64)
{
    *p64 = pft->dwHighDateTime;
    *p64 = *p64 << 32;
    *p64 |=  pft->dwLowDateTime;
}


static void ui64ToFileTime(const ULONGLONG *p64,FILETIME *pft)
{
    unsigned __int64 uTemp = *p64;
    pft->dwLowDateTime = (DWORD)uTemp;
    uTemp = uTemp >> 32;
    pft->dwHighDateTime = (DWORD)uTemp; 
}

static void DayInMonthToAbsolute(SYSTEMTIME *pst, const WORD wYear)
{
    const static int _lpdays[] = {
        -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
    };
    
    const static int _days[] = {
        -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
    };
    
    SHORT shYearDay;
    
    // If this is not 0, this is not a relative date
    if (pst->wYear == 0)
    {
        // Was that year a leap year?
        BOOL bLeap =  ( (( wYear % 400) == 0) || ((( wYear % 4) == 0) && (( wYear % 100) != 0)));
        
        // Figure out the day of the year for the first day of the month in question
        if (bLeap)
            shYearDay = 1 + _lpdays[pst->wMonth - 1];
        else
            shYearDay = 1 + _days[pst->wMonth - 1];
        
        // Now, figure out how many leap days there have been since 1/1/1601
        WORD yc = wYear - 1601;
        WORD y4 = (yc) / 4;
        WORD y100 = (yc) / 100;
        WORD y400 = (yc) / 400;
        
        // This will tell us the day of the week for the first day of the month in question.
        // The '1 +' reflects the fact that 1/1/1601 was a monday (figures).  You might ask,
        // 'why do we care what day of the week this is?'  Well, I'll tell you.  The way
        // daylight savings time is defined is with things like 'the last sunday of the month
        // of october.'  Kinda helps to know what day that is.
        SHORT monthdow = (1 + (yc * 365 + y4 + y400 - y100) + shYearDay) % 7;
        
        if ( monthdow < pst->wDayOfWeek )
            shYearDay += (pst->wDayOfWeek - monthdow) + (pst->wDay - 1) * 7;
        else
            shYearDay += (pst->wDayOfWeek - monthdow) + pst->wDay * 7;
        
            /*
            * May have to adjust the calculation above if week == 5 (meaning
            * the last instance of the day in the month). Check if yearday falls
            * beyond month and adjust accordingly.
        */
        if ( (pst->wDay == 5) &&
            (shYearDay > (bLeap ? _lpdays[pst->wMonth] :
        _days[pst->wMonth])) )
        {
            shYearDay -= 7;
        }

        // Now update the structure.
        pst->wYear = wYear;
        pst->wDay = shYearDay - (bLeap ? _lpdays[pst->wMonth - 1] :
        _days[pst->wMonth - 1]);
    }
}

CWbemDateTime::WBEMTime :: WBEMTime ( const FILETIME &ft )	
{
	FileTimeToui64(&ft, &m_uTime);
}

CWbemDateTime::WBEMTime CWbemDateTime::WBEMTime::operator+(const WBEMTimeSpan &uAdd) const
{
    WBEMTime ret;

    if (IsOk())
    {
        ret.m_uTime = m_uTime + uAdd.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

CWbemDateTime::WBEMTime CWbemDateTime::WBEMTime::operator-(const WBEMTimeSpan & sub) const
{
    WBEMTime ret;

    if (IsOk() && (m_uTime >= sub.m_Time))
    {
        ret.m_uTime = m_uTime - sub.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

BOOL CWbemDateTime::WBEMTime::GetFILETIME(FILETIME * pft) const
{
	if ((pft == NULL) || (!IsOk()))
	{
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
		return FALSE;
	}

	ui64ToFileTime(&m_uTime, pft);

    return TRUE;
}

LONG CWbemDateTime::WBEMTime::GetLocalOffsetForDate(const SYSTEMTIME *pst)
{
    TIME_ZONE_INFORMATION tzTime;
    DWORD dwRes = GetTimeZoneInformation(&tzTime);
    LONG lRes = 0xffffffff;

    switch (dwRes)
    {
    case TIME_ZONE_ID_UNKNOWN:
        {
            // Read tz, but no dst defined in this zone
            lRes = tzTime.Bias * -1;
            break;
        }
    case TIME_ZONE_ID_STANDARD:
    case TIME_ZONE_ID_DAYLIGHT:
        {

            // Convert the relative dates to absolute dates
            DayInMonthToAbsolute(&tzTime.DaylightDate, pst->wYear);
            DayInMonthToAbsolute(&tzTime.StandardDate, pst->wYear);

            if ( CompareSYSTEMTIME(&tzTime.DaylightDate, &tzTime.StandardDate) < 0 ) 
            {
                /*
                 * Northern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.DaylightDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.StandardDate) > 0)
                {
                    lRes = tzTime.Bias * -1;
                }
                else
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
            }
            else 
            {
                /*
                 * Southern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.StandardDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.DaylightDate) > 0)
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
                else
                {
                    lRes = tzTime.Bias * -1;
                }
            }

            break;

        }
    case TIME_ZONE_ID_INVALID:
    default:
        {
            // Can't read the timezone info
            ASSERT_BREAK(BAD_TIMEZONE);
            break;
        }
    }

    return lRes;
}

BOOL CWbemDateTime::WBEMTime::GetDMTF(SYSTEMTIME &st, long &offset) const
{
    if (!IsOk())
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    // If the date to be converted is within 12 hours of
    // 1/1/1601, return the greenwich time
	ULONGLONG t_ConversionZone = 12L * 60L * 60L ;
	t_ConversionZone = t_ConversionZone * 10000000L ;

	if ( m_uTime < t_ConversionZone ) 
	{
		if(!GetSYSTEMTIME(&st))
			return FALSE;
	}
	else
	{
		if (GetSYSTEMTIME(&st))
		{
            offset = GetLocalOffsetForDate(&st);

            WBEMTime wt;
            if (offset >= 0)
               wt = *this - WBEMTimeSpan(offset);
            else
               wt = *this + WBEMTimeSpan(-offset);
            wt.GetSYSTEMTIME(&st);
		}
		else
			return FALSE;
	}

	return TRUE ;
}

BOOL CWbemDateTime::WBEMTime::GetSYSTEMTIME(SYSTEMTIME * pst) const
{
	if ((pst == NULL) || (!IsOk()))
	{
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
		return FALSE;
	}

	FILETIME t_ft;

	if (GetFILETIME(&t_ft))
	{
		if (!FileTimeToSystemTime(&t_ft, pst))
		{
            ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

    return TRUE;
}

//***************************************************************************
//
//  SCODE CWbemDateTime::SetVarDate
//
//  DESCRIPTION:
//
//  Set the value in Variant form 
//
//  PARAMETERS:
//
//		dVarDate		the new value
//		bIsLocal		whether to treat as local or UTC value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//
//***************************************************************************
HRESULT CWbemDateTime::SetFileTimeDate( 

        /*[in]*/ FILETIME fFileTime,
		/*[in, optional]*/ VARIANT_BOOL bIsLocal) 
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;

	SYSTEMTIME	sysTime;
	
	long offset = 0;

	if (VARIANT_TRUE == bIsLocal)
	{
		WBEMTime wbemTime (fFileTime);
		if (!wbemTime.GetDMTF (sysTime, offset))
			return WBEM_E_INVALID_SYNTAX;
	}
	else
	{
		WBEMTime wbemTime (fFileTime);
		wbemTime.GetSYSTEMTIME(&sysTime);
	}

	m_iYear = sysTime.wYear;
	m_iMonth = sysTime.wMonth;
	m_iDay = sysTime.wDay;
	m_iHours = sysTime.wHour;
	m_iMinutes = sysTime.wMinute;
	m_iSeconds = sysTime.wSecond;
	m_iMicroseconds = sysTime.wMilliseconds * 1000;
	m_iUTC = offset;

	m_bYearSpecified = VARIANT_TRUE,	
	m_bMonthSpecified = VARIANT_TRUE, 
	m_bDaySpecified = VARIANT_TRUE, 
	m_bHoursSpecified = VARIANT_TRUE, 
	m_bMinutesSpecified = VARIANT_TRUE, 
	m_bSecondsSpecified = VARIANT_TRUE, 
	m_bMicrosecondsSpecified = VARIANT_TRUE, 
	m_bUTCSpecified = VARIANT_TRUE, 
	m_bIsInterval = VARIANT_FALSE;			

	hr = S_OK;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\common\cglobals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <windows.h>
#include <objbase.h>
#include <sddl.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemcli.h>
#include <wbemint.h>
#include <winntsec.h>
#include <wbemcomn.h>
#include <callsec.h>
#include <cominit.h>

#include <BasicTree.h>
#include <Thread.h>
#include <Logging.h>
#include <PSSException.h>
#include <Cache.h>

#include "DateTime.h"
#include "CGlobals.h"

#include <Allocator.cpp>
#include <HelperFuncs.cpp>
#include <Logging.cpp>

#include <Cache.cpp>

#include <CallSec.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LPCWSTR ProviderSubSystem_Common_Globals :: s_Wql = L"Wql" ;
LPCWSTR ProviderSubSystem_Common_Globals :: s_Provider = L"Provider" ;

WORD ProviderSubSystem_Common_Globals :: s_System_ACESize = 0 ;
WORD ProviderSubSystem_Common_Globals :: s_LocalService_ACESize = 0 ;
WORD ProviderSubSystem_Common_Globals :: s_NetworkService_ACESize = 0 ;
WORD ProviderSubSystem_Common_Globals :: s_LocalAdmins_ACESize = 0 ;

ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Provider_System_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Provider_LocalService_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Provider_NetworkService_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Provider_LocalAdmins_ACE = NULL ;

ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Token_All_Access_System_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Token_All_Access_LocalService_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Token_All_Access_NetworkService_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Token_All_Access_LocalAdmins_ACE = NULL ;

SECURITY_DESCRIPTOR *ProviderSubSystem_Common_Globals :: s_MethodSecurityDescriptor = NULL ;
SECURITY_DESCRIPTOR *ProviderSubSystem_Common_Globals :: s_DefaultDecoupledSD = NULL ;
ULONG ProviderSubSystem_Common_Globals :: s_TransmitBufferSize = SYNCPROV_BATCH_TRANSMIT_SIZE ;
ULONG ProviderSubSystem_Common_Globals :: s_DefaultStackSize = 0 ;



wchar_t * DupString(const wchar_t * src)
{
	wchar_t * dest = 0;
	size_t len = wcslen(src);
	dest = new wchar_t[len+1];
	if (dest) memcpy(dest,src, (len+1)*sizeof(wchar_t));
	return dest;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CreateInstance ( 

	const CLSID &a_ReferenceClsid ,
	LPUNKNOWN a_OuterUnknown ,
	const DWORD &a_ClassContext ,
	const UUID &a_ReferenceInterfaceId ,
	void **a_ObjectInterface
)
{
	HRESULT t_Result = S_OK ;

	COAUTHINFO t_AuthenticationInfo ;
	ZeroMemory ( & t_AuthenticationInfo , sizeof ( t_AuthenticationInfo ) ) ;

    t_AuthenticationInfo.dwAuthnSvc = RPC_C_AUTHN_DEFAULT ;
    t_AuthenticationInfo.dwAuthzSvc = RPC_C_AUTHZ_DEFAULT ;
    t_AuthenticationInfo.pwszServerPrincName = NULL ;
    t_AuthenticationInfo.dwAuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT ;
    t_AuthenticationInfo.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE  ;
    t_AuthenticationInfo.dwCapabilities = EOAC_NONE ;
    t_AuthenticationInfo.pAuthIdentityData = NULL ;

	COSERVERINFO t_ServerInfo ;
	ZeroMemory ( & t_ServerInfo , sizeof ( t_ServerInfo ) ) ;

	t_ServerInfo.pwszName = NULL ;
    t_ServerInfo.dwReserved2 = 0 ;
    t_ServerInfo.pAuthInfo = & t_AuthenticationInfo ;

	IClassFactory *t_ClassFactory = NULL ;

	t_Result = CoGetClassObject (

		a_ReferenceClsid ,
		a_ClassContext ,
		& t_ServerInfo ,
		IID_IClassFactory ,
		( void ** )  & t_ClassFactory
	) ;
 
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_ClassFactory->CreateInstance (

			a_OuterUnknown ,
			a_ReferenceInterfaceId ,
			a_ObjectInterface 
		);	

		t_ClassFactory->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetNamespaceServerPath (

	IWbemPath *a_Namespace ,
	wchar_t *&a_ServerNamespacePath
)
{
	a_ServerNamespacePath = NULL ;

	wchar_t *t_Server = NULL ;
	ULONG t_ServerLength = 0 ;

	HRESULT t_Result = a_Namespace->GetServer (

		& t_ServerLength , 
		t_Server
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Server = new wchar_t [ t_ServerLength + 1 ] ;

		if (NULL != t_Server)
		{
			t_Result = a_Namespace->GetServer (

				& t_ServerLength , 
				t_Server
			) ;
		}
		else
		{
		    t_Result = WBEM_E_OUT_OF_MEMORY;
		}

		if ( FAILED ( t_Result ) )
		{
			delete [] t_Server ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_NAMESPACE ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		wchar_t *t_ConcatString = NULL ;

		WmiStatusCode t_StatusCode = WmiHelper :: ConcatenateStrings_Wchar ( 

			2 , 
			& t_ConcatString ,
			L"\\\\" ,
			t_Server
		) ;

		delete [] t_Server ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			a_ServerNamespacePath = t_ConcatString ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		ULONG t_NamespaceCount = 0 ;

        t_Result = a_Namespace->GetNamespaceCount (

            & t_NamespaceCount 
		) ;

		if ( t_NamespaceCount )
		{
			for ( ULONG t_Index = 0 ; t_Index < t_NamespaceCount ; t_Index ++ )
			{
				wchar_t *t_Namespace = NULL ;
				ULONG t_NamespaceLength = 0 ;

    			t_Result = a_Namespace->GetNamespaceAt (

					t_Index ,
					& t_NamespaceLength ,
					t_Namespace 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Namespace = new wchar_t [ t_NamespaceLength + 1 ] ;

					if (0 != t_Namespace) 
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
						break;
					}

    				t_Result = a_Namespace->GetNamespaceAt (

						t_Index ,
						& t_NamespaceLength ,
						t_Namespace 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						wchar_t *t_ConcatString = NULL ;

						WmiStatusCode t_StatusCode = WmiHelper :: ConcatenateStrings_Wchar ( 

							3 , 
							& t_ConcatString ,
							a_ServerNamespacePath ,
							L"\\" ,
							t_Namespace
						) ;

						delete [] t_Namespace ;

						if ( t_StatusCode == e_StatusCode_Success )
						{
							delete [] a_ServerNamespacePath ;
							a_ServerNamespacePath = t_ConcatString ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
							break;
						}
					}
					else
					{
                                                delete [] t_Namespace ;
						t_Result = WBEM_E_CRITICAL_ERROR ;
						break ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_NAMESPACE ;
		}
	}

	if ( FAILED ( t_Result ) ) 
	{
		delete [] a_ServerNamespacePath ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetNamespacePath (

	IWbemPath *a_Namespace ,
	wchar_t *&a_NamespacePath
)
{
	a_NamespacePath = NULL ;

	ULONG t_NamespaceCount = 0 ;

    HRESULT t_Result = a_Namespace->GetNamespaceCount (

        & t_NamespaceCount 
	) ;

	if ( t_NamespaceCount )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_NamespaceCount ; t_Index ++ )
		{
			wchar_t *t_Namespace = NULL ;
			ULONG t_NamespaceLength = 0 ;

    		t_Result = a_Namespace->GetNamespaceAt (

				t_Index ,
				& t_NamespaceLength ,
				t_Namespace 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Namespace = new wchar_t [ t_NamespaceLength + 1 ] ;

				if (NULL != t_Namespace)
				{
	    			t_Result = a_Namespace->GetNamespaceAt (

						t_Index ,
						& t_NamespaceLength ,
						t_Namespace 
					) ;
				}
				else
				{
				    t_Result = WBEM_E_OUT_OF_MEMORY;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					wchar_t *t_ConcatString = NULL ;

					WmiStatusCode t_StatusCode = WmiHelper :: ConcatenateStrings_Wchar ( 

						3 , 
						& t_ConcatString ,
						a_NamespacePath ,
						t_Index ? L"\\" : NULL ,
						t_Namespace
					) ;

					delete [] t_Namespace ;

					if ( t_StatusCode == e_StatusCode_Success )
					{
						delete [] a_NamespacePath ;
						a_NamespacePath = t_ConcatString ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
					break ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
				break ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_NAMESPACE ;
	}

	if ( FAILED ( t_Result ) ) 
	{
		delete [] a_NamespacePath ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetPathText (

	IWbemPath *a_Path ,
	wchar_t *&a_ObjectPath
)
{
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Path->GetText ( 

		0 ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		a_ObjectPath = new wchar_t [ t_ObjectPathLength + 1 ] ;
		if ( a_ObjectPath )
		{
			t_Result = a_Path->GetText ( 

				0 ,
				& t_ObjectPathLength ,
				a_ObjectPath
			) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY;
		}
	}
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Set_Uint32 ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	const DWORD &a_Uint32
)
{
	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( DWORD ) , 
		0 ,
		CIM_UINT32 ,
		( void * ) & a_Uint32
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Set_String ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	wchar_t *a_String
)
{
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_String ) ;
	a_Instance->Put ( a_Name , 0 , & t_Variant , 0 ) ;
	VariantClear ( & t_Variant ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	_IWmiCallSec *t_CallSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: CreateInstance (

		CLSID__IWbemCallSec ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID__IWmiCallSec ,
		( void ** ) & t_CallSecurity 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: BeginImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating ,
	DWORD *a_AuthenticationLevel
)
{
	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	_IWmiCallSec *t_CallSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: CreateInstance (

		CLSID__IWbemCallSec ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID__IWmiCallSec ,
		( void ** ) & t_CallSecurity 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD | WMI_ORIGIN_EXISTING | WMI_ORIGIN_RPC ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_AuthenticationLevel )
					{
						t_Result = t_ThreadSecurity->GetAuthentication ( a_AuthenticationLevel  ) ;
					}

					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: EndImpersonation (

	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_Impersonating

)
{
	HRESULT t_Result = S_OK ;

	IUnknown *t_NewContext = NULL ;

	t_Result = CoSwitchCallContext ( a_OldContext , & t_NewContext ) ;
	// CoSwitchCallContext cannot fail if the previous one ( in 	
	// BeginImpersonation succeeds. Leave position of a_OldSecurity release.

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_OldContext )
		{
			if ( a_Impersonating )
			{
				IServerSecurity *t_ServerSecurity = NULL ;
				t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_ServerSecurity->ImpersonateClient () ;

					t_ServerSecurity->Release () ;
				}
			}
		}

		if ( a_OldSecurity )
		{
			a_OldSecurity->Release() ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}


	if ( a_OldContext )
	{ 
        a_OldContext->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetProxy (

	REFIID a_InterfaceId ,
	IUnknown *a_Interface ,
	IUnknown *&a_Proxy 
)
{
	IUnknown *t_Unknown = NULL ;

    HRESULT t_Result = a_Interface->QueryInterface (
		a_InterfaceId , 
		( void ** ) & t_Unknown
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
	    IClientSecurity *t_ClientSecurity = NULL ;

		t_Result = a_Interface->QueryInterface (
			IID_IClientSecurity , 
			( void ** ) & t_ClientSecurity
		) ;

		if ( SUCCEEDED ( t_Result ))
		{
			t_Result = t_ClientSecurity->CopyProxy (
				a_Interface ,
				( IUnknown ** ) & a_Proxy
			) ;

			t_ClientSecurity->Release () ;
		}
		else if ( t_Result == E_NOINTERFACE)
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}

		t_Unknown->Release () ;
	}
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetProxy (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface ,
	IUnknown *&a_Proxy 
)
{
	IUnknown *t_Unknown = NULL ;

    HRESULT t_Result = a_Interface->QueryInterface (
	
		a_InterfaceId , 
		( void ** ) & t_Unknown
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
	    IClientSecurity *t_ClientSecurity = NULL ;

		t_Result = a_Interface->QueryInterface (
		
			IID_IClientSecurity , 
			( void ** ) & t_ClientSecurity
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

			WmiStatusCode t_StatusCode = a_Container.Top ( a_Proxy , a_ProxyIndex ) ;
			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				t_StatusCode = a_Container.Reserve ( a_ProxyIndex ) ;
			}
			else
			{
				if ( a_Container.GetCurrentSize () < a_Container.GetTopSize () )
				{
					t_Result = t_ClientSecurity->CopyProxy (

						a_Interface ,
						( IUnknown ** ) & a_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						a_Container.SetCurrentSize ( a_Container.GetCurrentSize () + 1 ) ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;
			t_ClientSecurity->Release () ;
		}
		else if (E_NOINTERFACE == t_Result)
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}

		t_Unknown->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetCloaking ( 

	IUnknown *a_Unknown ,
	DWORD a_AuthenticationLevel ,
	DWORD a_ImpersonationLevel
)
{
    IClientSecurity *t_ClientSecurity = NULL ;

    HRESULT t_Result = a_Unknown->QueryInterface (
	
		IID_IClientSecurity , 
		( void ** ) & t_ClientSecurity
	) ;

    if ( SUCCEEDED ( t_Result ) )
    {
		t_Result = t_ClientSecurity->SetBlanket (

			a_Unknown ,
			RPC_C_AUTHN_WINNT ,
			RPC_C_AUTHZ_NONE ,
			NULL ,
			a_AuthenticationLevel ,
			a_ImpersonationLevel ,
			NULL ,
			EOAC_DYNAMIC_CLOAKING
		) ;

		t_ClientSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetCloaking ( 

	IUnknown *a_Unknown
)
{
    IClientSecurity *t_ClientSecurity = NULL ;

    HRESULT t_Result = a_Unknown->QueryInterface (
	
		IID_IClientSecurity , 
		( void ** ) & t_ClientSecurity
	) ;

    if ( SUCCEEDED ( t_Result ) )
    {
		t_Result = t_ClientSecurity->SetBlanket (

			a_Unknown ,
			RPC_C_AUTHN_WINNT ,
			RPC_C_AUTHZ_NONE ,
			NULL ,
			RPC_C_AUTHN_LEVEL_DEFAULT ,
			RPC_C_IMP_LEVEL_DEFAULT ,
			NULL ,
			EOAC_DYNAMIC_CLOAKING
		) ;

		t_ClientSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel ()
{
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;

    HANDLE t_ThreadToken = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread() ,
		TOKEN_QUERY,
		TRUE ,
		&t_ThreadToken
	) ;

    if ( t_Status )
    {
		SECURITY_IMPERSONATION_LEVEL t_Level = SecurityAnonymous ;
		DWORD t_Returned = 0 ;

		t_Status = GetTokenInformation (

			t_ThreadToken ,
			TokenImpersonationLevel ,
			& t_Level ,
			sizeof ( SECURITY_IMPERSONATION_LEVEL ) ,
			& t_Returned
		) ;

		CloseHandle ( t_ThreadToken ) ;

		if ( t_Status == FALSE )
		{
			t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
		}
		else
		{
			switch ( t_Level )
			{
				case SecurityAnonymous:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;

				case SecurityIdentification:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				break ;

				case SecurityImpersonation:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
				}
				break ;

				case SecurityDelegation:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
				}
				break ;

				default:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;
			}
		}
	}
	else
	{
        ULONG t_LastError = GetLastError () ;

        if ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN )
        {
            t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
        }
        else 
		{
			if ( t_LastError == ERROR_CANT_OPEN_ANONYMOUS )
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
			}
			else
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
			}
		}
    }

	return t_ImpersonationLevel ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: EnableAllPrivileges ( HANDLE a_Token )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ReturnedLength = 0 ;

	BOOL t_Status = GetTokenInformation (

		a_Token , 
		TokenPrivileges , 
		NULL , 
		0 , 
		& t_ReturnedLength
	) ;

	UCHAR *t_Buffer = new UCHAR [ t_ReturnedLength ] ;
	if ( t_Buffer )
	{
		t_Status = GetTokenInformation (

			a_Token , 
			TokenPrivileges , 
			t_Buffer , 
			t_ReturnedLength , 
			& t_ReturnedLength
		) ;

		if ( t_Status )
		{
			TOKEN_PRIVILEGES *t_Privileges = ( TOKEN_PRIVILEGES * ) t_Buffer ;
			BOOL bNeedToAdjust = FALSE;

			for ( ULONG t_Index = 0; t_Index < t_Privileges->PrivilegeCount ; t_Index ++ )
			{
				if (!(t_Privileges->Privileges [ t_Index ].Attributes & SE_PRIVILEGE_ENABLED))
				{
    				bNeedToAdjust = TRUE;
					t_Privileges->Privileges [ t_Index ].Attributes |= SE_PRIVILEGE_ENABLED ;
				}
			}

            if (bNeedToAdjust)
            {
				t_Status = AdjustTokenPrivileges (

					a_Token, 
					FALSE, 
					t_Privileges , 
					0, 
					NULL, 
					NULL
				) ;            
            }

			if ( t_Status == FALSE )
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}
		else
		{
			t_Status = WBEM_E_ACCESS_DENIED ;
		}

		delete [] t_Buffer ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: EnableAllPrivileges ()
{
	HRESULT t_Result = S_OK ;

    HANDLE t_Token = NULL ;

    BOOL t_Status = TRUE ;

	t_Status = OpenThreadToken (

		GetCurrentThread (), 
		TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES ,
		FALSE, 
		&t_Token
	) ;

    if ( t_Status )
	{
		DWORD t_ReturnedLength = 0 ;

		t_Status = GetTokenInformation (

			t_Token , 
			TokenPrivileges , 
			NULL , 
			0 , 
			& t_ReturnedLength
		) ;
    
		UCHAR *t_Buffer = new UCHAR [ t_ReturnedLength ] ;
		if ( t_Buffer )
		{
			t_Status = GetTokenInformation (

				t_Token , 
				TokenPrivileges , 
				t_Buffer , 
				t_ReturnedLength , 
				& t_ReturnedLength
			) ;

			if ( t_Status )
			{
				TOKEN_PRIVILEGES *t_Privileges = ( TOKEN_PRIVILEGES * ) t_Buffer ;
				BOOL bNeedToAdjust = FALSE;

				for ( ULONG t_Index = 0; t_Index < t_Privileges->PrivilegeCount ; t_Index ++ )
				{
				    if (!(t_Privileges->Privileges [ t_Index ].Attributes & SE_PRIVILEGE_ENABLED))
				    {
					    t_Privileges->Privileges [ t_Index ].Attributes |= SE_PRIVILEGE_ENABLED ;
					    bNeedToAdjust = TRUE;
				    }
				}

                if (bNeedToAdjust)
                {
					t_Status = AdjustTokenPrivileges (

						t_Token, 
						FALSE, 
						t_Privileges , 
						0, 
						NULL, 
						NULL
					) ;
                }

				if ( t_Status == FALSE )
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}
								
			}
			else
			{
				t_Status = WBEM_E_ACCESS_DENIED ;
			}

			delete [] t_Buffer ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		CloseHandle ( t_Token ) ;
	}
	else
	{
		DWORD t_LastError = GetLastError () ;
        t_Result = WBEM_E_ACCESS_DENIED;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState ( 

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_Container , a_ProxyIndex , a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
			}
			else
			{
				t_Result = SetInterfaceSecurity (

					a_Proxy ,
					NULL ,
					NULL ,
					NULL ,
					DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
					RPC_C_IMP_LEVEL_IDENTIFY
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		if ( FAILED ( t_Result ) )
		{
			RevertProxyState (

				a_Container , 
				a_ProxyIndex ,
				a_Proxy , 
				a_Revert
			) ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	IUnknown *a_Proxy , 
	BOOL a_Revert
)
{
	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

	WmiStatusCode t_StatusCode = a_Container.Return ( a_Proxy , a_ProxyIndex ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Proxy->Release () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState_NoImpersonation ( 

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy ,
	BOOL &a_Revert
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_Container , a_ProxyIndex , a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = SetInterfaceSecurity (

			a_Proxy ,
			NULL ,
			NULL ,
			NULL ,
			DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
			RPC_C_IMP_LEVEL_IDENTIFY
		) ;

		if ( FAILED ( t_Result ) )
		{
			RevertProxyState (

				a_Container , 
				a_ProxyIndex ,
				a_Proxy , 
				a_Revert
			) ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: ConstructIdentifyToken_SvcHost (

	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_ThreadToken = NULL ;

	BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& t_ThreadToken
	) ;
	
	if ( t_Status )
	{
		CoRevertToSelf () ;

		a_Revert = FALSE ;

		SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

		DWORD t_LengthRequested = 0 ;
		DWORD t_LengthReturned = 0 ;

		t_Status = GetKernelObjectSecurity (

			t_ThreadToken ,
			DACL_SECURITY_INFORMATION ,
			& t_SecurityDescriptor ,
			t_LengthRequested ,
			& t_LengthReturned
		) ;

		if ( ( t_Status == FALSE ) && ( GetLastError () == ERROR_INSUFFICIENT_BUFFER ) )
		{
			t_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_LengthReturned ] ;
			if ( t_SecurityDescriptor )
			{
				t_LengthRequested = t_LengthReturned ;

				t_Status = GetKernelObjectSecurity (

					t_ThreadToken ,
					DACL_SECURITY_INFORMATION ,
					t_SecurityDescriptor ,
					t_LengthRequested ,
					& t_LengthReturned
				) ;

				if ( t_LengthRequested != t_LengthReturned )
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		HANDLE t_AdjustedThreadToken = NULL ;

		if ( SUCCEEDED ( t_Result ) )
		{
			PACL t_ExtraDacl = NULL ;

			ACL *t_Dacl = NULL ;
			BOOL t_DaclPresent = FALSE ;
			BOOL t_DaclDefaulted = FALSE ;

			t_Status = GetSecurityDescriptorDacl (

				t_SecurityDescriptor ,
				& t_DaclPresent ,
				& t_Dacl ,
				& t_DaclDefaulted
			) ;

			if ( t_Status )
			{
				ACL_SIZE_INFORMATION t_Size ;

				if ( t_Dacl )
				{
					BOOL t_Status = GetAclInformation (

						t_Dacl ,
						& t_Size ,
						sizeof ( t_Size ) ,
						AclSizeInformation
					);

					if ( t_Status )
					{
						DWORD t_ExtraSize = t_Size.AclBytesInUse + t_Size.AclBytesFree + a_AceSize ;

						t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
						if ( t_ExtraDacl )
						{
							CopyMemory ( t_ExtraDacl , t_Dacl , t_Size.AclBytesInUse + t_Size.AclBytesFree ) ;
							t_ExtraDacl->AclSize = t_ExtraSize ;

							BOOL t_Status = :: AddAce ( t_ExtraDacl , ACL_REVISION, t_Size.AceCount , a_Ace , a_AceSize ) ;
							if ( t_Status )
							{
								SECURITY_DESCRIPTOR t_AdjustedSecurityDescriptor ;

								if ( SUCCEEDED ( t_Result ) )
								{
									BOOL t_Status = InitializeSecurityDescriptor ( & t_AdjustedSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
									if ( t_Status ) 
									{
										t_Status = SetSecurityDescriptorDacl (

											& t_AdjustedSecurityDescriptor ,
											t_DaclPresent ,
											t_ExtraDacl ,
											t_DaclDefaulted
										) ;

										if ( t_Status ) 
										{
											SECURITY_ATTRIBUTES t_SecurityAttributes ;
											t_SecurityAttributes.nLength = GetSecurityDescriptorLength ( & t_AdjustedSecurityDescriptor ) ;
											t_SecurityAttributes.lpSecurityDescriptor = & t_AdjustedSecurityDescriptor ;
											t_SecurityAttributes.bInheritHandle = FALSE ;

											t_Status = DuplicateTokenEx ( 

												t_ThreadToken,
												DUPLICATE_SAME_ACCESS ,
												& t_SecurityAttributes ,
												( SECURITY_IMPERSONATION_LEVEL ) SecurityIdentification ,
												TokenImpersonation ,
												& t_AdjustedThreadToken
											) ;

											if ( t_Status == FALSE )
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}
										}
										else
										{
											t_Result = WBEM_E_CRITICAL_ERROR ;
										}
									}
									else
									{
										t_Result = WBEM_E_UNEXPECTED ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_CRITICAL_ERROR ;
							}

							delete [] ( BYTE * ) t_ExtraDacl ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			HANDLE t_ProcessHandle = OpenProcess (

				MAXIMUM_ALLOWED ,
				FALSE ,
				a_ProcessIdentifier 
			) ;

			if ( t_ProcessHandle )
			{
				t_Status = DuplicateHandle (

					GetCurrentProcess () ,
					t_AdjustedThreadToken ,
					t_ProcessHandle ,
					& a_IdentifyToken ,
					MAXIMUM_ALLOWED | TOKEN_DUPLICATE | TOKEN_IMPERSONATE ,
					TRUE ,
					0
				) ;

				if ( t_Status )
				{

				}
				else
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}

				CloseHandle ( t_ProcessHandle ) ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}

		if ( t_SecurityDescriptor )
		{
			delete [] ( BYTE * ) t_SecurityDescriptor ; 
		}

		if ( t_AdjustedThreadToken )
		{
			CloseHandle ( t_AdjustedThreadToken ) ;
		}

		CloseHandle ( t_ThreadToken ) ;
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: ConstructIdentifyToken_PrvHost (

	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_ThreadToken = NULL ;

	BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& t_ThreadToken
	) ;
	
	if ( t_Status )
	{
		CoRevertToSelf () ;

		a_Revert = FALSE ;

		SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

		DWORD t_LengthRequested = 0 ;
		DWORD t_LengthReturned = 0 ;

		t_Status = GetKernelObjectSecurity (

			t_ThreadToken ,
			DACL_SECURITY_INFORMATION ,
			& t_SecurityDescriptor ,
			t_LengthRequested ,
			& t_LengthReturned
		) ;

		if ( ( t_Status == FALSE ) && ( GetLastError () == ERROR_INSUFFICIENT_BUFFER ) )
		{
			t_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_LengthReturned ] ;
			if ( t_SecurityDescriptor )
			{
				t_LengthRequested = t_LengthReturned ;

				t_Status = GetKernelObjectSecurity (

					t_ThreadToken ,
					DACL_SECURITY_INFORMATION ,
					t_SecurityDescriptor ,
					t_LengthRequested ,
					& t_LengthReturned
				) ;

				if ( t_LengthRequested != t_LengthReturned )
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			PACL t_ExtraDacl = NULL ;

			ACL *t_Dacl = NULL ;
			BOOL t_DaclPresent = FALSE ;
			BOOL t_DaclDefaulted = FALSE ;

			t_Status = GetSecurityDescriptorDacl (

				t_SecurityDescriptor ,
				& t_DaclPresent ,
				& t_Dacl ,
				& t_DaclDefaulted
			) ;

			if ( t_Status )
			{
				ACL_SIZE_INFORMATION t_Size ;

				if ( t_Dacl )
				{
					BOOL t_Status = GetAclInformation (

						t_Dacl ,
						& t_Size ,
						sizeof ( t_Size ) ,
						AclSizeInformation
					);

					if ( t_Status )
					{
						DWORD t_ExtraSize = t_Size.AclBytesInUse + t_Size.AclBytesFree + a_AceSize ;

						t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
						if ( t_ExtraDacl )
						{
							CopyMemory ( t_ExtraDacl , t_Dacl , t_Size.AclBytesInUse + t_Size.AclBytesFree ) ;
							t_ExtraDacl->AclSize = t_ExtraSize ;

							BOOL t_Status = :: AddAce ( t_ExtraDacl , ACL_REVISION, t_Size.AceCount , a_Ace , a_AceSize ) ;
							if ( t_Status )
							{
								SECURITY_DESCRIPTOR t_AdjustedSecurityDescriptor ;

								if ( SUCCEEDED ( t_Result ) )
								{
									BOOL t_Status = InitializeSecurityDescriptor ( & t_AdjustedSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
									if ( t_Status ) 
									{
										t_Status = SetSecurityDescriptorDacl (

											& t_AdjustedSecurityDescriptor ,
											t_DaclPresent ,
											t_ExtraDacl ,
											t_DaclDefaulted
										) ;

										if ( t_Status ) 
										{
											SECURITY_ATTRIBUTES t_SecurityAttributes ;
											t_SecurityAttributes.nLength = GetSecurityDescriptorLength ( & t_AdjustedSecurityDescriptor ) ;
											t_SecurityAttributes.lpSecurityDescriptor = & t_AdjustedSecurityDescriptor ;
											t_SecurityAttributes.bInheritHandle = FALSE ;

											t_Status = DuplicateTokenEx ( 

												t_ThreadToken,
												DUPLICATE_SAME_ACCESS ,
												& t_SecurityAttributes ,
												( SECURITY_IMPERSONATION_LEVEL ) SecurityIdentification ,
												TokenImpersonation ,
												& a_IdentifyToken
											) ;

											if ( t_Status == FALSE )
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}
										}
										else
										{
											t_Result = WBEM_E_CRITICAL_ERROR ;
										}
									}
									else
									{
										t_Result = WBEM_E_UNEXPECTED ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_CRITICAL_ERROR ;
							}

							delete [] ( BYTE * ) t_ExtraDacl ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( t_SecurityDescriptor )
		{
			delete [] ( BYTE * ) t_SecurityDescriptor ; 
		}

		CloseHandle ( t_ThreadToken ) ;
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_Container , a_ProxyIndex , a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
				a_IdentifyToken = 0 ;
			}
			else
			{
				t_Result = ConstructIdentifyToken_SvcHost (

					a_Revert ,
					a_ProcessIdentifier ,
					a_IdentifyToken ,
					a_Ace ,
					a_AceSize
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SetInterfaceSecurity (

						a_Proxy ,
						NULL ,
						NULL ,
						NULL ,
						DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
						RPC_C_IMP_LEVEL_IDENTIFY
					) ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		if ( FAILED ( t_Result ) )
		{
			RevertProxyState_SvcHost (

				a_Container , 
				a_ProxyIndex ,
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken
			) ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

	WmiStatusCode t_StatusCode = a_Container.Return ( a_Proxy , a_ProxyIndex ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Proxy->Release () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState_PrvHost ( 

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_Container , a_ProxyIndex , a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
				a_IdentifyToken = 0 ;
			}
			else
			{
				t_Result = ConstructIdentifyToken_PrvHost (

					a_Revert ,
					a_ProcessIdentifier ,
					a_IdentifyToken ,
					s_Token_All_Access_System_ACE ,
					s_System_ACESize
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SetInterfaceSecurity (

						a_Proxy ,
						NULL ,
						NULL ,
						NULL ,
						DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
						RPC_C_IMP_LEVEL_IDENTIFY
					) ;
				}
			}

			CoRevertToSelf () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		if ( FAILED ( t_Result ) )
		{
			RevertProxyState_PrvHost (

				a_Container , 
				a_ProxyIndex ,
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken
			) ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

	WmiStatusCode t_StatusCode = a_Container.Return ( a_Proxy , a_ProxyIndex ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Proxy->Release () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	CloseHandle ( a_IdentifyToken ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 

	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
				a_IdentifyToken = 0 ;
			}
			else
			{
				t_Result = ConstructIdentifyToken_SvcHost (

					a_Revert ,
					a_ProcessIdentifier ,
					a_IdentifyToken ,
					a_Ace ,
					a_AceSize
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SetInterfaceSecurity (

						a_Proxy ,
						NULL ,
						NULL ,
						NULL ,
						DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
						RPC_C_IMP_LEVEL_IDENTIFY
					) ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		if ( FAILED ( t_Result ) )
		{
			RevertProxyState_SvcHost (

				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken
			) ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost (

	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	HRESULT t_Result = S_OK ;

	a_Proxy->Release () ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState_PrvHost ( 

	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
				a_IdentifyToken = 0 ;
			}
			else
			{
				t_Result = ConstructIdentifyToken_PrvHost (

					a_Revert ,
					a_ProcessIdentifier ,
					a_IdentifyToken ,
					s_Token_All_Access_System_ACE ,
					s_System_ACESize
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SetInterfaceSecurity (

						a_Proxy ,
						NULL ,
						NULL ,
						NULL ,
						DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
						RPC_C_IMP_LEVEL_IDENTIFY
					) ;
				}
			}

			CoRevertToSelf () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		if ( FAILED ( t_Result ) )
		{
			RevertProxyState_PrvHost (

				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken
			) ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost (

	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	HRESULT t_Result = S_OK ;

	a_Proxy->Release () ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	CloseHandle ( a_IdentifyToken ) ;

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState ( 

	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
			}
			else
			{
				t_Result = SetInterfaceSecurity (

					a_Proxy ,
					NULL ,
					NULL ,
					NULL ,
					DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
					RPC_C_IMP_LEVEL_IDENTIFY
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
        }

		if ( FAILED ( t_Result ) )
		{
			RevertProxyState (

				a_Proxy , 
				a_Revert
			) ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState_NoImpersonation ( 

	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = SetInterfaceSecurity (

			a_Proxy ,
			NULL ,
			NULL ,
			NULL ,
			DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
			RPC_C_IMP_LEVEL_IDENTIFY
		) ;

		if ( FAILED ( t_Result ) )
		{
			RevertProxyState (

				a_Proxy , 
				a_Revert
			) ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState ( IUnknown *a_Proxy , BOOL a_Revert )
{
	HRESULT t_Result = S_OK ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	a_Proxy->Release () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Load_DWORD ( HKEY a_Key , LPCWSTR a_Name , DWORD &a_Value )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_DWORD ;
	DWORD t_Data = 0 ;
	DWORD t_DataSize = sizeof ( t_ValueType ) ;

	LONG t_RegResult = RegQueryValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  & t_ValueType ,
	  LPBYTE ( & t_Data ) ,
	  & t_DataSize 
	) ;

	if ( ( t_RegResult == ERROR_SUCCESS ) && ( t_ValueType == REG_DWORD ) )
	{
		a_Value = t_Data ;
	}
	else
	{
		t_Result = ERROR_FILE_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Load_String ( HKEY a_Key , LPCWSTR a_Name , BSTR &a_Value )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	wchar_t *t_Data = NULL ;
	DWORD t_DataSize = 0 ;

	LONG t_RegResult = RegQueryValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  & t_ValueType ,
	  NULL ,
	  & t_DataSize 
	) ;

	if ( ( t_RegResult == ERROR_SUCCESS ) && ( t_ValueType == REG_SZ ) )
	{
		t_Data = new wchar_t [ t_DataSize / sizeof ( wchar_t ) ] ;
		if ( t_Data )
		{
			t_RegResult = RegQueryValueEx (

				a_Key ,
				a_Name ,
				0 ,
				& t_ValueType ,
				LPBYTE ( t_Data ) ,
				& t_DataSize 
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				a_Value = SysAllocString ( t_Data ) ;
				if ( a_Value == NULL )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				delete [] t_Data ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				DWORD t_LastError = GetLastError () ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = ERROR_FILE_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Load_ByteArray ( HKEY a_Key , LPCWSTR a_Name , BYTE *&a_Value , DWORD &a_ValueLength )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_BINARY ;
	BYTE *t_Data = NULL ;
	DWORD t_DataSize = 0 ;

	LONG t_RegResult = RegQueryValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  & t_ValueType ,
	  NULL ,
	  & t_DataSize 
	) ;

	if ( ( t_RegResult == ERROR_SUCCESS ) && ( t_ValueType == REG_BINARY ) )
	{
		t_Data = new BYTE [ t_DataSize ] ;
		if ( t_Data )
		{
			t_RegResult = RegQueryValueEx (

				a_Key ,
				a_Name ,
				0 ,
				& t_ValueType ,
				LPBYTE ( t_Data ) ,
				& t_DataSize 
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				a_Value = t_Data ;
				a_ValueLength = t_DataSize ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				DWORD t_LastError = GetLastError () ;
				_DBG_ASSERT( FALSE ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = ERROR_FILE_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Save_DWORD ( HKEY a_Key , LPCWSTR a_Name , DWORD a_Value )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_DWORD ;
	DWORD t_DataSize = sizeof ( t_ValueType ) ;

	LONG t_RegResult = RegSetValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  t_ValueType ,
	  LPBYTE ( & a_Value ) ,
	  t_DataSize 
	) ;

	if ( t_RegResult != ERROR_SUCCESS ) 
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Save_String ( HKEY a_Key , LPCWSTR a_Name , BSTR a_Value )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	DWORD t_DataSize = wcslen ( a_Value ) + 1 ;

	LONG t_RegResult = RegSetValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  t_ValueType ,
	  LPBYTE ( a_Value ) ,
	  t_DataSize * sizeof ( wchar_t ) 
	) ;

	if ( t_RegResult != ERROR_SUCCESS ) 
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Save_ByteArray ( HKEY a_Key , LPCWSTR a_Name , BYTE *a_Value , DWORD a_ValueLength )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_BINARY ;

	LONG t_RegResult = RegSetValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  t_ValueType ,
	  LPBYTE ( a_Value ) ,
	  a_ValueLength 
	) ;

	if ( t_RegResult != ERROR_SUCCESS ) 
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: UnMarshalRegistration (

	IUnknown **a_Unknown ,
	BYTE *a_MarshaledProxy ,
	DWORD a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	IStream *t_Stream = NULL ;

	HGLOBAL t_Global = GlobalAlloc (

		GHND ,
		a_MarshaledProxyLength
	) ;

	if ( t_Global ) 
	{
		void *t_Memory = GlobalLock ( t_Global ) ;

		CopyMemory ( t_Memory , a_MarshaledProxy , a_MarshaledProxyLength ) ;

		GlobalUnlock ( t_Global ) ;

		t_Result = CreateStreamOnHGlobal (

			t_Global ,
			TRUE ,
			& t_Stream 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CoUnmarshalInterface (

				t_Stream ,
				IID_IUnknown ,
				( void ** ) a_Unknown
			) ;

			t_Stream->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ; 
	}
	
	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: ReleaseRegistration (

	BYTE *a_MarshaledProxy ,
	DWORD a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	IStream *t_Stream = NULL ;

	HGLOBAL t_Global = GlobalAlloc (

		GHND ,
		a_MarshaledProxyLength
	) ;

	if ( t_Global ) 
	{
		void *t_Memory = GlobalLock ( t_Global ) ;

		CopyMemory ( t_Memory , a_MarshaledProxy , a_MarshaledProxyLength ) ;

		GlobalUnlock ( t_Global ) ;

		t_Result = CreateStreamOnHGlobal (

			t_Global ,
			TRUE ,
			& t_Stream 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CoReleaseMarshalData (

				t_Stream
			) ;

			t_Stream->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ; 
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: MarshalRegistration (

	IUnknown *a_Unknown ,
	BYTE *&a_MarshaledProxy ,
	DWORD &a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	t_Result = CoGetMarshalSizeMax (

		& a_MarshaledProxyLength ,
		IID_IUnknown ,
		a_Unknown ,
		MSHCTX_LOCAL ,
		NULL ,
		MSHLFLAGS_TABLESTRONG
	) ;
 
	if ( SUCCEEDED ( t_Result ) ) 
	{
		IStream *t_Stream = NULL ;

		HGLOBAL t_Global = GlobalAlloc (

			GHND ,
			a_MarshaledProxyLength
		) ;

		if ( t_Global ) 
		{
			t_Result = CreateStreamOnHGlobal (

			  t_Global ,
			  TRUE ,
			  & t_Stream 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
			
				t_Result = CoMarshalInterface (

					t_Stream ,
					IID_IUnknown ,
					a_Unknown ,
					MSHCTX_LOCAL ,
					NULL ,
					MSHLFLAGS_TABLESTRONG
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					a_MarshaledProxy = new BYTE [ a_MarshaledProxyLength ] ;
					if ( a_MarshaledProxy )
					{
						void *t_Memory = GlobalLock ( t_Global ) ;

						CopyMemory ( a_MarshaledProxy , t_Memory , a_MarshaledProxyLength ) ;

						GlobalUnlock ( t_Global ) ;

					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ; 
					}
				}
				t_Stream->Release();	
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ; 
		}
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: IsDependantCall ( IWbemContext *a_ParentContext , IWbemContext *a_ChildContext , BOOL &a_DependantCall )
{
	HRESULT t_Result = S_OK ;

	if ( a_ParentContext )
	{
		if ( a_ChildContext )
		{
			IWbemCausalityAccess *t_ParentCausality = NULL ;
			t_Result = a_ParentContext->QueryInterface ( IID_IWbemCausalityAccess , ( void ** ) & t_ParentCausality ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemCausalityAccess *t_ChildCausality = NULL ;
				t_Result = a_ChildContext->QueryInterface ( IID_IWbemCausalityAccess , ( void ** ) & t_ChildCausality ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					REQUESTID t_ParentId ;

					t_Result = t_ParentCausality->GetRequestId ( & t_ParentId ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_ChildCausality->IsChildOf ( t_ParentId ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							a_DependantCall = ( t_Result == S_FALSE ) ? FALSE : TRUE ;
							t_Result = S_OK;
						}
					}

					t_ChildCausality->Release () ;		
				}
				else
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}

				t_ParentCausality->Release () ;		
			}
		}
	}

	_DBG_ASSERT( SUCCEEDED(t_Result));

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Check_SecurityDescriptor_CallIdentity ( 

	SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
	DWORD a_Access , 
	GENERIC_MAPPING *a_Mapping,
	SECURITY_DESCRIPTOR *defaultSD
)
{
	HRESULT t_Result = S_OK ;

	SECURITY_DESCRIPTOR *t_SecurityDescriptor = a_SecurityDescriptor ? a_SecurityDescriptor : defaultSD ;

	HANDLE t_Token = NULL ;

	BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		TOKEN_QUERY ,
		TRUE ,
		& t_Token 										
	) ;

	DWORD t_LastError = GetLastError () ;
	if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
	{
		HANDLE t_ProcessToken = NULL ;
		t_Status = OpenProcessToken (

			GetCurrentProcess () ,
			TOKEN_QUERY | TOKEN_DUPLICATE ,
			& t_ProcessToken
		) ;

		if ( t_Status )
		{
			t_Status = ImpersonateLoggedOnUser ( t_ProcessToken ) ;
			if ( t_Status )
			{
				BOOL t_Status = OpenThreadToken (

					GetCurrentThread () ,
					TOKEN_QUERY ,
					TRUE ,
					& t_Token 										
				) ;

				if ( ! t_Status )
				{
					DWORD t_LastError = GetLastError () ;

					t_Result = WBEM_E_ACCESS_DENIED ;
				}

				RevertToSelf () ;
			}
			else
			{
				DWORD t_LastError = GetLastError () ;

				t_Result = WBEM_E_ACCESS_DENIED ;
			}

			CloseHandle ( t_ProcessToken ) ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		if ( ! t_Status ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		DWORD t_Access = 0 ;
		BOOL t_AccessStatus = FALSE ;
		PRIVILEGE_SET *t_PrivilegeSet = NULL ;
		DWORD t_PrivilegeSetSize = 0 ;
	
		MapGenericMask (

			& a_Access ,
			a_Mapping
		) ;

		t_Status = AccessCheck (

			t_SecurityDescriptor ,
			t_Token,
			a_Access ,
			a_Mapping ,
			NULL ,
			& t_PrivilegeSetSize ,
			& t_Access ,
			& t_AccessStatus
		) ;

		if ( t_Status && t_AccessStatus )
		{
		}
		else
		{
			DWORD t_LastError = GetLastError () ;
			if ( t_LastError == ERROR_INSUFFICIENT_BUFFER )
			{
				t_PrivilegeSet = ( PRIVILEGE_SET * ) new BYTE [ t_PrivilegeSetSize ] ;
				if ( t_PrivilegeSet )
				{
					t_Status = AccessCheck (

						t_SecurityDescriptor ,
						t_Token,
						a_Access ,
						a_Mapping ,
						t_PrivilegeSet ,
						& t_PrivilegeSetSize ,
						& t_Access ,
						& t_AccessStatus
					) ;

					if ( t_Status && t_AccessStatus )
					{
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					delete [] ( BYTE * ) t_PrivilegeSet ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED;
			}
		}

		CloseHandle ( t_Token ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: AdjustSecurityDescriptorWithSid ( 

	SID *a_OwnerSid , 
	SID *a_GroupSid , 
	DWORD a_Access ,
	SECURITY_DESCRIPTOR *&a_SecurityDescriptor , 
	SECURITY_DESCRIPTOR *&a_AlteredSecurityDescriptor
)
{
	HRESULT t_Result = S_OK ;

	SECURITY_DESCRIPTOR t_CreatedSecurityDescriptor ;
	SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

	PACL t_Dacl = NULL ;
	PACL t_Sacl = NULL ;
	PSID t_Owner = NULL ;
	PSID t_PrimaryGroup = NULL ;
	SECURITY_DESCRIPTOR *t_AlteredSecurityDescriptor = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_SecurityDescriptor )
		{
			DWORD t_AlteredSecurityDescriptorSize = sizeof ( SECURITY_DESCRIPTOR ) ;
			DWORD t_DaclSize = 0 ;
			DWORD t_SaclSize = 0 ;
			DWORD t_OwnerSize = 0 ;
			DWORD t_PrimaryGroupSize = 0 ;

			BOOL t_Status = MakeAbsoluteSD (

			  a_SecurityDescriptor ,
			  t_AlteredSecurityDescriptor ,
			  & t_AlteredSecurityDescriptorSize ,
			  t_Dacl,
			  & t_DaclSize,
			  t_Sacl,
			  & t_SaclSize,
			  t_Owner,
			  & t_OwnerSize,
			  t_PrimaryGroup,
			  & t_PrimaryGroupSize
			) ;

			if ( ( t_Status == FALSE ) && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
			{
				DWORD t_SidLength = GetLengthSid ( a_OwnerSid ) ;
				DWORD t_ExtraSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

				t_Dacl = ( PACL ) new BYTE [ t_DaclSize + t_ExtraSize ] ;
				t_Sacl = ( PACL ) new BYTE [ t_SaclSize ] ;
				t_Owner = ( PSID ) new BYTE [ t_OwnerSize ] ;
				t_PrimaryGroup = ( PSID ) new BYTE [ t_PrimaryGroupSize ] ;

				t_AlteredSecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_AlteredSecurityDescriptorSize ] ;

				if ( t_AlteredSecurityDescriptor && t_Dacl && t_Sacl && t_Owner && t_PrimaryGroup )
				{
					BOOL t_Status = InitializeSecurityDescriptor ( t_AlteredSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
					if ( t_Status )
					{
						t_Status = MakeAbsoluteSD (

							a_SecurityDescriptor ,
							t_AlteredSecurityDescriptor ,
							& t_AlteredSecurityDescriptorSize ,
							t_Dacl,
							& t_DaclSize,
							t_Sacl,
							& t_SaclSize,
							t_Owner,
							& t_OwnerSize,
							t_PrimaryGroup,
							& t_PrimaryGroupSize
						) ;

						if ( t_Status )
						{
							t_SecurityDescriptor = t_AlteredSecurityDescriptor ;

							if ( t_OwnerSize == 0 )
							{
								t_Status = SetSecurityDescriptorOwner (

									t_SecurityDescriptor ,
									a_OwnerSid ,
									FALSE 
								) ;

								if ( ! t_Status )
								{
									t_Result = WBEM_E_CRITICAL_ERROR ;
								}
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_PrimaryGroupSize == 0 )
								{
									t_Status = SetSecurityDescriptorGroup (

										t_SecurityDescriptor ,
										a_GroupSid ,
										FALSE 
									) ;

									if ( ! t_Status )
									{
										t_Result = WBEM_E_CRITICAL_ERROR ;
									}
								}
							}
						}
						else
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		else
		{
			BOOL t_Status = InitializeSecurityDescriptor ( & t_CreatedSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
			if ( t_Status )
			{
				t_Status = SetSecurityDescriptorOwner (

					& t_CreatedSecurityDescriptor ,
					a_OwnerSid ,
					FALSE 
				) ;

				if ( ! t_Status )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Status = SetSecurityDescriptorGroup (

						& t_CreatedSecurityDescriptor ,
						a_GroupSid ,
						FALSE 
					) ;

					if ( ! t_Status )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			t_SecurityDescriptor = & t_CreatedSecurityDescriptor ;
		}
	}


	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;
	DWORD t_SidLength = GetLengthSid ( a_OwnerSid ) ;

	PACL t_ExtraDacl = NULL ;
	ACCESS_ALLOWED_ACE *t_Ace = NULL ;
	DWORD t_AceSize = 0 ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_AceSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Ace = (ACCESS_ALLOWED_ACE*) new BYTE [ t_AceSize ] ;
		if ( t_Ace )
		{
			CopySid ( t_SidLength, (PSID) & t_Ace->SidStart, a_OwnerSid ) ;
			t_Ace->Mask = a_Access ;
			t_Ace->Header.AceType = 0 ;
			t_Ace->Header.AceFlags = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE ;
			t_Ace->Header.AceSize = t_AceSize ;

		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ACL_SIZE_INFORMATION t_Size ;

		if ( t_Dacl )
		{
			BOOL t_Status = GetAclInformation (

				t_Dacl ,
				& t_Size ,
				sizeof ( t_Size ) ,
				AclSizeInformation
			);

			if ( t_Status )
			{
				DWORD t_ExtraSize = t_Size.AclBytesInUse + t_Size.AclBytesFree + ( sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ) ;
				t_ExtraSize = t_ExtraSize + s_LocalService_ACESize + s_NetworkService_ACESize + s_System_ACESize + s_LocalAdmins_ACESize ;

				t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
				if ( t_ExtraDacl )
				{
					CopyMemory ( t_ExtraDacl , t_Dacl , t_Size.AclBytesInUse + t_Size.AclBytesFree ) ;
					t_ExtraDacl->AclSize = t_ExtraSize ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		else
		{
			DWORD t_SidLength = GetLengthSid ( a_OwnerSid ) ;
			DWORD t_ExtraSize = sizeof ( ACL ) + ( sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ) ;
			t_ExtraSize = t_ExtraSize + s_LocalService_ACESize + s_NetworkService_ACESize + s_System_ACESize + s_LocalAdmins_ACESize ;

			t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
			if ( t_ExtraDacl )
			{
				BOOL t_Status = InitializeAcl (

					t_ExtraDacl ,
					t_ExtraSize ,
					ACL_REVISION 
				) ;

				if ( t_Status )
				{
					BOOL t_Status = GetAclInformation (

						t_ExtraDacl ,
						& t_Size ,
						sizeof ( t_Size ) ,
						AclSizeInformation
					);

					if ( ! t_Status )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		DWORD t_AceIndex = 0 ;

		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Status = :: AddAce ( t_ExtraDacl , ACL_REVISION, t_Size.AceCount , t_Ace , t_AceSize ) ;
			if ( t_Status )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( s_System_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , s_Provider_System_ACE , s_System_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( s_LocalService_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , s_Provider_LocalService_ACE , s_LocalService_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( s_NetworkService_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , s_Provider_NetworkService_ACE , s_NetworkService_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}			

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( s_LocalAdmins_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , s_Provider_LocalAdmins_ACE , s_LocalAdmins_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}			


		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Status = SetSecurityDescriptorDacl (

				  t_SecurityDescriptor ,
				  TRUE ,
				  t_ExtraDacl ,
				  FALSE 
			) ;

			if ( t_Status )
			{
				DWORD t_FinalLength = 0 ;

				t_Status = MakeSelfRelativeSD (

					t_SecurityDescriptor ,
					a_AlteredSecurityDescriptor ,
					& t_FinalLength 
				) ;

				if ( t_Status == FALSE && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
				{
					a_AlteredSecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_FinalLength ] ;
					if ( a_AlteredSecurityDescriptor )
					{
						t_Status = MakeSelfRelativeSD (

							t_SecurityDescriptor ,
							a_AlteredSecurityDescriptor ,
							& t_FinalLength 
						) ;

						if ( t_Status == FALSE )
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;									
					}
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		delete [] t_Ace ;
		delete [] t_ExtraDacl ;
	}

	delete [] ( BYTE * ) t_Dacl ;
	delete [] ( BYTE * ) t_Sacl ;
	delete [] ( BYTE * ) t_Owner ;
	delete [] ( BYTE * ) t_PrimaryGroup ;
	delete [] ( BYTE * ) t_AlteredSecurityDescriptor ;

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CreateSystemAces ()
{
	HRESULT t_Result = S_OK ;

	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

	PSID t_System_Sid = NULL ;
	PSID t_LocalService_Sid = NULL ;
	PSID t_NetworkService_Sid = NULL ;
	PSID t_LocalAdmins_Sid = NULL ;

	BOOL t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_LOCAL_SYSTEM_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_System_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
		s_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

		s_Provider_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_System_ACESize ] ;
		if ( s_Provider_System_ACE )
		{
			CopySid ( t_SidLength, (PSID) & s_Provider_System_ACE->SidStart, t_System_Sid ) ;
			s_Provider_System_ACE->Mask =  MASK_PROVIDER_BINDING_BIND  ;
			s_Provider_System_ACE->Header.AceType = 0 ;
			s_Provider_System_ACE->Header.AceFlags = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE ;
			s_Provider_System_ACE->Header.AceSize = s_System_ACESize ;

			s_Token_All_Access_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_System_ACESize ] ;
			if ( s_Token_All_Access_System_ACE )
			{
				CopySid ( t_SidLength, (PSID) & s_Token_All_Access_System_ACE->SidStart, t_System_Sid ) ;
				s_Token_All_Access_System_ACE->Mask = TOKEN_ALL_ACCESS ;
				s_Token_All_Access_System_ACE->Header.AceType = 0 ;
				s_Token_All_Access_System_ACE->Header.AceFlags = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE ; ;
				s_Token_All_Access_System_ACE->Header.AceSize = s_System_ACESize ;
			}
			else
			{
				t_Result = E_OUTOFMEMORY ;
			}
		}
		else
		{
			t_Result = E_OUTOFMEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = E_OUTOFMEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			1 ,
			SECURITY_LOCAL_SERVICE_RID,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_LocalService_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_LocalService_Sid );
			s_LocalService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

			s_Provider_LocalService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_LocalService_ACESize ] ;
			if ( s_Provider_LocalService_ACE )
			{
				CopySid ( t_SidLength, (PSID) & s_Provider_LocalService_ACE->SidStart, t_LocalService_Sid ) ;
				s_Provider_LocalService_ACE->Mask =  MASK_PROVIDER_BINDING_BIND ;
				s_Provider_LocalService_ACE->Header.AceType = 0 ;
				s_Provider_LocalService_ACE->Header.AceFlags = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE ; ;
				s_Provider_LocalService_ACE->Header.AceSize = s_LocalService_ACESize ;

				s_Token_All_Access_LocalService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_LocalService_ACESize ] ;
				if ( s_Token_All_Access_LocalService_ACE )
				{
					CopySid ( t_SidLength, (PSID) & s_Token_All_Access_LocalService_ACE->SidStart, t_LocalService_Sid ) ;
					s_Token_All_Access_LocalService_ACE->Mask =  TOKEN_ALL_ACCESS ;
					s_Token_All_Access_LocalService_ACE->Header.AceType = 0 ;
					s_Token_All_Access_LocalService_ACE->Header.AceFlags = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE ; ;
					s_Token_All_Access_LocalService_ACE->Header.AceSize = s_LocalService_ACESize ;
				}
				else
				{
					t_Result = E_OUTOFMEMORY ;
				}
			}
			else
			{
				t_Result = E_OUTOFMEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = E_OUTOFMEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			1 ,
			SECURITY_NETWORK_SERVICE_RID,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_NetworkService_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_NetworkService_Sid );
			s_NetworkService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

			s_Provider_NetworkService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_NetworkService_ACESize ] ;
			if ( s_Provider_NetworkService_ACE )
			{
				CopySid ( t_SidLength, (PSID) & s_Provider_NetworkService_ACE->SidStart, t_NetworkService_Sid ) ;
				s_Provider_NetworkService_ACE->Mask =  MASK_PROVIDER_BINDING_BIND ;
				s_Provider_NetworkService_ACE->Header.AceType = 0 ;
				s_Provider_NetworkService_ACE->Header.AceFlags = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE ;
				s_Provider_NetworkService_ACE->Header.AceSize = s_NetworkService_ACESize ;

				s_Token_All_Access_NetworkService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_NetworkService_ACESize ] ;
				if ( s_Token_All_Access_NetworkService_ACE )
				{
					CopySid ( t_SidLength, (PSID) & s_Token_All_Access_NetworkService_ACE->SidStart, t_NetworkService_Sid ) ;
					s_Token_All_Access_NetworkService_ACE->Mask =  TOKEN_ALL_ACCESS ;
					s_Token_All_Access_NetworkService_ACE->Header.AceType = 0 ;
					s_Token_All_Access_NetworkService_ACE->Header.AceFlags = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE ; ;
					s_Token_All_Access_NetworkService_ACE->Header.AceSize = s_NetworkService_ACESize ;
				}
				else
				{
					t_Result = E_OUTOFMEMORY ;
				}

			}
			else
			{
				t_Result = E_OUTOFMEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = E_OUTOFMEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			2 ,
			SECURITY_BUILTIN_DOMAIN_RID ,
			DOMAIN_ALIAS_RID_ADMINS ,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_LocalAdmins_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_LocalAdmins_Sid );
			s_LocalAdmins_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

			s_Provider_LocalAdmins_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_LocalAdmins_ACESize ] ;
			if ( s_Provider_LocalAdmins_ACE )
			{
				CopySid ( t_SidLength, (PSID) & s_Provider_LocalAdmins_ACE->SidStart, t_LocalAdmins_Sid ) ;
				s_Provider_LocalAdmins_ACE->Mask =  MASK_PROVIDER_BINDING_BIND ;
				s_Provider_LocalAdmins_ACE->Header.AceType = 0 ;
				s_Provider_LocalAdmins_ACE->Header.AceFlags = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE ; ;
				s_Provider_LocalAdmins_ACE->Header.AceSize = s_LocalAdmins_ACESize ;

				s_Token_All_Access_LocalAdmins_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_LocalAdmins_ACESize ] ;
				if ( s_Token_All_Access_LocalAdmins_ACE )
				{
					CopySid ( t_SidLength, (PSID) & s_Token_All_Access_LocalAdmins_ACE->SidStart, t_LocalAdmins_Sid ) ;
					s_Token_All_Access_LocalAdmins_ACE->Mask =  TOKEN_ALL_ACCESS ;
					s_Token_All_Access_LocalAdmins_ACE->Header.AceType = 0 ;
					s_Token_All_Access_LocalAdmins_ACE->Header.AceFlags = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE ; ;
					s_Token_All_Access_LocalAdmins_ACE->Header.AceSize = s_LocalAdmins_ACESize ;
				}
				else
				{
					t_Result = E_OUTOFMEMORY ;
				}

			}
			else
			{
				t_Result = E_OUTOFMEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = E_OUTOFMEMORY ;
		}
	}

	if ( t_LocalAdmins_Sid )
	{
		FreeSid ( t_LocalAdmins_Sid ) ;
	}

	if ( t_System_Sid )
	{
		FreeSid ( t_System_Sid ) ;
	}

	if ( t_LocalService_Sid )
	{
		FreeSid ( t_LocalService_Sid ) ;
	}

	if ( t_NetworkService_Sid )
	{
		FreeSid ( t_NetworkService_Sid ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: DeleteSystemAces ()
{
	if ( s_Provider_System_ACE )
	{
		delete [] ( ( BYTE * ) s_Provider_System_ACE ) ;
		s_Provider_System_ACE = NULL;
	}

	if ( s_Provider_LocalService_ACE )
	{
		delete [] ( ( BYTE * ) s_Provider_LocalService_ACE ) ;
		s_Provider_LocalService_ACE = NULL;
	}

	if ( s_Provider_NetworkService_ACE )
	{
		delete [] ( ( BYTE * ) s_Provider_NetworkService_ACE ) ;
		s_Provider_NetworkService_ACE = NULL;
	}

	if ( s_Provider_LocalAdmins_ACE )
	{
		delete [] ( ( BYTE * ) s_Provider_LocalAdmins_ACE ) ;
		s_Provider_LocalAdmins_ACE = NULL;
	}

	if ( s_Token_All_Access_System_ACE )
	{
		delete [] ( ( BYTE * ) s_Token_All_Access_System_ACE ) ;
		s_Token_All_Access_System_ACE = NULL;
	}

	if ( s_Token_All_Access_LocalService_ACE )
	{
		delete [] ( ( BYTE * ) s_Token_All_Access_LocalService_ACE ) ;
		s_Token_All_Access_LocalService_ACE = NULL;
	}

	if ( s_Token_All_Access_NetworkService_ACE )
	{
		delete [] ( ( BYTE * ) s_Token_All_Access_NetworkService_ACE ) ;
		s_Token_All_Access_NetworkService_ACE = NULL;
	}

	if ( s_Token_All_Access_LocalAdmins_ACE )
	{
		delete [] ( ( BYTE * ) s_Token_All_Access_LocalAdmins_ACE ) ;
		s_Token_All_Access_LocalAdmins_ACE = NULL;
	}

	return S_OK ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CheckAccess ( 

	SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
	DWORD a_Access , 
	GENERIC_MAPPING *a_Mapping
)
{
	HRESULT t_Result = S_OK ;

	if ( a_SecurityDescriptor )	
	{
		t_Result = CoImpersonateClient () ;
		if ( SUCCEEDED ( t_Result ) || t_Result == RPC_E_CALL_COMPLETE )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Check_SecurityDescriptor_CallIdentity (

				a_SecurityDescriptor , 
				a_Access ,
				a_Mapping
			) ;

			CoRevertToSelf () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetUserSid (

	HANDLE a_Token ,
	ULONG *a_Size ,
	PSID &a_Sid
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

    if ( a_Token )
	{
		if ( a_Size ) 
		{
			TOKEN_USER *t_TokenUser = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenUser ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						t_TokenUser = ( TOKEN_USER * ) new BYTE [ t_ReturnLength ] ;
						if ( t_TokenUser )
						{
							t_TokenStatus = GetTokenInformation (

								a_Token ,
								t_TokenInformationClass ,
								t_TokenUser ,
								t_ReturnLength ,
								& t_ReturnLength
							) ;

							if ( t_TokenStatus )
							{
								DWORD t_SidLength = GetLengthSid ( t_TokenUser->User.Sid ) ;
								*a_Size = t_SidLength ;

								a_Sid = new BYTE [ t_SidLength ] ;
								if ( a_Sid )
								{
									CopyMemory ( a_Sid , t_TokenUser->User.Sid , t_SidLength ) ;

									t_Result = S_OK ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							delete [] t_TokenUser ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetGroupSid (

	HANDLE a_Token ,
	ULONG *a_Size ,
	PSID &a_Sid
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

    if ( a_Token )
	{
		if ( a_Size ) 
		{
			TOKEN_PRIMARY_GROUP *t_TokenGroup = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenPrimaryGroup ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenGroup ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						t_TokenGroup = ( TOKEN_PRIMARY_GROUP * ) new BYTE [ t_ReturnLength ] ;
						if ( t_TokenGroup )
						{
							t_TokenStatus = GetTokenInformation (

								a_Token ,
								t_TokenInformationClass ,
								t_TokenGroup ,
								t_ReturnLength ,
								& t_ReturnLength
							) ;

							if ( t_TokenStatus )
							{
								DWORD t_SidLength = GetLengthSid ( t_TokenGroup->PrimaryGroup ) ;
								*a_Size = t_SidLength ;

								a_Sid = new BYTE [ t_SidLength ] ;
								if ( a_Sid )
								{
									CopyMemory ( a_Sid , t_TokenGroup->PrimaryGroup , t_SidLength ) ;

									t_Result = S_OK ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							delete [] t_TokenGroup ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetAceWithProcessTokenUser ( 
					
	DWORD a_ProcessIdentifier ,
	WORD &a_AceSize ,
	ACCESS_ALLOWED_ACE *&a_Ace 
)
{
	HRESULT t_Result = WBEM_E_ACCESS_DENIED ;

	HANDLE t_ProcessHandle = OpenProcess (

		MAXIMUM_ALLOWED ,
		FALSE ,
		a_ProcessIdentifier 
	) ;

	if ( t_ProcessHandle )
	{
		HANDLE t_ProcessToken = NULL ;
		BOOL t_Status = OpenProcessToken (
			t_ProcessHandle ,
			TOKEN_QUERY,
			& t_ProcessToken
		) ;

		if ( t_Status )
		{
			DWORD t_OwnerSize = 0 ; 
			PSID t_OwnerSid = NULL ;
			BOOL t_OwnerDefaulted = FALSE ;

			t_Result = GetUserSid (

				t_ProcessToken ,
				& t_OwnerSize , 
				t_OwnerSid 
			) ; 

			if ( SUCCEEDED ( t_Result ) ) 
			{
				ACCESS_ALLOWED_ACE *t_Ace = NULL ;
				DWORD t_AceSize = 0 ;

				t_AceSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_OwnerSize - sizeof(DWORD) ) ;
				t_Ace = (ACCESS_ALLOWED_ACE*) new BYTE [ t_AceSize ] ;
				if ( t_Ace )
				{
					CopySid ( t_OwnerSize, (PSID) & t_Ace->SidStart, t_OwnerSid ) ;
					t_Ace->Mask = TOKEN_ALL_ACCESS ;
					t_Ace->Header.AceType = 0 ;
					t_Ace->Header.AceFlags = 0 ;
					t_Ace->Header.AceSize = t_AceSize ;

					a_Ace = t_Ace ;
					a_AceSize = t_AceSize ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				delete [] ( BYTE * ) t_OwnerSid ;
			}

			CloseHandle ( t_ProcessToken ) ;
		}

		CloseHandle ( t_ProcessHandle ) ;
	}
	else
		t_Result = MAKE_HRESULT(1, FACILITY_WIN32, RPC_S_SERVER_UNAVAILABLE);

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SinkAccessInitialize (

	SECURITY_DESCRIPTOR *a_RegistrationSecurityDescriptor ,
	SECURITY_DESCRIPTOR *&a_SinkSecurityDescriptor
)
{
	HRESULT t_Result = CoImpersonateClient () ;
        HANDLE t_Token = NULL ;
        BOOL t_Status = FALSE;

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Status = OpenThreadToken (

			GetCurrentThread () ,
			TOKEN_QUERY,
			TRUE ,
			&t_Token
		) ;

		CoRevertToSelf ();
                if (!t_Status)
                {
			t_Result = WBEM_E_ACCESS_DENIED;
                }
        }
        else if ( t_Result == RPC_E_CALL_COMPLETE )
        {
        	t_Status = OpenProcessToken(

                	GetCurrentProcess () ,
 			TOKEN_QUERY ,
			&t_Token
		);

		if ( !t_Status )
		{
			t_Result = WBEM_E_ACCESS_DENIED;
		}
        }

	if ( t_Status )
	{
		DWORD t_OwnerSize = 0 ; 
		PSID t_OwnerSid = NULL ;
		BOOL t_OwnerDefaulted = FALSE ;

		t_Result = GetUserSid (

			t_Token ,
			& t_OwnerSize , 
			t_OwnerSid 
		) ; 

		if ( SUCCEEDED ( t_Result ) )
		{
			DWORD t_GroupSize = 0 ; 
			PSID t_GroupSid = NULL ;
			BOOL t_GroupDefaulted = FALSE ;

			t_Result = GetGroupSid (

				t_Token ,
				& t_GroupSize , 
				t_GroupSid 
			) ; 

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = ProviderSubSystem_Common_Globals :: AdjustSecurityDescriptorWithSid ( 

					( SID * ) t_OwnerSid ,
					( SID * ) t_GroupSid ,
					MASK_PROVIDER_BINDING_BIND ,
					a_RegistrationSecurityDescriptor , 
					a_SinkSecurityDescriptor
				) ;

				delete [] ( BYTE * ) t_GroupSid ;
			}

			delete [] ( BYTE * ) t_OwnerSid ;
		}
		else
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		CloseHandle ( t_Token ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CreateMethodSecurityDescriptor ()
{
	HRESULT t_Result = S_OK ;

	BOOL t_Status = ConvertStringSecurityDescriptorToSecurityDescriptor (

		L"O:BAG:BAD:(A;;0x10000001;;;BA)(A;;0x10000001;;;SY)(A;;0x10000001;;;LA)(A;;0x10000001;;;S-1-5-20)(A;;0x10000001;;;S-1-5-19)" ,
		SDDL_REVISION_1 ,
		( PSECURITY_DESCRIPTOR * ) & s_MethodSecurityDescriptor ,
		NULL 
	) ;

	if ( t_Status )
	{
		t_Status = ConvertStringSecurityDescriptorToSecurityDescriptor (

			L"O:BAG:BAD:(A;;0x10000001;;;BA)(A;;0x10000001;;;SY)(A;;0x10000001;;;LA)(A;;0x10000001;;;S-1-5-20)(A;;0x10000001;;;S-1-5-19)"
			L"(A;;0x10000001;;;S-1-5-3) (A;;0x10000001;;;S-1-5-6)",
			SDDL_REVISION_1 ,
			( PSECURITY_DESCRIPTOR * ) & s_DefaultDecoupledSD ,
			NULL 
		) ;
		if ( t_Status )
		{
		}
		else
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}			
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: DeleteMethodSecurityDescriptor ()
{
	if ( s_MethodSecurityDescriptor	)
	{
		LocalFree ( s_MethodSecurityDescriptor ) ;
		s_MethodSecurityDescriptor = NULL;

	}
	if ( s_DefaultDecoupledSD)
	{
		LocalFree ( s_DefaultDecoupledSD ) ;
		s_DefaultDecoupledSD = NULL;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD ProviderSubSystem_Common_Globals :: InitializeTransmitSize ()
{	
	s_TransmitBufferSize = SYNCPROV_BATCH_TRANSMIT_SIZE ;

	HKEY t_ConfigRoot ;

	LONG t_RegResult = RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		L"Software\\Microsoft\\WBEM\\CIMOM" ,
		0 ,
		KEY_READ ,
		& t_ConfigRoot 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		DWORD t_ValueType = REG_DWORD ;
		DWORD t_DataSize = sizeof ( s_TransmitBufferSize ) ;

		t_RegResult = RegQueryValueEx (

		  t_ConfigRoot ,
		  L"Sink Transmit Buffer Size" ,
		  0 ,
		  & t_ValueType ,
		  LPBYTE ( & s_TransmitBufferSize ) ,
		  & t_DataSize 
		);

		if ( t_RegResult == ERROR_SUCCESS )
		{
		}

		RegCloseKey ( t_ConfigRoot ) ;
	}

	return s_TransmitBufferSize ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#ifdef IA64
#define RPC_STACK_COMMIT_SIZE 8192 * 8
#else
#define RPC_STACK_COMMIT_SIZE 4096 * 8
#endif

#define REGSTR_PATH_SVCHOST     TEXT("Software\\Microsoft\\Wbem\\Cimom")

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD ProviderSubSystem_Common_Globals :: InitializeDefaultStackSize ()
{	
	s_DefaultStackSize = RPC_STACK_COMMIT_SIZE ;

	HKEY t_ConfigRoot ;

	LONG t_RegResult = RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		REGSTR_PATH_SVCHOST ,
		0 ,
		KEY_READ ,
		& t_ConfigRoot 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		DWORD t_ValueType = REG_DWORD ;
		DWORD t_Value = 0 ;
		DWORD t_DataSize = sizeof ( t_Value ) ;

		t_RegResult = RegQueryValueEx (

		  t_ConfigRoot ,
		  L"DefaultRpcStackSize" ,
		  0 ,
		  & t_ValueType ,
		  LPBYTE ( & t_Value ) ,
		  & t_DataSize 
		);

		if ( t_RegResult == ERROR_SUCCESS )
		{
			s_DefaultStackSize = t_Value * 1024 ;
		}

		RegCloseKey ( t_ConfigRoot ) ;
	}

	return s_DefaultStackSize ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\common\provobjectsink.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <stdio.h>

#include "CGlobals.h"
#include "ProvObjectSink.h"

#include <wbemutil.h>

#ifdef DBG
fn__uncaught_exception InterlockedGuard::__uncaught_exception = NULL;
InterlockedGuard::FunctLoader InterlockedGuard::FunctLoader_;
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CCommon_IWbemSyncObjectSink :: CCommon_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	ObjectSinkContainerElement ( 

			a_Controller ,
			a_InterceptedSink
		) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( 0 ) ,
		m_InProgress ( 0 ) ,
		m_Unknown ( a_Unknown ) ,
		m_StatusCalled ( FALSE ) ,
		m_Dependant ( a_Dependant )
{
	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CCommon_IWbemSyncObjectSink :: ~CCommon_IWbemSyncObjectSink ()
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CCommon_IWbemSyncObjectSink :: CallBackInternalRelease ()
{
	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 0 , 0 ) )
	{
		m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_UNEXPECTED ,
			NULL ,
			NULL
		) ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CCommon_IWbemSyncObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CCommon_IWbemSyncObjectSink :: AddRef ( void )
{
	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CCommon_IWbemSyncObjectSink :: Release ( void )
{
	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: SinkInitialize ()
{
	HRESULT t_Result = S_OK ;
	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

    InterlockedGuard ig(&m_InProgress);

	if ( m_GateClosed )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = Helper_Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;

#ifdef DBG
		if ( FAILED ( t_Result ) )
		{
			DbgPrintfA(0,"CCommon_IWbemSyncObjectSink :: Indicate - %08x",t_Result) ;
		}
#endif
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Helper_Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = m_InterceptedSink->Indicate (

		a_ObjectCount ,
		a_ObjectArray
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Helper_SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_StringParam = NULL ;
	if ( a_StringParam )
	{
		t_StringParam = SysAllocString ( a_StringParam ) ;
		if ( t_StringParam == NULL )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = m_InterceptedSink->SetStatus (

			a_Flags ,
			a_Result ,
			t_StringParam ,
			a_ObjectParam
		) ;

		SysFreeString ( t_StringParam ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

    InterlockedGuard ig(&m_InProgress);

	if ( m_GateClosed )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		switch ( a_Flags )
		{
			case WBEM_STATUS_PROGRESS:
			{
				t_Result = Helper_SetStatus ( 

					a_Flags ,
					a_Result ,
					a_StringParam ,
					a_ObjectParam
				) ;
			}
			break ;

			case WBEM_STATUS_COMPLETE:
			{
				if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
				{
					t_Result = Helper_SetStatus ( 

						a_Flags ,
						a_Result ,
						a_StringParam ,
						a_ObjectParam
					) ;
				}
			}
			break ;

			default:
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
			break ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
	{
		t_Result = Helper_SetStatus ( 

			0 ,
			WBEM_E_SHUTTING_DOWN ,
			NULL ,
			NULL
		) ;
	}

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CCommon_Batching_IWbemSyncObjectSink :: CCommon_Batching_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_IWbemSyncObjectSink ( 

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Queue ( a_Allocator ) ,
		m_Size ( 0 ),
		m_CriticalSection(NOTHROW_LOCK)
{
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CCommon_Batching_IWbemSyncObjectSink :: ~CCommon_Batching_IWbemSyncObjectSink ()
{

    ULONG t_Count = m_Queue.Size();
	for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
	{
		IWbemClassObject *t_ClassObject ;
		WmiStatusCode t_StatusCode = m_Queue.Top ( t_ClassObject ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_ClassObject->Release () ;

			t_StatusCode = m_Queue.DeQueue () ;
		}
	}
	m_Queue.UnInitialize () ;

	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection );
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_Batching_IWbemSyncObjectSink :: SinkInitialize ()
{
	HRESULT t_Result = CCommon_IWbemSyncObjectSink :: SinkInitialize () ;
	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection );
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = m_Queue.Initialize () ;
			if ( t_StatusCode == e_StatusCode_Success )
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

class CReleaseMe 
{
private:
	IUnknown * m_pUnk;
public:
	CReleaseMe(IUnknown * pUnk):m_pUnk(pUnk){};
	~CReleaseMe(){ m_pUnk->Release(); };
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_Batching_IWbemSyncObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	if ( m_GateClosed == 0 )
	{
		WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection , FALSE ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			for ( LONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < a_ObjectCount ) ; t_Index ++ )
			{
				if ( a_ObjectArray [ t_Index ] )
				{
					IWbemClassObject *t_ClonedObject = NULL ;
					t_Result = a_ObjectArray [ t_Index ]->Clone ( &t_ClonedObject ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
    					CReleaseMe rmCloned(t_ClonedObject);
    					
						ULONG t_ObjectSize = 0 ;
						_IWmiObject *t_Object ;
						HRESULT t_TempResult = t_ClonedObject->QueryInterface ( IID__IWmiObject , ( void ** ) & t_Object ) ;
						if ( SUCCEEDED ( t_TempResult ) )
						{
    						CReleaseMe rmQIed(t_Object);
    						
							t_TempResult = t_Object->GetObjectMemory (

								NULL ,
								0 ,
								& t_ObjectSize
							);

							if ( t_TempResult == WBEM_E_BUFFER_TOO_SMALL )
							{

								WmiStatusCode t_StatusCode = m_Queue.EnQueue ( t_ClonedObject ) ;
								if ( t_StatusCode == e_StatusCode_Success )
								{
 									t_ClonedObject ->AddRef();
									m_Size = m_Size + t_ObjectSize ;
								}			
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							
								if ( SUCCEEDED(t_Result) && 
								   (( m_Size ) >= ProviderSubSystem_Common_Globals :: GetTransmitSize () ))
								{
									ULONG t_Count = m_Queue.Size () ;
									IWbemClassObject **t_Array = new IWbemClassObject * [ t_Count ] ;
									if ( t_Array )
									{
										IWbemClassObject *t_ClassObject ;
										WmiStatusCode t_StatusCode ;

										ULONG t_InnerIndex = 0 ;
										while ( ( t_StatusCode = m_Queue.Top ( t_ClassObject ) ) == e_StatusCode_Success )
										{
											t_Array [ t_InnerIndex ] = t_ClassObject ;

											t_InnerIndex ++ ;

											t_StatusCode = m_Queue.DeQueue() ;
										}

										m_Size = 0 ;

										WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

										t_Result = CCommon_IWbemSyncObjectSink :: Indicate ( t_Count , t_Array ) ;

										for ( t_InnerIndex = 0 ; t_InnerIndex < t_Count ; t_InnerIndex ++ )
										{
											t_Array [ t_InnerIndex ]->Release () ;
										}

										delete [] t_Array ;

										t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection , FALSE ) ;
										if ( t_StatusCode == e_StatusCode_Success )
										{
										}
										else
										{
											t_Result = WBEM_E_OUT_OF_MEMORY ;
										}
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_CRITICAL_ERROR ;
							}
						}
						else
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
				}
			}

			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );

			return t_Result ;
		}
		else
		{
			return WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		return WBEM_E_SHUTTING_DOWN ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_Batching_IWbemSyncObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	switch ( a_Flags )
	{
		case WBEM_STATUS_COMPLETE:
		{
			if ( m_GateClosed == 0 )
			{
				WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection , FALSE );
				if ( t_StatusCode == e_StatusCode_Success )
				{
					LONG t_Count = m_Queue.Size () ;
					if ( t_Count )
					{
						IWbemClassObject **t_Array = new IWbemClassObject * [ m_Queue.Size () ] ;
						if ( t_Array )
						{
							for ( LONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
							{
								IWbemClassObject *t_ClassObject ;
								WmiStatusCode t_StatusCode = m_Queue.Top ( t_ClassObject ) ;
								if ( t_StatusCode == e_StatusCode_Success )
								{
									t_Array [ t_Index ] = t_ClassObject ;

									t_StatusCode = m_Queue.DeQueue () ;
								}
							}

							WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );

							t_Result = CCommon_IWbemSyncObjectSink :: Indicate ( t_Count , t_Array ) ;

							for ( t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
							{
								if ( t_Array [ t_Index ] )
								{
									t_Array [ t_Index ]->Release () ;
								}
							}

							delete [] t_Array ;
						}
						else
						{
							WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				a_Result = t_Result ;
			}

			t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

				a_Flags , 
				a_Result , 
				a_StringParam ,	
				a_ObjectParam
			) ;
		}
		break ;

		default:
		{
			t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

				a_Flags , 
				a_Result , 
				a_StringParam ,	
				a_ObjectParam
			) ;
		}
		break ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\common\provregdecoupled.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"

#include <typeinfo.h>
#include <stdio.h>
#include <Aclapi.h>

#include <wbemint.h>
#include <HelperFuncs.h>
#include <Logging.h>

#include <HelperFuncs.h>
#include "CGlobals.h"
#include "ProvRegDeCoupled.h"
#include "DateTime.h"
#include <scopeguard.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT SetSecurity ( HKEY a_Key , DWORD a_Access ) 
{

	HRESULT t_Result = S_OK ;

	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

	PSID t_Administrator_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Administrator_ACE = NULL ;
	DWORD t_Administrator_ACESize = 0 ;

	BOOL t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		2 ,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Administrator_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Administrator_Sid );
		t_Administrator_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Administrator_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Administrator_ACESize ] ;
		if ( t_Administrator_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Administrator_ACE->SidStart, t_Administrator_Sid ) ;
			t_Administrator_ACE->Mask = 0x1F01FF;
			t_Administrator_ACE->Header.AceType = 0 ;
			t_Administrator_ACE->Header.AceFlags = 3 ;
			t_Administrator_ACE->Header.AceSize = t_Administrator_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	PSID t_System_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_System_ACE = NULL ;
	DWORD t_System_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_LOCAL_SYSTEM_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_System_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
		t_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_System_ACESize ] ;
		if ( t_System_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_System_ACE->SidStart, t_System_Sid ) ;
			t_System_ACE->Mask = 0x1F01FF;
			t_System_ACE->Header.AceType = 0 ;
			t_System_ACE->Header.AceFlags = 3 ;
			t_System_ACE->Header.AceSize = t_System_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	PSID t_PowerUsers_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_PowerUsers_ACE = NULL ;
	DWORD t_PowerUsers_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		2 ,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_POWER_USERS,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_PowerUsers_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_PowerUsers_Sid );
		t_PowerUsers_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_PowerUsers_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_PowerUsers_ACESize ] ;
		if ( t_PowerUsers_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_PowerUsers_ACE->SidStart, t_PowerUsers_Sid ) ;
			t_PowerUsers_ACE->Mask = GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE ;
			t_PowerUsers_ACE->Header.AceType = 0 ;
			t_PowerUsers_ACE->Header.AceFlags = 3 ;
			t_PowerUsers_ACE->Header.AceSize = t_PowerUsers_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	SID_IDENTIFIER_AUTHORITY t_WorldAuthoritySid = SECURITY_WORLD_SID_AUTHORITY ;

	PSID t_Everyone_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Everyone_ACE = NULL ;
	DWORD t_Everyone_ACESize = 0 ;
	
	t_BoolResult = AllocateAndInitializeSid (

		& t_WorldAuthoritySid ,
		1 ,
		SECURITY_WORLD_RID ,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Everyone_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Everyone_Sid );
		t_Everyone_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Everyone_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Everyone_ACESize ] ;
		if ( t_Everyone_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Everyone_ACE->SidStart, t_Everyone_Sid ) ;
			t_Everyone_ACE->Mask = a_Access ;
			t_Everyone_ACE->Header.AceType = 0 ;
			t_Everyone_ACE->Header.AceFlags = 3 ;
			t_Everyone_ACE->Header.AceSize = t_Everyone_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	// Now we need to set permissions on the registry: Everyone read; Admins full.
	// We have the sid for admins from the above code.  Now get the sid for "Everyone"

	DWORD t_TotalAclSize = sizeof(ACL) + t_Administrator_ACESize + t_System_ACESize + t_Everyone_ACESize ;
	PACL t_Dacl = (PACL) new BYTE [ t_TotalAclSize ] ;
	if ( t_Dacl )
	{
		if ( :: InitializeAcl ( t_Dacl, t_TotalAclSize, ACL_REVISION ) )
		{
			DWORD t_AceIndex = 0 ;

			if ( t_Everyone_ACESize && :: AddAce ( t_Dacl , ACL_REVISION, t_AceIndex , t_Everyone_ACE , t_Everyone_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			if ( t_System_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_System_ACE , t_System_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			
			if ( t_Administrator_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_Administrator_ACE , t_Administrator_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			SECURITY_INFORMATION t_SecurityInfo = 0L;

			t_SecurityInfo |= DACL_SECURITY_INFORMATION;
			t_SecurityInfo |= PROTECTED_DACL_SECURITY_INFORMATION;

			SECURITY_DESCRIPTOR t_SecurityDescriptor ;
			t_BoolResult = InitializeSecurityDescriptor ( & t_SecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
			if ( t_BoolResult )
			{
				t_BoolResult = SetSecurityDescriptorDacl (

				  & t_SecurityDescriptor ,
				  TRUE ,
				  t_Dacl ,
				  FALSE
				) ;

				if ( t_BoolResult )
				{
					LONG t_SetStatus = RegSetKeySecurity (

					  a_Key ,
					  t_SecurityInfo ,
					  & t_SecurityDescriptor
					) ;

					if ( t_SetStatus != ERROR_SUCCESS )
					{
						DWORD t_LastError = GetLastError () ;

						t_Result = WBEM_E_ACCESS_DENIED ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;	
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;	
			}
		}

		delete [] ( ( BYTE * ) t_Dacl ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_Administrator_ACE )
	{
		delete [] ( ( BYTE * ) t_Administrator_ACE ) ;
	}

	if ( t_PowerUsers_ACE )
	{
		delete [] ( ( BYTE * ) t_PowerUsers_ACE ) ;
	}

	if ( t_Everyone_ACE )
	{
		delete [] ( ( BYTE * ) t_Everyone_ACE ) ;
	}

	if ( t_System_ACE )
	{
		delete [] ( ( BYTE * ) t_System_ACE ) ;
	}

	if ( t_System_Sid )
	{
		FreeSid ( t_System_Sid ) ;
	}

	if ( t_Administrator_Sid )
	{
		FreeSid ( t_Administrator_Sid ) ;
	}
	
	if ( t_PowerUsers_Sid )
	{
		FreeSid ( t_PowerUsers_Sid ) ;
	}

	if ( t_Everyone_Sid )
	{
		FreeSid ( t_Everyone_Sid ) ;
	}

	return t_Result ;
}



HRESULT SetClientSecurity ( HKEY a_Key) 
{
	HRESULT t_Result = S_OK ;

	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

	PSID t_Administrator_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Administrator_ACE = NULL ;
	DWORD t_Administrator_ACESize = 0 ;

	BOOL t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		2 ,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Administrator_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Administrator_Sid );
		t_Administrator_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Administrator_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Administrator_ACESize ] ;
		if ( t_Administrator_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Administrator_ACE->SidStart, t_Administrator_Sid ) ;
			t_Administrator_ACE->Mask = 0x1F01FF;
			t_Administrator_ACE->Header.AceType = 0 ;
			t_Administrator_ACE->Header.AceFlags = 3 ;
			t_Administrator_ACE->Header.AceSize = t_Administrator_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	PSID t_System_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_System_ACE = NULL ;
	DWORD t_System_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_LOCAL_SYSTEM_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_System_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
		t_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_System_ACESize ] ;
		if ( t_System_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_System_ACE->SidStart, t_System_Sid ) ;
			t_System_ACE->Mask = 0x1F01FF;
			t_System_ACE->Header.AceType = 0 ;
			t_System_ACE->Header.AceFlags = 3 ;
			t_System_ACE->Header.AceSize = t_System_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}


	ACCESS_ALLOWED_ACE *t_LocalService_ACE = NULL ;
	DWORD t_LocalService_ACESize = 0 ;
	
	{
	PSID t_LocalService_Sid = NULL ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_LOCAL_SERVICE_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_LocalService_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_LocalService_Sid );
		t_LocalService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_LocalService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_LocalService_ACESize ] ;
		if ( t_LocalService_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_LocalService_ACE->SidStart, t_LocalService_Sid ) ;
			t_LocalService_ACE->Mask = 0x1F01FF;
			t_LocalService_ACE->Header.AceType = 0 ;
			t_LocalService_ACE->Header.AceFlags = 3 ;
			t_LocalService_ACE->Header.AceSize = t_LocalService_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
		FreeSid(t_LocalService_Sid);
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}
	}

	ACCESS_ALLOWED_ACE *t_NetworkService_ACE = NULL ;
	DWORD t_NetworkService_ACESize = 0 ;

	{
	PSID t_NetworkService_Sid = NULL ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_NETWORK_SERVICE_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_NetworkService_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
		t_NetworkService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_NetworkService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_NetworkService_ACESize ] ;
		if ( t_NetworkService_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_NetworkService_ACE->SidStart, t_NetworkService_Sid ) ;
			t_NetworkService_ACE->Mask = 0x1F01FF;
			t_NetworkService_ACE->Header.AceType = 0 ;
			t_NetworkService_ACE->Header.AceFlags = 3 ;
			t_NetworkService_ACE->Header.AceSize = t_NetworkService_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
		FreeSid(t_NetworkService_Sid);		
	}
	else
	{
		DWORD t_LastError = ::GetLastError();
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	}
	
	SID_IDENTIFIER_AUTHORITY t_WorldAuthoritySid = SECURITY_WORLD_SID_AUTHORITY ;

	PSID t_Everyone_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Everyone_ACE = NULL ;
	DWORD t_Everyone_ACESize = 0 ;
	
	t_BoolResult = AllocateAndInitializeSid (

		& t_WorldAuthoritySid ,
		1 ,
		SECURITY_WORLD_RID ,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Everyone_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Everyone_Sid );
		t_Everyone_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Everyone_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Everyone_ACESize ] ;
		if ( t_Everyone_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Everyone_ACE->SidStart, t_Everyone_Sid ) ;
            		t_Everyone_ACE->Mask = KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS | KEY_SET_VALUE | READ_CONTROL | KEY_QUERY_VALUE ; // JeffCoop: added KEY_SET_VALUE | READ_CONTROL | KEY_QUERY_VALUE
			t_Everyone_ACE->Header.AceType = 0 ;
		        t_Everyone_ACE->Header.AceFlags = 0 ; // JeffCoop: was '3' ;
			t_Everyone_ACE->Header.AceSize = t_Everyone_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}


	SID_IDENTIFIER_AUTHORITY t_OwnerAuthoritySid = SECURITY_CREATOR_SID_AUTHORITY;
	PSID t_Owner_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Owner_ACE = NULL ;
	DWORD t_Owner_ACESize = 0 ;
	
	t_BoolResult = AllocateAndInitializeSid (

		& t_OwnerAuthoritySid ,
		1 ,
		SECURITY_CREATOR_OWNER_RID ,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Owner_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Owner_Sid );
		t_Owner_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Owner_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Owner_ACESize ] ;
		if ( t_Owner_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Owner_ACE->SidStart, t_Owner_Sid ) ;
			t_Owner_ACE->Mask = KEY_ALL_ACCESS ;
			t_Owner_ACE->Header.AceType = ACCESS_ALLOWED_ACE_TYPE ;
		        t_Owner_ACE->Header.AceFlags = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | NO_PROPAGATE_INHERIT_ACE | INHERIT_ONLY_ACE ; // JeffCoop: added NO_PROPAGATE_INHERIT_ACE | INHERIT_ONLY_ACE
			t_Owner_ACE->Header.AceSize = t_Owner_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	// Now we need to set permissions on the registry: Everyone read; Admins full.
	// We have the sid for admins from the above code.  Now get the sid for "Everyone"

	DWORD t_TotalAclSize = sizeof(ACL) + t_Administrator_ACESize + t_Owner_ACESize + t_Everyone_ACESize + t_System_ACESize+
							t_LocalService_ACESize + t_NetworkService_ACESize;
	PACL t_Dacl = (PACL) new BYTE [ t_TotalAclSize ] ;
	if ( t_Dacl )
	{
		if ( :: InitializeAcl ( t_Dacl, t_TotalAclSize, ACL_REVISION ) )
		{
			DWORD t_AceIndex = 0 ;

			if ( t_Everyone_ACESize && :: AddAce ( t_Dacl , ACL_REVISION, t_AceIndex , t_Everyone_ACE , t_Everyone_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			if ( t_Owner_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_Owner_ACE , t_Owner_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			
			if ( t_Administrator_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_Administrator_ACE , t_Administrator_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			if ( t_System_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_System_ACE , t_System_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			if ( t_LocalService_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_LocalService_ACE , t_LocalService_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			if ( t_NetworkService_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_NetworkService_ACE , t_NetworkService_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			SECURITY_INFORMATION t_SecurityInfo = 0L;

			t_SecurityInfo |= DACL_SECURITY_INFORMATION;

			SECURITY_DESCRIPTOR t_SecurityDescriptor ;
			t_BoolResult = InitializeSecurityDescriptor ( & t_SecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
			if ( t_BoolResult )
			{
				t_BoolResult = SetSecurityDescriptorDacl (

				  & t_SecurityDescriptor ,
				  TRUE ,
				  t_Dacl ,
				  FALSE
				) ;

				if ( t_BoolResult )
				{
					LONG t_SetStatus = RegSetKeySecurity (

					  a_Key ,
					  t_SecurityInfo ,
					  & t_SecurityDescriptor
					) ;

					if ( t_SetStatus != ERROR_SUCCESS )
					{
						DWORD t_LastError = GetLastError () ;

						t_Result = WBEM_E_ACCESS_DENIED ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;	
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;	
			}
		}

		delete [] ( ( BYTE * ) t_Dacl ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_Administrator_ACE )
	{
		delete [] ( ( BYTE * ) t_Administrator_ACE ) ;
	}

	if (t_Owner_ACE) delete [] ((BYTE *)t_Owner_ACE);
	if (t_Owner_Sid) FreeSid (t_Owner_Sid);

	if ( t_Everyone_ACE )
	{
		delete [] ( ( BYTE * ) t_Everyone_ACE ) ;
	}

	if ( t_System_ACE )
	{
		delete [] ( ( BYTE * ) t_System_ACE ) ;
	}

	if ( t_LocalService_ACE )
	{
		delete [] ( ( BYTE * ) t_LocalService_ACE ) ;
	}

	if ( t_NetworkService_ACE )
	{
		delete [] ( ( BYTE * ) t_NetworkService_ACE ) ;
	}
	
	if ( t_System_Sid )
	{
		FreeSid ( t_System_Sid ) ;
	}

	if ( t_Administrator_Sid )
	{
		FreeSid ( t_Administrator_Sid ) ;
	}
	


	if ( t_Everyone_Sid )
	{
		FreeSid ( t_Everyone_Sid ) ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Null = NULL ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Home = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_HomeClient = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled\\Client" ;

LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_CreationTime = L"CreationTime" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_User = L"User" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Locale = L"Locale" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Scope = L"Scope" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Provider = L"Provider" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_MarshaledProxy = L"MarshaledProxy" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_ProcessIdentifier = L"ProcessIdentifier" ;

LPCWSTR CServerObject_DecoupledClientRegistration :: s_Strings_Reg_Null = NULL ;
LPCWSTR CServerObject_DecoupledClientRegistration :: s_Strings_Reg_Home = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled" ;
LPCWSTR CServerObject_DecoupledClientRegistration :: s_Strings_Reg_HomeClient = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled\\Client" ;

LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_Null = NULL ;
LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_Home = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled" ;
LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_HomeServer = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled\\Server" ;

LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_CreationTime = L"CreationTime" ;
LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_ProcessIdentifier = L"ProcessIdentifier" ;
LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_MarshaledProxy = L"MarshaledProxy" ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration_Element :: CServerObject_DecoupledClientRegistration_Element ()

	:	m_Provider ( NULL ) ,
		m_Clsid ( NULL ) ,
		m_CreationTime ( NULL ) ,
		m_User ( NULL ) ,
		m_Locale ( NULL ) ,
		m_Scope ( NULL ) ,
		m_MarshaledProxy ( NULL ) ,
		m_MarshaledProxyLength ( 0 ) ,
		m_Result ( S_OK ) ,
		m_ProcessIdentifier ( 0 ) ,
		m_ReferenceCount ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration_Element :: ~CServerObject_DecoupledClientRegistration_Element ()
{
	Clear () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CServerObject_DecoupledClientRegistration_Element :: Clear () 
{
	if ( m_Provider )
	{
		SysFreeString ( m_Provider ) ;
		m_Provider = NULL ;
	}

	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
		m_CreationTime = NULL ;
	}

	if ( m_User )
	{
		SysFreeString ( m_User ) ;
		m_User = NULL ;
	}

	if ( m_Locale )
	{
		SysFreeString ( m_Locale ) ;
		m_Locale = NULL ;
	}

	if ( m_Scope )
	{
		SysFreeString ( m_Scope ) ;
		m_Scope = NULL ;
	}

	if ( m_Clsid ) 
	{
		SysFreeString ( m_Clsid ) ;
		m_Clsid = NULL ;
	}

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
		m_MarshaledProxy = NULL ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration_Element &CServerObject_DecoupledClientRegistration_Element :: operator= ( const CServerObject_DecoupledClientRegistration_Element &a_Key )
{
	if ( m_Provider )
	{
		SysFreeString ( m_Provider ) ;
		m_Provider = NULL ;
	}

	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
		m_CreationTime = NULL ;
	}

	if ( m_User )
	{
		SysFreeString ( m_User ) ;
		m_User = NULL ;
	}

	if ( m_Locale )
	{
		SysFreeString ( m_Locale ) ;
		m_Locale = NULL ;
	}

	if ( m_Scope )
	{
		SysFreeString ( m_Scope ) ;
		m_Scope = NULL ;
	}

	if ( m_Clsid ) 
	{
		SysFreeString ( m_Clsid ) ;
		m_Clsid = NULL ;
	}

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
		m_MarshaledProxy = NULL ;
	}

	if ( a_Key.m_Provider )
	{
		m_Provider = SysAllocString ( a_Key.m_Provider ) ;
	}

	if ( a_Key.m_CreationTime )
	{
		m_CreationTime = SysAllocString ( a_Key.m_CreationTime ) ;
	}

	if ( a_Key.m_User )
	{
		m_User = SysAllocString ( a_Key.m_User ) ;
	}

	if ( a_Key.m_Locale )
	{
		m_Locale = SysAllocString ( a_Key.m_Locale ) ;
	}

	if ( a_Key.m_Scope )
	{
		m_Scope = SysAllocString ( a_Key.m_Scope ) ;
	}

	if ( a_Key.m_Clsid ) 
	{
		m_Clsid = SysAllocString ( a_Key.m_Clsid ) ;
	}

	m_MarshaledProxyLength = a_Key.m_MarshaledProxyLength ;

	if ( a_Key.m_MarshaledProxy )
	{
		m_MarshaledProxy = new BYTE [ a_Key.m_MarshaledProxyLength ] ;
		if ( m_MarshaledProxy )
		{
			CopyMemory ( m_MarshaledProxy , a_Key.m_MarshaledProxy , a_Key.m_MarshaledProxyLength ) ;
		}
	}

	return *this ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetProcessIdentifier ( DWORD a_ProcessIdentifier )
{
	m_ProcessIdentifier = a_ProcessIdentifier ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetProvider ( BSTR a_Provider )
{
	HRESULT t_Result = S_OK ;

	if ( m_Provider )
	{
		SysFreeString ( m_Provider ) ;
	}

	m_Provider = SysAllocString ( a_Provider ) ;
	if ( m_Provider == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetLocale ( BSTR a_Locale )
{
	HRESULT t_Result = S_OK ;

	if ( m_Locale )
	{
		SysFreeString ( m_Locale ) ;
	}

	m_Locale = SysAllocString ( a_Locale ) ;
	if ( m_Locale == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetUser ( BSTR a_User )
{
	HRESULT t_Result = S_OK ;

	if ( m_User )
	{
		SysFreeString ( m_User ) ;
	}

	m_User = SysAllocString ( a_User ) ;
	if ( m_User == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetScope ( BSTR a_Scope )
{
	HRESULT t_Result = S_OK ;

	if ( m_Scope )
	{
		SysFreeString ( m_Scope ) ;
	}

	m_Scope = SysAllocString ( a_Scope ) ;
	if ( m_Scope == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetCreationTime ( BSTR a_CreationTime )
{
	HRESULT t_Result = S_OK ;

	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
	}

	m_CreationTime = SysAllocString ( a_CreationTime ) ;
	if ( m_CreationTime == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetClsid ( BSTR a_Clsid )
{
	HRESULT t_Result = S_OK ;

	if ( m_Clsid )
	{
		SysFreeString ( m_Clsid ) ;
	}

	m_Clsid = SysAllocString ( a_Clsid ) ;
	if ( m_Clsid == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetMarshaledProxy ( BYTE *a_MarshaledProxy , ULONG a_MarshaledProxyLength )
{
	HRESULT t_Result = S_OK ;

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
	}

	m_MarshaledProxyLength = a_MarshaledProxyLength ;
	m_MarshaledProxy = new BYTE [ a_MarshaledProxyLength ] ;
	if ( m_MarshaledProxy )
	{
		CopyMemory ( m_MarshaledProxy , a_MarshaledProxy , a_MarshaledProxyLength ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledClientRegistration_Element :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledClientRegistration_Element :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: Validate ()
{
	CWbemDateTime t_CreationTime ;

	HRESULT t_Result = t_CreationTime.PutValue ( m_CreationTime ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		HANDLE t_Handle = OpenProcess (

			PROCESS_QUERY_INFORMATION ,
			FALSE ,
			m_ProcessIdentifier
		) ;

		if ( t_Handle ) 
		{
			FILETIME t_CreationFileTime ;
			FILETIME t_ExitFileTime ;
			FILETIME t_KernelFileTime ;
			FILETIME t_UserFileTime ;

			BOOL t_Status = GetProcessTimes (

			  t_Handle ,
			  & t_CreationFileTime,
			  & t_ExitFileTime,
			  & t_KernelFileTime,
			  & t_UserFileTime
			) ;

			if ( t_Status ) 
			{
				CWbemDateTime t_Time ;
				t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;

				if ( t_CreationTime.Preceeds ( t_Time ) )
				{
					t_Result = WBEM_E_NOT_FOUND ;
				}
			}

			CloseHandle ( t_Handle ) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: Load ( BSTR a_Clsid )
{
	HRESULT t_Result = S_OK ;

	Clear () ;

	t_Result = SetClsid ( a_Clsid ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		LPWSTR t_HomeClientClsid_String = NULL ;
		t_Result = WmiHelper :: ConcatenateStrings ( 

			3, 
			& t_HomeClientClsid_String , 
			s_Strings_Reg_HomeClient ,
			L"\\" ,
			a_Clsid
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			HKEY t_HomeClientClsid_Key ;

			LONG t_RegResult = RegOpenKeyEx (

				HKEY_LOCAL_MACHINE ,
				t_HomeClientClsid_String ,
				0 ,
				KEY_READ ,
				& t_HomeClientClsid_Key 
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				ON_BLOCK_EXIT(RegCloseKey, t_HomeClientClsid_Key);
				
				t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_CreationTime , m_CreationTime ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_Provider , m_Provider ) ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_Scope , m_Scope ) ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_Locale , m_Locale ) ;
					if ( t_Result == ERROR_FILE_NOT_FOUND )
					{	
						t_Result = S_OK ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_User , m_User ) ;
					if ( t_Result == ERROR_FILE_NOT_FOUND )
					{	
						t_Result = S_OK ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_ByteArray ( t_HomeClientClsid_Key , s_Strings_Reg_MarshaledProxy , m_MarshaledProxy , m_MarshaledProxyLength ) ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_DWORD ( t_HomeClientClsid_Key , s_Strings_Reg_ProcessIdentifier , m_ProcessIdentifier ) ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = Validate () ;
				}
			}
			else
			{
				t_Result = WBEM_E_NOT_FOUND ;
			}

			SysFreeString ( t_HomeClientClsid_String ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( FAILED ( t_Result ) )
	{
		Delete ( a_Clsid ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: Save ( BSTR a_Clsid )
{
	HRESULT t_Result = S_OK ;

	t_Result = SetClsid ( a_Clsid ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		LPWSTR t_HomeClientClsid_String = NULL ;
		t_Result = WmiHelper :: ConcatenateStrings ( 

			2, 
			& t_HomeClientClsid_String , 
			s_Strings_Reg_HomeClient ,
			m_Clsid
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			HKEY t_HomeClient_Key ;
			DWORD t_Disposition = 0 ;

			LONG t_RegResult = RegCreateKeyEx (

				HKEY_LOCAL_MACHINE ,
				s_Strings_Reg_HomeClient ,
				0 ,
				NULL ,
				REG_OPTION_VOLATILE ,
				KEY_WRITE | WRITE_DAC ,
				NULL ,
				& t_HomeClient_Key ,
				& t_Disposition                     
			) ;

			if (t_RegResult == ERROR_SUCCESS) 
			{
				t_Result = SetClientSecurity ( t_HomeClient_Key) ;
				if  (t_Result != ERROR_SUCCESS) 
				{
					t_RegResult = t_Result;
					RegCloseKey ( t_HomeClient_Key ) ;				
				}
				
			}



			if ( t_RegResult == ERROR_SUCCESS )
			{
				t_Result = CoImpersonateClient();
				if (SUCCEEDED(t_Result))
				{
				HKEY t_HomeClientClsid_Key ;

				LONG t_RegResult = RegCreateKeyEx (

					t_HomeClient_Key ,
					m_Clsid ,
					0 ,
					NULL ,
					REG_OPTION_VOLATILE ,
					KEY_WRITE ,
					NULL ,
					& t_HomeClientClsid_Key ,
					& t_Disposition                     
				) ;

				if ( t_RegResult == ERROR_SUCCESS )
				{

					if ( t_Disposition == REG_CREATED_NEW_KEY )
					{
						t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_CreationTime , m_CreationTime ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_Provider , m_Provider ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_Scope , m_Scope ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( m_Locale )
							{
								t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_Locale , m_Locale ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( m_User )
							{
								t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_User , m_User ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = ProviderSubSystem_Common_Globals :: Save_ByteArray ( t_HomeClientClsid_Key , s_Strings_Reg_MarshaledProxy , m_MarshaledProxy , m_MarshaledProxyLength ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = ProviderSubSystem_Common_Globals :: Save_DWORD ( t_HomeClientClsid_Key , s_Strings_Reg_ProcessIdentifier , m_ProcessIdentifier ) ;
						}
					}
					else
					{
						t_Result = WBEM_E_ALREADY_EXISTS ;
					}

					RegCloseKey ( t_HomeClientClsid_Key ) ;
				}
				CoRevertToSelf();
				}

				RegCloseKey ( t_HomeClient_Key ) ;
			}

			SysFreeString ( t_HomeClientClsid_String ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: Delete ( BSTR a_Clsid )
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_HomeClientClsid_String = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		3, 
		& t_HomeClientClsid_String , 
		s_Strings_Reg_HomeClient ,
		L"\\" ,
		a_Clsid
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		HKEY t_HomeClientClsid_Key ;

		LONG t_RegResult = RegOpenKeyEx (

			HKEY_LOCAL_MACHINE ,
			t_HomeClientClsid_String ,
			0 ,
			KEY_READ ,
			& t_HomeClientClsid_Key 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			BYTE *t_MarshaledProxy = NULL ;
			ULONG t_MarshaledProxyLength = 0 ;

			t_Result = ProviderSubSystem_Common_Globals :: Load_ByteArray (

				t_HomeClientClsid_Key , 
				s_Strings_Reg_MarshaledProxy , 
				t_MarshaledProxy , 
				t_MarshaledProxyLength
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = ProviderSubSystem_Common_Globals :: ReleaseRegistration ( 

					t_MarshaledProxy , 
					t_MarshaledProxyLength
				) ;

				if ( t_MarshaledProxy )
				{
					delete [] t_MarshaledProxy ;
				}
			}

			RegCloseKey ( t_HomeClientClsid_Key ) ;
		}

		t_RegResult = RegDeleteKey (

			HKEY_LOCAL_MACHINE ,
			t_HomeClientClsid_String
		) ;

		if ( t_RegResult != ERROR_SUCCESS )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		SysFreeString ( t_HomeClientClsid_String ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration :: CServerObject_DecoupledClientRegistration (

	WmiAllocator &a_Allocator 

) : m_Queue ( a_Allocator ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration :: ~CServerObject_DecoupledClientRegistration ()
{
	m_Queue.UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledClientRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledClientRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration :: Load ()
{
	HRESULT t_Result = S_OK ;

	HKEY t_HomeClient_Key ;

	LONG t_RegResult = RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeClient ,
		0 ,
		KEY_READ ,
		& t_HomeClient_Key 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		DWORD t_Count = 0 ;
		DWORD t_Size = 16 ;

		BSTR *t_Elements = ( BSTR * ) malloc ( sizeof ( BSTR ) * t_Size ) ;
		if ( t_Elements )
		{
			FILETIME t_FileTime ;
			DWORD t_Class ;
			BOOL t_Continue = TRUE ;

			while ( SUCCEEDED ( t_Result ) && t_Continue )
			{
				DWORD t_NameLength = 256 ;
				wchar_t t_Name [ 256 ] ;

				LONG t_RegResult = RegEnumKeyEx (

					t_HomeClient_Key ,
					t_Count ,
					t_Name ,
					& t_NameLength ,            // size of subkey buffer
					NULL ,
					NULL ,
					NULL ,
					& t_FileTime
				) ;

				if ( t_RegResult == ERROR_SUCCESS )
				{
					if ( t_Count >= t_Size )
					{
						BSTR *t_NewElements = ( BSTR * ) realloc ( t_Elements , sizeof ( BSTR ) * ( t_Size + 16 ) ) ;
						if ( t_NewElements )
						{
							t_Elements = t_NewElements ;
							t_Size = t_Size + 16 ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Elements [ t_Count ] = SysAllocString ( t_Name ) ;
						if ( t_Elements [ t_Count ]  )
						{
                                                        t_Count ++ ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
				else if ( t_RegResult == ERROR_NO_MORE_ITEMS )
				{
					t_Continue = FALSE ;
				}
				else
				{
					t_Continue = FALSE ;
	// Generate message
				}
			}

			if ( t_Elements )
			{
				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_Elements [ t_Index ] )
					{
						CServerObject_DecoupledClientRegistration_Element t_Element ;
						HRESULT t_TempResult = t_Element.Load ( t_Elements [ t_Index ] ) ;
						if ( SUCCEEDED ( t_TempResult ) )
						{
							m_Queue.EnQueue ( t_Element ) ;
						}
						else
						{
			// Generate message
						}

						SysFreeString ( t_Elements [ t_Index ] ) ;
					}
				}

				free ( t_Elements ) ;
			}
		}
		else
		{
		}

		RegCloseKey ( t_HomeClient_Key ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration :: Load (

	BSTR a_Provider ,
	BSTR a_User ,
	BSTR a_Locale ,
	BSTR a_Scope
)
{
	HRESULT t_Result = S_OK ;

	HKEY t_HomeClient_Key ;

	LONG t_RegResult = RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeClient ,
		0 ,
		KEY_READ ,
		& t_HomeClient_Key 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		DWORD t_Index = 0 ;
		FILETIME t_FileTime ;
		DWORD t_Class ;
		BOOL t_Continue = TRUE ;

		while ( SUCCEEDED ( t_Result ) && t_Continue )
		{
			DWORD t_NameLength = 256 ;
			wchar_t t_Name [ 256 ] ;

			LONG t_RegResult = RegEnumKeyEx (

				t_HomeClient_Key ,
				t_Index ,
				t_Name ,
				& t_NameLength ,            // size of subkey buffer
				NULL ,
				NULL ,
				NULL ,
				& t_FileTime
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				CServerObject_DecoupledClientRegistration_Element t_Element ;
				HRESULT t_TempResult = t_Element.Load ( t_Name ) ;
				if ( SUCCEEDED ( t_TempResult ) )
				{
					BOOL t_Compare = ( wbem_wcsicmp ( a_Provider , t_Element.GetProvider () ) == 0 ) ;
					t_Compare = t_Compare && ( wbem_wcsicmp ( a_Scope , t_Element.GetScope () ) == 0 ) ;

					if ( t_Compare )
					{
						if ( ( a_Locale == NULL ) && ( t_Element.GetLocale () == NULL ) )
						{
						}
						else
						{
							if ( ( a_Locale ) && ( t_Element.GetLocale () ) )
							{
								t_Compare = ( wbem_wcsicmp ( a_Locale , t_Element.GetLocale () ) == 0 ) ;
							}
							else
							{
								t_Compare = FALSE ;
							}
						}
					}

					if ( t_Compare )
					{
						if ( ( a_User == NULL ) && ( t_Element.GetUser () == NULL ) )
						{
						}
						else
						{
							if ( ( a_User ) && ( t_Element.GetUser () ) )
							{
								t_Compare = ( wbem_wcsicmp ( a_User , t_Element.GetUser () ) == 0 ) ;
							}
							else
							{
								t_Compare = FALSE ;
							}
						}
					}

					if ( t_Compare )
					{
						m_Queue.EnQueue ( t_Element ) ;
					}
				}
				else
				{
// Generate message
				}
			}
			else if ( t_RegResult == ERROR_NO_MORE_ITEMS )
			{
				t_Continue = FALSE ;
			}
			else
			{
				t_Continue = FALSE ;
// Generate message
			}

			t_Index ++ ;
		}

		RegCloseKey ( t_HomeClient_Key ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledServerRegistration :: CServerObject_DecoupledServerRegistration ( WmiAllocator &a_Allocator )

	:	m_CreationTime ( NULL ) ,
		m_MarshaledProxy ( NULL ) ,
		m_MarshaledProxyLength ( 0 ) ,
		m_Result ( S_OK ) ,
		m_ProcessIdentifier ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledServerRegistration :: ~CServerObject_DecoupledServerRegistration ()
{
	Clear () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CServerObject_DecoupledServerRegistration :: Clear () 
{
	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
		m_CreationTime = NULL ;
	}

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
		m_MarshaledProxy = NULL ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledServerRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledServerRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: Validate ()
{
	CWbemDateTime t_CreationTime ;

	HRESULT t_Result = t_CreationTime.PutValue ( m_CreationTime ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		HANDLE t_Handle = OpenProcess (

			PROCESS_QUERY_INFORMATION ,
			FALSE ,
			m_ProcessIdentifier
		) ;

		if ( t_Handle ) 
		{
			FILETIME t_CreationFileTime ;
			FILETIME t_ExitFileTime ;
			FILETIME t_KernelFileTime ;
			FILETIME t_UserFileTime ;

			BOOL t_Status = GetProcessTimes (

			  t_Handle ,
			  & t_CreationFileTime,
			  & t_ExitFileTime,
			  & t_KernelFileTime,
			  & t_UserFileTime
			) ;

			if ( t_Status ) 
			{
				CWbemDateTime t_Time ;
				t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;

				if ( t_CreationTime.Preceeds ( t_Time ) )
				{
					t_Result = WBEM_E_NOT_FOUND ;
				}
			}

			CloseHandle ( t_Handle ) ;
		}
	}

 	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: Load ()
{
	HRESULT t_Result = S_OK ;

	Clear () ;

	HKEY t_HomeServerClsid_Key ;

	LONG t_RegResult = RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeServer ,
		0 ,
		KEY_READ ,
		& t_HomeServerClsid_Key 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		SECURITY_INFORMATION t_SecurityInformation = OWNER_SECURITY_INFORMATION ;
		SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;
		DWORD t_Length = 0 ;

		t_RegResult = RegGetKeySecurity (

			t_HomeServerClsid_Key ,
			t_SecurityInformation ,
			t_SecurityDescriptor ,
			& t_Length 
		) ;

		if ( t_RegResult == ERROR_INSUFFICIENT_BUFFER )
		{
			t_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_Length ] ;
			if ( t_SecurityDescriptor )
			{
				t_RegResult = RegGetKeySecurity (

					t_HomeServerClsid_Key ,
					t_SecurityInformation ,
					t_SecurityDescriptor ,
					& t_Length 
				) ;

				if ( t_RegResult == ERROR_SUCCESS )
				{
					SID *t_Sid = NULL ;
					BOOL t_Defaulted = FALSE ;

					BOOL t_Status = GetSecurityDescriptorOwner (

					  t_SecurityDescriptor ,
					  ( PSID * ) & t_Sid ,
					  & t_Defaulted
					) ;

					if ( t_Status )
					{
						SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

						PSID t_Administrator_Sid = NULL ;

						BOOL t_BoolResult = AllocateAndInitializeSid (

							& t_NtAuthoritySid ,
							2 ,
							SECURITY_BUILTIN_DOMAIN_RID,
							DOMAIN_ALIAS_RID_ADMINS,
							0,
							0,
							0,
							0,
							0,
							0,
							& t_Administrator_Sid
						);

						if ( t_BoolResult )
						{
							if ( EqualSid ( t_Administrator_Sid , t_Sid ) == FALSE )
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}

							if ( t_Administrator_Sid )
							{
								FreeSid ( t_Administrator_Sid ) ;
							}
						}
						else
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				delete [] ( BYTE * ) t_SecurityDescriptor ;
			}
		}
		else
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeServerClsid_Key , s_Strings_Reg_CreationTime , m_CreationTime ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Load_ByteArray ( t_HomeServerClsid_Key , s_Strings_Reg_MarshaledProxy , m_MarshaledProxy , m_MarshaledProxyLength ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Load_DWORD ( t_HomeServerClsid_Key , s_Strings_Reg_ProcessIdentifier , m_ProcessIdentifier ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = Validate () ;
		}

		RegCloseKey ( t_HomeServerClsid_Key ) ;
	}
	else
	{

    	    t_Result = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,t_RegResult);
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: SetCreationTime ( BSTR a_CreationTime )
{
	HRESULT t_Result = S_OK ;

	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
	}

	m_CreationTime = SysAllocString ( a_CreationTime ) ;
	if ( m_CreationTime == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: SetProcessIdentifier ( DWORD a_ProcessIdentifier )
{
	m_ProcessIdentifier = a_ProcessIdentifier ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: SetMarshaledProxy ( BYTE *a_MarshaledProxy , ULONG a_MarshaledProxyLength )
{
	HRESULT t_Result = S_OK ;

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
	}

	m_MarshaledProxyLength = a_MarshaledProxyLength ;
	m_MarshaledProxy = new BYTE [ a_MarshaledProxyLength ] ;
	if ( m_MarshaledProxy )
	{
		CopyMemory ( m_MarshaledProxy , a_MarshaledProxy , a_MarshaledProxyLength ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: Save ()
{
	HRESULT t_Result = S_OK ;

	HKEY t_HomeServer_Key ;
	DWORD t_Disposition = 0 ;

	LONG t_RegResult = RegCreateKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeServer ,
		0 ,
		NULL ,
		REG_OPTION_VOLATILE ,
		KEY_WRITE ,
		NULL ,
		& t_HomeServer_Key ,
		& t_Disposition                     
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		HRESULT t_TempResult = SetSecurity ( t_HomeServer_Key , KEY_READ ) ;

		t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeServer_Key , s_Strings_Reg_CreationTime , m_CreationTime ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Save_ByteArray ( t_HomeServer_Key , s_Strings_Reg_MarshaledProxy , m_MarshaledProxy , m_MarshaledProxyLength ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Save_DWORD ( t_HomeServer_Key , s_Strings_Reg_ProcessIdentifier , m_ProcessIdentifier ) ;
		}

		RegCloseKey ( t_HomeServer_Key ) ;
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: Delete ()
{
	HRESULT t_Result = S_OK ;

	HKEY t_HomeServerClsid_Key ;

	LONG t_RegResult = RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeServer ,
		0 ,
		KEY_READ ,
		& t_HomeServerClsid_Key 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		BYTE *t_MarshaledProxy = NULL ;
		ULONG t_MarshaledProxyLength = 0 ;

		t_Result = ProviderSubSystem_Common_Globals :: Load_ByteArray (

			t_HomeServerClsid_Key , 
			s_Strings_Reg_MarshaledProxy , 
			t_MarshaledProxy , 
			t_MarshaledProxyLength
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: ReleaseRegistration ( 

				t_MarshaledProxy , 
				t_MarshaledProxyLength
			) ;

			if ( t_MarshaledProxy )
			{
				delete [] t_MarshaledProxy ;
			}
		}

		RegCloseKey ( t_HomeServerClsid_Key ) ;
	}

	t_RegResult = RegDeleteKey (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeServer
	) ;

	if ( t_RegResult != ERROR_SUCCESS )
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}
    
	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\common\provtree.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvTree.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <typeinfo.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include "ProvTree.h"

WmiTreeNode *WmiTreeNode :: Copy () 
{
	TypeId_TreeNode t_Type = m_Type ;
	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_RightCopy = m_Right ? m_Right->Copy () : NULL ;
	WmiTreeNode *t_Node = new WmiTreeNode ( t_Type , t_DataCopy , t_LeftCopy , t_RightCopy , t_Parent ) ;
	return t_Node ;
} ;

WmiTreeNode *WmiTreeNode :: CopyNode () 
{
	WmiTreeNode *t_Node = new WmiTreeNode ( this ) ;
	return t_Node ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\common\provreginfo.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#undef POLARITY

#include <typeinfo.h>
#include <stdio.h>
#include <sddl.h>

#include <wbemint.h>
#include <genlex.h>
#include <sql_1.h>
#include <HelperFuncs.h>
#include <Logging.h>

#include <HelperFuncs.h>
#include "CGlobals.h"
#include "ProvDnf.h"
#include "ProvRegInfo.h"
#include "DateTime.h"


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

wchar_t *g_SecureSvcHostProviders [] =
{
	L"{266c72d4-62e8-11d1-ad89-00c04fd8fdff}"	,	// "LogFileEventConsumer"
    L"{266c72e6-62e8-11d1-ad89-00c04fd8fdff}"  	,	// "NTEventLogEventConsumer"    
	L"{29F06F0C-FB7F-44A5-83CD-D41705D5C525}"	,	// "Non Com provider"
	L"{405595AA-1E14-11d3-B33D-00105A1F4AAF}"	,	// "Microsoft WMI Transient Provider"
	L"{405595AB-1E14-11d3-B33D-00105A1F4AAF}"	,	// "Microsoft WMI Transient Reboot Event Provider"
	L"{74E3B84C-C7BE-4e0a-9BD2-853CA72CD435}"	,	// "Microsoft WMI Updating Consumer Assoc Provider"
	L"{7879E40D-9FB5-450a-8A6D-00C89F349FCE}"	,	// "Microsoft WMI Forwarding Event Provider"
	L"{7F598975-37E0-4a67-A992-116680F0CEDA}"	,	// "Msft_ProviderSubSystem"	
	L"{9877D8A7-FDA1-43F9-AEEA-F90747EA66B0}"	,	// "WMI Kernel Trace Event Provider"
	L"{A3A16907-227B-11d3-865D-00C04F63049B}"	,	// "Microsoft WMI Updating Consumer Provider"
	L"{A83EF168-CA8D-11d2-B33D-00104BCC4B4A}"	,	// "WBEMCORE
	L"{AD1B46E8-0AAC-401b-A3B8-FCDCF8186F55}"	,	// "Microsoft WMI Forwarding Consumer Provider"
	L"{C486ABD2-27F6-11d3-865E-00C04F63049B}"	,	// "Microsoft WMI Template Provider"
	L"{D6C74FF3-3DCD-4c23-9F58-DD86F371EC73}"	,	// "Microsoft WMI Forwarding Ack Event Provider"
	L"{FD18A1B2-9E61-4e8e-8501-DB0B07846396}"		// "Microsoft WMI Template Association Provider"
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

wchar_t *g_SecureLocalSystemProviders [] =
{
	L"{0725C3CB-FEFB-11d0-99F9-00C04FC2F8EC}",		// "WmiEventProv"
	L"{72967901-68EC-11d0-B729-00AA0062CBB7}",		// "RegPropProv"
	L"{B3FF88A4-96EC-4cc1-983F-72BE0EBB368B}",		// "Rsop Logging Mode Provider"	
	L"{BE0A9830-2B8B-11d1-A949-0060181EBBAD}",		// "MSIProv"
	L"{D2D588B5-D081-11d0-99E0-00C04FC2F8EC}",		// "WMIProv"
	L"{F0FF8EBB-F14D-4369-BD2E-D84FBF6122D6}",		// "Rsop Planning Mode Provider"
	L"{FA77A74E-E109-11D0-AD6E-00C04FD8FDFF}",		// "RegistryEventProvider"
	L"{FE9AF5C0-D3B6-11CE-A5B6-00AA00680C3F}"		// "RegProv"
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT QuickFind ( wchar_t *a_Clsid , ULONG a_Size , wchar_t **a_Container )
{
	ULONG t_Lower = 0 ;
	ULONG t_Upper = a_Size ;

	while ( t_Lower < t_Upper ) 
	{
		ULONG t_Index = ( t_Lower + t_Upper ) >> 1 ;

		LONG t_Compare = wbem_wcsicmp ( a_Clsid , a_Container [ t_Index ] ) ;
		if ( t_Compare == 0 ) 
		{
			return S_OK ;
		}
		else
		{
			if ( t_Compare < 0 ) 
			{
				t_Upper = t_Index ;
			}
			else
			{
				t_Lower = t_Index + 1 ;
			}
		}
	}

	return WBEM_E_ACCESS_DENIED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT VerifySecureLocalSystemProviders ( wchar_t *a_Clsid )
{
	return QuickFind ( a_Clsid , sizeof ( g_SecureLocalSystemProviders ) / sizeof ( wchar_t * ) , g_SecureLocalSystemProviders ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT VerifySecureSvcHostProviders ( wchar_t *a_Clsid )
{
	return QuickFind ( a_Clsid , sizeof ( g_SecureSvcHostProviders ) / sizeof ( wchar_t * ) , g_SecureSvcHostProviders ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

GENERIC_MAPPING g_ProviderBindingMapping = {

	0 ,
	0 ,
	STANDARD_RIGHTS_REQUIRED | MASK_PROVIDER_BINDING_BIND ,
	STANDARD_RIGHTS_REQUIRED | MASK_PROVIDER_BINDING_BIND 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_Class = L"__CLASS" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi___ObjectProviderCacheControl = L"__ObjectProviderCacheControl" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi___EventProviderCacheControl = L"__EventProviderCacheControl" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_ClearAfter = L"ClearAfter" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_s_Strings_Query_Object = L"Select * from __ObjectProviderCacheControl" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_s_Strings_Path_Object = L"__ObjectProviderCacheControl=@" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_s_Strings_Query_Event = L"Select * from __EventProviderCacheControl" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_s_Strings_Path_Event = L"__EventProviderCacheControl=@" ;

LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_HostQuotas_Query = L"Select * from __ProviderHostQuotaConfiguration" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_HostQuotas_Path = L"__ProviderHostQuotaConfiguration=@" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_MemoryPerHost = L"MemoryPerHost" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_MemoryAllHosts = L"MemoryAllHosts" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_ThreadsPerHost = L"ThreadsPerHost" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_HandlesPerHost = L"HandlesPerHost" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_ProcessLimitAllHosts = L"ProcessLimitAllHosts" ;

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_ClsidKeyStr = L"CLSID\\" ;

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Null = NULL ;

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_ThreadingModel = L"ThreadingModel" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_InProcServer32 = L"InProcServer32" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_LocalServer32 = L"LocalServer32" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization = L"Synchronization" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_AppId = L"AppId" ;

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Apartment_Apartment = L"apartment" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Apartment_Both = L"both";
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Apartment_Free = L"free";
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Apartment_Neutral = L"neutral";

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_Ignored = L"ignored" ; 
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_None = L"none" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_Supported = L"supported" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_Required = L"required" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_RequiresNew = L"requiresnew" ;

LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Clsid = L"CLSID" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_ClientClsid = L"ClientLoadableCLSID" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Name = L"Name" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultMachineName = L"DefaultMachineName" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_UnloadTimeout = L"UnloadTimeout" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_ImpersonationLevel = L"ImpersonationLevel" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_InitializationReentrancy = L"InitializationReentrancy" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_InitializeAsAdminFirst = L"InitializeAsAdminFirst" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_PerUserInitialization = L"PerUserInitialization" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_PerLocaleInitialization = L"PerLocaleInitialization" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Pure = L"Pure" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Hosting = L"HostingModel" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_HostingGroup = L"HostingGroup" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SupportsThrottling = L"SupportsThrottling" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SupportsShutdown = L"SupportsShutdown" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_ConcurrentIndependantRequests = L"ConcurrentIndependantRequests";
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SupportsSendStatus = L"SupportsSendStatus" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_OperationTimeoutInterval = L"OperationTimeoutInterval" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_InitializationTimeoutInterval = L"InitializationTimeoutInterval" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SupportsQuotas = L"SupportsQuotas" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Enabled = L"Enabled" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Version = L"Version" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SecurityDescriptor = L"SecurityDescriptor" ;

WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_WmiCore [] = L"WmiCore" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_WmiCoreOrSelfHost [] = L"WmiCoreOrSelfHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SelfHost [] = L"SelfHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Decoupled [] = L"Decoupled:Com" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DecoupledColon [] = L"Decoupled:Com:" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedLocalSystemHost [] = L"LocalSystemHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedLocalSystemHostOrSelfHost [] = L"LocalSystemHostOrSelfHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedNetworkServiceHost [] = L"NetworkServiceHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedLocalServiceHost [] = L"LocalServiceHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedUserHost [] = L"UserHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_NonCom [] = L"Decoupled:NonCom" ;

WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedLocalSystemHost [] = L"DefaultLocalSystemHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedLocalSystemHostOrSelfHost [] = L"DefaultLocalSystemHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedNetworkServiceHost [] = L"DefaultNetworkServiceHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedLocalServiceHost [] = L"DefaultLocalServiceHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedUserHost [] = L"DefaultUserHost" ;

LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultHostingRegistryKey = L"Software\\Microsoft\\WBEM\\Providers\\Configuration\\" ;

LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InstanceProviderRegistration = L"__InstanceProviderRegistration" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsPut = L"SupportsPut" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsGet = L"SupportsGet" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsDelete = L"SupportsDelete" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsEnumeration = L"SupportsEnumeration" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels = L"QuerySupportLevels" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InteractionType = L"InteractionType" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsBatching = L"SupportsBatching" ;;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsTransactions = L"SupportsTransactions" ;;

LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels_UnarySelect = L"WQL:UnarySelect" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels_References = L"WQL:References" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels_Associators = L"WQL:Associators" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels_V1ProviderDefined = L"WQL:V1ProviderDefined" ;

LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InteractionType_Pull = L"Pull" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InteractionType_Push = L"Push" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InteractionType_PushVerify = L"PushVerify" ;

LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_ClassProviderRegistration = L"__ClassProviderRegistration" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsPut = L"SupportsPut" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsGet = L"SupportsGet" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsDelete = L"SupportsDelete" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsEnumeration = L"SupportsEnumeration" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels = L"QuerySupportLevels" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_InteractionType = L"InteractionType" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsBatching = L"SupportsBatching" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsTransactions = L"SupportsTransactions" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_CacheRefreshInterval = L"CacheRefreshInterval" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_PerUserSchema = L"PerUserSchema" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_ReSynchroniseOnNamespaceOpen = L"ReSynchroniseOnNamespaceOpen" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_Version = L"Version" ;

LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels_UnarySelect = L"WQL:UnarySelect" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels_References = L"WQL:References" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels_Associators = L"WQL:Associators" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels_V1ProviderDefined = L"WQL:V1ProviderDefined" ;

LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_InteractionType_Pull = L"Pull" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_InteractionType_Push = L"Push" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_InteractionType_PushVerify = L"PushVerify" ;

LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_ResultSetQueries = L"ResultSetQueries" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_UnSupportedQueries = L"UnSupportedQueries" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_ReferencedSetQueries = L"ReferencedSetQueries" ;

LPCWSTR CServerObject_MethodProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_MethodProviderRegistrationV1 :: s_Strings_MethodProviderRegistration = L"__MethodProviderRegistration" ;

LPCWSTR CServerObject_EventProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_EventProviderRegistrationV1 :: s_Strings_EventProviderRegistration = L"__EventProviderRegistration" ;

LPCWSTR CServerObject_EventConsumerProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_EventConsumerProviderRegistrationV1 :: s_Strings_EventConsumerProviderRegistration = L"__EventConsumerProviderRegistration" ;

LPCWSTR CServerObject_DynamicPropertyProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_DynamicPropertyProviderRegistrationV1 :: s_Strings_PropertyProviderRegistration = L"__PropertyProviderRegistration" ;
LPCWSTR CServerObject_DynamicPropertyProviderRegistrationV1 :: s_Strings_SupportsPut = L"SupportsPut" ;
LPCWSTR CServerObject_DynamicPropertyProviderRegistrationV1 :: s_Strings_SupportsGet = L"SupportsGet" ;

LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_ClassProviderRegistration = L"__ClassProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_InstanceProviderRegistration = L"__InstanceProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_MethodProviderRegistration = L"__MethodProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_PropertyProviderRegistration = L"__PropertyProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_EventProviderRegistration = L"__EventProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_EventConsumerProviderRegistration = L"__EventConsumerProviderRegistration" ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_GlobalRegistration :: CServerObject_GlobalRegistration () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Object_UnloadTimeout ( NULL ) ,
	m_Event_UnloadTimeout ( NULL ) ,
	m_Object_UnloadTimeoutMilliSeconds ( DEFAULT_PROVIDER_TIMEOUT ) ,
	m_Event_UnloadTimeoutMilliSeconds ( DEFAULT_PROVIDER_TIMEOUT ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_GlobalRegistration :: ~CServerObject_GlobalRegistration ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	if ( m_Object_UnloadTimeout )
	{
		SysFreeString ( m_Object_UnloadTimeout ) ;
	}

	if ( m_Event_UnloadTimeout )
	{
		SysFreeString ( m_Event_UnloadTimeout ) ;
	}

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_GlobalRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_GlobalRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_GlobalRegistration :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_GlobalRegistration :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object ,
	LPWSTR &a_UnloadTimeout ,
	ULONG &a_UnloadTimeoutMilliSeconds 
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Mask & e_ClearAfter )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		t_Result = a_Object->Get ( s_Strings_Wmi_ClearAfter , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BSTR )
			{
				if ( a_UnloadTimeout )
				{
					SysFreeString ( a_UnloadTimeout ) ;
				}

				a_UnloadTimeout = SysAllocString ( t_Variant.bstrVal ) ;
				if ( a_UnloadTimeout )
				{
					CWbemDateTime t_Interval ;
					t_Result = t_Interval.PutValue ( a_UnloadTimeout ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						VARIANT_BOOL t_Bool = VARIANT_FALSE ;
						t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
						if ( t_Bool == VARIANT_TRUE )
						{
							LONG t_MicroSeconds = 0 ;
							LONG t_Seconds = 0 ;
							LONG t_Minutes = 0 ;
							LONG t_Hours = 0 ;
							LONG t_Days = 0 ;

							t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
							t_Interval.GetSeconds ( & t_Seconds ) ;
							t_Interval.GetMinutes ( & t_Minutes ) ;
							t_Interval.GetHours ( & t_Hours ) ;
							t_Interval.GetDay ( & t_Days ) ;

							a_UnloadTimeoutMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
														  ( t_Hours * 60 * 60 * 1000 ) +
														  ( t_Minutes * 60 * 1000 ) +
														  ( t_Seconds * 1000 ) +
														  ( t_MicroSeconds / 1000 ) ;
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				if ( a_UnloadTimeout )
				{
					SysFreeString ( a_UnloadTimeout ) ;
					a_UnloadTimeout = NULL ;
				}
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_GlobalRegistration :: QueryRepository ( 

	Enum_PropertyMask a_Mask
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_ObjectPath = SysAllocString ( s_Strings_Wmi_s_Strings_Path_Object ) ;
	if ( t_ObjectPath ) 
	{
		IWbemClassObject *t_ClassObject = NULL ;

		t_Result = m_Repository->GetObject ( 

			t_ObjectPath ,
			0 ,
			m_Context , 
			& t_ClassObject , 
			NULL 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = QueryProperties ( 

				a_Mask ,
				t_ClassObject ,
				m_Object_UnloadTimeout ,
				m_Object_UnloadTimeoutMilliSeconds
			) ;

			t_ClassObject->Release () ;
		}

		SysFreeString ( t_ObjectPath ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		BSTR t_ObjectPath = SysAllocString ( s_Strings_Wmi_s_Strings_Path_Event ) ;
		if ( t_ObjectPath ) 
		{
			IWbemClassObject *t_ClassObject = NULL ;

			t_Result = m_Repository->GetObject ( 

				t_ObjectPath ,
				0 ,
				m_Context , 
				& t_ClassObject , 
				NULL 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = QueryProperties ( 

					a_Mask ,
					t_ClassObject ,
					m_Event_UnloadTimeout ,
					m_Event_UnloadTimeoutMilliSeconds
				) ;

				t_ClassObject->Release () ;
			}

			SysFreeString ( t_ObjectPath ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_GlobalRegistration :: Load ( 

	Enum_PropertyMask a_Mask
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_HostQuotaRegistration :: CServerObject_HostQuotaRegistration () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_MemoryPerHost ( 0 ) ,
	m_MemoryAllHosts ( 0 ) ,
	m_ThreadsPerHost ( 0 ) ,
	m_HandlesPerHost ( 0 ) ,
	m_ProcessLimitAllHosts ( 0 ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_HostQuotaRegistration :: ~CServerObject_HostQuotaRegistration ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_HostQuotaRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_HostQuotaRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostQuotaRegistration :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostQuotaRegistration :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object
)
{
	HRESULT t_Result = S_OK ;

	_IWmiObject *t_FastObject = NULL ;

	t_Result = a_Object->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastObject ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_MemoryAllHosts )
		{
			UINT64 t_Value = 0 ;

			BOOL t_IsNull = FALSE ;
			CIMTYPE t_VarType = CIM_EMPTY ;
			LONG t_Flavour = 0 ;
			ULONG t_Used = 0 ;

			t_Result = t_FastObject->ReadProp ( 

				s_Strings_Wmi_MemoryAllHosts ,
				0 ,
				sizeof ( UINT64 ) ,
				& t_VarType ,
				& t_Flavour ,
				& t_IsNull ,
				& t_Used ,
				& t_Value
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IsNull )
				{
					m_MemoryAllHosts = 0 ;
				}
				else 
				{
					if ( t_VarType == CIM_UINT64 )
					{
						m_MemoryAllHosts = t_Value ;
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
			} 
		}

		if ( SUCCEEDED ( t_Result ) && (a_Mask & e_MemoryPerHost) )
		{
			UINT64 t_Value = 0 ;

			BOOL t_IsNull = FALSE ;
			CIMTYPE t_VarType = CIM_EMPTY ;
			LONG t_Flavour = 0 ;
			ULONG t_Used = 0 ;

			t_Result = t_FastObject->ReadProp ( 

				s_Strings_Wmi_MemoryPerHost ,
				0 ,
				sizeof ( UINT64 ) ,
				& t_VarType ,
				& t_Flavour ,
				& t_IsNull ,
				& t_Used ,
				& t_Value
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IsNull )
				{
					m_MemoryPerHost = 0 ;
				}
				else 
				{
					if ( t_VarType == CIM_UINT64 )
					{
						m_MemoryPerHost = t_Value ;
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
			}		
		}

		t_FastObject->Release () ;
	}

	if ( SUCCEEDED ( t_Result ) && (a_Mask & e_ThreadsPerHost) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		t_Result = a_Object->Get ( s_Strings_Wmi_ThreadsPerHost , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_ThreadsPerHost = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_ThreadsPerHost = 0 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}


		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED ( t_Result ) && (a_Mask & e_HandlesPerHost) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		t_Result = a_Object->Get ( s_Strings_Wmi_HandlesPerHost , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_HandlesPerHost = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_HandlesPerHost = 0 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED ( t_Result ) && (a_Mask & e_ProcessLimitAllHosts) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		t_Result = a_Object->Get ( s_Strings_Wmi_ProcessLimitAllHosts , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_ProcessLimitAllHosts = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_ProcessLimitAllHosts = 0 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostQuotaRegistration :: QueryRepository ( 

	Enum_PropertyMask a_Mask
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_ObjectPath = SysAllocString ( s_Strings_Wmi_HostQuotas_Path ) ;
	if ( t_ObjectPath ) 
	{
		IWbemClassObject *t_ClassObject = NULL ;

		t_Result = m_Repository->GetObject ( 

			t_ObjectPath ,
			0 ,
			m_Context , 
			& t_ClassObject , 
			NULL 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = QueryProperties ( 

				a_Mask ,
				t_ClassObject 
			) ;

			t_ClassObject->Release () ;
		}

		SysFreeString ( t_ObjectPath ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostQuotaRegistration :: Load ( 

	Enum_PropertyMask a_Mask
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ComRegistration :: CServerObject_ComRegistration ()

	:	m_ThreadingModel ( e_ThreadingModel_Unknown ) ,
		m_Synchronization ( e_Ignored ) ,
		m_InProcServer32 ( e_Boolean_Unknown ) ,
		m_LocalServer32 ( e_Boolean_Unknown ) ,
		m_Service ( e_Boolean_Unknown ) ,
		m_Loaded ( e_False ) ,
		m_Clsid ( NULL ) ,
		m_AppId ( NULL ) ,
		m_ProviderName ( NULL ) ,
		m_Result ( S_OK )
{
	m_InProcServer32_Path [ 0 ] = 0 ;
	m_LocalServer32_Path [ 0 ] = 0 ;
	m_Server_Name [ 0 ] = 0 ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ComRegistration :: ~CServerObject_ComRegistration ()
{
	if ( m_AppId )
	{
		SysFreeString ( m_AppId ) ;
	}

	if ( m_Clsid )
	{
		SysFreeString ( m_Clsid ) ;
	}

	if ( m_ProviderName )
	{
		SysFreeString ( m_ProviderName ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ComRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ComRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_ThreadingModel ( HKEY a_ClsidKey )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	wchar_t t_Data [ MAX_PATH ] ;
	DWORD t_DataSize = sizeof ( t_Data ) ;

	LONG t_RegResult = RegQueryValueEx (

	  a_ClsidKey ,
	  s_Strings_Reg_ThreadingModel ,
	  0 ,
	  & t_ValueType ,
	  LPBYTE ( & t_Data ) ,
	  & t_DataSize 
	);

	if ( t_RegResult == ERROR_SUCCESS )
	{
		if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Apartment_Apartment ) == 0 ) 
		{
			m_ThreadingModel = e_Apartment ;
		}
		else if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Apartment_Both ) == 0 ) 
		{
			m_ThreadingModel = e_Both ;
		}
		else if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Apartment_Free ) == 0 ) 
		{
			m_ThreadingModel = e_Free ;
		}
		else if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Apartment_Neutral ) == 0 )	
		{
			m_ThreadingModel = e_Neutral ;
		}
		else
		{
			m_ThreadingModel = e_ThreadingModel_Unknown ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_Synchronization ( HKEY a_ClsidKey )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	wchar_t t_Data [ MAX_PATH ] ;
	DWORD t_DataSize = sizeof ( t_Data ) ;

	LONG t_RegResult = RegQueryValueEx (

	  a_ClsidKey ,
	  s_Strings_Reg_Synchronization ,
	  0 ,
	  & t_ValueType ,
	  LPBYTE ( & t_Data ) ,
	  & t_DataSize 
	);

	if ( t_RegResult == ERROR_SUCCESS )
	{
		if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Synchronization_Ignored ) == 0 ) 
		{
			m_Synchronization = e_Ignored ;
		}
		else if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Synchronization_None ) == 0 ) 
		{
			m_Synchronization = e_None ;
		}
		else if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Synchronization_Supported ) == 0 )	
		{
			m_Synchronization = e_Supported ;
		}
		else if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Synchronization_Required ) == 0 )	
		{
			m_Synchronization = e_Required ;
		}
		else if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Synchronization_RequiresNew ) == 0 )	
		{
			m_Synchronization = e_RequiresNew ;
		}
		else
		{
			m_Synchronization = e_Synchronization_Unknown ;
		}
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_InProcServer32 ( LPCWSTR a_ClsidStringKey )
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_Clsid_String_Key_InProcServer32 = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		2, 
		& t_Clsid_String_Key_InProcServer32 , 
		a_ClsidStringKey ,
		s_Strings_Reg_InProcServer32
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		HKEY t_Clsid_Key_InProcServer32 ;

		LONG t_RegResult = RegOpenKeyEx (

			HKEY_CLASSES_ROOT ,
			t_Clsid_String_Key_InProcServer32 ,
			0 ,
			KEY_READ ,
			& t_Clsid_Key_InProcServer32 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			m_InProcServer32 = e_True ;

			t_Result = Load_ThreadingModel ( t_Clsid_Key_InProcServer32 ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Load_Synchronization ( t_Clsid_Key_InProcServer32 ) ;
			}

			DWORD t_ValueType = REG_SZ ;
			DWORD t_DataSize = sizeof ( m_InProcServer32_Path ) ;

			t_RegResult = RegQueryValueEx (

			  t_Clsid_Key_InProcServer32 ,
			  s_Strings_Reg_Null ,
			  0 ,
			  & t_ValueType ,
			  LPBYTE ( & m_InProcServer32_Path ) ,
			  & t_DataSize 
			);

			if ( t_RegResult == ERROR_SUCCESS )
			{
			}

			RegCloseKey ( t_Clsid_Key_InProcServer32 ) ;
		}

		SysFreeString ( t_Clsid_String_Key_InProcServer32 ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_LocalServer32 ( LPCWSTR a_ClsidStringKey )
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_Clsid_String_Key_LocalServer32 = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		2, 
		& t_Clsid_String_Key_LocalServer32 , 
		a_ClsidStringKey ,
		s_Strings_Reg_LocalServer32
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		HKEY t_Clsid_Key_LocalServer32 ;

		LONG t_RegResult = RegOpenKeyEx (

			HKEY_CLASSES_ROOT ,
			t_Clsid_String_Key_LocalServer32 ,
			0 ,
			KEY_READ ,
			& t_Clsid_Key_LocalServer32 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			m_LocalServer32 = e_True ;
			m_ThreadingModel = e_Free ;
			m_Synchronization = e_Ignored ;

			DWORD t_ValueType = REG_SZ ;
			DWORD t_DataSize = sizeof ( m_LocalServer32_Path ) ;

			t_RegResult = RegQueryValueEx (

			  t_Clsid_Key_LocalServer32 ,
			  s_Strings_Reg_Null ,
			  0 ,
			  & t_ValueType ,
			  LPBYTE ( & m_LocalServer32_Path ) ,
			  & t_DataSize 
			);

			if ( t_RegResult == ERROR_SUCCESS )
			{
			}

			RegCloseKey ( t_Clsid_Key_LocalServer32 ) ;
		}

		SysFreeString ( t_Clsid_String_Key_LocalServer32 ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_ServerTypes ( LPCWSTR a_ClsidString )
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_Clsid_String_Key = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		2, 
		& t_Clsid_String_Key , 
		a_ClsidString ,
		L"\\"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Load_InProcServer32 ( t_Clsid_String_Key ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = Load_LocalServer32 ( t_Clsid_String_Key ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
		}

		SysFreeString ( t_Clsid_String_Key ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_AppId ( HKEY a_Clsid_Key )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	wchar_t t_Data [ MAX_PATH ] ;
	DWORD t_DataSize = sizeof ( t_Data ) ;

	LONG t_RegResult = RegQueryValueEx (

	  a_Clsid_Key ,
	  s_Strings_Reg_AppId ,
	  0 ,
	  & t_ValueType ,
	  LPBYTE ( & t_Data ) ,
	  & t_DataSize 
	);

	if ( t_RegResult == ERROR_SUCCESS )
	{
		if ( m_AppId )
		{
			SysFreeString ( m_AppId ) ;
		}

		m_AppId = SysAllocString ( t_Data ) ;
		if ( m_AppId )
		{
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load ( LPCWSTR a_Clsid , LPCWSTR a_ProviderName )
{
	HRESULT t_Result = S_OK ;

	if ( m_Clsid ) 
	{
		SysFreeString ( m_Clsid ) ;
		m_Clsid = 0;
	}

	if (0 != a_Clsid)
	{
	     m_Clsid = SysAllocString ( a_Clsid ) ;
	     if (0 == m_Clsid ) return WBEM_E_OUT_OF_MEMORY;
	}
		
	if ( m_ProviderName ) 
	{
		SysFreeString ( m_ProviderName ) ;
		m_ProviderName = 0;
	}

	if (0!=a_ProviderName )
	{
	    m_ProviderName = SysAllocString ( a_ProviderName ) ;
	    if (0 == m_ProviderName) return WBEM_E_OUT_OF_MEMORY;
	}



	LPWSTR t_Clsid_String = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		2, 
		& t_Clsid_String , 
		s_Strings_Reg_ClsidKeyStr ,
		a_Clsid
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Load_ServerTypes ( t_Clsid_String ) ;

		HKEY t_Clsid_Key ;

		LONG t_RegResult = RegOpenKeyEx (

			HKEY_CLASSES_ROOT ,
			t_Clsid_String ,
			0 ,
			KEY_READ ,
			& t_Clsid_Key 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			DWORD t_ValueType = REG_SZ ;
			DWORD t_DataSize = sizeof ( m_Server_Name ) ;

			t_RegResult = RegQueryValueEx (

			  t_Clsid_Key ,
			  s_Strings_Reg_Null ,
			  0 ,
			  & t_ValueType ,
			  LPBYTE ( & m_Server_Name ) ,
			  & t_DataSize 
			);

			if ( t_RegResult == ERROR_SUCCESS )
			{
			}

			t_Result = Load_AppId ( t_Clsid_Key	) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( m_InProcServer32 != e_True && m_LocalServer32 != e_True )
				{
					m_Service = e_True ;
					m_ThreadingModel = e_Free ;
					m_Synchronization = e_Ignored ;
				}
			}

			RegCloseKey ( t_Clsid_Key ) ;
		}

		SysFreeString ( t_Clsid_String ) ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		m_Loaded = e_True ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ComProviderRegistrationV1 :: CServerObject_ComProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Identity ( NULL ) ,
	m_DefaultMachineName ( NULL ) ,
	m_UnloadTimeout ( NULL ) ,
	m_UnloadTimeoutMilliSeconds ( DEFAULT_PROVIDER_TIMEOUT ) ,
	m_OperationTimeout ( NULL ) ,
	m_OperationTimeoutMilliSeconds ( INFINITE ) ,
	m_InitializationTimeout ( NULL ) ,
	m_InitializationTimeoutMilliSeconds ( DEFAULT_PROVIDER_LOAD_TIMEOUT ) ,
	m_Enabled ( TRUE ) ,
	m_SupportsQuotas ( FALSE ) ,
	m_SupportsThrottling ( FALSE ) ,
	m_SupportsSendStatus ( FALSE ) ,
	m_SupportsShutdown ( FALSE ) ,
	m_ConcurrentIndependantRequests ( 0 ) ,
	m_ImpersonationLevel ( e_ImpersonationLevel_Unknown ) ,
	m_InitializationReentrancy ( e_InitializationReentrancy_Namespace ) ,
	m_InitializeAsAdminFirst ( FALSE ) ,
	m_PerUserInitialization ( FALSE ) ,
	m_PerLocaleInitialization ( FALSE ) ,
	m_Pure ( FALSE ) ,
	m_Version ( 1 ) ,
	m_ProviderName ( NULL ) ,
	m_Hosting ( e_Hosting_Undefined ) , // e_Hosting_SharedLocalSystemHost e_Hosting_WmiCore
	m_HostingGroup ( NULL ) ,
	m_Result ( S_OK ) ,
	m_SecurityDescriptor ( NULL ) ,
	m_DecoupledImpersonationRestriction ( TRUE )
{
	ZeroMemory ( & m_CLSID , sizeof ( GUID ) ) ;
	ZeroMemory ( & m_ClientCLSID  , sizeof ( GUID ) ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ComProviderRegistrationV1 :: ~CServerObject_ComProviderRegistrationV1 ()
{
	if ( m_SecurityDescriptor )
	{
		LocalFree ( m_SecurityDescriptor ) ;
	}

	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	if ( m_Identity )
	{
		m_Identity->Release () ;
	}

	if ( m_DefaultMachineName ) 
	{
		SysFreeString ( m_DefaultMachineName ) ;
	}

	if ( m_UnloadTimeout )
	{
		SysFreeString ( m_UnloadTimeout ) ;
	}

	if ( m_HostingGroup )
	{
		SysFreeString ( m_HostingGroup ) ;
	}

	if ( m_InitializationTimeout )
	{
		SysFreeString ( m_InitializationTimeout ) ;
	}

	if ( m_ProviderName ) 
	{
		SysFreeString ( m_ProviderName ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ComProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ComProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: GetDefaultHostingGroup ( 

	Enum_Hosting a_HostingValue ,
	BSTR & a_HostingGroup 
)
{
	HRESULT t_Result = S_OK ;

	switch ( a_HostingValue )
	{
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalSystemHostOrSelfHost:
		{
			a_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedLocalSystemHost ) ;

		}
		break ;

		case e_Hosting_SharedNetworkServiceHost:
		{
			a_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedNetworkServiceHost ) ;
		}
		break ;

		case e_Hosting_SharedLocalServiceHost:
		{
			a_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedLocalServiceHost ) ;
		}
		break ;

		default:
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}
		break ;
	}
	if ( SUCCEEDED(t_Result) && (0 == a_HostingGroup) ) t_Result = WBEM_E_OUT_OF_MEMORY;
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: GetHostingGroup ( 

	LPCWSTR a_Hosting , 
	size_t a_Prefix ,
	Enum_Hosting a_ExpectedHostingValue ,
	Enum_Hosting & a_HostingValue ,
	BSTR & a_HostingGroup 
)
{
	HRESULT t_Result = S_OK ;

	size_t t_Length = wcslen ( a_Hosting ) ;

	if ( t_Length > a_Prefix )
	{
		if ( a_Hosting [ a_Prefix ] == L':' ) 
		{
			if ( t_Length > a_Prefix + 1 )
			{
				a_HostingGroup = SysAllocString ( & a_Hosting [ a_Prefix + 1 ] ) ;
				if ( a_HostingGroup )
				{
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				a_HostingValue = a_ExpectedHostingValue ;
			}
			else
			{
				t_Result = GetDefaultHostingGroup ( a_ExpectedHostingValue , a_HostingGroup ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}
	}
	else
	{
		t_Result = GetDefaultHostingGroup ( a_ExpectedHostingValue , a_HostingGroup ) ;

		a_HostingValue = a_ExpectedHostingValue ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define StateAction_Accept		1	// Add the char to the token
#define StateAction_Consume		2	// Consume the char without adding to token
#define StateAction_Pushback	4	// Place the char back in the source buffer for next token
#define StateAction_Not			8	// A match occurs if the char is NOT the one specified
#define StateAction_Linefeed	16	// Increase the source linecount
#define StateAction_Return		32	// Return the indicated token to caller
#define StateAction_Any			64	// wchar_t(0xFFFF) Any character
#define StateAction_Empty		128	// wchar_t(0xFFFE) When subrange is not specified

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

struct StateTableEntry
{
	wchar_t m_LowerRange ;
	wchar_t m_UpperRange ;

	ULONG m_Token ;
	ULONG m_GotoState ;
	ULONG m_Action ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum LexicalStatus
{
	Success ,
	Syntax_Error ,
	Lexical_Error ,
	Failed ,
	Buffer_Too_Small ,
	ImpossibleState ,
	UnexpectedEof ,
	OutOfMemory 
} ;	

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define TOKEN_IDENTITY			1
#define TOKEN_LEFTPARENTHESIS	2
#define TOKEN_RIGHTPARENTHESIS	3
#define TOKEN_TRUE				4
#define TOKEN_FALSE				5
#define TOKEN_EOF				6
#define TOKEN_ERROR				7

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

struct StateTableEntry g_StateTable [] = {

	' ',			65534 ,				0 ,							0 ,			StateAction_Consume		,		// 0
	'\t',			65534 ,				0 ,							0 ,			StateAction_Consume		,		// 1
	'a',			'z',				0 ,							8 ,			StateAction_Accept		,		// 2
	'A',			'Z',				0 ,							8 ,			StateAction_Accept		,		// 3
	'(',			65534 ,				TOKEN_LEFTPARENTHESIS ,		0 ,			StateAction_Return		,		// 4
	')',			65534 ,				TOKEN_RIGHTPARENTHESIS ,	0 ,			StateAction_Return		,		// 5
	0,				65534 ,				TOKEN_EOF ,					0 ,			StateAction_Return		,		// 6
	65535,			65534 ,				TOKEN_ERROR ,				0 ,			StateAction_Return		,		// 7

	'a',			'z',				0	,						8 ,			StateAction_Accept		,		// 8
	'A',			'Z',				0	,						8 ,			StateAction_Accept		,		// 9
	65535,			65534 ,				TOKEN_IDENTITY ,			0 ,			StateAction_Pushback | StateAction_Return	// 10
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LexicalStatus LexicalAnalyser_NextToken ( 

	StateTableEntry *a_Dfa , 
	ULONG a_DfaSize ,
	const wchar_t *a_Stream , 
	ULONG a_Position , 
	ULONG &a_Token , 
	ULONG &a_NextPosition , 
	wchar_t *&a_TokenText
)
{
	LexicalStatus t_Status = Success ;

	a_Token = 0 ;
	a_TokenText = NULL ;
	a_NextPosition = a_Position ;

	ULONG t_State = 0 ;
    BOOL t_Read = TRUE ;
	BOOL t_EndOfFile = FALSE ;
    wchar_t t_Current = 0 ;
	ULONG CurrentLine = 0 ;
	wchar_t *t_TokenText = NULL ;
	ULONG t_TokenTextActualSize = 0 ;
	ULONG t_TokenTextBufferSize = 0 ;

    while ( 1 )
	{
		wchar_t t_First = a_Dfa [ t_State ].m_LowerRange ;
		wchar_t t_Last = a_Dfa [ t_State ].m_UpperRange ;
		ULONG t_GotoState = a_Dfa [ t_State ].m_GotoState ;
		ULONG t_ReturnToken = a_Dfa [ t_State ].m_Token ;
		ULONG t_Action = a_Dfa [ t_State ].m_Action ;

        if ( t_Read )
		{
			if ( t_EndOfFile ) 
			{
				t_Status = UnexpectedEof ;

				delete [] t_TokenText ;

				return t_Status ;
			}

            if ( a_NextPosition > wcslen ( a_Stream ) )
			{
				t_Current = 0 ;

				t_EndOfFile = TRUE ;
			}
			else
			{
				t_Current = a_Stream [ a_NextPosition ] ;
			}
		}

        BOOL t_Match = FALSE ;

        if ( t_First == 65535 )
		{
            t_Match = TRUE ;
		}
		else
        {
			if ( t_Last == 65534 )
			{
				if ( t_Current == t_First ) 
				{
					t_Match = TRUE ;
				}
	            else 
				{
					if ( ( t_Action & StateAction_Not ) && ( t_Current != t_First ) )
					{
                		t_Match = TRUE ;
					}
				}
			}
			else
			{
				if ( ( t_Action & StateAction_Not ) && ( ! ( ( t_Current >= t_First ) && ( t_Current <= t_Last ) ) ) )
				{
					t_Match = TRUE ;
				}
				else 
				{
					if ( ( t_Current >= t_First ) && ( t_Current <= t_Last ) )
					{
						t_Match = TRUE ;
					}
				}
			}
        }

        t_Read = FALSE ;

        if ( t_Match )
		{
            if ( t_Action & StateAction_Accept )
			{
				if ( t_TokenText )
				{
					if ( t_TokenTextActualSize < t_TokenTextBufferSize - 1 )
					{
					}
					else
					{
						t_TokenTextBufferSize = t_TokenTextBufferSize + 32 ;
						wchar_t *t_TempTokenText = new wchar_t [ t_TokenTextBufferSize ] ;
						if ( t_TempTokenText )
						{
							CopyMemory ( t_TempTokenText , t_TokenText , ( t_TokenTextActualSize ) * sizeof ( wchar_t ) ) ;

							delete [] t_TokenText ;
							t_TokenText = t_TempTokenText ;
						}
						else
						{
							delete [] t_TokenText ;

							return OutOfMemory ;
						}
					}

					t_TokenText [ t_TokenTextActualSize ] = t_Current ;
					t_TokenText [ t_TokenTextActualSize + 1 ] = 0 ;

					t_TokenTextActualSize ++ ;
				}
				else
				{
					t_TokenTextActualSize = 1 ;
					t_TokenTextBufferSize = 32 ;

					t_TokenText = new wchar_t [ t_TokenTextBufferSize ] ;
					if ( t_TokenText )
					{
						t_TokenText [ 0 ] = t_Current ;
						t_TokenText [ 1 ] = 0 ;
					}
					else
					{
						return OutOfMemory ;
					}
				}

                t_Read = TRUE ;
			}

            if ( t_Action & StateAction_Consume )
			{
               t_Read = TRUE ;
			}

            if ( t_Action & StateAction_Pushback )
			{
                t_Read = TRUE ;

                a_NextPosition = a_NextPosition - 1 ;
            }

            if ( t_Action & StateAction_Linefeed )
			{
                CurrentLine = CurrentLine + 1 ;
			}

			a_NextPosition = a_NextPosition + 1 ;

            if ( t_Action & StateAction_Return )
			{
                a_Token = t_ReturnToken ;
				a_TokenText = t_TokenText ;
				return t_Status ;
			}

            t_State = t_GotoState ;
        }
		else
		{
            t_State = t_State + 1 ;
		}
	}

	delete [] t_TokenText ;

    return ImpossibleState ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: GetDecoupledImpersonationRestriction ( 

	LPCWSTR a_Hosting , 
	BOOL &a_ImpersonationRestriction 
)
{
	HRESULT t_Result = S_OK ;

	if ( wbem_wcsicmp ( a_Hosting , s_Strings_Wmi_Decoupled ) != 0 )
	{
		if ( wbem_wcsnicmp ( a_Hosting , s_Strings_Wmi_DecoupledColon , ( sizeof ( s_Strings_Wmi_DecoupledColon ) / sizeof ( WCHAR ) - 1 ) ) == 0 )
		{
			const wchar_t *t_Scan = & a_Hosting [ ( sizeof ( s_Strings_Wmi_DecoupledColon ) / sizeof ( WCHAR ) - 1 ) ] ;

			ULONG t_Position = 0 ; 
			ULONG t_Token = 0 ;
			ULONG t_NextPosition = 0 ; 
			wchar_t *t_FoldText = NULL ;

			LexicalStatus t_Status = LexicalAnalyser_NextToken ( 

				g_StateTable ,
				sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
				t_Scan ,
				t_Position , 
				t_Token , 
				t_NextPosition , 
				t_FoldText
			) ;

			if ( ( t_Status == Success ) && ( t_Token == TOKEN_IDENTITY ) && (t_FoldText!=0) && ( wbem_wcsicmp ( t_FoldText , L"FoldIdentity" ) == 0 ) )
			{
				wchar_t *t_IgnoreText = NULL ;

				t_Position = t_NextPosition ;

				t_Status = LexicalAnalyser_NextToken ( 

					g_StateTable ,
					sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
					t_Scan ,
					t_Position , 
					t_Token , 
					t_NextPosition , 
					t_IgnoreText
				) ;

				delete [] t_IgnoreText ;

				if ( ( t_Status == Success ) && ( t_Token == TOKEN_LEFTPARENTHESIS ) )
				{
					wchar_t *t_ValueText = NULL ;

					t_Position = t_NextPosition ;

					t_Status = LexicalAnalyser_NextToken ( 

						g_StateTable ,
						sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
						t_Scan ,
						t_Position , 
						t_Token , 
						t_NextPosition , 
						t_ValueText
					) ;

					if ( ( t_Status == Success ) && ( t_Token == TOKEN_IDENTITY ) && ( wbem_wcsicmp ( t_ValueText , L"TRUE" ) == 0 ) )
					{
						a_ImpersonationRestriction = TRUE ;
					}
					else if ( ( t_Status == Success ) && ( t_Token == TOKEN_IDENTITY ) && ( wbem_wcsicmp ( t_ValueText , L"FALSE" ) == 0 ) )
					{
						a_ImpersonationRestriction = FALSE ;
					}
					else
					{
						t_Status = Syntax_Error ;
					}

					delete [] t_ValueText ;
				}
				else
				{
					t_Status = Syntax_Error ;
				}

				if ( t_Status == Success ) 
				{
					wchar_t *t_IgnoreText = NULL ;

					t_Position = t_NextPosition ;

					t_Status = LexicalAnalyser_NextToken ( 

						g_StateTable ,
						sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
						t_Scan ,
						t_Position , 
						t_Token , 
						t_NextPosition , 
						t_IgnoreText
					) ;

					if ( ( t_Status == Success ) && ( t_Token == TOKEN_RIGHTPARENTHESIS ) )
					{
					}
					else
					{
						t_Status = Syntax_Error ;
					}

					delete [] t_IgnoreText ;
				}

				if ( t_Status == Success ) 
				{
					wchar_t *t_IgnoreText = NULL ;

					t_Position = t_NextPosition ;

					t_Status = LexicalAnalyser_NextToken ( 

						g_StateTable ,
						sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
						t_Scan ,
						t_Position , 
						t_Token , 
						t_NextPosition , 
						t_IgnoreText
					) ;

					if ( ( t_Status == Success ) && ( t_Token == TOKEN_EOF ) )
					{
					}
					else
					{
						t_Status = Syntax_Error ;
					}

					delete [] t_IgnoreText ;
				}
			}
			else
			{
				t_Status = Syntax_Error ;
			}

			delete [] t_FoldText ;

			if ( t_Status != Success ) 
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: GetHosting ( 

	LPCWSTR a_Hosting , 
	Enum_Hosting & a_HostingValue ,
	LPWSTR &a_HostingGroup ,
	BOOL & a_ImpersonationRestriction
)
{
	HRESULT t_Result = S_OK ;

	if ( wbem_wcsicmp ( a_Hosting , s_Strings_Wmi_WmiCore ) == 0 )
	{
		a_HostingValue = e_Hosting_WmiCore ;
	}
	else if ( wbem_wcsicmp ( a_Hosting , s_Strings_Wmi_WmiCoreOrSelfHost ) == 0 )
	{
		a_HostingValue = e_Hosting_WmiCoreOrSelfHost ;
	}
	else if ( wbem_wcsicmp ( a_Hosting , s_Strings_Wmi_SelfHost ) == 0 )
	{
		a_HostingValue = e_Hosting_SelfHost ;
	}
	else if ( wbem_wcsnicmp ( a_Hosting , s_Strings_Wmi_Decoupled , ( sizeof ( s_Strings_Wmi_Decoupled ) / sizeof ( WCHAR ) -1 ) ) == 0 )
	{
		a_HostingValue = e_Hosting_Decoupled ;

		t_Result = GetDecoupledImpersonationRestriction ( 

			a_Hosting , 
			a_ImpersonationRestriction 
		) ;
	}
	else if ( wbem_wcsicmp ( a_Hosting , s_Strings_Wmi_NonCom ) == 0 )
	{
		a_HostingValue = e_Hosting_NonCom ;
	}
	else if ( wbem_wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedLocalSystemHostOrSelfHost , ( sizeof ( s_Strings_Wmi_SharedLocalSystemHostOrSelfHost ) / sizeof ( WCHAR ) - 1 ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedLocalSystemHostOrSelfHost ) / sizeof ( WCHAR ) - 1 ) ,
			e_Hosting_SharedLocalSystemHostOrSelfHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}	
	else if ( wbem_wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedLocalSystemHost , ( sizeof ( s_Strings_Wmi_SharedLocalSystemHost ) / sizeof ( WCHAR ) - 1 ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedLocalSystemHost ) / sizeof ( WCHAR ) - 1 ) ,
			e_Hosting_SharedLocalSystemHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else if ( wbem_wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedNetworkServiceHost , ( sizeof ( s_Strings_Wmi_SharedNetworkServiceHost ) / sizeof ( WCHAR ) - 1 ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedNetworkServiceHost ) / sizeof ( WCHAR ) - 1 ) ,
			e_Hosting_SharedNetworkServiceHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else if ( wbem_wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedLocalServiceHost , ( sizeof ( s_Strings_Wmi_SharedLocalServiceHost ) / sizeof ( WCHAR ) - 1 ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedLocalServiceHost ) / sizeof ( WCHAR ) - 1 ) ,
			e_Hosting_SharedLocalServiceHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object ,
	LPCWSTR a_ProviderName 
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Mask & e_Version )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Version , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_Version = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_Version = 1 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Name )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Name , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_ProviderName ) 
					{
						SysFreeString ( m_ProviderName ) ;
					}

					m_ProviderName = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_ProviderName == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Enabled )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Enabled , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_Enabled = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_Enabled = TRUE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Clsid  )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Clsid , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					t_Result = CLSIDFromString ( t_Variant.bstrVal , & m_CLSID ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = m_ClsidServer.Load ( (LPCWSTR) t_Variant.bstrVal , a_ProviderName ) ;
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_CLSID = CLSID_NULL ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ClientClsid  )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_ClientClsid , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					t_Result = CLSIDFromString ( t_Variant.bstrVal , & m_ClientCLSID ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_ClientCLSID = CLSID_NULL ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_DefaultMachineName )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_DefaultMachineName , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_DefaultMachineName )
					{
						SysFreeString ( m_DefaultMachineName ) ;
					}

					m_DefaultMachineName = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_DefaultMachineName == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_DefaultMachineName )
					{
						SysFreeString ( m_DefaultMachineName ) ;
						m_DefaultMachineName = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_UnloadTimeout )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_UnloadTimeout , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_UnloadTimeout )
					{
						SysFreeString ( m_UnloadTimeout ) ;
					}

					m_UnloadTimeout = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_UnloadTimeout )
					{
						CWbemDateTime t_Interval ;
						t_Result = t_Interval.PutValue ( m_UnloadTimeout ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT_BOOL t_Bool = VARIANT_FALSE ;
							t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
							if ( t_Bool == VARIANT_TRUE )
							{
								LONG t_MicroSeconds = 0 ;
								LONG t_Seconds = 0 ;
								LONG t_Minutes = 0 ;
								LONG t_Hours = 0 ;
								LONG t_Days = 0 ;

								t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
								t_Interval.GetSeconds ( & t_Seconds ) ;
								t_Interval.GetMinutes ( & t_Minutes ) ;
								t_Interval.GetHours ( & t_Hours ) ;
								t_Interval.GetDay ( & t_Days ) ;

								m_UnloadTimeoutMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
															  ( t_Hours * 60 * 60 * 1000 ) +
															  ( t_Minutes * 60 * 1000 ) +
															  ( t_Seconds * 1000 ) +
															  ( t_MicroSeconds / 1000 ) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_UnloadTimeout )
					{
						SysFreeString ( m_UnloadTimeout ) ;
						m_UnloadTimeout = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ImpersonationLevel )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_ImpersonationLevel , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_I4 )
				{
					switch ( t_Variant.lVal )
					{
						case 0:
						{
							m_ImpersonationLevel = e_Impersonate_None ;		
						}
						break ;

						case 1:
						{
							m_ImpersonationLevel = e_Impersonate ;
						}
						break ;

						default:
						{
							if ( m_Version > 1 )
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
							else
							{
								m_ImpersonationLevel = e_Impersonate_None ;	
							}
						}
						break ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_ImpersonationLevel = e_Impersonate_None ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsSendStatus )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SupportsSendStatus , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsSendStatus = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsSendStatus = TRUE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsShutdown )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SupportsShutdown , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsShutdown = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsShutdown = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}
			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsQuotas )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SupportsQuotas , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsQuotas = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsQuotas = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}
			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_OperationTimeoutInterval )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_OperationTimeoutInterval , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_OperationTimeout )
					{
						SysFreeString ( m_OperationTimeout ) ;
					}

					m_OperationTimeout = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_OperationTimeout )
					{
						CWbemDateTime t_Interval ;
						t_Result = t_Interval.PutValue ( m_OperationTimeout ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT_BOOL t_Bool = VARIANT_FALSE ;
							t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
							if ( t_Bool == VARIANT_TRUE )
							{
								LONG t_MicroSeconds = 0 ;
								LONG t_Seconds = 0 ;
								LONG t_Minutes = 0 ;
								LONG t_Hours = 0 ;
								LONG t_Days = 0 ;

								t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
								t_Interval.GetSeconds ( & t_Seconds ) ;
								t_Interval.GetMinutes ( & t_Minutes ) ;
								t_Interval.GetHours ( & t_Hours ) ;
								t_Interval.GetDay ( & t_Days ) ;

								m_OperationTimeoutMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
															  ( t_Hours * 60 * 60 * 1000 ) +
															  ( t_Minutes * 60 * 1000 ) +
															  ( t_Seconds * 1000 ) +
															  ( t_MicroSeconds / 1000 ) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_OperationTimeout )
					{
						SysFreeString ( m_OperationTimeout ) ;
						m_UnloadTimeout = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}
			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_InitializationTimeoutInterval )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_InitializationTimeoutInterval , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_InitializationTimeout )
					{
						SysFreeString ( m_InitializationTimeout ) ;
					}

					m_InitializationTimeout = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_InitializationTimeout )
					{
						CWbemDateTime t_Interval ;
						t_Result = t_Interval.PutValue ( m_InitializationTimeout ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT_BOOL t_Bool = VARIANT_FALSE ;
							t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
							if ( t_Bool == VARIANT_TRUE )
							{
								LONG t_MicroSeconds = 0 ;
								LONG t_Seconds = 0 ;
								LONG t_Minutes = 0 ;
								LONG t_Hours = 0 ;
								LONG t_Days = 0 ;

								t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
								t_Interval.GetSeconds ( & t_Seconds ) ;
								t_Interval.GetMinutes ( & t_Minutes ) ;
								t_Interval.GetHours ( & t_Hours ) ;
								t_Interval.GetDay ( & t_Days ) ;

								m_InitializationTimeoutMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
															  ( t_Hours * 60 * 60 * 1000 ) +
															  ( t_Minutes * 60 * 1000 ) +
															  ( t_Seconds * 1000 ) +
															  ( t_MicroSeconds / 1000 ) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_InitializationTimeout )
					{
						SysFreeString ( m_InitializationTimeout ) ;
						m_UnloadTimeout = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsThrottling )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SupportsThrottling , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsThrottling = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsThrottling = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}
			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ConcurrentIndependantRequests )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_ConcurrentIndependantRequests , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_I4 )
				{
					m_ConcurrentIndependantRequests = t_Variant.lVal ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_ConcurrentIndependantRequests = 0 ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}
			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_InitializationReentrancy )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_InitializationReentrancy , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_I4 )
				{
					switch ( t_Variant.lVal )
					{
						case 0:
						{
							m_InitializationReentrancy = e_InitializationReentrancy_Clsid ;		
						}
						break ;

						case 1:
						{
							m_InitializationReentrancy = e_InitializationReentrancy_Namespace ;
						}
						break ;

						case 2:
						{
							m_InitializationReentrancy = e_InitializationReentrancy_None ;
						}
						break ;

						default:
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
						break ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_InitializationReentrancy = e_InitializationReentrancy_Namespace;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}
			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_InitializeAsAdminFirst )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_InitializeAsAdminFirst , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_InitializeAsAdminFirst = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_InitializeAsAdminFirst = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}
			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_PerUserInitialization )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_PerUserInitialization , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_PerUserInitialization = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_PerUserInitialization = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}
			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_PerLocaleInitialization )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_PerLocaleInitialization , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_PerLocaleInitialization = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_PerLocaleInitialization = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}
			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Pure )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Pure , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_Pure = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_Pure = TRUE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}
			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Hosting )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Hosting , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					t_Result = GetHosting ( t_Variant.bstrVal , m_Hosting , m_HostingGroup , m_DecoupledImpersonationRestriction ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
#ifdef UNIQUE_HOST
						if ( m_HostingGroup )
						{
							SysFreeString ( m_HostingGroup ) ;
						}

						m_HostingGroup = SysAllocString ( GetProviderName () ) ;
						if ( m_HostingGroup == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
#else
#endif
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_Hosting = e_Hosting_SharedLocalSystemHostOrSelfHost ;

#ifdef UNIQUE_HOST
					m_HostingGroup = SysAllocString ( GetProviderName () ) ;
#else
					m_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedLocalSystemHostOrSelfHost ) ;
#endif
					if ( m_HostingGroup == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}
			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		switch ( GetHosting () )
		{
			case e_Hosting_NonCom:
			case e_Hosting_Decoupled:
			{
			}
			break ;

			default:
			{
				if ( GetClsidServer ().GetProviderClsid () == NULL )
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			break ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SecurityDescriptor )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SecurityDescriptor , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					BOOL t_Status = ConvertStringSecurityDescriptorToSecurityDescriptor (

						t_Variant.bstrVal ,
						SDDL_REVISION_1 ,
						( PSECURITY_DESCRIPTOR * ) & m_SecurityDescriptor,
						NULL 
					) ;

					if ( t_Status )
					{
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SecurityDescriptor = NULL ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}
			VariantClear ( & t_Variant ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_ObjectPath = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_ObjectPath , 
		L"__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\""
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( m_Identity )
		{
			m_Identity->Release () ;
		}

		t_Result = m_Repository->GetObject ( 

			t_ObjectPath ,
			0 ,
			m_Context , 
			& m_Identity , 
			NULL 
		) ;
	
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = QueryProperties ( 

				a_Mask ,
				m_Identity ,
				a_ProviderName 
			) ;
		}

		SysFreeString ( t_ObjectPath ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( m_Identity )
				{
					m_Identity->Release () ;
				}

				t_Result = m_Repository->GetObject ( 

					t_ObjectPath ,
					0 ,
					m_Context , 
					& m_Identity , 
					NULL 
				) ;
			
				if ( SUCCEEDED ( t_Result ) )
				{
					VARIANT t_Variant ;
					VariantInit ( & t_Variant ) ;
				
					LONG t_VarType = 0 ;
					LONG t_Flavour = 0 ;

					t_Result = m_Identity->Get ( L"Name" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Variant.vt == VT_BSTR )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								m_Identity ,
								t_Variant.bstrVal
							) ;
						}

						VariantClear ( & t_Variant ) ;
					}
				}

			}

			SysFreeString ( t_ObjectPath ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
				}
			}
		}

		VariantClear ( & t_Variant ) ;

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_InstanceProviderRegistrationV1 :: CServerObject_InstanceProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SupportsPut ( FALSE ) ,
	m_SupportsGet ( FALSE ) ,
	m_SupportsDelete ( FALSE ) ,
	m_SupportsEnumeration ( FALSE ) ,
	m_SupportsBatching ( FALSE ) ,
	m_SupportsTransactions ( FALSE ) ,
	m_Supported ( FALSE ) ,
	m_QuerySupportLevels ( e_QuerySupportLevels_Unknown ) ,
	m_InteractionType ( e_InteractionType_Unknown ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_InstanceProviderRegistrationV1::~CServerObject_InstanceProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_InstanceProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_InstanceProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	if ( a_Mask & e_SupportsPut )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsPut , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsPut = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsPut = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}
		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_SupportsGet) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsGet , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsGet = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsGet = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_SupportsDelete) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsDelete , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsDelete = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsDelete = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_SupportsEnumeration) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsEnumeration , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsEnumeration = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsEnumeration = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_SupportsBatching) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsBatching , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsBatching = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsBatching = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_SupportsTransactions) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsTransactions , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsTransactions = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsTransactions = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_QuerySupportLevels) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_QuerySupportLevels , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == ( VT_BSTR | VT_ARRAY ) )
			{
				if ( SafeArrayGetDim ( t_Variant.parray ) == 1 )
				{
					LONG t_Dimension = 1 ; 

					LONG t_Lower ;
					SafeArrayGetLBound ( t_Variant.parray , t_Dimension , & t_Lower ) ;

					LONG t_Upper ;
					SafeArrayGetUBound ( t_Variant.parray , t_Dimension , & t_Upper ) ;

					LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

					if ( t_Count ) 
					{
						for ( LONG t_ElementIndex = t_Lower ; t_ElementIndex <= t_Upper ; t_ElementIndex ++ )
						{
							BSTR t_Element ;
							if ( SUCCEEDED ( SafeArrayGetElement ( t_Variant.parray , &t_ElementIndex , & t_Element ) ) )
							{
								if ( wbem_wcsicmp ( s_Strings_QuerySupportLevels_UnarySelect , t_Element ) == 0 )
								{
									m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_UnarySelect ;
								}
								else if ( wbem_wcsicmp ( s_Strings_QuerySupportLevels_References , t_Element ) == 0 )
								{
									m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_References ;
								}
								else if ( wbem_wcsicmp ( s_Strings_QuerySupportLevels_Associators , t_Element ) == 0 )
								{
									m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_Associators ;
								}
								else if ( wbem_wcsicmp ( s_Strings_QuerySupportLevels_V1ProviderDefined , t_Element ) == 0 )
								{
									m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_V1ProviderDefined ;
								}
								else
								{
									t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
								}

								SysFreeString ( t_Element ) ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_QuerySupportLevels = e_QuerySupportLevels_None ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_InteractionType) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_InteractionType , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				switch ( t_Variant.lVal )
				{
					case 0:
					{
						m_InteractionType = e_InteractionType_Pull ;
					}
					break ;

					case 1:
					{
						m_InteractionType = e_InteractionType_Push ;
					}
					break ;

					case 2:
					{
						m_InteractionType = e_InteractionType_PushVerify ;
					}
					break ;

					default:
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
					break ;
				}
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_InteractionType = e_InteractionType_Pull ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( wbem_wcsicmp ( s_Strings_InstanceProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery ( 

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ClassProviderRegistrationV1 :: CServerObject_ClassProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SupportsPut ( FALSE ) ,
	m_SupportsGet ( FALSE ) ,
	m_SupportsDelete ( FALSE ) ,
	m_SupportsEnumeration ( FALSE ) ,
	m_SupportsBatching ( FALSE ) ,
	m_SupportsTransactions ( FALSE ) ,
	m_Supported ( FALSE ) ,
	m_ReSynchroniseOnNamespaceOpen ( FALSE ) ,
	m_PerUserSchema ( FALSE ) ,
	m_HasReferencedSet( FALSE ),
	m_CacheRefreshInterval ( NULL ) ,
	m_CacheRefreshIntervalMilliSeconds ( 0 ) ,
	m_QuerySupportLevels ( e_QuerySupportLevels_Unknown ) ,
	m_InteractionType ( e_InteractionType_Unknown ) ,
	m_ResultSetQueryTreeCount ( 0 ) ,
	m_UnSupportedQueryTreeCount ( 0 ) ,
	m_ReferencedSetQueryTreeCount ( 0 ) ,
	m_ResultSetQueryTree ( NULL ) ,
	m_UnSupportedQueryTree ( NULL ) ,
	m_ReferencedSetQueryTree ( NULL ) ,
	m_ProviderName ( NULL ) ,
	m_Version ( 1 ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ClassProviderRegistrationV1::~CServerObject_ClassProviderRegistrationV1 ()
{
	if ( m_ResultSetQueryTree )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_ResultSetQueryTreeCount ; t_Index ++ )
		{
			if ( m_ResultSetQueryTree [ t_Index ] )
			{
				delete m_ResultSetQueryTree [ t_Index ] ;
			}
		}

		delete [] m_ResultSetQueryTree ;
	}

	if ( m_UnSupportedQueryTree )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_UnSupportedQueryTreeCount ; t_Index ++ )
		{
			if ( m_UnSupportedQueryTree [ t_Index ] )
			{
				delete m_UnSupportedQueryTree [ t_Index ] ;
			}
		}

		delete [] m_UnSupportedQueryTree ;
	}

	if ( m_ReferencedSetQueryTree )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_ReferencedSetQueryTreeCount ; t_Index ++ )
		{
			if ( m_ReferencedSetQueryTree [ t_Index ] )
			{
				delete m_ReferencedSetQueryTree [ t_Index ] ;
			}
		}

		delete [] m_ReferencedSetQueryTree ;
	}

	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	if ( m_ProviderName ) 
	{
		delete [] m_ProviderName ;
	}

	if ( m_CacheRefreshInterval )
	{
		SysFreeString ( m_CacheRefreshInterval ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ClassProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ClassProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: ParseQuery ( 

	ULONG &a_Count ,
	WmiTreeNode **&a_Root , 
	SAFEARRAY *a_Array
)

{
	HRESULT t_Result = S_OK ;

	if ( SafeArrayGetDim ( a_Array ) == 1 )
	{
		LONG t_Dimension = 1 ; 

		LONG t_Lower ;
		SafeArrayGetLBound ( a_Array , t_Dimension , & t_Lower ) ;

		LONG t_Upper ;
		SafeArrayGetUBound ( a_Array , t_Dimension , & t_Upper ) ;

		LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

		a_Root = NULL ;
		a_Count = t_Count ;

		if ( t_Count )
		{
			a_Root = new WmiTreeNode * [ t_Count ] ;
			if ( a_Root ) 
			{
				ZeroMemory ( a_Root , sizeof ( WmiTreeNode * ) * t_Count ) ;

				for ( LONG t_ElementIndex = t_Lower ; SUCCEEDED ( t_Result ) && ( t_ElementIndex <= t_Upper ) ; t_ElementIndex ++ )
				{
					BSTR t_Element ;
					if ( SUCCEEDED ( t_Result = SafeArrayGetElement ( a_Array , &t_ElementIndex , & t_Element ) ) )
					{
						QueryPreprocessor t_PreProcessor ;

						IWbemQuery *t_QueryAnalyser = NULL ;
						t_Result = CoCreateInstance (

							CLSID_WbemQuery ,
							NULL ,
							CLSCTX_INPROC_SERVER ,
							IID_IWbemQuery ,
							( void ** ) & t_QueryAnalyser
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							switch ( t_PreProcessor.Query ( t_Element , t_QueryAnalyser ) )
							{
								case QueryPreprocessor :: State_True:
								{
									WmiTreeNode *t_Root = NULL ;

									switch ( t_PreProcessor.PreProcess ( m_Context , t_QueryAnalyser , t_Root ) )
									{
										case QueryPreprocessor :: State_True:
										{
											a_Root [ t_ElementIndex - t_Lower ] = t_Root ;
										}
										break ;

										case QueryPreprocessor :: State_Error:
										{
											t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
										}
										break;

										default:
										{
											t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
										}
										break ;
									}
								}
								break ;

								case QueryPreprocessor :: State_Error:
								{
									t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
								}
								break;

								default:
								{
									t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
								}
								break ;

							}

							t_QueryAnalyser->Release () ;
						}

						SysFreeString ( t_Element ) ;
					}
				}

				if ( FAILED ( t_Result ) ) 
				{
					for ( LONG t_ElementIndex = t_Lower ; t_ElementIndex <= t_Upper ; t_ElementIndex ++ )
					{
						delete a_Root [ t_ElementIndex  - t_Lower] ;
					}

					delete [] a_Root ;
					a_Root = NULL ;
					a_Count = 0 ;

					if ( m_Version == 1 )
					{
						t_Result = S_OK ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	if ( a_Mask & e_Version )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_Version , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_Version = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_Version = 1 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsPut )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsPut , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsPut = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsPut = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsGet )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsGet , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsGet = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsGet = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsDelete )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsDelete , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsDelete = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsDelete = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}
			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsEnumeration )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsEnumeration , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsEnumeration = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsEnumeration = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}
			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsBatching )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsBatching , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsBatching = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsBatching = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsTransactions )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsTransactions , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsTransactions = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsTransactions = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_PerUserSchema )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_PerUserSchema , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_PerUserSchema = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_PerUserSchema = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ReSynchroniseOnNamespaceOpen )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_ReSynchroniseOnNamespaceOpen , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_ReSynchroniseOnNamespaceOpen = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_ReSynchroniseOnNamespaceOpen = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_QuerySupportLevels  )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_QuerySupportLevels , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == ( VT_BSTR | VT_ARRAY ) )
				{
					if ( SafeArrayGetDim ( t_Variant.parray ) == 1 )
					{
						LONG t_Dimension = 1 ; 

						LONG t_Lower ;
						SafeArrayGetLBound ( t_Variant.parray , t_Dimension , & t_Lower ) ;

						LONG t_Upper ;
						SafeArrayGetUBound ( t_Variant.parray , t_Dimension , & t_Upper ) ;

						LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

						if ( t_Count )
						{
							for ( LONG t_ElementIndex = t_Lower ; t_ElementIndex <= t_Upper ; t_ElementIndex ++ )
							{
								BSTR t_Element ;
								if ( SUCCEEDED ( SafeArrayGetElement ( t_Variant.parray , &t_ElementIndex , & t_Element ) ) )
								{
									if ( wbem_wcsicmp ( s_Strings_QuerySupportLevels_UnarySelect , t_Element ) == 0 )
									{
										m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_UnarySelect ;
									}
									else if ( wbem_wcsicmp ( s_Strings_QuerySupportLevels_References , t_Element ) == 0 )
									{
										m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_References ;
									}
									else if ( wbem_wcsicmp ( s_Strings_QuerySupportLevels_Associators , t_Element ) == 0 )
									{
										m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_Associators ;
									}
									else if ( wbem_wcsicmp ( s_Strings_QuerySupportLevels_V1ProviderDefined , t_Element ) == 0 )
									{
										m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_V1ProviderDefined ;
									}
									else
									{
										t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
									}

									SysFreeString ( t_Element ) ;
								}
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_QuerySupportLevels = e_QuerySupportLevels_None ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_InteractionType )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_InteractionType , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_I4 )
				{
					switch ( t_Variant.lVal )
					{
						case 0:
						{
							m_InteractionType = e_InteractionType_Pull ;
						}
						break ;

						case 1:
						{
							m_InteractionType = e_InteractionType_Push ;
						}
						break ;

						case 2:
						{
							m_InteractionType = e_InteractionType_PushVerify ;
						}
						break ;

						default:
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
						break ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_InteractionType = e_InteractionType_Pull ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ResultSetQueries )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_ResultSetQueries , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == ( VT_ARRAY | VT_BSTR ) )
				{
					t_Result = ParseQuery ( m_ResultSetQueryTreeCount , m_ResultSetQueryTree , t_Variant.parray ) ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
				}
				else
				{
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_UnSupportedQueries )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_UnSupportedQueries , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == ( VT_ARRAY | VT_BSTR ) )
				{
					t_Result = ParseQuery ( m_UnSupportedQueryTreeCount , m_UnSupportedQueryTree , t_Variant.parray ) ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
				}
				else
				{
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}
			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ReferencedSetQueries )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_ReferencedSetQueries , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == ( VT_ARRAY | VT_BSTR ) )
				{
					t_Result = ParseQuery ( m_ReferencedSetQueryTreeCount , m_ReferencedSetQueryTree , t_Variant.parray ) ;

					// Backwards compatibility.
					// W2K code, Query is not really parsed, as long as there is a
					// value, m_HasReferencedSet is TRUE.
					LONG t_Lower ;
					SafeArrayGetLBound ( t_Variant.parray , 1 , & t_Lower ) ;

					LONG t_Upper ;
					SafeArrayGetUBound ( t_Variant.parray , 1 , & t_Upper ) ;

					LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

					m_HasReferencedSet = ( ( t_Upper - t_Lower ) + 1 ) > 0;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
				}
				else
				{
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_CacheRefreshInterval )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_CacheRefreshInterval , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_CacheRefreshInterval )
					{
						SysFreeString ( m_CacheRefreshInterval ) ;
					}

					m_CacheRefreshInterval = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_CacheRefreshInterval )
					{
						CWbemDateTime t_Interval ;
						t_Result = t_Interval.PutValue ( m_CacheRefreshInterval ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT_BOOL t_Bool = VARIANT_FALSE ;
							t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
							if ( t_Bool == VARIANT_TRUE )
							{
								LONG t_MicroSeconds = 0 ;
								LONG t_Seconds = 0 ;
								LONG t_Minutes = 0 ;
								LONG t_Hours = 0 ;
								LONG t_Days = 0 ;

								t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
								t_Interval.GetSeconds ( & t_Seconds ) ;
								t_Interval.GetMinutes ( & t_Minutes ) ;
								t_Interval.GetHours ( & t_Hours ) ;
								t_Interval.GetDay ( & t_Days ) ;

								m_CacheRefreshIntervalMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
															  ( t_Hours * 60 * 60 * 1000 ) +
															  ( t_Minutes * 60 * 1000 ) +
															  ( t_Seconds * 1000 ) +
															  ( t_MicroSeconds / 1000 ) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_CacheRefreshInterval )
					{
						SysFreeString ( m_CacheRefreshInterval ) ;
						m_CacheRefreshInterval = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( ( m_InteractionType == e_InteractionType_Pull ) && ( ( m_SupportsEnumeration == FALSE ) || ( m_SupportsGet == FALSE ) ) )
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( wbem_wcsicmp ( s_Strings_ClassProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			m_ProviderName = DupString(a_ProviderName) ;
			if ( m_ProviderName == 0) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemPathKeyList *t_Keys = NULL ;

						t_Result = a_Provider->GetKeyList (

							& t_Keys 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							ULONG t_ProviderNameLength = 0 ;
							ULONG t_Type = 0 ;

							t_Result = t_Keys->GetKey (

								0 ,
								0 ,
								NULL ,
								NULL ,
								& t_ProviderNameLength ,
								m_ProviderName ,
								& t_Type
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								m_ProviderName = new wchar_t [ ( t_ProviderNameLength / sizeof ( wchar_t ) ) + 1 ] ;
								if ( m_ProviderName ) 
								{
									t_Result = t_Keys->GetKey (

										0 ,
										0 ,
										NULL ,
										NULL ,
										& t_ProviderNameLength ,
										m_ProviderName ,
										& t_Type
									) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY;
								}
							}

							t_Keys->Release () ;
						}
					}
					
					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath * a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	if ( FAILED ( t_Result ) )
	{
		m_Result = t_Result ;
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_MethodProviderRegistrationV1 :: CServerObject_MethodProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SupportsMethods ( FALSE ) ,
	m_Supported ( FALSE ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_MethodProviderRegistrationV1::~CServerObject_MethodProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_MethodProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_MethodProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_SupportsMethods = TRUE ;

	m_Supported = TRUE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( wbem_wcsicmp ( s_Strings_MethodProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DynamicPropertyProviderRegistrationV1 :: CServerObject_DynamicPropertyProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SupportsPut ( FALSE ) ,
	m_SupportsGet ( FALSE ) ,
	m_Supported ( FALSE ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DynamicPropertyProviderRegistrationV1::~CServerObject_DynamicPropertyProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DynamicPropertyProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DynamicPropertyProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	if ( a_Mask & e_SupportsPut )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsPut , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsPut = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsPut = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_SupportsGet) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsGet , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsGet = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsGet = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( wbem_wcsicmp ( s_Strings_PropertyProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_EventProviderRegistrationV1 :: CServerObject_EventProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Supported ( FALSE ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_EventProviderRegistrationV1::~CServerObject_EventProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_EventProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_EventProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( wbem_wcsicmp ( s_Strings_EventProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_EventConsumerProviderRegistrationV1 :: CServerObject_EventConsumerProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Supported ( FALSE ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_EventConsumerProviderRegistrationV1::~CServerObject_EventConsumerProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_EventConsumerProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_EventConsumerProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( wbem_wcsicmp ( s_Strings_EventConsumerProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRegistrationV1 :: CServerObject_ProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Result ( S_OK ) ,
	m_ReferenceCount ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRegistrationV1::~CServerObject_ProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	t_Result = m_ComRegistration.SetContext ( 

		a_Context ,
		a_Namespace ,
		a_Repository
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( wbem_wcsicmp ( s_Strings_InstanceProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_InstanceProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( wbem_wcsicmp ( s_Strings_ClassProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_ClassProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( wbem_wcsicmp ( s_Strings_MethodProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_MethodProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( wbem_wcsicmp ( s_Strings_PropertyProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_PropertyProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( wbem_wcsicmp ( s_Strings_EventProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_EventProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( wbem_wcsicmp ( s_Strings_EventConsumerProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_EventConsumerProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = m_ComRegistration.QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepository ( 
	
						a_Mask ,
						a_Scope , 
						t_Variant.bstrVal
					) ;
				}

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = m_ComRegistration.QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepository ( 

			a_Mask ,
			a_Scope , 
			a_Provider
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = m_ComRegistration.QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepository ( 

			a_Mask ,
			a_Scope , 
			a_Provider
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CServerObject_ProviderRegistrationV1 :: ObjectProvider ()
{
	BOOL t_Supported =	GetClassProviderRegistration ().Supported () ||
						GetInstanceProviderRegistration ().Supported () ||
						GetMethodProviderRegistration ().Supported () || 
						GetPropertyProviderRegistration ().Supported () ;

	return t_Supported ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CServerObject_ProviderRegistrationV1 :: EventProvider ()
{
	BOOL t_Supported =	GetEventConsumerProviderRegistration ().Supported () ||
						GetEventProviderRegistration ().Supported () ;

	return t_Supported ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\common\provdnf.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvTree.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <wbemint.h>
#include <typeinfo.h>
#include <stdio.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include "ProvDnf.h"
#include "wbemutil.h"
#include "autoptr.h"
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOrNode :: ~WmiOrNode ()
{
	delete m_Left ;
	delete m_Right ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiAndNode :: ~WmiAndNode ()
{
	delete m_Left ;
	delete m_Right ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiNotNode :: ~WmiNotNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualNode :: ~WmiOperatorEqualNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotEqualNode :: ~WmiOperatorNotEqualNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualOrGreaterNode :: ~WmiOperatorEqualOrGreaterNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualOrLessNode :: ~WmiOperatorEqualOrLessNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorGreaterNode :: ~WmiOperatorGreaterNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorLessNode :: ~WmiOperatorLessNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorLikeNode :: ~WmiOperatorLikeNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotLikeNode :: ~WmiOperatorNotLikeNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorIsANode :: ~WmiOperatorIsANode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotIsANode :: ~WmiOperatorNotIsANode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOrNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_RightCopy = NULL ;
	if ( m_Right )
	{
		t_RightCopy = m_Right->Copy () ;
		if ( t_RightCopy == NULL )
		{
			delete t_LeftCopy ;
			return NULL ;
		}
	}

	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOrNode ( t_LeftCopy , t_RightCopy , t_Parent ) ;
	if ( t_Node)
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}

		if ( t_RightCopy )
		{
			t_RightCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		delete t_RightCopy ;
		return 0;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiAndNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_RightCopy = NULL ;
	if ( m_Right )
	{
		t_RightCopy = m_Right->Copy () ;
		if ( t_RightCopy == NULL )
		{
			delete t_LeftCopy ;
			return NULL ;
		}
	}

	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiAndNode ( t_LeftCopy , t_RightCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}

		if ( t_RightCopy )
		{
			t_RightCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		delete t_RightCopy ;
		return 0;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNotNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiNotNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node)
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node)
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotEqualNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotEqualNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node)
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualOrGreaterNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualOrGreaterNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node)
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualOrLessNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualOrLessNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorGreaterNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorGreaterNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorLessNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorLessNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorLikeNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorLikeNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotLikeNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotLikeNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorIsANode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorIsANode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotIsANode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotIsANode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{	
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiSignedIntegerNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiSignedIntegerNode ( m_PropertyName , m_Integer , m_Index , t_Parent ) ;

	if (t_Node && t_Node->IsValid()) return t_Node;

	delete t_Node;
	return 0;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiUnsignedIntegerNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiUnsignedIntegerNode ( m_PropertyName , m_Integer , m_Index , t_Parent ) ;

	if (t_Node && t_Node->IsValid()) return t_Node;

	delete t_Node;
	return 0;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiStringNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiStringNode ( m_PropertyName , m_String , m_PropertyFunction , m_ConstantFunction , m_Index , t_Parent ) ;

	if (t_Node && t_Node->IsValid()) return t_Node;

	delete t_Node;
	return 0;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNullNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiNullNode ( m_PropertyName , m_Index , t_Parent ) ;

	if (t_Node && t_Node->IsValid()) return t_Node;

	delete t_Node;
	return 0;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiSignedIntegerRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiSignedIntegerRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	if (t_Node && t_Node->IsValid()) return t_Node;

	delete t_Node;
	return 0;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiUnsignedIntegerRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiUnsignedIntegerRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	if (t_Node && t_Node->IsValid()) return t_Node;

	delete t_Node;
	return 0;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiStringRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiStringRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	if (t_Node && t_Node->IsValid()) return t_Node;

	delete t_Node;
	return 0;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNullRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiNullRangeNode ( m_PropertyName , m_Index , NULL , NULL ) ;

	if (t_Node && t_Node->IsValid()) return t_Node;

	delete t_Node;
	return 0;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOrNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" Or "
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetRight () )
		GetRight ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiAndNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" And "
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetRight () )
		GetRight ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNotNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Not"
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" = "
	) ;
)
	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotEqualNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" != "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualOrGreaterNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" >= "
	) ;
)
	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualOrLessNode :: Print () 
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" <= "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorLessNode :: Print () 
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" < "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorGreaterNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" > "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorLikeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" Like "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotLikeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" NotLike "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorIsANode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" IsA "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotIsANode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" Not IsA "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiStringNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %s ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiUnsignedIntegerNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %ld ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiSignedIntegerNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %d ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNullNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , NULL ) " ,
		GetPropertyName ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiStringRangeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %s , %s ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? L"" : m_LowerBound ,
		m_InfiniteUpperBound ? L"" : m_UpperBound 
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiUnsignedIntegerRangeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %lu , %lu ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? 0 : m_LowerBound ,
		m_InfiniteUpperBound ? 0 : m_UpperBound  
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiSignedIntegerRangeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %ld , %ld ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? 0 : m_LowerBound ,
		m_InfiniteUpperBound ? 0 : m_UpperBound  
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNullRangeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , NULL ) " ,
		GetPropertyName ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerLess (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X < Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerLessOrEqual (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X <= Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerGreater (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X > Y ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerEqual (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return X == Y ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerLess (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X < Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerLessOrEqual (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X <= Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerGreater (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X > Y ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerEqual (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return X == Y ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringLess (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) < 0 ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
  		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringLessOrEqual (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) <= 0 ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringGreater (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) > 0 ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringEqual (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return wcscmp ( X , Y ) == 0 ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareLessOrEqualRangeNode ( 

	WmiRangeNode *a_LeftRange ,
	WmiRangeNode *a_RightRange
) 
{
	LONG t_State = 0 ;

	if ( ( a_LeftRange->GetType () == TypeId_WmiStringRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiStringRangeNode ) )
	{
		WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) a_LeftRange ;
		WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) a_RightRange ;

		t_State = CompareStringLessOrEqual ( 

			t_LeftString->LowerBound () , 
			t_LeftString->InfiniteLowerBound () ? -1 : 0 ,
			t_RightString->LowerBound () ,
			t_RightString->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) )
	{
		WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) a_LeftRange ;
		WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareSignedIntegerLessOrEqual ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) )
	{
		WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) a_LeftRange ;
		WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareUnsignedIntegerLessOrEqual ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiNullRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiNullRangeNode ) )
	{
		t_State = TRUE ;
	}

	return t_State ;
}

template<typename T>
WmiTriState CheckValid(T *& node)
{
	if ( node && node->IsValid())
	{
		return State_True;
	}
	else
	{
		delete node;
		node = 0;
		return State_Error;
	};
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiUnsignedIntegerRangeNode :: GetIntersectingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{

		_DBG_ASSERT(FALSE);
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// Empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiSignedIntegerRangeNode :: GetIntersectingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > Y_E )
		{
		_DBG_ASSERT(FALSE);
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// Empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiStringRangeNode :: GetIntersectingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL 
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL 
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > Y_E )
		{

		_DBG_ASSERT(FALSE);

		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL 
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiSignedIntegerRangeNode :: GetOverlappingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);

			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);

			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )


				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
                }
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
                }
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
			if ( X_E_CLOSED && Y_S_CLOSED )
			{
				if ( Y_S - X_E == 1 )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_S ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
				}
			}
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{

		_DBG_ASSERT(FALSE);

		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
				}
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping

			if ( Y_E_CLOSED && X_S_CLOSED )
			{
				if ( X_S - Y_E == - 1 )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE,
					    X_E_INFINITE  ,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_S ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiUnsignedIntegerRangeNode :: GetOverlappingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

   				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
                }
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
                }
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
			// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
			_DBG_ASSERT(FALSE);

			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
			if ( X_E_CLOSED && Y_S_CLOSED )
			{
				if ( Y_S - X_E == 1 )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_S ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
				}
			}
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{

		_DBG_ASSERT(FALSE);

		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
				}
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping

			if ( Y_E_CLOSED && X_S_CLOSED )
			{
				if ( X_S - Y_E == -1 )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE,
					    X_E_INFINITE  ,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_S ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiStringRangeNode :: GetOverlappingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
                }
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
                }
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{

// Order ( X_S < Y_E < Y_S == X_E ) Can never happen

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE ,
					    X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					    Y_E_CLOSED ,
					    Y_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
                }
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{

		_DBG_ASSERT(FALSE);

		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
				}
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorEqualNode :: GetRange (WmiRangeNode *& a_Range)
{
	a_Range = NULL ;
	WmiTriState t_Status = :: State_False ; 
	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			a_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				FALSE ,
				TRUE ,
				TRUE ,
				t_Integer->GetValue () ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			a_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				FALSE ,
				TRUE ,
				TRUE ,
				t_Integer->GetValue () ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					FALSE ,
					TRUE ,
					TRUE ,
					t_String->GetValue () ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
				t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
				t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			a_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
			t_Status = CheckValid(a_Range);
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorEqualOrGreaterNode :: GetRange (WmiRangeNode *& a_Range)
{
	WmiTriState t_Status = ::State_False;
	a_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			a_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				TRUE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			a_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				TRUE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					TRUE ,
					TRUE ,
					FALSE ,
					t_String->GetValue () ,
					NULL ,
					NULL , 
					NULL 
				) ;
				t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
				t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			a_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
			t_Status = CheckValid(a_Range);
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorEqualOrLessNode :: GetRange (WmiRangeNode *& a_Range)
{
	a_Range = NULL ;
	WmiTriState t_Status = ::State_False;
	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			a_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				TRUE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			a_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				TRUE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					FALSE ,
					FALSE ,
					TRUE ,
					NULL ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			a_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
			t_Status = CheckValid(a_Range);
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorLessNode :: GetRange (WmiRangeNode *& a_Range)
{
	WmiTriState t_Status = ::State_False;
	a_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			a_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				FALSE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;

			a_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				FALSE ,
				0 ,
				t_Integer->GetValue ()  ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					FALSE ,
					FALSE ,
					FALSE ,
					NULL ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
				t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			a_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
			t_Status = CheckValid(a_Range);
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorGreaterNode :: GetRange (WmiRangeNode *& a_Range)
{
	WmiTriState t_Status = ::State_False;
	a_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			a_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				FALSE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;

			a_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				FALSE ,
				FALSE , 
				t_Integer->GetValue (),
				0 ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					TRUE ,
					FALSE ,
					FALSE ,
					t_String->GetValue () ,
					NULL ,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			a_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
			t_Status = CheckValid(a_Range);
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorLikeNode :: GetRange (WmiRangeNode*& a_Range)
{
	WmiTriState t_Status = ::State_False;
	a_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorNotLikeNode :: GetRange (WmiRangeNode*& a_Range)
{
	WmiTriState t_Status = ::State_False;
	a_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorIsANode :: GetRange (WmiRangeNode*& a_Range)
{
	WmiTriState t_Status = ::State_False;
	a_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorNotIsANode :: GetRange (WmiRangeNode*& a_Range )
{
	WmiTriState t_Status = ::State_False;
	a_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
				t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL QueryPreprocessor :: RecursiveEvaluate ( 

	void *a_Context ,
	SWbemRpnQueryToken **a_Expression , 
	WmiTreeNode *a_Parent , 
	WmiTreeNode **a_Node ,
	int &a_Index 
)
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"RecursiveEvaluate ( int &a_Index )"
	) ;
)

	BOOL t_Status = TRUE ;

	SWbemRpnQueryToken *t_Token = a_Expression [ a_Index ] ;
	a_Index -- ;

	switch ( t_Token->m_uTokenType )
	{
		case WMIQ_RPN_TOKEN_EXPRESSION:
		{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Operation = OP_EXPESSION"
	) ;
)
			WmiTreeNode *t_ParentNode = a_Parent ;
			WmiTreeNode **t_Node = a_Node ;
			WmiTreeNode *t_OperatorNode = NULL ;

			if ( t_Token->m_uSubexpressionShape & WMIQ_RPN_RELOP )
			{
				switch ( t_Token->m_uOperator )
				{
					case WMIQ_RPN_OP_EQ:
					{
						t_OperatorNode = new WmiOperatorEqualNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_NE:
					{
						t_OperatorNode = new WmiOperatorNotEqualNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_GE:
					{
						t_OperatorNode = new WmiOperatorEqualOrGreaterNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_LE: 
					{
						t_OperatorNode = new WmiOperatorEqualOrLessNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_LT:
					{
						t_OperatorNode = new WmiOperatorLessNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_GT:
					{
						t_OperatorNode = new WmiOperatorGreaterNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_LIKE:
					{
						t_OperatorNode = new WmiOperatorLikeNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_ISA:
					{
						t_OperatorNode = new WmiOperatorIsANode ( NULL , t_ParentNode ) ;
					}
					break ;

					default:
					{
						t_Status = FALSE ;
					}
					break ;
				}

				if ( t_OperatorNode == NULL )
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}

			if ( t_Status ) 
			{
				*t_Node = t_OperatorNode ;
				t_ParentNode = t_OperatorNode ;
				(*t_Node)->GetLeft ( t_Node ) ;

				t_Status = TRUE ;

				WmiValueNode :: WmiValueFunction t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_None ;

				if ( t_Token->m_uSubexpressionShape & WMIQ_RPN_LEFT_FUNCTION )
				{
					if ( wbem_wcsicmp ( t_Token->m_pszLeftFunc , L"Upper" ) == 0 )
					{
						t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_Upper ;
					}
					else if ( wbem_wcsicmp ( t_Token->m_pszLeftFunc , L"Lower" ) == 0 )
					{
						t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_Lower ;
					}
					else
					{
						t_Status = FALSE ;
					}
				}

				WmiValueNode :: WmiValueFunction t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_None ;

				if ( t_Token->m_uSubexpressionShape & WMIQ_RPN_RIGHT_FUNCTION )
				{
					if ( wbem_wcsicmp ( t_Token->m_pszRightFunc , L"Upper" ) == 0 )
					{
						t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_Upper ;
					}
					else if ( wbem_wcsicmp ( t_Token->m_pszRightFunc , L"Lower" ) == 0 )
					{
						t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_Lower ;
					}
					else
					{
						t_Status = FALSE ;
					}
				}

				if ( t_Status ) 
				{
					BOOL t_LeftProperty = t_Token->m_uSubexpressionShape & WMIQ_RPN_LEFT_PROPERTY_NAME ;
					BOOL t_RightProperty = t_Token->m_uSubexpressionShape & WMIQ_RPN_RIGHT_PROPERTY_NAME ;
					BOOL t_Const = t_Token->m_uSubexpressionShape & WMIQ_RPN_CONST ;
					BOOL t_Const2 = t_Token->m_uSubexpressionShape & WMIQ_RPN_CONST2 ;

					BOOL t_Validity = ( t_LeftProperty != 0 ) ? TRUE : FALSE ;
					t_Validity = t_Validity && ( ( t_RightProperty != 0 ) ? FALSE : TRUE ) ;
					t_Validity = t_Validity && ( ( t_Const != 0 ) ? TRUE : FALSE ) ;
					t_Validity = t_Validity && ( ( t_Const2 != 0 ) ? FALSE : TRUE ) ;

					if ( t_Validity ) 
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;

						switch ( t_Token->m_uConstApparentType )
						{
							case VT_I8:
							{
								t_Variant.vt = VT_R8 ;
								t_Variant.dblVal = t_Token->m_Const.m_dblVal ;
							}
							break ;

							case VT_I4:
							{
								t_Variant.vt = VT_I4 ;
								t_Variant.lVal = t_Token->m_Const.m_lLongVal ;
							}
							break ;

							case VT_LPWSTR:
							{
								t_Variant.vt = VT_BSTR ;
								t_Variant.bstrVal = SysAllocString ( t_Token->m_Const.m_pszStrVal ) ;
							}
							break ;

							case CIM_EMPTY:
							{
								t_Variant.vt = VT_NULL ;
							}
							break ;
						}

						BSTR t_PropertyName = SysAllocString ( t_Token->m_pLeftIdent->m_ppszNameList [ 0 ] ) ;
						if ( t_PropertyName ) 
						{
							WmiTreeNode *t_ValueNode = AllocTypeNode ( 

								a_Context ,
								t_PropertyName , 
								t_Variant , 
								t_PropertyFunction ,
								t_ConstantFunction ,
								t_ParentNode 
							) ;

							if ( t_ValueNode )
							{
								*t_Node = t_ValueNode ;

								t_Status = TRUE ;
							}
							else
							{				
								t_Status = FALSE ;
							}

							SysFreeString ( t_PropertyName ) ;
						}
						else
						{
							t_Status = FALSE ;
						}

						VariantClear ( & t_Variant ) ;
					}
					else
					{
						t_Status = FALSE ;
					}
				}
			}
		}
		break ;

		case WMIQ_RPN_TOKEN_AND:
		{
			*a_Node = new WmiAndNode ( NULL , NULL , a_Parent ) ;
			if ( *a_Node ) 
			{
				WmiTreeNode **t_Left = NULL ;
				WmiTreeNode **t_Right = NULL ;
				(*a_Node)->GetLeft ( t_Left ) ;
				(*a_Node)->GetRight ( t_Right ) ;

				t_Status =	RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) &&
							RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Right , a_Index ) ;

			}
			else
			{
				t_Status = FALSE ;
			}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Operation = TOKEN_AND"
	) ;
)

		}
		break ;

		case WMIQ_RPN_TOKEN_OR:
		{
			*a_Node = new WmiOrNode ( NULL , NULL , a_Parent ) ;
			if ( *a_Node )
			{
				WmiTreeNode **t_Left = NULL ;
				WmiTreeNode **t_Right = NULL ;
				(*a_Node)->GetLeft ( t_Left ) ;
				(*a_Node)->GetRight ( t_Right ) ;

				t_Status =	RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) &&
							RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Right , a_Index ) ;
			}
			else
			{
				t_Status = FALSE ;
			}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  


		L"Operation = TOKEN_OR"
	) ;
)

		}
		break ;

		case WMIQ_RPN_TOKEN_NOT:
		{
			*a_Node = new WmiNotNode ( NULL , a_Parent ) ;
			if ( *a_Node )
			{
				WmiTreeNode **t_Left = NULL ;
				(*a_Node)->GetLeft ( t_Left ) ;

				t_Status = RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) ;
			}
			else
			{
				t_Status = FALSE ;
			}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Operation = TOKEN_NOT"
	) ;
)

		}
		break ;
	}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"RecursiveEvaluation t_Status = (%lu)" ,
		( ULONG ) t_Status
	) ;
)
	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL QueryPreprocessor :: Evaluate ( 

	void *a_Context ,
	SWbemRpnQueryToken **a_Expression , 
	int a_Count ,
	WmiTreeNode **a_Root 
)
{
	BOOL t_Status = TRUE ;

	if ( a_Count )
	{
		int t_Index = a_Count - 1 ; ;  
		t_Status = RecursiveEvaluate ( a_Context , a_Expression , NULL , a_Root , t_Index ) ;
	}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"PostEvaluation Status = (%lu)\n" ,
		( ULONG ) t_Status
	) ;
)

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: PrintTree ( WmiTreeNode *a_Root )
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Expression = "
	) ;

	if ( a_Root ) 
		a_Root->Print () ;

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"\n"
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformAndOrExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_AndChild , 
	WmiTreeNode *a_OrChild 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_OrLeftChild = a_OrChild->GetLeft () ;
	WmiTreeNode *t_OrRightChild = a_OrChild->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_NewOrNodeLeft = new WmiAndNode ( a_AndChild , t_OrLeftChild , t_NewOrNode ) ;
		if ( t_NewOrNodeLeft )
		{
			t_NewOrNode->SetLeft ( t_NewOrNodeLeft ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}

		WmiTreeNode *t_AndChildCopy = a_AndChild->Copy () ;
		if ( t_AndChildCopy )
		{
			WmiTreeNode *t_NewOrNodeRight = new WmiAndNode ( t_AndChildCopy , t_OrRightChild , t_NewOrNode ) ;
			if ( t_NewOrNodeRight )
			{
				t_NewOrNode->SetRight ( t_NewOrNodeRight ) ;
			}
			else
			{
				t_Status = :: State_Error ;
			}
		}
		else
		{
			t_Status = :: State_Error ;
		}

		if ( t_Parent )
		{
			if ( t_Parent->GetLeft () == a_Node )
			{
				t_Parent->SetLeft ( t_NewOrNode ) ;
			}
			else 
			{
				t_Parent->SetRight ( t_NewOrNode ) ;
			}	
		}

		a_Node->SetLeft ( NULL ) ;
		a_Node->SetRight ( NULL ) ;
		a_Node->SetData ( NULL ) ;

		a_OrChild->SetLeft ( NULL ) ;
		a_OrChild->SetRight ( NULL ) ;
		a_OrChild->SetData ( NULL ) ;

		delete a_Node ; 
		a_Node = NULL ;

		delete a_OrChild ; 
		a_OrChild = NULL ;
	}

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
		a_Node = NULL ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotNotExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	t_Leaf->SetParent ( t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_Leaf ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_Leaf ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	a_Node = t_Leaf ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotAndExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_AndLeftChild = a_Child->GetLeft () ;
	WmiTreeNode *t_AndRightChild = a_Child->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_LeftNot = new WmiNotNode ( t_AndLeftChild , t_NewOrNode ) ;
		if ( t_LeftNot )
		{
			t_NewOrNode->SetLeft ( t_LeftNot ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}

		WmiTreeNode *t_RightNot = new WmiNotNode ( t_AndRightChild , t_NewOrNode ) ;
		if ( t_RightNot )
		{
			t_NewOrNode->SetRight ( t_RightNot ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOrExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_OrLeftChild = a_Child->GetLeft () ;
	WmiTreeNode *t_OrRightChild = a_Child->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewAndNode = new WmiAndNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewAndNode )
	{
		WmiTreeNode *t_LeftNot = new WmiNotNode ( t_OrLeftChild , t_NewAndNode ) ;
		if ( t_LeftNot )
		{
			t_NewAndNode->SetLeft ( t_LeftNot ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}

		WmiTreeNode *t_RightNot = new WmiNotNode ( t_OrRightChild , t_NewAndNode ) ;
		if ( t_RightNot )
		{
			t_NewAndNode->SetRight ( t_RightNot ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewAndNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewAndNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewAndNode ;
	}
	else
	{
		delete t_NewAndNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_LessNode = new WmiOperatorLessNode  ( a_Child , t_NewOrNode ) ;
		if ( t_LessNode )
		{
			t_NewOrNode->SetLeft ( t_LessNode ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}

		WmiTreeNode *t_CopyGreaterChild = a_Child->Copy () ;
		if ( t_CopyGreaterChild )
		{
			WmiTreeNode *t_GreatorNode = new WmiOperatorGreaterNode  ( t_CopyGreaterChild , t_NewOrNode ) ;
			if ( t_GreatorNode )
			{
				t_NewOrNode->SetRight ( t_GreatorNode ) ;
			}
			else
			{
				t_Status = :: State_Error ;
			}
		}
		else
		{
			t_Status = :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotEqualNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualOrGreaterExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrLessNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualOrLessExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrGreaterNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorGreaterExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrLessNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorLessExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrGreaterNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorLikeExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotLikeNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotLikeExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorLikeNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorIsAExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotIsANode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotIsAExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorIsANode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformAndTrueEvaluation ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	if ( a_Node->GetLeft () == a_Child )
	{
		a_Node->SetLeft ( NULL ) ;
	}
	else
	{
		a_Node->SetRight ( NULL ) ;
	}

	WmiTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( a_Child ) ;
		}
		else 
		{
			t_Parent->SetRight ( a_Child ) ;
		}	
	}

	a_Child->SetParent ( t_Parent ) ;

	delete a_Node ;
	a_Node = a_Child ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformOrFalseEvaluation ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	if ( a_Node->GetLeft () == a_Child )
	{
		a_Node->SetLeft ( NULL ) ;
	}
	else
	{
		a_Node->SetRight ( NULL ) ;
	}

	WmiTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( a_Child ) ;
		}
		else 
		{
			t_Parent->SetRight ( a_Child ) ;
		}	

	}

	a_Child->SetParent ( t_Parent ) ;

	delete a_Node ;

	a_Node = a_Child ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformOperatorToRange ( 

	WmiTreeNode *&a_Node 
)
{
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiOperatorNode *t_OperatorNode = ( WmiOperatorNode * ) a_Node ;
	WmiRangeNode *t_Range = 0;
	if (t_OperatorNode->GetRange (t_Range) == State_True && t_Range)
	{
		if ( t_Parent )
		{
			if ( t_Parent->GetLeft () == a_Node )
			{
				t_Parent->SetLeft ( t_Range ) ;
			}
			else 
			{
				t_Parent->SetRight ( t_Range ) ;
			}	
		}

		t_Range->SetParent ( t_Parent ) ;
	}

	delete a_Node ;

	a_Node = t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateNotExpression ( WmiTreeNode *&a_Node )
{
	if ( a_Node->GetLeft () )
	{
		WmiTreeNode *t_Left = a_Node->GetLeft () ;
		if ( t_Left->GetType () == TypeId_WmiAndNode ) 
		{
			TransformNotAndExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOrNode ) 
		{
			TransformNotOrExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiNotNode ) 
		{
			TransformNotNotExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			TransformNotOperatorEqualExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			TransformNotOperatorNotEqualExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			TransformNotOperatorEqualOrGreaterExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			TransformNotOperatorEqualOrLessExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			TransformNotOperatorLessExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			TransformNotOperatorGreaterExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			TransformNotOperatorLikeExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			TransformNotOperatorNotLikeExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			TransformNotOperatorIsAExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			TransformNotOperatorNotIsAExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else
		{
			return :: State_False ; 
		}
	}

	return :: State_Error ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateNotEqualExpression ( WmiTreeNode *&a_Node )
{
	WmiTreeNode *t_Left = a_Node->GetLeft () ;

	TransformNotEqualExpression ( a_Node , t_Left ) ;
	return a_Node ? :: State_True : :: State_Error ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateAndExpression ( WmiTreeNode *&a_Node )
{
	WmiTreeNode *t_Left = a_Node->GetLeft () ;
	WmiTreeNode *t_Right = a_Node->GetRight () ;
	
	if ( t_Left )
	{
		if ( t_Left->GetType () == TypeId_WmiOrNode ) 
		{
			TransformAndOrExpression ( a_Node , t_Right , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
	}

	if ( t_Right )
	{
		if ( t_Right->GetType () == TypeId_WmiOrNode ) 
		{
			TransformAndOrExpression ( a_Node , t_Left , t_Right ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
	}

	return :: State_False ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateOrExpression ( WmiTreeNode *&a_Node )
{
	return :: State_False  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveDisjunctiveNormalForm ( WmiTreeNode *&a_Node )
{
	QueryPreprocessor :: QuadState t_Status = State_True ;
	WmiTriState tStatus = :: State_Error;
	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			if ( (tStatus = EvaluateAndExpression ( a_Node )) == :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else if (tStatus == :: State_Error)
			{
				t_Status = QuadState :: State_Error ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				WmiTreeNode *t_Right = a_Node->GetRight () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}

				if ( t_Right )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Right ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			if ( EvaluateOrExpression ( a_Node ) == :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				WmiTreeNode *t_Right = a_Node->GetRight () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}

				if ( t_Right )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Right ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
			if ( (tStatus = EvaluateNotExpression ( a_Node )) == :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else if (tStatus == ::State_Error)
			{
				t_Status = QuadState :: State_Error;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			if ( (tStatus = EvaluateNotEqualExpression ( a_Node )) == :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else if (tStatus == ::State_Error)
			{
				t_Status = QuadState::State_Error;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: DisjunctiveNormalForm ( WmiTreeNode *&a_Root ) 
{
	QueryPreprocessor :: QuadState t_Status = RecursiveDisjunctiveNormalForm ( a_Root ) ;
	if ( t_Status == QuadState :: State_ReEvaluate )
	{
		t_Status = DisjunctiveNormalForm ( a_Root ) ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveRemoveInvariants ( 

	void *a_Context , 
	WmiTreeNode *&a_Node
)
{
	QueryPreprocessor :: QuadState t_Status = State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Left ) ;

				if ( t_Status == State_False )
				{
					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Right
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context, a_Node ) ;
					return t_Status ;
				}
			}

			if ( t_Right )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Right ) ;

				if ( t_Status == State_False )
				{
					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Left
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Left ) ;
				if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Right
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}

			if ( t_Right )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Right ) ;

				if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Left
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{

// Should never happen, failure in DFN evaluation otherwise

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{

// Should never happen, failure in DFN evaluation otherwise

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{

// Should never happen, failure in DFN evaluation otherwise

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{

// Should never happen, failure in DFN evaluation otherwise

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{

// Should never happen, failure in DFN evaluation otherwise
	
			_DBG_ASSERT(FALSE);

			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{

			// Should never happen, failure in DFN evaluation otherwise
			_DBG_ASSERT(FALSE);

			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{

			// Should never happen, failure in DFN evaluation otherwise
			_DBG_ASSERT(FALSE);

			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
			// Should never happen, failure in DFN evaluation otherwise

			_DBG_ASSERT(FALSE);
			
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
			// Should never happen, failure in DFN evaluation otherwise

			_DBG_ASSERT(FALSE);

			}
		}
		else
		{
		// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RemoveInvariants (

	void *a_Context , 
	WmiTreeNode *&a_Root
)
{
	QuadState t_Status = RecursiveRemoveInvariants ( a_Context , a_Root ) ;
	if ( t_Status == State_ReEvaluate )
	{
		t_Status = RemoveInvariants ( a_Context , a_Root ) ;
		if ( t_Status == State_False || t_Status == State_True )
		{
			delete a_Root ;
			a_Root = NULL ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveInsertNode ( WmiTreeNode *&a_Node , WmiTreeNode *&a_Insertion )
{
	WmiTriState t_Status = :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;

			if ( t_Left )
			{
				t_Status = RecursiveInsertNode ( t_Left , a_Insertion ) ;
				if ( t_Status != :: State_False )
				{
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Right  )
			{
				t_Status = RecursiveInsertNode ( t_Right , a_Insertion ) ;
				if ( t_Status != :: State_False )
				{
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
		// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
		// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
		else
		{
// Operator

			WmiValueNode *t_CompareValue = ( WmiValueNode * ) a_Node->GetLeft () ;
			WmiValueNode *t_InsertionValue = ( WmiValueNode * ) a_Insertion->GetLeft () ;
			LONG t_Compare = t_InsertionValue ->ComparePropertyName ( *t_CompareValue ) ;
			if ( t_Compare < 0 )
			{
// Insert to left

				WmiTreeNode *t_Parent = a_Node->GetParent () ;
				WmiTreeNode *t_NewAndNode = new WmiAndNode ( a_Insertion , a_Node , t_Parent ) ;
				if ( t_NewAndNode )
				{
					a_Node->SetParent ( t_NewAndNode ) ;
					a_Insertion->SetParent ( t_NewAndNode ) ;

					if ( t_Parent )
					{
						if ( t_Parent->GetLeft () == a_Node )
						{
							t_Parent->SetLeft ( t_NewAndNode ) ;
						}
						else
						{
							t_Parent->SetRight ( t_NewAndNode ) ;
						}
					}

					a_Node = t_NewAndNode ;

					t_Status = :: State_True ;
				}
				else
				{
					t_Status = :: State_Error ; 
				}
			}
			else
			{
				t_Status = :: State_False  ;
			}
		}
	}
	else
	{
		a_Node = a_Insertion ;

		t_Status = :: State_True ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState  QueryPreprocessor :: InsertNode ( WmiTreeNode *&a_NewRoot , WmiTreeNode *&a_Insertion )
{
	WmiTriState t_Status = RecursiveInsertNode ( a_NewRoot , a_Insertion ) ;
	if ( t_Status == :: State_False  )
	{
// Insert to right

		WmiTreeNode *t_Parent = a_NewRoot->GetParent () ;
		WmiTreeNode *t_NewAndNode = new WmiAndNode ( a_NewRoot , a_Insertion , t_Parent ) ;
		if ( t_NewAndNode )
		{
			a_NewRoot->SetParent ( t_NewAndNode ) ;
			a_Insertion->SetParent ( t_NewAndNode ) ;

			if ( t_Parent )
			{
				if ( t_Parent->GetLeft () == a_NewRoot )
				{
					t_Parent->SetLeft ( t_NewAndNode ) ;
				}
				else
				{
					t_Parent->SetRight ( t_NewAndNode ) ;
				}
			}

			a_NewRoot = t_NewAndNode ;
		}
		else
		{
			return :: State_Error ;
		}
	}

	return :: State_True ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveSortConditionals ( WmiTreeNode *&a_NewRoot , WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveSortConditionals ( a_NewRoot , t_Left  ) ;
				a_Node->SetLeft ( NULL ) ;
				delete t_Left ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveSortConditionals ( a_NewRoot , t_Right ) ;
				a_Node->SetRight ( NULL ) ;
				delete t_Right ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
		// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
		// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
		else
		{
// Operator

			WmiTreeNode *t_Parent = a_Node->GetParent () ;
			if ( t_Parent ) 
			{
				if ( t_Parent->GetLeft () == a_Node )
				{
					t_Parent->SetLeft ( NULL ) ;
				}
				else
				{
					t_Parent->SetRight ( NULL ) ;
				}
			}

			a_Node->SetParent ( NULL ) ;

			t_Status = InsertNode ( a_NewRoot , a_Node ) ;

			a_Node = NULL ;
		}		
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: SortConditionals ( WmiTreeNode *&a_Root )
{
	WmiTreeNode *t_NewRoot = NULL ;
	WmiTriState t_Status = RecursiveSortConditionals ( t_NewRoot , a_Root ) ;

    if ( a_Root )
    {
	    WmiTreeNode *t_Parent = a_Root->GetParent () ;
	    if ( t_Parent ) 
	    {
		    if ( t_Parent->GetLeft () == a_Root )
		    {
			    t_Parent->SetLeft ( t_NewRoot ) ;
		    }
		    else
		    {
			    t_Parent->SetRight ( t_NewRoot ) ;
		    }
	    }

	    t_NewRoot->SetParent ( t_Parent ) ;

	    delete a_Root ;
    }

	a_Root = t_NewRoot ;

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveSort ( WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveSort ( t_Left ) ;
			}

			if ( t_Status == :: State_True )
			{
				if ( t_Right  )
				{
					t_Status = RecursiveSort ( t_Right ) ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			t_Status = SortConditionals ( a_Node ) ;
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
		// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
		else
		{
// Single operand
			t_Status = :: State_True ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: Sort ( WmiTreeNode *&a_Root )
{
	WmiTriState t_Status = RecursiveSort ( a_Root ) ;
	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveConvertToRanges ( WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = :: State_True ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveConvertToRanges ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveConvertToRanges ( t_Right ) ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveConvertToRanges ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveConvertToRanges ( t_Right ) ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
		// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else
		{
		// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: ConvertToRanges ( WmiTreeNode *&a_Root )
{
	return RecursiveConvertToRanges ( a_Root ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformIntersectingRange (

	WmiTreeNode *&a_Node ,
	WmiTreeNode *a_Compare ,
	WmiTreeNode *a_Intersection
)
{
	WmiTreeNode *t_CompareParent = a_Compare->GetParent () ;
	if ( t_CompareParent )
	{
		if ( t_CompareParent->GetLeft () == a_Compare )
		{
			t_CompareParent->SetLeft ( a_Intersection ) ;
		}
		else
		{
			t_CompareParent->SetRight ( a_Intersection ) ;
		}

		a_Intersection->SetParent ( t_CompareParent ) ;

		delete a_Compare ; 
		a_Compare = NULL ;
	}
	else
	{
	// Should never happen

	_DBG_ASSERT(FALSE);

	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNonIntersectingRange (

	WmiTreeNode *&a_Node ,
	WmiTreeNode *a_Compare
) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveRemoveNonOverlappingRanges ( WmiTreeNode *&a_Node , WmiTreeNode *&a_Compare )
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				a_Compare = NULL ;
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Left , a_Compare ) ;
				if ( t_Status == State_False )
				{
					WmiTreeNode *t_Right = a_Node->GetRight () ;

					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Right
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				a_Compare = NULL ;
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Right , a_Compare ) ;
				if ( t_Status == State_False )
				{
					WmiTreeNode *t_Left = a_Node->GetLeft () ;

					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Left
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Left , a_Compare ) ;
				if ( t_Status == State_True )
				{
					WmiTreeNode *t_Right = a_Node->GetRight () ;

					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Right
					) ;

					a_Compare = NULL ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Right , a_Compare ) ;

				if ( t_Status == State_True )
				{
					WmiTreeNode *t_Left = a_Node->GetLeft () ;

					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Left
					) ;

                    a_Compare = NULL;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNullRangeNode ) 
		{
			WmiRangeNode *t_Node = ( WmiRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiNullRangeNode ) 
					{
						WmiTreeNode *t_Intersection = a_Node->Copy () ;

						TransformIntersectingRange (

							a_Node ,
							a_Compare ,
							t_Intersection
						) ;

						a_Compare = t_Intersection ;

						t_Status = QueryPreprocessor :: QuadState :: State_True ;
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiStringRangeNode ) 
		{
			WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiStringRangeNode ) 
					{
						WmiStringRangeNode *t_StringRange = ( WmiStringRangeNode * ) t_Range ;

						WmiStringRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_StringRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break ;

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) 
		{
			WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) 
					{
						WmiUnsignedIntegerRangeNode *t_IntegerRange = ( WmiUnsignedIntegerRangeNode * ) t_Range ;

						WmiUnsignedIntegerRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_IntegerRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break; 

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiSignedIntegerRangeNode ) 
		{
			WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiSignedIntegerRangeNode ) 
					{
						WmiSignedIntegerRangeNode *t_IntegerRange = ( WmiSignedIntegerRangeNode * ) t_Range ;

						WmiSignedIntegerRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_IntegerRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break ;

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else
		{
		// Should never happen, failure in DNF evaluation otherwise
		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RemoveNonOverlappingRanges  ( WmiTreeNode *&a_Root )
{
	WmiTreeNode *t_Compare = NULL ;

	QueryPreprocessor :: QuadState t_Status = RecursiveRemoveNonOverlappingRanges ( a_Root , t_Compare ) ;
	if ( t_Status == State_ReEvaluate )
	{
		t_Status = RemoveNonOverlappingRanges ( a_Root ) ;
		if ( t_Status == State_False || t_Status == State_True )
		{
			delete a_Root ;
			a_Root = NULL ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: CountDisjunctions ( WmiTreeNode *a_Node , ULONG &a_Count ) 
{
	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			a_Count ++ ;

			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				CountDisjunctions ( t_Left , a_Count ) ;
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				CountDisjunctions ( t_Right , a_Count ) ;
			}
		}
	}
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintInit (

	Disjunctions *a_Disjunctions , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
	ULONG a_KeyIndex 
)
{
   	for ( ULONG t_Index = 0 ; t_Index < a_KeyIndex ; t_Index ++ )
    {
        DebugMacro3( 

            WmiDebugLog :: s_WmiDebugLog->Write (  

	            L"    "
            ) ;
        )
    }

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
    {
        DebugMacro3( 

            WmiDebugLog :: s_WmiDebugLog->Write (  

	            L"%lu", a_DisjunctionSetToTest [ t_Index ] ? 1 : 0
            ) ;
        )
    }

    DebugMacro3( 

        WmiDebugLog :: s_WmiDebugLog->Write (  

	        L"\n"
        ) ;
    )

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
	{
    	for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < a_KeyIndex ; t_InnerIndex ++ )
        {
            DebugMacro3( 

                WmiDebugLog :: s_WmiDebugLog->Write (  

	                L"    "
                ) ;
            )
        }

		Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( t_Index ) ;
		if ( t_Disjunction )
		{
			if (WmiRangeNode * range = t_Disjunction->GetRange ( a_KeyIndex ))
			{
				range->Print () ;

				DebugMacro3( 

					WmiDebugLog :: s_WmiDebugLog->Write (  

						L"\n"
				) ;
			)
			}
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintSortedRange (

	Disjunctions *a_Disjunctions , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
    ULONG *a_OriginToSorted ,
	ULONG a_KeyIndex ,
    WmiRangeNode **a_RangeTable
)
{
	for ( ULONG t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
	{
   		if ( a_RangeTable [ t_Index ] )
        {
    	    for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < a_KeyIndex ; t_InnerIndex ++ )
            {
                DebugMacro3( 

                    WmiDebugLog :: s_WmiDebugLog->Write (  

	                    L"%lu    ", t_Index
                    ) ;
                )
            }

            if ( a_DisjunctionSetToTest [ a_OriginToSorted [ t_Index ] ] )
            {
                DebugMacro3( 

                    WmiDebugLog :: s_WmiDebugLog->Write (  

	                    L"In "
                    ) ;
				)
            }
            else
            {
                DebugMacro3( 

                    WmiDebugLog :: s_WmiDebugLog->Write (  

	                    L"Out "
                    ) ;
				)
            }

		    a_RangeTable [ t_Index ]->Print () ;

            DebugMacro3( 

                WmiDebugLog :: s_WmiDebugLog->Write (  

	                L"\n"
                ) ;
            )
        }
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintOverlap (

	ULONG a_DisjunctionSetToTestCount ,
   	ULONG *a_DisjunctionSetToTest ,
	ULONG *a_SortedDisjunctionSetToTest ,
    ULONG *a_OverlappingIndex ,
  	ULONG a_KeyIndex 
)
{
	for ( ULONG t_Index = 0 ; t_Index < a_KeyIndex ; t_Index ++ )
    {
DebugMacro3( 

    WmiDebugLog :: s_WmiDebugLog->Write (  

	    L"    "
    ) ;
)
    }

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
    {
DebugMacro3( 

    if ( a_DisjunctionSetToTest [ t_Index ] )
    {
        WmiDebugLog :: s_WmiDebugLog->Write (  

	        L"%lu ",  a_OverlappingIndex [ t_Index ]
        ) ;
    }
    else
    {
        WmiDebugLog :: s_WmiDebugLog->Write (  

	        L"X "
        ) ;
    }
)
    }

DebugMacro3( 

    WmiDebugLog :: s_WmiDebugLog->Write (  

	    L"\n"
    ) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: RecursiveQuickSort (

	WmiRangeNode **a_Array , 
    ULONG *a_UnsortedOrder ,
	ULONG a_Lower , 
	ULONG a_Upper
)
{
	if ( a_Lower <= a_Upper )
	{
		ULONG t_LeftIndex = a_Lower ; 
		ULONG t_RightIndex = a_Upper ;

		while ( true )
		{
			while ( ( t_LeftIndex < t_RightIndex ) && CompareLessOrEqualRangeNode ( a_Array [ t_LeftIndex ]  , a_Array [ a_Lower - 1 ] ) )
			{
				t_LeftIndex ++ ;
			}

			while ( ( t_LeftIndex < t_RightIndex ) && CompareLessOrEqualRangeNode ( a_Array [ a_Lower - 1 ]  , a_Array [ t_RightIndex ] ) )
			{
				t_RightIndex -- ;
			}

			if ( t_LeftIndex < t_RightIndex ) 
			{
				WmiRangeNode *t_Temp = a_Array [ t_LeftIndex ] ;
				a_Array [ t_LeftIndex ] = a_Array [ t_RightIndex ] ;
				a_Array [ t_RightIndex ] = t_Temp ;

				ULONG t_Val = a_UnsortedOrder [ t_LeftIndex ] ;
				a_UnsortedOrder [ t_LeftIndex ] = a_UnsortedOrder [ t_RightIndex ];
				a_UnsortedOrder [ t_RightIndex ] = t_Val ;
			}
			else
			{
				break ;
			}
		}

		LONG t_Compare = CompareLessOrEqualRangeNode ( a_Array [ t_LeftIndex ] , a_Array [ a_Lower - 1 ] ) ;
		if ( t_Compare )
		{
			WmiRangeNode *t_Temp = a_Array [ t_LeftIndex ] ;
			a_Array [ t_LeftIndex ] = a_Array [ a_Lower - 1 ] ;
			a_Array [ a_Lower - 1 ] = t_Temp ;

			ULONG t_Val = a_UnsortedOrder [ t_LeftIndex ] ;
			a_UnsortedOrder [ t_LeftIndex ] = a_UnsortedOrder [ a_Lower - 1 ];
			a_UnsortedOrder [ a_Lower - 1 ] = t_Val ;
		}

		RecursiveQuickSort ( 

			a_Array , 
			a_UnsortedOrder ,
			a_Lower , 
			t_LeftIndex - 1 
		) ;

 		RecursiveQuickSort ( 

			a_Array  , 
			a_UnsortedOrder ,
			t_LeftIndex + 1 , 
			a_Upper
		) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: QuickSort (

	WmiRangeNode **a_Array , 
    ULONG *a_UnsortedOrder ,
	ULONG a_Size
)
{
	RecursiveQuickSort ( a_Array , a_UnsortedOrder , 1 , a_Size - 1 ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: SortRanges (

	ULONG t_DisjunctionCount ,
    ULONG *t_OriginToSorted ,
	WmiRangeNode **t_RangeTable 
)
{
	QuickSort (	t_RangeTable , t_OriginToSorted , t_DisjunctionCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RemoveOverlaps (

	ULONG *a_DisjunctionSetToTest ,
	ULONG a_DisjunctionCount ,
	ULONG *a_OverlappingIndex ,
    ULONG *a_OriginToSorted ,
	WmiRangeNode **a_RangeTable 
)
{
	WmiTriState t_Status = :: State_True ;

/*
 *  Remove Overlaps
 */

	ULONG t_InnerIndex = 0 ;
	ULONG t_OuterIndex = 1 ;

	while ( ( t_Status != :: State_Error ) && ( t_OuterIndex < a_DisjunctionCount ) )
	{
		WmiRangeNode *t_LeftRange = a_RangeTable [ t_OuterIndex ] ;
		WmiRangeNode *t_RightRange = a_RangeTable [ t_InnerIndex ] ;

		if ( a_OverlappingIndex [ t_OuterIndex ] != a_OverlappingIndex [ t_InnerIndex ] )
		{
			if ( t_LeftRange && t_RightRange )
			{
				if ( ( t_LeftRange->GetType () == TypeId_WmiStringRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiStringRangeNode ) )
				{
					WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) t_LeftRange ;
					WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) t_RightRange ;
    				WmiStringRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftString->GetOverlappingRange ( *t_RightString , t_OverLap ) ;
					if ( t_Status == :: State_True )
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Overlap\n"
	) ;
)

						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;

						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
					}
					else
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else if ( ( t_LeftRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) )
				{
					WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) t_LeftRange ;
					WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) t_RightRange ;
    				WmiUnsignedIntegerRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftInteger->GetOverlappingRange ( *t_RightInteger , t_OverLap ) ;
					if ( t_Status == :: State_True )
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Overlap\n"
	) ;
)
						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;
						
						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
                    }
					else
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else if ( ( t_LeftRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) )
				{
					WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) t_LeftRange ;
					WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) t_RightRange ;
    				WmiSignedIntegerRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftInteger->GetOverlappingRange ( *t_RightInteger , t_OverLap ) ;
					if ( t_Status == :: State_True )
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Overlap\n"
	) ;
)
						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;
						
						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
                    }
					else
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else
				{
// Failure
					t_Status = :: State_Error ;  
				}
			}
		}

		t_InnerIndex ++ ;
		t_OuterIndex ++ ;
	}

	for ( LONG t_Index = a_DisjunctionCount - 1 ; t_Index >= 0 ; t_Index -- )
	{
		if ( t_Index < a_OverlappingIndex [ t_Index ] )
		{
			a_OverlappingIndex [ t_Index ] = a_OverlappingIndex [ a_OverlappingIndex [ t_Index ] ] ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursivePartitionSet ( 

	Disjunctions *a_Disjunctions , 
	PartitionSet *&a_Partition , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
	ULONG a_KeyIndex 
)
{
	WmiTriState t_Status = :: State_True ;

	if ( a_KeyIndex < a_Disjunctions->GetConjunctionCount () )
	{
		ULONG *t_OverlappingIndex = new ULONG [ a_DisjunctionSetToTestCount ] ;
		wmilib::auto_buffer<ULONG> autoOverlappingIndex(t_OverlappingIndex);

        ULONG *t_OriginToSorted = new ULONG [ a_DisjunctionSetToTestCount ] ;
        wmilib::auto_buffer<ULONG> autoOriginToSorted(t_OriginToSorted);
        
		WmiRangeNode **t_RangeTable = new WmiRangeNode * [ a_DisjunctionSetToTestCount ] ;
		wmilib::auto_buffer<WmiRangeNode *> autoRangeTable(t_RangeTable);
			
		if ( t_OverlappingIndex && t_OriginToSorted && t_RangeTable )
		{
			for ( ULONG t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
			{
				Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionSetToTest [ t_Index ] ) ;
				if (NULL == t_Disjunction) 
				{
					t_Status = ::State_Error;
					break;
				}
				
				t_RangeTable [ t_Index ] = ( WmiRangeNode * ) t_Disjunction->GetRange ( a_KeyIndex )->Copy () ;
				t_OverlappingIndex [ t_Index ] = t_Index ;
				t_OriginToSorted [ t_Index ] = t_Index ;
			}

// Sort Partitions
			if ( t_Status != :: State_Error )
			{
				SortRanges (

					a_DisjunctionSetToTestCount ,
					t_OriginToSorted ,
					t_RangeTable 
				) ;

				t_Status = RemoveOverlaps (

					a_DisjunctionSetToTest ,
					a_DisjunctionSetToTestCount ,
					t_OverlappingIndex ,
					t_OriginToSorted ,
					t_RangeTable 
				) ;
			}

			if ( t_Status != :: State_Error )
			{
				ULONG t_PartitionCount = 0 ;
				for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
				{
					if ( t_RangeTable [ t_Index ] )
					{
						t_PartitionCount ++ ;
					}
				}

				t_Status = a_Partition->Initialize ( t_PartitionCount ) ;
				if ( t_Status == :: State_True )
				{
					ULONG t_PartitionIndex = 0 ;
					for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount; t_Index ++ )
					{
						WmiRangeNode *t_Range = t_RangeTable [ t_Index ] ;
						if ( t_Range )
						{
							PartitionSet *t_Partition = new PartitionSet ;
							if ( t_Partition )
							{
								a_Partition->SetPartition ( t_PartitionIndex , t_Partition ) ;

								WmiRangeNode *t_Copy = ( WmiRangeNode * ) t_Range->Copy () ;
								if ( t_Copy )
								{
									t_Partition->SetRange ( t_Copy ) ;
									t_Partition->SetKeyIndex ( a_KeyIndex ) ;
									t_PartitionIndex ++ ;
								}
								else
								{
									t_Status = :: State_Error ; 
									break ;
								}
							}
							else
							{
								t_Status = :: State_Error ; 
								break ;
							}
						}
					}
				}

				if ( t_Status == :: State_True )
				{
/*
 *  Outer Index is the range order
 */
					ULONG t_PartitionIndex = 0 ;

/*
 *	Array allocation has max defined by function arg.
 */

					ULONG *t_DisjunctionSetToTest = new ULONG [ a_DisjunctionSetToTestCount ] ;
					if ( t_DisjunctionSetToTest )
					{
						ULONG t_OuterIndex = 0 ;
						while ( t_Status && ( t_OuterIndex < a_DisjunctionSetToTestCount ) )
						{
							BOOL t_Found = FALSE ;

							ULONG t_DisjunctionSetToTestCount = 0 ;

							if ( t_RangeTable [ t_OuterIndex ] )
							{
/*
 * Inner index matches the overlaps
 */

								LONG t_InnerIndex = t_OuterIndex ;
								while ( t_InnerIndex >= 0 )
								{
									if ( t_OverlappingIndex [ t_OuterIndex ] == t_OverlappingIndex [ t_InnerIndex ] )
									{
										t_DisjunctionSetToTest [ t_DisjunctionSetToTestCount ] = a_DisjunctionSetToTest [ t_OriginToSorted [ t_InnerIndex ] ] ;
										t_DisjunctionSetToTestCount ++ ;
										t_Found = TRUE ;
									}
									else
									{
										break ;
									}

									t_InnerIndex -- ;
								}
							}

    						if ( t_Found )
							{
								PartitionSet *t_Partition = a_Partition->GetPartition ( t_PartitionIndex ) ;
								if ( t_Partition )
								{
									t_Status = RecursivePartitionSet (

										a_Disjunctions ,
										t_Partition ,
										t_DisjunctionSetToTestCount ,
										t_DisjunctionSetToTest ,
										a_KeyIndex + 1
									) ;

									t_PartitionIndex ++ ;
								}
							}

							t_OuterIndex ++ ;
						}

						delete [] t_DisjunctionSetToTest ;
					}
					else
					{
						t_Status = :: State_Error ; 
					}
				}
			}
			else
			{
				t_Status = :: State_Error ; 
			}

			for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
			{
				if ( t_RangeTable [ t_Index ] )
				{
					delete t_RangeTable [ t_Index ] ;
				}
			}
		}
		else
		{
			t_Status = :: State_Error ; 
		}

	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: CreatePartitionSet ( Disjunctions *a_Disjunctions , PartitionSet *&a_Partition )
{
	WmiTriState t_Status = :: State_False ;

	a_Partition = NULL ;

	ULONG t_DisjunctionCount = a_Disjunctions->GetDisjunctionCount () ;
	ULONG *t_DisjunctionSetToTest = new ULONG [ t_DisjunctionCount ] ;
	if ( t_DisjunctionSetToTest )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
		{
			t_DisjunctionSetToTest [ t_Index ] = t_Index ;
		}

		a_Partition = new PartitionSet ;
		if ( a_Partition )
		{
			t_Status = RecursivePartitionSet (

				a_Disjunctions ,
				a_Partition ,
				t_DisjunctionCount ,
				t_DisjunctionSetToTest ,
				0
			) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}

		delete [] t_DisjunctionSetToTest ;
	}
	else
	{
		t_Status = :: State_Error ;
	}

	return t_Status;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: PreProcess (

	void *a_Context ,																
	IWbemQuery *a_QueryAnalysis ,
	WmiTreeNode *&a_Root 
)
{
	QuadState t_State = State_Error ;

	SWbemRpnEncodedQuery *t_Expression = NULL ;

	HRESULT t_Result = a_QueryAnalysis->GetAnalysis (

		WMIQ_ANALYSIS_RPN_SEQUENCE ,
        0 ,
        ( void ** ) & t_Expression
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		BOOL t_Status = Evaluate ( 
		
			a_Context , 
			( t_Expression->m_ppRpnWhereClause ) , 
			( t_Expression->m_uWhereClauseSize ) , 
			& a_Root
		) ;

		if ( t_Status )
		{
			t_State = State_True ;

			PrintTree ( a_Root ) ;
        
			t_State = DisjunctiveNormalForm ( a_Root ) ;

			PrintTree ( a_Root ) ;
		}

		a_QueryAnalysis->FreeMemory ( t_Expression ) ;
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: Query ( 

	BSTR a_Query ,
	IWbemQuery *a_QueryAnalysis
)
{
	QuadState t_State = State_Error ;

	ULONG t_Array [] = { 

		WMIQ_LF1_BASIC_SELECT ,
		WMIQ_LF2_CLASS_NAME_IN_QUERY ,
		WMIQ_LF3_STRING_CASE_FUNCTIONS ,
		WMIQ_LF4_PROP_TO_PROP_TESTS ,
		WMIQ_LF8_ISA ,
		WMIQ_LF9_THIS ,
		WMIQ_LF26_LIKE
	} ;
 
	ULONG t_ArraySize = sizeof ( t_Array ) / sizeof ( ULONG ) ;

    HRESULT t_Result = a_QueryAnalysis->SetLanguageFeatures (

        0 ,
        t_ArraySize ,
        t_Array
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_QueryAnalysis->Parse ( L"WQL" , a_Query , 0 ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_State = State_True ;
		}
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QueryPreprocessor () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: ~QueryPreprocessor () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define SYSTEM_PROPERTY_DYNASTY				L"__DYNASTY"
#define SYSTEM_PROPERTY_DERIVATION			L"__DERIVATION"
#define SYSTEM_PROPERTY_GENUS				L"__GENUS"
#define SYSTEM_PROPERTY_NAMESPACE			L"__NAMESPACE"
#define SYSTEM_PROPERTY_PROPERTY_COUNT		L"__PROPERTY_COUNT"
#define SYSTEM_PROPERTY_SERVER				L"__SERVER"
#define SYSTEM_PROPERTY_RELPATH				L"__RELPATH"
#define SYSTEM_PROPERTY_PATH				L"__PATH"

#define SYSTEM_PROPERTY_CLASS				L"__CLASS"
#define SYSTEM_PROPERTY_SUPERCLASS			L"__SUPERCLASS"
#define SYSTEM_PROPERTY_THIS				L"__THIS"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *QueryPreprocessor :: AllocTypeNode ( 

	void *a_Context ,
	BSTR a_PropertyName , 
	VARIANT &a_Variant , 
	WmiValueNode :: WmiValueFunction a_PropertyFunction ,
	WmiValueNode :: WmiValueFunction a_ConstantFunction ,
	WmiTreeNode *a_Parent 
)
{
	WmiTreeNode *t_Node = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	if ( *a_PropertyName == L'_' )
	{
// System property

		if ( wbem_wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( wbem_wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_THIS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( wbem_wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
	}

	if ( t_Node && !t_Node->IsValid())
	{
		delete t_Node;
		t_Node = 0;
	}

	return t_Node ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\common\include\cglobals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _CommonGlobals_H
#define _CommonGlobals_H

#include <pssException.h>
#include <HelperFuncs.h>
#include <Allocator.h>
#include <BasicTree.h>
#include <Queue.h>
#include <Cache.h>
#include <locks.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define SYNCPROV_BATCH_TRANSMIT_SIZE 0x40000

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef WmiContainerController <void *>										CWbemGlobal_VoidPointerController ;
typedef CWbemGlobal_VoidPointerController :: Container						CWbemGlobal_VoidPointerController_Container ;
typedef CWbemGlobal_VoidPointerController :: Container_Iterator				CWbemGlobal_VoidPointerController_Container_Iterator ;
typedef CWbemGlobal_VoidPointerController :: WmiContainerElement			VoidPointerContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define CWbemGlobal_IWmiObjectSinkController						CWbemGlobal_VoidPointerController
#define CWbemGlobal_IWmiObjectSinkController_Container				CWbemGlobal_VoidPointerController_Container
#define CWbemGlobal_IWmiObjectSinkController_Container_Iterator		CWbemGlobal_VoidPointerController_Container_Iterator
#define ObjectSinkContainerElement									VoidPointerContainerElement

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define MASK_PROVIDER_BINDING_BIND 1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define HRESULT_ERROR_MASK (0x0000FFFF)
#define HRESULT_ERROR_FUNC(X) (X&HRESULT_ERROR_MASK)
#define HRESULT_FACILITY_MASK (0x0FFF0000)
#define HRESULT_FACILITY_FUNC(X) ((X&HRESULT_FACILITY_MASK)>>16)
#define HRESULT_SEVERITY_MASK (0xC0000000)
#define HRESULT_SEVERITY_FUNC(X) ((X&HRESULT_SEVERITY_MASK)>>30)

#define HRESULT_ERROR_SERVER_UNAVAILABLE	1722L
#define HRESULT_ERROR_CALL_FAILED_DNE		1727L

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define MAX_PROXIES 512

class ProxyContainer
{
private:

	WmiAllocator &m_Allocator ;
#if 1
	WmiStack <IUnknown *,8> **m_ContainerArray ;
#else
	WmiQueue <IUnknown *,8> **m_ContainerArray ;
#endif
	CriticalSection m_CriticalSection ;
	ULONG m_TopSize ;
	ULONG m_CurrentSize ;
	ULONG m_ProxyCount ;
	BOOL m_Initialized ;

public:

	ProxyContainer ( 

		WmiAllocator &a_Allocator ,
		ULONG a_ProxyCount ,
		ULONG a_TopSize 

	) : m_Allocator ( a_Allocator ) ,
		m_ContainerArray ( NULL ) ,
		m_TopSize ( a_TopSize ) ,
		m_CurrentSize ( 0 ) ,
		m_ProxyCount ( a_ProxyCount ) ,
		m_Initialized ( FALSE ) ,
		m_CriticalSection(NOTHROW_LOCK)
	{
	}

	~ProxyContainer ()
	{
		UnInitialize () ;
	}

	WmiStatusCode Initialize () 
	{
		WmiStatusCode t_StatusCode = e_StatusCode_Success ;

#if 1
		m_ContainerArray = new WmiStack <IUnknown *,8> * [ m_ProxyCount ] ;
#else
		m_ContainerArray = new WmiQueue <IUnknown *,8> * [ m_ProxyCount ] ;
#endif
		if ( m_ContainerArray )
		{
			t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				m_Initialized = TRUE ;

 				for ( ULONG t_Index = 0 ; t_Index < m_ProxyCount ; t_Index ++ )
				{
					m_ContainerArray [ t_Index ] = NULL ;
				}

				for ( t_Index = 0 ; t_Index < m_ProxyCount ; t_Index ++ )
				{
#if 1
					WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ t_Index ] = new WmiStack <IUnknown *,8> ( m_Allocator ) ;
#else
					WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ t_Index ] = new WmiQueue <IUnknown *,8> ( m_Allocator ) ;
#endif

					if ( t_Container )
					{
						t_StatusCode = t_Container->Initialize () ;
						if ( t_StatusCode != e_StatusCode_Success )
						{
							break ;
						}
					}
					else
					{
						t_StatusCode = e_StatusCode_OutOfMemory ;

						break ;
					}
				}
			}
		}
		else
		{
			t_StatusCode = e_StatusCode_OutOfMemory ;
		}

		return t_StatusCode ;
	}

	WmiStatusCode UnInitialize ()
	{
		WmiStatusCode t_StatusCode = e_StatusCode_Success ;

		if ( m_ContainerArray )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_ProxyCount ; t_Index ++ )
			{
#if 1
				WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ t_Index ] ;
#else
				WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ t_Index ] ;
#endif
				if ( t_Container )
				{
					IUnknown *t_Top = NULL ;
					WmiStatusCode t_StatusCode ;
					while ( ( t_StatusCode = t_Container->Top ( t_Top ) ) == e_StatusCode_Success )
					{
						t_Top->Release () ;
#if 1
						t_StatusCode = t_Container->Pop () ;
#else
						t_StatusCode = t_Container->DeQueue () ;
#endif
					}

					t_StatusCode = t_Container->UnInitialize () ;

					delete t_Container ;
				}
			}

			delete [] m_ContainerArray ;

			m_ContainerArray = NULL ;
		}

		if ( m_Initialized )
		{
			WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;
			m_Initialized = FALSE ;
		}

		return t_StatusCode ;
	}

	WmiStatusCode Return ( 

		IUnknown *a_Element ,
		ULONG a_Index
	)
	{
#if 1
		WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->Push ( a_Element ) ;
#else
		WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->EnQueue ( a_Element ) ;
#endif
	}

	WmiStatusCode Top ( 

		IUnknown *&a_Element ,
		ULONG a_Index
	)
	{
#if 1
		WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->Top ( a_Element ) ;
#else
		WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->Top ( a_Element ) ;
#endif
	}

	WmiStatusCode Reserve ( ULONG a_Index )
	{
#if 1
		WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->Pop () ;
#else
		WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->DeQueue () ;
#endif
	}
	
	ULONG GetTopSize () { return m_TopSize ; } ;
	ULONG GetCurrentSize () { return m_CurrentSize ; } ;
	BOOL GetInitialized () { return m_Initialized ; }

	void SetCurrentSize ( ULONG a_CurrentSize ) { m_CurrentSize = a_CurrentSize ; }

	CriticalSection &GetCriticalSection () { return m_CriticalSection ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class ProviderSubSystem_Common_Globals
{
public:

	static LPCWSTR s_Wql ;
	static LPCWSTR s_Provider ;

	static WORD s_System_ACESize ;
	static WORD s_LocalService_ACESize ;
	static WORD s_NetworkService_ACESize ;
	static WORD s_LocalAdmins_ACESize ;

	static ACCESS_ALLOWED_ACE *s_Provider_System_ACE ;
	static ACCESS_ALLOWED_ACE *s_Provider_LocalService_ACE ;
	static ACCESS_ALLOWED_ACE *s_Provider_NetworkService_ACE ;
	static ACCESS_ALLOWED_ACE *s_Provider_LocalAdmins_ACE ;

	static ACCESS_ALLOWED_ACE *s_Token_All_Access_System_ACE ;
	static ACCESS_ALLOWED_ACE *s_Token_All_Access_LocalService_ACE ;
	static ACCESS_ALLOWED_ACE *s_Token_All_Access_NetworkService_ACE ;
	static ACCESS_ALLOWED_ACE *s_Token_All_Access_LocalAdmins_ACE ;

	static SECURITY_DESCRIPTOR *s_MethodSecurityDescriptor ;
	static SECURITY_DESCRIPTOR *s_DefaultDecoupledSD;
	static ULONG s_TransmitBufferSize ;
	static ULONG s_DefaultStackSize ;

public:

	static HRESULT CreateInstance ( 

		const CLSID &a_ReferenceClsid ,
		LPUNKNOWN a_OuterUnknown ,
		const DWORD &a_ClassContext ,
		const UUID &a_ReferenceInterfaceId ,
		void **a_ObjectInterface
	) ;

	static HRESULT CreateRemoteInstance ( 

		LPCWSTR a_Server ,
		const CLSID &a_ReferenceClsid ,
		LPUNKNOWN a_OuterUnknown ,
		const DWORD &a_ClassContext ,
		const UUID &a_ReferenceInterfaceId ,
		void **a_ObjectInterface
	) ;

	static HRESULT GetNamespaceServerPath (

		IWbemPath *a_Namespace ,
		wchar_t *&a_ServerNamespacePath
	) ;

	static HRESULT GetNamespacePath (

		IWbemPath *a_Namespace ,
		wchar_t *&a_NamespacePath
	) ;

	static HRESULT GetPathText (

		IWbemPath *a_Path ,
		wchar_t *&a_ObjectPath
	) ;

	static HRESULT Set_Uint32 ( 
		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		const DWORD &a_Uint32
	);

	static HRESULT Set_String ( 
		IWbemClassObject *a_Instance , 
		wchar_t *a_Name ,
		wchar_t *a_String
		);

	static HRESULT BeginCallbackImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	) ;

	static HRESULT BeginImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating ,
		DWORD *a_AuthenticationLevel = NULL
	) ;

	static HRESULT EndImpersonation (

		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_Impersonating 
	) ;

	static HRESULT GetProxy (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy 
	) ;

	static HRESULT GetProxy (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy 
	) ;

	static HRESULT SetCloaking ( 

		IUnknown *a_Unknown
	) ;

	static HRESULT SetCloaking ( 

		IUnknown *a_Unknown ,
		DWORD a_AuthenticationLevel ,
		DWORD a_ImpersonationLevel
	) ;

	static DWORD GetCurrentImpersonationLevel () ;

	static HRESULT EnableAllPrivileges () ;

	static HRESULT EnableAllPrivileges ( HANDLE a_Token ) ;

	static HRESULT SetProxyState_NoImpersonation (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert
	) ;

	static HRESULT SetProxyState (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert
	) ;

	static HRESULT RevertProxyState ( 

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		IUnknown *a_Proxy , 
		BOOL a_Revert
	) ;

	static HRESULT SetProxyState_SvcHost (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize
	) ;

	static HRESULT RevertProxyState_SvcHost ( 

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;

	static HRESULT SetProxyState_PrvHost (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken
	) ;

	static HRESULT RevertProxyState_PrvHost ( 

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;

	static HRESULT SetProxyState_SvcHost (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize
	) ;

	static HRESULT RevertProxyState_SvcHost ( 

		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;

	static HRESULT SetProxyState_PrvHost (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken
	) ;

	static HRESULT RevertProxyState_PrvHost ( 

		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;

	static HRESULT SetProxyState (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert
	) ;

	static HRESULT SetProxyState_NoImpersonation (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert
	) ;

	static HRESULT RevertProxyState ( 

		IUnknown *a_Proxy , 
		BOOL a_Revert
	) ;

	static HRESULT Load_DWORD ( HKEY a_Key , LPCWSTR a_Name , DWORD &a_Value ) ;
	static HRESULT Load_String ( HKEY a_Key , LPCWSTR a_Name , BSTR &a_Value ) ;
	static HRESULT Load_ByteArray ( HKEY a_Key , LPCWSTR a_Name , BYTE *&a_Value , DWORD &a_ValueLength ) ;

	static HRESULT Save_DWORD ( HKEY a_Key , LPCWSTR a_Name , DWORD a_Value ) ;
	static HRESULT Save_String ( HKEY a_Key , LPCWSTR a_Name , BSTR a_Value ) ;
	static HRESULT Save_ByteArray ( HKEY a_Key , LPCWSTR a_Name , BYTE *a_Value , DWORD a_ValueLength ) ;

	static HRESULT UnMarshalRegistration (

		IUnknown **a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) ;

	static HRESULT MarshalRegistration (

		IUnknown *a_Unknown ,
		BYTE *&a_MarshaledProxy ,
		DWORD &a_MarshaledProxyLength
	) ;

	static HRESULT ReleaseRegistration (

		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) ;

	static HRESULT IsDependantCall ( IWbemContext *a_Parent , IWbemContext *a_ChildContext , BOOL &a_DependantCall ) ;


	static HRESULT Check_SecurityDescriptor_CallIdentity ( 

		SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
		DWORD a_Access , 
		GENERIC_MAPPING *a_Mapping,
		SECURITY_DESCRIPTOR *defaultSD = GetMethodSecurityDescriptor()
	) ;

	static HRESULT AdjustSecurityDescriptorWithSid ( 

		SID *a_OwnerSid , 
		SID *a_GroupSid , 
		DWORD a_Access ,
		SECURITY_DESCRIPTOR *&a_SecurityDescriptor , 
		SECURITY_DESCRIPTOR *&a_AlteredSecurityDescriptor
	) ;

	static HRESULT CreateSystemAces () ;

	static HRESULT DeleteSystemAces () ;

	static HRESULT ConstructIdentifyToken_SvcHost (

		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize
	) ;

	static HRESULT ConstructIdentifyToken_PrvHost (

		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize
	) ;

	static HRESULT CheckAccess (
	
		SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
		DWORD a_Access , 
		GENERIC_MAPPING *a_Mapping
	) ;

	static HRESULT GetUserSid (

		HANDLE a_Token ,
		ULONG *a_Size ,
		PSID &a_Sid
	) ;

	static HRESULT GetGroupSid (

		HANDLE a_Token ,
		ULONG *a_Size ,
		PSID &a_Sid
	) ;

	static HRESULT GetAceWithProcessTokenUser ( 
					
		DWORD a_ProcessIdentifier ,
		WORD &a_AceSize ,
		ACCESS_ALLOWED_ACE *&a_Ace 
	) ;

	static HRESULT SinkAccessInitialize (

		SECURITY_DESCRIPTOR *a_RegistrationSecurityDescriptor ,
		SECURITY_DESCRIPTOR *&a_SinkSecurityDescriptor
	) ;

	static HRESULT CreateMethodSecurityDescriptor () ;

	static HRESULT DeleteMethodSecurityDescriptor () ;

	static SECURITY_DESCRIPTOR *GetMethodSecurityDescriptor () 
	{
		return s_MethodSecurityDescriptor ;
	}

	static SECURITY_DESCRIPTOR *GetDefaultDecoupledSD() 
	{
		return s_DefaultDecoupledSD ;
	}

	static DWORD InitializeTransmitSize () ;
	static DWORD GetTransmitSize () { return s_TransmitBufferSize ; }

	static DWORD InitializeDefaultStackSize () ;
	static DWORD GetDefaultStackSize () { return s_DefaultStackSize ; }
} ;
	wchar_t * DupString(const wchar_t * src);

#endif // _CommonGlobals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\common\include\provdnf.h ===
// (C) 1999-2001 Microsoft Corporation 

#ifndef __DNF_TREE_H
#define __DNF_TREE_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#include <stdio.h>
#include <wmiutils.h>
#include <strutils.h>
#include "ProvTree.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum WmiTriState
{
	State_False		= 0 ,
	State_True		= 1 ,
	State_Error		= 0xFFFFFFFF
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define TypeId_WmiOrNode						1
#define TypeId_WmiAndNode						2
#define TypeId_WmiNotNode						3
#define TypeId_WmiOperatorNode					4
#define TypeId_WmiOperatorEqualNode				5
#define TypeId_WmiOperatorNotEqualNode			6
#define TypeId_WmiOperatorEqualOrGreaterNode	7
#define TypeId_WmiOperatorEqualOrLessNode		8
#define TypeId_WmiOperatorGreaterNode			9
#define TypeId_WmiOperatorLessNode				10
#define TypeId_WmiOperatorLikeNode				11
#define TypeId_WmiOperatorNotLikeNode			12
#define TypeId_WmiOperatorIsANode				13
#define TypeId_WmiOperatorNotIsANode			14
#define TypeId_WmiValueNode						15
#define TypeId_WmiSignedIntegerNode				16	
#define TypeId_WmiUnsignedIntegerNode			17
#define TypeId_WmiStringNode					18
#define TypeId_WmiNullNode						19
#define TypeId_WmiRangeNode						20
#define TypeId_WmiUnsignedIntegerRangeNode		21
#define TypeId_WmiSignedIntegerRangeNode		22
#define TypeId_WmiStringRangeNode				23
#define TypeId_WmiNullRangeNode					24

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOrNode : public WmiTreeNode
{
private:
protected:
public:

	WmiOrNode ( 

		WmiTreeNode *a_Left = NULL , 
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiOrNode , NULL , a_Left , a_Right , a_Parent ) {}

	~WmiOrNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiAndNode : public WmiTreeNode
{
private:
protected:
public:

	WmiAndNode ( 

		WmiTreeNode *a_Left = NULL , 
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiAndNode , NULL , a_Left , a_Right , a_Parent ) {}

	~WmiAndNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiNotNode : public WmiTreeNode
{
private:
protected:
public:

	WmiNotNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiNotNode , NULL , a_Node , NULL , a_Parent ) {}

	~WmiNotNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiRangeNode ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorNode : public WmiTreeNode
{
private:
protected:
public:

	WmiOperatorNode ( 

		TypeId_TreeNode a_Type , 
		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( a_Type , NULL , a_Node , NULL , a_Parent ) {}

	~WmiOperatorNode () {} ;

	virtual WmiTriState GetRange (WmiRangeNode *&) = 0 ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorEqualNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualNode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorNotEqualNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotEqualNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotEqualNode , a_Node , a_Parent ) {}

	~WmiOperatorNotEqualNode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *& a_Range ) { a_Range = 0; return ::State_True; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorEqualOrGreaterNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualOrGreaterNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualOrGreaterNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualOrGreaterNode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorEqualOrLessNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualOrLessNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualOrLessNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualOrLessNode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorGreaterNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorGreaterNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorGreaterNode , a_Node , a_Parent ) {}

	~WmiOperatorGreaterNode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorLessNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorLessNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorLessNode , a_Node , a_Parent ) {}

	~WmiOperatorLessNode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorLikeNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorLikeNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorLikeNode , a_Node , a_Parent ) {}

	~WmiOperatorLikeNode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
 
class WmiOperatorNotLikeNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotLikeNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotLikeNode , a_Node , a_Parent ) {}

	~WmiOperatorNotLikeNode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorIsANode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorIsANode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorIsANode , a_Node , a_Parent ) {}

	~WmiOperatorIsANode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorNotIsANode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotIsANode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotIsANode , a_Node , a_Parent ) {}

	~WmiOperatorNotIsANode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiValueNode : public WmiTreeNode
{
public:

	enum WmiValueFunction
	{
		Function_None = 0 ,
		Function_Upper = 1 ,
		Function_Lower = 2
	} ;

private:
protected:

	BSTR m_PropertyName ;
	ULONG m_Index ;
	WmiValueFunction m_PropertyFunction ;
	WmiValueFunction m_ConstantFunction ;

public:

	WmiValueNode ( 

		TypeId_TreeNode a_Type ,
		BSTR a_PropertyName ,
		WmiValueFunction a_PropertyFunction ,
		WmiValueFunction a_ConstantFunction ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( a_Type , NULL , NULL , NULL , a_Parent ) ,
		m_PropertyFunction ( a_PropertyFunction ) ,
		m_ConstantFunction ( a_ConstantFunction ) ,
		m_Index ( a_Index )
	{
		if ( a_PropertyName )
		{
			m_PropertyName = SysAllocString ( a_PropertyName ) ;
			SetValid(m_PropertyName != NULL);
		}
		else
		{
			m_PropertyName = NULL ;
		}
	}

	~WmiValueNode ()
	{
		SysFreeString ( m_PropertyName ) ;
	}

	BSTR GetPropertyName ()
	{
		return m_PropertyName ;
	}

	ULONG GetIndex () { return m_Index ; }

	WmiValueNode :: WmiValueFunction GetPropertyFunction ()
	{
		return m_PropertyFunction ;
	}

	WmiValueNode :: WmiValueFunction GetConstantFunction ()
	{
		return m_ConstantFunction ;
	}

	LONG ComparePropertyName ( WmiValueNode &a_ValueNode ) 
	{
		if ( m_Index < a_ValueNode.m_Index )
		{
			return -1 ;
		}
		else if ( m_Index > a_ValueNode.m_Index )
		{
			return 1 ;
		}
		else
		{
			return _wcsicmp ( m_PropertyName , a_ValueNode.m_PropertyName ) ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiSignedIntegerNode : public WmiValueNode
{
private:
protected:

	LONG m_Integer ;

public:

	WmiSignedIntegerNode ( 

		BSTR a_PropertyName ,
		LONG a_Integer ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiSignedIntegerNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 
		) , m_Integer ( a_Integer ) 
	{
	}

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( LONG &a_Integer )
	{
		if ( m_Integer == 0x80000000 )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer - 1 ;
			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( LONG &a_Integer )
	{
		if ( m_Integer == 0x7FFFFFFF )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer + 1 ;
			return TRUE ;
		}
	}

	LONG GetValue ()
	{
		return m_Integer ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiUnsignedIntegerNode : public WmiValueNode
{
private:
protected:

	ULONG m_Integer ;

public:

	WmiUnsignedIntegerNode ( 

		BSTR a_PropertyName ,
		ULONG a_Integer ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiUnsignedIntegerNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 

		) , m_Integer ( a_Integer ) 
	{
	}

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( ULONG &a_Integer )
	{
		if ( m_Integer == 0 )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer - 1 ;
			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( ULONG &a_Integer )
	{
		if ( m_Integer == 0xFFFFFFFF )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer + 1 ;
			return TRUE ;
		}
	}

	ULONG GetValue ()
	{
		return m_Integer ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiStringNode : public WmiValueNode
{
private:
protected:

	BSTR m_String ;

public:

	WmiStringNode ( 

		BSTR a_PropertyName ,
		BSTR a_String ,
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiStringNode ,
			a_PropertyName , 
			a_PropertyFunction , 
			Function_None ,
			a_Index ,
			a_Parent 
		) 
	{
		if ( a_String ) 
		{
			ULONG t_StringLength = wcslen ( a_String ) ;
			m_String = SysAllocString ( a_String) ;	
			if (!m_String) 
				{
					SetValid(false);
					return;
				}

			if ( a_ConstantFunction == Function_Upper || a_ConstantFunction == Function_Upper)
			{
				for ( ULONG t_Index = 0 ; t_Index < t_StringLength ; t_Index ++ )
				{
					m_String [ t_Index ] = wbem_towlower ( a_String [ t_Index ] ) ;
				}
			}
		}
		else
		{
			m_String = NULL ;
		}
	}

	~WmiStringNode ()
	{
		if ( m_String )
		{
			SysFreeString ( m_String ) ;
		}
	} ;

	WmiTreeNode *Copy () ;


	BSTR GetValue ()
	{
		return m_String ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiNullNode : public WmiValueNode
{
private:
protected:
public:

	WmiNullNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiNullNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 
		) 
	{
	}

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiRangeNode : public WmiTreeNode
{
private:
protected:

	BSTR m_PropertyName ;
	ULONG m_Index ;

	BOOL m_InfiniteLowerBound ;
	BOOL m_InfiniteUpperBound ;

	BOOL m_LowerBoundClosed;
	BOOL m_UpperBoundClosed;

public:

	LONG ComparePropertyName ( WmiRangeNode &a_RangeNode ) 
	{
		if ( m_Index < a_RangeNode.m_Index )
		{
			return -1 ;
		}
		else if ( m_Index > a_RangeNode.m_Index )
		{
			return 1 ;
		}
		else
		{
			return _wcsicmp ( m_PropertyName , a_RangeNode.m_PropertyName ) ;
		}
	}

public:

	WmiRangeNode ( 

		TypeId_TreeNode a_Type ,
		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 
		
	) : WmiTreeNode ( a_Type , NULL , NULL , a_NextNode , a_Parent ),
		m_InfiniteLowerBound ( a_InfiniteLowerBound ) , 
		m_InfiniteUpperBound ( a_InfiniteUpperBound ) ,
		m_LowerBoundClosed ( a_LowerBoundClosed ) ,
		m_UpperBoundClosed ( a_UpperBoundClosed ) ,
		m_Index ( a_Index )
	{
		if ( a_PropertyName )
		{
			m_PropertyName = SysAllocString ( a_PropertyName ) ;
			SetValid(m_PropertyName != NULL);
		}
		else
		{
			m_PropertyName = NULL ;
		}
	} ;

	~WmiRangeNode () 
	{
		if ( m_PropertyName )
		{
			SysFreeString ( m_PropertyName ) ;
		}
	} ;

	BSTR GetPropertyName ()
	{
		return m_PropertyName ;
	}

	ULONG GetIndex () { return m_Index ; }

	BOOL InfiniteLowerBound () { return m_InfiniteLowerBound ; }
	BOOL InfiniteUpperBound () { return m_InfiniteUpperBound ; }

	BOOL ClosedLowerBound () { return m_LowerBoundClosed ; }
	BOOL ClosedUpperBound () { return m_UpperBoundClosed ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiUnsignedIntegerRangeNode : public WmiRangeNode
{
private:
protected:

	ULONG m_LowerBound ;
	ULONG m_UpperBound ;

public:

	WmiTreeNode *Copy () ;
	
	WmiTriState GetIntersectingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Intersection
	) ;

public:

	WmiUnsignedIntegerRangeNode (

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		ULONG a_LowerBound ,
		ULONG a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiUnsignedIntegerRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) , 
		m_LowerBound ( a_LowerBound ) , 
		m_UpperBound ( a_UpperBound ) 
	{
	}

	ULONG LowerBound () { return m_LowerBound ; }
	ULONG UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiSignedIntegerRangeNode : public WmiRangeNode
{
private:
protected:

	LONG m_LowerBound ;
	LONG m_UpperBound ;

public:

	WmiTreeNode *Copy () ;

	WmiTriState GetIntersectingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Intersection
	) ;


public:

	WmiSignedIntegerRangeNode (

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		LONG a_LowerBound ,
		LONG a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiSignedIntegerRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) , 
		m_LowerBound ( a_LowerBound ) , 
		m_UpperBound ( a_UpperBound ) 
	{
	}

	LONG LowerBound () { return m_LowerBound ; }
	LONG UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
 
class WmiStringRangeNode : public WmiRangeNode
{
private:
protected:

	BSTR m_LowerBound ;
	BSTR m_UpperBound ;

public:

	WmiTreeNode *Copy () ;

	WmiTriState GetIntersectingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Intersection
	) ;


public:

	WmiStringRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		BSTR a_LowerBound ,
		BSTR a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiStringRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) 
	{
		if ( a_LowerBound )
		{
			m_LowerBound = SysAllocString ( a_LowerBound ) ;
			SetValid(m_LowerBound != NULL);
		}
		else
		{
			m_LowerBound = NULL ;
		}

		if ( a_UpperBound )
		{
			m_UpperBound = SysAllocString ( a_UpperBound ) ;
			SetValid(m_UpperBound != NULL);			
		}
		else
		{
			m_UpperBound = NULL ;
		}
	}

	~WmiStringRangeNode ()
	{
		if ( m_LowerBound )
		{
			SysFreeString ( m_LowerBound ) ;
		}

		if ( m_UpperBound )
		{
			SysFreeString ( m_UpperBound ) ;
		}
	} ;

	BSTR LowerBound () { return m_LowerBound ; }
	BSTR UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiNullRangeNode : public WmiRangeNode
{
private:
protected:
public:

	WmiNullRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiNullRangeNode ,
			a_PropertyName , 
			a_Index , 
			TRUE ,
			TRUE ,
			FALSE ,
			FALSE ,
			a_NextNode ,
			a_Parent 
		) 
	{
	}

	~WmiNullRangeNode ()
	{
	} ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Conjunctions
{
private:
protected:

/* 
 *	Range values for the set of properties in a disjunction.
 *	Array index is ordered in property order.
 */

	ULONG m_RangeContainerCount ;
	WmiRangeNode **m_RangeContainer ;
	
public:

	Conjunctions (

		ULONG a_RangeContainerCount 

	) :	m_RangeContainerCount ( a_RangeContainerCount ) ,
		m_RangeContainer ( NULL )
	{
	}

	~Conjunctions () 
	{
		if ( m_RangeContainer )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_RangeContainerCount ; t_Index ++ )
			{
				delete m_RangeContainer [ t_Index ] ;
			}

			delete [] m_RangeContainer ;
		}
	} ;	

	WmiTriState Initialize ()
	{
		WmiTriState t_Status = State_True ;

		m_RangeContainer = new WmiRangeNode * [ m_RangeContainerCount ] ;
		if ( m_RangeContainer )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_RangeContainerCount ; t_Index ++ )
			{
				m_RangeContainer [ t_Index ] = NULL ;
			}
		}
		else
		{
			t_Status = State_Error ; 
		}

		return t_Status ;
	}

	ULONG GetRangeCount () 
	{
		return m_RangeContainerCount ;
	}

	WmiRangeNode *GetRange ( ULONG a_Index ) 
	{
		if ( m_RangeContainerCount > a_Index ) 
		{
			return m_RangeContainer [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}

	void SetRange ( ULONG a_Index , WmiRangeNode *a_Range ) 
	{
		if ( m_RangeContainerCount > a_Index ) 
		{
			if ( m_RangeContainer [ a_Index ] )
			{
				delete m_RangeContainer [ a_Index ] ;
			}

			m_RangeContainer [ a_Index ] = a_Range ;
		}		
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Disjunctions 
{
private:
protected:

/* 
 *	Range values for the set of properties in a disjunction.
 *	Array index is ordered in property order.
 */

	ULONG m_ConjunctionCount ;
	ULONG m_DisjunctionCount ;
	Conjunctions **m_Disjunction ;
	
public:

	Disjunctions (

		ULONG a_DisjunctionCount ,
		ULONG a_ConjunctionCount 

	) :	m_DisjunctionCount ( a_DisjunctionCount ) ,
		m_ConjunctionCount ( a_ConjunctionCount ) ,
		m_Disjunction ( NULL )
	{
	}

	WmiTriState Initialize ()
	{
		WmiTriState t_Status = State_True ;

		m_Disjunction = new Conjunctions * [ m_DisjunctionCount ] ;
		if ( m_Disjunction )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				m_Disjunction [ t_Index ] = NULL ;
			}

			for ( t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				Conjunctions *t_Disjunction = new Conjunctions ( m_ConjunctionCount ) ;
				if ( t_Disjunction )
				{
					t_Status = t_Disjunction->Initialize () ;
					if ( t_Status != State_True )
					{
						break ;
					}
				}
				else
				{
					t_Status = State_Error ;
					break ;
				}

				m_Disjunction [ t_Index ] = t_Disjunction ;
			}
		}
		else
		{
			t_Status = State_Error ;
		}

		return t_Status ;
	}

	~Disjunctions () 
	{
		if ( m_Disjunction )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				Conjunctions *t_Disjunction = m_Disjunction [ t_Index ] ;
				delete t_Disjunction ;
			}
			
			delete [] m_Disjunction ;
		}
	} ;	

	ULONG GetDisjunctionCount () 
	{
		return m_DisjunctionCount ;
	}

	ULONG GetConjunctionCount () 
	{
		return m_ConjunctionCount ;
	}

	Conjunctions *GetDisjunction ( ULONG a_Index ) 
	{
		if ( m_DisjunctionCount > a_Index ) 
		{
			return m_Disjunction [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class PartitionSet
{
private:
protected:

/*
 *	Null for top level
 */
	ULONG m_KeyIndex ;
	WmiRangeNode *m_Range ;

/*
 *	Number of non overlapping partitions, zero when all keys have been partitioned
 */

	ULONG m_NumberOfNonOverlappingPartitions ;
	PartitionSet **m_NonOverlappingPartitions ;

public:

	PartitionSet ()	:	m_Range ( NULL ) ,
						m_KeyIndex ( 0 ) ,
						m_NumberOfNonOverlappingPartitions ( 0 ) ,
						m_NonOverlappingPartitions ( NULL )
	{
	}

	virtual ~PartitionSet () 
	{
		delete m_Range ;

		if ( m_NonOverlappingPartitions )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_NumberOfNonOverlappingPartitions ; t_Index ++ )
			{
				delete m_NonOverlappingPartitions [ t_Index ] ;
			}

			delete [] m_NonOverlappingPartitions ;
		}
	}

public:

	WmiTriState Initialize ( ULONG a_Count ) 
	{
		WmiTriState t_Status = State_True ;

		m_NumberOfNonOverlappingPartitions = a_Count ;
		m_NonOverlappingPartitions = new PartitionSet * [ a_Count ] ;
		if ( m_NonOverlappingPartitions )
		{
			for ( ULONG t_Index = 0 ; t_Index < a_Count ; t_Index ++ )
			{
				m_NonOverlappingPartitions [ t_Index ] = NULL ;
			}
		}
		else
		{
			t_Status = State_Error ;
		}

		return t_Status ;
	}
	
	void SetPartition ( ULONG a_Index , PartitionSet *a_Partition )
	{
		if ( a_Index < m_NumberOfNonOverlappingPartitions ) 
		{
			m_NonOverlappingPartitions [ a_Index ] = a_Partition ;
		}
	}

public:

	ULONG GetKeyIndex () { return m_KeyIndex ; }
	void SetKeyIndex ( ULONG a_KeyIndex ) { m_KeyIndex = a_KeyIndex ; }

	BOOL Root () { return m_Range == NULL ; }
	BOOL Leaf () { return m_NonOverlappingPartitions == NULL ; }

	void SetRange ( WmiRangeNode *a_Range ) { m_Range = a_Range ; }
	WmiRangeNode *GetRange () { return m_Range ; }

	ULONG GetPartitionCount () { return m_NumberOfNonOverlappingPartitions ; }

	PartitionSet *GetPartition ( ULONG a_Index )
	{
		if ( a_Index < m_NumberOfNonOverlappingPartitions ) 
		{
			return m_NonOverlappingPartitions [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class QueryPreprocessor 
{
public:

	enum QuadState {

		State_True ,
		State_False ,
		State_ReEvaluate ,
		State_Undefined ,
		State_Error 
	} ;

private:
protected:

	BOOL RecursiveEvaluate ( 

		void *a_Context ,
		SWbemRpnQueryToken ** a_Expression , 
		WmiTreeNode *a_Parent , 
		WmiTreeNode **a_Node ,
		int &a_Index 
	) ;

	void TransformAndOrExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_AndChild , 
		WmiTreeNode *a_OrChild 
	) ;

	void TransformNotNotExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotAndExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualOrGreaterExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualOrLessExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorGreaterExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorLessExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorLikeExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotLikeExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorIsAExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotIsAExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOrExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformAndTrueEvaluation ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformOrFalseEvaluation ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformOperatorToRange ( 

		WmiTreeNode *&a_Node
	) ;

	void TransformIntersectingRange (

		WmiTreeNode *&a_Node ,
		WmiTreeNode *a_Compare ,
		WmiTreeNode *a_Intersection
	) ;

	void TransformNonIntersectingRange (

		WmiTreeNode *&a_Node ,
		WmiTreeNode *a_Compare
	) ;

	WmiTriState EvaluateNotEqualExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateNotExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateAndExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateOrExpression ( WmiTreeNode *&a_Node ) ;

	QuadState RecursiveDisjunctiveNormalForm ( WmiTreeNode *&a_Node ) ;

	QuadState RecursiveRemoveInvariants ( void *a_Context , WmiTreeNode *&a_Root ) ;

	WmiTriState RecursiveInsertNode ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Node ) ;
	WmiTriState InsertNode ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Node ) ;

	WmiTriState RecursiveSortConditionals ( WmiTreeNode *&a_Root , WmiTreeNode *&a_NewRoot ) ;
	WmiTriState SortConditionals ( WmiTreeNode *&a_Root ) ;
	WmiTriState RecursiveSort ( WmiTreeNode *&a_Root ) ;

	WmiTriState RecursiveConvertToRanges ( WmiTreeNode *&a_Root ) ;
	
	QuadState RecursiveRemoveNonOverlappingRanges ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Compare ) ;

	void CountDisjunctions ( WmiTreeNode *a_Root , ULONG &a_Count ) ;


	WmiTriState RecursivePartitionSet ( 

		Disjunctions *a_Disjunctions , 
		PartitionSet *&a_Partition , 
		ULONG a_DisjunctionSetToTestCount ,
		ULONG *a_DisjunctionSetToTest ,
		ULONG a_KeyIndex 
	) ;

protected:

/*
 *	Given a property name and it's value convert to it's correct type.
 *	e.g. if the CIMType of a_PropertyName is uint32 then create an WmiUnsignedIntegerNode
 *	return NULL if error.
 */

	virtual WmiTreeNode *AllocTypeNode ( 

		void *a_Context ,
		BSTR a_PropertyName , 
		VARIANT &a_Variant , 
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		WmiTreeNode *a_Parent 

	) ;

	virtual QuadState InvariantEvaluate ( 

		void *a_Context ,
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 

	) { return State_Undefined ; }

	virtual WmiRangeNode *AllocInfiniteRangeNode (

		void *a_Context ,
		BSTR a_PropertyName 

	) { return NULL ; }

protected:

	BOOL Evaluate (

		void *a_Context ,
		SWbemRpnQueryToken **a_Expression , 
		int a_Count ,
		WmiTreeNode **a_Root
	) ;

	QuadState DisjunctiveNormalForm ( WmiTreeNode *&a_Root ) ;

	void RecursiveQuickSort (

		WmiRangeNode **a_Array , 
		ULONG *a_UnsortedOrder ,
		ULONG a_Lower , 
		ULONG a_Upper
	) ;

	void QuickSort (

		WmiRangeNode **a_Array , 
		ULONG *a_UnsortedOrder ,
		ULONG a_Size
	) ;

	void SortRanges (

		ULONG a_DisjunctionCount ,
		ULONG *a_OriginToSorted ,
		WmiRangeNode **a_RangeTable 
	) ;

	WmiTriState RemoveOverlaps (

		ULONG *a_DisjunctionSetToTest ,
		ULONG a_DisjunctionCount ,
		ULONG *a_OverlappingIndex ,
		ULONG *a_OriginToSorted ,
		WmiRangeNode **a_RangeTable 
	) ;

	QuadState RemoveInvariants ( void *a_Context , WmiTreeNode *&a_Root ) ;

	WmiTriState Sort ( WmiTreeNode *&a_Root ) ;

	WmiTriState ConvertToRanges ( WmiTreeNode *&a_Root ) ;

	QuadState RemoveNonOverlappingRanges ( WmiTreeNode *&a_Root ) ;


	WmiTriState CreatePartitionSet ( 

		Disjunctions *a_Disjunctions , 
		PartitionSet *&a_Partition
	) ;

	void PrintTree ( WmiTreeNode *a_Root ) ;

public:

	QueryPreprocessor () ;
	virtual ~QueryPreprocessor () ;

	QuadState PreProcess (

		void *a_Context , 
		IWbemQuery *a_QueryAnalysis , 
		WmiTreeNode *&a_Root
	) ;


	QuadState Query ( 

		BSTR a_Query ,
		IWbemQuery *a_QueryAnalysis
	) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\common\include\datetime.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  datetime.h
//
//  alanbos  20-Jan-00   Created.
//
//  Datetime helper implementation.
//
//***************************************************************************

#ifndef _DATETIME_H_
#define _DATETIME_H_

#define WBEMDT_DMTF_LEN		25
#define WBEMDT_DMTF_SPOS	14
#define WBEMDT_DMTF_UPOS	21

#define	WBEMDT_MIN_YEAR		0
#define	WBEMDT_MAX_YEAR		9999
#define WBEMDT_MIN_MONTH	1
#define WBEMDT_MAX_MONTH	12
#define WBEMDT_MIN_DAY		1
#define WBEMDT_MAX_DAY		31
#define WBEMDT_MIN_DAYINT	0
#define WBEMDT_MAX_DAYINT	999999
#define	WBEMDT_MIN_HOURS	0
#define	WBEMDT_MAX_HOURS	23
#define	WBEMDT_MIN_MINUTES	0
#define	WBEMDT_MAX_MINUTES	59
#define	WBEMDT_MIN_SECONDS	0
#define	WBEMDT_MAX_SECONDS	59
#define	WBEMDT_MIN_MICROSEC	0
#define	WBEMDT_MAX_MICROSEC	999999
#define	WBEMDT_MIN_UTC		-720
#define	WBEMDT_MAX_UTC		720

#define INVALID_TIME 0xffffffffffffffff

//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemDateTime
//
//  DESCRIPTION:
//
//  Implements the ISWbemDateTime interface.  
//
//***************************************************************************

class CWbemDateTime 
{
private:

	// Private helper class for all the messy business
	class WBEMTime 
	{
		private:

			class WBEMTimeSpan 
			{
				private:

					ULONGLONG m_Time;
					friend class WBEMTime;

				public:

					WBEMTimeSpan ( 
						int iMinutes 
					) 
					{
						m_Time = iMinutes * 60;
						m_Time *= 10000000;
				}
			};

		public:

			WBEMTime () { m_uTime = INVALID_TIME ; }
			WBEMTime ( const FILETIME &ft )	;

			WBEMTime    operator+ ( const WBEMTimeSpan &ts ) const;
			WBEMTime    operator- ( const WBEMTimeSpan &sub ) const;

			BOOL GetSYSTEMTIME ( SYSTEMTIME *pst ) const;
			BOOL GetDMTF ( SYSTEMTIME &st, long &offset ) const;
			BOOL GetFILETIME ( FILETIME *pst ) const;

			bool IsOk () const { return m_uTime != INVALID_TIME ? true : false; }

			static LONG WINAPI GetLocalOffsetForDate(const SYSTEMTIME *pst);

		private:

			ULONGLONG m_uTime;
	};

private:

	VARIANT_BOOL		m_bYearSpecified;
	VARIANT_BOOL		m_bMonthSpecified;
	VARIANT_BOOL		m_bDaySpecified;
	VARIANT_BOOL		m_bHoursSpecified;
	VARIANT_BOOL		m_bMinutesSpecified;
	VARIANT_BOOL		m_bSecondsSpecified;
	VARIANT_BOOL		m_bMicrosecondsSpecified;
	VARIANT_BOOL		m_bUTCSpecified;
	VARIANT_BOOL		m_bIsInterval;
	
	long				m_iYear;
	long				m_iMonth;
	long				m_iDay;
	long				m_iHours;
	long				m_iMinutes;
	long				m_iSeconds;
	long				m_iMicroseconds;
	long				m_iUTC;

	bool				CheckField (
								LPWSTR			pValue,
								ULONG			len,
								VARIANT_BOOL	&bIsSpecified,
								long			&iValue,
								long			maxValue,
								long			minValue
						);

	bool				CheckUTC (
								LPWSTR			pValue,
								VARIANT_BOOL	&bIsSpecified,
								long			&iValue,
								bool			bParseSign = true
						);

protected:
public:
    
    CWbemDateTime(void);
    virtual ~CWbemDateTime(void);

	// ISWbemDateTime methods

    HRESULT GetValue ( BSTR *value ) ;
    
    HRESULT PutValue ( BSTR value ) ;

	HRESULT GetDay ( long *value ) 
	{
		*value = m_iDay;

		return S_OK;
	}

	HRESULT GetHours ( long *value ) 
	{
		*value = m_iHours;

		return S_OK;
	}
    
	HRESULT GetMinutes ( long *value ) 
	{
		*value = m_iMinutes;

		return S_OK;
	}
    
	HRESULT GetSeconds ( long *value ) 
	{
		*value = m_iSeconds;

		return S_OK;
	}
        
	HRESULT GetMicroseconds ( long *value ) 
	{
		*value = m_iMicroseconds;

		return S_OK;
	}
    
	HRESULT GetIsInterval ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bIsInterval; 

		return S_OK;
	}
    
	HRESULT GetFileTimeDate (

		FILETIME &fFileTime
	) ;

	HRESULT GetSystemTimeDate (

		SYSTEMTIME &fSystemTime
	) ;

	HRESULT SetFileTimeDate ( 

		FILETIME fFileTime,
		VARIANT_BOOL bIsLocal
	) ;

	BOOL Preceeds ( CWbemDateTime &a_Time ) ;
};

#endif // _DATETIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\common\include\provobjectsink.h ===
#ifndef _Common_IWbemObjectSink_H
#define _Common_IWbemObjectSink_H

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvObSk.H

Abstract:


History:

--*/

#include "Queue.h"
#include "CGlobals.h"

typedef bool (__stdcall * fn__uncaught_exception)();

class InterlockedGuard
{
private:
	LPLONG volatile lValue_;
#ifdef DBG	
    bool bIsUnwind_;
	static fn__uncaught_exception __uncaught_exception;
	class FunctLoader
	{
	private:
		HMODULE hCRT_;		
	public:
		FunctLoader()
		{ 
		    hCRT_ = LoadLibraryExW(L"msvcrt.dll",0,0); 
		    if (hCRT_) __uncaught_exception = (fn__uncaught_exception)GetProcAddress(hCRT_,"__uncaught_exception");
		};
		~FunctLoader(){ if (hCRT_) FreeLibrary(hCRT_); };
	};
    static FunctLoader FunctLoader_;
#endif    
public:	
    InterlockedGuard(LPLONG volatile lValue):lValue_(lValue)
    {
        InterlockedIncrement(lValue_);
#ifdef DBG        
        if (__uncaught_exception)
        {
            bIsUnwind_ = __uncaught_exception();
        }
#endif        
    }
    ~InterlockedGuard()
    {
        InterlockedDecrement(lValue_);
#ifdef DBG        
        if (__uncaught_exception)
        {
            bool bIsUnwind = __uncaught_exception();
            if (bIsUnwind_ != bIsUnwind)
                DebugBreak();
        }
#endif        
    }
};

#define SYNCPROV_USEBATCH

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex_IWbemObjectSink					0
#define ProxyIndex_Internal_IWbemObjectSink			1
#define ProxyIndex_ObjectSink_Size					2

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CCommon_IWbemSyncObjectSink :			public IWbemObjectSink , 
											public IWbemShutdown ,
											public ObjectSinkContainerElement
{
private:

	LONG m_InProgress ;
	LONG m_StatusCalled ;

	ULONG m_Dependant ;
	IWbemObjectSink *m_InterceptedSink ;

	IUnknown *m_Unknown ;

protected:

	LONG m_GateClosed ;

protected:

    HRESULT STDMETHODCALLTYPE Helper_Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE Helper_SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

public:

	CCommon_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CCommon_IWbemSyncObjectSink() ;

	void CallBackInternalRelease () ;

	virtual HRESULT SinkInitialize () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CCommon_Batching_IWbemSyncObjectSink :	public CCommon_IWbemSyncObjectSink
{
private:

	DWORD m_Size ;
	WmiQueue <IWbemClassObject *,8> m_Queue ;
	CriticalSection m_CriticalSection ;

protected:
public:

	CCommon_Batching_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CCommon_Batching_IWbemSyncObjectSink () ;

	HRESULT SinkInitialize () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

#endif _Common_IWbemObjectSink_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\common\include\provtree.h ===
// (C) 1999-2001 Microsoft Corporation 
#ifndef WMI_TREE
#define WMI_TREE

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef DWORD TypeId_TreeNode ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiTreeNode 
{
	bool m_valid;

protected:

	TypeId_TreeNode m_Type ;

	void *m_Data ;
	WmiTreeNode *m_Left ;
	WmiTreeNode *m_Right ;
	WmiTreeNode *m_Parent ;
	
public:

	WmiTreeNode ( 

		WmiTreeNode *a_Node 
	) 
	{
		m_Type = a_Node->m_Type ;
		m_Data = a_Node->m_Data ;
		m_Left = a_Node->m_Left ;
		m_Right = a_Node->m_Right ;
		m_Parent = a_Node->m_Parent ;
		m_valid = a_Node->m_valid;
	}

	WmiTreeNode ( 

		TypeId_TreeNode a_Type = 0 ,
		void *a_Data = NULL ,
		WmiTreeNode *a_Left = NULL ,
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 
	) : m_valid(true)
	{
		m_Type = a_Type ;
		m_Parent = a_Parent ;
		m_Data = a_Data ;
		m_Left = a_Left ;
		m_Right = a_Right ;

		if ( m_Left )
			m_Left->SetParent ( this ) ;

		if ( m_Right )
			m_Right->SetParent ( this ) ;

	}

	virtual ~WmiTreeNode () {}

	bool IsValid() { return m_valid;}
	
	void SetValid(bool valid) { m_valid = valid;}
		
	TypeId_TreeNode GetType ()
	{
		return m_Type ;
	}

	void *GetData () 
	{
		return m_Data ; 
	}

	WmiTreeNode *GetLeft () 
	{ 
		return m_Left ; 
	}

	WmiTreeNode *GetRight () 
	{
		return m_Right ; 
	}

	WmiTreeNode *GetParent () 
	{
		return m_Parent ; 
	}

	void GetData ( void **a_Data ) 
	{
		*a_Data = & m_Data ; 
	}

	void GetLeft ( WmiTreeNode **&a_Left ) 
	{ 
		a_Left = &m_Left ; 
	}

	void GetRight ( WmiTreeNode **&a_Right ) 
	{
		a_Right = &m_Right ; 
	}

	void GetParent ( WmiTreeNode **&a_Parent ) 
	{
		a_Parent = &m_Parent ; 
	}

	void SetType ( TypeId_TreeNode a_Type )
	{
		m_Type = a_Type ;
	}

	void *SetData ( void *a_Data )
	{
		void *t_Data = m_Data ;
		m_Data = a_Data ;
		return t_Data ;
	}

	WmiTreeNode *SetLeft ( WmiTreeNode *a_Left )
	{
		WmiTreeNode *t_Left = m_Left ;
		m_Left = a_Left ;
		return t_Left ;
	}

	WmiTreeNode *SetRight ( WmiTreeNode *a_Right ) 
	{
		WmiTreeNode *t_Right = m_Right ;
		m_Right = a_Right ;
		return t_Right ;
	}

	WmiTreeNode *SetParent ( WmiTreeNode *a_Parent ) 
	{
		WmiTreeNode *t_Parent = m_Parent ;
		m_Parent = a_Parent ;
		return t_Parent ;
	}

	virtual WmiTreeNode *Copy () ;	// Copy node, not allocating copies of data and allocating copies of sub tree

	virtual WmiTreeNode *CopyNode () ; // Copy node, not allocating copies of data and subtree

	virtual void Print () {} ;
} ;

class WmiTreeNodeIterator 
{
protected:

	WmiTreeNode *m_Iterator ;

public:

	WmiTreeNodeIterator ( WmiTreeNodeIterator *a_WmiTreeNodeIterator )
	{
		m_Iterator = a_WmiTreeNodeIterator->m_Iterator ; 
	}

	WmiTreeNodeIterator ( WmiTreeNode *a_Root ) 
	{
		m_Iterator = a_Root ; 
	}

	virtual ~WmiTreeNodeIterator () {}

	WmiTreeNode *GetIterator () 
	{
		return m_Iterator ; 
	}

	WmiTreeNode *SetIterator ( WmiTreeNode *a_Iterator ) 
	{ 
		WmiTreeNode *t_Iterator = m_Iterator ;
		m_Iterator = a_Iterator ;
		return t_Iterator ;
	}

	virtual WmiTreeNodeIterator *Copy ()	
	{
		WmiTreeNodeIterator *t_Iterator = new WmiTreeNodeIterator ( m_Iterator ) ;
		return t_Iterator ;
	}

	void InOrder () ;
	void PreOrder () ;
	void PostOrder () ;
} ;

#endif // WMI_TREE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\common\include\provregdecoupled.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvRegInfo.h

Abstract:


History:

--*/

#ifndef _Server_ProviderRegistrationDecoupled_H
#define _Server_ProviderRegistrationDecoupled_H

#include "Queue.h"
#include "DateTime.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DecoupledClientRegistration_Element
{
private:

	LONG m_ReferenceCount ;

private:

protected:

	HRESULT m_Result ;

	DWORD m_ProcessIdentifier ;
	BSTR m_Provider ;
	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Scope ;
	BSTR m_CreationTime ;
	BSTR m_Clsid ;
	BYTE *m_MarshaledProxy ;
	DWORD m_MarshaledProxyLength ;

protected:

	static LPCWSTR s_Strings_Reg_Null ;
	static LPCWSTR s_Strings_Reg_Home ;
	static LPCWSTR s_Strings_Reg_HomeClient ;

	static LPCWSTR s_Strings_Reg_CreationTime ;
	static LPCWSTR s_Strings_Reg_User ;
	static LPCWSTR s_Strings_Reg_Locale ;
	static LPCWSTR s_Strings_Reg_Scope ;
	static LPCWSTR s_Strings_Reg_Provider;
	static LPCWSTR s_Strings_Reg_MarshaledProxy ;
	static LPCWSTR s_Strings_Reg_ProcessIdentifier ;

	void Clear () ;

	HRESULT Validate () ;

public:	/* Internal */

    CServerObject_DecoupledClientRegistration_Element () ;
    ~CServerObject_DecoupledClientRegistration_Element () ;

	CServerObject_DecoupledClientRegistration_Element &operator= ( const CServerObject_DecoupledClientRegistration_Element &a_Key ) ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT Load ( BSTR a_Clsid ) ;
	HRESULT Save ( BSTR a_Clsid ) ;
	HRESULT Delete ( BSTR a_Clsid ) ;

	HRESULT GetResult () { return m_Result ; }

	DWORD GetProcessIdentifier () { return m_ProcessIdentifier ; }
	BSTR GetProvider () { return m_Provider ; }
	BSTR GetLocale () { return m_Locale ; }
	BSTR GetUser () { return m_User ; }
	BSTR GetScope () { return m_Scope ; }
	BSTR GetCreationTime () { return m_CreationTime ; }
	BSTR GetClsid () { return m_Clsid ; }
	BYTE *GetMarshaledProxy () { return m_MarshaledProxy ; }
	DWORD GetMarshaledProxyLength () { return m_MarshaledProxyLength ; }

	HRESULT SetProcessIdentifier ( DWORD a_ProcessIdentifier ) ;
	HRESULT SetProvider ( BSTR a_Provider ) ;
	HRESULT SetLocale ( BSTR a_Locale ) ;
	HRESULT SetUser ( BSTR a_User ) ;
	HRESULT SetScope ( BSTR a_Scope ) ;
	HRESULT SetCreationTime ( BSTR a_CreationTime ) ;
	HRESULT SetClsid ( const BSTR a_Clsid ) ;
	HRESULT SetMarshaledProxy ( BYTE *a_MarshaledProxy , DWORD a_MarshaledProxyLength ) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DecoupledClientRegistration
{
private:

	LONG m_ReferenceCount ;

private:

	WmiQueue < CServerObject_DecoupledClientRegistration_Element , 8 > m_Queue ;

protected:

	HRESULT m_Result ;

protected:

	static LPCWSTR s_Strings_Reg_Null ;
	static LPCWSTR s_Strings_Reg_Home ;
	static LPCWSTR s_Strings_Reg_HomeClient ;

public:	/* Internal */

    CServerObject_DecoupledClientRegistration ( WmiAllocator &a_Allocator ) ;
    ~CServerObject_DecoupledClientRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT Load () ;

	HRESULT Load (

		BSTR a_Provider ,
		BSTR a_User ,
		BSTR a_Locale ,
		BSTR a_Scope
	) ;

	static  LPCWSTR getClientKey(void) { return s_Strings_Reg_HomeClient;}

	WmiQueue < CServerObject_DecoupledClientRegistration_Element , 8 > &GetQueue () { return m_Queue ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DecoupledServerRegistration
{
private:

	LONG m_ReferenceCount ;

private:

protected:

	HRESULT m_Result ;

	DWORD m_ProcessIdentifier ;
	BSTR m_CreationTime ;
	BYTE *m_MarshaledProxy ;
	DWORD m_MarshaledProxyLength ;

protected:

	static LPCWSTR s_Strings_Reg_Null ;
	static LPCWSTR s_Strings_Reg_Home ;
	static LPCWSTR s_Strings_Reg_HomeServer ;

	static LPCWSTR s_Strings_Reg_CreationTime ;
	static LPCWSTR s_Strings_Reg_ProcessIdentifier ;
	static LPCWSTR s_Strings_Reg_MarshaledProxy ;

	void Clear () ;

	HRESULT Validate () ;

public:	/* Internal */

    CServerObject_DecoupledServerRegistration ( WmiAllocator &a_Allocator ) ;
    ~CServerObject_DecoupledServerRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT Load () ;
	HRESULT Save () ;
	HRESULT Delete () ;

	HRESULT GetResult () { return m_Result ; }

	DWORD GetProcessIdentifier () { return m_ProcessIdentifier ; }
	BSTR GetCreationTime () { return m_CreationTime ; }
	BYTE *GetMarshaledProxy () { return m_MarshaledProxy ; }
	DWORD GetMarshaledProxyLength () { return m_MarshaledProxyLength ; }

	HRESULT SetProcessIdentifier ( DWORD a_ProcessIdentifier ) ;
	HRESULT SetCreationTime ( BSTR a_CreationTime ) ;
	HRESULT SetMarshaledProxy ( BYTE *a_MarshaledProxy , DWORD a_MarshaledProxyLength ) ;

};


#endif // _Server_ProviderRegistrationDecoupled_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\common\include\provreginfo.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvRegInfo.h

Abstract:


History:

--*/

#ifndef _Server_ProviderRegistrationInfo_H
#define _Server_ProviderRegistrationInfo_H

#include "ProvDnf.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT VerifySecureLocalSystemProviders ( wchar_t *a_Clsid ) ;
HRESULT VerifySecureSvcHostProviders ( wchar_t *a_Clsid ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern GENERIC_MAPPING g_ProviderBindingMapping ; 

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define DEFAULT_PROVIDER_TIMEOUT 120000
#define DEFAULT_PROVIDER_LOAD_TIMEOUT 120000

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_ThreadingModel
{
	e_Apartment = 0 ,
	e_Both ,
	e_Free ,
	e_Neutral ,
	e_ThreadingModel_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_Synchronization
{
	e_Ignored = 0 ,
	e_None ,
	e_Supported ,
	e_Required ,
	e_RequiresNew ,
	e_Synchronization_Unknown 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_Boolean
{
	e_False = 0 ,
	e_True ,
	e_Boolean_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_ImpersonationLevel
{
	e_Impersonate_None = 0 ,
	e_Impersonate ,
	e_ImpersonationLevel_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_InitializationReentrancy
{
	e_InitializationReentrancy_Clsid = 0 ,
	e_InitializationReentrancy_Namespace ,
	e_InitializationReentrancy_None ,
	e_InitializationReentrancy_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_InteractionType
{
	e_InteractionType_Pull = 0 ,
	e_InteractionType_Push ,
	e_InteractionType_PushVerify ,
	e_InteractionType_Unknown
} ;


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define e_QuerySupportLevels_UnarySelect ( 1 )
#define e_QuerySupportLevels_References ( e_QuerySupportLevels_UnarySelect << 1 )
#define e_QuerySupportLevels_Associators ( e_QuerySupportLevels_References << 1 )
#define e_QuerySupportLevels_V1ProviderDefined ( e_QuerySupportLevels_Associators << 1 )
#define e_QuerySupportLevels_None ( e_QuerySupportLevels_V1ProviderDefined << 1 )
#define e_QuerySupportLevels_Unknown ( 0 )


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef ULONGLONG Enum_PropertyMask ;

#define	e_ThreadingModel 0x1 
#define	e_Synchronization 0x2
#define	e_Clsid 0x4
#define	e_ClientClsid 0x8
#define	e_DefaultMachineName 0x10
#define	e_UnloadTimeout 0x20
#define	e_ImpersonationLevel 0x40
#define	e_InitializationReentrancy 0x80
#define	e_InitializeAsAdminFirst 0x100
#define	e_PerUserInitialization 0x200
#define	e_PerLocaleInitialization 0x400
#define	e_Pure 0x800
#define	e_Hosting 0x1000
#define	e_HostingGroup 0x2000
#define	e_SupportsPut 0x4000
#define	e_SupportsGet 0x8000
#define	e_SupportsDelete 0x10000
#define	e_SupportsEnumeration 0x20000
#define	e_QuerySupportLevels 0x40000
#define	e_InteractionType 0x80000
#define	e_ResultSetQueries 0x100000
#define	e_UnSupportedQueries 0x200000
#define	e_ReferencedSetQueries 0x400000
#define	e_ClearAfter 0x800000
#define	e_SupportsThrottling 0x1000000
#define	e_ConcurrentIndependantRequests 0x2000000
#define	e_SupportsSendStatus 0x4000000
#define	e_OperationTimeoutInterval 0x8000000
#define	e_InitializationTimeoutInterval 0x10000000
#define	e_SupportsQuotas 0x20000000
#define	e_Enabled 0x40000000
#define	e_SupportsShutdown 0x80000000
#define	e_SupportsBatching 0x100000000
#define	e_SupportsTransactions 0x200000000
#define	e_CacheRefreshInterval 0x400000000
#define	e_PerUserSchema 0x800000000
#define	e_ReSynchroniseOnNamespaceOpen 0x1000000000
#define	e_MemoryPerHost 0x2000000000
#define	e_MemoryAllHosts 0x4000000000
#define	e_ThreadsPerHost 0x8000000000
#define	e_HandlesPerHost 0x10000000000
#define	e_ProcessLimitAllHosts 0x20000000000
#define	e_Version 0x40000000000
#define	e_SecurityDescriptor 0x80000000000
#define	e_Name 0x100000000000

#define	e_All 0xFFFFFFFFFFFFFFFF

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_GlobalRegistration 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	LPWSTR m_Object_UnloadTimeout ;
	ULONG m_Object_UnloadTimeoutMilliSeconds ;

	LPWSTR m_Event_UnloadTimeout ;
	ULONG m_Event_UnloadTimeoutMilliSeconds ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

protected:

	static LPCWSTR s_Strings_Wmi_ClearAfter ;
	static LPCWSTR s_Strings_Wmi___ObjectProviderCacheControl ;
	static LPCWSTR s_Strings_Wmi___EventProviderCacheControl ;
	static LPCWSTR s_Strings_Wmi_Class ;
	static LPCWSTR s_Strings_Wmi_s_Strings_Query_Object ;
	static LPCWSTR s_Strings_Wmi_s_Strings_Path_Object ;
	static LPCWSTR s_Strings_Wmi_s_Strings_Query_Event ;
	static LPCWSTR s_Strings_Wmi_s_Strings_Path_Event ;

protected:
public:	/* Internal */

    CServerObject_GlobalRegistration () ;
    ~CServerObject_GlobalRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object ,
		LPWSTR &a_UnloadTimeout ,
		ULONG &a_UnloadTimeoutMilliSeconds 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask
	) ;

	wchar_t *GetUnloadTimeout () { return m_Object_UnloadTimeout ; }
	ULONG GetUnloadTimeoutMilliSeconds () { return m_Object_UnloadTimeoutMilliSeconds ; }

	wchar_t *GetObjectUnloadTimeout () { return m_Object_UnloadTimeout ; }
	ULONG GetObjectUnloadTimeoutMilliSeconds () { return m_Object_UnloadTimeoutMilliSeconds ; }

	wchar_t *GetEventUnloadTimeout () { return m_Event_UnloadTimeout ; }
	ULONG GetEventUnloadTimeoutMilliSeconds () { return m_Event_UnloadTimeoutMilliSeconds ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_HostQuotaRegistration 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	SIZE_T m_MemoryPerHost ;
	SIZE_T m_MemoryAllHosts ;
	ULONG m_ThreadsPerHost ;
	ULONG m_HandlesPerHost ;
	ULONG m_ProcessLimitAllHosts ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

protected:

	static LPCWSTR s_Strings_Wmi_HostQuotas_Query ;
	static LPCWSTR s_Strings_Wmi_HostQuotas_Path ;
	static LPCWSTR s_Strings_Wmi_MemoryPerHost ;
	static LPCWSTR s_Strings_Wmi_MemoryAllHosts ;
	static LPCWSTR s_Strings_Wmi_ThreadsPerHost ;
	static LPCWSTR s_Strings_Wmi_HandlesPerHost ;
	static LPCWSTR s_Strings_Wmi_ProcessLimitAllHosts ;

protected:
public:	/* Internal */

    CServerObject_HostQuotaRegistration () ;
    ~CServerObject_HostQuotaRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask
	) ;

	SIZE_T GetMemoryPerHost () { return m_MemoryPerHost ; }
	SIZE_T GetMemoryAllHosts () { return m_MemoryAllHosts ; }
	ULONG GetThreadsPerHost () { return m_ThreadsPerHost; }
	ULONG GetHandlesPerHost () { return m_HandlesPerHost; }
	ULONG GetProcessLimitAllHosts () { return m_ProcessLimitAllHosts ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ComRegistration 
{
private:

	LONG m_ReferenceCount ;

private:

	HRESULT Load_ThreadingModel ( HKEY a_Clsid ) ;
	HRESULT Load_Synchronization ( HKEY a_ClsidKey ) ;

	HRESULT Load_InProcServer32 ( LPCWSTR a_ClsidStringKey ) ;
	HRESULT Load_LocalServer32 ( LPCWSTR a_ClsidStringKey ) ;

	HRESULT Load_AppId ( HKEY a_Clsid_Key ) ;
	HRESULT Load_ServerTypes ( LPCWSTR a_ClsidString ) ;

protected:

	HRESULT m_Result ;

	Enum_ThreadingModel m_ThreadingModel ;
	Enum_Synchronization m_Synchronization ;

	Enum_Boolean m_InProcServer32 ;
	Enum_Boolean m_LocalServer32 ;
	Enum_Boolean m_Service ;
	Enum_Boolean m_Loaded ;
	BSTR m_Clsid ;
	BSTR m_AppId ;
	BSTR m_ProviderName ;
	wchar_t m_InProcServer32_Path [ MAX_PATH ] ;
	wchar_t m_LocalServer32_Path [ MAX_PATH ] ;
	wchar_t m_Server_Name [ MAX_PATH ] ;

protected:

	static LPCWSTR s_Strings_Reg_Null ;

	static LPCWSTR s_Strings_Reg_ThreadingModel ;
	static LPCWSTR s_Strings_Reg_InProcServer32 ;
	static LPCWSTR s_Strings_Reg_LocalServer32 ;
	static LPCWSTR s_Strings_Reg_Synchronization ;
	static LPCWSTR s_Strings_Reg_AppId ;

	static LPCWSTR s_Strings_Reg_Apartment_Apartment ;
	static LPCWSTR s_Strings_Reg_Apartment_Both ;
	static LPCWSTR s_Strings_Reg_Apartment_Free ;
	static LPCWSTR s_Strings_Reg_Apartment_Neutral ;

	static LPCWSTR s_Strings_Reg_Apartment_Required ;
	static LPCWSTR s_Strings_Reg_Synchronization_Ignored ; 
	static LPCWSTR s_Strings_Reg_Synchronization_None ;
	static LPCWSTR s_Strings_Reg_Synchronization_Supported ;
	static LPCWSTR s_Strings_Reg_Synchronization_Required ;
	static LPCWSTR s_Strings_Reg_Synchronization_RequiresNew ;

	static LPCWSTR s_Strings_Reg_ClsidKeyStr ;

public:	/* Internal */

    CServerObject_ComRegistration () ;
    ~CServerObject_ComRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT Load ( LPCWSTR a_Clsid , LPCWSTR a_ProviderName ) ;

	Enum_ThreadingModel GetThreadingModel () { return m_ThreadingModel ; }
	Enum_Synchronization GetSynchronization () { return m_Synchronization ; }

	Enum_Boolean InProcServer32 () { return m_InProcServer32 ; }
	Enum_Boolean LocalServer32 () { return m_LocalServer32 ; }
	Enum_Boolean Loaded () { return m_Loaded ; }

	wchar_t *GetInProcServer32_Path () { return m_InProcServer32_Path ; }
	wchar_t *GetLocalServer32_Path () { return m_LocalServer32_Path ; }
	wchar_t *GetServer_Name () { return m_Server_Name ; }
	wchar_t *GetProviderName () { return m_ProviderName ; }
	wchar_t *GetProviderClsid () { return m_Clsid ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ComProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	CServerObject_ComRegistration m_ClsidServer ;

	ULONG m_Version ;
	Enum_ImpersonationLevel m_ImpersonationLevel ;
	Enum_InitializationReentrancy m_InitializationReentrancy ;
	BOOL m_InitializeAsAdminFirst ;
	BOOL m_PerUserInitialization ;
	BOOL m_PerLocaleInitialization ;
	BOOL m_SupportsQuotas ;
	BOOL m_Enabled ;
	BOOL m_SupportsShutdown ;
	BOOL m_Pure ;
	Enum_Hosting m_Hosting ;
	LPWSTR m_HostingGroup ;
	LPWSTR m_DefaultMachineName ;
	BOOL m_DecoupledImpersonationRestriction ;

	LPWSTR m_InitializationTimeout ;
	ULONG m_InitializationTimeoutMilliSeconds ;

	LPWSTR m_UnloadTimeout ;
	ULONG m_UnloadTimeoutMilliSeconds ;

	BOOL m_SupportsSendStatus ;
	LPWSTR m_OperationTimeout ;
	ULONG m_OperationTimeoutMilliSeconds ;

	BOOL m_SupportsThrottling ;
	ULONG m_ConcurrentIndependantRequests ;

	BSTR m_ProviderName ;

	GUID m_CLSID ;
	GUID m_ClientCLSID ;

	IWbemClassObject *m_Identity ;
	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;
	SECURITY_DESCRIPTOR *m_SecurityDescriptor ;

public:

	static LPCWSTR s_Strings_Wmi_Clsid ;
	static LPCWSTR s_Strings_Wmi_ClientClsid ;
	static LPCWSTR s_Strings_Wmi_Name ;
	static LPCWSTR s_Strings_Wmi_Version ;
	static LPCWSTR s_Strings_Wmi_DefaultMachineName ;
	static LPCWSTR s_Strings_Wmi_UnloadTimeout ;
	static LPCWSTR s_Strings_Wmi_ImpersonationLevel ;
	static LPCWSTR s_Strings_Wmi_InitializationReentrancy ;
	static LPCWSTR s_Strings_Wmi_InitializeAsAdminFirst ;
	static LPCWSTR s_Strings_Wmi_PerUserInitialization ;
	static LPCWSTR s_Strings_Wmi_PerLocaleInitialization ;
	static LPCWSTR s_Strings_Wmi_Pure ;
	static LPCWSTR s_Strings_Wmi_Hosting ;
	static LPCWSTR s_Strings_Wmi_HostingGroup ;
	static LPCWSTR s_Strings_Wmi_SupportsThrottling ;
	static LPCWSTR s_Strings_Wmi_SupportsQuotas ;
	static LPCWSTR s_Strings_Wmi_SupportsShutdown ;
	static LPCWSTR s_Strings_Wmi_Enabled ;
	static LPCWSTR s_Strings_Wmi_ConcurrentIndependantRequests ;
	static LPCWSTR s_Strings_Wmi_SupportsSendStatus ;
	static LPCWSTR s_Strings_Wmi_OperationTimeoutInterval ;
	static LPCWSTR s_Strings_Wmi_InitializationTimeoutInterval ;
	static LPCWSTR s_Strings_Wmi_SecurityDescriptor ;

	static WCHAR s_Strings_Wmi_WmiCore [] ;
	static WCHAR s_Strings_Wmi_SelfHost [] ;
	static WCHAR s_Strings_Wmi_WmiCoreOrSelfHost [] ;
	static WCHAR s_Strings_Wmi_Decoupled [] ;
	static WCHAR s_Strings_Wmi_DecoupledColon [] ;
	static WCHAR s_Strings_Wmi_SharedLocalSystemHost [] ;
	static WCHAR s_Strings_Wmi_SharedLocalSystemHostOrSelfHost [] ;
	static WCHAR s_Strings_Wmi_SharedLocalServiceHost [] ;
	static WCHAR s_Strings_Wmi_SharedNetworkServiceHost [] ;
	static WCHAR s_Strings_Wmi_SharedUserHost [] ;
	static WCHAR s_Strings_Wmi_NonCom [] ;

	static WCHAR s_Strings_Wmi_DefaultSharedLocalSystemHost [] ;
	static WCHAR s_Strings_Wmi_DefaultSharedLocalSystemHostOrSelfHost [] ;
	static WCHAR s_Strings_Wmi_DefaultSharedLocalServiceHost [] ;
	static WCHAR s_Strings_Wmi_DefaultSharedNetworkServiceHost [] ;
	static WCHAR s_Strings_Wmi_DefaultSharedUserHost [] ;

	static LPCWSTR s_Strings_Wmi_DefaultHostingRegistryKey ;

protected:
public:	/* Internal */

    CServerObject_ComProviderRegistrationV1 () ;
    ~CServerObject_ComProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object ,
		LPCWSTR a_ProviderName
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	const CLSID &GetClsid () { return m_CLSID ; }
	const CLSID &GetClientClsid () { return m_ClientCLSID ; }
	wchar_t *GetProviderName () { return m_ProviderName ; }

	ULONG GetVersion () { return m_Version ; }
	Enum_ImpersonationLevel GetImpersonationLevel () { return m_ImpersonationLevel ; }
	Enum_InitializationReentrancy GetInitializationReentrancy () { return m_InitializationReentrancy ; }
	Enum_Hosting GetHosting () { return m_Hosting ; }
	LPCWSTR GetHostingGroup () { return m_HostingGroup ; }

	BOOL InitializeAsAdminFirst () { return m_InitializeAsAdminFirst ; }
	BOOL PerUserInitialization () { return m_PerUserInitialization ; }
	BOOL PerLocaleInitialization () { return m_PerLocaleInitialization ; }
	BOOL Pure () { return m_Pure ; }
	BOOL Enabled () { return m_Enabled ; }
	BOOL SupportsQuotas () { return m_SupportsQuotas ; }

	wchar_t *GetDefaultMachineName () { return m_DefaultMachineName ; }
	wchar_t *GetUnloadTimeout () { return m_UnloadTimeout ; }
	wchar_t *GetInitializationTimeout () { return m_InitializationTimeout ; }
	wchar_t *GetOperationTimeout () { return m_OperationTimeout ; }

	void SetUnloadTimeoutMilliSeconds ( ULONG a_UnloadTimeoutMilliSeconds ) { m_UnloadTimeoutMilliSeconds = a_UnloadTimeoutMilliSeconds ; }

	ULONG GetUnloadTimeoutMilliSeconds () { return m_UnloadTimeoutMilliSeconds ; }
	ULONG GetInitializationTimeoutMilliSeconds () { return m_InitializationTimeoutMilliSeconds ; }
	ULONG GetOperationTimeoutMilliSeconds () { return m_OperationTimeoutMilliSeconds ; }

	ULONG GetConcurrentIndependantRequests () { return m_ConcurrentIndependantRequests ; }
	BOOL GetSupportsThrottling () { return m_SupportsThrottling ; }
	BOOL GetSupportsSendStatus () { return m_SupportsSendStatus ; }
	BOOL GetSupportsShutdown () { return m_SupportsShutdown ; }

	Enum_ThreadingModel GetThreadingModel () { return m_ClsidServer.GetThreadingModel () ; }	

	BOOL GetDecoupledImpersonationRestriction () { return m_DecoupledImpersonationRestriction ; }

	CServerObject_ComRegistration &GetClsidServer () { return m_ClsidServer ; }

	SECURITY_DESCRIPTOR *GetSecurityDescriptor () { return m_SecurityDescriptor ; }

	HRESULT GetResult () { return m_Result ; }

	IWbemClassObject *GetIdentity () { return m_Identity ; }

	static HRESULT GetHosting (
	
		LPCWSTR a_Hosting , 
		Enum_Hosting & a_HostingValue , 
		LPWSTR &a_HostingGroup ,
		BOOL & a_ImpersonationRestriction 
	) ;

	static HRESULT GetHostingGroup ( 

		LPCWSTR a_Hosting , 
		size_t a_Prefix ,
		Enum_Hosting a_ExpectedHostingValue ,
		Enum_Hosting & a_HostingValue ,
		BSTR & a_HostingGroup
	) ;

	static HRESULT GetDefaultHostingGroup ( 

		Enum_Hosting a_HostingValue ,
		BSTR & a_HostingGroup 
	) ;

	static HRESULT GetDecoupledImpersonationRestriction ( 

		LPCWSTR a_Hosting , 
		BOOL & a_ImpersonationRestriction 
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_InstanceProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;
	BOOL m_SupportsPut ;
 	BOOL m_SupportsGet ;
	BOOL m_SupportsDelete ;
	BOOL m_SupportsEnumeration ;
	BOOL m_SupportsBatching ;
	BOOL m_SupportsTransactions ;

	Enum_InteractionType m_InteractionType ;
	ULONG m_QuerySupportLevels ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_InstanceProviderRegistration ;

	static LPCWSTR s_Strings_SupportsPut ;
	static LPCWSTR s_Strings_SupportsGet ;
	static LPCWSTR s_Strings_SupportsDelete ;
	static LPCWSTR s_Strings_SupportsEnumeration ;
	static LPCWSTR s_Strings_QuerySupportLevels ;
	static LPCWSTR s_Strings_InteractionType ;

	static LPCWSTR s_Strings_SupportsBatching ;
	static LPCWSTR s_Strings_SupportsTransactions ;

	static LPCWSTR s_Strings_QuerySupportLevels_UnarySelect ;
	static LPCWSTR s_Strings_QuerySupportLevels_References ;
	static LPCWSTR s_Strings_QuerySupportLevels_Associators ;
	static LPCWSTR s_Strings_QuerySupportLevels_V1ProviderDefined ;

	static LPCWSTR s_Strings_InteractionType_Pull ;
	static LPCWSTR s_Strings_InteractionType_Push ;
	static LPCWSTR s_Strings_InteractionType_PushVerify ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_InstanceProviderRegistrationV1 () ;
    ~CServerObject_InstanceProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL SupportsPut () { return m_SupportsPut ; }
	BOOL SupportsGet () { return m_SupportsGet ; }
	BOOL SupportsDelete () { return m_SupportsDelete ; }
	BOOL SupportsEnumeration () { return m_SupportsEnumeration ; }
	BOOL SupportsTransactions () { return m_SupportsTransactions ; }
	BOOL SupportsBatching () { return m_SupportsBatching ; }

	ULONG QuerySupportLevels () { return m_QuerySupportLevels ; }
	Enum_InteractionType InteractionType () { return m_InteractionType ; }

	BOOL Supported () { return m_Supported ; }
	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ClassProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;
	BOOL m_SupportsPut ;
 	BOOL m_SupportsGet ;
	BOOL m_SupportsDelete ;
	BOOL m_SupportsEnumeration ;
	BOOL m_SupportsBatching ;
	BOOL m_SupportsTransactions ;
	BOOL m_PerUserSchema ;
	BOOL m_ReSynchroniseOnNamespaceOpen ;
	BOOL m_HasReferencedSet;
	Enum_InteractionType m_InteractionType ;
	ULONG m_QuerySupportLevels ;
	ULONG m_Version ;
	LPWSTR m_CacheRefreshInterval ;
	ULONG m_CacheRefreshIntervalMilliSeconds ;

	LPWSTR m_ProviderName ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

	ULONG m_ResultSetQueryTreeCount ;
	WmiTreeNode **m_ResultSetQueryTree ;

	ULONG m_UnSupportedQueryTreeCount ;
	WmiTreeNode **m_UnSupportedQueryTree ;

	ULONG m_ReferencedSetQueryTreeCount ;
	WmiTreeNode **m_ReferencedSetQueryTree ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_ClassProviderRegistration ;

	static LPCWSTR s_Strings_Version ;

	static LPCWSTR s_Strings_SupportsPut ;
	static LPCWSTR s_Strings_SupportsGet ;
	static LPCWSTR s_Strings_SupportsDelete ;
	static LPCWSTR s_Strings_SupportsEnumeration ;
	static LPCWSTR s_Strings_QuerySupportLevels ;
	static LPCWSTR s_Strings_InteractionType ;
	static LPCWSTR s_Strings_SupportsBatching ;
	static LPCWSTR s_Strings_SupportsTransactions ;
	static LPCWSTR s_Strings_CacheRefreshInterval ;
	static LPCWSTR s_Strings_PerUserSchema ;
	static LPCWSTR s_Strings_ReSynchroniseOnNamespaceOpen ;

	static LPCWSTR s_Strings_QuerySupportLevels_UnarySelect ;
	static LPCWSTR s_Strings_QuerySupportLevels_References ;
	static LPCWSTR s_Strings_QuerySupportLevels_Associators ;
	static LPCWSTR s_Strings_QuerySupportLevels_V1ProviderDefined ;

	static LPCWSTR s_Strings_InteractionType_Pull ;
	static LPCWSTR s_Strings_InteractionType_Push ;
	static LPCWSTR s_Strings_InteractionType_PushVerify ;

	static LPCWSTR s_Strings_ResultSetQueries ;
	static LPCWSTR s_Strings_UnSupportedQueries ;
	static LPCWSTR s_Strings_ReferencedSetQueries ;

private:

	HRESULT ParseQuery (

		ULONG &a_Count ,
		WmiTreeNode **&a_Root ,
		SAFEARRAY *a_Array
	) ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_ClassProviderRegistrationV1 () ;
    ~CServerObject_ClassProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL SupportsPut () { return m_SupportsPut ; }
	BOOL SupportsGet () { return m_SupportsGet ; }
	BOOL SupportsDelete () { return m_SupportsDelete ; }
	BOOL SupportsEnumeration () { return m_SupportsEnumeration ; }
	BOOL SupportsTransactions () { return m_SupportsTransactions ; }
	BOOL SupportsBatching () { return m_SupportsBatching ; }
	BOOL GetPerUserSchema () { return m_PerUserSchema ; }
	BOOL GetReSynchroniseOnNamespaceOpen () { return m_ReSynchroniseOnNamespaceOpen ; }
	BOOL HasReferencedSet () { return m_HasReferencedSet ; }
	ULONG QuerySupportLevels () { return m_QuerySupportLevels ; }
	Enum_InteractionType InteractionType () { return m_InteractionType ; }

	ULONG GetResultSetQueryCount () { return m_ResultSetQueryTreeCount ; }
	WmiTreeNode **GetResultSetQuery () { return m_ResultSetQueryTree ; }

	ULONG GetUnSupportedQueryCount () { return m_UnSupportedQueryTreeCount ; }
	WmiTreeNode **GetUnSupportedQuery () { return m_UnSupportedQueryTree ; }

	ULONG GetReferencedSetQueryCount () { return m_ReferencedSetQueryTreeCount ; }
	WmiTreeNode **GetReferencedSetQuery () { return m_ReferencedSetQueryTree ; }

	wchar_t *GetCacheRefreshInterval () { return m_CacheRefreshInterval ; }
	ULONG GetCacheRefreshIntervalMilliSeconds () { return m_CacheRefreshIntervalMilliSeconds ; }

	wchar_t *GetProviderName () { return m_ProviderName ; }

	BOOL Supported () { return m_Supported ; }
	HRESULT GetResult () { return m_Result ; }

	BOOL GetVersion () { return m_Version ; } 
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_MethodProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;
	BOOL m_SupportsMethods ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_MethodProviderRegistration ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_MethodProviderRegistrationV1 () ;
    ~CServerObject_MethodProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL SupportsMethods () { return m_SupportsMethods ; }

	BOOL Supported () { return m_Supported ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_EventProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_EventProviderRegistration ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_EventProviderRegistrationV1 () ;
    ~CServerObject_EventProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL Supported () { return m_Supported ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_EventConsumerProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_EventConsumerProviderRegistration ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_EventConsumerProviderRegistrationV1 () ;
    ~CServerObject_EventConsumerProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL Supported () { return m_Supported ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DynamicPropertyProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;
	BOOL m_SupportsPut ;
 	BOOL m_SupportsGet ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;


private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_PropertyProviderRegistration ;

	static LPCWSTR s_Strings_SupportsPut ;
	static LPCWSTR s_Strings_SupportsGet ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_DynamicPropertyProviderRegistrationV1 () ;
    ~CServerObject_DynamicPropertyProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL SupportsPut () { return m_SupportsPut ; }
	BOOL SupportsGet () { return m_SupportsGet ; }

	BOOL Supported () { return m_Supported ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_ClassProviderRegistration ;
	static LPCWSTR s_Strings_InstanceProviderRegistration ;
	static LPCWSTR s_Strings_MethodProviderRegistration ;
	static LPCWSTR s_Strings_PropertyProviderRegistration ;
	static LPCWSTR s_Strings_EventProviderRegistration ;
	static LPCWSTR s_Strings_EventConsumerProviderRegistration ;

protected:

	HRESULT m_Result ;

	CServerObject_ComProviderRegistrationV1 m_ComRegistration ;

	CServerObject_ClassProviderRegistrationV1 m_ClassProviderRegistration ;
	CServerObject_InstanceProviderRegistrationV1 m_InstanceProviderRegistration ;
	CServerObject_MethodProviderRegistrationV1 m_MethodProviderRegistration ;
	CServerObject_DynamicPropertyProviderRegistrationV1 m_PropertyProviderRegistration ;
	CServerObject_EventProviderRegistrationV1 m_EventProviderRegistration ;
	CServerObject_EventConsumerProviderRegistrationV1 m_EventConsumerProviderRegistration ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_ProviderRegistrationV1 () ;
    ~CServerObject_ProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	const CLSID &GetClsid () { return m_ComRegistration.GetClsid () ; }

	BOOL PerUserInitialization () { return m_ComRegistration.PerUserInitialization () ; }
	BOOL PerLocaleInitialization () { return m_ComRegistration.PerLocaleInitialization () ; }
	Enum_InitializationReentrancy GetInitializationReentrancy () { return m_ComRegistration.GetInitializationReentrancy () ; }
	Enum_ThreadingModel GetThreadingModel () { return m_ComRegistration.GetThreadingModel () ; }	
	Enum_Hosting GetHosting () { return m_ComRegistration.GetHosting () ; }
	LPCWSTR GetHostingGroup () { return m_ComRegistration.GetHostingGroup () ; }

	ULONG GetUnloadTimeoutMilliSeconds () { return m_ComRegistration.GetUnloadTimeoutMilliSeconds () ; }
	wchar_t *GetProviderName () { return m_ComRegistration.GetProviderName () ; }
	CServerObject_ComProviderRegistrationV1 &GetComRegistration () { return m_ComRegistration ; }

	IWbemClassObject *GetIdentity () { return m_ComRegistration.GetIdentity () ; }

	CServerObject_ClassProviderRegistrationV1 &GetClassProviderRegistration () { return m_ClassProviderRegistration ; }
	CServerObject_InstanceProviderRegistrationV1 &GetInstanceProviderRegistration () { return m_InstanceProviderRegistration ; }
	CServerObject_MethodProviderRegistrationV1 &GetMethodProviderRegistration () { return m_MethodProviderRegistration ; }
	CServerObject_DynamicPropertyProviderRegistrationV1 &GetPropertyProviderRegistration () { return m_PropertyProviderRegistration ; }
	CServerObject_EventProviderRegistrationV1 &GetEventProviderRegistration () { return m_EventProviderRegistration ; }
	CServerObject_EventConsumerProviderRegistrationV1 &GetEventConsumerProviderRegistration () { return m_EventConsumerProviderRegistration ; }

	void SetUnloadTimeoutMilliSeconds ( ULONG a_UnloadTimeoutMilliSeconds ) { m_ComRegistration.SetUnloadTimeoutMilliSeconds ( a_UnloadTimeoutMilliSeconds ) ; }

	ULONG GetInitializationTimeoutMilliSeconds () { return m_ComRegistration.GetInitializationTimeoutMilliSeconds () ; }

	HRESULT GetResult () { return m_Result ; }

	BOOL ObjectProvider () ;
	BOOL EventProvider () ;
};

#endif // _Server_ProviderRegistrationInfo_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\callsec.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CALLSEC.CPP

Abstract:

History:

    raymcc      29-Jul-98        First draft.

--*/

#include "precomp.h"
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <stdio.h>
#include <wbemint.h>
#include "CallSec.h"

// {4551AB1A-C16F-40f3-A192-6A6264FE89D6}
DEFINE_GUID(IID_CWbemCallSecurity, 
0x4551ab1a, 0xc16f, 0x40f3, 0xa1, 0x92, 0x6a, 0x62, 0x64, 0xfe, 0x89, 0xd6);

// {60B9F5CA-036E-4795-BB7C-017B9807E9B3}
DEFINE_GUID(IID_CWbemThreadSecurityHandle, 
0x60b9f5ca, 0x36e, 0x4795, 0xbb, 0x7c, 0x1, 0x7b, 0x98, 0x7, 0xe9, 0xb3);


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT IsNetworkLogin (

	HANDLE a_Token ,
	BOOL &a_Truth 
)
{
	HRESULT t_Result = S_OK ;

	PSID t_NetworkSid = NULL ;

    SID_IDENTIFIER_AUTHORITY t_NtAuthority = SECURITY_NT_AUTHORITY ;
    BOOL t_Status = AllocateAndInitializeSid (

        &t_NtAuthority,
        1,
        SECURITY_NETWORK_RID,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        & t_NetworkSid
    ) ;

    if ( t_Status )
    {
		t_Status = CheckTokenMembership ( a_Token, t_NetworkSid, & a_Truth ) ;
		if ( t_Status ) 
		{
		}
		else
		{
			t_Result = WBEM_E_FAILED ;
		}

		FreeSid ( t_NetworkSid ) ;
	}
	else
	{
		t_Result = WBEM_E_FAILED ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetImpersonationLevel (

	HANDLE a_Token ,
	SECURITY_IMPERSONATION_LEVEL &a_Level ,
	TOKEN_TYPE &a_TokenType
)
{
	HRESULT t_Result = S_OK ;
	DWORD t_ReturnLength = 0 ;
	BOOL t_TokenStatus = GetTokenInformation (

		a_Token ,
		TokenType ,
		( void * ) & a_TokenType ,
		sizeof ( a_TokenType ) ,
		& t_ReturnLength
	) ;

	if ( t_TokenStatus )
	{
		if ( a_TokenType == TokenImpersonation )
		{
			BOOL t_TempTokenStatus = GetTokenInformation (

				a_Token ,
				TokenImpersonationLevel ,
				( void * ) & a_Level ,
				sizeof ( a_Level ) ,
				& t_ReturnLength
			) ;

			if ( t_TempTokenStatus )
			{
				t_Result = S_OK ;
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_FAILED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetUserSid (

	HANDLE a_Token ,
	ULONG *a_Size ,
	PSID a_Sid
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

    if ( a_Token )
	{
		if ( a_Size ) 
		{
			TOKEN_USER *t_TokenUser = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenUser ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						if ( a_Sid )
						{
							if ( *a_Size >= t_ReturnLength )
							{
								t_TokenUser = ( TOKEN_USER * ) new BYTE [ t_ReturnLength ] ;
								if ( t_TokenUser )
								{
									t_TokenStatus = GetTokenInformation (

										a_Token ,
										t_TokenInformationClass ,
										t_TokenUser ,
										t_ReturnLength ,
										& t_ReturnLength
									) ;

									if ( t_TokenStatus )
									{
										DWORD t_SidLength = GetLengthSid ( t_TokenUser->User.Sid ) ;
										*a_Size = t_SidLength ;

										CopyMemory ( a_Sid , t_TokenUser->User.Sid , t_SidLength ) ;

										t_Result = S_OK ;
									}

									delete [] t_TokenUser ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = WBEM_E_BUFFER_TOO_SMALL ;
							}
						}
						else
						{
							*a_Size = t_ReturnLength ;

							t_Result = S_OK ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetUser (

	HANDLE a_Token ,
    ULONG *a_Size ,
    LPWSTR a_Buffer
)
{
	HRESULT t_Result = S_OK ;

    if ( a_Token )
	{
		if ( a_Size && a_Buffer ) 
		{
			TOKEN_USER *t_TokenUser = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenUser ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						t_TokenUser = ( TOKEN_USER * ) new BYTE [ t_ReturnLength ] ;

						t_TokenStatus = GetTokenInformation (

							a_Token ,
							t_TokenInformationClass ,
							t_TokenUser ,
							t_ReturnLength ,
							& t_ReturnLength
						) ;
					}
					break ;

					default:
					{
					}
					break ;
				}
			}

			if ( t_TokenStatus )
			{
				SID_NAME_USE t_SidNameUse ;
				wchar_t *t_Domain = NULL ;
				wchar_t *t_User = NULL ;
				ULONG t_DomainSize = 0 ;
				ULONG t_UserSize = 0 ;

				BOOL t_LookupStatus = LookupAccountSidW (

					NULL ,
					t_TokenUser->User.Sid ,
					t_User ,
					& t_UserSize ,
					t_Domain ,
					& t_DomainSize ,
					& t_SidNameUse
				) ;

				if ( ! t_LookupStatus )
				{
					DWORD t_LastError = GetLastError () ;

					switch ( t_LastError ) 
					{
						case ERROR_INSUFFICIENT_BUFFER:
						{
							t_User = new wchar_t [ t_UserSize ] ;
							if ( t_User )
							{
								t_Domain = new wchar_t [ t_DomainSize ] ;
								if ( t_Domain ) 
								{
									t_LookupStatus = LookupAccountSidW (

										NULL ,
										t_TokenUser->User.Sid ,
										t_User ,
										& t_UserSize ,
										t_Domain ,
										& t_DomainSize ,
										& t_SidNameUse
									) ;

									if ( t_LookupStatus )
									{
										ULONG t_Size = wcslen ( t_User ) + wcslen ( t_Domain ) + 2 ;

										if ( *a_Size >= t_Size )
										{
											StringCchPrintfW ( a_Buffer , *a_Size, L"%s\\%s" , t_Domain , t_User ) ;
										}
										else
										{
											t_Result = WBEM_E_BUFFER_TOO_SMALL ;
										}

										*a_Size = t_Size ;
									}
									else
									{
										if ( GetLastError () == ERROR_NONE_MAPPED )
										{
											t_Result = WBEM_E_NOT_FOUND ;
										}
										else
										{
											t_Result = WBEM_E_FAILED ;
										}
									}

									delete [] t_Domain ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								delete [] t_User ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						break ;

						case ERROR_NONE_MAPPED:
						{
							t_Result = WBEM_E_NOT_FOUND ;
						}
						break ;

						default:
						{
							t_Result = WBEM_E_FAILED ;
						}
						break ;
					}
				}
				else
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
				DWORD t_LastError = GetLastError () ;
			}

			if ( t_TokenUser )
			{
				delete [] ( ( BYTE * ) t_TokenUser ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetAuthenticationLuid ( 

	HANDLE a_Token ,
	LPVOID a_Luid
)
{
    if ( a_Token )
	{
		TOKEN_STATISTICS t_Statistics ;

		DWORD t_Returned = 0 ;
		BOOL t_Status = GetTokenInformation (

			a_Token, 
			TokenStatistics, 
			( void * ) & t_Statistics , 
			sizeof ( t_Statistics ) , 
			& t_Returned 
		) ;

		if ( t_Status )
		{
			* ( ( LUID * ) a_Luid ) = t_Statistics.AuthenticationId ;
		}
		else
		{
			return WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
        return ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle :: CWbemThreadSecurityHandle ( CLifeControl *a_Control ) : 

	m_ReferenceCount ( 0 ) ,
	m_ThreadToken ( NULL ) ,
	m_ImpersonationLevel ( 0 ) ,
	m_AuthorizationService ( 0 ) ,
	m_AuthenticationService ( 0 ) ,
	m_AuthenticationLevel ( 0 ) ,
	m_ServerPrincipalName ( 0 ) ,
	m_Identity ( NULL ) ,
	m_Origin ( WMI_ORIGIN_UNDEFINED ) ,
	m_Control ( a_Control ) 
{
    if ( m_Control )
    {
        m_Control->ObjectCreated ( ( IServerSecurity * ) this ) ;
    }
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle :: CWbemThreadSecurityHandle ( 

	const CWbemThreadSecurityHandle &a_Copy

) : m_ReferenceCount ( 0 ) ,
	m_ThreadToken ( NULL ) ,
	m_ImpersonationLevel ( 0 ) ,
	m_AuthorizationService ( 0 ) ,
	m_AuthenticationService ( 0 ) ,
	m_AuthenticationLevel ( 0 ) ,
	m_ServerPrincipalName ( 0 ) ,
	m_Identity ( NULL ) ,
	m_Origin ( WMI_ORIGIN_UNDEFINED ) ,
	m_Control ( NULL ) 
{
	*this = a_Copy ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle :: ~CWbemThreadSecurityHandle ()
{
    if ( m_ThreadToken )
	{
        CloseHandle ( m_ThreadToken ) ;
	}

    if ( m_ServerPrincipalName )
	{
        CoTaskMemFree ( m_ServerPrincipalName ) ;
	}

    if ( m_Identity )
	{
        CoTaskMemFree ( m_Identity ) ;
	}

    if ( m_Control )
    {
        m_Control->ObjectDestroyed ( ( IServerSecurity * ) this ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle &CWbemThreadSecurityHandle :: operator= ( const CWbemThreadSecurityHandle &a_Copy )
{
    if ( m_ThreadToken )
	{
        CloseHandle ( m_ThreadToken ) ;
		m_ThreadToken = NULL ;
	}

	if ( a_Copy.m_ThreadToken )
	{
		BOOL t_Status = DuplicateHandle (

			GetCurrentProcess () ,
			a_Copy.m_ThreadToken ,
			GetCurrentProcess () ,
			& m_ThreadToken ,
			0 ,
			TRUE ,
			DUPLICATE_SAME_ACCESS
		) ;
	}

	m_Origin = a_Copy.m_Origin ;
    m_ImpersonationLevel = a_Copy.m_ImpersonationLevel ;

    m_AuthenticationService = a_Copy.m_AuthenticationService ;
    m_AuthorizationService = a_Copy.m_AuthorizationService ;
    m_AuthenticationLevel = a_Copy.m_AuthenticationLevel ;
 
    if ( m_ServerPrincipalName )
    {
        CoTaskMemFree ( m_ServerPrincipalName ) ;
        m_ServerPrincipalName = NULL ;
    }

    if ( a_Copy.m_ServerPrincipalName )
    {        
        m_ServerPrincipalName = ( LPWSTR ) CoTaskMemAlloc ( ( wcslen ( a_Copy.m_ServerPrincipalName ) + 1 ) * 2	) ;
        if ( m_ServerPrincipalName )
		{
            StringCchCopyW ( m_ServerPrincipalName, wcslen ( a_Copy.m_ServerPrincipalName ) + 1, a_Copy.m_ServerPrincipalName ) ;
		}
    }

    if ( m_Identity )
    {
        CoTaskMemFree ( m_Identity ) ;
        m_Identity = NULL ;
    }

    if ( a_Copy.m_Identity )
    {
        m_Identity = ( LPWSTR ) CoTaskMemAlloc ( ( wcslen ( a_Copy.m_Identity ) + 1 ) * 2 ) ;
        if ( m_Identity )
		{
            StringCchCopyW ( m_Identity , wcslen ( a_Copy.m_Identity ) + 1, a_Copy.m_Identity ) ;
		}
    }

	if ( a_Copy.m_Control )
	{
		m_Control = a_Copy.m_Control ;
        if ( m_Control )
        {
            m_Control->ObjectCreated ( ( IServerSecurity * ) this ) ;
        }

	}

	return *this ;
}
    
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CWbemThreadSecurityHandle :: AddRef ()
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CWbemThreadSecurityHandle :: Release ()
{
    LONG t_ReferenceCount = InterlockedDecrement( & m_ReferenceCount ) ;
    if ( t_ReferenceCount == 0 )
	{
        delete this ;
	}

    return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: QueryInterface ( REFIID a_Riid , void **a_Void )
{
    if ( a_Riid == IID_IUnknown )
    {
        *a_Void = ( void ** ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID__IWmiThreadSecHandle )
    {
        *a_Void = ( void ** ) ( _IWmiThreadSecHandle * ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID_CWbemThreadSecurityHandle )
    {
        *a_Void = ( void ** ) ( CWbemThreadSecurityHandle * ) this ;

        AddRef () ;

        return S_OK ;
    }
    else 
	{
		return E_NOINTERFACE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
    
HRESULT CWbemThreadSecurityHandle :: GetToken ( HANDLE *a_ThreadToken )
{
	HRESULT t_Result = S_OK ;

	if ( a_ThreadToken )
	{
		if ( m_ThreadToken )
		{
			HANDLE t_ThreadToken = NULL ;

			BOOL t_Status = DuplicateHandle (

				GetCurrentProcess () ,
				m_ThreadToken ,
				GetCurrentProcess () ,
				& t_ThreadToken ,
				0 ,
				TRUE ,
				DUPLICATE_SAME_ACCESS
			) ;

			if ( t_Status )
			{
				*a_ThreadToken = t_ThreadToken ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}
		else
		{
			t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetUser ( 

    ULONG *a_Size ,
    LPWSTR a_Buffer
)
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadToken )
	{
		t_Result = :: GetUser ( m_ThreadToken , a_Size , a_Buffer ) ;
	}
	else
	{
		t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetUserSid ( 

    ULONG *a_Size ,
    PSID a_Sid
)
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadToken )
	{
		t_Result = :: GetUserSid ( m_ThreadToken , a_Size , a_Sid ) ;
	}
	else
	{
		t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetAuthenticationLuid ( LPVOID a_Luid )
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadToken )
	{
		t_Result = :: GetAuthenticationLuid ( m_ThreadToken , a_Luid ) ;
	}
	else
	{
		t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetImpersonation ( DWORD *a_Level )
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadToken )
	{		
		if ( a_Level )
		{
			SECURITY_IMPERSONATION_LEVEL t_ImpersonationLevel = SecurityAnonymous ;
			TOKEN_TYPE t_TokenType = TokenImpersonation ;

			t_Result = :: GetImpersonationLevel ( 

				m_ThreadToken , 
				t_ImpersonationLevel ,
				t_TokenType 		
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				switch ( t_ImpersonationLevel )
				{
					case SecurityAnonymous:
					{
						*a_Level = RPC_C_IMP_LEVEL_ANONYMOUS ;
					}
					break ;
    
					case SecurityIdentification:
					{
						*a_Level = RPC_C_IMP_LEVEL_IDENTIFY ;
					}
					break ;

					case SecurityImpersonation:
					{
						*a_Level = RPC_C_IMP_LEVEL_IMPERSONATE ;
					}
					break ;

					case SecurityDelegation:
					{
						*a_Level = RPC_C_IMP_LEVEL_DELEGATE ;
					}
					break ;

					default:
					{
						*a_Level = 0 ;
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetAuthentication (

	DWORD *a_Level
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Level ) 
	{
		*a_Level = GetAuthenticationLevel () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
    
HRESULT CWbemThreadSecurityHandle :: CloneRpcContext ( 

	IServerSecurity *a_Security 
)
{
	HRESULT t_Result = S_OK ;

	// If here, we are not impersonating and we want to gather info
	// about the client's call.
	// ============================================================

	RPC_AUTHZ_HANDLE t_Authorization = NULL ;

	// Ensures auto release of the mutex if we crash

//	CAutoSecurityMutex t_SecurityMutex ;

	DWORD t_ImpersonationLevel = 0 ;

	t_Result = a_Security->QueryBlanket (

		& m_AuthenticationService ,
		& m_AuthorizationService ,
		& m_ServerPrincipalName ,
		& m_AuthenticationLevel ,
		& t_ImpersonationLevel ,
		& t_Authorization ,
		NULL
	) ;

	if ( FAILED ( t_Result ) )
	{

		// In some cases, we cant get the name, but the rest is ok.  In particular
		// the temporary SMS accounts have that property.  Or nt 4 after IPCONFIG /RELEASE

		t_Result = a_Security->QueryBlanket (

			& m_AuthenticationService ,
			& m_AuthorizationService ,
			& m_ServerPrincipalName ,
			& m_AuthenticationLevel ,
			& t_ImpersonationLevel ,
			NULL ,
			NULL
		) ;

		t_Authorization = NULL ;
	}

	// We don't need this anymore.

//	t_SecurityMutex.Release () ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Authorization )
		{
			m_Identity = LPWSTR ( CoTaskMemAlloc ( ( wcslen ( LPWSTR ( t_Authorization ) ) + 1 ) * 2 ) ) ;
			if ( m_Identity )
			{
				StringCchCopyW ( m_Identity , wcslen ( LPWSTR ( t_Authorization ) ) + 1, LPWSTR ( t_Authorization ) ) ;
			}
		}

		// Impersonate the client long enough to clone the thread token.
		// =============================================================

		BOOL t_Impersonating = a_Security->IsImpersonating () ;
		if ( ! t_Impersonating )
		{
			t_Result = a_Security->ImpersonateClient () ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CloneThreadContext () ;

			if ( ! t_Impersonating )
			{
				a_Security->RevertToSelf () ;
			}
		}
	}
	else
	{        
		// THIS IS A WORKAROUND FOR COM BUG:
		// This failure is indicative of an anonymous-level client. 
		// ========================================================

		m_ImpersonationLevel = 0 ;

		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: CloneThreadContext ()
{
	HRESULT t_Result = S_OK ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& m_ThreadToken
	) ;

    if ( t_Status ) 
	{
		// Find out token info.
		// =====================

		DWORD t_ImpersonationLevel = 0 ;
		DWORD t_Returned = 0 ;

		t_Status = GetTokenInformation (

			m_ThreadToken ,
			TokenImpersonationLevel ,
			& t_ImpersonationLevel ,
			sizeof ( DWORD ) ,
			& t_Returned
		) ;

		if ( t_Status )
		{
			switch ( t_ImpersonationLevel )
			{
				case SecurityAnonymous:
				{
					m_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;
            
				case SecurityIdentification:
				{
					m_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				break ;

				case SecurityImpersonation:
				{
					m_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
				}
				break ;

				case SecurityDelegation:
				{
					m_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
				}
				break ;

				default:
				{
					m_ImpersonationLevel = 0 ;
				}
				break ;
			}

		}
		else
		{
			if ( GetLastError () == ERROR_ACCESS_DENIED )
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
			else
			{
				t_Result = WBEM_E_NOT_FOUND ;
			}
		}

	}
	else
	{
		if ( GetLastError () == ERROR_ACCESS_DENIED )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}
		
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: CloneProcessContext ()
{
	HRESULT t_Result = S_OK ;

	m_AuthenticationService = RPC_C_AUTHN_WINNT ;
	m_AuthorizationService = RPC_C_AUTHZ_NONE ;
	m_AuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY ;
	m_ServerPrincipalName = NULL ;
	m_Identity = NULL ;

	HANDLE t_ProcessToken = NULL ;
	BOOL t_Status = OpenProcessToken (

		GetCurrentProcess () ,
		TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE ,
		& t_ProcessToken
	) ;

	if ( t_Status ) 
	{
		t_Status = DuplicateTokenEx (

			t_ProcessToken,
			MAXIMUM_ALLOWED ,
			NULL ,
			( SECURITY_IMPERSONATION_LEVEL ) SecurityImpersonation ,
			TokenImpersonation ,
			& m_ThreadToken
		) ;

		if ( t_Status ) 
		{
			// This is the basic process thread. 
			// =================================

			m_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;

			t_Result = S_OK ;
		}
		else
		{
			// Unknown error
			// =============

			m_ImpersonationLevel = 0 ;

			t_Result = E_FAIL ;
		}

		CloseHandle ( t_ProcessToken ) ;
	}
	else
	{
		// Unknown error
		// =============

		m_ImpersonationLevel = 0 ;

		t_Result = E_FAIL ;
	}
		
	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle  *CWbemThreadSecurityHandle :: New ()
{
	return new CWbemThreadSecurityHandle ( NULL ) ;
}
    
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemCallSecurity :: CWbemCallSecurity ( 

	CLifeControl *a_Control

) : m_ReferenceCount ( 0 ) ,
	m_ImpersonationLevel ( 0 ) ,
	m_ThreadSecurityHandle ( NULL ) ,
	m_ThreadToken ( NULL ) ,
	m_Control ( a_Control ) 
{
	if ( m_Control ) 
	{
		m_Control->ObjectCreated ( ( IServerSecurity * ) this ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemCallSecurity :: ~CWbemCallSecurity ()
{
 	if ( m_ThreadToken )
	{
		CloseHandle ( m_ThreadToken ) ;
	}

   if ( m_ThreadSecurityHandle )
	{
        m_ThreadSecurityHandle->Release () ;
	}

	if ( m_Control ) 
	{
		m_Control->ObjectDestroyed ( ( IServerSecurity * ) this ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemCallSecurity &CWbemCallSecurity :: operator= ( const CWbemCallSecurity &a_Copy )
{
	if ( m_ThreadSecurityHandle )
	{
		m_ThreadSecurityHandle->Release () ;
		m_ThreadSecurityHandle = NULL ;
	}

	if ( a_Copy.m_Control )
	{
		m_Control = a_Copy.m_Control ;
        if ( m_Control )
           {
           m_Control->ObjectCreated ( ( IServerSecurity * ) this ) ;
           }
	}

	if ( a_Copy.m_ThreadSecurityHandle )
	{
		m_ThreadSecurityHandle = new CWbemThreadSecurityHandle ( * ( a_Copy.m_ThreadSecurityHandle ) ) ;
	}

	m_ImpersonationLevel = a_Copy.m_ImpersonationLevel ;

	m_ReferenceCount = 1 ;

	return *this ;
}
    
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CWbemCallSecurity :: AddRef ()
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CWbemCallSecurity :: Release ()
{
    LONG t_ReferenceCount = InterlockedDecrement( & m_ReferenceCount ) ;
    if ( t_ReferenceCount == 0 )
	{
        delete this ;
	}

    return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: QueryInterface ( REFIID a_Riid , void **a_Void )
{
    if ( a_Riid == IID_IUnknown )
    {
        *a_Void = ( void ** ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID_IServerSecurity )
    {
        *a_Void = ( void ** ) ( IServerSecurity * ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID_CWbemCallSecurity )
    {
        *a_Void = ( void ** ) ( CWbemCallSecurity * ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID__IWmiCallSec )
    {
        *a_Void = ( void ** ) ( _IWmiCallSec  *) this ;

        AddRef () ;

        return S_OK ;
    }
    else 
	{
		return E_NOINTERFACE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: QueryBlanket ( 

	DWORD *a_AuthenticationService ,
	DWORD *a_AuthorizationService ,
	OLECHAR **a_ServerPrincipalName ,
	DWORD *a_AuthenticationLevel ,
	DWORD *a_ImpersonationLevel ,
	void **a_Privileges ,
	DWORD *a_Capabilities
)
{
	if ( m_ThreadSecurityHandle )
	{
		if ( m_ThreadSecurityHandle->GetImpersonationLevel () == 0 )
		{
			return E_FAIL ;
		}

		if ( a_AuthenticationService )
		{
			*a_AuthenticationService = m_ThreadSecurityHandle->GetAuthenticationService () ;
		}

		if ( a_AuthorizationService )
		{
			*a_AuthorizationService = m_ThreadSecurityHandle->GetAuthorizationService () ;
		}

		if ( a_ImpersonationLevel )
		{
			*a_ImpersonationLevel = m_ThreadSecurityHandle->GetImpersonationLevel () ;
		}

		if ( a_AuthenticationLevel )
		{
			*a_AuthenticationLevel = m_ThreadSecurityHandle->GetAuthenticationLevel () ;
		}

		if ( a_ServerPrincipalName )
		{
			*a_ServerPrincipalName = 0 ;
        
			if ( m_ThreadSecurityHandle->GetServerPrincipalName () )
			{        
				*a_ServerPrincipalName = ( LPWSTR ) CoTaskMemAlloc ( ( wcslen ( m_ThreadSecurityHandle->GetServerPrincipalName () ) + 1 ) * 2 ) ;
				if ( a_ServerPrincipalName )
				{
					StringCchCopyW ( *a_ServerPrincipalName , wcslen ( m_ThreadSecurityHandle->GetServerPrincipalName () ) + 1, m_ThreadSecurityHandle->GetServerPrincipalName () ) ;	
				}
				else
				{
					return E_OUTOFMEMORY ;
				}
			}
		}        

		if ( a_Privileges )
		{
			*a_Privileges = m_ThreadSecurityHandle->GetIdentity () ;  // Documented to point to an internal!!
		}
	}
	else
	{
		return ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CWbemCallSecurity :: ImpersonateClient ()
{
	if ( m_ImpersonationLevel != 0 )
	{
		return S_OK ;
	}
	else
	{
		if ( m_ThreadSecurityHandle )
		{
			if ( m_ThreadSecurityHandle->GetImpersonationLevel () == 0 )
			{
				return ( ERROR_CANT_OPEN_ANONYMOUS | 0x80070000 ) ;
			}

			BOOL t_Status = OpenThreadToken (

				GetCurrentThread () ,
				TOKEN_IMPERSONATE ,
				TRUE ,
				& m_ThreadToken
			) ;

			if ( t_Status == FALSE ) 
			{
				DWORD t_LastError = GetLastError () ;
				if ( ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
				{
				}
				else
				{
					return ( ERROR_ACCESS_DENIED | 0x80070000 ) ;
				}
			}

			t_Status = SetThreadToken ( NULL , m_ThreadSecurityHandle->GetThreadToken () ) ;
			if ( t_Status )
			{
				m_ImpersonationLevel = m_ThreadSecurityHandle->GetImpersonationLevel () ; 

				return S_OK ;
			}
			else
			{
				CloseHandle ( m_ThreadToken ) ;

				m_ThreadToken = NULL ;	
			}
		}
		else
		{
			return ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
		}
	}

    return E_FAIL ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: RevertToSelf ()
{
	if ( m_ImpersonationLevel == 0 )
	{
		return S_OK ;
	}
	else
	{
		if ( m_ThreadSecurityHandle )
		{
			// If here,we are impersonating and can definitely revert.
			// =======================================================

			BOOL t_Status = SetThreadToken ( NULL , m_ThreadToken ) ;
			if ( t_Status == FALSE )
			{
				return ( GetLastError () |  0x80070000 ) ;
			}

			CloseHandle ( m_ThreadToken ) ;

			m_ThreadToken = NULL ;

			m_ImpersonationLevel = 0 ;
		}
		else
		{
			return ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
		}
	}

    return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
BOOL CWbemCallSecurity :: IsImpersonating ()
{
	if ( m_ImpersonationLevel != 0 )
	{
		return TRUE ;
	}

	return FALSE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetThreadSecurity ( 

	WMI_THREAD_SECURITY_ORIGIN a_Origin , 
	_IWmiThreadSecHandle **a_ThreadSecurity
)
{
	HRESULT t_Result = S_OK ;

	BOOL t_ValidOrigin = ( ( a_Origin & WMI_ORIGIN_THREAD ) || ( a_Origin & WMI_ORIGIN_EXISTING ) || ( a_Origin & WMI_ORIGIN_RPC ) ) ;

	if ( a_ThreadSecurity && t_ValidOrigin )
	{
		if ( a_Origin & WMI_ORIGIN_THREAD )
		{
			*a_ThreadSecurity = new CWbemThreadSecurityHandle ( m_Control ) ;
			if ( *a_ThreadSecurity )
			{
				( *a_ThreadSecurity )->AddRef () ;

				( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity )->SetOrigin ( WMI_ORIGIN_THREAD ) ;

				t_Result = ( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity)->CloneThreadContext () ;
				if ( FAILED ( t_Result ) )
				{	
					( *a_ThreadSecurity )->Release () ;
					*a_ThreadSecurity = NULL;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			if ( a_Origin & WMI_ORIGIN_RPC || a_Origin & WMI_ORIGIN_EXISTING )
			{
				// Figure out if the call context is ours or RPCs
				// ==============================================

				IServerSecurity *t_Security = NULL ;
				t_Result = CoGetCallContext ( IID_IServerSecurity , ( void ** ) & t_Security ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemCallSecurity *t_Internal = NULL ;
					if ( SUCCEEDED ( t_Security->QueryInterface ( IID_CWbemCallSecurity , ( void ** ) & t_Internal ) ) )
					{
						
						// This is our own call context --- this must be an in-proc object
						// calling us from our thread.  Behave depending on the flags
						// ===============================================================

						if ( a_Origin & WMI_ORIGIN_EXISTING ) 
						{
							*a_ThreadSecurity = new CWbemThreadSecurityHandle ( *t_Internal->GetThreadSecurityHandle () ) ;
							if ( *a_ThreadSecurity )
							{
								(*a_ThreadSecurity)->AddRef () ;

								t_Result = S_OK ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = WBEM_E_NOT_FOUND ;
						}

						t_Internal->Release () ;
					}
					else
					{
						t_Result = WBEM_E_NOT_FOUND ;
					}

					if ( t_Result == WBEM_E_NOT_FOUND ) 
					{
						if ( a_Origin & WMI_ORIGIN_RPC )
						{
							*a_ThreadSecurity = new CWbemThreadSecurityHandle ( m_Control ) ;
							if ( *a_ThreadSecurity )
							{
								( *a_ThreadSecurity )->AddRef () ;

								t_Result = ( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity)->CloneRpcContext ( 

									t_Security 
								) ;

								if ( SUCCEEDED( t_Result ) )
								{
									( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity) ->SetOrigin ( WMI_ORIGIN_RPC ) ;
								}
								else
								{	
									( *a_ThreadSecurity )->Release ();
									*a_ThreadSecurity = NULL;
								}

							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
					}

					t_Security->Release();
				}
				else
				{
					t_Result = WBEM_E_NOT_FOUND ;
				}

				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					if ( a_Origin & WMI_ORIGIN_THREAD )
					{
						*a_ThreadSecurity = new CWbemThreadSecurityHandle ( m_Control ) ;
						if ( *a_ThreadSecurity )
						{
							( *a_ThreadSecurity )->AddRef () ;

							( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity )->SetOrigin ( WMI_ORIGIN_THREAD ) ;

							t_Result = ( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity)->CloneProcessContext () ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
			}
			else
			{
				if ( a_Origin & WMI_ORIGIN_THREAD )
				{
					*a_ThreadSecurity = new CWbemThreadSecurityHandle ( m_Control ) ;
					if ( *a_ThreadSecurity )
					{
						( *a_ThreadSecurity )->AddRef () ;

						( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity )->SetOrigin ( WMI_ORIGIN_THREAD ) ;

						t_Result = ( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity)->CloneProcessContext () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: SetThreadSecurity ( 

	_IWmiThreadSecHandle *a_ThreadSecurity
)
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadSecurityHandle )
	{
		m_ThreadSecurityHandle->Release () ;
		m_ThreadSecurityHandle = NULL ;
	}

	if ( a_ThreadSecurity ) 
	{
		CWbemThreadSecurityHandle *t_ThreadHandle = NULL ; 
		t_Result = a_ThreadSecurity->QueryInterface ( IID_CWbemThreadSecurityHandle , ( void ** ) & t_ThreadHandle ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			m_ThreadSecurityHandle = t_ThreadHandle ;

			IUnknown *t_Unknown = NULL ;
			IUnknown *t_SwitchUnknown = NULL ;
			t_Result = this->QueryInterface ( IID_IUnknown , ( void **) & t_SwitchUnknown ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = CoSwitchCallContext ( t_SwitchUnknown, & t_Unknown ) ;
		
				t_SwitchUnknown->Release () ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetUser ( 

    ULONG *a_Size ,
    LPWSTR a_Buffer
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_Token = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread() ,
        TOKEN_QUERY,
		TRUE ,
        & t_Token
	) ;

	DWORD t_LastError = GetLastError () ;
	if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
	{
		t_Status = OpenProcessToken (

			GetCurrentProcess() ,
            TOKEN_QUERY,
            & t_Token
		) ;

		if ( ! t_Status )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		if ( ! t_Status ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( t_Status )
	{
		t_Result = :: GetUser ( t_Token , a_Size , a_Buffer ) ;

		CloseHandle ( t_Token ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetUserSid ( 

    ULONG *a_Size ,
    PSID a_Sid
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_Token = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
        TOKEN_QUERY,
		TRUE ,
        & t_Token
	) ;

	DWORD t_LastError = GetLastError () ;
	if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
	{
		t_Status = OpenProcessToken (

			GetCurrentProcess () ,
            TOKEN_QUERY,
            & t_Token
		) ;

		if ( ! t_Status )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		if ( ! t_Status ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( t_Status )
	{
		t_Result = :: GetUserSid ( t_Token , a_Size , a_Sid ) ;

		CloseHandle ( t_Token ) ;
	}

    return t_Result ;
}
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetAuthenticationLuid ( LPVOID a_Luid )
{
	HRESULT t_Result = S_OK ;

	HANDLE t_Token = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
        TOKEN_QUERY,
		TRUE ,
        & t_Token
	) ;

	DWORD t_LastError = GetLastError () ;
	if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
	{
		t_Status = OpenProcessToken (

			GetCurrentProcess () ,
            TOKEN_QUERY,
            & t_Token
		) ;

		if ( ! t_Status )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		if ( ! t_Status ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( t_Status )
	{
		t_Result = :: GetAuthenticationLuid ( t_Token , a_Luid ) ;

		CloseHandle ( t_Token ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetImpersonation ( DWORD *a_Level )
{
	HRESULT t_Result = S_OK ;

	if ( a_Level ) 
	{
		HANDLE t_Token = NULL ;

		BOOL t_Status = OpenThreadToken (

			GetCurrentThread () ,
			TOKEN_QUERY,
			TRUE ,
			& t_Token
		) ;

		DWORD t_LastError = GetLastError () ;
		if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
		{
			*a_Level = 0 ;
		}
		else
		{
			if ( t_Status ) 
			{
				SECURITY_IMPERSONATION_LEVEL t_ImpersonationLevel = SecurityAnonymous ;
				TOKEN_TYPE t_TokenType = TokenImpersonation ;
 
				t_Result = :: GetImpersonationLevel ( 

					t_Token , 
					t_ImpersonationLevel ,
					t_TokenType 		
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					switch ( t_ImpersonationLevel )
					{
						case SecurityAnonymous:
						{
							*a_Level = RPC_C_IMP_LEVEL_ANONYMOUS ;
						}
						break ;
            
						case SecurityIdentification:
						{
							*a_Level = RPC_C_IMP_LEVEL_IDENTIFY ;
						}
						break ;

						case SecurityImpersonation:
						{
							*a_Level = RPC_C_IMP_LEVEL_IMPERSONATE ;
						}
						break ;

						case SecurityDelegation:
						{
							*a_Level = RPC_C_IMP_LEVEL_DELEGATE ;
						}
						break ;

						default:
						{
							*a_Level = 0 ;
						}
						break ;
					}
				}

				CloseHandle ( t_Token ) ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetAuthentication (

	DWORD *a_Level
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Level ) 
	{
		if ( m_ThreadSecurityHandle )
		{
			*a_Level = m_ThreadSecurityHandle->GetAuthenticationLevel () ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemCallSecurity  *CWbemCallSecurity :: New ()
{
	return new CWbemCallSecurity ( NULL ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\aggregator.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "precomp.h"
#include <wbemint.h>
#include <wmiutils.h>
#include <strsafe.h>
#include "Globals.h"
#include "ProvRegDeCoupled.h"
#include "CGlobals.h"
#include "provcache.h"
#include "aggregator.h"
#include "ProvWsvS.h"
#include "ProvWsv.h"
#include "ProvInSk.h"
#include "ProvobSk.h"




/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DCProxyAggr :: DCProxyAggr ( ) : 
	m_ReferenceCount ( 0 ) , 
	m_UnRegistered( -1 ),
	m_Allocator ( *DecoupledProviderSubSystem_Globals :: s_Allocator ),
	CWbemGlobal_IWmiObjectSinkController ( *DecoupledProviderSubSystem_Globals :: s_Allocator ),
	m_Sink(NULL),
	initialized_(false),
	m_Controller(0),
	m_CriticalSection(NOTHROW_LOCK)

{

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DCProxyAggr :: ~DCProxyAggr ()
{
#ifdef _DBG
	if (m_UnRegistered != -1) DebugBreak();
#endif

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	if ( m_Controller )
	{
		CWbemGlobal_IWbemSyncProvider_Container *t_Container = NULL ;
		m_Controller->GetContainer ( t_Container ) ;

		m_Controller->Lock () ;

		CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator = t_Container->Begin () ;
		while ( ! t_Iterator.Null () )
		{
			SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;

			t_Container->Delete ( t_Element->GetKey () ) ;

			m_Controller->UnLock () ;

			t_Element->Release () ;

			m_Controller->Lock () ;

			t_Iterator = t_Container->Begin () ;
		}

		m_Controller->UnLock () ;

		m_Controller->UnInitialize () ;

		m_Controller->Release () ;

	}
}

void DCProxyAggr::activate()
{
	LONG registerCount = InterlockedIncrement(&m_UnRegistered);
	if (registerCount == 0)	// is the first aggregator
		{
		const DC_DBkey key( m_User, m_Locale, m_Namespace, m_ProviderName);
		DC_registrar::instance()->RegisterAggregator(key, auto_ref<DCProxyAggr>(this));	
		}
};

void DCProxyAggr::deActivate()
{
	LONG registerCount = InterlockedDecrement(&m_UnRegistered);
	if (  registerCount < 0 ) DC_registrar::instance()->UnRegisterAggregator (auto_ref<DCProxyAggr>(this));
};


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) DCProxyAggr :: AddRef ( void )
{
	return InterlockedIncrement(&m_ReferenceCount) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) DCProxyAggr :: Release ( void )
{
	LONG t_Reference = InterlockedDecrement(&m_ReferenceCount);
	
	if (  0 == t_Reference )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Reference ;
	}
}

// IWbemServices

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class TInterface, const IID *TInterface_Id>
HRESULT GetProviders (

	IWbemContext *a_Context ,
	CWbemGlobal_IWbemSyncProviderController *a_Controller ,
	TInterface **&a_Elements ,
	ULONG &a_ElementCount ,
	ULONG &a_ContainerCount 
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWbemSyncProvider_Container *t_Container = NULL ;
	WmiStatusCode t_StatusCode = a_Controller->GetContainer ( t_Container ) ;

	a_Controller->Lock () ;

	a_ContainerCount = t_Container->Size () ;

	a_Elements = new TInterface * [ t_Container->Size () ] ;
	if ( a_Elements )
	{
		CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator = t_Container->Begin () ;

		a_ElementCount = 0 ;

		while ( ! t_Iterator.Null () )
		{
			SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;

			a_Elements [ a_ElementCount ] = NULL ;

			_IWmiProviderInitialize *t_Initializer = NULL ;

			t_Result = t_Element->QueryInterface (

				IID__IWmiProviderInitialize	,
				( void ** ) & t_Initializer
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Initializer->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					HRESULT t_Result = t_Element->QueryInterface ( *TInterface_Id , ( void ** ) & a_Elements [ a_ElementCount ] ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						a_ElementCount ++ ;
					}
				}

				t_Initializer->Release () ;
			}

			t_Iterator.Increment () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	a_Controller->UnLock () ;

	return t_Result ;
}
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class TInterface >
HRESULT GetProviders (

	CWbemGlobal_IWbemSyncProviderController *a_Controller ,
	TInterface **&a_Elements ,
	ULONG &a_ElementCount
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWbemSyncProvider_Container *t_Container = NULL ;
	WmiStatusCode t_StatusCode = a_Controller->GetContainer ( t_Container ) ;

	a_Controller->Lock () ;

	a_Elements = new TInterface * [ t_Container->Size () ] ;
	if ( a_Elements )
	{
		CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator = t_Container->Begin () ;

		a_ElementCount = 0 ;

		while ( ! t_Iterator.Null () )
		{
			SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;

			a_Elements [ a_ElementCount ] = NULL ;

			HRESULT t_TempResult = t_Element->QueryInterface ( __uuidof(TInterface) , ( void ** ) & a_Elements [ a_ElementCount ] ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				a_ElementCount ++ ;
			}

			t_Iterator.Increment () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	a_Controller->UnLock () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class TInterface>
HRESULT ClearProviders (

	TInterface **a_Elements ,
	ULONG a_ElementCount
) 
{
	HRESULT t_Result = S_OK ;

	for ( ULONG t_Index = 0 ; t_Index < a_ElementCount ; t_Index ++ )
	{
		a_Elements [ t_Index ]->Release () ;
	}

	delete [] a_Elements ;

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
      

HRESULT DCProxyAggr :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	LPWSTR a_ProviderName,
	IWbemServices *a_CoreService,         // For anybody
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	if ( initialized() )
		return a_Sink->SetStatus ( WBEM_S_NO_ERROR , 0 ) ;
	

	if( !a_Sink)
		return WBEM_E_INVALID_PARAMETER;

	if(!a_CoreService )
		return a_Sink->SetStatus ( WBEM_E_INVALID_PARAMETER , 0 ) ;
	
	m_context = a_Context;
	
	if (m_context == 0)	// Create a default context or the test provider will fail !
		m_context.CreateInstance(CLSID_WbemContext);
	if (m_context == 0)
		return a_Sink->SetStatus ( WBEM_E_OUT_OF_MEMORY , 0 ) ;

	m_CoreService = a_CoreService;
	m_Flags = a_Flags;
	


	try{
		m_User = a_User;
		m_Locale = a_Locale;
		m_Namespace = a_Namespace;
		m_ProviderName = a_ProviderName;
		}
	catch( _com_error& err){
		return a_Sink->SetStatus ( WBEM_E_OUT_OF_MEMORY , 0 ) ;

	}
	
	HRESULT t_Result = S_OK ;
	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}


	t_Result = m_NamespacePath.CreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER);

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = m_NamespacePath->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Namespace ) ;
	}


	if ( SUCCEEDED ( t_Result ) )
	{
		m_Controller = new CWbemGlobal_IWbemSyncProviderController ( m_Allocator ) ;
		if ( m_Controller )
		{
			m_Controller->AddRef () ;

			t_StatusCode = m_Controller->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success ) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	LoadAll();

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr :: CreateSyncProvider ( 

	IUnknown *a_ServerSideProvider ,
	IWbemServices *a_Stub ,
	wchar_t *a_NamespacePath ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	GUID a_Identity ,
	CInterceptor_IWbemDecoupledProvider *&a_Interceptor 
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IWbemDecoupledProvider *t_Interceptor = new CInterceptor_IWbemDecoupledProvider (

		m_Allocator , 
		a_ServerSideProvider ,
		a_Stub ,
		m_Controller , 
		a_Context ,
		a_Registration ,
		a_Identity
	) ;

	if ( t_Interceptor ) 
	{
/*
 *	One for the cache
 */
		t_Interceptor->AddRef () ;

		_IWmiProviderInitialize *t_InterceptorInit = NULL ;

		t_Result = t_Interceptor->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_InterceptorInit ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
			if ( t_ProviderInitSink )
			{
				t_ProviderInitSink->AddRef () ;

				t_Result = t_ProviderInitSink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						t_Result = t_InterceptorInit->Initialize (

							0 ,
							a_Context ,
							NULL ,
							a_Registration.GetComRegistration ().PerUserInitialization () ? ( BSTR ) a_User : NULL ,
							a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( BSTR ) a_Locale : NULL  ,
							a_NamespacePath ,
							NULL ,
							NULL ,
							t_Sink    
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_ProviderInitSink->Wait () ;
							t_Result = t_ProviderInitSink->GetResult () ;
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_ProviderInitSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			t_InterceptorInit->Release () ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Interceptor->AddRef () ;

			CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator ;

			WmiStatusCode t_StatusCode = m_Controller->Insert ( 

				*t_Interceptor ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			m_Controller->UnLock () ;
		}
		else
		{
			m_Controller->UnLock () ;
		}

		t_Interceptor->SetInitialized ( t_Result ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			a_Interceptor = t_Interceptor ;
		}
		else
		{
			t_Interceptor->Release () ;
		}
	}
	else
	{
		m_Controller->UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DCProxyAggr :: Register ( DC_reg& reg, bool validate )
{
	DC_DBkey key( m_User, m_Locale, m_Namespace, m_ProviderName);

	if( !key.equal(reg) )
		return S_OK;

	HRESULT t_Result = S_OK ;
	
	// Check the client pointer
	IUnknown * pUnk = reg.service();
	if (pUnk == 0)
		return WBEM_E_PROVIDER_FAILURE;

	try
	{
		CServerObject_ProviderRegistrationV1 *t_Registration = new CServerObject_ProviderRegistrationV1 ;

		if ( t_Registration )
		{
			t_Registration->AddRef () ;

			t_Result = t_Registration->SetContext ( 

				m_context ,
				m_NamespacePath , 
				m_CoreService
			) ;
			
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Registration->Load ( 

					e_All ,
					m_NamespacePath , 
					reg.GetProvider()
				) ;
                if ( SUCCEEDED ( t_Result ) )
                {
                    if (validate)
                    {
                        t_Result = OS::CoImpersonateClient();
                        if (SUCCEEDED(t_Result))
                        {
                            t_Result = ProviderSubSystem_Common_Globals::ValidateClientSecurity (*t_Registration);
                            CoRevertToSelf();
                        }
                    }
                
				    if ( SUCCEEDED ( t_Result ) )
				    {
					    m_Controller->Lock () ;

					    CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator ;

					    WmiStatusCode t_StatusCode = m_Controller->Find ( reg.identity() , t_Iterator ) ;
    					
    					
					    if ( t_StatusCode != e_StatusCode_Success )
					    {
						    CInterceptor_IWbemServices_Stub *t_Stub = new CInterceptor_IWbemServices_Stub ( m_Allocator , m_CoreService.GetInterfacePtr() ) ;
    						
						    CInterceptor_IWbemDecoupledProvider * t_Provider = NULL;
						    if ( t_Stub )
						    {
							    t_Stub->AddRef () ;


							    CInterceptor_IWbemDecoupledProvider *t_Interceptor = NULL ;


							    t_Result = CreateSyncProvider ( 

								    pUnk ,
								    t_Stub ,
								    reg.GetScope() ,
								    0 ,
								    m_context ,
								    reg.GetUser() ,
								    reg.GetLocale() ,
								    NULL ,
								    *t_Registration ,
								    reg.identity(),
								    t_Interceptor
							    ) ;

							    if ( SUCCEEDED ( t_Result ) )
							    {
								    IUnknown *t_Unknown = NULL ;
								    t_Result = t_Interceptor->QueryInterface ( IID_IUnknown , ( void ** ) & t_Unknown ) ;
								    if ( SUCCEEDED ( t_Result ) )
								    {

								    t_Result = InitializeProvider ( 

									    t_Unknown ,
									    t_Stub ,
									    reg.GetScope() ,
									    m_Flags ,
									    m_context ,
									    reg.GetUser() ,
									    reg.GetLocale() ,
									    NULL ,
									    *t_Registration
								    ) ;


								    if ( SUCCEEDED ( t_Result ) )
								    {
									    if ( m_Sink )
									    {
										    IWbemEventProvider *t_EvProvider = NULL ;

										    t_Result = t_Unknown->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & t_EvProvider ) ;
										    if ( SUCCEEDED ( t_Result ) )
										    {
											    t_Result = t_EvProvider->ProvideEvents ( (IWbemObjectSink *)m_Sink , 0 ) ;

											    t_EvProvider->Release () ;
										    }

										    m_Sink->SetStatus ( 

											    WBEM_STATUS_REQUIREMENTS, 
											    WBEM_REQUIREMENTS_RECHECK_SUBSCRIPTIONS, 
											    NULL, 
											    NULL
										    ) ;
									    }
								    }

								    t_Unknown->Release () ;
								    }

								    t_Interceptor->Release () ;
							    }

							    t_Stub->Release () ;
						    }
						    else
						    {
							    m_Controller->UnLock () ;

							    t_Result = WBEM_E_OUT_OF_MEMORY ;
						    }
					    }
					    else
					    {
		  				    SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;

						    m_Controller->UnLock () ;

						    t_Element->Release () ;
						    t_Result = S_OK ;
					    }
                    }
			    }
            }
	
			t_Registration->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DCProxyAggr :: UnRegister ( GUID a_Identity )
{
	HRESULT t_Result = S_OK ;

	try
	{
		CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator ;

		IWbemShutdown *t_Shutdown = NULL ;

		m_Controller->Lock () ;

		WmiStatusCode t_StatusCode = m_Controller->Find ( a_Identity , t_Iterator ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;			

			t_Result = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;

			m_Controller->Delete ( a_Identity ) ;

			m_Controller->UnLock () ;

			if ( SUCCEEDED ( t_Result ) && t_Shutdown )
			{
				t_Result = t_Shutdown->Shutdown ( 
		
					0 , 
					0 , 
					NULL 
				) ;

				t_Shutdown->Release () ;
			}

/*
 *	One for the find.
 */

			t_Element->Release () ;

/*
 *	Removed reference due the cache.
 */

			t_Element->Release () ;
		}
		else
		{
			m_Controller->UnLock () ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DCProxyAggr :: UnRegister ( const CInterceptor_IWbemDecoupledProvider& provider  )
{
	CInterceptor_IWbemDecoupledProvider& prov = const_cast<CInterceptor_IWbemDecoupledProvider&>(provider);
	return UnRegister(prov.GetKey());
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DCProxyAggr :: InitializeProvider ( 
	IUnknown *a_Unknown ,
	IWbemServices *a_Stub ,
	wchar_t *a_NamespacePath ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
  LPCWSTR a_Scope ,
	CServerObject_ProviderRegistrationV1 &a_Registration
)
{
	HRESULT t_Result = S_OK ;

	IWbemProviderInit *t_ProviderInit = NULL ;
	t_Result = a_Unknown->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_ProviderInit ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
		
		if ( t_ProviderInitSink )
		{
			t_ProviderInitSink->AddRef () ;

			t_Result = t_ProviderInitSink->SinkInitialize (a_Registration.GetComRegistration ().GetSecurityDescriptor ()) ;

			CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				try
				{
					BOOL t_Impersonating = FALSE ;
					IUnknown *t_OldContext = NULL ;
					IServerSecurity *t_OldSecurity = NULL ;

					t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_ProviderInit->Initialize (

							a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
							0 ,
							( const BSTR ) a_NamespacePath ,
							a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
							a_Stub ,
							a_Context ,
							t_Sink    
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_ProviderInitSink->Wait () ;
							t_Result = t_ProviderInitSink->GetResult () ;
						}

						DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
					}
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}
				
				t_Sink->Release();
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
			t_ProviderInitSink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_ProviderInit->Release () ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/



HRESULT DCProxyAggr :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_ObjectGot = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			CInterceptor_IWbemWaitingObjectSink *t_GettingSink = new CInterceptor_IWbemWaitingObjectSink (
                                                        				m_Allocator , 
                                                        				( CWbemGlobal_IWmiObjectSinkController * ) this
                                                        			) ;

			if ( t_GettingSink )
			{
				t_GettingSink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_GettingSink ,
					t_Iterator
				) ;

				UnLock () ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ;

					t_Result = t_Provider->GetObjectAsync ( 
							
						a_ObjectPath , 
						0 , 
						a_Context,
						t_GettingSink
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_GettingSink->Wait ( INFINITE ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_GettingSink->GetResult () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_ObjectGot = TRUE ;
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
							}
						}
					}
					else if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
					{
						t_Result = S_OK ;
					}
					else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) || (t_Result == WBEM_E_TRANSPORT_FAILURE))
					{
						const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
						UnRegister(*last_interceptor);
						t_Result = S_OK ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				WmiQueue <IWbemClassObject *,8> &t_Queue = t_GettingSink->GetQueue () ;

				IWbemClassObject *t_Object = NULL ;
				while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = a_Sink->Indicate ( 1 , & t_Object ) ;
					}

					t_Object->Release () ;
					t_StatusCode = t_Queue.DeQueue () ;
				}

				t_GettingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_ObjectGot == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr :: PutClassAsync ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_ClassPut = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			CInterceptor_IWbemWaitingObjectSink *t_ClassPuttingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_ClassPuttingSink )
			{
				t_ClassPuttingSink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_ClassPuttingSink ,
					t_Iterator
				) ;

				UnLock () ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ;

					t_Result = t_Provider->PutClassAsync ( 
							
						a_Object , 
						a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
						a_Context,
						t_ClassPuttingSink
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_ClassPuttingSink->Wait ( INFINITE ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( SUCCEEDED ( t_ClassPuttingSink->GetResult () ) )
							{
								t_ClassPut = TRUE ;
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
						{
							t_Result = S_OK ;
						}
						else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) || (t_Result == WBEM_E_TRANSPORT_FAILURE))						
						{
							const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
							UnRegister(*last_interceptor);
							t_Result = S_OK ;
						}

					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				WmiQueue <IWbemClassObject *,8> &t_Queue = t_ClassPuttingSink->GetQueue () ;

				IWbemClassObject *t_Object = NULL ;
				while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
				{
					t_Object->Release () ;
					t_StatusCode = t_Queue.DeQueue () ;
				}

				t_ClassPuttingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_ClassPut == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}



/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr :: DeleteClassAsync ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_ClassDeleted = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			CInterceptor_IWbemWaitingObjectSink *t_ClassDeletingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_ClassDeletingSink )
			{
				t_ClassDeletingSink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_ClassDeletingSink ,
					t_Iterator
				) ;

				UnLock () ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ;

					t_Result = t_Provider->DeleteClassAsync ( 
							
						a_Class , 
						a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
						a_Context,
						t_ClassDeletingSink
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_ClassDeletingSink->Wait ( INFINITE ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( SUCCEEDED ( t_ClassDeletingSink->GetResult () ) )
							{
								t_ClassDeleted = TRUE ;
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
						{
							t_Result = S_OK ;
						}
						else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) || (t_Result == WBEM_E_TRANSPORT_FAILURE))
						{
							const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
							UnRegister(*last_interceptor);
							t_Result = S_OK ;
						}
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				WmiQueue <IWbemClassObject *,8> &t_Queue = t_ClassDeletingSink->GetQueue () ;

				IWbemClassObject *t_Object = NULL ;
				while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
				{
					t_Object->Release () ;
					t_StatusCode = t_Queue.DeQueue () ;
				}

				t_ClassDeletingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_ClassDeleted == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE DCProxyAggr :: CreateClassEnumAsync (

	const BSTR a_Superclass , 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
  HRESULT t_Result = S_OK ;
  CInterceptor_DecoupledIWbemCombiningObjectSink *t_CombiningSink = new CInterceptor_DecoupledIWbemCombiningObjectSink (

		m_Allocator ,
		a_Sink , 
		( CWbemGlobal_IWmiObjectSinkController * ) this
	) ;

	if ( t_CombiningSink )
	{
		t_CombiningSink->AddRef () ;

		t_CombiningSink->Suspend () ;

		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Insert ( 

			*t_CombiningSink ,
			t_Iterator
		) ;

		UnLock () ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			IWbemServices **t_Elements = NULL ;
			ULONG t_ElementsCount = 0 ;

			t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_ProviderFound = FALSE ;

				for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
				{
					CInterceptor_DecoupledIWbemObjectSink *t_Sink = new CInterceptor_DecoupledIWbemObjectSink (

						t_CombiningSink , 
						( IWbemObjectSink * ) t_CombiningSink , 
						( CWbemGlobal_IWmiObjectSinkController * ) t_CombiningSink
					) ;

					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						t_Result = t_CombiningSink->EnQueue ( t_Sink ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							IWbemServices *t_Provider = t_Elements [ t_Index ] ; 

							t_Result = t_Provider->CreateClassEnumAsync ( 
									
								a_Superclass , 
								a_Flags, 
								a_Context,
								t_Sink
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
								else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) || (t_Result == WBEM_E_TRANSPORT_FAILURE))
								{
									const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
									UnRegister(*last_interceptor);
									t_Result = S_OK ;
								}

							}
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
			}

			if ( SUCCEEDED ( t_Result ) && t_ElementsCount )
			{
				t_CombiningSink->Resume () ;

				t_Result = t_CombiningSink->Wait ( INFINITE ) ;
			}
			else
			{
				a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_CombiningSink->Release () ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags ,
    IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{

	BOOL t_InstancePut = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			CInterceptor_IWbemWaitingObjectSink *t_InstancePuttingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_InstancePuttingSink )
			{
				t_InstancePuttingSink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_InstancePuttingSink ,
					t_Iterator
				) ;

				UnLock () ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ;

					t_Result = t_Provider->PutInstanceAsync ( 
							
						a_Instance , 
						a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
						a_Context,
						t_InstancePuttingSink
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_InstancePuttingSink->Wait ( INFINITE ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( SUCCEEDED ( t_InstancePuttingSink->GetResult () ) )
							{
								t_InstancePut = TRUE ;
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
						{
							t_Result = S_OK ;
						}
						else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) || (t_Result == WBEM_E_TRANSPORT_FAILURE))
						{
							const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
							UnRegister(*last_interceptor);
							t_Result = S_OK ;
						}

					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				WmiQueue <IWbemClassObject *,8> &t_Queue = t_InstancePuttingSink->GetQueue () ;

				IWbemClassObject *t_Object = NULL ;
				while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
				{
					t_Object->Release () ;
					t_StatusCode = t_Queue.DeQueue () ;
				}

				t_InstancePuttingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_InstancePut == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT DCProxyAggr :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	BOOL t_InstanceDeleted = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			CInterceptor_IWbemWaitingObjectSink *t_InstanceDeletingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_InstanceDeletingSink )
			{
				t_InstanceDeletingSink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_InstanceDeletingSink ,
					t_Iterator
				) ;

				UnLock () ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ;

					t_Result = t_Provider->DeleteInstanceAsync ( 
							
						a_ObjectPath , 
						a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
						a_Context,
						t_InstanceDeletingSink
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_InstanceDeletingSink->Wait ( INFINITE ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( SUCCEEDED ( t_InstanceDeletingSink->GetResult () ) )
							{
								t_InstanceDeleted = TRUE ;
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
						{
							t_Result = S_OK ;
						}
						else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
						{
							const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
							UnRegister(*last_interceptor);
							t_Result = S_OK ;
						}

					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				WmiQueue <IWbemClassObject *,8> &t_Queue = t_InstanceDeletingSink->GetQueue () ;

				IWbemClassObject *t_Object = NULL ;
				while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
				{
					t_Object->Release () ;
					t_StatusCode = t_Queue.DeQueue () ;
				}

				t_InstanceDeletingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_InstanceDeleted == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	CInterceptor_DecoupledIWbemCombiningObjectSink *t_CombiningSink = new CInterceptor_DecoupledIWbemCombiningObjectSink (

		m_Allocator ,
		a_Sink , 
		( CWbemGlobal_IWmiObjectSinkController * ) this
	) ;

	if ( t_CombiningSink )
	{
		t_CombiningSink->AddRef () ;

		t_CombiningSink->Suspend () ;

		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Insert ( 

			*t_CombiningSink ,
			t_Iterator
		) ;

		UnLock () ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			IWbemServices **t_Elements = NULL ;
			ULONG t_ElementsCount = 0 ;

			t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_ProviderFound = FALSE ;

				for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
				{
					CInterceptor_DecoupledIWbemObjectSink *t_Sink = new CInterceptor_DecoupledIWbemObjectSink (

						t_CombiningSink , 
						( IWbemObjectSink * ) t_CombiningSink , 
						( CWbemGlobal_IWmiObjectSinkController * ) t_CombiningSink
					) ;


					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						t_Result = t_CombiningSink->EnQueue ( t_Sink ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							IWbemServices *t_Provider = t_Elements [ t_Index ] ; 

							t_Result = t_Provider->CreateInstanceEnumAsync ( 
									
								a_Class, 
								a_Flags, 
								a_Context,
								t_Sink
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
								else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) || (t_Result == WBEM_E_TRANSPORT_FAILURE))
								{
									const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
									UnRegister(*last_interceptor);
									t_Result = S_OK ;
								}

							}
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
			}

			if ( SUCCEEDED ( t_Result ) && t_ElementsCount )
			{
				t_CombiningSink->Resume () ;

				t_Result = t_CombiningSink->Wait ( INFINITE ) ;
			}
			else
			{
				a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_CombiningSink->Release () ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	CInterceptor_DecoupledIWbemCombiningObjectSink *t_CombiningSink = new CInterceptor_DecoupledIWbemCombiningObjectSink (

		m_Allocator ,
		a_Sink , 
		( CWbemGlobal_IWmiObjectSinkController * ) this
	) ;

	if ( t_CombiningSink )
	{
		t_CombiningSink->AddRef () ;

		t_CombiningSink->Suspend () ;

		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Insert ( 

			*t_CombiningSink ,
			t_Iterator
		) ;

		UnLock () ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			IWbemServices **t_Elements = NULL ;
			ULONG t_ElementsCount = 0 ;

			t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_ProviderFound = FALSE ;

				for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
				{
					CInterceptor_DecoupledIWbemObjectSink *t_Sink = new CInterceptor_DecoupledIWbemObjectSink (

						t_CombiningSink , 
						( IWbemObjectSink * ) t_CombiningSink , 
						( CWbemGlobal_IWmiObjectSinkController * ) t_CombiningSink
					) ;

					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						t_Result = t_CombiningSink->EnQueue ( t_Sink ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							IWbemServices *t_Provider = t_Elements [ t_Index ] ; 

							t_Result = t_Provider->ExecQueryAsync ( 
									
								a_QueryLanguage, 
								a_Query, 
								a_Flags, 
								a_Context,
								t_Sink
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
								else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) || (t_Result == WBEM_E_TRANSPORT_FAILURE))
								{
									const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
									UnRegister(*last_interceptor);
									t_Result = S_OK ;
								}

							}
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
			}

			if ( SUCCEEDED ( t_Result ) && t_ElementsCount )
			{
				t_CombiningSink->Resume () ;

				t_Result = t_CombiningSink->Wait ( INFINITE ) ;
			}
			else
			{
				a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_CombiningSink->Release () ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}



/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{

	BOOL t_MethodCalled = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) &&  !t_MethodCalled ; t_Index ++ )
		{
			CInterceptor_IWbemWaitingObjectSink *t_MethodSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_MethodSink )
			{
				t_MethodSink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_MethodSink ,
					t_Iterator
				) ;

				UnLock () ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ;

					t_Result = t_Provider->ExecMethodAsync ( 
							
						a_ObjectPath,
						a_MethodName,
						a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
						a_Context,
						a_InParams,
						t_MethodSink
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_MethodSink->Wait ( INFINITE ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( SUCCEEDED ( t_MethodSink->GetResult () ) )
							{
								t_MethodCalled = TRUE ;
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
						{
							t_Result = S_OK ;
						}
						else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) || (t_Result == WBEM_E_TRANSPORT_FAILURE))
						{
							const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
							UnRegister(*last_interceptor);
							t_Result = S_OK ;
						}

					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				WmiQueue <IWbemClassObject *,8> &t_Queue = t_MethodSink->GetQueue () ;

				IWbemClassObject *t_Object = NULL ;
				while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
				{
                                        if (SUCCEEDED(t_Result))
                                        {
                                            a_Sink->Indicate ( 1 , & t_Object ) ;
                                        }
					t_Object->Release () ;
					t_StatusCode = t_Queue.DeQueue () ;
				}

				t_MethodSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_MethodCalled == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;


	m_Sink = a_Sink;

	IWbemEventProvider **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	t_Result = GetProviders <IWbemEventProvider> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->ProvideEvents (

 				a_Sink,
				a_Flags
			) ;
			if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) || (t_Result == WBEM_E_TRANSPORT_FAILURE))
				{
				const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Elements [ t_Index ]);
				UnRegister(*last_interceptor);
				t_Result = S_OK ;
				}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventProvider> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}

HRESULT DCProxyAggr ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	HRESULT t_AggregatedResult = S_OK ;

	IWbemEventProviderSecurity **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemEventProviderSecurity,&IID_IWbemEventProviderSecurity> ( NULL , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->AccessCheck (

 				a_QueryLanguage,
				a_Query ,
				a_SidLength ,
				a_Sid
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Result != S_OK )
				{
					t_AggregatedResult = t_Result ;
				}
			}
			else
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) || (t_Result == WBEM_E_TRANSPORT_FAILURE))
				{				
					const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Elements [ t_Index ]);
					UnRegister(*last_interceptor);
					t_Result = S_OK ;
				}
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventProviderSecurity> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{		
		if ( t_ContainerCount )
		{
			if ( t_ElementsCount != t_ContainerCount )
			{
				t_AggregatedResult = WBEM_S_SUBJECT_TO_SDS ;
			}
		}

		t_Result = t_AggregatedResult ;
	}

	return t_Result ;
}
	
HRESULT 
DCProxyAggr::LoadAll ( void )
{
	HRESULT t_Result = S_OK ;

	try
	{
		CServerObject_DecoupledClientRegistration t_Elements ( m_Allocator ) ;
		HRESULT t_TempResult = t_Elements.Load () ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			WmiQueue < CServerObject_DecoupledClientRegistration_Element , 8 > &t_Queue = t_Elements.GetQueue () ;
			
			CServerObject_DecoupledClientRegistration_Element t_Top ;

			WmiStatusCode t_StatusCode ;
			while ( ( t_StatusCode = t_Queue.Top ( t_Top ) ) == e_StatusCode_Success )
			{
				HRESULT t_TempResult = Register( DC_reg (t_Top ), false );
				if (FAILED(t_TempResult) && t_TempResult == WBEM_E_PROVIDER_FAILURE)
				t_Top.Delete(t_Top.GetClsid());
				t_StatusCode = t_Queue.DeQueue () ;
			}
		}
		else
		{
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	initialized_ = true;
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	IWbemEventProviderQuerySink **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	t_Result = GetProviders <IWbemEventProviderQuerySink> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->NewQuery (

 				a_Id,
				a_QueryLanguage ,
				a_Query
			) ;
			if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) || (t_Result == WBEM_E_TRANSPORT_FAILURE))
			{
				const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Elements [ t_Index ]);
				UnRegister(*last_interceptor);
				t_Result = S_OK ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventProviderQuerySink> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr ::CancelQuery (

	unsigned long a_Id
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	IWbemEventProviderQuerySink **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	t_Result = GetProviders <IWbemEventProviderQuerySink> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->CancelQuery ( a_Id ) ;
			
			if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) || (t_Result == WBEM_E_TRANSPORT_FAILURE))
			{
				const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Elements [ t_Index ]);
				UnRegister(*last_interceptor);
				t_Result = S_OK ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventProviderQuerySink> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\classfac.cpp ===
#ifndef __CLASSFACTORY_CPP
#define __CLASSFACTORY_CPP

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ClassFac.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "classfac.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ClassFactoryBase::ClassFactoryBase() : m_ReferenceCount ( 0 )
{
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals::s_CServerClassFactory_ObjectsInProgress);
	InterlockedIncrement(&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ClassFactoryBase:: ~ClassFactoryBase()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress ) ;
	InterlockedDecrement(&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT 
ClassFactoryBase::QueryInterface (REFIID iid, LPVOID FAR *iplpv) 
{
  if (iplpv==0)
    return E_POINTER;
  
  if (iid == IID_IUnknown)
    {
    *iplpv = static_cast<IUnknown*>(this) ;
    }
  else if (iid == IID_IClassFactory)
    {
    *iplpv = static_cast<IClassFactory *>(this);		
    }	
  else
    {
      *iplpv = NULL;
      return E_NOINTERFACE;
    }

  ClassFactoryBase::AddRef () ;
  return S_OK;
  }


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG ClassFactoryBase::AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


ULONG ClassFactoryBase :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CServerClassFactory <Object,ObjectInterface> :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		Object *lpunk = new Object ( );
		if ( lpunk == NULL)
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->Initialize () ;
			if (FAILED(status))
			{
				delete lpunk ;
				return status;
			};
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
			else
			{
			}
		}			
	}

	return status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP ClassFactoryBase:: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

	if ( fLock )
		InterlockedIncrement(&DecoupledProviderSubSystem_Globals :: s_LocksInProgress );
	else
		InterlockedDecrement(&DecoupledProviderSubSystem_Globals :: s_LocksInProgress );

	return S_OK	;
}

#endif __CLASSFACTORY_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\cglobals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <windows.h>
#include <objbase.h>
#include <sddl.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemcli.h>
#include <wbemint.h>
#include <callsec.h>
#include <cominit.h>

#include <BasicTree.h>
#include <Thread.h>
#include <Logging.h>
#include <PSSException.h>
#include <Cache.h>

#include "DateTime.h"
#include "CGlobals.h"

#include <Allocator.cpp>
#include <HelperFuncs.cpp>
#include <Logging.cpp>

#include <Cache.cpp>

#include <CallSec.h>
#include <OS.h>
#include <ssdlhelper.h>
#include "ProvRegInfo.h"
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LPCWSTR ProviderSubSystem_Common_Globals :: s_Wql = L"Wql" ;
LPCWSTR ProviderSubSystem_Common_Globals :: s_Provider = L"Provider" ;

WORD ProviderSubSystem_Common_Globals :: s_System_ACESize = 0 ;
WORD ProviderSubSystem_Common_Globals :: s_LocalService_ACESize = 0 ;
WORD ProviderSubSystem_Common_Globals :: s_NetworkService_ACESize = 0 ;
WORD ProviderSubSystem_Common_Globals :: s_LocalAdmins_ACESize = 0 ;

ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Provider_System_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Provider_LocalService_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Provider_NetworkService_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Provider_LocalAdmins_ACE = NULL ;

ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Token_All_Access_System_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Token_All_Access_LocalService_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Token_All_Access_NetworkService_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Token_All_Access_LocalAdmins_ACE = NULL ;

SECURITY_DESCRIPTOR *ProviderSubSystem_Common_Globals :: s_MethodSecurityDescriptor = NULL ;

ULONG ProviderSubSystem_Common_Globals :: s_TransmitBufferSize = SYNCPROV_BATCH_TRANSMIT_SIZE ;
ULONG ProviderSubSystem_Common_Globals :: s_DefaultStackSize = 0 ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CreateInstance ( 

	const CLSID &a_ReferenceClsid ,
	LPUNKNOWN a_OuterUnknown ,
	const DWORD &a_ClassContext ,
	const UUID &a_ReferenceInterfaceId ,
	void **a_ObjectInterface
)
{
	HRESULT t_Result = S_OK ;

	COAUTHINFO t_AuthenticationInfo ;
	ZeroMemory ( & t_AuthenticationInfo , sizeof ( t_AuthenticationInfo ) ) ;

    t_AuthenticationInfo.dwAuthnSvc = RPC_C_AUTHN_DEFAULT ;
    t_AuthenticationInfo.dwAuthzSvc = RPC_C_AUTHZ_DEFAULT ;
    t_AuthenticationInfo.pwszServerPrincName = NULL ;
    t_AuthenticationInfo.dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
    t_AuthenticationInfo.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE  ;
    t_AuthenticationInfo.dwCapabilities = EOAC_NONE ;
    t_AuthenticationInfo.pAuthIdentityData = NULL ;

	COSERVERINFO t_ServerInfo ;
	ZeroMemory ( & t_ServerInfo , sizeof ( t_ServerInfo ) ) ;

	t_ServerInfo.pwszName = NULL ;
    t_ServerInfo.dwReserved2 = 0 ;
    t_ServerInfo.pAuthInfo = & t_AuthenticationInfo ;

	IClassFactory *t_ClassFactory = NULL ;

	t_Result = CoGetClassObject (

		a_ReferenceClsid ,
		a_ClassContext ,
		& t_ServerInfo ,
		IID_IClassFactory ,
		( void ** )  & t_ClassFactory
	) ;
 
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_ClassFactory->CreateInstance (

			a_OuterUnknown ,
			a_ReferenceInterfaceId ,
			a_ObjectInterface 
		);	

		t_ClassFactory->Release () ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetNamespaceServerPath (

	IWbemPath *a_Namespace ,
	wchar_t *&a_ServerNamespacePath
)
{
	a_ServerNamespacePath = NULL ;

	wchar_t *t_Server = NULL ;
	ULONG t_ServerLength = 0 ;

	HRESULT t_Result = a_Namespace->GetServer (

		& t_ServerLength , 
		t_Server
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Server = new wchar_t [ t_ServerLength + 1 ] ;

		t_Result = a_Namespace->GetServer (

			& t_ServerLength , 
			t_Server
		) ;

		if ( FAILED ( t_Result ) )
		{
			delete [] t_Server ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_NAMESPACE ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		wchar_t *t_ConcatString = NULL ;

		WmiStatusCode t_StatusCode = WmiHelper :: ConcatenateStrings_Wchar ( 

			2 , 
			& t_ConcatString ,
			L"\\\\" ,
			t_Server
		) ;

		delete [] t_Server ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			a_ServerNamespacePath = t_ConcatString ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		ULONG t_NamespaceCount = 0 ;

        t_Result = a_Namespace->GetNamespaceCount (

            & t_NamespaceCount 
		) ;

		if ( t_NamespaceCount )
		{
			for ( ULONG t_Index = 0 ; t_Index < t_NamespaceCount ; t_Index ++ )
			{
				wchar_t *t_Namespace = NULL ;
				ULONG t_NamespaceLength = 0 ;

    			t_Result = a_Namespace->GetNamespaceAt (

					t_Index ,
					& t_NamespaceLength ,
					t_Namespace 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Namespace = new wchar_t [ t_NamespaceLength + 1 ] ;

					if (0 != t_Namespace) 
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
						break;
					}

    				t_Result = a_Namespace->GetNamespaceAt (

						t_Index ,
						& t_NamespaceLength ,
						t_Namespace 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						wchar_t *t_ConcatString = NULL ;

						WmiStatusCode t_StatusCode = WmiHelper :: ConcatenateStrings_Wchar ( 

							3 , 
							& t_ConcatString ,
							a_ServerNamespacePath ,
							L"\\" ,
							t_Namespace
						) ;

						delete [] t_Namespace ;

						if ( t_StatusCode == e_StatusCode_Success )
						{
							delete [] a_ServerNamespacePath ;
							a_ServerNamespacePath = t_ConcatString ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
							break;
							
						}
					}
					else
					{
                                                delete[] t_Namespace;
						t_Result = WBEM_E_CRITICAL_ERROR ;
						break ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_NAMESPACE ;
		}

	}
        if (FAILED(t_Result))
        {
            delete []a_ServerNamespacePath;
        }


    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetNamespacePath (

	IWbemPath *a_Namespace ,
	wchar_t *&a_NamespacePath
)
{
	a_NamespacePath = NULL ;

	ULONG t_NamespaceCount = 0 ;

    HRESULT t_Result = a_Namespace->GetNamespaceCount (

        & t_NamespaceCount 
	) ;

	if ( t_NamespaceCount )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_NamespaceCount ; t_Index ++ )
		{
			wchar_t *t_Namespace = NULL ;
			ULONG t_NamespaceLength = 0 ;

    		t_Result = a_Namespace->GetNamespaceAt (

				t_Index ,
				& t_NamespaceLength ,
				t_Namespace 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Namespace = new wchar_t [ t_NamespaceLength + 1 ] ;

    			t_Result = a_Namespace->GetNamespaceAt (

					t_Index ,
					& t_NamespaceLength ,
					t_Namespace 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					wchar_t *t_ConcatString = NULL ;

					WmiStatusCode t_StatusCode = WmiHelper :: ConcatenateStrings_Wchar ( 

						3 , 
						& t_ConcatString ,
						a_NamespacePath ,
						t_Index ? L"\\" : NULL ,
						t_Namespace
					) ;

					delete [] t_Namespace ;

					if ( t_StatusCode == e_StatusCode_Success )
					{
						delete [] a_NamespacePath ;
						a_NamespacePath = t_ConcatString ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
					break ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
				break ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_NAMESPACE ;
	}

	if ( FAILED ( t_Result ) ) 
	{
		delete [] a_NamespacePath ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetPathText (

	IWbemPath *a_Path ,
	wchar_t *&a_ObjectPath
)
{
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Path->GetText ( 

		0 ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		a_ObjectPath = new wchar_t [ t_ObjectPathLength + 1 ] ;
		if ( a_ObjectPath )
		{
			t_Result = a_Path->GetText ( 

				0 ,
				& t_ObjectPathLength ,
				a_ObjectPath
			) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	_IWmiCallSec *t_CallSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: CreateInstance (

		CLSID__IWbemCallSec ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID__IWmiCallSec ,
		( void ** ) & t_CallSecurity 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: BeginImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating ,
	DWORD *a_AuthenticationLevel
)
{
	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	_IWmiCallSec *t_CallSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: CreateInstance (

		CLSID__IWbemCallSec ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID__IWmiCallSec ,
		( void ** ) & t_CallSecurity 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD | WMI_ORIGIN_EXISTING | WMI_ORIGIN_RPC ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_AuthenticationLevel )
					{
						t_Result = t_ThreadSecurity->GetAuthentication ( a_AuthenticationLevel  ) ;
					}

					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: EndImpersonation (

	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_Impersonating

)
{
	HRESULT t_Result = S_OK ;

	IUnknown *t_NewContext = NULL ;

	t_Result = CoSwitchCallContext ( a_OldContext , & t_NewContext ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_OldContext )
		{
			if ( a_Impersonating )
			{
				IServerSecurity *t_ServerSecurity = NULL ;
				t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_ServerSecurity->ImpersonateClient () ;

					t_ServerSecurity->Release () ;
				}
			}
		}

		if ( a_OldSecurity )
		{
			a_OldSecurity->Release() ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( a_OldContext )
	{ 
        a_OldContext->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetProxy (

	REFIID a_InterfaceId ,
	IUnknown *a_Interface ,
	IUnknown *&a_Proxy 
)
{
	IUnknown *t_Unknown = NULL ;

    HRESULT t_Result = a_Interface->QueryInterface (
	
		a_InterfaceId , 
		( void ** ) & t_Unknown
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
	    IClientSecurity *t_ClientSecurity = NULL ;

		t_Result = a_Interface->QueryInterface (
		
			IID_IClientSecurity , 
			( void ** ) & t_ClientSecurity
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_ClientSecurity->CopyProxy (

				a_Interface ,
				( IUnknown ** ) & a_Proxy
			) ;

			t_ClientSecurity->Release () ;
		}
		else if ( t_Result == E_NOINTERFACE)
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}

		t_Unknown->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetProxy (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface ,
	IUnknown *&a_Proxy 
)
{
	IUnknown *t_Unknown = NULL ;

    HRESULT t_Result = a_Interface->QueryInterface (
	
		a_InterfaceId , 
		( void ** ) & t_Unknown
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
	    IClientSecurity *t_ClientSecurity = NULL ;

		t_Result = a_Interface->QueryInterface (
		
			IID_IClientSecurity , 
			( void ** ) & t_ClientSecurity
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

			WmiStatusCode t_StatusCode = a_Container.Top ( a_Proxy , a_ProxyIndex ) ;
			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				t_StatusCode = a_Container.Reserve ( a_ProxyIndex ) ;
			}
			else
			{
				if ( a_Container.GetCurrentSize () < a_Container.GetTopSize () )
				{
					t_Result = t_ClientSecurity->CopyProxy (

						a_Interface ,
						( IUnknown ** ) & a_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						a_Container.SetCurrentSize ( a_Container.GetCurrentSize () + 1 ) ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

			t_ClientSecurity->Release () ;
		}
		else if (E_NOINTERFACE == t_Result)
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}

		t_Unknown->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetCloaking ( 

	IUnknown *a_Unknown ,
	DWORD a_AuthenticationLevel ,
	DWORD a_ImpersonationLevel
)
{
    IClientSecurity *t_ClientSecurity = NULL ;

    HRESULT t_Result = a_Unknown->QueryInterface (
	
		IID_IClientSecurity , 
		( void ** ) & t_ClientSecurity
	) ;

    if ( SUCCEEDED ( t_Result ) )
    {
		t_Result = t_ClientSecurity->SetBlanket (

			a_Unknown ,
			RPC_C_AUTHN_WINNT ,
			RPC_C_AUTHZ_NONE ,
			NULL ,
			a_AuthenticationLevel ,
			a_ImpersonationLevel ,
			NULL ,
			EOAC_DYNAMIC_CLOAKING
		) ;

		t_ClientSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetCloaking ( 

	IUnknown *a_Unknown
)
{
    IClientSecurity *t_ClientSecurity = NULL ;

    HRESULT t_Result = a_Unknown->QueryInterface (
	
		IID_IClientSecurity , 
		( void ** ) & t_ClientSecurity
	) ;

    if ( SUCCEEDED ( t_Result ) )
    {
		t_Result = t_ClientSecurity->SetBlanket (

			a_Unknown ,
			RPC_C_AUTHN_WINNT ,
			RPC_C_AUTHZ_NONE ,
			NULL ,
			RPC_C_AUTHN_LEVEL_DEFAULT ,
			RPC_C_IMP_LEVEL_DEFAULT ,
			NULL ,
			EOAC_DYNAMIC_CLOAKING
		) ;

		t_ClientSecurity->Release () ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL ProviderSubSystem_Common_Globals :: IsProxy ( IUnknown *a_Unknown )
{
	BOOL t_IsProxy ;

    IClientSecurity *t_ClientSecurity = NULL ;

    HRESULT t_Result = a_Unknown->QueryInterface (
	
		IID_IClientSecurity , 
		( void ** ) & t_ClientSecurity
	) ;

    if ( SUCCEEDED ( t_Result ) )
    {
		t_IsProxy = TRUE ;
		t_ClientSecurity->Release () ;
	}
	else
	{
		t_IsProxy = FALSE ;
	}

	return t_IsProxy ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel ()
{
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;

    HANDLE t_ThreadToken = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread() ,
		TOKEN_QUERY,
		TRUE ,
		&t_ThreadToken
	) ;

    if ( t_Status )
    {
		SECURITY_IMPERSONATION_LEVEL t_Level = SecurityAnonymous ;
		DWORD t_Returned = 0 ;

		t_Status = GetTokenInformation (

			t_ThreadToken ,
			TokenImpersonationLevel ,
			& t_Level ,
			sizeof ( SECURITY_IMPERSONATION_LEVEL ) ,
			& t_Returned
		) ;

		CloseHandle ( t_ThreadToken ) ;

		if ( t_Status == FALSE )
		{
			t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
		}
		else
		{
			switch ( t_Level )
			{
				case SecurityAnonymous:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;

				case SecurityIdentification:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				break ;

				case SecurityImpersonation:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
				}
				break ;

				case SecurityDelegation:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
				}
				break ;

				default:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;
			}
		}
	}
	else
	{
        ULONG t_LastError = GetLastError () ;

        if ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN )
        {
            t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
        }
        else 
		{
			if ( t_LastError == ERROR_CANT_OPEN_ANONYMOUS )
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
			}
			else
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
			}
		}
    }

	return t_ImpersonationLevel ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: EnableAllPrivileges ( HANDLE a_Token )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ReturnedLength = 0 ;

	BOOL t_Status = GetTokenInformation (

		a_Token , 
		TokenPrivileges , 
		NULL , 
		0 , 
		& t_ReturnedLength
	) ;

	UCHAR *t_Buffer = new UCHAR [ t_ReturnedLength ] ;
	if ( t_Buffer )
	{
		t_Status = GetTokenInformation (

			a_Token , 
			TokenPrivileges , 
			t_Buffer , 
			t_ReturnedLength , 
			& t_ReturnedLength
		) ;

		if ( t_Status )
		{
			TOKEN_PRIVILEGES *t_Privileges = ( TOKEN_PRIVILEGES * ) t_Buffer ;
			BOOL bNeedToAdjust = FALSE;
			for ( ULONG t_Index = 0; t_Index < t_Privileges->PrivilegeCount ; t_Index ++ )
			{
				if (!(t_Privileges->Privileges [ t_Index ].Attributes & SE_PRIVILEGE_ENABLED))
				{
    				bNeedToAdjust = TRUE;
				t_Privileges->Privileges [ t_Index ].Attributes |= SE_PRIVILEGE_ENABLED ;
    			}
    		}

            if (bNeedToAdjust)
            {
			t_Status = AdjustTokenPrivileges (

				a_Token, 
				FALSE, 
				t_Privileges , 
				0, 
				NULL, 
				NULL
			) ;
            }

			if ( t_Status == FALSE )
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}
		else
		{
			t_Status = WBEM_E_ACCESS_DENIED ;
		}

		delete [] t_Buffer ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: EnableAllPrivileges ()
{
	HRESULT t_Result = S_OK ;

    HANDLE t_Token = NULL ;

    BOOL t_Status = TRUE ;

	t_Status = OpenThreadToken (

		GetCurrentThread (), 
		TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES ,
		FALSE, 
		&t_Token
	) ;

    if ( t_Status )
	{
		DWORD t_ReturnedLength = 0 ;

		t_Status = GetTokenInformation (

			t_Token , 
			TokenPrivileges , 
			NULL , 
			0 , 
			& t_ReturnedLength
		) ;
    
		UCHAR *t_Buffer = new UCHAR [ t_ReturnedLength ] ;
		if ( t_Buffer )
		{
			t_Status = GetTokenInformation (

				t_Token , 
				TokenPrivileges , 
				t_Buffer , 
				t_ReturnedLength , 
				& t_ReturnedLength
			) ;

			if ( t_Status )
			{
				TOKEN_PRIVILEGES *t_Privileges = ( TOKEN_PRIVILEGES * ) t_Buffer ;
				BOOL bNeedToAdjust = FALSE;
				for ( ULONG t_Index = 0; t_Index < t_Privileges->PrivilegeCount ; t_Index ++ )
				{
				    if (!(t_Privileges->Privileges [ t_Index ].Attributes & SE_PRIVILEGE_ENABLED))
				    {
	    			    t_Privileges->Privileges [ t_Index ].Attributes |= SE_PRIVILEGE_ENABLED ;
					    bNeedToAdjust = TRUE;
	    			}
				}

                if (bNeedToAdjust)
                {
				t_Status = AdjustTokenPrivileges (

					t_Token, 
					FALSE, 
					t_Privileges , 
					0, 
					NULL, 
					NULL
				) ;
				}

				if ( t_Status == FALSE )
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}
			}
			else
			{
				t_Status = WBEM_E_ACCESS_DENIED ;
			}

			delete [] t_Buffer ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		CloseHandle ( t_Token ) ;
	}
	else
	{
		DWORD t_LastError = GetLastError () ;
        t_Result = WBEM_E_ACCESS_DENIED;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState ( 

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_Container , a_ProxyIndex , a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
			}
			else
			{
				t_Result = SetInterfaceSecurity (

					a_Proxy ,
					NULL ,
					NULL ,
					NULL ,
					DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
					RPC_C_IMP_LEVEL_IDENTIFY
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
		if ( FAILED ( t_Result ) )
		{
			RevertProxyState (

				a_Container , 
				a_ProxyIndex ,
				a_Proxy , 
				a_Revert
			) ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	IUnknown *a_Proxy , 
	BOOL a_Revert
)
{
	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

	WmiStatusCode t_StatusCode = a_Container.Return ( a_Proxy , a_ProxyIndex ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Proxy->Release () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: ConstructIdentifyToken_SvcHost (

	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize,
	SECURITY_IMPERSONATION_LEVEL impersonationLevel
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_ThreadToken = NULL ;

	BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& t_ThreadToken
	) ;

	DWORD dummy = 0;
	
	if ( t_Status )
	{
		CoRevertToSelf () ;

		a_Revert = FALSE ;

		SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

		DWORD t_LengthRequested = 0 ;
		DWORD t_LengthReturned = 0 ;

		t_Status = GetKernelObjectSecurity (

			t_ThreadToken ,
			DACL_SECURITY_INFORMATION ,
			& t_SecurityDescriptor ,
			t_LengthRequested ,
			& t_LengthReturned
		) ;

		if ( ( t_Status == FALSE ) && ( GetLastError () == ERROR_INSUFFICIENT_BUFFER ) )
		{
			t_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_LengthReturned ] ;
			if ( t_SecurityDescriptor )
			{
				t_LengthRequested = t_LengthReturned ;

				t_Status = GetKernelObjectSecurity (

					t_ThreadToken ,
					DACL_SECURITY_INFORMATION ,
					t_SecurityDescriptor ,
					t_LengthRequested ,
					& t_LengthReturned
				) ;

				if ( t_LengthRequested != t_LengthReturned )
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		HANDLE t_AdjustedThreadToken = NULL ;

		if ( SUCCEEDED ( t_Result ) )
		{
			PACL t_ExtraDacl = NULL ;

			ACL *t_Dacl = NULL ;
			BOOL t_DaclPresent = FALSE ;
			BOOL t_DaclDefaulted = FALSE ;

			t_Status = GetSecurityDescriptorDacl (

				t_SecurityDescriptor ,
				& t_DaclPresent ,
				& t_Dacl ,
				& t_DaclDefaulted
			) ;

			if ( t_Status )
			{
				ACL_SIZE_INFORMATION t_Size ;

				if ( t_Dacl )
				{
					BOOL t_Status = GetAclInformation (

						t_Dacl ,
						& t_Size ,
						sizeof ( t_Size ) ,
						AclSizeInformation
					);

					if ( t_Status )
					{
						DWORD t_ExtraSize = t_Size.AclBytesInUse + t_Size.AclBytesFree + a_AceSize ;

						t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
						if ( t_ExtraDacl )
						{
							CopyMemory ( t_ExtraDacl , t_Dacl , t_Size.AclBytesInUse + t_Size.AclBytesFree ) ;
							t_ExtraDacl->AclSize = t_ExtraSize ;

							BOOL t_Status = :: AddAce ( t_ExtraDacl , ACL_REVISION, t_Size.AceCount , a_Ace , a_AceSize ) ;
							if ( t_Status )
							{
								SECURITY_DESCRIPTOR t_AdjustedSecurityDescriptor ;

								if ( SUCCEEDED ( t_Result ) )
								{
									BOOL t_Status = InitializeSecurityDescriptor ( & t_AdjustedSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
									if ( t_Status ) 
									{
										t_Status = SetSecurityDescriptorDacl (

											& t_AdjustedSecurityDescriptor ,
											t_DaclPresent ,
											t_ExtraDacl ,
											t_DaclDefaulted
										) ;

										if ( t_Status ) 
										{
											SECURITY_ATTRIBUTES t_SecurityAttributes ;
											t_SecurityAttributes.nLength = GetSecurityDescriptorLength ( & t_AdjustedSecurityDescriptor ) ;
											t_SecurityAttributes.lpSecurityDescriptor = & t_AdjustedSecurityDescriptor ;
											t_SecurityAttributes.bInheritHandle = FALSE ;

											t_Status = DuplicateTokenEx ( 

												t_ThreadToken,
												MAXIMUM_ALLOWED ,//| TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY,
												& t_SecurityAttributes ,
												impersonationLevel ,
												TokenImpersonation ,
												& t_AdjustedThreadToken
											) ;

											if ( t_Status == FALSE )
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}
										}
										else
										{
											t_Result = WBEM_E_CRITICAL_ERROR ;
										}
									}
									else
									{
										t_Result = WBEM_E_UNEXPECTED ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_CRITICAL_ERROR ;
							}

							delete [] ( BYTE * ) t_ExtraDacl ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			HANDLE t_ProcessHandle = OpenProcess (

				PROCESS_DUP_HANDLE,
				FALSE ,
				a_ProcessIdentifier 
			) ;


			if ( t_ProcessHandle )
			{
				t_Status = DuplicateHandle (

					GetCurrentProcess() ,
					t_AdjustedThreadToken ,
					t_ProcessHandle ,
					& a_IdentifyToken ,
					0,
					TRUE ,
					DUPLICATE_SAME_ACCESS 
				) ;

				if ( t_Status )
				{

				}
				else
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}

				CloseHandle ( t_ProcessHandle ) ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}

		if ( t_SecurityDescriptor )
		{
			delete [] ( BYTE * ) t_SecurityDescriptor ; 
		}

		if ( t_AdjustedThreadToken )
		{
			CloseHandle ( t_AdjustedThreadToken ) ;
		}

		CloseHandle ( t_ThreadToken ) ;
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: ConstructIdentifyToken_PrvHost (

	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_ThreadToken = NULL ;

	BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& t_ThreadToken
	) ;
	
	if ( t_Status )
	{
		CoRevertToSelf () ;

		a_Revert = FALSE ;

		SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

		DWORD t_LengthRequested = 0 ;
		DWORD t_LengthReturned = 0 ;

		t_Status = GetKernelObjectSecurity (

			t_ThreadToken ,
			DACL_SECURITY_INFORMATION ,
			& t_SecurityDescriptor ,
			t_LengthRequested ,
			& t_LengthReturned
		) ;

		if ( ( t_Status == FALSE ) && ( GetLastError () == ERROR_INSUFFICIENT_BUFFER ) )
		{
			t_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_LengthReturned ] ;
			if ( t_SecurityDescriptor )
			{
				t_LengthRequested = t_LengthReturned ;

				t_Status = GetKernelObjectSecurity (

					t_ThreadToken ,
					DACL_SECURITY_INFORMATION ,
					t_SecurityDescriptor ,
					t_LengthRequested ,
					& t_LengthReturned
				) ;

				if ( t_LengthRequested != t_LengthReturned )
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			PACL t_ExtraDacl = NULL ;

			ACL *t_Dacl = NULL ;
			BOOL t_DaclPresent = FALSE ;
			BOOL t_DaclDefaulted = FALSE ;

			t_Status = GetSecurityDescriptorDacl (

				t_SecurityDescriptor ,
				& t_DaclPresent ,
				& t_Dacl ,
				& t_DaclDefaulted
			) ;

			if ( t_Status )
			{
				ACL_SIZE_INFORMATION t_Size ;

				if ( t_Dacl )
				{
					BOOL t_Status = GetAclInformation (

						t_Dacl ,
						& t_Size ,
						sizeof ( t_Size ) ,
						AclSizeInformation
					);

					if ( t_Status )
					{
						DWORD t_ExtraSize = t_Size.AclBytesInUse + t_Size.AclBytesFree + a_AceSize ;

						t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
						if ( t_ExtraDacl )
						{
							CopyMemory ( t_ExtraDacl , t_Dacl , t_Size.AclBytesInUse + t_Size.AclBytesFree ) ;
							t_ExtraDacl->AclSize = t_ExtraSize ;

							BOOL t_Status = :: AddAce ( t_ExtraDacl , ACL_REVISION, t_Size.AceCount , a_Ace , a_AceSize ) ;
							if ( t_Status )
							{
								SECURITY_DESCRIPTOR t_AdjustedSecurityDescriptor ;

								if ( SUCCEEDED ( t_Result ) )
								{
									BOOL t_Status = InitializeSecurityDescriptor ( & t_AdjustedSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
									if ( t_Status ) 
									{
										t_Status = SetSecurityDescriptorDacl (

											& t_AdjustedSecurityDescriptor ,
											t_DaclPresent ,
											t_ExtraDacl ,
											t_DaclDefaulted
										) ;

										if ( t_Status ) 
										{
											SECURITY_ATTRIBUTES t_SecurityAttributes ;
											t_SecurityAttributes.nLength = GetSecurityDescriptorLength ( & t_AdjustedSecurityDescriptor ) ;
											t_SecurityAttributes.lpSecurityDescriptor = & t_AdjustedSecurityDescriptor ;
											t_SecurityAttributes.bInheritHandle = FALSE ;

											t_Status = DuplicateTokenEx ( 

												t_ThreadToken,
												DUPLICATE_SAME_ACCESS ,
												& t_SecurityAttributes ,
												( SECURITY_IMPERSONATION_LEVEL ) SecurityIdentification ,
												TokenImpersonation ,
												& a_IdentifyToken
											) ;

											if ( t_Status == FALSE )
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}
										}
										else
										{
											t_Result = WBEM_E_CRITICAL_ERROR ;
										}
									}
									else
									{
										t_Result = WBEM_E_UNEXPECTED ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_CRITICAL_ERROR ;
							}

							delete [] ( BYTE * ) t_ExtraDacl ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( t_SecurityDescriptor )
		{
			delete [] ( BYTE * ) t_SecurityDescriptor ; 
		}

		CloseHandle ( t_ThreadToken ) ;
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}

	return t_Result ;
}


HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

	WmiStatusCode t_StatusCode = a_Container.Return ( a_Proxy , a_ProxyIndex ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Proxy->Release () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState_PrvHost ( 

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_Container , a_ProxyIndex , a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
				a_IdentifyToken = 0 ;
			}
			else
			{
				t_Result = ConstructIdentifyToken_PrvHost (

					a_Revert ,
					a_ProcessIdentifier ,
					a_IdentifyToken ,
					s_Token_All_Access_System_ACE ,
					s_System_ACESize
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SetInterfaceSecurity (

						a_Proxy ,
						NULL ,
						NULL ,
						NULL ,
						DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
						RPC_C_IMP_LEVEL_IDENTIFY
					) ;
				}
			}

			CoRevertToSelf () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

	WmiStatusCode t_StatusCode = a_Container.Return ( a_Proxy , a_ProxyIndex ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Proxy->Release () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	CloseHandle ( a_IdentifyToken ) ;

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost (

	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	HRESULT t_Result = S_OK ;

	a_Proxy->Release () ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState_PrvHost ( 

	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
				a_IdentifyToken = 0 ;
			}
			else
			{
				t_Result = ConstructIdentifyToken_PrvHost (

					a_Revert ,
					a_ProcessIdentifier ,
					a_IdentifyToken ,
					s_Token_All_Access_System_ACE ,
					s_System_ACESize
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SetInterfaceSecurity (

						a_Proxy ,
						NULL ,
						NULL ,
						NULL ,
						DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
						RPC_C_IMP_LEVEL_IDENTIFY
					) ;
				}
			}

			CoRevertToSelf () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost (

	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	HRESULT t_Result = S_OK ;

	a_Proxy->Release () ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	CloseHandle ( a_IdentifyToken ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetCallState ( 

	IUnknown *a_Interface , 
	BOOL &a_Revert
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = S_OK ;
	
	if ( IsProxy ( a_Interface ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			t_Result = EnableAllPrivileges () ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
			else
			{
				CoRevertToSelf () ;

				a_Revert = FALSE ;

				t_Result = WBEM_E_ACCESS_DENIED ;

			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
        }
	}
	else 
	{
		t_Result = WBEM_E_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT ProviderSubSystem_Common_Globals :: RevertCallState (

	BOOL a_Revert
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState ( 

	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
			}
			else
			{
				t_Result = SetInterfaceSecurity (

					a_Proxy ,
					NULL ,
					NULL ,
					NULL ,
					DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
					RPC_C_IMP_LEVEL_IDENTIFY
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
        }
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState ( IUnknown *a_Proxy , BOOL a_Revert )
{
	HRESULT t_Result = S_OK ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	a_Proxy->Release () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Load_DWORD ( HKEY a_Key , LPCWSTR a_Name , DWORD &a_Value )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_DWORD ;
	DWORD t_Data = 0 ;
	DWORD t_DataSize = sizeof ( t_ValueType ) ;

	LONG t_RegResult = OS::RegQueryValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  & t_ValueType ,
	  LPBYTE ( & t_Data ) ,
	  & t_DataSize 
	) ;

	if ( ( t_RegResult == ERROR_SUCCESS ) && ( t_ValueType == REG_DWORD ) )
	{
		a_Value = t_Data ;
	}
	else
	{
		t_Result = ERROR_FILE_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Load_String ( HKEY a_Key , LPCWSTR a_Name , BSTR &a_Value )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	wchar_t *t_Data = NULL ;
	DWORD t_DataSize = 0 ;

	LONG t_RegResult = OS::RegQueryValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  & t_ValueType ,
	  NULL ,
	  & t_DataSize 
	) ;

	if ( ( t_RegResult == ERROR_SUCCESS ) && ( t_ValueType == REG_SZ ) )
	{
		t_Data = new wchar_t [ t_DataSize / sizeof ( wchar_t ) ] ;
		if ( t_Data )
		{
			t_RegResult = OS::RegQueryValueEx (

				a_Key ,
				a_Name ,
				0 ,
				& t_ValueType ,
				LPBYTE ( t_Data ) ,
				& t_DataSize 
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				a_Value = SysAllocString ( t_Data ) ;
				if ( a_Value == NULL )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				delete [] t_Data ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				DWORD t_LastError = GetLastError () ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = ERROR_FILE_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Load_ByteArray ( HKEY a_Key , LPCWSTR a_Name , BYTE *&a_Value , DWORD &a_ValueLength )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_BINARY ;
	BYTE *t_Data = NULL ;
	DWORD t_DataSize = 0 ;

	LONG t_RegResult = OS::RegQueryValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  & t_ValueType ,
	  NULL ,
	  & t_DataSize 
	) ;

	if ( ( t_RegResult == ERROR_SUCCESS ) && ( t_ValueType == REG_BINARY ) )
	{
		t_Data = new BYTE [ t_DataSize ] ;
		if ( t_Data )
		{
			t_RegResult = OS::RegQueryValueEx (

				a_Key ,
				a_Name ,
				0 ,
				& t_ValueType ,
				LPBYTE ( t_Data ) ,
				& t_DataSize 
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				a_Value = t_Data ;
				a_ValueLength = t_DataSize ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = ERROR_FILE_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Save_DWORD ( HKEY a_Key , LPCWSTR a_Name , DWORD a_Value )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_DWORD ;
	DWORD t_DataSize = sizeof ( t_ValueType ) ;

	LONG t_RegResult = OS::RegSetValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  t_ValueType ,
	  LPBYTE ( & a_Value ) ,
	  t_DataSize 
	) ;

	if ( t_RegResult != ERROR_SUCCESS ) 
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Save_String ( HKEY a_Key , LPCWSTR a_Name , BSTR a_Value )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	DWORD t_DataSize = wcslen ( a_Value ) + 1 ;

	LONG t_RegResult = OS::RegSetValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  t_ValueType ,
	  LPBYTE ( a_Value ) ,
	  t_DataSize * sizeof ( wchar_t ) 
	) ;

	if ( t_RegResult != ERROR_SUCCESS ) 
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Save_ByteArray ( HKEY a_Key , LPCWSTR a_Name , BYTE *a_Value , DWORD a_ValueLength )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_BINARY ;

	LONG t_RegResult = OS::RegSetValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  t_ValueType ,
	  LPBYTE ( a_Value ) ,
	  a_ValueLength 
	) ;

	if ( t_RegResult != ERROR_SUCCESS ) 
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: UnMarshalRegistration (

	IUnknown **a_Unknown ,
	BYTE *a_MarshaledProxy ,
	DWORD a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	IStream *t_Stream = NULL ;

	HGLOBAL t_Global = GlobalAlloc (

		GHND ,
		a_MarshaledProxyLength
	) ;

	if ( t_Global ) 
	{
		void *t_Memory = GlobalLock ( t_Global ) ;

		CopyMemory ( t_Memory , a_MarshaledProxy , a_MarshaledProxyLength ) ;

		GlobalUnlock ( t_Global ) ;

		t_Result = CreateStreamOnHGlobal (

			t_Global ,
			TRUE ,
			& t_Stream 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CoUnmarshalInterface (

				t_Stream ,
				IID_IUnknown ,
				( void ** ) a_Unknown
			) ;

			t_Stream->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ; 
	}
	
	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: ReleaseRegistration (

	BYTE *a_MarshaledProxy ,
	DWORD a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	IStream *t_Stream = NULL ;

	HGLOBAL t_Global = GlobalAlloc (

		GHND ,
		a_MarshaledProxyLength
	) ;

	if ( t_Global ) 
	{
		void *t_Memory = GlobalLock ( t_Global ) ;

		CopyMemory ( t_Memory , a_MarshaledProxy , a_MarshaledProxyLength ) ;

		GlobalUnlock ( t_Global ) ;

		t_Result = CreateStreamOnHGlobal (

			t_Global ,
			TRUE ,
			& t_Stream 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CoReleaseMarshalData (

				t_Stream
			) ;

			t_Stream->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ; 
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: MarshalRegistration (

	IUnknown *a_Unknown ,
	BYTE *&a_MarshaledProxy ,
	DWORD &a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	t_Result = CoGetMarshalSizeMax (

		& a_MarshaledProxyLength ,
		IID_IUnknown ,
		a_Unknown ,
		MSHCTX_LOCAL ,
		NULL ,
		MSHLFLAGS_TABLEWEAK
	) ;
 
	if ( SUCCEEDED ( t_Result ) ) 
	{
		IStream *t_Stream = NULL ;

		HGLOBAL t_Global = GlobalAlloc (

			GHND ,
			a_MarshaledProxyLength
		) ;

		if ( t_Global ) 
		{
			t_Result = CreateStreamOnHGlobal (

			  t_Global ,
			  TRUE ,
			  & t_Stream 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = CoMarshalInterface (

					t_Stream ,
					IID_IUnknown ,
					a_Unknown ,
					MSHCTX_LOCAL ,
					NULL ,
					MSHLFLAGS_TABLESTRONG
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					a_MarshaledProxy = new BYTE [ a_MarshaledProxyLength ] ;
					if ( a_MarshaledProxy )
					{
						void *t_Memory = GlobalLock ( t_Global ) ;

						CopyMemory ( a_MarshaledProxy , t_Memory , a_MarshaledProxyLength ) ;

						GlobalUnlock ( t_Global ) ;

					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ; 
					}
				}
			t_Stream->Release();
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ; 
		}
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: IsDependantCall ( IWbemContext *a_ParentContext , IWbemContext *a_ChildContext , BOOL &a_DependantCall )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( a_ParentContext )
	{
		if ( a_ChildContext )
		{
			IWbemCausalityAccess *t_ParentCausality = NULL ;
			t_Result = a_ParentContext->QueryInterface ( IID_IWbemCausalityAccess , ( void ** ) & t_ParentCausality ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemCausalityAccess *t_ChildCausality = NULL ;
				t_Result = a_ChildContext->QueryInterface ( IID_IWbemCausalityAccess , ( void ** ) & t_ChildCausality ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					REQUESTID t_ParentId ;

					t_Result = t_ParentCausality->GetRequestId ( & t_ParentId ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_ChildCausality->IsChildOf ( t_ParentId ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							a_DependantCall = ( t_Result == S_FALSE ) ? FALSE : TRUE ;
						}
					}

					t_ChildCausality->Release () ;		
				}
				else
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}

				t_ParentCausality->Release () ;		
			}
		}
	}

	return S_OK ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Check_SecurityDescriptor_CallIdentity ( 

	SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
	DWORD a_Access , 
	GENERIC_MAPPING *a_Mapping
)
{
	HRESULT t_Result = S_OK ;
	if (!OS::secureOS_)
		return S_OK;

	SECURITY_DESCRIPTOR *t_SecurityDescriptor = a_SecurityDescriptor ? a_SecurityDescriptor : GetMethodSecurityDescriptor ();

	if (t_SecurityDescriptor == NULL) return S_OK;
	
	HANDLE t_Token = NULL ;

	BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		TOKEN_QUERY ,
		TRUE ,
		& t_Token 										
	) ;

	DWORD t_LastError = GetLastError () ;
	if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
	{
		HANDLE t_ProcessToken = NULL ;
		t_Status = OpenProcessToken (

			GetCurrentProcess () ,
			TOKEN_QUERY | TOKEN_DUPLICATE ,
			& t_ProcessToken
		) ;

		if ( t_Status )
		{
			t_Status = ImpersonateLoggedOnUser ( t_ProcessToken ) ;
			if ( t_Status )
			{
				BOOL t_Status = OpenThreadToken (

					GetCurrentThread () ,
					TOKEN_QUERY ,
					TRUE ,
					& t_Token 										
				) ;

				if ( ! t_Status )
				{
					DWORD t_LastError = GetLastError () ;

					t_Result = WBEM_E_ACCESS_DENIED ;
				}

				RevertToSelf () ;
			}
			else
			{
				DWORD t_LastError = GetLastError () ;

				t_Result = WBEM_E_ACCESS_DENIED ;
			}

			CloseHandle ( t_ProcessToken ) ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		if ( ! t_Status ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		DWORD t_Access = 0 ;
		BOOL t_AccessStatus = FALSE ;
		PRIVILEGE_SET *t_PrivilegeSet = NULL ;
		DWORD t_PrivilegeSetSize = 0 ;
	
		MapGenericMask (

			& a_Access ,
			a_Mapping
		) ;

		t_Status = AccessCheck (

			t_SecurityDescriptor ,
			t_Token,
			a_Access ,
			a_Mapping ,
			NULL ,
			& t_PrivilegeSetSize ,
			& t_Access ,
			& t_AccessStatus
		) ;

		if ( t_Status && t_AccessStatus )
		{
		}
		else
		{
			DWORD t_LastError = GetLastError () ;
			if ( t_LastError == ERROR_INSUFFICIENT_BUFFER )
			{
				t_PrivilegeSet = ( PRIVILEGE_SET * ) new BYTE [ t_PrivilegeSetSize ] ;
				if ( t_PrivilegeSet )
				{
					t_Status = AccessCheck (

						t_SecurityDescriptor ,
						t_Token,
						a_Access ,
						a_Mapping ,
						t_PrivilegeSet ,
						& t_PrivilegeSetSize ,
						& t_Access ,
						& t_AccessStatus
					) ;

					if ( t_Status && t_AccessStatus )
					{
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					delete [] ( BYTE * ) t_PrivilegeSet ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED;
			}
		}

		CloseHandle ( t_Token ) ;
	}

	return t_Result ;
}
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: AdjustSecurityDescriptorWithSid ( 

	SID *a_OwnerSid , 
	SID *a_GroupSid , 
	DWORD a_Access ,
	SECURITY_DESCRIPTOR *&a_SecurityDescriptor , 
	SECURITY_DESCRIPTOR *&a_AlteredSecurityDescriptor
)
{
	HRESULT t_Result = S_OK ;

	SECURITY_DESCRIPTOR t_CreatedSecurityDescriptor ;
	SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

	PACL t_Dacl = NULL ;
	PACL t_Sacl = NULL ;
	PSID t_Owner = NULL ;
	PSID t_PrimaryGroup = NULL ;
	SECURITY_DESCRIPTOR *t_AlteredSecurityDescriptor = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_SecurityDescriptor )
		{
			DWORD t_AlteredSecurityDescriptorSize = sizeof ( SECURITY_DESCRIPTOR ) ;
			DWORD t_DaclSize = 0 ;
			DWORD t_SaclSize = 0 ;
			DWORD t_OwnerSize = 0 ;
			DWORD t_PrimaryGroupSize = 0 ;

			BOOL t_Status = MakeAbsoluteSD (

			  a_SecurityDescriptor ,
			  t_AlteredSecurityDescriptor ,
			  & t_AlteredSecurityDescriptorSize ,
			  t_Dacl,
			  & t_DaclSize,
			  t_Sacl,
			  & t_SaclSize,
			  t_Owner,
			  & t_OwnerSize,
			  t_PrimaryGroup,
			  & t_PrimaryGroupSize
			) ;

			if ( ( t_Status == FALSE ) && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
			{
				DWORD t_SidLength = GetLengthSid ( a_OwnerSid ) ;
				DWORD t_ExtraSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

				t_Dacl = ( PACL ) new BYTE [ t_DaclSize + t_ExtraSize ] ;
				t_Sacl = ( PACL ) new BYTE [ t_SaclSize ] ;
				t_Owner = ( PSID ) new BYTE [ t_OwnerSize ] ;
				t_PrimaryGroup = ( PSID ) new BYTE [ t_PrimaryGroupSize ] ;

				t_AlteredSecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_AlteredSecurityDescriptorSize ] ;

				if ( t_AlteredSecurityDescriptor && t_Dacl && t_Sacl && t_Owner && t_PrimaryGroup )
				{
					BOOL t_Status = InitializeSecurityDescriptor ( t_AlteredSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
					if ( t_Status )
					{
						t_Status = MakeAbsoluteSD (

							a_SecurityDescriptor ,
							t_AlteredSecurityDescriptor ,
							& t_AlteredSecurityDescriptorSize ,
							t_Dacl,
							& t_DaclSize,
							t_Sacl,
							& t_SaclSize,
							t_Owner,
							& t_OwnerSize,
							t_PrimaryGroup,
							& t_PrimaryGroupSize
						) ;

						if ( t_Status )
						{
							t_SecurityDescriptor = t_AlteredSecurityDescriptor ;

							if ( t_OwnerSize == 0 )
							{
								t_Status = SetSecurityDescriptorOwner (

									t_SecurityDescriptor ,
									a_OwnerSid ,
									FALSE 
								) ;

								if ( ! t_Status )
								{
									t_Result = WBEM_E_CRITICAL_ERROR ;
								}
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_PrimaryGroupSize == 0 )
								{
									t_Status = SetSecurityDescriptorGroup (

										t_SecurityDescriptor ,
										a_GroupSid ,
										FALSE 
									) ;

									if ( ! t_Status )
									{
										t_Result = WBEM_E_CRITICAL_ERROR ;
									}
								}
							}
						}
						else
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		else
		{
			BOOL t_Status = InitializeSecurityDescriptor ( & t_CreatedSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
			if ( t_Status )
			{
				t_Status = SetSecurityDescriptorOwner (

					& t_CreatedSecurityDescriptor ,
					a_OwnerSid ,
					FALSE 
				) ;

				if ( ! t_Status )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Status = SetSecurityDescriptorGroup (

						& t_CreatedSecurityDescriptor ,
						a_GroupSid ,
						FALSE 
					) ;

					if ( ! t_Status )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			t_SecurityDescriptor = & t_CreatedSecurityDescriptor ;
		}
	}


	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;
	DWORD t_SidLength = GetLengthSid ( a_OwnerSid ) ;

	PACL t_ExtraDacl = NULL ;
	ACCESS_ALLOWED_ACE *t_Ace = NULL ;
	DWORD t_AceSize = 0 ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_AceSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Ace = (ACCESS_ALLOWED_ACE*) new BYTE [ t_AceSize ] ;
		if ( t_Ace )
		{
			CopySid ( t_SidLength, (PSID) & t_Ace->SidStart, a_OwnerSid ) ;
			t_Ace->Mask = a_Access ;
			t_Ace->Header.AceType = 0 ;
			t_Ace->Header.AceFlags = 0 ;
			t_Ace->Header.AceSize = t_AceSize ;

		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ACL_SIZE_INFORMATION t_Size ;

		if ( t_Dacl )
		{
			BOOL t_Status = GetAclInformation (

				t_Dacl ,
				& t_Size ,
				sizeof ( t_Size ) ,
				AclSizeInformation
			);

			if ( t_Status )
			{
				DWORD t_ExtraSize = t_Size.AclBytesInUse + t_Size.AclBytesFree + ( sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ) ;
				t_ExtraSize = t_ExtraSize + s_LocalService_ACESize + s_NetworkService_ACESize + s_System_ACESize + s_LocalAdmins_ACESize ;

				t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
				if ( t_ExtraDacl )
				{
					CopyMemory ( t_ExtraDacl , t_Dacl , t_Size.AclBytesInUse + t_Size.AclBytesFree ) ;
					t_ExtraDacl->AclSize = t_ExtraSize ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		else
		{
			DWORD t_SidLength = GetLengthSid ( a_OwnerSid ) ;
			DWORD t_ExtraSize = sizeof ( ACL ) + ( sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ) ;
			t_ExtraSize = t_ExtraSize + s_LocalService_ACESize + s_NetworkService_ACESize + s_System_ACESize + s_LocalAdmins_ACESize ;

			t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
			if ( t_ExtraDacl )
			{
				BOOL t_Status = InitializeAcl (

					t_ExtraDacl ,
					t_ExtraSize ,
					ACL_REVISION 
				) ;

				if ( t_Status )
				{
					BOOL t_Status = GetAclInformation (

						t_ExtraDacl ,
						& t_Size ,
						sizeof ( t_Size ) ,
						AclSizeInformation
					);

					if ( ! t_Status )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		DWORD t_AceIndex = 0 ;

		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Status = :: AddAce ( t_ExtraDacl , ACL_REVISION, t_Size.AceCount , t_Ace , t_AceSize ) ;
			if ( t_Status )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( s_System_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , s_Provider_System_ACE , s_System_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( s_LocalService_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , s_Provider_LocalService_ACE , s_LocalService_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( s_NetworkService_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , s_Provider_NetworkService_ACE , s_NetworkService_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}			

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( s_LocalAdmins_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , s_Provider_LocalAdmins_ACE , s_LocalAdmins_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}			


		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Status = SetSecurityDescriptorDacl (

				  t_SecurityDescriptor ,
				  TRUE ,
				  t_ExtraDacl ,
				  FALSE 
			) ;

			if ( t_Status )
			{
				DWORD t_FinalLength = 0 ;

				t_Status = MakeSelfRelativeSD (

					t_SecurityDescriptor ,
					a_AlteredSecurityDescriptor ,
					& t_FinalLength 
				) ;

				if ( t_Status == FALSE && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
				{
					a_AlteredSecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_FinalLength ] ;
					if ( a_AlteredSecurityDescriptor )
					{
						t_Status = MakeSelfRelativeSD (

							t_SecurityDescriptor ,
							a_AlteredSecurityDescriptor ,
							& t_FinalLength 
						) ;

						if ( t_Status == FALSE )
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;									
					}
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		delete [] t_Ace ;
		delete [] t_ExtraDacl ;
	}

	delete [] ( BYTE * ) t_Dacl ;
	delete [] ( BYTE * ) t_Sacl ;
	delete [] ( BYTE * ) t_Owner ;
	delete [] ( BYTE * ) t_PrimaryGroup ;
	delete [] ( BYTE * ) t_AlteredSecurityDescriptor ;

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CreateSystemAces ()
{
	HRESULT t_Result = S_OK ;

	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

	PSID t_System_Sid = NULL ;
	PSID t_LocalService_Sid = NULL ;
	PSID t_NetworkService_Sid = NULL ;
	PSID t_LocalAdmins_Sid = NULL ;

	BOOL t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_LOCAL_SYSTEM_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_System_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
		s_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

		s_Provider_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_System_ACESize ] ;
		if ( s_Provider_System_ACE )
		{
			CopySid ( t_SidLength, (PSID) & s_Provider_System_ACE->SidStart, t_System_Sid ) ;
			s_Provider_System_ACE->Mask =  MASK_PROVIDER_BINDING_BIND  ;
			s_Provider_System_ACE->Header.AceType = 0 ;
			s_Provider_System_ACE->Header.AceFlags = 3 ;
			s_Provider_System_ACE->Header.AceSize = s_System_ACESize ;

			s_Token_All_Access_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_System_ACESize ] ;
			if ( s_Token_All_Access_System_ACE )
			{
				CopySid ( t_SidLength, (PSID) & s_Token_All_Access_System_ACE->SidStart, t_System_Sid ) ;
				s_Token_All_Access_System_ACE->Mask = TOKEN_ALL_ACCESS ;
				s_Token_All_Access_System_ACE->Header.AceType = 0 ;
				s_Token_All_Access_System_ACE->Header.AceFlags = 3 ;
				s_Token_All_Access_System_ACE->Header.AceSize = s_System_ACESize ;
			}
			else
			{
				t_Result = E_OUTOFMEMORY ;
			}
		}
		else
		{
			t_Result = E_OUTOFMEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = E_OUTOFMEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			1 ,
			SECURITY_LOCAL_SERVICE_RID,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_LocalService_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_LocalService_Sid );
			s_LocalService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

			s_Provider_LocalService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_LocalService_ACESize ] ;
			if ( s_Provider_LocalService_ACE )
			{
				CopySid ( t_SidLength, (PSID) & s_Provider_LocalService_ACE->SidStart, t_LocalService_Sid ) ;
				s_Provider_LocalService_ACE->Mask =  MASK_PROVIDER_BINDING_BIND ;
				s_Provider_LocalService_ACE->Header.AceType = 0 ;
				s_Provider_LocalService_ACE->Header.AceFlags = 3 ;
				s_Provider_LocalService_ACE->Header.AceSize = s_LocalService_ACESize ;

				s_Token_All_Access_LocalService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_LocalService_ACESize ] ;
				if ( s_Token_All_Access_LocalService_ACE )
				{
					CopySid ( t_SidLength, (PSID) & s_Token_All_Access_LocalService_ACE->SidStart, t_LocalService_Sid ) ;
					s_Token_All_Access_LocalService_ACE->Mask =  TOKEN_ALL_ACCESS ;
					s_Token_All_Access_LocalService_ACE->Header.AceType = 0 ;
					s_Token_All_Access_LocalService_ACE->Header.AceFlags = 3 ;
					s_Token_All_Access_LocalService_ACE->Header.AceSize = s_LocalService_ACESize ;
				}
				else
				{
					t_Result = E_OUTOFMEMORY ;
				}
			}
			else
			{
				t_Result = E_OUTOFMEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = E_OUTOFMEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			1 ,
			SECURITY_NETWORK_SERVICE_RID,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_NetworkService_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_NetworkService_Sid );
			s_NetworkService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

			s_Provider_NetworkService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_NetworkService_ACESize ] ;
			if ( s_Provider_NetworkService_ACE )
			{
				CopySid ( t_SidLength, (PSID) & s_Provider_NetworkService_ACE->SidStart, t_NetworkService_Sid ) ;
				s_Provider_NetworkService_ACE->Mask =  MASK_PROVIDER_BINDING_BIND ;
				s_Provider_NetworkService_ACE->Header.AceType = 0 ;
				s_Provider_NetworkService_ACE->Header.AceFlags = 3 ;
				s_Provider_NetworkService_ACE->Header.AceSize = s_NetworkService_ACESize ;

				s_Token_All_Access_NetworkService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_NetworkService_ACESize ] ;
				if ( s_Token_All_Access_NetworkService_ACE )
				{
					CopySid ( t_SidLength, (PSID) & s_Token_All_Access_NetworkService_ACE->SidStart, t_NetworkService_Sid ) ;
					s_Token_All_Access_NetworkService_ACE->Mask =  TOKEN_ALL_ACCESS ;
					s_Token_All_Access_NetworkService_ACE->Header.AceType = 0 ;
					s_Token_All_Access_NetworkService_ACE->Header.AceFlags = 3 ;
					s_Token_All_Access_NetworkService_ACE->Header.AceSize = s_NetworkService_ACESize ;
				}
				else
				{
					t_Result = E_OUTOFMEMORY ;
				}

			}
			else
			{
				t_Result = E_OUTOFMEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = E_OUTOFMEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			2 ,
			SECURITY_BUILTIN_DOMAIN_RID ,
			DOMAIN_ALIAS_RID_ADMINS ,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_LocalAdmins_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_LocalAdmins_Sid );
			s_LocalAdmins_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

			s_Provider_LocalAdmins_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_LocalAdmins_ACESize ] ;
			if ( s_Provider_LocalAdmins_ACE )
			{
				CopySid ( t_SidLength, (PSID) & s_Provider_LocalAdmins_ACE->SidStart, t_LocalAdmins_Sid ) ;
				s_Provider_LocalAdmins_ACE->Mask =  MASK_PROVIDER_BINDING_BIND ;
				s_Provider_LocalAdmins_ACE->Header.AceType = 0 ;
				s_Provider_LocalAdmins_ACE->Header.AceFlags = 3 ;
				s_Provider_LocalAdmins_ACE->Header.AceSize = s_LocalAdmins_ACESize ;

				s_Token_All_Access_LocalAdmins_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_LocalAdmins_ACESize ] ;
				if ( s_Token_All_Access_LocalAdmins_ACE )
				{
					CopySid ( t_SidLength, (PSID) & s_Token_All_Access_LocalAdmins_ACE->SidStart, t_LocalAdmins_Sid ) ;
					s_Token_All_Access_LocalAdmins_ACE->Mask =  TOKEN_ALL_ACCESS ;
					s_Token_All_Access_LocalAdmins_ACE->Header.AceType = 0 ;
					s_Token_All_Access_LocalAdmins_ACE->Header.AceFlags = 3 ;
					s_Token_All_Access_LocalAdmins_ACE->Header.AceSize = s_LocalAdmins_ACESize ;
				}
				else
				{
					t_Result = E_OUTOFMEMORY ;
				}

			}
			else
			{
				t_Result = E_OUTOFMEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = E_OUTOFMEMORY ;
		}
	}

	if ( t_LocalAdmins_Sid )
	{
		FreeSid ( t_LocalAdmins_Sid ) ;
	}

	if ( t_System_Sid )
	{
		FreeSid ( t_System_Sid ) ;
	}

	if ( t_LocalService_Sid )
	{
		FreeSid ( t_LocalService_Sid ) ;
	}

	if ( t_NetworkService_Sid )
	{
		FreeSid ( t_NetworkService_Sid ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: DeleteSystemAces ()
{
	if ( s_Provider_System_ACE )
	{
		delete [] ( ( BYTE * ) s_Provider_System_ACE ) ;
		s_Provider_System_ACE = NULL;
	}

	if ( s_Provider_LocalService_ACE )
	{
		delete [] ( ( BYTE * ) s_Provider_LocalService_ACE ) ;
		s_Provider_LocalService_ACE = NULL;
	}

	if ( s_Provider_NetworkService_ACE )
	{
		delete [] ( ( BYTE * ) s_Provider_NetworkService_ACE ) ;
		s_Provider_NetworkService_ACE = NULL;
	}

	if ( s_Provider_LocalAdmins_ACE )
	{
		delete [] ( ( BYTE * ) s_Provider_LocalAdmins_ACE ) ;
		s_Provider_LocalAdmins_ACE = NULL;
	}

	if ( s_Token_All_Access_System_ACE )
	{
		delete [] ( ( BYTE * ) s_Token_All_Access_System_ACE ) ;
		s_Token_All_Access_System_ACE = NULL;
	}

	if ( s_Token_All_Access_LocalService_ACE )
	{
		delete [] ( ( BYTE * ) s_Token_All_Access_LocalService_ACE ) ;
		s_Token_All_Access_LocalService_ACE  = NULL;
	}

	if ( s_Token_All_Access_NetworkService_ACE )
	{
		delete [] ( ( BYTE * ) s_Token_All_Access_NetworkService_ACE ) ;
		s_Token_All_Access_NetworkService_ACE = NULL;
	}

	if ( s_Token_All_Access_LocalAdmins_ACE )
	{
		delete [] ( ( BYTE * ) s_Token_All_Access_LocalAdmins_ACE ) ;
		s_Token_All_Access_LocalAdmins_ACE = NULL;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CheckAccess ( 

	SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
	DWORD a_Access , 
	GENERIC_MAPPING *a_Mapping
)
{
	HRESULT t_Result = S_OK ;

	if ( a_SecurityDescriptor )	
	{
		t_Result = CoImpersonateClient () ;
		if ( SUCCEEDED ( t_Result ) || t_Result == RPC_E_CALL_COMPLETE )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Check_SecurityDescriptor_CallIdentity (

				a_SecurityDescriptor , 
				a_Access ,
				a_Mapping
			) ;

			CoRevertToSelf () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetUserSid (

	HANDLE a_Token ,
	ULONG *a_Size ,
	PSID &a_Sid
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

    if ( a_Token )
	{
		if ( a_Size ) 
		{
			TOKEN_USER *t_TokenUser = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenUser ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						t_TokenUser = ( TOKEN_USER * ) new BYTE [ t_ReturnLength ] ;
						if ( t_TokenUser )
						{
							t_TokenStatus = GetTokenInformation (

								a_Token ,
								t_TokenInformationClass ,
								t_TokenUser ,
								t_ReturnLength ,
								& t_ReturnLength
							) ;

							if ( t_TokenStatus )
							{
								DWORD t_SidLength = GetLengthSid ( t_TokenUser->User.Sid ) ;
								*a_Size = t_SidLength ;

								a_Sid = new BYTE [ t_SidLength ] ;
								if ( a_Sid )
								{
									CopyMemory ( a_Sid , t_TokenUser->User.Sid , t_SidLength ) ;

									t_Result = S_OK ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							delete [] t_TokenUser ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetGroupSid (

	HANDLE a_Token ,
	ULONG *a_Size ,
	PSID &a_Sid
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

    if ( a_Token )
	{
		if ( a_Size ) 
		{
			TOKEN_PRIMARY_GROUP *t_TokenGroup = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenPrimaryGroup ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenGroup ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						t_TokenGroup = ( TOKEN_PRIMARY_GROUP * ) new BYTE [ t_ReturnLength ] ;
						if ( t_TokenGroup )
						{
							t_TokenStatus = GetTokenInformation (

								a_Token ,
								t_TokenInformationClass ,
								t_TokenGroup ,
								t_ReturnLength ,
								& t_ReturnLength
							) ;

							if ( t_TokenStatus )
							{
								DWORD t_SidLength = GetLengthSid ( t_TokenGroup->PrimaryGroup ) ;
								*a_Size = t_SidLength ;

								a_Sid = new BYTE [ t_SidLength ] ;
								if ( a_Sid )
								{
									CopyMemory ( a_Sid , t_TokenGroup->PrimaryGroup , t_SidLength ) ;

									t_Result = S_OK ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							delete [] t_TokenGroup ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SinkAccessInitialize (

	SECURITY_DESCRIPTOR *a_RegistrationSecurityDescriptor ,
	SECURITY_DESCRIPTOR *&a_SinkSecurityDescriptor
)
{
	HRESULT t_Result = CoImpersonateClient () ;
	HANDLE t_Token = NULL ;
	BOOL t_Status = FALSE;

	if ( SUCCEEDED ( t_Result ) ) 
	{
		
		t_Status = OpenThreadToken (
			GetCurrentThread () ,
			TOKEN_QUERY,
			TRUE ,
			&t_Token
		) ;

		CoRevertToSelf () ;
        if (!t_Status)
        {
			t_Result = WBEM_E_ACCESS_DENIED;
        }
    }
    else if ( t_Result == RPC_E_CALL_COMPLETE )
    {
    	t_Status = OpenProcessToken(

            	GetCurrentProcess () ,
			TOKEN_QUERY ,
		&t_Token
	);

	if ( !t_Status )
	{
		t_Result = WBEM_E_ACCESS_DENIED;
	}
    }
		if ( t_Status )
		{
			DWORD t_OwnerSize = 0 ; 
			PSID t_OwnerSid = NULL ;
			BOOL t_OwnerDefaulted = FALSE ;

			t_Result = GetUserSid (

				t_Token ,
				& t_OwnerSize , 
				t_OwnerSid 
			) ; 

			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_GroupSize = 0 ; 
				PSID t_GroupSid = NULL ;
				BOOL t_GroupDefaulted = FALSE ;

				t_Result = GetGroupSid (

					t_Token ,
					& t_GroupSize , 
					t_GroupSid 
				) ; 

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: AdjustSecurityDescriptorWithSid ( 

						( SID * ) t_OwnerSid ,
						( SID * ) t_GroupSid ,
						MASK_PROVIDER_BINDING_BIND ,
						a_RegistrationSecurityDescriptor , 
						a_SinkSecurityDescriptor
					) ;

					delete [] ( BYTE * ) t_GroupSid ;
				}

				delete [] ( BYTE * ) t_OwnerSid ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			CloseHandle ( t_Token ) ;
		}

	return t_Result ;
}

HRESULT ProviderSubSystem_Common_Globals :: ValidateClientSecurity (
        CServerObject_ProviderRegistrationV1& t_Registration) 
{
	HRESULT t_Result = S_OK ;
	if (!OS::secureOS_)
		return S_OK;


	SECURITY_DESCRIPTOR *t_SecurityDescriptor = t_Registration.GetComRegistration ().GetSecurityDescriptor () ;
	t_Result = ProviderSubSystem_Common_Globals :: Check_SecurityDescriptor_CallIdentity (
			t_SecurityDescriptor , 
			MASK_PROVIDER_BINDING_BIND ,
			& g_ProviderBindingMapping
		) ;
	return t_Result ;
}

/*
DWORD defultDecoupledSD[] = 
{0x80040001,0x00000070 ,0x00000080 ,0x00000000,
0x00000014 ,0x005c0002 ,0x00000004 ,0x00180000,
0x10000001 ,0x00000201 ,0x05000000 ,0x00000020,
0x00000220 ,0x00140000 ,0x10000001 ,0x00000101,
0x05000000 ,0x00000012 ,0x00140000 ,0x10000001,
0x00000101 ,0x05000000 ,0x00000003 ,0x00140000,
0x10000001 ,0x00000101 ,0x05000000 ,0x00000006,
0x00000201 ,0x05000000 ,0x00000020 ,0x00000220,
0x00000201 ,0x05000000 ,0x00000020 ,0x00000220};
*/

HRESULT ProviderSubSystem_Common_Globals :: CreateMethodSecurityDescriptor ()
{
	HRESULT t_Result = S_OK ;

	if (SDDL::hasSDDLSupport())
	{
		BOOL t_Status = SDDL::ConvertStringSecurityDescriptorToSecurityDescriptor (

			L"O:BAG:BAD:(A;;0x10000001;;;BA)(A;;0x10000001;;;SY)(A;;0x10000001;;;LA)"
			L"(A;;0x10000001;;;S-1-5-3) (A;;0x10000001;;;S-1-5-6)",
			SDDL_REVISION_1 ,
			( PSECURITY_DESCRIPTOR * ) & s_MethodSecurityDescriptor ,
			NULL 
		) ;
		if ( t_Status )
		{
		}
		else
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}			

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: DeleteMethodSecurityDescriptor ()
{
	if ( s_MethodSecurityDescriptor	)
	{
		LocalFree ( s_MethodSecurityDescriptor ) ;
		s_MethodSecurityDescriptor = NULL;
	}
	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\datetime.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  DATETIME.CPP
//
//  alanbos  20-Jan-00   Created.
//
//  Defines the implementation of ISWbemDateTime
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <sys/timeb.h>
#include <math.h>
#include <time.h> 
#include <float.h>
#include <wbemint.h>
#include "DateTime.h"


#define ISWILD(c)		(L'*' == c)
#define ISINTERVAL(c)	(L':' == c)
#define ISMINUS(c)		(L'-' == c)
#define ISPLUS(c)		(L'+' == c)
#define	ISDOT(c)		(L'.' == c)

#define	WILD2			L"**"
#define	WILD3			L"***"
#define	WILD4			L"****"
#define	WILD6			L"******"

#define ASSERT_BREAK 

//***************************************************************************
//
//  CWbemDateTime::CWbemDateTime
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CWbemDateTime::CWbemDateTime() :
		m_bYearSpecified (VARIANT_TRUE),
		m_bMonthSpecified (VARIANT_TRUE),
		m_bDaySpecified (VARIANT_TRUE),
		m_bHoursSpecified (VARIANT_TRUE),
		m_bMinutesSpecified (VARIANT_TRUE),
		m_bSecondsSpecified (VARIANT_TRUE),
		m_bMicrosecondsSpecified (VARIANT_TRUE),
		m_bUTCSpecified (VARIANT_TRUE),
		m_bIsInterval (VARIANT_FALSE),
		m_iYear (0),
		m_iMonth (1),
		m_iDay (1),
		m_iHours (0),
		m_iMinutes (0),
		m_iSeconds (0),
		m_iMicroseconds (0),
		m_iUTC (0)
{
}

//***************************************************************************
//
//  CWbemDateTime::~CWbemDateTime
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CWbemDateTime::~CWbemDateTime(void)
{
}

//***************************************************************************
//
//  SCODE CWbemDateTime::get_Value
//
//  DESCRIPTION:
//
//  Retrieve the DMTF datetime value
//
//  PARAMETERS:
//
//		pbsValue		pointer to BSTR to hold value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
HRESULT CWbemDateTime :: GetValue ( BSTR *pbsValue) 
{
	HRESULT hr = WBEM_E_FAILED;

	if (NULL == pbsValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		wchar_t	dmtfValue [WBEMDT_DMTF_LEN + 1];
		int dmtfLength = sizeof dmtfValue / sizeof dmtfValue[0];
		dmtfValue [WBEMDT_DMTF_LEN] = NULL;

		if (m_bIsInterval)
		{
			// Intervals are easy
			hr = StringCchPrintf (dmtfValue, dmtfLength , L"%08d%02d%02d%02d.%06d:000", m_iDay, 
						m_iHours, m_iMinutes, m_iSeconds, m_iMicroseconds);
		}
		else
		{
			if (m_bYearSpecified)
				hr = StringCchPrintf(dmtfValue, dmtfLength , L"%04d", m_iYear);
			else
				hr = StringCchCopyW (dmtfValue, dmtfLength, WILD4);

			if (m_bMonthSpecified)
				hr = StringCchPrintf (dmtfValue + 4, dmtfLength-4, L"%02d", m_iMonth);
			else
				hr = StringCchCatW (dmtfValue + 4, dmtfLength-4, WILD2);

			if (m_bDaySpecified)
				hr = StringCchPrintf (dmtfValue + 6, dmtfLength-6, L"%02d", m_iDay);
			else
				hr = StringCchCatW (dmtfValue + 6, dmtfLength-6, WILD2);

			if (m_bHoursSpecified)
				hr = StringCchPrintf (dmtfValue + 8, dmtfLength-8, L"%02d", m_iHours);
			else
				hr = StringCchCatW (dmtfValue + 8, dmtfLength-8, WILD2);

			if (m_bMinutesSpecified)
				hr = StringCchPrintf (dmtfValue + 10, dmtfLength - 10, L"%02d", m_iMinutes);
			else
				hr = StringCchCatW (dmtfValue + 10, dmtfLength-10, WILD2);

			if (m_bSecondsSpecified)
				hr = StringCchPrintf (dmtfValue + 12, dmtfLength-12, L"%02d.", m_iSeconds);
			else
			{
				hr = StringCchCatW (dmtfValue + 12, dmtfLength-12, WILD2);
				hr = StringCchCatW (dmtfValue + 14, dmtfLength-14, L".");
			}

			if (m_bMicrosecondsSpecified)
				hr = StringCchPrintf (dmtfValue + 15, dmtfLength - 15, L"%06d", m_iMicroseconds);
			else
				hr = StringCchCatW (dmtfValue + 15, dmtfLength-15, WILD6);

			if (m_bUTCSpecified)
				hr = StringCchPrintf (dmtfValue + 21, dmtfLength-21, L"%C%03d", (0 <= m_iUTC) ? L'+' : L'-', 
							(0 <= m_iUTC) ? m_iUTC : -m_iUTC);
			else
			{
				hr = StringCchCatW (dmtfValue + 21, dmtfLength-21, L"+");
				hr = StringCchCatW (dmtfValue + 22, dmtfLength-22, WILD3);
			}
		}
		if (SUCCEEDED(hr))
		{
			*pbsValue = SysAllocString (dmtfValue);
			if ( *pbsValue == NULL )
			{
				hr = WBEM_E_OUT_OF_MEMORY ;
			}
			else
			{
				hr = WBEM_S_NO_ERROR;
			}
		}
	}
	return hr;
}


//***************************************************************************
//
//  SCODE CWbemDateTime::put_Value
//
//  DESCRIPTION:
//
//  Retrieve the DMTF datetime value
//
//  PARAMETERS:
//
//		bsValue		new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemDateTime::PutValue( BSTR bsValue) 
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;

	// First check that the value is the right length
	if (bsValue && (WBEMDT_DMTF_LEN == wcslen (bsValue)))
	{
		bool err = false;
		long iYear = 0, iMonth = 1, iDay = 1, iHours = 0, iMinutes = 0, 
		iSeconds = 0, iMicroseconds = 0, iUTC = 0;
		VARIANT_BOOL bYearSpecified = VARIANT_TRUE, 
		bMonthSpecified = VARIANT_TRUE, 
		bDaySpecified = VARIANT_TRUE, 
		bHoursSpecified = VARIANT_TRUE, 
		bMinutesSpecified = VARIANT_TRUE, 
		bSecondsSpecified = VARIANT_TRUE, 
		bMicrosecondsSpecified = VARIANT_TRUE, 
		bUTCSpecified = VARIANT_TRUE, 
		bIsInterval = VARIANT_TRUE;

		LPWSTR pValue = (LPWSTR) bsValue;
		
		// Check whether its an interval
		if (ISINTERVAL(pValue [WBEMDT_DMTF_UPOS]))
		{
			// Years and months are as nothing to us in interval land
			bYearSpecified = VARIANT_FALSE;
			bMonthSpecified = VARIANT_FALSE;

			// Check that everything is a digit apart from
			// the interval separator
			for (int i = 0; i < WBEMDT_DMTF_LEN; i++)
			{
				if ((WBEMDT_DMTF_UPOS != i) && 
					(WBEMDT_DMTF_SPOS != i) && !wbem_iswdigit (pValue [i]))
				{
					err = true;
					break;
				}
			}

			if (!err)
			{
				// Now check all is within bounds
				err = !(CheckField (pValue, 8, bDaySpecified, iDay, WBEMDT_MAX_DAYINT, WBEMDT_MIN_DAYINT) &&
					(VARIANT_TRUE == bDaySpecified) &&
					CheckField (pValue+8, 2, bHoursSpecified, iHours, WBEMDT_MAX_HOURS, WBEMDT_MIN_HOURS) &&
					(VARIANT_TRUE == bHoursSpecified) &&
					CheckField (pValue+10, 2, bMinutesSpecified, iMinutes, WBEMDT_MAX_MINUTES, WBEMDT_MIN_MINUTES) &&
					(VARIANT_TRUE == bMinutesSpecified) &&
					CheckField (pValue+12, 2, bSecondsSpecified, iSeconds, WBEMDT_MAX_SECONDS, WBEMDT_MIN_SECONDS) &&
					(VARIANT_TRUE == bSecondsSpecified) &&
					(ISDOT(pValue [WBEMDT_DMTF_SPOS])) &&
					CheckField (pValue+15, 6, bMicrosecondsSpecified, iMicroseconds, WBEMDT_MAX_MICROSEC, WBEMDT_MIN_MICROSEC) &&
					(VARIANT_TRUE == bMicrosecondsSpecified) &&
					CheckUTC (pValue+21, bUTCSpecified, iUTC, false));
				
			}
		}
		else
		{
			// assume it's a datetime
			bIsInterval = VARIANT_FALSE;

			err = !(CheckField (pValue, 4, bYearSpecified, iYear, WBEMDT_MAX_YEAR, WBEMDT_MIN_YEAR) &&
				CheckField (pValue+4, 2, bMonthSpecified, iMonth, WBEMDT_MAX_MONTH, WBEMDT_MIN_MONTH) &&
				CheckField (pValue+6, 2, bDaySpecified, iDay, WBEMDT_MAX_DAY, WBEMDT_MIN_DAY) &&
				CheckField (pValue+8, 2, bHoursSpecified, iHours, WBEMDT_MAX_HOURS, WBEMDT_MIN_HOURS) &&
				CheckField (pValue+10, 2, bMinutesSpecified, iMinutes, WBEMDT_MAX_MINUTES, WBEMDT_MIN_MINUTES) &&
				CheckField (pValue+12, 2, bSecondsSpecified, iSeconds, WBEMDT_MAX_SECONDS, WBEMDT_MIN_SECONDS) &&
				(ISDOT(pValue [WBEMDT_DMTF_SPOS])) &&
				CheckField (pValue+15, 6, bMicrosecondsSpecified, iMicroseconds, WBEMDT_MAX_MICROSEC, WBEMDT_MIN_MICROSEC) &&
				CheckUTC (pValue+21, bUTCSpecified, iUTC));
		}

		if (!err)
		{
			m_iYear = iYear;
			m_iMonth = iMonth;
			m_iDay = iDay;
			m_iHours = iHours;
			m_iMinutes = iMinutes;
			m_iSeconds = iSeconds;
			m_iMicroseconds = iMicroseconds;
			m_iUTC = iUTC;
			m_bYearSpecified = bYearSpecified;
			m_bMonthSpecified = bMonthSpecified;
			m_bDaySpecified = bDaySpecified;
			m_bHoursSpecified = bHoursSpecified;
			m_bMinutesSpecified = bMinutesSpecified;
			m_bSecondsSpecified = bSecondsSpecified;
			m_bMicrosecondsSpecified = bMicrosecondsSpecified;
			m_bUTCSpecified = bUTCSpecified;
			m_bIsInterval = bIsInterval;
			hr = S_OK;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemDateTime::CheckField
//
//  DESCRIPTION:
//
//  Check a string-based datetime field for correctness
//
//  PARAMETERS:
//
//		pValue			pointer to the value to check
//		len				number of characters in the value
//		bIsSpecified	on return defines whether value is wildcard
//		iValue			on return specifies integer value (if not wildcard)
//		maxValue		maximum numeric value allowed for this field
//		minValue		minimum numeric value allowed for this field
//
//  RETURN VALUES:
//
//		true if value parsed ok, false otherwise
//
//***************************************************************************
bool CWbemDateTime::CheckField (
		LPWSTR			pValue,
		ULONG			len,
		VARIANT_BOOL	&bIsSpecified,
		long			&iValue,
		long			maxValue,
		long			minValue
	)
{
	bool status = true;
	bIsSpecified = VARIANT_FALSE;

	for (ULONG i = 0; i < len; i++)
	{
		if (ISWILD(pValue [i]))
		{
			if (VARIANT_TRUE == bIsSpecified)
			{
				status = false;
				break;
			}
		}
		else if (!wbem_iswdigit (pValue [i]))
		{
			status = false;
			break;
		}
		else
			bIsSpecified = VARIANT_TRUE;
	}

	if (status)
	{
		if (VARIANT_TRUE == bIsSpecified)
		{
			wchar_t *dummy = NULL;
			wchar_t temp [12];
			
			if ( len > ( ( sizeof ( temp ) / sizeof ( wchar_t ) ) - 1 ) )
			{
				return false ;
			}

			if ( FAILED ( StringCchCopyNW ( temp , ( sizeof ( temp ) / sizeof ( wchar_t ) ) , pValue, len ) ) )
			{
				return false ;
			}
			temp [len] = NULL;
			iValue = wcstol (temp, &dummy, 10);
		}
	}
	
	return status;
}

//***************************************************************************
//
//  SCODE CWbemDateTime::CheckUTC
//
//  DESCRIPTION:
//
//  Check a string-based UTC field for correctness
//
//  PARAMETERS:
//
//		pValue			pointer to the value to check
//		bIsSpecified	on return defines whether value is wildcard
//		iValue			on return specifies integer value (if not wildcard)
//		bParseSign		whether first character should be a sign (+/-) or
//						a : (for intervals)
//
//  RETURN VALUES:
//
//		true if value parsed ok, false otherwise
//
//***************************************************************************
bool CWbemDateTime::CheckUTC (
		LPWSTR			pValue,
		VARIANT_BOOL	&bIsSpecified,
		long			&iValue,
		bool			bParseSign
	)
{
	bool status = true;
	bool lessThanZero = false;
	bIsSpecified = VARIANT_FALSE;

	// Check if we have a signed offset
	if (bParseSign)
	{
		if (ISMINUS(pValue [0]))
			lessThanZero = true;
		else if (!ISPLUS(pValue [0]))
			status = false;
	}
	else
	{
		if (!ISINTERVAL(pValue[0]))
			status = false;
	}

	if (status)
	{
		// Check remaining are digits or wildcars
		for (int i = 1; i < 4; i++)
		{
			if (ISWILD(pValue [i]))
			{
				if (VARIANT_TRUE == bIsSpecified)
				{
					status = false;
					break;
				}
			}
			else if (!wbem_iswdigit (pValue [i]))
			{
				status = false;
				break;
			}
			else
				bIsSpecified = VARIANT_TRUE;
		}
	}

	if (status)
	{
		if (VARIANT_TRUE == bIsSpecified)
		{
			wchar_t *dummy = NULL;
			wchar_t temp [4];
			
			wcsncpy (temp, pValue+1, 3);
			temp [3] = NULL;
			iValue = wcstol (temp, &dummy, 10);

			if (lessThanZero)
				iValue = -iValue;
		}
	}
	
	return status;
}


//***************************************************************************
//
//  SCODE CWbemDateTime::GetVarDate
//
//  DESCRIPTION:
//
//  Retrieve the value in Variant form 
//
//  PARAMETERS:
//
//		bIsLocal		whether to return a local or UTC value
//		pVarDate		holds result on successful return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
HRESULT CWbemDateTime::GetVarDate( 
        IN VARIANT_BOOL bIsLocal,
		OUT DATE *pVarDate) 
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;

	if (NULL == pVarDate)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		// We cannot perform this operation for interval
		// or wildcarded values
		if ((VARIANT_TRUE == m_bIsInterval) ||
			(VARIANT_FALSE == m_bYearSpecified) ||
			(VARIANT_FALSE == m_bMonthSpecified) ||
			(VARIANT_FALSE == m_bDaySpecified) ||
			(VARIANT_FALSE == m_bHoursSpecified) ||
			(VARIANT_FALSE == m_bMinutesSpecified) ||
			(VARIANT_FALSE == m_bSecondsSpecified) ||
			(VARIANT_FALSE == m_bMicrosecondsSpecified) ||
			(VARIANT_FALSE == m_bUTCSpecified))
		{ 
			hr = WBEM_E_FAILED;
		}
		else
		{	
			SYSTEMTIME sysTime;
			sysTime.wYear = ( WORD ) m_iYear;
			sysTime.wMonth = ( WORD ) m_iMonth;
			sysTime.wDay = ( WORD ) m_iDay;
			sysTime.wHour = ( WORD ) m_iHours;
			sysTime.wMinute = ( WORD ) m_iMinutes;
			sysTime.wSecond = ( WORD ) m_iSeconds;
			sysTime.wMilliseconds = ( WORD ) ( m_iMicroseconds/1000 ) ;
				
			if (VARIANT_TRUE == bIsLocal)
			{
				// Need to convert this to a local DATE value
				// This requires that we switch the currently stored
				// time to one for the appropriate timezone, lop off
				// the UTC and set the rest in a variant.

				// Coerce the time to GMT first
				WBEMTime wbemTime (sysTime);
				
				if (!wbemTime.GetDMTF (sysTime))
					return WBEM_E_INVALID_SYNTAX;
			}

			double dVarDate;

			if (SystemTimeToVariantTime (&sysTime, &dVarDate))
			{
				*pVarDate = dVarDate;
				hr = S_OK;
			}
		}
	}

	return hr;
}
    
//***************************************************************************
//
//  SCODE CWbemDateTime::SetVarDate
//
//  DESCRIPTION:
//
//  Set the value in Variant form 
//
//  PARAMETERS:
//
//		dVarDate		the new value
//		bIsLocal		whether to treat as local or UTC value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//
//***************************************************************************
HRESULT CWbemDateTime::SetVarDate( 
        /*[in]*/ DATE dVarDate,
		/*[in, optional]*/ VARIANT_BOOL bIsLocal) 
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;

	SYSTEMTIME	sysTime;
	
	if (TRUE == VariantTimeToSystemTime (dVarDate, &sysTime))
	{
		long offset = 0;

		if (VARIANT_TRUE == bIsLocal)
		{
			WBEMTime wbemTime (sysTime);
			if (!wbemTime.GetDMTF (sysTime, offset))
				return WBEM_E_INVALID_SYNTAX;
		}

		m_iYear = sysTime.wYear;
		m_iMonth = sysTime.wMonth;
		m_iDay = sysTime.wDay;
		m_iHours = sysTime.wHour;
		m_iMinutes = sysTime.wMinute;
		m_iSeconds = sysTime.wSecond;
		m_iMicroseconds = sysTime.wMilliseconds * 1000;
		m_iUTC = offset;

		m_bYearSpecified = VARIANT_TRUE,	
		m_bMonthSpecified = VARIANT_TRUE, 
		m_bDaySpecified = VARIANT_TRUE, 
		m_bHoursSpecified = VARIANT_TRUE, 
		m_bMinutesSpecified = VARIANT_TRUE, 
		m_bSecondsSpecified = VARIANT_TRUE, 
		m_bMicrosecondsSpecified = VARIANT_TRUE, 
		m_bUTCSpecified = VARIANT_TRUE, 
		m_bIsInterval = VARIANT_FALSE;			

		hr = S_OK;
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemDateTime::SetVarDate
//
//  DESCRIPTION:
//
//  Set the value in Variant form 
//
//  PARAMETERS:
//
//		dVarDate		the new value
//		bIsLocal		whether to treat as local or UTC value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//
//***************************************************************************
HRESULT CWbemDateTime::SetFileTimeDate( 
        /*[in]*/ FILETIME fFileTime,
		/*[in, optional]*/ VARIANT_BOOL bIsLocal) 
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;

	SYSTEMTIME	sysTime;
	
	long offset = 0;

	if (VARIANT_TRUE == bIsLocal)
	{
		WBEMTime wbemTime (fFileTime);
		if (!wbemTime.GetDMTF (sysTime, offset))
			return WBEM_E_INVALID_SYNTAX;
	}
	else
	{
		WBEMTime wbemTime (fFileTime);
		wbemTime.GetSYSTEMTIME(&sysTime);
	}

	m_iYear = sysTime.wYear;
	m_iMonth = sysTime.wMonth;
	m_iDay = sysTime.wDay;
	m_iHours = sysTime.wHour;
	m_iMinutes = sysTime.wMinute;
	m_iSeconds = sysTime.wSecond;
	m_iMicroseconds = sysTime.wMilliseconds * 1000;
	m_iUTC = offset;

	m_bYearSpecified = VARIANT_TRUE,	
	m_bMonthSpecified = VARIANT_TRUE, 
	m_bDaySpecified = VARIANT_TRUE, 
	m_bHoursSpecified = VARIANT_TRUE, 
	m_bMinutesSpecified = VARIANT_TRUE, 
	m_bSecondsSpecified = VARIANT_TRUE, 
	m_bMicrosecondsSpecified = VARIANT_TRUE, 
	m_bUTCSpecified = VARIANT_TRUE, 
	m_bIsInterval = VARIANT_FALSE;			

	hr = S_OK;

	return hr;
}


// These are here rather than wbemtime.h so we don't have to doc/support
#define INVALID_TIME_FORMAT 0
#define INVALID_TIME_ARITHMETIC 0
#define BAD_TIMEZONE 0

//***************************************************************************
//
//  FileTimeToui64 
//  ui64ToFileTime
//
//  Description:  Conversion routines for going between FILETIME structures
//  and __int64.
//
//***************************************************************************

static void FileTimeToui64(const FILETIME *pft, ULONGLONG *p64)
{
    *p64 = pft->dwHighDateTime;
    *p64 = *p64 << 32;
    *p64 |=  pft->dwLowDateTime;
}

static void ui64ToFileTime(const ULONGLONG *p64,FILETIME *pft)
{
    unsigned __int64 uTemp = *p64;
    pft->dwLowDateTime = (DWORD)uTemp;
    uTemp = uTemp >> 32;
    pft->dwHighDateTime = (DWORD)uTemp; 
}

static int CompareSYSTEMTIME(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2)
{
    FILETIME ft1, ft2;

    SystemTimeToFileTime(pst1, &ft1);
    SystemTimeToFileTime(pst2, &ft2);

    return CompareFileTime(&ft1, &ft2);
}

// This function is used to convert the relative values that come
// back from GetTimeZoneInformation into an actual date for the year
// in question.  The system time structure that is passed in is updated
// to contain the absolute values.
static void DayInMonthToAbsolute(SYSTEMTIME *pst, const WORD wYear)
{
    const static int _lpdays[] = {
        -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
    };
    
    const static int _days[] = {
        -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
    };
    
    SHORT shYearDay;
    
    // If this is not 0, this is not a relative date
    if (pst->wYear == 0)
    {
        // Was that year a leap year?
        BOOL bLeap =  ( (( wYear % 400) == 0) || ((( wYear % 4) == 0) && (( wYear % 100) != 0)));
        
        // Figure out the day of the year for the first day of the month in question
        if (bLeap)
            shYearDay = 1 + _lpdays[pst->wMonth - 1];
        else
            shYearDay = 1 + _days[pst->wMonth - 1];
        
        // Now, figure out how many leap days there have been since 1/1/1601
        WORD yc = wYear - 1601;
        WORD y4 = (yc) / 4;
        WORD y100 = (yc) / 100;
        WORD y400 = (yc) / 400;
        
        // This will tell us the day of the week for the first day of the month in question.
        // The '1 +' reflects the fact that 1/1/1601 was a monday (figures).  You might ask,
        // 'why do we care what day of the week this is?'  Well, I'll tell you.  The way
        // daylight savings time is defined is with things like 'the last sunday of the month
        // of october.'  Kinda helps to know what day that is.
        SHORT monthdow = (1 + (yc * 365 + y4 + y400 - y100) + shYearDay) % 7;
        
        if ( monthdow < pst->wDayOfWeek )
            shYearDay += (pst->wDayOfWeek - monthdow) + (pst->wDay - 1) * 7;
        else
            shYearDay += (pst->wDayOfWeek - monthdow) + pst->wDay * 7;
        
            /*
            * May have to adjust the calculation above if week == 5 (meaning
            * the last instance of the day in the month). Check if yearday falls
            * beyond month and adjust accordingly.
        */
        if ( (pst->wDay == 5) &&
            (shYearDay > (bLeap ? _lpdays[pst->wMonth] :
        _days[pst->wMonth])) )
        {
            shYearDay -= 7;
        }

        // Now update the structure.
        pst->wYear = wYear;
        pst->wDay = shYearDay - (bLeap ? _lpdays[pst->wMonth - 1] :
        _days[pst->wMonth - 1]);
    }
    
}

// **************************************************************************
// These are static to WBEMTIME, which means they CAN be called from outside
// wbemtime

CWbemDateTime::WBEMTime :: WBEMTime ( const FILETIME &ft )	
{
	FileTimeToui64(&ft, &m_uTime);
}

LONG CWbemDateTime::WBEMTime::GetLocalOffsetForDate(const SYSTEMTIME *pst)
{
    TIME_ZONE_INFORMATION tzTime;
    DWORD dwRes = GetTimeZoneInformation(&tzTime);
    LONG lRes = 0xffffffff;

    switch (dwRes)
    {
    case TIME_ZONE_ID_UNKNOWN:
        {
            // Read tz, but no dst defined in this zone
            lRes = tzTime.Bias * -1;
            break;
        }
    case TIME_ZONE_ID_STANDARD:
    case TIME_ZONE_ID_DAYLIGHT:
        {

            // Convert the relative dates to absolute dates
            DayInMonthToAbsolute(&tzTime.DaylightDate, pst->wYear);
            DayInMonthToAbsolute(&tzTime.StandardDate, pst->wYear);

            if ( CompareSYSTEMTIME(&tzTime.DaylightDate, &tzTime.StandardDate) < 0 ) 
            {
                /*
                 * Northern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.DaylightDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.StandardDate) > 0)
                {
                    lRes = tzTime.Bias * -1;
                }
                else
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
            }
            else 
            {
                /*
                 * Southern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.StandardDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.DaylightDate) > 0)
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
                else
                {
                    lRes = tzTime.Bias * -1;
                }
            }

            break;

        }
    case TIME_ZONE_ID_INVALID:
    default:
        {
            // Can't read the timezone info
            ASSERT_BREAK(BAD_TIMEZONE);
            break;
        }
    }

    return lRes;
}

///////////////////////////////////////////////////////////////////////////
// WBEMTime - This class holds time values. 

//***************************************************************************
//
//  WBEMTime::operator+(const WBEMTimeSpan &uAdd)
//
//  Description:  dummy function for adding two WBEMTime.  It doesnt really
//  make sense to add two date, but this is here for Tomas's template.
//
//  Return: WBEMTime object.
//
//***************************************************************************

CWbemDateTime::WBEMTime CWbemDateTime::WBEMTime::operator+(const WBEMTimeSpan &uAdd) const
{
    WBEMTime ret;

    if (IsOk())
    {
        ret.m_uTime = m_uTime + uAdd.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

//***************************************************************************
//
//  WBEMTime::operator=(const SYSTEMTIME) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard WIN32 SYSTEMTIME stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const	CWbemDateTime::WBEMTime & CWbemDateTime::WBEMTime::operator=(const SYSTEMTIME & st)
{
    Clear();   // set when properly assigned
	FILETIME t_ft;

    if ( SystemTimeToFileTime(&st, &t_ft) )
	{
		// now assign using a FILETIME.
		*this = t_ft;
	}
    else
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator=(const FILETIME) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard WIN32 FILETIME stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const CWbemDateTime::WBEMTime & CWbemDateTime::WBEMTime::operator=(const FILETIME & ft)
{
	FileTimeToui64(&ft, &m_uTime);
    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator-(const WBEMTime & sub)
//
//  Description:  returns a WBEMTimeSpan object as the difference between 
//  two WBEMTime objects.
//
//  Return: WBEMTimeSpan object.
//
//***************************************************************************

CWbemDateTime::WBEMTime CWbemDateTime::WBEMTime::operator-(const WBEMTimeSpan & sub) const
{
    WBEMTime ret;

    if (IsOk() && (m_uTime >= sub.m_Time))
    {
        ret.m_uTime = m_uTime - sub.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

//***************************************************************************
//
//  WBEMTime::GetSYSTEMTIME(SYSTEMTIME * pst)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL CWbemDateTime::WBEMTime::GetSYSTEMTIME(SYSTEMTIME * pst) const
{
	if ((pst == NULL) || (!IsOk()))
	{
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
		return FALSE;
	}

	FILETIME t_ft;

	if (GetFILETIME(&t_ft))
	{
		if (!FileTimeToSystemTime(&t_ft, pst))
		{
            ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

    return TRUE;
}

//***************************************************************************
//
//  WBEMTime::GetFILETIME(FILETIME * pst)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL CWbemDateTime::WBEMTime::GetFILETIME(FILETIME * pft) const
{
	if ((pft == NULL) || (!IsOk()))
	{
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
		return FALSE;
	}

	ui64ToFileTime(&m_uTime, pft);

    return TRUE;
}

//***************************************************************************
//
//  BSTR WBEMTime::GetDMTF(SYSTEMTIME &st, long &offset)
//
//  Description:  Gets the time in DMTF string local datetime format as a 
//	SYSTEMTIME. 
//
//  Return: NULL if not OK.
//
//***************************************************************************


BOOL CWbemDateTime::WBEMTime::GetDMTF(SYSTEMTIME &st, long &offset) const
{
    if (!IsOk())
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    // If the date to be converted is within 12 hours of
    // 1/1/1601, return the greenwich time
	ULONGLONG t_ConversionZone = 12L * 60L * 60L ;
	t_ConversionZone = t_ConversionZone * 10000000L ;

	if ( m_uTime < t_ConversionZone ) 
	{
		if(!GetSYSTEMTIME(&st))
			return FALSE;
	}
	else
	{
		if (GetSYSTEMTIME(&st))
		{
            offset = GetLocalOffsetForDate(&st);

            WBEMTime wt;
            if (offset >= 0)
               wt = *this - WBEMTimeSpan(offset);
            else
               wt = *this + WBEMTimeSpan(-offset);
            wt.GetSYSTEMTIME(&st);
		}
		else
			return FALSE;
	}

	return TRUE ;
}

//***************************************************************************
//
//  BSTR WBEMTime::GetDMTF(SYSTEMTIME &st)
//
//  Description:  Gets the time in as local SYSTEMTIME. 
//
//  Return: NULL if not OK.
//
//***************************************************************************


BOOL CWbemDateTime::WBEMTime::GetDMTF(SYSTEMTIME &st) const
{
    if (!IsOk())
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    // If the date to be converted is within 12 hours of
    // 1/1/1601, return the greenwich time
	ULONGLONG t_ConversionZone = 12L * 60L * 60L ;
	t_ConversionZone = t_ConversionZone * 10000000L ;

	if ( m_uTime < t_ConversionZone ) 
	{
		if(!GetSYSTEMTIME(&st))
			return FALSE;
	}
	else
	{
		if (GetSYSTEMTIME(&st))
		{
            long offset = GetLocalOffsetForDate(&st);

            WBEMTime wt;
            if (offset >= 0)
               wt = *this + WBEMTimeSpan(offset);
            else
               wt = *this - WBEMTimeSpan(-offset);
            wt.GetSYSTEMTIME(&st);
		}
		else
			return FALSE;
	}

	return TRUE ;
}

BOOL CWbemDateTime::Preceeds ( CWbemDateTime &a_Time )
{
	BOOL t_Truth = TRUE ;

	SYSTEMTIME t_ThisTime ;
	t_ThisTime.wYear = ( WORD ) m_iYear;
	t_ThisTime.wMonth = ( WORD ) m_iMonth;
	t_ThisTime.wDay = ( WORD ) m_iDay;
	t_ThisTime.wHour = ( WORD ) m_iHours;
	t_ThisTime.wMinute = ( WORD ) m_iMinutes;
	t_ThisTime.wSecond = ( WORD ) m_iSeconds;
	t_ThisTime.wMilliseconds = ( WORD ) ( m_iMicroseconds/1000 ) ;
		
	SYSTEMTIME t_ArgTime ;
	t_ArgTime.wYear = ( WORD ) a_Time.m_iYear;
	t_ArgTime.wMonth = ( WORD ) a_Time.m_iMonth;
	t_ArgTime.wDay = ( WORD ) a_Time.m_iDay;
	t_ArgTime.wHour = ( WORD ) a_Time.m_iHours;
	t_ArgTime.wMinute = ( WORD ) a_Time.m_iMinutes;
	t_ArgTime.wSecond = ( WORD ) a_Time.m_iSeconds;
	t_ArgTime.wMilliseconds = ( WORD ) ( a_Time.m_iMicroseconds/1000 ) ;

	t_Truth = CompareSYSTEMTIME ( & t_ThisTime , & t_ArgTime ) < 0 ;

	return t_Truth ;
}

HRESULT CWbemDateTime::GetSystemTimeDate (

	SYSTEMTIME &fSystemTime
)
{
	ZeroMemory ( & fSystemTime , sizeof ( fSystemTime ) ) ;

	fSystemTime.wYear = ( WORD ) m_iYear;
	fSystemTime.wMonth = ( WORD ) m_iMonth;
	fSystemTime.wDay = ( WORD ) m_iDay;
	fSystemTime.wHour = ( WORD ) m_iHours;
	fSystemTime.wMinute = ( WORD ) m_iMinutes;
	fSystemTime.wSecond = ( WORD ) m_iSeconds;
	fSystemTime.wMilliseconds = ( WORD ) ( m_iMicroseconds/1000 ) ;

	return S_OK ;
}

HRESULT CWbemDateTime::GetFileTimeDate (

	FILETIME &fFileTime
)
{
	SYSTEMTIME fSystemTime ;
	ZeroMemory ( & fSystemTime , sizeof ( fSystemTime ) ) ;

	fSystemTime.wYear = ( WORD ) m_iYear;
	fSystemTime.wMonth = ( WORD ) m_iMonth;
	fSystemTime.wDay = ( WORD ) m_iDay;
	fSystemTime.wHour = ( WORD ) m_iHours;
	fSystemTime.wMinute = ( WORD ) m_iMinutes;
	fSystemTime.wSecond = ( WORD ) m_iSeconds;
	fSystemTime.wMilliseconds = ( WORD ) ( m_iMicroseconds/1000 ) ;

	if ( FileTimeToSystemTime ( & fFileTime , & fSystemTime ) ) 
	{
		return S_OK ;
	}
	else
	{
		return WBEM_E_FAILED ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Precomp.h

Abstract:


History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
#include <ntpsapi.h>
#include <ntexapi.h>
#include <polarity.h>
#define _WINNT_ // have what is needed from above

#include <ole2.h>
#include <windows.h>

#include <corepol.h>

#ifdef USE_POLARITY
    #ifdef BUILDING_DLL
        #define CORE_POLARITY __declspec( dllexport )
    #else 
       #define CORE_POLARITY __declspec( dllimport )
    #endif
#else
    #define CORE_POLARITY
#endif
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
#undef LOCALE_INVARIANT
#define LOCALE_INVARIANT MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)
#include <strutils.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\globals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/
#include "precomp.h"
#include <windows.h>
#include <objbase.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemcli.h>
#include <wbemint.h>

#include <comdef.h>
#include <strsafe.h>
#include <winntsec.h>
#include <callsec.h>
#include <cominit.h>

#include <Guids.h>

#include <BasicTree.h>
#include <Thread.h>
#include <Logging.h>

#include "Globals.h"
#include "aggregator.h"
#include "os.h"
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiAllocator *DecoupledProviderSubSystem_Globals :: s_Allocator = NULL ;


LONG DecoupledProviderSubSystem_Globals :: s_LocksInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_RegistrarUsers = 0 ;

LONG DecoupledProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderRegistrar_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderEvents_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncProvider_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Stub_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemProviderInitSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemWaitingObjectSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncObjectSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemFilteringObjectSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncFilteringObjectSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSinkEx_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncObjectSinkEx_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CDecoupledAggregator_IWbemProvider_ObjectsInProgress=0;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledUnboundObjectSink_ObjectsInProgress=0;
LONG DecoupledProviderSubSystem_Globals :: s_CDecoupled_Batching_IWbemSyncObjectSink_ObjectsInProgress=0;
LONG DecoupledProviderSubSystem_Globals :: s_CDecoupled_IWbemSyncObjectSink_ObjectsInProgress=0;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_DecoupledClient_ObjectsInProgress =0;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledProvider_ObjectsInProgress = 0;
LONG DecoupledProviderSubSystem_Globals :: s_CDecoupled_IWbemUnboundObjectSink_ObjectsInProgress=0;
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: Global_Startup ()
{
	HRESULT t_Result = S_OK ;
	
	if ( ! s_Allocator )
	{
/*
 *	Use the global process heap for this particular boot operation
 */

		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.New (

			( void ** ) & s_Allocator ,
			sizeof ( WmiAllocator ) 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			:: new ( ( void * ) s_Allocator ) WmiAllocator ;

			t_StatusCode = s_Allocator->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( *s_Allocator ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DecoupledProviderSubSystem_Globals::CreateSystemAces ();
	}
    	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProviderSubSystem_Common_Globals :: CreateMethodSecurityDescriptor () ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: Global_Shutdown ()
{
	HRESULT t_Result = S_OK ;
	
	WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( *s_Allocator ) ;

	if ( s_Allocator )
	{
		WmiAllocator t_Allocator ;
		t_StatusCode = t_Allocator.Delete (

			( void * ) s_Allocator
		) ;
	}
	
	t_Result = DecoupledProviderSubSystem_Globals::DeleteSystemAces () ;
	t_Result = ProviderSubSystem_Common_Globals :: DeleteMethodSecurityDescriptor () ;



	return t_Result ;
}


HRESULT 
DecoupledProviderSubSystem_Globals::CreateSystemAces()
{
  if (!OS::secureOS_) return S_OK;

  return ProviderSubSystem_Common_Globals::CreateSystemAces();
};

HRESULT 
DecoupledProviderSubSystem_Globals::DeleteSystemAces()
{
  if (!OS::secureOS_)
    return S_OK;
  return ProviderSubSystem_Common_Globals::DeleteSystemAces();
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
HRESULT 
DecoupledProviderSubSystem_Globals::SetCloaking ( 
		IUnknown *a_Unknown ,
		DWORD a_AuthenticationLevel ,
		DWORD a_ImpersonationLevel)
{
  if ( !OS::secureOS_) return S_OK;

    DWORD cloaking = (OS::osVer_ > OS::NT4) ? EOAC_DYNAMIC_CLOAKING : 0;
	DWORD impersonationLevel = (OS::osVer_ > OS::NT4) ? a_ImpersonationLevel : min(a_ImpersonationLevel,RPC_C_IMP_LEVEL_IDENTIFY) ;
    
    IClientSecurity *t_ClientSecurity = NULL ;

    HRESULT t_Result = a_Unknown->QueryInterface (
	
		IID_IClientSecurity , 
		( void ** ) & t_ClientSecurity
	) ;

    if ( SUCCEEDED ( t_Result ) )
    {
		t_Result = t_ClientSecurity->SetBlanket (

			a_Unknown ,
			RPC_C_AUTHN_WINNT ,
			RPC_C_AUTHZ_NONE ,
			NULL ,
			a_AuthenticationLevel ,
			impersonationLevel ,
			NULL ,
			cloaking
		) ;

		t_ClientSecurity->Release () ;
	}
	return t_Result ;
};
		

HRESULT DecoupledProviderSubSystem_Globals :: BeginImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating,
	DWORD *a_AuthenticationLevel
)
{
	if (!OS::secureOS_)
		return S_OK;

	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	

	CWbemCallSecurity * pSec = new CWbemCallSecurity(NULL);
	_IWmiCallSec *t_CallSecurity = NULL ;
	
	if (pSec == 0)
	  t_Result = WBEM_E_OUT_OF_MEMORY;
	else
	  t_Result = pSec->QueryInterface(IID__IWmiCallSec, ( void ** ) & t_CallSecurity);

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD | WMI_ORIGIN_EXISTING | WMI_ORIGIN_RPC ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_AuthenticationLevel )
					{
						t_Result = t_ThreadSecurity->GetAuthentication ( a_AuthenticationLevel  ) ;
					}

					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

HRESULT DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	if (!OS::secureOS_)
		return S_OK;

	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	CWbemCallSecurity * pSec = new CWbemCallSecurity(NULL);
	_IWmiCallSec *t_CallSecurity = NULL ;
	
	if (pSec == 0)
	  t_Result = WBEM_E_OUT_OF_MEMORY;
	else
	  t_Result = pSec->QueryInterface(IID__IWmiCallSec, ( void ** ) & t_CallSecurity);

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: BeginThreadImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	CWbemCallSecurity *t_CallSecurity = CWbemCallSecurity :: New () ;

	if ( t_CallSecurity )
	{
		t_CallSecurity->AddRef () ;

		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: EndThreadImpersonation (

	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_Impersonating

)
{
	HRESULT t_Result = S_OK ;

	IUnknown *t_NewContext = NULL ;

	t_Result = CoSwitchCallContext ( a_OldContext , & t_NewContext ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_OldContext )
		{
			if ( a_Impersonating )
			{
				IServerSecurity *t_ServerSecurity = NULL ;
				t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_ServerSecurity->ImpersonateClient () ;

					t_ServerSecurity->Release () ;
				}
			}
		}

		if ( a_OldSecurity )
		{
			a_OldSecurity->Release() ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

/* 
 * CoGetCallContext AddReffed this thing so now we have to release it.
 */

	if ( a_OldContext )
	{ 
        a_OldContext->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
HRESULT DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

	WmiInternalContext a_InternalContext ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity
)
{
	if (!OS::secureOS_)
		return S_OK;

	HRESULT t_Result = WBEM_E_INVALID_PARAMETER ;

	if ( a_InternalContext.m_IdentifyHandle )
	{
		HANDLE t_IdentifyToken = ( HANDLE ) a_InternalContext.m_IdentifyHandle ;

		BOOL t_Status = SetThreadToken ( NULL , t_IdentifyToken ) ;
		if ( t_Status )
		{
			t_Result = BeginThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

			RevertToSelf () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		CloseHandle ( t_IdentifyToken ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost (

	WmiInternalContext a_InternalContext ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	if (!OS::secureOS_)
		return S_OK;

	EndThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	RevertToSelf () ;

	return S_OK ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: SetProxyState_SvcHost ( 

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize,
	SECURITY_IMPERSONATION_LEVEL t_ImpersonationLevel
)
{
	if (!OS::secureOS_)
		return S_OK;

	a_Revert = FALSE ;

	HRESULT t_Result = ProviderSubSystem_Common_Globals::GetProxy ( a_Container , a_ProxyIndex , a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = ProviderSubSystem_Common_Globals::EnableAllPrivileges () ;

			// Get the token's impersonation level
			// ===================================

			if ( (t_ImpersonationLevel == SecurityImpersonation  || t_ImpersonationLevel == SecurityDelegation ) && (OS::osVer_ > OS::NT4) )
			{
				a_IdentifyToken = 0 ;
			}
			else
			{
				t_Result = ProviderSubSystem_Common_Globals::ConstructIdentifyToken_SvcHost (

					a_Revert ,
					a_ProcessIdentifier ,
					a_IdentifyToken ,
					a_Ace ,
					a_AceSize,
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SetInterfaceSecurity (

						a_Proxy ,
						NULL ,
						NULL ,
						NULL ,
						DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
						RPC_C_IMP_LEVEL_IDENTIFY
					) ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: RevertProxyState_SvcHost (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	if (!OS::secureOS_)
		return S_OK;

	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

	WmiStatusCode t_StatusCode = a_Container.Return ( a_Proxy , a_ProxyIndex ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Proxy->Release () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: GetAceWithProcessTokenUser ( 
					
	DWORD a_ProcessIdentifier ,
	WORD &a_AceSize ,
	ACCESS_ALLOWED_ACE *&a_Ace 
)
{
	if (!OS::secureOS_)
		return S_OK;

	HRESULT t_Result = WBEM_E_ACCESS_DENIED ;

	HANDLE t_ProcessHandle = OpenProcess (

		MAXIMUM_ALLOWED ,
		FALSE ,
		a_ProcessIdentifier 
	) ;

	if ( t_ProcessHandle )
	{
		HANDLE t_ProcessToken = NULL ;
		BOOL t_Status = OpenProcessToken (

			t_ProcessHandle ,
			TOKEN_QUERY | TOKEN_DUPLICATE ,
			& t_ProcessToken
		) ;

		if ( t_Status )
		{
			DWORD t_OwnerSize = 0 ; 
			PSID t_OwnerSid = NULL ;
			BOOL t_OwnerDefaulted = FALSE ;

			t_Result = GetUserSid (

				t_ProcessToken ,
				& t_OwnerSize , 
				t_OwnerSid 
			) ; 

			if ( SUCCEEDED ( t_Result ) ) 
			{
				ACCESS_ALLOWED_ACE *t_Ace = NULL ;
				DWORD t_AceSize = 0 ;

				t_AceSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_OwnerSize - sizeof(DWORD) ) ;
				t_Ace = (ACCESS_ALLOWED_ACE*) new BYTE [ t_AceSize ] ;
				if ( t_Ace )
				{
					CopySid ( t_OwnerSize, (PSID) & t_Ace->SidStart, t_OwnerSid ) ;
					t_Ace->Mask = TOKEN_ALL_ACCESS ;
					t_Ace->Header.AceType = 0 ;
					t_Ace->Header.AceFlags = 0 ;
					t_Ace->Header.AceSize = t_AceSize ;

					a_Ace = t_Ace ;
					a_AceSize = t_AceSize ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				delete [] ( BYTE * ) t_OwnerSid ;
			}

			CloseHandle ( t_ProcessToken ) ;
		}

		CloseHandle ( t_ProcessHandle ) ;
	}
	else
		{
		t_Result = WBEM_E_TRANSPORT_FAILURE;		
		}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: GetUserSid (

	HANDLE a_Token ,
	ULONG *a_Size ,
	PSID &a_Sid
)
{
	if (!OS::secureOS_)
		return S_OK;

	HRESULT t_Result = WBEM_E_FAILED ;

    if ( a_Token )
	{
		if ( a_Size ) 
		{
			TOKEN_USER *t_TokenUser = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenUser ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						t_TokenUser = ( TOKEN_USER * ) new BYTE [ t_ReturnLength ] ;
						if ( t_TokenUser )
						{
							t_TokenStatus = GetTokenInformation (

								a_Token ,
								t_TokenInformationClass ,
								t_TokenUser ,
								t_ReturnLength ,
								& t_ReturnLength
							) ;

							if ( t_TokenStatus )
							{
								DWORD t_SidLength = GetLengthSid ( t_TokenUser->User.Sid ) ;
								*a_Size = t_SidLength ;

								a_Sid = new BYTE [ t_SidLength ] ;
								if ( a_Sid )
								{
									CopyMemory ( a_Sid , t_TokenUser->User.Sid , t_SidLength ) ;

									t_Result = S_OK ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							delete [] t_TokenUser ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\maindll.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	MainDll.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <comdef.h>
#include <stdio.h>
#include <strsafe.h>
#include "Globals.h"
#include "ClassFac.h"
#include "Guids.h"
#include "aggregator.h"
#include "ProvRegistrar.h"
#include "ProvEvents.h"
#include "OS.h"



HINSTANCE g_hInst=NULL;
enum { RUN_AS_PROVIDER = 1, RUN_AS_CLIENT=2 };
int run_as = 0;

CriticalSection s_CriticalSection(NOTHROW_LOCK) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{
	g_hInst=hInstance;

	BOOL t_Status = TRUE ;

    if ( DLL_PROCESS_DETACH == ulReason )
	{
		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Global_Shutdown () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Status = TRUE ;
		}
		else
		{
			t_Status = FALSE ;
		}

		t_Status = TRUE ;
    }
    else if ( DLL_PROCESS_ATTACH == ulReason )
	{
		if (!s_CriticalSection.valid())
			return FALSE;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Global_Startup () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Status = TRUE ;
		}
		else
		{
			t_Status = FALSE ;
		}
    }
    else if ( DLL_THREAD_DETACH == ulReason )
	{
		t_Status = TRUE ;
    }
    else if ( DLL_THREAD_ATTACH == ulReason )
	{
		t_Status = TRUE ;
    }

    return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllGetClassObject (

	REFCLSID rclsid , 
	REFIID riid, 
	void **ppv 
)
{
	CS_GUARD_RETURN(monitor, s_CriticalSection,  E_OUTOFMEMORY) ;
	
	HRESULT status = S_OK ; 

	if ( rclsid == CLSID_WmiDCProxyProvider) 
	{
		run_as = RUN_AS_PROVIDER;
		CServerClassFactory <DCProxy,IWbemServices> *lpunk = new CServerClassFactory <DCProxy,IWbemServices> ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	} else if ( rclsid == CLSID_WbemDecoupledRegistrar) 
	{
		run_as = RUN_AS_CLIENT;
		CServerClassFactory <CServerObject_ProviderRegistrar,IWbemDecoupledRegistrar> *lpunk = new CServerClassFactory <CServerObject_ProviderRegistrar,IWbemDecoupledRegistrar> ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}
	else if ( rclsid == CLSID_WbemDecoupledBasicEventProvider) 
	{
		run_as = RUN_AS_CLIENT;
		CServerClassFactory <CServerObject_ProviderEvents,IWbemDecoupledBasicEventProvider> *lpunk = new CServerClassFactory <CServerObject_ProviderEvents,IWbemDecoupledBasicEventProvider> ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}

	else
	{
		status = CLASS_E_CLASSNOTAVAILABLE ;
	}

	return status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllCanUnloadNow ()
{

	CS_GUARD_RETURN(monitor, s_CriticalSection,  E_OUTOFMEMORY) ;	bool unload = true;

	switch(run_as)
	{
	case 0:
					break;
	case RUN_AS_PROVIDER:
					{
					DC_registrar * dcReg = DC_registrar::instance_;
					if (dcReg && DecoupledProviderSubSystem_Globals::s_ObjectsInProgress == 0)
					{
								dcReg->Delete();
								dcReg->Release();
					}

					unload = DecoupledProviderSubSystem_Globals::s_LocksInProgress || DecoupledProviderSubSystem_Globals::s_ObjectsInProgress || 
									 DecoupledProviderSubSystem_Globals::s_RegistrarUsers;
					break;
					}
	case RUN_AS_CLIENT:
				unload = DecoupledProviderSubSystem_Globals::s_LocksInProgress || DecoupledProviderSubSystem_Globals::s_ObjectsInProgress;
				break;
	};


	unload = ! unload ;

	return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

//Strings used during self registeration


#define REG_FORMAT_STR			("%s\\%s")
#define NOT_INSERT_STR			("NotInsertable")
#define INPROC32_STR			("InprocServer32")
#define LOCALSERVER32_STR		("LocalServer32")
#define THREADING_MODULE_STR	("ThreadingModel")
#define APARTMENT_STR			("Both")
#define APPID_VALUE_STR			("APPID")
#define APPID_STR				("APPID\\")
#define CLSID_STR				("CLSID\\")

#define WMI_DECCUPLED_PROXY_PROVIDER				("Microsoft WMI Adaptor Provider for Decoupled  Provider")
#define WMI_PROVIDER_DECOUPLED_REGISTRAR				("Microsoft WMI Provider Subsystem Decoupled Registrar")
#define WMI_PROVIDER_DECOUPLED_BASIC_EVENT_PROVIDER		("Microsoft WMI Provider Subsystem Decoupled Basic Event Provider")

const char * WmiDCProxyProviderKey= ("{54D8502C-527D-43f7-A506-A9DA075E229C}");
const char * WbemDecoupledRegistrarKey=("{4cfc7932-0f9d-4bef-9c32-8ea2a6b56fcb}");
const char * WbemDecoupledBasicEventProviderKey = ("{f5f75737-2843-4f22-933d-c76a97cda62f}");

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL SetKeyAndValue ( char *pszKey , char *pszSubkey , char *pszValueName , char *pszValue )
{
    HKEY hKey;
    char szKey[256];

	StringCchCopyA ( szKey , 256, pszKey ) ;

    if ( NULL != pszSubkey )
    {
		StringCchCatA ( szKey , 256, ("\\") ) ;
        StringCchCatA ( szKey , 256, pszSubkey ) ;
    }

    if ( ERROR_SUCCESS != RegCreateKeyExA ( 

			HKEY_CLASSES_ROOT , 
			szKey , 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE ,
			KEY_ALL_ACCESS, 
			NULL, 
			&hKey, 
			NULL
		)
	)
	{
        return FALSE ;
	}

    if ( NULL != pszValue )
    {
        if ( ERROR_SUCCESS != RegSetValueExA (

				hKey, 
				pszValueName, 
				0, 
				REG_SZ, 
				(BYTE *) pszValue , 
				(lstrlenA(pszValue)+1)*sizeof(char)
			)
		)
		{
			return FALSE;
		}
    }

    RegCloseKey ( hKey ) ;

    return TRUE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI RegisterServer ( const char *  szProviderClassID , char *a_ProviderName )
{
    CServerObject_DecoupledClientRegistration_Element::VerifyClientKey();
    char szModule[512];
	if (GetModuleFileNameA(g_hInst,(char *)szModule, sizeof(szModule)/sizeof(char))==0)
        return HRESULT_FROM_WIN32(GetLastError());

	char szProviderCLSIDClassID[128];

	StringCchCopyA(szProviderCLSIDClassID,128, CLSID_STR);

	StringCchCatA(szProviderCLSIDClassID,128, szProviderClassID);

		//Create entries under CLSID
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, a_ProviderName ))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INSERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

	return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI UnregisterServer( const char * szProviderClassID )
{
	
	char szTemp[128];

	char szProviderCLSIDClassID[128];

	StringCchCopyA(szProviderCLSIDClassID,128, CLSID_STR);
	StringCchCatA(szProviderCLSIDClassID,128, szProviderClassID);

	//Delete entries under CLSID

	StringCchPrintfA(szTemp, 128, REG_FORMAT_STR, szProviderCLSIDClassID, NOT_INSERT_STR);
	RegDeleteKeyA(HKEY_CLASSES_ROOT, szTemp);

	StringCchPrintfA(szTemp, 128, REG_FORMAT_STR,szProviderCLSIDClassID, INPROC32_STR);
	RegDeleteKeyA(HKEY_CLASSES_ROOT, szTemp);

	RegDeleteKeyA(HKEY_CLASSES_ROOT, szProviderCLSIDClassID);

    return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllRegisterServer ()
{
	HRESULT t_Result ;

	t_Result = RegisterServer ( WmiDCProxyProviderKey			,	WMI_DECCUPLED_PROXY_PROVIDER ) ;
	t_Result = RegisterServer ( WbemDecoupledRegistrarKey			,	WMI_PROVIDER_DECOUPLED_REGISTRAR ) ;
	t_Result = RegisterServer ( WbemDecoupledBasicEventProviderKey	,	WMI_PROVIDER_DECOUPLED_BASIC_EVENT_PROVIDER ) ;
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllUnregisterServer ()
{
	HRESULT t_Result ;

	t_Result = UnregisterServer ( WmiDCProxyProviderKey ) ;
	t_Result = UnregisterServer ( WbemDecoupledRegistrarKey ) ;
	t_Result = UnregisterServer ( WbemDecoupledBasicEventProviderKey ) ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\os.cpp ===
#include "PreComp.h"
#undef POLARITY
#include <windows.h>
#include <objbase.h>
#include "os.h"
#include <autoptr.h>

namespace OS
{
int sysVersion();
const bool unicodeOS_ = unicodeOS();
const bool secureOS_ = unicodeOS(); 
const int osVer_ = sysVersion();
	
DWORD convert2ansi(const wchar_t* unicode,  wmilib::auto_buffer<char>& ansi)
{
  if (unicode)
  {
    size_t class_len = wcslen(unicode);
    ansi  = wmilib::auto_buffer<char>(new char[2*class_len+1],2*class_len+1);
    if (ansi.get() == 0)
      return ERROR_NOT_ENOUGH_MEMORY;
    if (wcstombs(ansi.get(),unicode, 2*class_len+1)==-1)
      return ERROR_NO_UNICODE_TRANSLATION;
  }
  return ERROR_SUCCESS;
};
 
bool unicodeOS()
{
    OSVERSIONINFOA OsVersionInfoA;
    OsVersionInfoA.dwOSVersionInfoSize = sizeof (OSVERSIONINFOA) ;
    GetVersionExA(&OsVersionInfoA);
    return (OsVersionInfoA.dwPlatformId == VER_PLATFORM_WIN32_NT);
};

int sysVersion()
{
    OSVERSIONINFOA OsVersionInfoA;
    OsVersionInfoA.dwOSVersionInfoSize = sizeof (OSVERSIONINFOA) ;
    GetVersionExA(&OsVersionInfoA);
    //return (OsVersionInfoA.dwMajorVersion);
    return 4;
};

HRESULT 
CoImpersonateClient()
{
	if (secureOS_) return ::CoImpersonateClient();
	else return S_OK;
}

LONG RegOpenKeyExW (HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
{
	if (unicodeOS_)
		return ::RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);
	size_t key_len = wcslen(lpSubKey);
	wmilib::auto_buffer<char> ansi_key (new char[2*key_len+1]);
	if (ansi_key.get() == 0)
		return ERROR_NOT_ENOUGH_MEMORY;
	if (wcstombs(ansi_key.get(),lpSubKey, 2*key_len+1)==-1)
		return ERROR_NO_UNICODE_TRANSLATION;
	
	return ::RegOpenKeyExA(hKey, ansi_key.get(), ulOptions, samDesired, phkResult);
};

LONG RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey,DWORD Reserved, LPWSTR lpClass,DWORD dwOptions,REGSAM samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
{
	if (unicodeOS_)
		return ::RegCreateKeyExW(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

	wmilib::auto_buffer<char> ansi_class;
	if (lpClass)
	{
	  size_t class_len = wcslen(lpClass);
	  ansi_class  = wmilib::auto_buffer<char>(new char[2*class_len+1]);
	  if (ansi_class.get() == 0)
	    return ERROR_NOT_ENOUGH_MEMORY;
	  if (wcstombs(ansi_class.get(),lpClass, 2*class_len+1)==-1)
	    return ERROR_NO_UNICODE_TRANSLATION;
	};

	size_t key_len = wcslen(lpSubKey);
	wmilib::auto_buffer<char> ansi_key (new char[2*key_len+1]);
	
	if (ansi_key.get() == 0)
		return ERROR_NOT_ENOUGH_MEMORY;
	if (wcstombs(ansi_key.get(),lpSubKey, 2*key_len+1)==-1)
		return ERROR_NO_UNICODE_TRANSLATION;
	
	return ::RegCreateKeyExA(hKey, ansi_key.get(), Reserved, ansi_class.get(), dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
};

LONG RegEnumKeyExW (HKEY hKey,DWORD dwIndex,LPWSTR lpName,LPDWORD lpcName,LPDWORD lpReserved,LPWSTR lpClass,LPDWORD lpcClass,PFILETIME lpftLastWriteTime)
{
if (unicodeOS_)
	return ::RegEnumKeyExW(hKey,dwIndex,lpName,lpcName,lpReserved,lpClass,lpcClass,lpftLastWriteTime);

DWORD nameLength = *lpcName ;
wmilib::auto_buffer<char> ansi_name(new char[(*lpcName)*2]);
if (ansi_name.get() == 0)
	return ERROR_NOT_ENOUGH_MEMORY;

LONG return_code = ::RegEnumKeyExA(hKey,dwIndex,ansi_name.get(),&nameLength,0, 0, 0,lpftLastWriteTime);

if (return_code == ERROR_SUCCESS)
{
	mbstowcs(lpName, ansi_name.get(), *lpcName);
	*lpcName = nameLength;
}
return return_code;
};

LONG RegDeleteKeyW (HKEY hKey, LPCWSTR lpSubKey)
{
if (unicodeOS_)
	return ::RegDeleteKeyW(hKey, lpSubKey);

size_t key_len = wcslen(lpSubKey);
wmilib::auto_buffer<char> ansi_key (new char[2*key_len+1]);
if (ansi_key.get() == 0)
	return ERROR_NOT_ENOUGH_MEMORY;
if (wcstombs(ansi_key.get(),lpSubKey, 2*key_len+1)==-1)
	return ERROR_NO_UNICODE_TRANSLATION;

return ::RegDeleteKeyA(hKey, ansi_key.get());
};



LONG RegQueryValueExW( HKEY hKey,  LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData,  LPDWORD lpcbData )
{
if (unicodeOS_)
	return ::RegQueryValueExW(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

size_t key_len = wcslen(lpValueName);
wmilib::auto_buffer<char> ansi_key (new char[2*key_len+1]);
if (ansi_key.get() == 0)
	return ERROR_NOT_ENOUGH_MEMORY;
if (wcstombs(ansi_key.get(),lpValueName, 2*key_len+1)==-1)
	return ERROR_NO_UNICODE_TRANSLATION;

LONG available_size = *lpcbData;
LONG return_code = ::RegQueryValueExA(hKey, ansi_key.get(), lpReserved, lpType, lpData, lpcbData);
if (lpData==0)
{
*lpcbData *= 2;
return return_code;
}

if (return_code == ERROR_SUCCESS && (*lpType == REG_EXPAND_SZ || *lpType == REG_SZ))
{
	wmilib::auto_buffer<BYTE> tempData(new BYTE[*lpcbData]);
	if (tempData.get() == 0)
		return ERROR_NOT_ENOUGH_MEMORY;
	memcpy(tempData.get(), lpData, *lpcbData);
	const char * src = (char *)tempData.get();
	wchar_t * dst = (wchar_t*)lpData;

	if (*lpType==REG_SZ)
		*lpcbData = (mbstowcs(dst, src, available_size)+1)*sizeof(wchar_t);
	else
	{
		// Not Implemented
		return ERROR_NOT_ENOUGH_MEMORY;
	};
}
return return_code;
};

LONG RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, CONST BYTE *lpData, DWORD cbData)
{
if (unicodeOS_)
	return ::RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);

size_t key_len = wcslen(lpValueName);
wmilib::auto_buffer<char> ansi_key (new char[2*key_len+1]);
if (ansi_key.get() == 0)
	return ERROR_NOT_ENOUGH_MEMORY;
if (wcstombs(ansi_key.get(),lpValueName, 2*key_len+1)==-1)
	return ERROR_NO_UNICODE_TRANSLATION;

if (dwType==REG_EXPAND_SZ || dwType==REG_SZ)
{
	const wchar_t * src = reinterpret_cast<const wchar_t*>(lpData);
	size_t value_len = cbData / sizeof(wchar_t) ;
	wmilib::auto_buffer<char> ansi_value (new char[2*value_len+1]);
	if (ansi_value.get() == 0)
		return ERROR_NOT_ENOUGH_MEMORY;
	char * dest = ansi_value.get();
	
	if (dwType==REG_SZ)
	{
		if ((value_len = wcstombs(dest,src, value_len)+1)==-1)
			return ERROR_NO_UNICODE_TRANSLATION;
	} 
	else
	{
		// Not Implemented
		return ERROR_NOT_ENOUGH_MEMORY;
	};
	return ::RegSetValueExA(hKey, ansi_key.get(), Reserved, dwType, (const BYTE*)ansi_value.get(), value_len);
}
return ::RegSetValueExA(hKey, ansi_key.get(), Reserved, dwType, lpData, cbData);
}

BOOL GetProcessTimes(
  HANDLE hProcess,           // handle to process
  LPFILETIME lpCreationTime, // process creation time
  LPFILETIME lpExitTime,     // process exit time
  LPFILETIME lpKernelTime,   // process kernel-mode time
  LPFILETIME lpUserTime      // process user-mode time
)
{
	if (unicodeOS_)
		return ::GetProcessTimes(hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
	FILETIME zero = {0, 0};
	*lpCreationTime = zero;
	*lpExitTime = zero;
	*lpKernelTime = zero;
	*lpUserTime = zero;
	return 1;
};

  HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName )
  {
  if (unicodeOS_)
    return ::CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);
  
  wmilib::auto_buffer<char> name;
  DWORD res = convert2ansi(lpName, name);
  if (res == ERROR_SUCCESS)
    return ::CreateEventA(lpEventAttributes, bManualReset, bInitialState, name.get());
  else
    ::SetLastError(res);
  return NULL;
  }

  HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bInitialOwner, LPCWSTR lpName )
  {
  if (unicodeOS_)
    return ::CreateMutexW(lpEventAttributes, bInitialOwner, lpName);
  
  wmilib::auto_buffer<char> name;
  DWORD res = convert2ansi(lpName, name);
  if (res == ERROR_SUCCESS)
    return ::CreateMutexA(lpEventAttributes, bInitialOwner, name.get());
  else
    ::SetLastError(res);
  return NULL;
  }

wchar_t ToUpper(wchar_t c)
{
    if (unicodeOS_)
    {
    wchar_t wideChar ;
    if (LCMapStringW(LOCALE_INVARIANT, LCMAP_UPPERCASE, &c, 1, &wideChar, 1) ==0)
    {
        _DBG_BREAK;
        return c;
    }
    return wideChar;
    }
    else
    {
        char ansiString[16];
        char ansiUpper[16];
        wchar_t wideChar = c;
        if (WideCharToMultiByte(CP_ACP, 0, &c, 1, ansiString, 16, NULL, NULL))
        {
            if (LCMapStringA(LOCALE_INVARIANT, LCMAP_UPPERCASE, ansiString, -1, ansiUpper, 16) ==0)
            {
                _DBG_BREAK;
                return c;
            }
            MultiByteToWideChar(CP_ACP, 0, ansiUpper, -1, &wideChar, 1);
            return wideChar;
        };
        return c;
     }
}

wchar_t ToLower(wchar_t c)
{
    if (unicodeOS_)
    {
    wchar_t wideChar ;

    if (LCMapStringW(LOCALE_INVARIANT, LCMAP_LOWERCASE, &c, 1, &wideChar, 1) ==0)
    {
        _DBG_BREAK;
	return c;
    }
    return wideChar;
    }
    else
    {
        char ansiString[16];
        char ansiUpper[16];
        wchar_t wideChar = c;
        if (WideCharToMultiByte(CP_ACP, 0, &c, 1, ansiString, 16, NULL, NULL))
        {
            if (LCMapStringA(LOCALE_INVARIANT, LCMAP_LOWERCASE, ansiString, -1, ansiUpper, 16) ==0)
            {
                _DBG_BREAK;
                return c;
            }
            MultiByteToWideChar(CP_ACP, 0, ansiUpper, -1, &wideChar, 1);
            return wideChar;
        };
        return c;
     }
    
}
bool wbem_iswdigit(wchar_t c)
{
    WORD result;
    if (unicodeOS_)
    {
        if (GetStringTypeExW(LOCALE_INVARIANT, CT_CTYPE1, &c, 1, &result))
        {
            return (result & C1_DIGIT) != 0;
        };
        return false;
    }
    else
    {
        char ansiString[16];
        if (WideCharToMultiByte(CP_ACP, 0, &c, 1, ansiString, 16, NULL, NULL))
        {
            if (GetStringTypeExA(LOCALE_INVARIANT, CT_CTYPE1, ansiString, 1, &result))
            {
                return (result & C1_DIGIT) != 0;
            }
        };
        return false;
    }
};

bool wbem_iswalnum (wchar_t c)
{
    WORD result;
    if (unicodeOS_)
    {
        if (GetStringTypeExW(LOCALE_INVARIANT, CT_CTYPE1, &c, 1, &result))
        {
            return (result & (C1_DIGIT | C1_ALPHA)) != 0;
        };
        return false;
    }
    else
    {
        char ansiString[16];
        if (WideCharToMultiByte(CP_ACP, 0, &c, 1, ansiString, 16, NULL, NULL))
        {
            if (GetStringTypeExA(LOCALE_INVARIANT, CT_CTYPE1, ansiString, 1, &result))
            {
                return (result & (C1_DIGIT | C1_ALPHA)) != 0;
            }
        };
        return false;
    }
};


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provcache.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvSubS.cpp

Abstract:


History:

--*/

#include "precomp.h"
#include <wbemint.h>

#include <HelperFuncs.h>

#include "Guids.h"
#include "Globals.h"
#include "CGlobals.h"
#include "ProvWsv.h"
#include "ProvObSk.h"

#include "ProvCache.h"


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const ProviderCacheKey &a_Arg1 , const ProviderCacheKey &a_Arg2 ) 
{
	return a_Arg1.Compare ( a_Arg2 ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const GUID &a_Guid1 , const GUID &a_Guid2 )
{
	return memcmp ( & a_Guid1, & a_Guid2 , sizeof ( GUID ) ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const LONG &a_Arg1 , const LONG &a_Arg2 )
{
	return a_Arg1 - a_Arg2 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provdwsv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"

#include <wbemint.h>
#include <wmiutils.h>
#include "Globals.h"
#include "ProvRegDeCoupled.h"

#include "CGlobals.h"
#include "provcache.h"
#include "aggregator.h"
#include "ProvWsvS.h"
#include "ProvWsv.h"
#include "ProvInSk.h"
#include "ProvobSk.h"

#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

SECURITY_IMPERSONATION_LEVEL RpcToNT(DWORD impersonation)
{
switch(impersonation)
{
case RPC_C_IMP_LEVEL_IMPERSONATE:
	return  SecurityImpersonation;
case RPC_C_IMP_LEVEL_ANONYMOUS:
	return SecurityAnonymous;
case RPC_C_IMP_LEVEL_IDENTIFY:
	return SecurityIdentification;
case RPC_C_IMP_LEVEL_DELEGATE:
	return   SecurityDelegation;
default:
#ifdef DBG
	DebugBreak();
#endif
	return SECURITY_IMPERSONATION_LEVEL(0);
};
}

CDecoupled_IWbemUnboundObjectSink :: CDecoupled_IWbemUnboundObjectSink (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) :	VoidPointerContainerElement (

		a_Controller ,
		this 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Controller ( NULL ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_Internal_IWbemUnboundObjectSink ( NULL ) ,
	m_Registration ( & a_Registration ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_UnBound_Size , MAX_PROXIES ) ,
	m_ProcessIdentifier ( 0 ) ,
	m_InitializeResult ( S_OK ) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals  :: s_CDecoupled_IWbemUnboundObjectSink_ObjectsInProgress ) ;

	InterlockedIncrement(&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);
	
	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	m_InitializeResult = a_Controller->QueryInterface ( IID__IWmiProviderAbnormalShutdown , ( void ** ) & m_Controller ) ;
	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		if ( a_ServerSideProvider ) 
		{
			m_Unknown = a_ServerSideProvider ;
			m_Unknown->AddRef () ;

			m_InitializeResult = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
			if ( SUCCEEDED ( m_InitializeResult ) )
			{
				m_InitializeResult  = a_ServerSideProvider->QueryInterface ( IID_Internal_IWbemUnboundObjectSink , ( void ** ) & m_Provider_Internal_IWbemUnboundObjectSink ) ;
			}
		}
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_IWbemUnboundObjectSink :: ~CDecoupled_IWbemUnboundObjectSink ()
{
	if ( m_Controller )
	{
		m_Controller->Release () ;
	}

	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_Internal_IWbemUnboundObjectSink )
	{
		m_Provider_Internal_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals  :: s_CDecoupled_IWbemUnboundObjectSink_ObjectsInProgress ) ;

	InterlockedDecrement(&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: Initialize ()
{
	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			m_InitializeResult = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		_IWmiProviderSite *t_Site = NULL ;
		m_InitializeResult = m_Unknown->QueryInterface ( IID__IWmiProviderSite , ( void ** ) & t_Site ) ;
		if ( SUCCEEDED ( m_InitializeResult ) )
		{
			m_InitializeResult = t_Site->GetSite ( & m_ProcessIdentifier ) ;
			t_Site->Release () ;
		}
	}

	return m_InitializeResult ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupled_IWbemUnboundObjectSink :: AddRef ()
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CDecoupled_IWbemUnboundObjectSink :: Release ()
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CDecoupled_IWbemUnboundObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: Begin_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	if (!OS::secureOS_)
	{
	  a_Interface = a_ServerInterface ;
	  a_IsProxy = FALSE ;
	  return S_OK;
	}

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	DWORD t_AuthenticationLevel = 0 ;

	t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating , & t_AuthenticationLevel ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_ProcessIdentifier )
		{
			t_Result = OS::CoImpersonateClient () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

				CoRevertToSelf () ;
			
				if ( (t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE) && (OS::osVer_ > OS::NT4))
				{
					t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( 
					
						m_ProxyContainer , 
						a_ProxyIndex , 
						a_InterfaceIdentifier , 
						a_ServerInterface , 
						a_Proxy , 
						a_Revert
					) ;
				}
				else
				{
					if ( m_Registration->GetComRegistration ().GetDecoupledImpersonationRestriction () )
					{
						t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
					}

					WORD t_AceSize = 0 ;
					ACCESS_ALLOWED_ACE *t_Ace = NULL ;

					t_Result = DecoupledProviderSubSystem_Globals :: GetAceWithProcessTokenUser ( 
					
						a_ProcessIdentifier ,
						t_AceSize ,
						t_Ace 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState_SvcHost ( 
						
							m_ProxyContainer , 
							a_InternalProxyIndex , 
							a_InterfaceIdentifier , 
							a_InternalServerInterface , 
							a_Proxy , 
							a_Revert , 
							a_ProcessIdentifier , 
							a_IdentifyToken ,
							t_Ace ,
							t_AceSize,
							RpcToNT(t_ImpersonationLevel)
						) ;

						delete [] ( BYTE * ) t_Ace ;
					}
				}
			}
		}
		else
		{
			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( 
			
				m_ProxyContainer , 
				a_ProxyIndex , 
				a_InterfaceIdentifier , 
				a_ServerInterface , 
				a_Proxy , 
				a_Revert
			) ;
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = a_ServerInterface ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IUnknown * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel ;

				if ( m_Registration->GetComRegistration ().GetDecoupledImpersonationRestriction () )
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				else
				{
					t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;
				}

				t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( a_Context )
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;
						t_Variant.lVal = t_AuthenticationLevel ;
						t_Variant.vt = VT_I4 ;

						
						t_Result = a_Context->SetValue ( L"__WBEM_CLIENT_AUTHENTICATION_LEVEL" , 0, & t_Variant ) ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					if ( a_IdentifyToken )
					{
						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState_SvcHost ( 

							m_ProxyContainer , 
							a_InternalProxyIndex , 
							a_Proxy , 
							a_Revert ,
							a_ProcessIdentifier , 
							a_IdentifyToken 
						) ;
					}
					else
					{
						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							a_ProxyIndex , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			DecoupledProviderSubSystem_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: End_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	if (!OS::secureOS_)
	{
	  return S_OK;
	}

	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState_SvcHost ( 

				m_ProxyContainer , 
				a_InternalProxyIndex , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				a_ProxyIndex , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	DecoupledProviderSubSystem_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemUnboundObjectSink ;
		REFIID t_InterfaceIdentifier = IID_IWbemUnboundObjectSink ;
		DWORD t_ProxyIndex = ProxyIndex_UnBound_IWbemUnboundObjectSink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemUnboundObjectSink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemUnboundObjectSink ;
		DWORD t_InternalProxyIndex = ProxyIndex_UnBound_Internal_IWbemUnboundObjectSink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = m_ProcessIdentifier ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemUnboundObjectSink * ) t_Interface )->Internal_IndicateToConsumer (

					t_InternalContext ,
					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else
			{

				t_Result = ( ( IWbemUnboundObjectSink * ) t_Interface )->IndicateToConsumer (

					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				if ( m_Controller )
				{
					m_Controller->AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemDecoupledProvider :: CInterceptor_IWbemDecoupledProvider (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	IWbemServices *a_CoreStub ,
	CWbemGlobal_IWbemSyncProviderController *a_Controller ,
	IWbemContext *a_InitializationContext ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	GUID &a_Guid 

) :	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	SyncProviderContainerElement (

		a_Controller ,
		a_Guid
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemServices ( NULL ) ,
	m_Provider_IWbemPropertyProvider ( NULL ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_IWbemProviderInit ( NULL ) ,
	m_Provider_IWbemProviderIdentity ( NULL ) ,
	m_Provider_Internal_IWbemServices ( NULL ) ,
	m_Provider_Internal_IWbemPropertyProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_Internal_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_Internal_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_Internal_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_Internal_IWmiProviderConfiguration ( NULL ) ,
	m_Provider_Internal_IWbemProviderInit ( NULL ) ,
	m_Provider_Internal_IWbemProviderIdentity ( NULL ) ,
	m_ExtendedStatusObject ( NULL ) ,
	m_CoreStub ( a_CoreStub ) ,
	m_Registration ( & a_Registration ) ,
	m_Locale ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_ProcessIdentifier ( 0 ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_Provider_Size , MAX_PROXIES ) ,
	m_ProviderOperation_GetObjectAsync ( 0 ) ,
	m_ProviderOperation_PutClassAsync ( 0 ) ,
	m_ProviderOperation_DeleteClassAsync ( 0 ) ,
	m_ProviderOperation_CreateClassEnumAsync ( 0 ) ,
	m_ProviderOperation_PutInstanceAsync ( 0 ) ,
	m_ProviderOperation_DeleteInstanceAsync ( 0 ) ,
	m_ProviderOperation_CreateInstanceEnumAsync ( 0 ) ,
	m_ProviderOperation_ExecQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecNotificationQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecMethodAsync ( 0 ) ,
	m_ProviderOperation_QueryInstances ( 0 ) ,
	m_ProviderOperation_CreateRefresher ( 0 ) ,
	m_ProviderOperation_CreateRefreshableObject ( 0 ) ,
	m_ProviderOperation_StopRefreshing ( 0 ) ,
	m_ProviderOperation_CreateRefreshableEnum ( 0 ) ,
	m_ProviderOperation_GetObjects ( 0 ) ,
	m_ProviderOperation_GetProperty ( 0 ) ,
	m_ProviderOperation_PutProperty ( 0 ) ,
	m_ProviderOperation_ProvideEvents ( 0 ) ,
	m_ProviderOperation_NewQuery ( 0 ) ,
	m_ProviderOperation_CancelQuery ( 0 ) ,
	m_ProviderOperation_AccessCheck ( 0 ) ,
	m_ProviderOperation_SetRegistrationObject ( 0 ) ,
	m_ProviderOperation_FindConsumer ( 0 ) ,
	m_ProviderOperation_ValidateSubscription ( 0 ) ,
	m_Initialized ( 0 ) ,
	m_InitializeResult ( S_OK ) ,
	m_InitializedEvent ( NULL ) , 
	m_InitializationContext ( a_InitializationContext )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals  :: s_CInterceptor_IWbemDecoupledProvider_ObjectsInProgress ) ;

	InterlockedIncrement(&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);

	if ( a_InitializationContext )
	{
		a_InitializationContext->AddRef () ;
	}

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		m_Unknown = a_ServerSideProvider ;
		m_Unknown->AddRef () ;

		HRESULT t_TempResult = m_Unknown->QueryInterface ( IID_IWbemServices , ( void ** ) & m_Provider_IWbemServices ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemServices , ( void ** ) & m_Provider_Internal_IWbemServices ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemPropertyProvider , ( void ** ) & m_Provider_IWbemPropertyProvider ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemPropertyProvider , ( void ** ) & m_Provider_Internal_IWbemPropertyProvider ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProvider , ( void ** ) & m_Provider_Internal_IWbemEventProvider ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_Internal_IWbemEventProviderQuerySink ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProviderSecurity , ( void ** ) & m_Provider_Internal_IWbemEventProviderSecurity ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemUnboundObjectSink , ( void ** ) & m_Provider_Internal_IWbemUnboundObjectSink ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventConsumerProvider , ( void ** ) & m_Provider_Internal_IWbemEventConsumerProvider ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_Internal_IWbemEventConsumerProviderEx ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & m_Provider_IWbemProviderInit ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemProviderInit , ( void ** ) & m_Provider_Internal_IWbemProviderInit ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemProviderIdentity , ( void ** ) & m_Provider_IWbemProviderIdentity ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemProviderIdentity , ( void ** ) & m_Provider_Internal_IWbemProviderIdentity ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}
	}

	if ( m_CoreStub )
	{
		m_CoreStub->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemDecoupledProvider :: ~CInterceptor_IWbemDecoupledProvider ()
{

	if ( m_ExtendedStatusObject )
	{
		m_ExtendedStatusObject->Release () ;
	}

	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemServices )
	{
		m_Provider_IWbemServices->Release () ; 
	}

	if ( m_Provider_IWbemPropertyProvider )
	{
		m_Provider_IWbemPropertyProvider->Release () ; 
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		m_Provider_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_IWbemProviderInit )
	{
		m_Provider_IWbemProviderInit->Release () ;
	}

	if ( m_Provider_IWbemProviderIdentity )
	{
		m_Provider_IWbemProviderIdentity->Release () ;
	}

	if ( m_Provider_Internal_IWbemServices )
	{
		m_Provider_Internal_IWbemServices->Release () ;
	}

	if ( m_Provider_Internal_IWbemPropertyProvider )
	{
		m_Provider_Internal_IWbemPropertyProvider->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventProvider )
	{
		m_Provider_Internal_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventProviderQuerySink )
	{
		m_Provider_Internal_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventProviderSecurity )
	{
		m_Provider_Internal_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventConsumerProvider )
	{
		m_Provider_Internal_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventConsumerProviderEx )
	{
		m_Provider_Internal_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_Internal_IWbemUnboundObjectSink )
	{
		m_Provider_Internal_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_Internal_IWmiProviderConfiguration )
	{
		m_Provider_Internal_IWmiProviderConfiguration->Release () ;
	}

	if ( m_Provider_Internal_IWbemProviderInit )
	{
		m_Provider_Internal_IWbemProviderInit->Release () ;
	}

	if ( m_Provider_Internal_IWbemProviderIdentity )
	{
		m_Provider_Internal_IWbemProviderIdentity->Release () ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->Release () ;
	}

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	if ( m_InitializationContext )
	{
		m_InitializationContext->Release () ;
	}

	if ( m_InitializedEvent )
	{
		CloseHandle ( m_InitializedEvent ) ;
	}

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals  :: s_CInterceptor_IWbemDecoupledProvider_ObjectsInProgress ) ;

	InterlockedDecrement(&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemDecoupledProvider :: AddRef ()
{
	return SyncProviderContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemDecoupledProvider :: Release ()
{
	return SyncProviderContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemDecoupledProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		if ( m_Provider_IWbemServices )
		{
			*iplpv = ( LPVOID ) ( IWbemServices * ) this ;
		}
	}
	else if ( iid == IID_IWbemPropertyProvider )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemPropertyProvider * ) this ;
		}
	}	
	else if ( iid == IID_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_IWbemProviderInit )
	{
		if ( m_Provider_IWbemProviderInit )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
		}
	}
	else if ( iid == IID_IWbemProviderIdentity )
	{
		if ( m_Provider_IWbemProviderIdentity )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderIdentity * ) this ;
		}
	}
	else if ( iid == IID__IWmiProviderAbnormalShutdown )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderAbnormalShutdown * ) this ;
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}
	else if ( iid == IID_CWbemGlobal_IWmiObjectSinkController )
	{
		*iplpv = ( LPVOID ) ( CWbemGlobal_IWmiObjectSinkController * ) this ;		
	}	
	else if ( iid == IID_CacheElement )
	{
		*iplpv = ( LPVOID ) ( SyncProviderContainerElement * ) this ;		
	}
	else if ( iid == IID__IWmiProviderInitialize )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
HRESULT CInterceptor_IWbemDecoupledProvider :: Begin_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context
)
{
	if (!OS::secureOS_)
	{
	  a_Interface = a_ServerInterface ;
	  a_IsProxy = FALSE ;
	  return S_OK;
	}


	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	DWORD t_AuthenticationLevel = 0 ;


    t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating , & t_AuthenticationLevel ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = OS::CoImpersonateClient () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;
			
			CoRevertToSelf () ;

			if ( (t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE) && (OS::osVer_ > OS::NT4) )
			{
				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( 
				
					m_ProxyContainer , 
					a_ProxyIndex , 
					a_InterfaceIdentifier , 
					a_ServerInterface , 
					a_Proxy , 
					a_Revert
				) ;
			}
			else
			{
				WORD t_AceSize = 0 ;
				ACCESS_ALLOWED_ACE *t_Ace = NULL ;

				if ( m_Registration->GetComRegistration ().GetDecoupledImpersonationRestriction () )
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}

				t_Result = DecoupledProviderSubSystem_Globals :: GetAceWithProcessTokenUser ( 
				
					a_ProcessIdentifier ,
					t_AceSize ,
					t_Ace 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState_SvcHost ( 
					
						m_ProxyContainer , 
						a_InternalProxyIndex , 
						a_InterfaceIdentifier , 
						a_InternalServerInterface , 
						a_Proxy , 
						a_Revert , 
						a_ProcessIdentifier , 
						a_IdentifyToken ,
						t_Ace ,
						t_AceSize,
						RpcToNT(t_ImpersonationLevel)
					) ;

					delete [] ( BYTE * ) t_Ace ;
				}
			}
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = a_ServerInterface ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IUnknown * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel ;

				if ( m_Registration->GetComRegistration ().GetDecoupledImpersonationRestriction () )
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				else
				{
					t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;
				}

				t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( a_Context )
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;
						t_Variant.lVal = t_AuthenticationLevel ;
						t_Variant.vt = VT_I4 ;

						
						t_Result = a_Context->SetValue ( L"__WBEM_CLIENT_AUTHENTICATION_LEVEL" , 0, & t_Variant ) ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					if ( a_IdentifyToken )
					{
						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState_SvcHost ( 

							m_ProxyContainer , 
							a_InternalProxyIndex , 
							a_Proxy , 
							a_Revert ,
							a_ProcessIdentifier , 
							a_IdentifyToken 
						) ;
					}
					else
					{
						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							a_ProxyIndex , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			DecoupledProviderSubSystem_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: End_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	if (!OS::secureOS_)
	{
	  return S_OK;
	}

	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState_SvcHost ( 

				m_ProxyContainer , 
				a_InternalProxyIndex , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				a_ProxyIndex , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	DecoupledProviderSubSystem_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Find ( 

			a_Sink ,
			t_Iterator
		) ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			ObjectSinkContainerElement *t_Element = t_Iterator.GetElement () ;

			UnLock () ;

			IWbemObjectSink *t_ObjectSink = NULL ;
			t_Result = t_Element->QueryInterface ( IID_IWbemObjectSink , ( void ** ) & t_ObjectSink ) ;
			if ( SUCCEEDED ( t_Result ) )
			{ 
				IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
				REFIID t_InterfaceIdentifier = IID_IWbemServices ;
				DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
				IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
				REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
				DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
				BOOL t_Impersonating ;
				IUnknown *t_OldContext ;
				IServerSecurity *t_OldSecurity ;
				BOOL t_IsProxy ;
				IUnknown *t_Interface ;
				BOOL t_Revert ;
				IUnknown *t_Proxy ;
				HANDLE t_IdentifyToken = NULL ;

				t_Result = Begin_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_IdentifyToken )
					{
						WmiInternalContext t_InternalContext ;
						t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
						t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

						t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CancelAsyncCall (

							t_InternalContext ,
							t_ObjectSink
						) ;
					}
					else
					{
						t_Result = ( ( IWbemServices * ) t_Interface )->CancelAsyncCall (

							t_ObjectSink
						) ;
					}

					End_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;
				}

				t_ObjectSink->Release () ;
			}

			IWbemShutdown *t_Shutdown = NULL ;
			HRESULT t_TempResult = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				t_TempResult = t_Shutdown->Shutdown ( 

					0 , 
					0 , 
					NULL 
				) ;

				t_Shutdown->Release () ;
			}

			t_Element->Release () ;
		}
		else
		{
			UnLock () ;

			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	BOOL t_DependantCall = FALSE ;

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							if ( t_ObjectPath )
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_GetObjectAsync (

									t_InternalContext ,
									t_ObjectPath, 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;

								SysFreeString ( t_ObjectPath ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->GetObjectAsync (

								a_ObjectPath, 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							WmiInternalContext t_InternalContext ;
							t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
							t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

							t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutClassAsync (

								t_InternalContext ,
								a_Object , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->PutClassAsync (

								a_Object , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: DeleteClassAsync ( 
		
	const BSTR a_Class ,
	long a_Flags,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_Class = SysAllocString ( a_Class ) ;
							if ( t_Class ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteClassAsync (

									t_InternalContext ,
									t_Class , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;

								SysFreeString ( t_Class ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->DeleteClassAsync (

								a_Class , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CInterceptor_IWbemDecoupledProvider :: CreateClassEnumAsync (

	const BSTR a_Superclass ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_Superclass = SysAllocString ( a_Superclass ) ;
							if ( t_Superclass ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateClassEnumAsync  (

									t_InternalContext ,
									t_Superclass , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;

								SysFreeString ( t_Superclass ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->CreateClassEnumAsync  (

								a_Superclass , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutInstance (

    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance , 
	long a_Flags ,
    IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							WmiInternalContext t_InternalContext ;
							t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
							t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

							t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutInstanceAsync (

								t_InternalContext ,
								a_Instance , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->PutInstanceAsync (

								a_Instance , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: DeleteInstance ( 

	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemDecoupledProvider :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink	
)
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							if ( t_ObjectPath ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteInstanceAsync  (

									t_InternalContext ,
									t_ObjectPath ,
									a_Flags ,
									a_Context ,
									t_Sink
								) ;

								SysFreeString ( t_ObjectPath ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->DeleteInstanceAsync  (

								a_ObjectPath ,
								a_Flags ,
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: CreateInstanceEnum ( 

	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink

) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							WmiInternalContext t_InternalContext ;
							t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
							t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

							BSTR t_Class = SysAllocString ( a_Class ) ;
							if ( t_Class )
							{
								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateInstanceEnumAsync (

									t_InternalContext ,
 									t_Class ,
									a_Flags ,
									a_Context ,
									t_Sink 
								) ;

								SysFreeString ( t_Class ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{

							t_Result = ( ( IWbemServices * ) t_Interface )->CreateInstanceEnumAsync (

 								a_Class ,
								a_Flags ,
								a_Context ,
								t_Sink 
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecQuery ( 

	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemFilteringObjectSink *t_Sink = new CInterceptor_IWbemFilteringObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			a_QueryLanguage ,
			a_Query 
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
							BSTR t_Query = SysAllocString ( a_Query ) ;

							if ( t_QueryLanguage && t_Query ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecQueryAsync  (

									t_InternalContext ,
									t_QueryLanguage , 
									t_Query, 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							SysFreeString ( t_QueryLanguage ) ;
							SysFreeString ( t_Query ) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->ExecQueryAsync  (

								a_QueryLanguage , 
								a_Query, 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			
			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemDecoupledProvider :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecMethod (

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecMethodAsync ( 

    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy ,
						a_Context
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							BSTR t_MethodName = SysAllocString ( a_MethodName ) ;

							if ( t_ObjectPath && t_MethodName ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecMethodAsync  (

									t_InternalContext ,
									t_ObjectPath ,
									t_MethodName ,
									a_Flags ,
									a_Context ,
									a_InParams ,
									t_Sink
								) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							SysFreeString ( t_ObjectPath ) ;
							SysFreeString ( t_MethodName ) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->ExecMethodAsync  (

								a_ObjectPath ,
								a_MethodName ,
								a_Flags ,
								a_Context ,
								a_InParams ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemPropertyProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemPropertyProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemPropertyProvider ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemPropertyProvider ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemPropertyProvider ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemPropertyProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				BSTR t_ClassMapping = NULL ;
				BSTR t_InstanceMapping = NULL ;
				BSTR t_PropertyMapping = NULL ;

				if ( a_ClassMapping )
				{
					t_ClassMapping = SysAllocString ( a_ClassMapping ) ;
					if ( t_ClassMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( a_InstanceMapping )
				{
					t_InstanceMapping = SysAllocString ( a_InstanceMapping ) ;
					if ( t_InstanceMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					} 
				}

				if ( a_PropertyMapping )
				{
					t_PropertyMapping = SysAllocString ( a_PropertyMapping ) ;
					if ( t_PropertyMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					( ( Internal_IWbemPropertyProvider * ) t_Interface )->Internal_GetProperty ( 

						t_InternalContext ,
						a_Flags ,
						a_Locale ,
						t_ClassMapping ,
						t_InstanceMapping ,
						t_PropertyMapping ,
						a_Value
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_ClassMapping ) ;
				SysFreeString ( t_InstanceMapping ) ;
				SysFreeString ( t_PropertyMapping ) ;
			}
			else
			{
				t_Result = ( ( IWbemPropertyProvider * ) t_Interface )->GetProperty (

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}	
	else
	{
		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemPropertyProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemPropertyProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemPropertyProvider ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemPropertyProvider ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemPropertyProvider ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemPropertyProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				BSTR t_ClassMapping = NULL ;
				BSTR t_InstanceMapping = NULL ;
				BSTR t_PropertyMapping = NULL ;

				if ( a_ClassMapping )
				{
					t_ClassMapping = SysAllocString ( a_ClassMapping ) ;
					if ( t_ClassMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( a_InstanceMapping )
				{
					t_InstanceMapping = SysAllocString ( a_InstanceMapping ) ;
					if ( t_InstanceMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					} 
				}

				if ( a_PropertyMapping )
				{
					t_PropertyMapping = SysAllocString ( a_PropertyMapping ) ;
					if ( t_PropertyMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					( ( Internal_IWbemPropertyProvider * ) t_Interface )->Internal_PutProperty ( 

						t_InternalContext ,
						a_Flags ,
						a_Locale ,
						t_ClassMapping ,
						t_InstanceMapping ,
						t_PropertyMapping ,
						a_Value
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_ClassMapping ) ;
				SysFreeString ( t_InstanceMapping ) ;
				SysFreeString ( t_PropertyMapping ) ;
			}
			else
			{
				t_Result = ( ( IWbemPropertyProvider * ) t_Interface )->PutProperty (

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	if ( m_Provider_IWbemEventProvider )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProvider ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProvider ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProvider ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemEventProvider * ) t_Interface )->Internal_ProvideEvents (

					t_InternalContext ,
					a_Sink ,
					a_Flags 
				) ;
			}
			else
			{
				t_Result = ( ( IWbemEventProvider * ) t_Interface )->ProvideEvents (

					a_Sink ,
					a_Flags 
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderQuerySink ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProviderQuerySink ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderQuerySink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderQuerySink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderQuerySink ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderQuerySink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
				BSTR t_Query = SysAllocString ( a_Query ) ;

				if ( t_QueryLanguage && t_Query )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemEventProviderQuerySink * ) t_Interface )->Internal_NewQuery (

						t_InternalContext ,
						a_Id ,
						t_QueryLanguage ,
						t_Query
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_QueryLanguage ) ;
				SysFreeString ( t_Query ) ;
			}
			else
			{
				t_Result = ( ( IWbemEventProviderQuerySink * ) t_Interface )->NewQuery (

					a_Id ,
					a_QueryLanguage ,
					a_Query
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::CancelQuery (

	unsigned long a_Id
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderQuerySink ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProviderQuerySink ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderQuerySink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderQuerySink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderQuerySink ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderQuerySink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemEventProviderQuerySink * ) t_Interface )->Internal_CancelQuery (

					t_InternalContext ,
					a_Id
				) ;
			}
			else
			{
				t_Result = ( ( IWbemEventProviderQuerySink * ) t_Interface )->CancelQuery (

					a_Id
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	if ( m_Provider_IWbemEventProviderSecurity )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderSecurity ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProviderSecurity ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderSecurity ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderSecurity ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderSecurity ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderSecurity;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
				BSTR t_Query = SysAllocString ( a_Query ) ;

				if ( t_QueryLanguage && t_Query )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemEventProviderSecurity * ) t_Interface )->Internal_AccessCheck (

						t_InternalContext ,
						t_QueryLanguage ,
						t_Query ,
						a_SidLength ,
						a_Sid
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_QueryLanguage ) ;
				SysFreeString ( t_Query ) ;
			}
			else
			{
				t_Result = ( ( IWbemEventProviderSecurity * ) t_Interface )->AccessCheck (

					a_QueryLanguage ,
					a_Query ,
					a_SidLength ,
					a_Sid
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	if ( m_Provider_IWbemEventConsumerProvider )
	{
		IWbemUnboundObjectSink *t_Consumer = NULL ;

		IUnknown *t_ServerInterface = m_Provider_IWbemEventConsumerProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventConsumerProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventConsumerProvider ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventConsumerProvider ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventConsumerProvider ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventConsumerProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemEventConsumerProvider * ) t_Interface )->Internal_FindConsumer (

					t_InternalContext ,
					a_LogicalConsumer ,
					& t_Consumer
				) ;
			}
			else
			{
				t_Result = ( ( IWbemEventConsumerProvider * ) t_Interface )->FindConsumer (

					a_LogicalConsumer ,
					& t_Consumer
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_Consumer )
			{
				CDecoupled_IWbemUnboundObjectSink *t_UnboundObjectSink = new CDecoupled_IWbemUnboundObjectSink (

						m_Allocator ,
						t_Consumer , 
						this ,
						*m_Registration
				) ;

				if ( t_UnboundObjectSink )
				{
					t_UnboundObjectSink->AddRef () ;

					t_Result = t_UnboundObjectSink->Initialize () ;
					if ( SUCCEEDED ( t_Result ) ) 
					{
						CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

						Lock () ;

						WmiStatusCode t_StatusCode = Insert ( 

							*t_UnboundObjectSink ,
							t_Iterator
						) ;

						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							UnLock () ;

							*a_Consumer = t_UnboundObjectSink ;

							t_UnboundObjectSink->AddRef () ;
						}
						else
						{
							UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_UnboundObjectSink->Release () ;
				}
			}
		}
		else
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		if ( t_Consumer )
		{
			t_Consumer->Release () ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventConsumerProviderEx ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventConsumerProviderEx ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventConsumerProviderEx ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventConsumerProviderEx ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventConsumerProviderEx ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventConsumerProviderEx ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemEventConsumerProviderEx * ) t_Interface )->Internal_ValidateSubscription (

					t_InternalContext ,
					a_LogicalConsumer
				) ;
			}
			else
			{

				t_Result = ( ( IWbemEventConsumerProviderEx * ) t_Interface )->ValidateSubscription (

					a_LogicalConsumer
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemUnboundObjectSink ;
		REFIID t_InterfaceIdentifier = IID_IWbemUnboundObjectSink ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemUnboundObjectSink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemUnboundObjectSink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemUnboundObjectSink ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemUnboundObjectSink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemUnboundObjectSink * ) t_Interface )->Internal_IndicateToConsumer (

					t_InternalContext ,
					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else
			{

				t_Result = ( ( IWbemUnboundObjectSink * ) t_Interface )->IndicateToConsumer (

					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: SetInitialized ( HRESULT a_InitializeResult )
{
	m_InitializeResult = a_InitializeResult ;

	InterlockedExchange ( & m_Initialized , 1 ) ;

	if ( m_InitializedEvent )
	{
		SetEvent ( m_InitializedEvent ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( m_Initialized == 0 )
	{
		BOOL t_DependantCall = FALSE ;
		t_Result = DecoupledProviderSubSystem_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_DependantCall == FALSE )
			{
				if ( WaitForSingleObject ( m_InitializedEvent , a_Timeout ) == WAIT_TIMEOUT )
				{
					return WBEM_E_PROVIDER_LOAD_FAILURE ;
				}
			}
			else
			{
				if ( WaitForSingleObject ( m_InitializedEvent , 0 ) == WAIT_TIMEOUT )
				{
					return S_FALSE ;
				}
			}
		}
	}
	else
	{
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	if ( m_Provider_IWbemProviderIdentity )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemProviderIdentity ;
		REFIID t_InterfaceIdentifier = IID_IWbemProviderIdentity ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemProviderIdentity ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemProviderIdentity ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemProviderIdentity ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemProviderIdentity ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemProviderIdentity * ) t_Interface )->Internal_SetRegistrationObject (

					t_InternalContext ,
					a_Flags ,
					a_ProviderRegistration
				) ;
			}
			else
			{
				t_Result = ( ( IWbemProviderIdentity * ) t_Interface )->SetRegistrationObject (

					a_Flags ,
					a_ProviderRegistration
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: Initialize (

	LPWSTR a_User ,
	LONG a_Flags ,
	LPWSTR a_Namespace ,
	LPWSTR a_Locale ,
	IWbemServices *a_CoreService ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	if ( m_Provider_IWbemProviderInit )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemProviderInit ;
		REFIID t_InterfaceIdentifier = IID_IWbemProviderInit ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemProviderInit ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemProviderInit ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemProviderInit ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemProviderInit ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemProviderInit * ) t_Interface )->Internal_Initialize (

					t_InternalContext ,
					a_User ,
					a_Flags ,
					a_Namespace ,
					a_Locale ,
					a_CoreService ,
					a_Context ,
					a_Sink
				) ;
			}
			else
			{
				t_Result = ( ( IWbemProviderInit * ) t_Interface )->Initialize (

					a_User ,
					a_Flags ,
					a_Namespace ,
					a_Locale ,
					a_CoreService ,
					a_Context ,
					a_Sink
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: AbnormalShutdown ()
{
	HRESULT t_Result = S_OK ;
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Unknown )
	{
		t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , IID_IWbemShutdown , t_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_Shutdown->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Provider = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								try
								{
									t_Result = t_Provider->Shutdown (

										a_Flags ,
										a_MaxMilliSeconds ,
										a_Context
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_Shutdown->Release () ;
		}
	}

	if ( m_CoreStub )
	{
		t_Shutdown = NULL ;
		t_Result = m_CoreStub->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Shutdown->Shutdown (

				a_Flags ,
				a_MaxMilliSeconds ,
				a_Context
			) ;

			t_Shutdown->Release () ;
		}
	}

	Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Container->Size () ] ;
	if ( t_ShutdownElements )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

		ULONG t_Count = 0 ;
		while ( ! t_Iterator.Null () )
		{
			t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

			t_Iterator.Increment () ;

			t_Count ++ ;
		}

		UnLock () ;

		for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
		{
			if ( t_ShutdownElements [ t_Index ] ) 
			{
				t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

					a_Flags ,
					a_MaxMilliSeconds ,
					a_Context
				) ;

				t_ShutdownElements [ t_Index ]->Release () ;
			}
		}

		delete [] t_ShutdownElements ;
	}
	else
	{	
		UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: Initialize (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Namespace ,
	IWbemServices *a_Repository ,
	IWbemServices *a_Service ,
	IWbemProviderInitSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_TransactionIdentifier )
		{
			wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

			if ( a_TransactionIdentifier )
			{
				StringFromGUID2 ( *a_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
			}

			m_TransactionIdentifier = SysAllocString ( t_TransactionIdentifier ) ;
		}
	}

	if ( a_Repository )
	{
		t_Result = a_Repository->GetObject ( 

			L"__ExtendedStatus" ,
			0 , 
			a_Context ,
			& m_ExtendedStatusObject ,
			NULL
		) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_InitializedEvent = OS::CreateEvent ( NULL , TRUE , FALSE , NULL ) ;
		if ( m_InitializedEvent == NULL )
		{
			t_Result = t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiProviderSite *t_Site = NULL ;
		t_Result = m_Unknown->QueryInterface ( IID__IWmiProviderSite , ( void ** ) & t_Site ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Site->GetSite ( & m_ProcessIdentifier ) ;
			t_Site->Release () ;
		}
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provdnf.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvTree.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <wbemint.h>
#include <typeinfo.h>
#include <stdio.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include "ProvDnf.h"
#include "wbemutil.h"
#include "autoptr.h"
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOrNode :: ~WmiOrNode ()
{
	delete m_Left ;
	delete m_Right ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiAndNode :: ~WmiAndNode ()
{
	delete m_Left ;
	delete m_Right ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiNotNode :: ~WmiNotNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualNode :: ~WmiOperatorEqualNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotEqualNode :: ~WmiOperatorNotEqualNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualOrGreaterNode :: ~WmiOperatorEqualOrGreaterNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualOrLessNode :: ~WmiOperatorEqualOrLessNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorGreaterNode :: ~WmiOperatorGreaterNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorLessNode :: ~WmiOperatorLessNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorLikeNode :: ~WmiOperatorLikeNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotLikeNode :: ~WmiOperatorNotLikeNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorIsANode :: ~WmiOperatorIsANode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotIsANode :: ~WmiOperatorNotIsANode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOrNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_RightCopy = NULL ;
	if ( m_Right )
	{
		t_RightCopy = m_Right->Copy () ;
		if ( t_RightCopy == NULL )
		{
			delete t_LeftCopy ;
			return NULL ;
		}
	}

	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOrNode ( t_LeftCopy , t_RightCopy , t_Parent ) ;
	if ( t_Node)
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}

		if ( t_RightCopy )
		{
			t_RightCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		delete t_RightCopy ;
		return 0;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiAndNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_RightCopy = NULL ;
	if ( m_Right )
	{
		t_RightCopy = m_Right->Copy () ;
		if ( t_RightCopy == NULL )
		{
			delete t_LeftCopy ;
			return NULL ;
		}
	}

	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiAndNode ( t_LeftCopy , t_RightCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}

		if ( t_RightCopy )
		{
			t_RightCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		delete t_RightCopy ;
		return 0;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNotNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiNotNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node)
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node)
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotEqualNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotEqualNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node)
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualOrGreaterNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualOrGreaterNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node)
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualOrLessNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualOrLessNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorGreaterNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorGreaterNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorLessNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorLessNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorLikeNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorLikeNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotLikeNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotLikeNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorIsANode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorIsANode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotIsANode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotIsANode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{	
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		return 0;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiSignedIntegerNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiSignedIntegerNode ( m_PropertyName , m_Integer , m_Index , t_Parent ) ;

	if (t_Node && t_Node->IsValid()) return t_Node;

	delete t_Node;
	return 0;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiUnsignedIntegerNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiUnsignedIntegerNode ( m_PropertyName , m_Integer , m_Index , t_Parent ) ;

	if (t_Node && t_Node->IsValid()) return t_Node;

	delete t_Node;
	return 0;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiStringNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiStringNode ( m_PropertyName , m_String , m_PropertyFunction , m_ConstantFunction , m_Index , t_Parent ) ;

	if (t_Node && t_Node->IsValid()) return t_Node;

	delete t_Node;
	return 0;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNullNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiNullNode ( m_PropertyName , m_Index , t_Parent ) ;

	if (t_Node && t_Node->IsValid()) return t_Node;

	delete t_Node;
	return 0;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiSignedIntegerRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiSignedIntegerRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	if (t_Node && t_Node->IsValid()) return t_Node;

	delete t_Node;
	return 0;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiUnsignedIntegerRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiUnsignedIntegerRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	if (t_Node && t_Node->IsValid()) return t_Node;

	delete t_Node;
	return 0;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiStringRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiStringRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	if (t_Node && t_Node->IsValid()) return t_Node;

	delete t_Node;
	return 0;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNullRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiNullRangeNode ( m_PropertyName , m_Index , NULL , NULL ) ;

	if (t_Node && t_Node->IsValid()) return t_Node;

	delete t_Node;
	return 0;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOrNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" Or "
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetRight () )
		GetRight ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiAndNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" And "
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetRight () )
		GetRight ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNotNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Not"
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" = "
	) ;
)
	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotEqualNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" != "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualOrGreaterNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" >= "
	) ;
)
	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualOrLessNode :: Print () 
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" <= "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorLessNode :: Print () 
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" < "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorGreaterNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" > "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorLikeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" Like "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotLikeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" NotLike "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorIsANode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" IsA "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotIsANode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" Not IsA "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiStringNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %s ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiUnsignedIntegerNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %ld ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiSignedIntegerNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %d ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNullNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , NULL ) " ,
		GetPropertyName ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiStringRangeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %s , %s ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? L"" : m_LowerBound ,
		m_InfiniteUpperBound ? L"" : m_UpperBound 
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiUnsignedIntegerRangeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %lu , %lu ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? 0 : m_LowerBound ,
		m_InfiniteUpperBound ? 0 : m_UpperBound  
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiSignedIntegerRangeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %ld , %ld ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? 0 : m_LowerBound ,
		m_InfiniteUpperBound ? 0 : m_UpperBound  
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNullRangeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , NULL ) " ,
		GetPropertyName ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerLess (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X < Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerLessOrEqual (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X <= Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerGreater (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X > Y ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerEqual (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return X == Y ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerLess (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X < Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerLessOrEqual (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X <= Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerGreater (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X > Y ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerEqual (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return X == Y ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringLess (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) < 0 ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
  		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringLessOrEqual (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) <= 0 ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringGreater (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) > 0 ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringEqual (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return wcscmp ( X , Y ) == 0 ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareLessOrEqualRangeNode ( 

	WmiRangeNode *a_LeftRange ,
	WmiRangeNode *a_RightRange
) 
{
	LONG t_State = 0 ;

	if ( ( a_LeftRange->GetType () == TypeId_WmiStringRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiStringRangeNode ) )
	{
		WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) a_LeftRange ;
		WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) a_RightRange ;

		t_State = CompareStringLessOrEqual ( 

			t_LeftString->LowerBound () , 
			t_LeftString->InfiniteLowerBound () ? -1 : 0 ,
			t_RightString->LowerBound () ,
			t_RightString->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) )
	{
		WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) a_LeftRange ;
		WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareSignedIntegerLessOrEqual ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) )
	{
		WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) a_LeftRange ;
		WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareUnsignedIntegerLessOrEqual ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiNullRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiNullRangeNode ) )
	{
		t_State = TRUE ;
	}

	return t_State ;
}

template<typename T>
WmiTriState CheckValid(T *& node)
{
	if ( node && node->IsValid())
	{
		return State_True;
	}
	else
	{
		delete node;
		node = 0;
		return State_Error;
	};
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiUnsignedIntegerRangeNode :: GetIntersectingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{

		_DBG_ASSERT(FALSE);
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// Empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiSignedIntegerRangeNode :: GetIntersectingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > Y_E )
		{
		_DBG_ASSERT(FALSE);
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// Empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiStringRangeNode :: GetIntersectingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL 
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL 
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > Y_E )
		{

		_DBG_ASSERT(FALSE);

		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Intersection);
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL 
				) ;

				t_Status = CheckValid(a_Intersection);
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiSignedIntegerRangeNode :: GetOverlappingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);

			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);

			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )


				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
                }
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
                }
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
			if ( X_E_CLOSED && Y_S_CLOSED )
			{
				if ( Y_S - X_E == 1 )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_S ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
				}
			}
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{

		_DBG_ASSERT(FALSE);

		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
				}
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping

			if ( Y_E_CLOSED && X_S_CLOSED )
			{
				if ( X_S - Y_E == - 1 )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE,
					    X_E_INFINITE  ,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_S ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiUnsignedIntegerRangeNode :: GetOverlappingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

   				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
                }
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
                }
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
			// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
			_DBG_ASSERT(FALSE);

			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
			if ( X_E_CLOSED && Y_S_CLOSED )
			{
				if ( Y_S - X_E == 1 )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_S ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
				}
			}
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{

		_DBG_ASSERT(FALSE);

		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
				}
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping

			if ( Y_E_CLOSED && X_S_CLOSED )
			{
				if ( X_S - Y_E == -1 )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE,
					    X_E_INFINITE  ,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_S ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiStringRangeNode :: GetOverlappingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
                }
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
                }
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{

// Order ( X_S < Y_E < Y_S == X_E ) Can never happen

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE ,
					    X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					    Y_E_CLOSED ,
					    Y_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
                }
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{

		_DBG_ASSERT(FALSE);

		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

				t_Status = CheckValid(a_Overlap);
				}
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = CheckValid(a_Overlap);
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorEqualNode :: GetRange (WmiRangeNode *& a_Range)
{
	a_Range = NULL ;
	WmiTriState t_Status = :: State_False ; 
	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			a_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				FALSE ,
				TRUE ,
				TRUE ,
				t_Integer->GetValue () ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			a_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				FALSE ,
				TRUE ,
				TRUE ,
				t_Integer->GetValue () ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					FALSE ,
					TRUE ,
					TRUE ,
					t_String->GetValue () ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
				t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
				t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			a_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
			t_Status = CheckValid(a_Range);
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorEqualOrGreaterNode :: GetRange (WmiRangeNode *& a_Range)
{
	WmiTriState t_Status = ::State_False;
	a_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			a_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				TRUE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			a_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				TRUE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					TRUE ,
					TRUE ,
					FALSE ,
					t_String->GetValue () ,
					NULL ,
					NULL , 
					NULL 
				) ;
				t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
				t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			a_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
			t_Status = CheckValid(a_Range);
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorEqualOrLessNode :: GetRange (WmiRangeNode *& a_Range)
{
	a_Range = NULL ;
	WmiTriState t_Status = ::State_False;
	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			a_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				TRUE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			a_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				TRUE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					FALSE ,
					FALSE ,
					TRUE ,
					NULL ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			a_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
			t_Status = CheckValid(a_Range);
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorLessNode :: GetRange (WmiRangeNode *& a_Range)
{
	WmiTriState t_Status = ::State_False;
	a_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			a_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				FALSE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;

			a_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				FALSE ,
				0 ,
				t_Integer->GetValue ()  ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					FALSE ,
					FALSE ,
					FALSE ,
					NULL ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
				t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			a_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
			t_Status = CheckValid(a_Range);
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorGreaterNode :: GetRange (WmiRangeNode *& a_Range)
{
	WmiTriState t_Status = ::State_False;
	a_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			a_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				FALSE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;

			a_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				FALSE ,
				FALSE , 
				t_Integer->GetValue (),
				0 ,
				NULL , 
				NULL 
			) ;
			t_Status = CheckValid(a_Range);
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					TRUE ,
					FALSE ,
					FALSE ,
					t_String->GetValue () ,
					NULL ,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			a_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
			t_Status = CheckValid(a_Range);
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorLikeNode :: GetRange (WmiRangeNode*& a_Range)
{
	WmiTriState t_Status = ::State_False;
	a_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorNotLikeNode :: GetRange (WmiRangeNode*& a_Range)
{
	WmiTriState t_Status = ::State_False;
	a_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorIsANode :: GetRange (WmiRangeNode*& a_Range)
{
	WmiTriState t_Status = ::State_False;
	a_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiOperatorNotIsANode :: GetRange (WmiRangeNode*& a_Range )
{
	WmiTriState t_Status = ::State_False;
	a_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			t_Status = CheckValid(a_Range);
			}
			else
			{
				a_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
				t_Status = CheckValid(a_Range);
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL QueryPreprocessor :: RecursiveEvaluate ( 

	void *a_Context ,
	SWbemRpnQueryToken **a_Expression , 
	WmiTreeNode *a_Parent , 
	WmiTreeNode **a_Node ,
	int &a_Index 
)
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"RecursiveEvaluate ( int &a_Index )"
	) ;
)

	BOOL t_Status = TRUE ;

	SWbemRpnQueryToken *t_Token = a_Expression [ a_Index ] ;
	a_Index -- ;

	switch ( t_Token->m_uTokenType )
	{
		case WMIQ_RPN_TOKEN_EXPRESSION:
		{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Operation = OP_EXPESSION"
	) ;
)
			WmiTreeNode *t_ParentNode = a_Parent ;
			WmiTreeNode **t_Node = a_Node ;
			WmiTreeNode *t_OperatorNode = NULL ;

			if ( t_Token->m_uSubexpressionShape & WMIQ_RPN_RELOP )
			{
				switch ( t_Token->m_uOperator )
				{
					case WMIQ_RPN_OP_EQ:
					{
						t_OperatorNode = new WmiOperatorEqualNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_NE:
					{
						t_OperatorNode = new WmiOperatorNotEqualNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_GE:
					{
						t_OperatorNode = new WmiOperatorEqualOrGreaterNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_LE: 
					{
						t_OperatorNode = new WmiOperatorEqualOrLessNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_LT:
					{
						t_OperatorNode = new WmiOperatorLessNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_GT:
					{
						t_OperatorNode = new WmiOperatorGreaterNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_LIKE:
					{
						t_OperatorNode = new WmiOperatorLikeNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_ISA:
					{
						t_OperatorNode = new WmiOperatorIsANode ( NULL , t_ParentNode ) ;
					}
					break ;

					default:
					{
						t_Status = FALSE ;
					}
					break ;
				}

				if ( t_OperatorNode == NULL )
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}

			if ( t_Status ) 
			{
				*t_Node = t_OperatorNode ;
				t_ParentNode = t_OperatorNode ;
				(*t_Node)->GetLeft ( t_Node ) ;

				t_Status = TRUE ;

				WmiValueNode :: WmiValueFunction t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_None ;

				if ( t_Token->m_uSubexpressionShape & WMIQ_RPN_LEFT_FUNCTION )
				{
					if ( wbem_wcsicmp ( t_Token->m_pszLeftFunc , L"Upper" ) == 0 )
					{
						t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_Upper ;
					}
					else if ( wbem_wcsicmp ( t_Token->m_pszLeftFunc , L"Lower" ) == 0 )
					{
						t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_Lower ;
					}
					else
					{
						t_Status = FALSE ;
					}
				}

				WmiValueNode :: WmiValueFunction t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_None ;

				if ( t_Token->m_uSubexpressionShape & WMIQ_RPN_RIGHT_FUNCTION )
				{
					if ( wbem_wcsicmp ( t_Token->m_pszRightFunc , L"Upper" ) == 0 )
					{
						t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_Upper ;
					}
					else if ( wbem_wcsicmp ( t_Token->m_pszRightFunc , L"Lower" ) == 0 )
					{
						t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_Lower ;
					}
					else
					{
						t_Status = FALSE ;
					}
				}

				if ( t_Status ) 
				{
					BOOL t_LeftProperty = t_Token->m_uSubexpressionShape & WMIQ_RPN_LEFT_PROPERTY_NAME ;
					BOOL t_RightProperty = t_Token->m_uSubexpressionShape & WMIQ_RPN_RIGHT_PROPERTY_NAME ;
					BOOL t_Const = t_Token->m_uSubexpressionShape & WMIQ_RPN_CONST ;
					BOOL t_Const2 = t_Token->m_uSubexpressionShape & WMIQ_RPN_CONST2 ;

					BOOL t_Validity = ( t_LeftProperty != 0 ) ? TRUE : FALSE ;
					t_Validity = t_Validity && ( ( t_RightProperty != 0 ) ? FALSE : TRUE ) ;
					t_Validity = t_Validity && ( ( t_Const != 0 ) ? TRUE : FALSE ) ;
					t_Validity = t_Validity && ( ( t_Const2 != 0 ) ? FALSE : TRUE ) ;

					if ( t_Validity ) 
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;

						switch ( t_Token->m_uConstApparentType )
						{
							case VT_I8:
							{
								t_Variant.vt = VT_R8 ;
								t_Variant.dblVal = t_Token->m_Const.m_dblVal ;
							}
							break ;

							case VT_I4:
							{
								t_Variant.vt = VT_I4 ;
								t_Variant.lVal = t_Token->m_Const.m_lLongVal ;
							}
							break ;

							case VT_LPWSTR:
							{
								t_Variant.vt = VT_BSTR ;
								t_Variant.bstrVal = SysAllocString ( t_Token->m_Const.m_pszStrVal ) ;
							}
							break ;

							case CIM_EMPTY:
							{
								t_Variant.vt = VT_NULL ;
							}
							break ;
						}

						BSTR t_PropertyName = SysAllocString ( t_Token->m_pLeftIdent->m_ppszNameList [ 0 ] ) ;
						if ( t_PropertyName ) 
						{
							WmiTreeNode *t_ValueNode = AllocTypeNode ( 

								a_Context ,
								t_PropertyName , 
								t_Variant , 
								t_PropertyFunction ,
								t_ConstantFunction ,
								t_ParentNode 
							) ;

							if ( t_ValueNode )
							{
								*t_Node = t_ValueNode ;

								t_Status = TRUE ;
							}
							else
							{				
								t_Status = FALSE ;
							}

							SysFreeString ( t_PropertyName ) ;
						}
						else
						{
							t_Status = FALSE ;
						}

						VariantClear ( & t_Variant ) ;
					}
					else
					{
						t_Status = FALSE ;
					}
				}
			}
		}
		break ;

		case WMIQ_RPN_TOKEN_AND:
		{
			*a_Node = new WmiAndNode ( NULL , NULL , a_Parent ) ;
			if ( *a_Node ) 
			{
				WmiTreeNode **t_Left = NULL ;
				WmiTreeNode **t_Right = NULL ;
				(*a_Node)->GetLeft ( t_Left ) ;
				(*a_Node)->GetRight ( t_Right ) ;

				t_Status =	RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) &&
							RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Right , a_Index ) ;

			}
			else
			{
				t_Status = FALSE ;
			}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Operation = TOKEN_AND"
	) ;
)

		}
		break ;

		case WMIQ_RPN_TOKEN_OR:
		{
			*a_Node = new WmiOrNode ( NULL , NULL , a_Parent ) ;
			if ( *a_Node )
			{
				WmiTreeNode **t_Left = NULL ;
				WmiTreeNode **t_Right = NULL ;
				(*a_Node)->GetLeft ( t_Left ) ;
				(*a_Node)->GetRight ( t_Right ) ;

				t_Status =	RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) &&
							RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Right , a_Index ) ;
			}
			else
			{
				t_Status = FALSE ;
			}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  


		L"Operation = TOKEN_OR"
	) ;
)

		}
		break ;

		case WMIQ_RPN_TOKEN_NOT:
		{
			*a_Node = new WmiNotNode ( NULL , a_Parent ) ;
			if ( *a_Node )
			{
				WmiTreeNode **t_Left = NULL ;
				(*a_Node)->GetLeft ( t_Left ) ;

				t_Status = RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) ;
			}
			else
			{
				t_Status = FALSE ;
			}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Operation = TOKEN_NOT"
	) ;
)

		}
		break ;
	}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"RecursiveEvaluation t_Status = (%lu)" ,
		( ULONG ) t_Status
	) ;
)
	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL QueryPreprocessor :: Evaluate ( 

	void *a_Context ,
	SWbemRpnQueryToken **a_Expression , 
	int a_Count ,
	WmiTreeNode **a_Root 
)
{
	BOOL t_Status = TRUE ;

	if ( a_Count )
	{
		int t_Index = a_Count - 1 ; ;  
		t_Status = RecursiveEvaluate ( a_Context , a_Expression , NULL , a_Root , t_Index ) ;
	}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"PostEvaluation Status = (%lu)\n" ,
		( ULONG ) t_Status
	) ;
)

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: PrintTree ( WmiTreeNode *a_Root )
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Expression = "
	) ;

	if ( a_Root ) 
		a_Root->Print () ;

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"\n"
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformAndOrExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_AndChild , 
	WmiTreeNode *a_OrChild 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_OrLeftChild = a_OrChild->GetLeft () ;
	WmiTreeNode *t_OrRightChild = a_OrChild->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_NewOrNodeLeft = new WmiAndNode ( a_AndChild , t_OrLeftChild , t_NewOrNode ) ;
		if ( t_NewOrNodeLeft )
		{
			t_NewOrNode->SetLeft ( t_NewOrNodeLeft ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}

		WmiTreeNode *t_AndChildCopy = a_AndChild->Copy () ;
		if ( t_AndChildCopy )
		{
			WmiTreeNode *t_NewOrNodeRight = new WmiAndNode ( t_AndChildCopy , t_OrRightChild , t_NewOrNode ) ;
			if ( t_NewOrNodeRight )
			{
				t_NewOrNode->SetRight ( t_NewOrNodeRight ) ;
			}
			else
			{
				t_Status = :: State_Error ;
			}
		}
		else
		{
			t_Status = :: State_Error ;
		}

		if ( t_Parent )
		{
			if ( t_Parent->GetLeft () == a_Node )
			{
				t_Parent->SetLeft ( t_NewOrNode ) ;
			}
			else 
			{
				t_Parent->SetRight ( t_NewOrNode ) ;
			}	
		}

		a_Node->SetLeft ( NULL ) ;
		a_Node->SetRight ( NULL ) ;
		a_Node->SetData ( NULL ) ;

		a_OrChild->SetLeft ( NULL ) ;
		a_OrChild->SetRight ( NULL ) ;
		a_OrChild->SetData ( NULL ) ;

		delete a_Node ; 
		a_Node = NULL ;

		delete a_OrChild ; 
		a_OrChild = NULL ;
	}

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
		a_Node = NULL ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotNotExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	t_Leaf->SetParent ( t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_Leaf ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_Leaf ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	a_Node = t_Leaf ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotAndExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_AndLeftChild = a_Child->GetLeft () ;
	WmiTreeNode *t_AndRightChild = a_Child->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_LeftNot = new WmiNotNode ( t_AndLeftChild , t_NewOrNode ) ;
		if ( t_LeftNot )
		{
			t_NewOrNode->SetLeft ( t_LeftNot ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}

		WmiTreeNode *t_RightNot = new WmiNotNode ( t_AndRightChild , t_NewOrNode ) ;
		if ( t_RightNot )
		{
			t_NewOrNode->SetRight ( t_RightNot ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOrExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_OrLeftChild = a_Child->GetLeft () ;
	WmiTreeNode *t_OrRightChild = a_Child->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewAndNode = new WmiAndNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewAndNode )
	{
		WmiTreeNode *t_LeftNot = new WmiNotNode ( t_OrLeftChild , t_NewAndNode ) ;
		if ( t_LeftNot )
		{
			t_NewAndNode->SetLeft ( t_LeftNot ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}

		WmiTreeNode *t_RightNot = new WmiNotNode ( t_OrRightChild , t_NewAndNode ) ;
		if ( t_RightNot )
		{
			t_NewAndNode->SetRight ( t_RightNot ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewAndNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewAndNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewAndNode ;
	}
	else
	{
		delete t_NewAndNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_LessNode = new WmiOperatorLessNode  ( a_Child , t_NewOrNode ) ;
		if ( t_LessNode )
		{
			t_NewOrNode->SetLeft ( t_LessNode ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}

		WmiTreeNode *t_CopyGreaterChild = a_Child->Copy () ;
		if ( t_CopyGreaterChild )
		{
			WmiTreeNode *t_GreatorNode = new WmiOperatorGreaterNode  ( t_CopyGreaterChild , t_NewOrNode ) ;
			if ( t_GreatorNode )
			{
				t_NewOrNode->SetRight ( t_GreatorNode ) ;
			}
			else
			{
				t_Status = :: State_Error ;
			}
		}
		else
		{
			t_Status = :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotEqualNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualOrGreaterExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrLessNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualOrLessExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrGreaterNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorGreaterExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrLessNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorLessExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrGreaterNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorLikeExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotLikeNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotLikeExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorLikeNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorIsAExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotIsANode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotIsAExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorIsANode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformAndTrueEvaluation ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	if ( a_Node->GetLeft () == a_Child )
	{
		a_Node->SetLeft ( NULL ) ;
	}
	else
	{
		a_Node->SetRight ( NULL ) ;
	}

	WmiTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( a_Child ) ;
		}
		else 
		{
			t_Parent->SetRight ( a_Child ) ;
		}	
	}

	a_Child->SetParent ( t_Parent ) ;

	delete a_Node ;
	a_Node = a_Child ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformOrFalseEvaluation ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	if ( a_Node->GetLeft () == a_Child )
	{
		a_Node->SetLeft ( NULL ) ;
	}
	else
	{
		a_Node->SetRight ( NULL ) ;
	}

	WmiTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( a_Child ) ;
		}
		else 
		{
			t_Parent->SetRight ( a_Child ) ;
		}	

	}

	a_Child->SetParent ( t_Parent ) ;

	delete a_Node ;

	a_Node = a_Child ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformOperatorToRange ( 

	WmiTreeNode *&a_Node 
)
{
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiOperatorNode *t_OperatorNode = ( WmiOperatorNode * ) a_Node ;
	WmiRangeNode *t_Range = 0;
	if (t_OperatorNode->GetRange (t_Range) == State_True && t_Range)
	{
		if ( t_Parent )
		{
			if ( t_Parent->GetLeft () == a_Node )
			{
				t_Parent->SetLeft ( t_Range ) ;
			}
			else 
			{
				t_Parent->SetRight ( t_Range ) ;
			}	
		}

		t_Range->SetParent ( t_Parent ) ;
	}

	delete a_Node ;

	a_Node = t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateNotExpression ( WmiTreeNode *&a_Node )
{
	if ( a_Node->GetLeft () )
	{
		WmiTreeNode *t_Left = a_Node->GetLeft () ;
		if ( t_Left->GetType () == TypeId_WmiAndNode ) 
		{
			TransformNotAndExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOrNode ) 
		{
			TransformNotOrExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiNotNode ) 
		{
			TransformNotNotExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			TransformNotOperatorEqualExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			TransformNotOperatorNotEqualExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			TransformNotOperatorEqualOrGreaterExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			TransformNotOperatorEqualOrLessExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			TransformNotOperatorLessExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			TransformNotOperatorGreaterExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			TransformNotOperatorLikeExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			TransformNotOperatorNotLikeExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			TransformNotOperatorIsAExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			TransformNotOperatorNotIsAExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else
		{
			return :: State_False ; 
		}
	}

	return :: State_Error ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateNotEqualExpression ( WmiTreeNode *&a_Node )
{
	WmiTreeNode *t_Left = a_Node->GetLeft () ;

	TransformNotEqualExpression ( a_Node , t_Left ) ;
	return a_Node ? :: State_True : :: State_Error ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateAndExpression ( WmiTreeNode *&a_Node )
{
	WmiTreeNode *t_Left = a_Node->GetLeft () ;
	WmiTreeNode *t_Right = a_Node->GetRight () ;
	
	if ( t_Left )
	{
		if ( t_Left->GetType () == TypeId_WmiOrNode ) 
		{
			TransformAndOrExpression ( a_Node , t_Right , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
	}

	if ( t_Right )
	{
		if ( t_Right->GetType () == TypeId_WmiOrNode ) 
		{
			TransformAndOrExpression ( a_Node , t_Left , t_Right ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
	}

	return :: State_False ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateOrExpression ( WmiTreeNode *&a_Node )
{
	return :: State_False  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveDisjunctiveNormalForm ( WmiTreeNode *&a_Node )
{
	QueryPreprocessor :: QuadState t_Status = State_True ;
	WmiTriState tStatus = :: State_Error;
	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			if ( (tStatus = EvaluateAndExpression ( a_Node )) == :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else if (tStatus == :: State_Error)
			{
				t_Status = QuadState :: State_Error ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				WmiTreeNode *t_Right = a_Node->GetRight () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}

				if ( t_Right )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Right ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			if ( EvaluateOrExpression ( a_Node ) == :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				WmiTreeNode *t_Right = a_Node->GetRight () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}

				if ( t_Right )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Right ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
			if ( (tStatus = EvaluateNotExpression ( a_Node )) == :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else if (tStatus == ::State_Error)
			{
				t_Status = QuadState :: State_Error;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			if ( (tStatus = EvaluateNotEqualExpression ( a_Node )) == :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else if (tStatus == ::State_Error)
			{
				t_Status = QuadState::State_Error;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: DisjunctiveNormalForm ( WmiTreeNode *&a_Root ) 
{
	QueryPreprocessor :: QuadState t_Status = RecursiveDisjunctiveNormalForm ( a_Root ) ;
	if ( t_Status == QuadState :: State_ReEvaluate )
	{
		t_Status = DisjunctiveNormalForm ( a_Root ) ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveRemoveInvariants ( 

	void *a_Context , 
	WmiTreeNode *&a_Node
)
{
	QueryPreprocessor :: QuadState t_Status = State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Left ) ;

				if ( t_Status == State_False )
				{
					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Right
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context, a_Node ) ;
					return t_Status ;
				}
			}

			if ( t_Right )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Right ) ;

				if ( t_Status == State_False )
				{
					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Left
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Left ) ;
				if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Right
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}

			if ( t_Right )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Right ) ;

				if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Left
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{

// Should never happen, failure in DFN evaluation otherwise

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{

// Should never happen, failure in DFN evaluation otherwise

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{

// Should never happen, failure in DFN evaluation otherwise

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{

// Should never happen, failure in DFN evaluation otherwise

			_DBG_ASSERT(FALSE);

			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{

// Should never happen, failure in DFN evaluation otherwise
	
			_DBG_ASSERT(FALSE);

			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{

			// Should never happen, failure in DFN evaluation otherwise
			_DBG_ASSERT(FALSE);

			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{

			// Should never happen, failure in DFN evaluation otherwise
			_DBG_ASSERT(FALSE);

			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
			// Should never happen, failure in DFN evaluation otherwise

			_DBG_ASSERT(FALSE);
			
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
			// Should never happen, failure in DFN evaluation otherwise

			_DBG_ASSERT(FALSE);

			}
		}
		else
		{
		// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RemoveInvariants (

	void *a_Context , 
	WmiTreeNode *&a_Root
)
{
	QuadState t_Status = RecursiveRemoveInvariants ( a_Context , a_Root ) ;
	if ( t_Status == State_ReEvaluate )
	{
		t_Status = RemoveInvariants ( a_Context , a_Root ) ;
		if ( t_Status == State_False || t_Status == State_True )
		{
			delete a_Root ;
			a_Root = NULL ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveInsertNode ( WmiTreeNode *&a_Node , WmiTreeNode *&a_Insertion )
{
	WmiTriState t_Status = :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;

			if ( t_Left )
			{
				t_Status = RecursiveInsertNode ( t_Left , a_Insertion ) ;
				if ( t_Status != :: State_False )
				{
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Right  )
			{
				t_Status = RecursiveInsertNode ( t_Right , a_Insertion ) ;
				if ( t_Status != :: State_False )
				{
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
		// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
		// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
		else
		{
// Operator

			WmiValueNode *t_CompareValue = ( WmiValueNode * ) a_Node->GetLeft () ;
			WmiValueNode *t_InsertionValue = ( WmiValueNode * ) a_Insertion->GetLeft () ;
			LONG t_Compare = t_InsertionValue ->ComparePropertyName ( *t_CompareValue ) ;
			if ( t_Compare < 0 )
			{
// Insert to left

				WmiTreeNode *t_Parent = a_Node->GetParent () ;
				WmiTreeNode *t_NewAndNode = new WmiAndNode ( a_Insertion , a_Node , t_Parent ) ;
				if ( t_NewAndNode )
				{
					a_Node->SetParent ( t_NewAndNode ) ;
					a_Insertion->SetParent ( t_NewAndNode ) ;

					if ( t_Parent )
					{
						if ( t_Parent->GetLeft () == a_Node )
						{
							t_Parent->SetLeft ( t_NewAndNode ) ;
						}
						else
						{
							t_Parent->SetRight ( t_NewAndNode ) ;
						}
					}

					a_Node = t_NewAndNode ;

					t_Status = :: State_True ;
				}
				else
				{
					t_Status = :: State_Error ; 
				}
			}
			else
			{
				t_Status = :: State_False  ;
			}
		}
	}
	else
	{
		a_Node = a_Insertion ;

		t_Status = :: State_True ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState  QueryPreprocessor :: InsertNode ( WmiTreeNode *&a_NewRoot , WmiTreeNode *&a_Insertion )
{
	WmiTriState t_Status = RecursiveInsertNode ( a_NewRoot , a_Insertion ) ;
	if ( t_Status == :: State_False  )
	{
// Insert to right

		WmiTreeNode *t_Parent = a_NewRoot->GetParent () ;
		WmiTreeNode *t_NewAndNode = new WmiAndNode ( a_NewRoot , a_Insertion , t_Parent ) ;
		if ( t_NewAndNode )
		{
			a_NewRoot->SetParent ( t_NewAndNode ) ;
			a_Insertion->SetParent ( t_NewAndNode ) ;

			if ( t_Parent )
			{
				if ( t_Parent->GetLeft () == a_NewRoot )
				{
					t_Parent->SetLeft ( t_NewAndNode ) ;
				}
				else
				{
					t_Parent->SetRight ( t_NewAndNode ) ;
				}
			}

			a_NewRoot = t_NewAndNode ;
		}
		else
		{
			return :: State_Error ;
		}
	}

	return :: State_True ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveSortConditionals ( WmiTreeNode *&a_NewRoot , WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveSortConditionals ( a_NewRoot , t_Left  ) ;
				a_Node->SetLeft ( NULL ) ;
				delete t_Left ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveSortConditionals ( a_NewRoot , t_Right ) ;
				a_Node->SetRight ( NULL ) ;
				delete t_Right ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
		// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
		// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
		else
		{
// Operator

			WmiTreeNode *t_Parent = a_Node->GetParent () ;
			if ( t_Parent ) 
			{
				if ( t_Parent->GetLeft () == a_Node )
				{
					t_Parent->SetLeft ( NULL ) ;
				}
				else
				{
					t_Parent->SetRight ( NULL ) ;
				}
			}

			a_Node->SetParent ( NULL ) ;

			t_Status = InsertNode ( a_NewRoot , a_Node ) ;

			a_Node = NULL ;
		}		
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: SortConditionals ( WmiTreeNode *&a_Root )
{
	WmiTreeNode *t_NewRoot = NULL ;
	WmiTriState t_Status = RecursiveSortConditionals ( t_NewRoot , a_Root ) ;

    if ( a_Root )
    {
	    WmiTreeNode *t_Parent = a_Root->GetParent () ;
	    if ( t_Parent ) 
	    {
		    if ( t_Parent->GetLeft () == a_Root )
		    {
			    t_Parent->SetLeft ( t_NewRoot ) ;
		    }
		    else
		    {
			    t_Parent->SetRight ( t_NewRoot ) ;
		    }
	    }

	    t_NewRoot->SetParent ( t_Parent ) ;

	    delete a_Root ;
    }

	a_Root = t_NewRoot ;

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveSort ( WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveSort ( t_Left ) ;
			}

			if ( t_Status == :: State_True )
			{
				if ( t_Right  )
				{
					t_Status = RecursiveSort ( t_Right ) ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			t_Status = SortConditionals ( a_Node ) ;
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
		// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
		else
		{
// Single operand
			t_Status = :: State_True ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: Sort ( WmiTreeNode *&a_Root )
{
	WmiTriState t_Status = RecursiveSort ( a_Root ) ;
	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveConvertToRanges ( WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = :: State_True ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveConvertToRanges ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveConvertToRanges ( t_Right ) ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveConvertToRanges ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveConvertToRanges ( t_Right ) ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
		// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else
		{
		// Should never happen, failure in DFN evaluation otherwise

		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: ConvertToRanges ( WmiTreeNode *&a_Root )
{
	return RecursiveConvertToRanges ( a_Root ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformIntersectingRange (

	WmiTreeNode *&a_Node ,
	WmiTreeNode *a_Compare ,
	WmiTreeNode *a_Intersection
)
{
	WmiTreeNode *t_CompareParent = a_Compare->GetParent () ;
	if ( t_CompareParent )
	{
		if ( t_CompareParent->GetLeft () == a_Compare )
		{
			t_CompareParent->SetLeft ( a_Intersection ) ;
		}
		else
		{
			t_CompareParent->SetRight ( a_Intersection ) ;
		}

		a_Intersection->SetParent ( t_CompareParent ) ;

		delete a_Compare ; 
		a_Compare = NULL ;
	}
	else
	{
	// Should never happen

	_DBG_ASSERT(FALSE);

	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNonIntersectingRange (

	WmiTreeNode *&a_Node ,
	WmiTreeNode *a_Compare
) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveRemoveNonOverlappingRanges ( WmiTreeNode *&a_Node , WmiTreeNode *&a_Compare )
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				a_Compare = NULL ;
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Left , a_Compare ) ;
				if ( t_Status == State_False )
				{
					WmiTreeNode *t_Right = a_Node->GetRight () ;

					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Right
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				a_Compare = NULL ;
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Right , a_Compare ) ;
				if ( t_Status == State_False )
				{
					WmiTreeNode *t_Left = a_Node->GetLeft () ;

					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Left
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Left , a_Compare ) ;
				if ( t_Status == State_True )
				{
					WmiTreeNode *t_Right = a_Node->GetRight () ;

					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Right
					) ;

					a_Compare = NULL ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Right , a_Compare ) ;

				if ( t_Status == State_True )
				{
					WmiTreeNode *t_Left = a_Node->GetLeft () ;

					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Left
					) ;

                    a_Compare = NULL;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNullRangeNode ) 
		{
			WmiRangeNode *t_Node = ( WmiRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiNullRangeNode ) 
					{
						WmiTreeNode *t_Intersection = a_Node->Copy () ;

						TransformIntersectingRange (

							a_Node ,
							a_Compare ,
							t_Intersection
						) ;

						a_Compare = t_Intersection ;

						t_Status = QueryPreprocessor :: QuadState :: State_True ;
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiStringRangeNode ) 
		{
			WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiStringRangeNode ) 
					{
						WmiStringRangeNode *t_StringRange = ( WmiStringRangeNode * ) t_Range ;

						WmiStringRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_StringRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break ;

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) 
		{
			WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) 
					{
						WmiUnsignedIntegerRangeNode *t_IntegerRange = ( WmiUnsignedIntegerRangeNode * ) t_Range ;

						WmiUnsignedIntegerRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_IntegerRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break; 

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiSignedIntegerRangeNode ) 
		{
			WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiSignedIntegerRangeNode ) 
					{
						WmiSignedIntegerRangeNode *t_IntegerRange = ( WmiSignedIntegerRangeNode * ) t_Range ;

						WmiSignedIntegerRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_IntegerRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break ;

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else
		{
		// Should never happen, failure in DNF evaluation otherwise
		_DBG_ASSERT(FALSE);

		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RemoveNonOverlappingRanges  ( WmiTreeNode *&a_Root )
{
	WmiTreeNode *t_Compare = NULL ;

	QueryPreprocessor :: QuadState t_Status = RecursiveRemoveNonOverlappingRanges ( a_Root , t_Compare ) ;
	if ( t_Status == State_ReEvaluate )
	{
		t_Status = RemoveNonOverlappingRanges ( a_Root ) ;
		if ( t_Status == State_False || t_Status == State_True )
		{
			delete a_Root ;
			a_Root = NULL ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: CountDisjunctions ( WmiTreeNode *a_Node , ULONG &a_Count ) 
{
	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			a_Count ++ ;

			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				CountDisjunctions ( t_Left , a_Count ) ;
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				CountDisjunctions ( t_Right , a_Count ) ;
			}
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: CreateDisjunctions ( 

	void *a_Context , 
	WmiTreeNode *a_Node , 
	Disjunctions *a_Disjunctions , 
	ULONG a_PropertiesToPartitionCount ,
	BSTR *a_PropertiesToPartition ,
	ULONG &a_DisjunctionIndex
) 
{
	WmiTriState t_Status = :: State_True ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = CreateDisjunctions ( 

					a_Context , 
					t_Left , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex 
				) ;
			}

			if ( t_Status == :: State_True )
			{
				Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;

				for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
				{
					if ( t_Disjunction->GetRange ( t_Index ) == NULL )
					{
						WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

							a_Context ,
							a_PropertiesToPartition [ t_Index ] 
						) ;

						if ( t_RangeNode )
						{
							t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
						}
						else
						{
							t_Status = :: State_Error ;
							break ;
						}
					}
				}
			}

			a_DisjunctionIndex ++ ;

			if ( t_Status == :: State_True )
			{
				WmiTreeNode *t_Right = a_Node->GetRight () ;
				if ( t_Right )
				{
					t_Status = CreateDisjunctions ( 

						a_Context ,
						t_Right , 
						a_Disjunctions ,
						a_PropertiesToPartitionCount ,
						a_PropertiesToPartition ,
						a_DisjunctionIndex
					) ;
				}

				if ( t_Status == :: State_True )
				{
					Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;

					for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
					{
						if ( t_Disjunction->GetRange ( t_Index ) == NULL )
						{
							WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

								a_Context ,
								a_PropertiesToPartition [ t_Index ] 
							) ;

							if ( t_RangeNode )
							{
								t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
							}
							else
							{
								t_Status = :: State_Error ; 
							}
						}
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = CreateDisjunctions ( 

					a_Context ,
					t_Left , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex
				) ;
			}

			if ( t_Status == :: State_True )
			{
				WmiTreeNode *t_Right = a_Node->GetRight () ;
				if ( t_Right )
				{
					t_Status = CreateDisjunctions ( 

						a_Context , 
						t_Right , 
						a_Disjunctions ,
						a_PropertiesToPartitionCount ,
						a_PropertiesToPartition ,
						a_DisjunctionIndex
					) ;
				}
			}
		}
		else
		{
			Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;
			WmiRangeNode *t_Node = ( WmiRangeNode * ) a_Node ;
			BSTR t_PropertyName = t_Node->GetPropertyName () ;
			for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
			{
				if ( wbem_wcsicmp ( t_PropertyName , a_PropertiesToPartition [ t_Index ] ) == 0 )
				{
					WmiRangeNode *t_NodeCopy = ( WmiRangeNode * ) t_Node->Copy () ;
					if ( t_NodeCopy )
					{
						t_Disjunction->SetRange ( t_Index , t_NodeCopy ) ;
					}
					else
					{
						t_Status = :: State_Error ;
					}

					break ;
				}
			}			
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: CreateDisjunctionContainer ( 

	void *a_Context , 
	WmiTreeNode *a_Root , 
	ULONG a_Count , 
	BSTR *a_Container , 
	Disjunctions *&a_Disjunctions
)
{
	WmiTriState t_Status = :: State_True ;

	if ( a_Count && a_Container )
	{
		ULONG t_PropertiesToPartitionCount = a_Count ;
		BSTR *t_PropertiesToPartition = a_Container ;

		ULONG t_Count = 1 ;
		CountDisjunctions ( a_Root , t_Count ) ;
		a_Disjunctions = new Disjunctions ( t_Count , t_PropertiesToPartitionCount ) ;
		if ( a_Disjunctions )
		{
			t_Status = a_Disjunctions->Initialize () ;
			if ( t_Status == :: State_True )
			{
				t_Count = 0 ; 
				t_Status = CreateDisjunctions ( 

					a_Context , 
					a_Root , 
					a_Disjunctions ,
					t_PropertiesToPartitionCount ,
					t_PropertiesToPartition ,
					t_Count
				) ;

				if ( t_Status == :: State_True )
				{
					Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( 0 ) ;

					for ( ULONG t_Index = 0 ; t_Index < t_PropertiesToPartitionCount ; t_Index ++ )
					{
						if ( t_Disjunction->GetRange ( t_Index ) == NULL )
						{
							WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

								a_Context ,
								t_PropertiesToPartition [ t_Index ] 
							) ;

							if ( t_RangeNode )
							{
								t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
							}
							else
							{
								t_Status = :: State_Error ;
								break ;
							}
						}
					}
				}
			}
		}
		else
		{
			t_Status = :: State_Error ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintInit (

	Disjunctions *a_Disjunctions , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
	ULONG a_KeyIndex 
)
{
   	for ( ULONG t_Index = 0 ; t_Index < a_KeyIndex ; t_Index ++ )
    {
        DebugMacro3( 

            WmiDebugLog :: s_WmiDebugLog->Write (  

	            L"    "
            ) ;
        )
    }

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
    {
        DebugMacro3( 

            WmiDebugLog :: s_WmiDebugLog->Write (  

	            L"%lu", a_DisjunctionSetToTest [ t_Index ] ? 1 : 0
            ) ;
        )
    }

    DebugMacro3( 

        WmiDebugLog :: s_WmiDebugLog->Write (  

	        L"\n"
        ) ;
    )

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
	{
    	for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < a_KeyIndex ; t_InnerIndex ++ )
        {
            DebugMacro3( 

                WmiDebugLog :: s_WmiDebugLog->Write (  

	                L"    "
                ) ;
            )
        }

		Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( t_Index ) ;
		if ( t_Disjunction )
		{
			if (WmiRangeNode * range = t_Disjunction->GetRange ( a_KeyIndex ))
			{
				range->Print () ;

				DebugMacro3( 

					WmiDebugLog :: s_WmiDebugLog->Write (  

						L"\n"
				) ;
			)
			}
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintSortedRange (

	Disjunctions *a_Disjunctions , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
    ULONG *a_OriginToSorted ,
	ULONG a_KeyIndex ,
    WmiRangeNode **a_RangeTable
)
{
	for ( ULONG t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
	{
   		if ( a_RangeTable [ t_Index ] )
        {
    	    for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < a_KeyIndex ; t_InnerIndex ++ )
            {
                DebugMacro3( 

                    WmiDebugLog :: s_WmiDebugLog->Write (  

	                    L"%lu    ", t_Index
                    ) ;
                )
            }

            if ( a_DisjunctionSetToTest [ a_OriginToSorted [ t_Index ] ] )
            {
                DebugMacro3( 

                    WmiDebugLog :: s_WmiDebugLog->Write (  

	                    L"In "
                    ) ;
				)
            }
            else
            {
                DebugMacro3( 

                    WmiDebugLog :: s_WmiDebugLog->Write (  

	                    L"Out "
                    ) ;
				)
            }

		    a_RangeTable [ t_Index ]->Print () ;

            DebugMacro3( 

                WmiDebugLog :: s_WmiDebugLog->Write (  

	                L"\n"
                ) ;
            )
        }
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintOverlap (

	ULONG a_DisjunctionSetToTestCount ,
   	ULONG *a_DisjunctionSetToTest ,
	ULONG *a_SortedDisjunctionSetToTest ,
    ULONG *a_OverlappingIndex ,
  	ULONG a_KeyIndex 
)
{
	for ( ULONG t_Index = 0 ; t_Index < a_KeyIndex ; t_Index ++ )
    {
DebugMacro3( 

    WmiDebugLog :: s_WmiDebugLog->Write (  

	    L"    "
    ) ;
)
    }

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
    {
DebugMacro3( 

    if ( a_DisjunctionSetToTest [ t_Index ] )
    {
        WmiDebugLog :: s_WmiDebugLog->Write (  

	        L"%lu ",  a_OverlappingIndex [ t_Index ]
        ) ;
    }
    else
    {
        WmiDebugLog :: s_WmiDebugLog->Write (  

	        L"X "
        ) ;
    }
)
    }

DebugMacro3( 

    WmiDebugLog :: s_WmiDebugLog->Write (  

	    L"\n"
    ) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: RecursiveQuickSort (

	WmiRangeNode **a_Array , 
    ULONG *a_UnsortedOrder ,
	ULONG a_Lower , 
	ULONG a_Upper
)
{
	if ( a_Lower <= a_Upper )
	{
		ULONG t_LeftIndex = a_Lower ; 
		ULONG t_RightIndex = a_Upper ;

		while ( true )
		{
			while ( ( t_LeftIndex < t_RightIndex ) && CompareLessOrEqualRangeNode ( a_Array [ t_LeftIndex ]  , a_Array [ a_Lower - 1 ] ) )
			{
				t_LeftIndex ++ ;
			}

			while ( ( t_LeftIndex < t_RightIndex ) && CompareLessOrEqualRangeNode ( a_Array [ a_Lower - 1 ]  , a_Array [ t_RightIndex ] ) )
			{
				t_RightIndex -- ;
			}

			if ( t_LeftIndex < t_RightIndex ) 
			{
				WmiRangeNode *t_Temp = a_Array [ t_LeftIndex ] ;
				a_Array [ t_LeftIndex ] = a_Array [ t_RightIndex ] ;
				a_Array [ t_RightIndex ] = t_Temp ;

				ULONG t_Val = a_UnsortedOrder [ t_LeftIndex ] ;
				a_UnsortedOrder [ t_LeftIndex ] = a_UnsortedOrder [ t_RightIndex ];
				a_UnsortedOrder [ t_RightIndex ] = t_Val ;
			}
			else
			{
				break ;
			}
		}

		LONG t_Compare = CompareLessOrEqualRangeNode ( a_Array [ t_LeftIndex ] , a_Array [ a_Lower - 1 ] ) ;
		if ( t_Compare )
		{
			WmiRangeNode *t_Temp = a_Array [ t_LeftIndex ] ;
			a_Array [ t_LeftIndex ] = a_Array [ a_Lower - 1 ] ;
			a_Array [ a_Lower - 1 ] = t_Temp ;

			ULONG t_Val = a_UnsortedOrder [ t_LeftIndex ] ;
			a_UnsortedOrder [ t_LeftIndex ] = a_UnsortedOrder [ a_Lower - 1 ];
			a_UnsortedOrder [ a_Lower - 1 ] = t_Val ;
		}

		RecursiveQuickSort ( 

			a_Array , 
			a_UnsortedOrder ,
			a_Lower , 
			t_LeftIndex - 1 
		) ;

 		RecursiveQuickSort ( 

			a_Array  , 
			a_UnsortedOrder ,
			t_LeftIndex + 1 , 
			a_Upper
		) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: QuickSort (

	WmiRangeNode **a_Array , 
    ULONG *a_UnsortedOrder ,
	ULONG a_Size
)
{
	RecursiveQuickSort ( a_Array , a_UnsortedOrder , 1 , a_Size - 1 ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: SortRanges (

	ULONG t_DisjunctionCount ,
    ULONG *t_OriginToSorted ,
	WmiRangeNode **t_RangeTable 
)
{
	QuickSort (	t_RangeTable , t_OriginToSorted , t_DisjunctionCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RemoveOverlaps (

	ULONG *a_DisjunctionSetToTest ,
	ULONG a_DisjunctionCount ,
	ULONG *a_OverlappingIndex ,
    ULONG *a_OriginToSorted ,
	WmiRangeNode **a_RangeTable 
)
{
	WmiTriState t_Status = :: State_True ;

/*
 *  Remove Overlaps
 */

	ULONG t_InnerIndex = 0 ;
	ULONG t_OuterIndex = 1 ;

	while ( ( t_Status != :: State_Error ) && ( t_OuterIndex < a_DisjunctionCount ) )
	{
		WmiRangeNode *t_LeftRange = a_RangeTable [ t_OuterIndex ] ;
		WmiRangeNode *t_RightRange = a_RangeTable [ t_InnerIndex ] ;

		if ( a_OverlappingIndex [ t_OuterIndex ] != a_OverlappingIndex [ t_InnerIndex ] )
		{
			if ( t_LeftRange && t_RightRange )
			{
				if ( ( t_LeftRange->GetType () == TypeId_WmiStringRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiStringRangeNode ) )
				{
					WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) t_LeftRange ;
					WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) t_RightRange ;
    				WmiStringRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftString->GetOverlappingRange ( *t_RightString , t_OverLap ) ;
					if ( t_Status == :: State_True )
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Overlap\n"
	) ;
)

						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;

						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
					}
					else
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else if ( ( t_LeftRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) )
				{
					WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) t_LeftRange ;
					WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) t_RightRange ;
    				WmiUnsignedIntegerRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftInteger->GetOverlappingRange ( *t_RightInteger , t_OverLap ) ;
					if ( t_Status == :: State_True )
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Overlap\n"
	) ;
)
						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;
						
						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
                    }
					else
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else if ( ( t_LeftRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) )
				{
					WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) t_LeftRange ;
					WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) t_RightRange ;
    				WmiSignedIntegerRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftInteger->GetOverlappingRange ( *t_RightInteger , t_OverLap ) ;
					if ( t_Status == :: State_True )
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Overlap\n"
	) ;
)
						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;
						
						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
                    }
					else
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else
				{
// Failure
					t_Status = :: State_Error ;  
				}
			}
		}

		t_InnerIndex ++ ;
		t_OuterIndex ++ ;
	}

	for ( LONG t_Index = a_DisjunctionCount - 1 ; t_Index >= 0 ; t_Index -- )
	{
		if ( t_Index < a_OverlappingIndex [ t_Index ] )
		{
			a_OverlappingIndex [ t_Index ] = a_OverlappingIndex [ a_OverlappingIndex [ t_Index ] ] ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursivePartitionSet ( 

	Disjunctions *a_Disjunctions , 
	PartitionSet *&a_Partition , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
	ULONG a_KeyIndex 
)
{
	WmiTriState t_Status = :: State_True ;

	if ( a_KeyIndex < a_Disjunctions->GetConjunctionCount () )
	{
		ULONG *t_OverlappingIndex = new ULONG [ a_DisjunctionSetToTestCount ] ;
		wmilib::auto_buffer<ULONG> autoOverlappingIndex(t_OverlappingIndex);

        ULONG *t_OriginToSorted = new ULONG [ a_DisjunctionSetToTestCount ] ;
        wmilib::auto_buffer<ULONG> autoOriginToSorted(t_OriginToSorted);
        
		WmiRangeNode **t_RangeTable = new WmiRangeNode * [ a_DisjunctionSetToTestCount ] ;
		wmilib::auto_buffer<WmiRangeNode *> autoRangeTable(t_RangeTable);
			
		if ( t_OverlappingIndex && t_OriginToSorted && t_RangeTable )
		{
			for ( ULONG t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
			{
				Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionSetToTest [ t_Index ] ) ;
				if (NULL == t_Disjunction) 
				{
					t_Status = ::State_Error;
					break;
				}
				
				t_RangeTable [ t_Index ] = ( WmiRangeNode * ) t_Disjunction->GetRange ( a_KeyIndex )->Copy () ;
				t_OverlappingIndex [ t_Index ] = t_Index ;
				t_OriginToSorted [ t_Index ] = t_Index ;
			}

// Sort Partitions
			if ( t_Status != :: State_Error )
			{
				SortRanges (

					a_DisjunctionSetToTestCount ,
					t_OriginToSorted ,
					t_RangeTable 
				) ;

				t_Status = RemoveOverlaps (

					a_DisjunctionSetToTest ,
					a_DisjunctionSetToTestCount ,
					t_OverlappingIndex ,
					t_OriginToSorted ,
					t_RangeTable 
				) ;
			}

			if ( t_Status != :: State_Error )
			{
				ULONG t_PartitionCount = 0 ;
				for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
				{
					if ( t_RangeTable [ t_Index ] )
					{
						t_PartitionCount ++ ;
					}
				}

				t_Status = a_Partition->Initialize ( t_PartitionCount ) ;
				if ( t_Status == :: State_True )
				{
					ULONG t_PartitionIndex = 0 ;
					for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount; t_Index ++ )
					{
						WmiRangeNode *t_Range = t_RangeTable [ t_Index ] ;
						if ( t_Range )
						{
							PartitionSet *t_Partition = new PartitionSet ;
							if ( t_Partition )
							{
								a_Partition->SetPartition ( t_PartitionIndex , t_Partition ) ;

								WmiRangeNode *t_Copy = ( WmiRangeNode * ) t_Range->Copy () ;
								if ( t_Copy )
								{
									t_Partition->SetRange ( t_Copy ) ;
									t_Partition->SetKeyIndex ( a_KeyIndex ) ;
									t_PartitionIndex ++ ;
								}
								else
								{
									t_Status = :: State_Error ; 
									break ;
								}
							}
							else
							{
								t_Status = :: State_Error ; 
								break ;
							}
						}
					}
				}

				if ( t_Status == :: State_True )
				{
/*
 *  Outer Index is the range order
 */
					ULONG t_PartitionIndex = 0 ;

/*
 *	Array allocation has max defined by function arg.
 */

					ULONG *t_DisjunctionSetToTest = new ULONG [ a_DisjunctionSetToTestCount ] ;
					if ( t_DisjunctionSetToTest )
					{
						ULONG t_OuterIndex = 0 ;
						while ( t_Status && ( t_OuterIndex < a_DisjunctionSetToTestCount ) )
						{
							BOOL t_Found = FALSE ;

							ULONG t_DisjunctionSetToTestCount = 0 ;

							if ( t_RangeTable [ t_OuterIndex ] )
							{
/*
 * Inner index matches the overlaps
 */

								LONG t_InnerIndex = t_OuterIndex ;
								while ( t_InnerIndex >= 0 )
								{
									if ( t_OverlappingIndex [ t_OuterIndex ] == t_OverlappingIndex [ t_InnerIndex ] )
									{
										t_DisjunctionSetToTest [ t_DisjunctionSetToTestCount ] = a_DisjunctionSetToTest [ t_OriginToSorted [ t_InnerIndex ] ] ;
										t_DisjunctionSetToTestCount ++ ;
										t_Found = TRUE ;
									}
									else
									{
										break ;
									}

									t_InnerIndex -- ;
								}
							}

    						if ( t_Found )
							{
								PartitionSet *t_Partition = a_Partition->GetPartition ( t_PartitionIndex ) ;
								if ( t_Partition )
								{
									t_Status = RecursivePartitionSet (

										a_Disjunctions ,
										t_Partition ,
										t_DisjunctionSetToTestCount ,
										t_DisjunctionSetToTest ,
										a_KeyIndex + 1
									) ;

									t_PartitionIndex ++ ;
								}
							}

							t_OuterIndex ++ ;
						}

						delete [] t_DisjunctionSetToTest ;
					}
					else
					{
						t_Status = :: State_Error ; 
					}
				}
			}
			else
			{
				t_Status = :: State_Error ; 
			}

			for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
			{
				if ( t_RangeTable [ t_Index ] )
				{
					delete t_RangeTable [ t_Index ] ;
				}
			}
		}
		else
		{
			t_Status = :: State_Error ; 
		}

	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: CreatePartitionSet ( Disjunctions *a_Disjunctions , PartitionSet *&a_Partition )
{
	WmiTriState t_Status = :: State_False ;

	a_Partition = NULL ;

	ULONG t_DisjunctionCount = a_Disjunctions->GetDisjunctionCount () ;
	ULONG *t_DisjunctionSetToTest = new ULONG [ t_DisjunctionCount ] ;
	if ( t_DisjunctionSetToTest )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
		{
			t_DisjunctionSetToTest [ t_Index ] = t_Index ;
		}

		a_Partition = new PartitionSet ;
		if ( a_Partition )
		{
			t_Status = RecursivePartitionSet (

				a_Disjunctions ,
				a_Partition ,
				t_DisjunctionCount ,
				t_DisjunctionSetToTest ,
				0
			) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}

		delete [] t_DisjunctionSetToTest ;
	}
	else
	{
		t_Status = :: State_Error ;
	}

	return t_Status;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: PreProcess (

	void *a_Context ,																
	IWbemQuery *a_QueryAnalysis ,
	WmiTreeNode *&a_Root 
)
{
	QuadState t_State = State_Error ;

	SWbemRpnEncodedQuery *t_Expression = NULL ;

	HRESULT t_Result = a_QueryAnalysis->GetAnalysis (

		WMIQ_ANALYSIS_RPN_SEQUENCE ,
        0 ,
        ( void ** ) & t_Expression
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		BOOL t_Status = Evaluate ( 
		
			a_Context , 
			( t_Expression->m_ppRpnWhereClause ) , 
			( t_Expression->m_uWhereClauseSize ) , 
			& a_Root
		) ;

		if ( t_Status )
		{
			t_State = State_True ;

			PrintTree ( a_Root ) ;
        
			t_State = DisjunctiveNormalForm ( a_Root ) ;

			PrintTree ( a_Root ) ;
		}

		a_QueryAnalysis->FreeMemory ( t_Expression ) ;
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: Query ( 

	BSTR a_Query ,
	IWbemQuery *a_QueryAnalysis
)
{
	QuadState t_State = State_Error ;

	ULONG t_Array [] = { 

		WMIQ_LF1_BASIC_SELECT ,
		WMIQ_LF2_CLASS_NAME_IN_QUERY ,
		WMIQ_LF3_STRING_CASE_FUNCTIONS ,
		WMIQ_LF4_PROP_TO_PROP_TESTS ,
		WMIQ_LF8_ISA ,
		WMIQ_LF9_THIS ,
		WMIQ_LF26_LIKE
	} ;
 
	ULONG t_ArraySize = sizeof ( t_Array ) / sizeof ( ULONG ) ;

    HRESULT t_Result = a_QueryAnalysis->SetLanguageFeatures (

        0 ,
        t_ArraySize ,
        t_Array
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_QueryAnalysis->Parse ( L"WQL" , a_Query , 0 ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_State = State_True ;
		}
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QueryPreprocessor () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: ~QueryPreprocessor () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define SYSTEM_PROPERTY_DYNASTY				L"__DYNASTY"
#define SYSTEM_PROPERTY_DERIVATION			L"__DERIVATION"
#define SYSTEM_PROPERTY_GENUS				L"__GENUS"
#define SYSTEM_PROPERTY_NAMESPACE			L"__NAMESPACE"
#define SYSTEM_PROPERTY_PROPERTY_COUNT		L"__PROPERTY_COUNT"
#define SYSTEM_PROPERTY_SERVER				L"__SERVER"
#define SYSTEM_PROPERTY_RELPATH				L"__RELPATH"
#define SYSTEM_PROPERTY_PATH				L"__PATH"

#define SYSTEM_PROPERTY_CLASS				L"__CLASS"
#define SYSTEM_PROPERTY_SUPERCLASS			L"__SUPERCLASS"
#define SYSTEM_PROPERTY_THIS				L"__THIS"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *QueryPreprocessor :: AllocTypeNode ( 

	void *a_Context ,
	BSTR a_PropertyName , 
	VARIANT &a_Variant , 
	WmiValueNode :: WmiValueFunction a_PropertyFunction ,
	WmiValueNode :: WmiValueFunction a_ConstantFunction ,
	WmiTreeNode *a_Parent 
)
{
	WmiTreeNode *t_Node = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	if ( *a_PropertyName == L'_' )
	{
// System property

		if ( wbem_wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( wbem_wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_THIS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( wbem_wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
	}

	if ( t_Node && !t_Node->IsValid())
	{
		delete t_Node;
		t_Node = 0;
	}

	return t_Node ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provinterceptor.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"

#include <wbemint.h>
#include <stdio.h>
#include "CGlobals.h"
#include "Globals.h"
#include "ProvInterceptor.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemDecoupledUnboundObjectSink :: CInterceptor_IWbemDecoupledUnboundObjectSink (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) :	VoidPointerContainerElement (

		a_Controller ,
		this 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Registration ( & a_Registration ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_UnBoundSync_Size , MAX_PROXIES )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledUnboundObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		m_Unknown = a_ServerSideProvider ;
		m_Unknown->AddRef () ;

		HRESULT t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemDecoupledUnboundObjectSink :: ~CInterceptor_IWbemDecoupledUnboundObjectSink ()
{
	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}
	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledUnboundObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: Initialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemDecoupledUnboundObjectSink :: AddRef ()
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemDecoupledUnboundObjectSink :: Release ()
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemDecoupledUnboundObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID__IWmiProviderSite )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderSite * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: Internal_IndicateToConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = IndicateToConsumer (


			a_LogicalConsumer ,
			a_ObjectCount ,
			a_Objects
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_UnBoundSync_IWbemUnboundObjectSink , IID_IWbemUnboundObjectSink , m_Provider_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Provider_IWbemUnboundObjectSink->IndicateToConsumer (


					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemUnboundObjectSink *t_Provider = ( IWbemUnboundObjectSink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Provider->IndicateToConsumer (

							a_LogicalConsumer ,
							a_ObjectCount ,
							a_Objects
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_UnBoundSync_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: GetSite ( DWORD *a_ProcessIdentifier )
{
	HRESULT t_Result = S_OK ;

	if ( a_ProcessIdentifier ) 
	{
		*a_ProcessIdentifier = GetCurrentProcessId () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: SetContainer ( IUnknown *a_Container )
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CDecoupled_IWbemSyncObjectSink :: CDecoupled_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	: CCommon_IWbemSyncObjectSink ( 

		a_Allocator ,
		a_InterceptedSink ,
		a_Unknown ,
		a_Controller ,
		a_Dependant 
	) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CDecoupled_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_IWbemSyncObjectSink :: ~CDecoupled_IWbemSyncObjectSink ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CDecoupled_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CDecoupled_Batching_IWbemSyncObjectSink :: CDecoupled_Batching_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	: CCommon_Batching_IWbemSyncObjectSink ( 

		a_Allocator ,
		a_InterceptedSink ,
		a_Unknown ,
		a_Controller ,
		a_Dependant 
	) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CDecoupled_Batching_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_Batching_IWbemSyncObjectSink :: ~CDecoupled_Batching_IWbemSyncObjectSink ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CDecoupled_Batching_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_DecoupledClient :: CInterceptor_DecoupledClient (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	IWbemServices *a_CoreStub ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) :	m_ReferenceCount ( 0 ) ,
	m_Allocator ( a_Allocator ) ,
	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemServices ( NULL ) ,
	m_Provider_IWbemPropertyProvider ( NULL ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_CoreStub ( a_CoreStub ) ,
	m_Registration ( & a_Registration ) ,
	m_Locale ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_Provider_Size , MAX_PROXIES )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_DecoupledClient_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		m_Unknown = a_ServerSideProvider ;
		m_Unknown->AddRef () ;

		HRESULT t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemServices , ( void ** ) & m_Provider_IWbemServices ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemPropertyProvider , ( void ** ) & m_Provider_IWbemPropertyProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_DecoupledClient :: ~CInterceptor_DecoupledClient ()
{
	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemServices )
	{
		m_Provider_IWbemServices->Release () ; 
	}

	if ( m_Provider_IWbemPropertyProvider )
	{
		m_Provider_IWbemPropertyProvider->Release () ; 
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		m_Provider_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->Release () ;
	}

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_DecoupledClient_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_DecoupledClient :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_DecoupledClient :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_DecoupledClient :: QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	if ( a_Riid == IID_IWbemProviderInit )
	{
		*a_Void = ( LPVOID ) ( IWbemProviderInit * ) this ;
	}
	if ( a_Riid == IID_Internal_IWbemProviderInit )
	{
		*a_Void = ( LPVOID ) ( Internal_IWbemProviderInit * ) this ;
	}
	else if ( a_Riid == IID_IWbemServices )
	{
		if ( m_Provider_IWbemServices )
		{
			*a_Void = ( LPVOID ) ( IWbemServices * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemPropertyProvider )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			*a_Void = ( LPVOID ) ( IWbemPropertyProvider * ) this ;
		}
	}	
	else if ( a_Riid == IID_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*a_Void = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*a_Void = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*a_Void = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( a_Riid == IID__IWmiProviderInitialize )
	{
		*a_Void = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;		
	}
	else if ( a_Riid == IID__IWmiProviderSite )
	{
		*a_Void = ( LPVOID ) ( _IWmiProviderSite * ) this ;		
	}
	else if ( a_Riid == IID_IWbemShutdown )
	{
		*a_Void = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}
	else if ( a_Riid == IID__IWmiProviderConfiguration )
	{
		*a_Void = ( LPVOID ) ( _IWmiProviderConfiguration * ) this ;		
	}	
	else if ( a_Riid == IID_Internal_IWbemServices )
	{
		if ( m_Provider_IWbemServices )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemServices * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemPropertyProvider )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemPropertyProvider * ) this ;
		}
	}	
	else if ( a_Riid == IID_Internal_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemUnboundObjectSink * ) this ;
		}
	}

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_OpenNamespace ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = OpenNamespace (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_NamespaceService ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CancelAsyncCall ( 
	
	WmiInternalContext a_InternalContext ,		
	IWbemObjectSink *a_Sink
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CancelAsyncCall (
		
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_QueryObjectSink ( 

	WmiInternalContext a_InternalContext ,
	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryObjectSink (

			a_Flags ,	
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_GetObject ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetObject (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_Object ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_GetObjectAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetObjectAsync (

			a_ObjectPath ,
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutClass ( 

	WmiInternalContext a_InternalContext ,		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutClass (

			a_Object ,
			a_Flags , 
			a_Context ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutClassAsync ( 
		
	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_Object , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutClassAsync (

			a_Object , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_DeleteClass ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteClass (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_DeleteClassAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteClassAsync (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CreateClassEnum ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_SuperClass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateClassEnum (

			a_SuperClass ,
			a_Flags, 
			a_Context ,
			a_Enum
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CreateClassEnumAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_SuperClass , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateClassEnumAsync (

			a_SuperClass ,
			a_Flags, 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutInstance (

	WmiInternalContext a_InternalContext ,
    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutInstance (

			a_Instance ,
			a_Flags ,
			a_Context ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutInstanceAsync ( 

	WmiInternalContext a_InternalContext ,		
	IWbemClassObject *a_Instance , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutInstanceAsync (

			a_Instance , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_DeleteInstance ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteInstance (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_DeleteInstanceAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteInstanceAsync (

			a_ObjectPath ,
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CreateInstanceEnum ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateInstanceEnum (

			a_Class ,
			a_Flags , 
			a_Context , 
			a_Enum
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CreateInstanceEnumAsync (

	WmiInternalContext a_InternalContext ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateInstanceEnumAsync (

			a_Class ,
			a_Flags ,
			a_Context ,
			a_Sink 
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecQuery ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecQuery (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Enum
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecQueryAsync ( 

	WmiInternalContext a_InternalContext ,		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecQueryAsync (

			a_QueryLanguage ,
			a_Query, 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecNotificationQuery ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecNotificationQuery (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Enum
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_DecoupledClient :: Internal_ExecNotificationQueryAsync ( 

	WmiInternalContext a_InternalContext ,            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecNotificationQueryAsync (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Sink 
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecMethod (

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecMethod (

			a_ObjectPath ,
			a_MethodName ,
			a_Flags ,
			a_Context ,
			a_InParams ,
			a_OutParams ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecMethodAsync ( 

	WmiInternalContext a_InternalContext ,		
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecMethodAsync (

			a_ObjectPath ,
			a_MethodName ,
			a_Flags ,
			a_Context ,
			a_InParams ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_GetProperty (

	WmiInternalContext a_InternalContext ,
    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetProperty ( 

			a_Flags ,
			a_Locale ,
			a_ClassMapping ,
			a_InstanceMapping ,
			a_PropertyMapping ,
			a_Value
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutProperty (

	WmiInternalContext a_InternalContext ,
    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutProperty ( 

			a_Flags ,
			a_Locale ,
			a_ClassMapping ,
			a_InstanceMapping ,
			a_PropertyMapping ,
			a_Value
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ProvideEvents (

	WmiInternalContext a_InternalContext ,
	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProvideEvents (

			a_Sink ,
			a_Flags 
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_NewQuery (

	WmiInternalContext a_InternalContext ,
	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = NewQuery (

			a_Id ,
			a_QueryLanguage ,
			a_Query
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CancelQuery (

	WmiInternalContext a_InternalContext ,
	unsigned long a_Id
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CancelQuery (

			a_Id
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_AccessCheck (

	WmiInternalContext a_InternalContext ,
	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = AccessCheck (

			a_QueryLanguage ,
			a_Query ,
			a_SidLength ,
			a_Sid
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_FindConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = FindConsumer (

			a_LogicalConsumer ,
			a_Consumer
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ValidateSubscription (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ValidateSubscription (

			a_LogicalConsumer
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_IndicateToConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = IndicateToConsumer (


			a_LogicalConsumer ,
			a_ObjectCount ,
			a_Objects
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: AdjustGetContext (

    IWbemContext *a_Context
)
{
    // See if per-property get are being used.
    // ========================================

    HRESULT t_Result = S_OK ;

    if ( a_Context )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		t_Result = a_Context->GetValue ( L"__GET_EXTENSIONS" , 0, & t_Variant ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			// If here, they are being used.  Next we have to check and see
			// if the reentrancy flag is set or not.
			// =============================================================

			VariantClear ( & t_Variant ) ;

			t_Result = a_Context->GetValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 , & t_Variant ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				
				VariantClear ( & t_Variant ) ;

				a_Context->DeleteValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 ) ;
			}
			else
			{
				// If here, we have to clear out the get extensions.
				// =================================================

				a_Context->DeleteValue ( L"__GET_EXTENSIONS" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_KEYS_ONLY" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_PROPERTIES" , 0 ) ;
			}
		}
	}

    return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: SetStatus ( 

	LPWSTR a_Operation ,
	LPWSTR a_Parameters ,
	LPWSTR a_Description ,
	HRESULT a_Result ,
	IWbemObjectSink *a_Sink
)
{
	return a_Sink->SetStatus ( 0 , a_Result , NULL , NULL ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Begin_IWbemServices (

	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IWbemServices *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy
)
{
	if (!OS::secureOS_)
	{
	  a_Interface = m_Provider_IWbemServices ;
	  a_IsProxy = FALSE ;
	  return S_OK;
	}

	HRESULT t_Result = S_OK ;

	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalServiceHost:
		case e_Hosting_SharedNetworkServiceHost:
		{
			a_Interface = m_Provider_IWbemServices ;
			a_IsProxy = FALSE ;
		}
		break ;

		default:
		{
			t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , a_Proxy , a_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					a_Interface = m_Provider_IWbemServices ;
					a_IsProxy = FALSE ;
					t_Result = S_OK ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						a_IsProxy = TRUE ;

						a_Interface = ( IWbemServices * ) a_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

							a_Interface ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						if ( FAILED ( t_Result ) )
						{
							HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( 

								m_ProxyContainer , 
								ProxyIndex_IWbemServices , 
								a_Proxy , 
								a_Revert
							) ;
						}
					}
				}

				if ( FAILED ( t_Result ) )
				{
					DecoupledProviderSubSystem_Globals  :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
				}
			}
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: End_IWbemServices (

	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IWbemServices *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	if (!OS::secureOS_)
	{
	  return S_OK;
	}

	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( 

			m_ProxyContainer , 
			ProxyIndex_IWbemServices , 
			a_Proxy , 
			a_Revert
		) ;
	}

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalServiceHost:
		case e_Hosting_SharedNetworkServiceHost:
		{
		}
		break ;

		default:
		{
			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
		break ;
	}
	
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Find ( 

			a_Sink ,
			t_Iterator
		) ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			ObjectSinkContainerElement *t_Element = t_Iterator.GetElement () ;

			UnLock () ;

			IWbemObjectSink *t_ObjectSink = NULL ;
			t_Result = t_Element->QueryInterface ( IID_IWbemObjectSink , ( void ** ) & t_ObjectSink ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_Impersonating ;
				IUnknown *t_OldContext ;
				IServerSecurity *t_OldSecurity ;
				BOOL t_IsProxy ;
				IWbemServices *t_Interface ;
				BOOL t_Revert ;
				IUnknown *t_Proxy ;

				t_Result = Begin_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Interface->CancelAsyncCall (

						t_ObjectSink
					) ;

					End_IWbemServices (

						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;
				}

				t_ObjectSink->Release () ;
			}

			IWbemShutdown *t_Shutdown = NULL ;
			HRESULT t_TempResult = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				t_TempResult = t_Shutdown->Shutdown ( 

					0 , 
					0 , 
					NULL 
				) ;

				t_Shutdown->Release () ;
			}

			t_Element->Release () ;
		}
		else
		{
			UnLock () ;

			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_GetObjectAsync (

	BOOL a_IsProxy ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_GetObjectAsync () ;

						try	
						{
							t_Result = a_Service->GetObjectAsync (

 								a_ObjectPath ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						Increment_ProviderOperation_GetObjectAsync () ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							try
							{
								t_Result = a_Service->GetObjectAsync (

 									a_ObjectPath ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"GetObjectAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsGet () || m_Registration->GetClassProviderRegistration ().SupportsGet () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_GetObjectAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_PutClassAsync (

	BOOL a_IsProxy ,
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_PutClassAsync () ;

						try
						{
							t_Result = a_Service->PutClassAsync (

 								a_Object ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_PutClassAsync () ;

							try
							{
								t_Result = a_Service->PutClassAsync (

 									a_Object ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"PutClassAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsPut () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_PutClassAsync ( 

					t_IsProxy ,
					a_Object ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_DeleteClassAsync (

	BOOL a_IsProxy ,
	const BSTR a_Class , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_DeleteClassAsync () ;

						try
						{
							t_Result = a_Service->DeleteClassAsync (

 								a_Class ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_DeleteClassAsync () ;

							try
							{
								t_Result = a_Service->DeleteClassAsync (

 									a_Class ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"DeleteClassAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: DeleteClassAsync ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsDelete () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_DeleteClassAsync ( 

					t_IsProxy ,
					a_Class ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_CreateClassEnumAsync (

	BOOL a_IsProxy ,
	const BSTR a_SuperClass , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CDecoupled_Batching_IWbemSyncObjectSink *t_Sink = new CDecoupled_Batching_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_CreateClassEnumAsync () ;

						try
						{
							t_Result = a_Service->CreateClassEnumAsync (

 								a_SuperClass ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_CreateClassEnumAsync () ;

							try
							{
								t_Result = a_Service->CreateClassEnumAsync (

 									a_SuperClass ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"CreateClassEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CreateClassEnumAsync ( 
		
	const BSTR a_SuperClass , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsEnumeration () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_CreateClassEnumAsync ( 

					t_IsProxy ,
					a_SuperClass ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutInstance (

    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_PutInstanceAsync (

	BOOL a_IsProxy ,
	IWbemClassObject *a_Instance ,
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) ) 
					{
						Increment_ProviderOperation_PutInstanceAsync () ;

						try
						{
							t_Result = a_Service->PutInstanceAsync (

 								a_Instance ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_PutInstanceAsync () ;

							try
							{
								t_Result = a_Service->PutInstanceAsync (

 									a_Instance ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"PutInstanceAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsPut () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_PutInstanceAsync ( 

					t_IsProxy ,
					a_Instance ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: DeleteInstance ( 

	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_DeleteInstanceAsync (

	BOOL a_IsProxy ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_DeleteInstanceAsync () ;

						try
						{
							t_Result = a_Service->DeleteInstanceAsync (

 								a_ObjectPath ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_DeleteInstanceAsync () ;

							try
							{
								t_Result = a_Service->DeleteInstanceAsync (

 									a_ObjectPath ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"DeleteInstanceAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: DeleteInstanceAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsDelete () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_DeleteInstanceAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CreateInstanceEnum ( 

	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_CreateInstanceEnumAsync (

	BOOL a_IsProxy ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_CreateInstanceEnumAsync () ;

						try
						{
							t_Result = a_Service->CreateInstanceEnumAsync (

 								a_Class ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							Increment_ProviderOperation_CreateInstanceEnumAsync () ;

							try
							{
								t_Result = a_Service->CreateInstanceEnumAsync (

 									a_Class ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				HRESULT t_TempResult = SetStatus ( L"CreateInstanceEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_CreateInstanceEnumAsync ( 

					t_IsProxy ,
					a_Class ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecQuery ( 

	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_ExecQueryAsync (

	BOOL a_IsProxy ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Context )
		{
			t_Result = a_Context->Clone ( & t_ContextCopy ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = S_OK ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		if ( ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_UnarySelect ) ||  ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_V1ProviderDefined ) ) 
		{
			CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

				m_Allocator ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				FALSE
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_ExecQueryAsync () ;

							try
							{
								t_Result = a_Service->ExecQueryAsync (

									a_QueryLanguage ,
									a_Query, 
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							if ( a_IsProxy )
							{
								t_Result = OS::CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{
								Increment_ProviderOperation_ExecQueryAsync () ;

								try
								{
									t_Result = a_Service->ExecQueryAsync (

										a_QueryLanguage ,
										a_Query, 
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( FAILED ( t_Result ) )
					{
						HRESULT t_TempResult = SetStatus ( L"ExecQueryAsync" , NULL , NULL , t_Result , t_Sink ) ;
					}
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else if ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () )
		{
			IWbemQuery *t_QueryFilter = NULL ;
			t_Result = DecoupledProviderSubSystem_Globals  :: CreateInstance	(

				CLSID_WbemQuery ,
				NULL ,
				CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
				IID_IWbemQuery ,
				( void ** ) & t_QueryFilter
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_QueryFilter->Parse ( 

					a_QueryLanguage ,
					a_Query , 
					0 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					SWbemRpnEncodedQuery *t_Expression = NULL ;

					t_Result = t_QueryFilter->GetAnalysis (

						WMIQ_ANALYSIS_RPN_SEQUENCE ,
						0 ,
						( void ** ) & t_Expression
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Expression->m_uFromTargetType == WMIQ_RPN_FROM_UNARY )
						{
							BSTR t_Class = SysAllocString ( t_Expression->m_ppszFromList [ 0 ] ) ;
							if ( t_Class )
							{
								CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

									m_Allocator ,
									a_Sink , 
									( IWbemServices * ) this , 
									( CWbemGlobal_IWmiObjectSinkController * ) this ,
									FALSE
								) ;

								if ( t_Sink )
								{
									t_Sink->AddRef () ;

									t_Result = t_Sink->SinkInitialize () ;
									if ( SUCCEEDED ( t_Result ) )
									{
										a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;

										CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

										Lock () ;

										WmiStatusCode t_StatusCode = Insert ( 

											*t_Sink ,
											t_Iterator
										) ;

										if ( t_StatusCode == e_StatusCode_Success ) 
										{
											UnLock () ;

											if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
											{
												a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
											}

											if ( a_IsProxy )
											{
												t_Result = OS::CoImpersonateClient () ;
											}
											else
											{
												t_Result = S_OK ;
											}

											if ( SUCCEEDED ( t_Result ) )
											{
												a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;

												Increment_ProviderOperation_CreateInstanceEnumAsync () ;

												try
												{
													t_Result = a_Service->CreateInstanceEnumAsync (

 														t_Class ,
														a_Flags ,
														t_ContextCopy ,
														t_Sink 
													) ;
												}
												catch ( ... )
												{
													t_Result = WBEM_E_PROVIDER_FAILURE ;
												}
				
												CoRevertToSelf () ;
											}
											else
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}

											if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
											{
												a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

												if ( a_IsProxy )
												{
													t_Result = OS::CoImpersonateClient () ;
												}
												else
												{
													t_Result = S_OK ;
												}

												if ( SUCCEEDED ( t_Result ) ) 
												{
													Increment_ProviderOperation_CreateInstanceEnumAsync () ;

													try
													{
														t_Result = a_Service->CreateInstanceEnumAsync (

 															t_Class ,
															a_Flags ,
															t_ContextCopy ,
															t_Sink 
														) ;
													}
													catch ( ... )
													{
														t_Result = WBEM_E_PROVIDER_FAILURE ;
													}
					
													CoRevertToSelf () ;
												}
												else
												{
													t_Result = WBEM_E_ACCESS_DENIED ;
												}
											}
										}
										else
										{
											t_Result = WBEM_E_OUT_OF_MEMORY ;
										}
									}

									if ( FAILED ( t_Result ) )
									{
										HRESULT t_TempResult = SetStatus ( L"CreateInstanceEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
									}

                                    t_Sink->Release () ;
								}
								else
								{
									SysFreeString ( t_Class ) ;

									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = WBEM_E_NOT_SUPPORTED ;
						}

						t_QueryFilter->FreeMemory ( t_Expression ) ;
					}
					else
					{
						t_Result = WBEM_E_UNEXPECTED ;
					}
				}
				else
				{
					t_Result = WBEM_E_NOT_SUPPORTED ;
				}

				t_QueryFilter->Release () ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_SUPPORTED ;
		}
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_UnarySelect ) || ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_V1ProviderDefined ) || ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () ) )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_ExecQueryAsync ( 

					t_IsProxy ,
					a_QueryLanguage ,
					a_Query, 
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_DecoupledClient :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecMethod (

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_ExecMethodAsync (

	BOOL a_IsProxy ,
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) ) 
					{
						Increment_ProviderOperation_ExecMethodAsync () ;

						try
						{
							t_Result = a_Service->ExecMethodAsync (

 								a_ObjectPath ,
								a_MethodName ,
								a_Flags ,
								t_ContextCopy ,
								a_InParams ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_ExecMethodAsync () ;

							try
							{
								t_Result = a_Service->ExecMethodAsync (

 									a_ObjectPath ,
									a_MethodName ,
									a_Flags ,
									t_ContextCopy ,
									a_InParams ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"ExecMethodAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecMethodAsync ( 
		
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetMethodProviderRegistration ().SupportsMethods () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_ExecMethodAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_MethodName ,
					a_Flags ,
					a_Context ,
					a_InParams ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		if ( m_Registration->GetPropertyProviderRegistration ().SupportsGet () )
		{
			Increment_ProviderOperation_GetProperty () ;

			HRESULT t_Result = S_OK ;

			try
			{
				t_Result = m_Provider_IWbemPropertyProvider->GetProperty ( 

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;

				CoRevertToSelf () ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				CoRevertToSelf () ;
			}

			return t_Result ;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		if ( m_Registration->GetPropertyProviderRegistration ().SupportsPut () )
		{
			Increment_ProviderOperation_PutProperty () ;

			HRESULT t_Result = S_OK ;

			try
			{
				t_Result = m_Provider_IWbemPropertyProvider->PutProperty ( 

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;

				CoRevertToSelf () ;

				return t_Result ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				CoRevertToSelf () ;
			}

			return t_Result ;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	if ( m_Provider_IWbemEventProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProvider , IID_IWbemEventProvider , m_Provider_IWbemEventProvider , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_ProvideEvents () ;

				try
				{
					t_Result = m_Provider_IWbemEventProvider->ProvideEvents (

						a_Sink ,
						a_Flags 
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProvider *t_Provider = ( IWbemEventProvider * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_ProvideEvents () ;

							try
							{
								t_Result = t_Provider->ProvideEvents (

									a_Sink ,
									a_Flags 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProvider , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_NewQuery () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderQuerySink->NewQuery (

						a_Id ,
						a_QueryLanguage ,
						a_Query
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_NewQuery () ;

							try
							{
								t_Result = t_Provider->NewQuery (

									a_Id ,
									a_QueryLanguage ,
									a_Query
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::CancelQuery (

	unsigned long a_Id
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_CancelQuery () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderQuerySink->CancelQuery (

						a_Id
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_CancelQuery () ;

							try
							{
								t_Result = t_Provider->CancelQuery (

									a_Id
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	if ( m_Provider_IWbemEventProviderSecurity )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderSecurity , IID_IWbemEventProviderSecurity , m_Provider_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_AccessCheck () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderSecurity->AccessCheck (

						a_QueryLanguage ,
						a_Query ,
						a_SidLength ,
						a_Sid
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderSecurity *t_Provider = ( IWbemEventProviderSecurity * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_AccessCheck () ;

							try
							{
								t_Result = t_Provider->AccessCheck (

									a_QueryLanguage ,
									a_Query ,
									a_SidLength ,
									a_Sid
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	if ( m_Provider_IWbemProviderIdentity )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemProviderIdentity , IID_IWbemProviderIdentity , m_Provider_IWbemProviderIdentity , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_SetRegistrationObject () ;

				try
				{
					t_Result = m_Provider_IWbemProviderIdentity->SetRegistrationObject (

						a_Flags ,
						a_ProviderRegistration
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemProviderIdentity *t_Provider = ( IWbemProviderIdentity * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_SetRegistrationObject () ;

							try
							{
								t_Result = t_Provider->SetRegistrationObject (

									a_Flags ,
									a_ProviderRegistration
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemProviderIdentity , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	if ( m_Provider_IWbemEventConsumerProvider )
	{
		IWbemUnboundObjectSink *t_Consumer = NULL ;

		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProvider , IID_IWbemEventConsumerProvider , m_Provider_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_FindConsumer () ;

				try
				{
					t_Result = m_Provider_IWbemEventConsumerProvider->FindConsumer (

						a_LogicalConsumer ,
						& t_Consumer
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventConsumerProvider *t_Provider = ( IWbemEventConsumerProvider * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_FindConsumer () ;

							try
							{
								t_Result = t_Provider->FindConsumer (

									a_LogicalConsumer ,
									& t_Consumer
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_Consumer )
			{
				CInterceptor_IWbemDecoupledUnboundObjectSink *t_UnboundObjectSink = new CInterceptor_IWbemDecoupledUnboundObjectSink (

						m_Allocator ,
						t_Consumer , 
						this ,
						*m_Registration
				) ;

				if ( t_UnboundObjectSink )
				{
					t_UnboundObjectSink->AddRef () ;

					t_Result = t_UnboundObjectSink->Initialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

						Lock () ;

						WmiStatusCode t_StatusCode = Insert ( 

							*t_UnboundObjectSink ,
							t_Iterator
						) ;

						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							UnLock () ;

							*a_Consumer = t_UnboundObjectSink ;

							t_UnboundObjectSink->AddRef () ;
						}
						else
						{
							UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_UnboundObjectSink->Release () ;
				}
			}
		}

		if ( t_Consumer )
		{
			t_Consumer->Release () ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProviderEx , IID_IWbemEventConsumerProviderEx , m_Provider_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_ValidateSubscription () ;

				try
				{
					t_Result = m_Provider_IWbemEventConsumerProviderEx->ValidateSubscription (

						a_LogicalConsumer
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventConsumerProviderEx *t_Provider = ( IWbemEventConsumerProviderEx * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_ValidateSubscription () ;

							try
							{
								t_Result = t_Provider->ValidateSubscription (

									a_LogicalConsumer
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemUnboundObjectSink , IID_IWbemUnboundObjectSink , m_Provider_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Provider_IWbemUnboundObjectSink->IndicateToConsumer (


					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemUnboundObjectSink *t_Provider = ( IWbemUnboundObjectSink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Provider->IndicateToConsumer (

							a_LogicalConsumer ,
							a_ObjectCount ,
							a_Objects
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Initialize (

	LPWSTR a_User ,
	LONG a_Flags ,
	LPWSTR a_Namespace ,
	LPWSTR a_Locale ,
	IWbemServices *a_CoreService ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;
	
	if ( m_Unknown )
	{
		IWbemProviderInit *t_Provider = NULL ;

		t_Result = m_Unknown->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_Provider ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			try 
			{
				t_Result = t_Provider->Initialize (

					a_User,
					a_Flags,
					a_Namespace,
					a_Locale,
					a_CoreService,
					a_Context,
					a_Sink
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}

			t_Provider->Release () ;
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_Initialize (

	WmiInternalContext a_InternalContext ,
	LPWSTR a_User ,
	LONG a_Flags ,
	LPWSTR a_Namespace ,
	LPWSTR a_Locale ,
	IWbemServices *a_CoreService ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Initialize (

			a_User ,
			a_Flags ,
			a_Namespace ,
			a_Locale ,
			a_CoreService ,
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ProviderInitialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: GetSite ( DWORD *a_ProcessIdentifier )
{
	HRESULT t_Result = S_OK ;

	if ( a_ProcessIdentifier ) 
	{
		*a_ProcessIdentifier = GetCurrentProcessId () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: SetContainer ( IUnknown *a_Container )
{	
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Unknown )
	{
		t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , IID_IWbemShutdown , t_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_Shutdown->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Provider = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								try
								{
									t_Result = t_Provider->Shutdown (

										a_Flags ,
										a_MaxMilliSeconds ,
										a_Context
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_Shutdown->Release () ;
		}
	}

	Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Container->Size () ] ;
	if ( t_ShutdownElements )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

		ULONG t_Count = 0 ;
		while ( ! t_Iterator.Null () )
		{
			t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

			t_Iterator.Increment () ;

			t_Count ++ ;
		}

		UnLock () ;

		for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
		{
			if ( t_ShutdownElements [ t_Index ] ) 
			{
				t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

					a_Flags ,
					a_MaxMilliSeconds ,
					a_Context
				) ;

				t_ShutdownElements [ t_Index ]->Release () ;
			}
		}

		delete [] t_ShutdownElements ;
	}
	else
	{	
		UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provevt.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"

#include <wbemint.h>
#include <stdio.h>
#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvEvents.h"
#include "ProvEvt.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CEventProvider :: CEventProvider (

	WmiAllocator &a_Allocator ,
	CServerObject_ProviderEvents *a_EventRegistrar ,
	IUnknown *a_Unknown

) :	m_EventRegistrar ( a_EventRegistrar ) ,
	m_Unknown ( a_Unknown ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemProviderIdentity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_CoreService ( NULL ) ,
	m_Locale ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_ReferenceCount ( 0 ) ,
	m_CriticalSection(NOTHROW_LOCK)
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	if ( m_EventRegistrar )
	{
		m_EventRegistrar->InternalAddRef () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;

		HRESULT t_Result = m_Unknown->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemProviderIdentity , ( void ** ) & m_Provider_IWbemProviderIdentity ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CEventProvider :: ~CEventProvider ()
{
	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}

	if ( m_EventRegistrar )
	{
		m_EventRegistrar->InternalRelease () ;
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_IWbemProviderIdentity )
	{
		m_Provider_IWbemProviderIdentity->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		m_Provider_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_CoreService )
	{
		m_CoreService->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider :: Initialize ()
{
	return m_CriticalSection.valid() ? S_OK : WBEM_E_OUT_OF_MEMORY ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CEventProvider :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CEventProvider :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}
	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CEventProvider :: QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	else if ( a_Riid == IID_IWbemEventProvider )
	{
		if ( m_Unknown )
		{
			if ( m_Provider_IWbemEventProvider )
			{
				*a_Void = ( LPVOID ) ( IWbemEventProvider * ) this ;
			}
		}
		else
		{
			*a_Void = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemProviderIdentity )
	{
		if ( m_Provider_IWbemProviderIdentity )
		{
			*a_Void = ( LPVOID ) ( IWbemProviderIdentity * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*a_Void = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*a_Void = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemProviderInit )
	{
		*a_Void = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}
	else if ( a_Riid == IID_IWbemShutdown )
	{
		*a_Void = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		HRESULT t_TempResult = m_EventRegistrar->SetSink ( a_Sink ) ;

		if ( SUCCEEDED ( t_TempResult ) ) 
		{
			if ( m_Provider_IWbemEventProvider )
			{

				BOOL t_Impersonating = FALSE ;
				IUnknown *t_OldContext = NULL ;
				IServerSecurity *t_OldSecurity = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					BOOL t_Revert = FALSE ;
					IUnknown *t_Proxy = NULL ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID_IWbemEventProvider , m_Provider_IWbemEventProvider , t_Proxy , t_Revert ) ;
					if ( t_Result == WBEM_E_NOT_FOUND )
					{
						try
						{
							t_Result = m_Provider_IWbemEventProvider->ProvideEvents (

								a_Sink ,
								a_Flags 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}
					}
					else 
					{
						if ( SUCCEEDED ( t_Result ) )
						{
							IWbemEventProvider *t_Provider = ( IWbemEventProvider * ) t_Proxy ;

							// Set cloaking on the proxy
							// =========================

							DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

							t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

								t_Provider ,
								RPC_C_AUTHN_LEVEL_CONNECT , 
								t_ImpersonationLevel
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = OS::CoImpersonateClient () ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Provider->ProvideEvents (

										a_Sink ,
										a_Flags 
									) ;
								}
								else
								{
									t_Result = WBEM_E_ACCESS_DENIED ;
								}
							}

							DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
						}
					}

					DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
				}
			}
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try 
					{
						t_Result = m_Provider_IWbemEventProviderQuerySink->NewQuery (

							a_Id ,
							a_QueryLanguage ,
							a_Query
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->NewQuery (

									a_Id ,
									a_QueryLanguage ,
									a_Query
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			return t_Result ;
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::CancelQuery (

	unsigned long a_Id
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemEventProviderQuerySink->CancelQuery (

							a_Id
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventProviderQuerySink *t_Provider = NULL ;
						t_Result = t_Proxy->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & t_Provider ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							// Set cloaking on the proxy
							// =========================

							DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

							t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

								t_Provider ,
								RPC_C_AUTHN_LEVEL_CONNECT , 
								t_ImpersonationLevel
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = OS::CoImpersonateClient () ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Provider->CancelQuery (

										a_Id
									) ;
								}
								else
								{
									t_Result = WBEM_E_ACCESS_DENIED ;
								}
							}

							t_Provider->Release () ;
						}

						DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID_IWbemEventProviderSecurity , m_Provider_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemEventProviderSecurity->AccessCheck (

							a_QueryLanguage ,
							a_Query ,
							a_SidLength ,
							a_Sid
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventProviderSecurity *t_Provider = ( IWbemEventProviderSecurity * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->AccessCheck (

									a_QueryLanguage ,
									a_Query ,
									a_SidLength ,
									a_Sid
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemProviderIdentity )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID_IWbemProviderIdentity , m_Provider_IWbemProviderIdentity , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemProviderIdentity->SetRegistrationObject (

							a_Flags ,
							a_ProviderRegistration
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemProviderIdentity *t_Provider = ( IWbemProviderIdentity * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->SetRegistrationObject (

									a_Flags ,
									a_ProviderRegistration
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID_IWbemEventConsumerProvider , m_Provider_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemEventConsumerProvider->FindConsumer (

							a_LogicalConsumer ,
							a_Consumer
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventConsumerProvider *t_Provider = ( IWbemEventConsumerProvider * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->FindConsumer (

									a_LogicalConsumer ,
									a_Consumer
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID_IWbemEventConsumerProviderEx , m_Provider_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemEventConsumerProviderEx->ValidateSubscription (

							a_LogicalConsumer
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventConsumerProviderEx *t_Provider = ( IWbemEventConsumerProviderEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->ValidateSubscription (

									a_LogicalConsumer
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider :: UnRegister ()
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_CoreService,         // For anybody
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	if ( a_CoreService ) 
	{
		m_CoreService = a_CoreService ;
		m_CoreService->AddRef () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	
	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Unknown )
	{
		t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID_IWbemShutdown , t_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_Shutdown->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Provider = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Provider->Shutdown (

								a_Flags ,
								a_MaxMilliSeconds ,
								a_Context
							) ;
						}

						DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_Shutdown->Release () ;
		}
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provinsk.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvInSk.h"
#include "guids.h"
#include <provreginfo.h>
enum { CALLED = 0, NOTCALLED = -1};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderInitSink :: CServerObject_ProviderInitSink (

	SECURITY_DESCRIPTOR *a_SecurityDescriptor 

)	:   m_ReferenceCount ( 0 ) , 
		m_Event ( NULL ) , 
		m_StatusCalled ( FALSE ) , 
		m_Result ( S_OK ) ,
		m_SecurityDescriptor ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderInitSink :: ~CServerObject_ProviderInitSink () 
{
	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}

	if ( m_SecurityDescriptor )
	{
		delete [] ( BYTE * ) m_SecurityDescriptor ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderInitSink :: SinkInitialize ( 
SECURITY_DESCRIPTOR *a_SecurityDescriptor )
{
	HRESULT t_Result = S_OK ;

	m_Event = OS::CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	if ( m_Event )
	{
		if ( a_SecurityDescriptor )
		{
			m_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ 
GetSecurityDescriptorLength ( a_SecurityDescriptor ) ] ;
			if ( m_SecurityDescriptor )
			{
				CopyMemory ( m_SecurityDescriptor , a_SecurityDescriptor , 
GetSecurityDescriptorLength ( a_SecurityDescriptor ) ) ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_ProviderInitSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemProviderInitSink )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderInitSink :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderInitSink :: Release ()
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderInitSink :: SetStatus (

    LONG a_Status,
    LONG a_Flags 
)
{
	HRESULT t_Result = S_OK ;
	if ( m_SecurityDescriptor )
	{
		t_Result = OS::CoImpersonateClient () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = DecoupledProviderSubSystem_Globals :: 
        Check_SecurityDescriptor_CallIdentity (

				m_SecurityDescriptor , 
				MASK_PROVIDER_BINDING_BIND ,
				& g_ProviderBindingMapping
			) ;

			CoRevertToSelf () ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_Result = a_Status ;
	}
	else
	{
		m_Result = t_Result ;
	}

	SetEvent ( m_Event ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemProviderInitSink :: CInterceptor_IWbemProviderInitSink (

	IWbemProviderInitSink *a_InterceptedSink

)	:	m_ReferenceCount ( 0 ) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_StatusCalled ( NOTCALLED ) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemProviderInitSink_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemProviderInitSink::~CInterceptor_IWbemProviderInitSink ()
{
	if ( m_StatusCalled == NOTCALLED ) 
	{
		m_InterceptedSink->SetStatus ( WBEM_E_UNEXPECTED , 0 ) ; 
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemProviderInitSink_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress)  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemProviderInitSink::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemProviderInitSink )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInitSink * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemProviderInitSink :: AddRef ()
{
	return InterlockedIncrement (&m_ReferenceCount) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemProviderInitSink :: Release ()
{
	if ( ( InterlockedDecrement (&m_ReferenceCount)) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return m_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProviderInitSink :: SetStatus (

	LONG a_Status,
    LONG a_Flags 
)
{
	HRESULT t_Result = S_OK ;

	m_StatusCalled = CALLED ;

	InterlockedIncrement (&m_InProgress) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedSink->SetStatus ( 

			a_Status,
			a_Flags 
		) ;
	}

	InterlockedDecrement (&m_InProgress);

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProviderInitSink :: Shutdown ()
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement (&m_GateClosed) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;
			break ;
		}

		::Sleep(0);
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provtree.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvTree.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <typeinfo.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include "ProvTree.h"

WmiTreeNode *WmiTreeNode :: Copy () 
{
	TypeId_TreeNode t_Type = m_Type ;
	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_RightCopy = m_Right ? m_Right->Copy () : NULL ;
	WmiTreeNode *t_Node = new WmiTreeNode ( t_Type , t_DataCopy , t_LeftCopy , t_RightCopy , t_Parent ) ;
	return t_Node ;
} ;

WmiTreeNode *WmiTreeNode :: CopyNode () 
{
	WmiTreeNode *t_Node = new WmiTreeNode ( this ) ;
	return t_Node ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provobsk.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <stdio.h>

#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvWsv.h"
#include "ProvObSk.h"
#include "Guids.h"

enum { CALLED = 0, NOTCALLED = -1};

inline int First(LONG& value)
  {
    return ( value<0 && InterlockedIncrement(&value)==0 );
  }

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemObjectSink :: CInterceptor_IWbemObjectSink (

	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller 

)	:	ObjectSinkContainerElement ( 

			a_Controller ,
			this
		) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_Unknown ( a_Unknown ) ,
		m_StatusCalled ( NOTCALLED ),
		m_SecurityDescriptor ( NULL ) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);

	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemObjectSink::~CInterceptor_IWbemObjectSink ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);
}

HRESULT CInterceptor_IWbemObjectSink :: Initialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor )
{
	return DecoupledProviderSubSystem_Globals :: SinkAccessInitialize ( a_SecurityDescriptor , m_SecurityDescriptor ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_IWbemObjectSink :: CallBackRelease ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemObjectSink :: CallBackRelease ()" )  ;
#endif

	if ( m_StatusCalled == NOTCALLED )
	{
		m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_UNEXPECTED ,
			NULL ,
			NULL
		) ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}
	delete [] (BYTE*) m_SecurityDescriptor;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemObjectSink::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemObjectSink :: AddRef ( void )
{
//	printf ( "\nCInterceptor_IWbemObjectSink :: AddRef ()" )  ;

	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemObjectSink :: Release ( void )
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemObjectSink :: Release () " ) ;
#endif

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedSink->Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		switch ( a_Flags )
		{
			case WBEM_STATUS_PROGRESS:
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					a_Flags ,
					a_Result ,
					a_StringParam ,
					a_ObjectParam
				) ;
			}
			break ;

			case WBEM_STATUS_COMPLETE:
			{
				if (First(m_StatusCalled))
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						a_Flags ,
						a_Result ,
						a_StringParam ,
						a_ObjectParam
					) ;
				}
			}
			break ;

			default:
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
			break ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			if (First(m_StatusCalled))
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					0 ,
					WBEM_E_SHUTTING_DOWN ,
					NULL ,
					NULL
				) ;
			}

			break ;
		}

		::Sleep(0);
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_DecoupledIWbemObjectSink :: CInterceptor_DecoupledIWbemObjectSink (

	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller 

)	:	ObjectSinkContainerElement ( 

			a_Controller ,
			this
		) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_Unknown ( a_Unknown ) ,
		m_StatusCalled ( NOTCALLED ) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);

	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_DecoupledIWbemObjectSink::~CInterceptor_DecoupledIWbemObjectSink ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


void CInterceptor_DecoupledIWbemObjectSink :: CallBackRelease ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemObjectSink :: CallBackRelease ()" )  ;
#endif

	if ( m_StatusCalled == NOTCALLED )
	{
		m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_UNEXPECTED ,
			NULL ,
			NULL
		) ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_DecoupledIWbemObjectSink::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_DecoupledIWbemObjectSink :: AddRef ( void )
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemObjectSink :: AddRef ()" )  ;
#endif

	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_DecoupledIWbemObjectSink :: Release ( void )
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemObjectSink :: Release () " ) ;
#endif

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedSink->Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		switch ( a_Flags )
		{
			case WBEM_STATUS_PROGRESS:
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					a_Flags ,
					a_Result ,
					a_StringParam ,
					a_ObjectParam
				) ;
			}
			break ;

			case WBEM_STATUS_COMPLETE:
			{
				if (First(m_StatusCalled))
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						a_Flags ,
						a_Result ,
						a_StringParam ,
						a_ObjectParam
					) ;
				}
			}
			break ;

			default:
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
			break ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			if (First(m_StatusCalled))
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					0 ,
					WBEM_E_SHUTTING_DOWN ,
					NULL ,
					NULL
				) ;
			}

			break ;
		}

		::Sleep(0);
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemFilteringObjectSink :: CInterceptor_IWbemFilteringObjectSink (

	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query

)	:	CInterceptor_IWbemObjectSink ( 

			a_InterceptedSink ,
			a_Unknown ,
			a_Controller 
		) ,
		m_Filtering ( FALSE ) ,
		m_QueryFilter ( NULL )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemFilteringObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);


	if ( a_Query )
	{
		m_Query = SysAllocString ( a_Query ) ;
	}

	if ( a_QueryLanguage ) 
	{
		m_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemFilteringObjectSink::~CInterceptor_IWbemFilteringObjectSink ()
{
	if ( m_QueryFilter )
	{
		m_QueryFilter->Release () ;
	}

	if ( m_Query )
	{
		SysFreeString ( m_Query ) ;
	}

	if ( m_QueryLanguage ) 
	{
		 SysFreeString ( m_QueryLanguage ) ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemFilteringObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemFilteringObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

#if 0
	if ( m_Filtering )
	{
		for ( LONG t_Index = 0 ; t_Index < a_ObjectCount ; t_Index ++ ) 
		{
			if ( SUCCEEDED ( m_QueryFilter->TestObject ( 0 , 0 , IID_IWbemClassObject , ( void * ) a_ObjectArray [ t_Index ] ) ) )
			{
				t_Result = CInterceptor_IWbemObjectSink :: Indicate ( 

					t_Index  ,
					& a_ObjectArray [ t_Index ]
				) ;
			}
		}
	}
	else
	{
		t_Result = CInterceptor_IWbemObjectSink :: Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;
	}
#else
	t_Result = CInterceptor_IWbemObjectSink :: Indicate ( 

		a_ObjectCount ,
		a_ObjectArray
	) ;
#endif

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemFilteringObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemFilteringObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	switch ( a_Flags )
	{
		case WBEM_STATUS_PROGRESS:
		{
			t_Result = CInterceptor_IWbemObjectSink :: SetStatus ( 

				a_Flags ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
		break ;

		case WBEM_STATUS_COMPLETE:
		{
			t_Result = CInterceptor_IWbemObjectSink :: SetStatus ( 

				a_Flags ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
		break ;

		case WBEM_STATUS_REQUIREMENTS:
		{
#if 0
			if ( ! InterlockedCompareExchange ( & m_Filtering , 1 , 0 ) )
			{
				t_Result = ProviderSubSystem_Common_Globals :: CreateInstance	(

					CLSID_WbemQuery ,
					NULL ,
					CLSCTX_INPROC_SERVER ,
					IID_IWbemQuery ,
					( void ** ) & m_QueryFilter
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = m_QueryFilter->Parse ( 

						m_QueryLanguage ,
						m_Query , 
						0 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
#else
			t_Result = CInterceptor_IWbemObjectSink :: SetStatus ( 

				a_Flags ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
#endif
		}
		break;

		default:
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_DecoupledIWbemCombiningObjectSink :: CInterceptor_DecoupledIWbemCombiningObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller

) : CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	ObjectSinkContainerElement ( 

			a_Controller ,
			this
	) ,
#if 0
	m_Internal ( this ) ,
#endif
	m_InterceptedSink ( a_InterceptedSink ) ,
	m_Event ( NULL ) , 
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_StatusCalled ( NOTCALLED ) ,
	m_SinkCount ( 0 )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress)  ;

	CWbemGlobal_IWmiObjectSinkController :: Initialize () ;

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}

	m_Event = OS::CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	DWORD lastError = GetLastError();
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_DecoupledIWbemCombiningObjectSink::~CInterceptor_DecoupledIWbemCombiningObjectSink ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_DecoupledIWbemCombiningObjectSink :: CallBackRelease ()
{
	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_DecoupledIWbemCombiningObjectSink::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
#if 0
	else if ( iid == IID_CWbemCombiningObjectSink )
	{
		*iplpv = ( LPVOID ) & ( this->m_Internal ) ;
	}	
#endif
	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_DecoupledIWbemCombiningObjectSink :: AddRef ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemCombiningObjectSink :: AddRef ()" ) ;
#endif

	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_DecoupledIWbemCombiningObjectSink :: Release ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemCombiningObjectSink :: Release ()" ) ;
#endif

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedSink->Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemCombiningObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( FAILED ( a_Result ) )
		{
			ULONG t_SinkCount = InterlockedDecrement ( & m_SinkCount ) ;
			if (t_SinkCount == 0)
			{
			if (First(m_StatusCalled))
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					WBEM_STATUS_COMPLETE ,
					a_Result ,
					NULL ,
					NULL 
				) ;

				SetEvent ( m_Event ) ;
			}
			}
		}
		else
		{
			ULONG t_SinkCount = InterlockedDecrement ( & m_SinkCount ) ;
			if ( t_SinkCount == 0 )
			{
				if (First(m_StatusCalled))
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						0 ,
						S_OK ,
						NULL ,
						NULL 
					) ;

					SetEvent ( m_Event ) ;
				}
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			if (First(m_StatusCalled))
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					0 ,
					WBEM_E_SHUTTING_DOWN ,
					NULL ,
					NULL
				) ;
			}

			break ;
		}

		::Sleep(0);
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: Wait ( ULONG a_Timeout ) 
{
	HRESULT t_Result = S_OK ;

	ULONG t_Status = WaitForSingleObject ( m_Event , a_Timeout ) ;
	switch ( t_Status )
	{
		case WAIT_TIMEOUT:
		{
			t_Result = WBEM_E_TIMED_OUT ;
		}
		break ;

		case WAIT_OBJECT_0:
		{
		}
		break ;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: EnQueue ( CInterceptor_DecoupledIWbemObjectSink *a_Sink ) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

	Lock () ;

	WmiStatusCode t_StatusCode = Insert ( 

		*a_Sink ,
		t_Iterator
	) ;

	UnLock () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		InterlockedIncrement ( & m_SinkCount ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_DecoupledIWbemCombiningObjectSink :: Suspend ()
{
	InterlockedIncrement ( & m_SinkCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_DecoupledIWbemCombiningObjectSink :: Resume ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_SinkCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		InterlockedIncrement ( & m_InProgress ) ;

		if ( m_GateClosed == 1 )
		{
		}
		else
		{
			if (First(m_StatusCalled))
			{
				HRESULT t_Result = m_InterceptedSink->SetStatus ( 

					WBEM_STATUS_COMPLETE ,
					S_OK ,
					NULL ,
					NULL 
				) ;

				SetEvent ( m_Event ) ;
			}			
		}

		InterlockedDecrement ( & m_InProgress ) ;

	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemWaitingObjectSink :: CInterceptor_IWbemWaitingObjectSink (

	WmiAllocator &a_Allocator ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller

) : CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	ObjectSinkContainerElement ( 

			a_Controller ,
			this
	) ,
	m_Queue ( a_Allocator ) ,
	m_Event ( NULL ) , 
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_StatusCalled ( NOTCALLED ) ,
	m_Result ( S_OK ) ,
	m_CriticalSection(NOTHROW_LOCK)
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemWaitingObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);

	WmiStatusCode t_StatusCode = m_Queue.Initialize () ;

	CWbemGlobal_IWmiObjectSinkController :: Initialize () ;

	m_Event = OS::CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	DWORD lastError = GetLastError();

}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink::~CInterceptor_IWbemWaitingObjectSink ()
{
	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}

	ULONG t_Count = m_Queue.Size();
	for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
	{
		IWbemClassObject *t_ClassObject ;
		WmiStatusCode t_StatusCode = m_Queue.Top ( t_ClassObject ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_ClassObject->Release () ;
			t_StatusCode = m_Queue.DeQueue () ;
		}
	}
	m_Queue.UnInitialize () ;

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemWaitingObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemWaitingObjectSink::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemWaitingObjectSink :: AddRef ()
{
	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemWaitingObjectSink :: Release ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemWaitingObjectSink :: Release ()" ) ;
#endif

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		LockGuard<CriticalSection> monitor(  m_CriticalSection ) ;
		if (monitor.locked())
			{
			for ( LONG t_Index = 0 ; t_Index < a_ObjectCount ; t_Index ++ )
			{
				WmiStatusCode t_StatusCode = m_Queue.EnQueue ( a_ObjectArray [ t_Index ] ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					a_ObjectArray [ t_Index ]->AddRef () ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
			}
			}
		else
			t_Result = WBEM_E_OUT_OF_MEMORY ;

	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemWaitingObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if (First(m_StatusCalled))
		{
			if ( SUCCEEDED ( m_Result ) )
			{
				m_Result = a_Result ;
			}

			SetEvent ( m_Event ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			if (First(m_StatusCalled))
			{
				m_Result = WBEM_E_SHUTTING_DOWN ;

				SetEvent ( m_Event ) ;
			}

			break ;
		}

		::Sleep(0);
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: Wait ( ULONG a_Timeout ) 
{
	HRESULT t_Result = S_OK ;

	ULONG t_Status = WaitForSingleObject ( m_Event , a_Timeout ) ;
	switch ( t_Status )
	{
		case WAIT_TIMEOUT:
		{
			t_Result = WBEM_E_TIMED_OUT ;
		}
		break ;

		case WAIT_OBJECT_0:
		{
		}
		break ;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provobjectsink.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <stdio.h>

#include "CGlobals.h"
#include "ProvObjectSink.h"

#ifdef INTERNAL_IDENTIFY

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Begin_IWbemObjectSink (

	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_ProcessIdentifier )
		{
			t_Result = CoImpersonateClient () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				CoRevertToSelf () ;

				if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
					
						m_ProxyContainer , 
						ProxyIndex_IWbemObjectSink , 
						IID_IWbemObjectSink , 
						m_InterceptedSink , 
						a_Proxy , 
						a_Revert
					) ;
				}
				else
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_PrvHost ( 
					
						m_ProxyContainer , 
						ProxyIndex_Internal_IWbemObjectSink , 
						IID_Internal_IWbemObjectSink , 
						m_Internal_InterceptedSink , 
						a_Proxy , 
						a_Revert ,
						a_ProcessIdentifier ,
						a_IdentifyToken 
					) ;
				}
			}
		}
		else
		{
			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
			
				m_ProxyContainer , 
				ProxyIndex_IWbemObjectSink , 
				IID_IWbemObjectSink , 
				m_InterceptedSink , 
				a_Proxy , 
				a_Revert
			) ;
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = m_InterceptedSink ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IUnknown * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( FAILED ( t_Result ) )
				{
					if ( a_IdentifyToken )
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost ( 

							m_ProxyContainer , 
							ProxyIndex_Internal_IWbemObjectSink , 
							a_Proxy , 
							a_Revert ,
							a_ProcessIdentifier , 
							a_IdentifyToken 
						) ;
					}
					else
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							ProxyIndex_IWbemObjectSink , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: End_IWbemObjectSink (

	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost ( 

				m_ProxyContainer , 
				ProxyIndex_Internal_IWbemObjectSink , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier , 
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				ProxyIndex_IWbemObjectSink , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	
	return S_OK ;
}

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CCommon_IWbemSyncObjectSink :: CCommon_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	ObjectSinkContainerElement ( 

			a_Controller ,
			a_InterceptedSink
		) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
#ifdef INTERNAL_IDENTIFY
		m_Internal_InterceptedSink ( NULL ) ,
		m_ProxyContainer ( a_Allocator , ProxyIndex_ObjectSink_Size , MAX_PROXIES )
#endif
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_Unknown ( a_Unknown ) ,
		m_StatusCalled ( FALSE ) ,
		m_Dependant ( a_Dependant )
{
	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;

#ifdef INTERNAL_IDENTIFY
		HRESULT t_TempResult = m_InterceptedSink->QueryInterface ( IID_Internal_IWbemObjectSink , ( void ** ) & m_Internal_InterceptedSink ) ;
#endif
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CCommon_IWbemSyncObjectSink :: ~CCommon_IWbemSyncObjectSink ()
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CCommon_IWbemSyncObjectSink :: CallBackInternalRelease ()
{
#ifdef INTERNAL_IDENTIFY
	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;
#endif
	
	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 0 , 0 ) )
	{
		m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_UNEXPECTED ,
			NULL ,
			NULL
		) ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

#ifdef INTERNAL_IDENTIFY

	if ( m_Internal_InterceptedSink )
	{
		m_Internal_InterceptedSink->Release () ;
	}
#endif

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CCommon_IWbemSyncObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CCommon_IWbemSyncObjectSink :: AddRef ( void )
{
	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CCommon_IWbemSyncObjectSink :: Release ( void )
{
	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: SinkInitialize ()
{
	HRESULT t_Result = S_OK ;

#ifdef INTERNAL_IDENTIFY

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}
#endif

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = Helper_Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;

#ifdef DBG
		if ( FAILED ( t_Result ) )
		{
			OutputDebugString ( L"\nCCommon_IWbemSyncObjectSink :: Indicate - Failure () " ) ;
		}
#endif
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

#ifdef INTERNAL_IDENTIFY

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Helper_Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	BOOL t_Impersonating ;
	IUnknown *t_OldContext ;
	IServerSecurity *t_OldSecurity ;
	BOOL t_IsProxy ;
	IUnknown *t_Interface ;
	BOOL t_Revert ;
	IUnknown *t_Proxy ;
	DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
	HANDLE t_IdentifyToken = NULL ;

	HRESULT t_Result = Begin_IWbemObjectSink (

		t_ProcessIdentifier ,
		t_IdentifyToken ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity ,
		t_IsProxy ,
		t_Interface ,
		t_Revert ,
		t_Proxy 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_IdentifyToken )
		{
			WmiInternalContext t_InternalContext ;
			t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
			t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

			t_Result = ( ( Internal_IWbemObjectSink * ) t_Interface )->Internal_Indicate (

				t_InternalContext ,
				a_ObjectCount ,
				a_ObjectArray
			) ;
		}
		else
		{

			t_Result = ( ( IWbemObjectSink * ) t_Interface )->Indicate (

				a_ObjectCount ,
				a_ObjectArray
			) ;
		}

		End_IWbemObjectSink (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Helper_SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	BOOL t_Impersonating ;
	IUnknown *t_OldContext ;
	IServerSecurity *t_OldSecurity ;
	BOOL t_IsProxy ;
	IUnknown *t_Interface ;
	BOOL t_Revert ;
	IUnknown *t_Proxy ;
	DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
	HANDLE t_IdentifyToken = NULL ;

	HRESULT t_Result = Begin_IWbemObjectSink (

		t_ProcessIdentifier ,
		t_IdentifyToken ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity ,
		t_IsProxy ,
		t_Interface ,
		t_Revert ,
		t_Proxy 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		BSTR t_StringParam = NULL ;
		if ( a_StringParam )
		{
			t_StringParam = SysAllocString ( a_StringParam ) ;
			if ( t_StringParam == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IWbemObjectSink * ) t_Interface )->Internal_SetStatus (

					t_InternalContext ,
					a_Flags ,
					a_Result ,
					t_StringParam ,
					a_ObjectParam
				) ;
			}
			else
			{

				t_Result = ( ( IWbemObjectSink * ) t_Interface )->SetStatus (

					a_Flags ,
					a_Result ,
					t_StringParam ,
					a_ObjectParam
				) ;
			}
		}

		SysFreeString ( t_StringParam ) ;

		End_IWbemObjectSink (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;
	}

	return t_Result ;
}

#else

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Helper_Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = m_InterceptedSink->Indicate (

		a_ObjectCount ,
		a_ObjectArray
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Helper_SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_StringParam = NULL ;
	if ( a_StringParam )
	{
		t_StringParam = SysAllocString ( a_StringParam ) ;
		if ( t_StringParam == NULL )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = m_InterceptedSink->SetStatus (

			a_Flags ,
			a_Result ,
			t_StringParam ,
			a_ObjectParam
		) ;

		SysFreeString ( t_StringParam ) ;
	}

	return t_Result ;
}

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCCommon_IWbemSyncObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		switch ( a_Flags )
		{
			case WBEM_STATUS_PROGRESS:
			{
				t_Result = Helper_SetStatus ( 

					a_Flags ,
					a_Result ,
					a_StringParam ,
					a_ObjectParam
				) ;
			}
			break ;

			case WBEM_STATUS_COMPLETE:
			{
				if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
				{
					t_Result = Helper_SetStatus ( 

						a_Flags ,
						a_Result ,
						a_StringParam ,
						a_ObjectParam
					) ;
				}
			}
			break ;

			default:
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
			break ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
	{
		t_Result = Helper_SetStatus ( 

			0 ,
			WBEM_E_SHUTTING_DOWN ,
			NULL ,
			NULL
		) ;
	}

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CCommon_Batching_IWbemSyncObjectSink :: CCommon_Batching_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_IWbemSyncObjectSink ( 

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Queue ( a_Allocator ) ,
		m_Size ( 0 ),
		m_CriticalSection(NOTHROW_LOCK)
{
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CCommon_Batching_IWbemSyncObjectSink :: ~CCommon_Batching_IWbemSyncObjectSink ()
{
    ULONG t_Count = m_Queue.Size();
	for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
	{
	IWbemClassObject *t_ClassObject ;
	WmiStatusCode t_StatusCode = m_Queue.Top ( t_ClassObject ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_ClassObject->Release () ;

		t_StatusCode = m_Queue.DeQueue () ;
	}
	}

	m_Queue.UnInitialize () ;

	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection );
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_Batching_IWbemSyncObjectSink :: SinkInitialize ()
{
	HRESULT t_Result = CCommon_IWbemSyncObjectSink :: SinkInitialize () ;
	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection );
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = m_Queue.Initialize () ;
			if ( t_StatusCode == e_StatusCode_Success )
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

class CReleaseMe 
{
private:
	IUnknown * m_pUnk;
public:
	CReleaseMe(IUnknown * pUnk):m_pUnk(pUnk){};
	~CReleaseMe(){ m_pUnk->Release(); };
};


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_Batching_IWbemSyncObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	if ( m_GateClosed == 0 )
	{
		WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection , FALSE ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			for ( LONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < a_ObjectCount ) ; t_Index ++ )
			{
				if ( a_ObjectArray [ t_Index ] )
				{
					IWbemClassObject *t_ClonedObject = NULL ;
					t_Result = a_ObjectArray [ t_Index ]->Clone ( &t_ClonedObject ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
    					CReleaseMe rmCloned(t_ClonedObject);
					ULONG t_ObjectSize = 0 ;
					_IWmiObject *t_Object ;
						HRESULT t_TempResult = t_ClonedObject->QueryInterface ( IID__IWmiObject , ( void ** ) & t_Object ) ;
					if ( SUCCEEDED ( t_TempResult ) )
					{
   						CReleaseMe rmQIed(t_Object);
						t_TempResult = t_Object->GetObjectMemory (

							NULL ,
							0 ,
							& t_ObjectSize
						);

						if ( t_TempResult == WBEM_E_BUFFER_TOO_SMALL )
						{
								WmiStatusCode t_StatusCode = m_Queue.EnQueue ( t_ClonedObject ) ;
								if ( t_StatusCode == e_StatusCode_Success )
								{
 									t_ClonedObject ->AddRef();
									m_Size = m_Size + t_ObjectSize ;
								}			
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
								if ( SUCCEEDED(t_Result) && 
								   (( m_Size ) >= ProviderSubSystem_Common_Globals :: GetTransmitSize () ))
							{
									ULONG t_Count = m_Queue.Size () ;
								IWbemClassObject **t_Array = new IWbemClassObject * [ t_Count ] ;
								if ( t_Array )
								{
									IWbemClassObject *t_ClassObject ;
									WmiStatusCode t_StatusCode ;

									ULONG t_InnerIndex = 0 ;
									while ( ( t_StatusCode = m_Queue.Top ( t_ClassObject ) ) == e_StatusCode_Success )
									{
										t_Array [ t_InnerIndex ] = t_ClassObject ;

										t_InnerIndex ++ ;

										t_StatusCode = m_Queue.DeQueue() ;
									}

									m_Size = 0 ;

									WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

									t_Result = CCommon_IWbemSyncObjectSink :: Indicate ( t_Count , t_Array ) ;

										for ( t_InnerIndex = 0 ; t_InnerIndex < t_Count ; t_InnerIndex ++ )
									{
										t_Array [ t_InnerIndex ]->Release () ;
									}

									delete [] t_Array ;

									t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection , FALSE ) ;
									if ( t_StatusCode == e_StatusCode_Success )
									{
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;

										WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );
									}
								}
							}
							else
							{
								t_Result = WBEM_E_CRITICAL_ERROR ;
							}
						}
						else
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
				}
			}

			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );

			return t_Result ;
		}
		else
		{
			return WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		return WBEM_E_SHUTTING_DOWN ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_Batching_IWbemSyncObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	switch ( a_Flags )
	{
		case WBEM_STATUS_COMPLETE:
		{
			if ( m_GateClosed == 0 )
			{
				WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection , FALSE );
				if ( t_StatusCode == e_StatusCode_Success )
				{
					LONG t_Count = m_Queue.Size () ;
					if ( t_Count )
					{
						IWbemClassObject **t_Array = new IWbemClassObject * [ m_Queue.Size () ] ;
						if ( t_Array )
						{
							for ( LONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
							{
								IWbemClassObject *t_ClassObject ;
								WmiStatusCode t_StatusCode = m_Queue.Top ( t_ClassObject ) ;
								if ( t_StatusCode == e_StatusCode_Success )
								{
									t_Array [ t_Index ] = t_ClassObject ;

									t_StatusCode = m_Queue.DeQueue () ;
								}
							}

							WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );

							t_Result = CCommon_IWbemSyncObjectSink :: Indicate ( t_Count , t_Array ) ;

							for ( t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
							{
								if ( t_Array [ t_Index ] )
								{
									t_Array [ t_Index ]->Release () ;
								}
							}

							delete [] t_Array ;
						}
						else
						{
							WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				a_Result = t_Result ;
			}

			t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

				a_Flags , 
				a_Result , 
				a_StringParam ,	
				a_ObjectParam
			) ;
		}
		break ;

		default:
		{
			t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

				a_Flags , 
				a_Result , 
				a_StringParam ,	
				a_ObjectParam
			) ;
		}
		break ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provevents.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include <PreComp.h>
#include <wbemint.h>
#include "Globals.h"
#include "Guids.h"

#include "ProvRegistrar.h"
#include "ProvEvents.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_IWbemObjectSink :: CDecoupled_IWbemObjectSink ()

	:	m_InterceptedSink ( NULL ) ,
		m_EventSink ( NULL ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_StatusCalled ( FALSE ) ,
		m_SecurityDescriptorLength ( 0 ) ,
		m_SecurityDescriptor ( NULL ),
		m_CriticalSection(NOTHROW_LOCK)
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_IWbemObjectSink::~CDecoupled_IWbemObjectSink ()
{
	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 0 , 0 ) )
	{
		WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

		IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
		if ( t_ObjectSink )
		{
			t_ObjectSink->AddRef () ;
		}

		WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

		if ( t_ObjectSink )
		{
			t_ObjectSink->SetStatus ( 

				0 ,
				WBEM_E_UNEXPECTED ,
				NULL ,
				NULL
			) ;

			t_ObjectSink->Release () ;
		}


	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_EventSink )
	{
		m_EventSink->Release () ;
	}

	if ( m_SecurityDescriptor )
	{
		delete [] m_SecurityDescriptor ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CDecoupled_IWbemObjectSink::QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	else if ( a_Riid == IID_IWbemObjectSink )
	{
		*a_Void = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}
	else if ( a_Riid == IID_IWbemEventSink )
	{
		*a_Void = ( LPVOID ) ( IWbemEventSink * ) this ;		
	}	
	else if ( a_Riid == IID_IWbemShutdown )
	{
		*a_Void = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
				if ( t_ObjectSink )
				{
					t_ObjectSink->AddRef () ;
				}

				WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				if ( t_ObjectSink )
				{
					t_Result = t_ObjectSink->Indicate ( 

						a_ObjectCount ,
						a_ObjectArray
					) ;

					t_ObjectSink->Release () ;
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				switch ( a_Flags )
				{
					case WBEM_STATUS_PROGRESS:
					{
						WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

						IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
						if ( t_ObjectSink )
						{
							t_ObjectSink->AddRef () ;
						}

						WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

						if ( t_ObjectSink )
						{
							t_Result = t_ObjectSink->SetStatus ( 

								a_Flags ,
								a_Result ,
								a_StringParam ,
								a_ObjectParam
							) ;

							t_ObjectSink->Release () ;
						}
					}
					break ;

					case WBEM_STATUS_COMPLETE:
					{
						if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
						{
							WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

							IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
							if ( t_ObjectSink )
							{
								t_ObjectSink->AddRef () ;
							}

							WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

							if ( t_ObjectSink )
							{
								t_Result = t_ObjectSink->SetStatus ( 

									a_Flags ,
									a_Result ,
									a_StringParam ,
									a_ObjectParam
								) ;

								t_ObjectSink->Release () ;
							}
						}
					}
					break ;

					default:
					{
						t_Result = WBEM_E_INVALID_PARAMETER ;
					}
					break ;
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: SetSinkSecurity (

	long a_SecurityDescriptorLength ,
	BYTE *a_SecurityDescriptor
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				IWbemEventSink *t_ObjectSink = m_EventSink ;
				if ( t_ObjectSink )
				{
					t_ObjectSink->AddRef () ;
				}

				WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				if ( t_ObjectSink )
				{
					t_Result = t_ObjectSink->SetSinkSecurity ( 

							a_SecurityDescriptorLength ,
							a_SecurityDescriptor
					) ;

					t_ObjectSink->Release () ;
				}
				else
				{
					if ( a_SecurityDescriptor )
					{
						if ( a_SecurityDescriptorLength )
						{
							WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;
                            m_SecurityDescriptorLength = a_SecurityDescriptorLength;
							m_SecurityDescriptor = new BYTE [ a_SecurityDescriptorLength ] ;
							if  ( m_SecurityDescriptor )
							{
								try
								{
									CopyMemory ( m_SecurityDescriptor , a_SecurityDescriptor , a_SecurityDescriptorLength ) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_CRITICAL_ERROR ;
								}
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;
						}
						else
						{
							t_Result = WBEM_E_INVALID_PARAMETER ;
						}
					}
					else
					{
						WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

						if ( m_SecurityDescriptor )
						{
							delete m_SecurityDescriptor ;
							m_SecurityDescriptor = NULL ;
						}

						m_SecurityDescriptorLength = 0 ;

						WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;
					}
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: IsActive ()
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				IWbemEventSink *t_ObjectSink = m_EventSink ;
				if ( t_ObjectSink )
				{
					t_ObjectSink->AddRef () ;
				}

				WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				if ( t_ObjectSink )
				{
					t_Result = t_ObjectSink->IsActive () ;

					t_ObjectSink->Release () ;
				}
				else
				{
					t_Result = WBEM_S_FALSE ;
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: SetBatchingParameters (

	LONG a_Flags,
	DWORD a_MaxBufferSize,
	DWORD a_MaxSendLatency
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				IWbemEventSink *t_ObjectSink = m_EventSink ;
				if ( t_ObjectSink )
				{
					t_ObjectSink->AddRef () ;
				}

				WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				if ( t_ObjectSink )
				{
					t_Result = t_ObjectSink->SetBatchingParameters ( 

						a_Flags ,
						a_MaxBufferSize ,
						a_MaxSendLatency
					) ;

					t_ObjectSink->Release () ;
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
		{
			WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

			IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
			if ( t_ObjectSink )
			{
				t_ObjectSink->AddRef () ;
			}

			WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

			if ( t_ObjectSink )
			{
				t_Result = t_ObjectSink->SetStatus ( 

					0 ,
					WBEM_E_SHUTTING_DOWN ,
					NULL ,
					NULL
				) ;

				t_ObjectSink->Release () ;
			}
		}

		m_GateClosed ++ ;

		try
		{
			bool t_Acquired = false ;
			while ( ! t_Acquired )
			{
				if ( m_InProgress == 0 )
				{
					t_Acquired = true ;

					break ;
				}

				if ( SwitchToThread () == FALSE ) 
				{
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledRoot_IWbemObjectSink :: SinkInitialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_DecoupledIWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledRoot_IWbemObjectSink :: SetSink ( IWbemObjectSink *a_Sink ) 
{
	Lock () ;

	CWbemGlobal_DecoupledIWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	CWbemGlobal_DecoupledIWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

	while ( ! t_Iterator.Null () )
	{
		HRESULT t_Result = t_Iterator.GetKey ()->SetSink ( a_Sink ) ;

		t_Iterator.Increment () ;
	}

	UnLock () ;

	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	m_InterceptedSink = a_Sink ;
	m_InterceptedSink->AddRef () ;

	t_Result = a_Sink->QueryInterface ( IID_IWbemEventSink , ( void ** ) & m_EventSink ) ;

	WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledChild_IWbemObjectSink :: SetSink ( IWbemObjectSink *a_Sink ) 
{
	HRESULT t_Result = S_OK ;

	IWbemObjectSink *t_InterceptedObjectSink = NULL ;
	IWbemEventSink *t_RestrictedEventSinkObjectSink = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemEventSink *t_EventSink = NULL ;
		t_Result = a_Sink->QueryInterface ( IID_IWbemEventSink , ( void ** ) & t_EventSink ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_EventSink->GetRestrictedSink (

				m_QueryCount ,
				m_Queries ,
				m_Callback ,
				& t_RestrictedEventSinkObjectSink
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
    			t_Result = t_RestrictedEventSinkObjectSink->QueryInterface ( IID_IWbemObjectSink , ( void ** ) & t_InterceptedObjectSink ) ;
    			if ( SUCCEEDED ( t_Result ) )
    			{
    				if ( m_SecurityDescriptor )
    				{
    					t_Result = t_RestrictedEventSinkObjectSink->SetSinkSecurity (

    						m_SecurityDescriptorLength ,
    						m_SecurityDescriptor
    					) ;
    				}
    			}
			}

			t_EventSink->Release () ;
		}
	}

	WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

	IWbemObjectSink *t_TempInterceptedObjectSink = m_InterceptedSink ;
	IWbemEventSink *t_TempRestrictedEventSinkObjectSink = m_EventSink ;

	m_InterceptedSink = t_InterceptedObjectSink ;
	m_EventSink = t_RestrictedEventSinkObjectSink  ;

	WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

	if ( t_TempInterceptedObjectSink )
	{
		t_TempInterceptedObjectSink->Release () ;
	}

	if ( t_TempRestrictedEventSinkObjectSink )
	{
		t_TempRestrictedEventSinkObjectSink->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CDecoupledChild_IWbemObjectSink :: CDecoupledChild_IWbemObjectSink (

	CDecoupledRoot_IWbemObjectSink *a_RootSink
	
) : DecoupledObjectSinkContainerElement ( 

		a_RootSink ,
		this
	) ,
 	m_RootSink ( a_RootSink )
{
	m_RootSink->AddRef () ;
}

#pragma warning( default : 4355 )


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupledChild_IWbemObjectSink :: ~CDecoupledChild_IWbemObjectSink ()
{
	m_RootSink->Release () ;

	if ( m_Queries )
	{
		for ( long t_Index = 0 ; t_Index < m_QueryCount ; t_Index ++ )
		{
			SysFreeString ( m_Queries [ t_Index ] ) ;
		}

		delete [] m_Queries ;
		m_Queries = NULL ;
	}

	if ( m_Callback )
	{
		m_Callback->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupledChild_IWbemObjectSink :: AddRef () 
{
	return DecoupledObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupledChild_IWbemObjectSink :: Release ()
{
	return DecoupledObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledChild_IWbemObjectSink :: SinkInitialize (

	long a_QueryCount ,
	const LPCWSTR *a_Queries ,
	IUnknown *a_Callback
) 
{
	HRESULT t_Result = S_OK ;

	if ( m_Callback )
	{
		m_Callback->Release () ;
	}

	m_Callback = a_Callback ;
	if ( m_Callback )
	{
		m_Callback->AddRef () ;
	}

	if ( m_Queries )
	{
		for ( long t_Index = 0 ; t_Index < m_QueryCount ; t_Index ++ )
		{
			SysFreeString ( m_Queries [ t_Index ] ) ;
		}

		delete [] m_Queries ;
		m_Queries = NULL ;
	}

	m_QueryCount = a_QueryCount ;
	if ( a_Queries )
	{
		m_Queries = new wchar_t * [ m_QueryCount ] ;
		if ( m_Queries )
		{
			for ( long t_Index = 0 ; t_Index < m_QueryCount ; t_Index ++ )
			{
				m_Queries [ t_Index ] = NULL ;
			}

			for ( t_Index = 0 ; t_Index < m_QueryCount ; t_Index ++ )
			{
				try
				{
					m_Queries [ t_Index ] = SysAllocString ( a_Queries [ t_Index ] ) ;
					if ( m_Queries [ t_Index ] )
					{
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
						break ;
					}
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CDecoupledChild_IWbemObjectSink :: GetRestrictedSink (

	long a_QueryCount ,
    const LPCWSTR *a_Queries ,
    IUnknown *a_Callback ,
    IWbemEventSink **a_Sink
)
{
	return m_RootSink->GetRestrictedSink (

		a_QueryCount ,
		a_Queries ,
		a_Callback ,
		a_Sink
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupledRoot_IWbemObjectSink :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CDecoupledRoot_IWbemObjectSink :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;

		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledRoot_IWbemObjectSink :: GetRestrictedSink (

	long a_QueryCount ,
    const LPCWSTR *a_Queries ,
    IUnknown *a_Callback ,
    IWbemEventSink **a_Sink
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		if ( a_Sink )
		{
			*a_Sink = NULL ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			InterlockedIncrement ( & m_InProgress ) ;

			try
			{
				if ( m_GateClosed == 1 )
				{
					t_Result = WBEM_E_SHUTTING_DOWN ;
				}
				else
				{
					WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

					IWbemEventSink *t_ObjectSink = m_EventSink ;
					if ( t_ObjectSink )
					{
						t_ObjectSink->AddRef () ;
					}

					WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

					if ( t_ObjectSink )
					{
						t_Result = t_ObjectSink->GetRestrictedSink ( 

								a_QueryCount ,
								a_Queries ,
								a_Callback ,
								a_Sink
						) ;

						t_ObjectSink->Release () ;
					}
					else
					{
						CDecoupledChild_IWbemObjectSink *t_RestrictedSink = new CDecoupledChild_IWbemObjectSink ( this ) ;
						if ( t_RestrictedSink )
						{
							t_RestrictedSink->AddRef () ;

							t_Result = t_RestrictedSink->SinkInitialize (

								a_QueryCount ,
								a_Queries ,
								a_Callback
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								Lock () ;

								CWbemGlobal_DecoupledIWmiObjectSinkController_Container_Iterator t_Iterator ;

								WmiStatusCode t_StatusCode = Insert (
								
									*t_RestrictedSink ,
									t_Iterator
								) ;

								if ( t_StatusCode == e_StatusCode_Success )
								{
									*a_Sink = t_RestrictedSink ;
								}
								else
								{
									t_RestrictedSink->Release () ;

									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								UnLock () ;
							}
							else
							{
								t_RestrictedSink->Release () ;
							}
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
			}
			catch ( ... )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			InterlockedDecrement ( & m_InProgress ) ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderEvents :: CServerObject_ProviderEvents (

	WmiAllocator &a_Allocator 

) : CServerObject_ProviderRegistrar_Base ( a_Allocator ) ,
	m_Allocator ( a_Allocator ) ,
	m_ReferenceCount ( 0 ) ,
	m_InternalReferenceCount ( 0 ) ,
	m_ObjectSink ( NULL ) ,
	m_Service ( NULL ) ,
	m_Provider ( NULL ),
	m_SinkCriticalSection(NOTHROW_LOCK)
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderEvents_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_SinkCriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderEvents::~CServerObject_ProviderEvents ()
{
	WmiHelper :: DeleteCriticalSection ( & m_SinkCriticalSection ) ;

	if ( m_Provider ) 
	{
		m_Provider->Release () ;
	}

	if ( m_Service ) 
	{
		m_Service->Release () ;
	}

	if ( m_ObjectSink )
	{
		m_ObjectSink->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderEvents_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_ProviderEvents::QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	else if ( a_Riid == IID_IWbemDecoupledRegistrar )
	{
		*a_Void = ( LPVOID ) ( IWbemDecoupledRegistrar * ) ( CServerObject_ProviderRegistrar_Base * ) this ;		
	}	
	else if ( a_Riid == IID_IWbemDecoupledBasicEventProvider )
	{
		*a_Void = ( LPVOID ) ( IWbemDecoupledBasicEventProvider * ) this ;		
	}	

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderEvents :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 1 )
	{
		InternalAddRef () ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderEvents :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		if ( m_Provider )
		{
			m_Provider->Release () ;
			m_Provider = NULL ;
		}

		InternalRelease () ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderEvents :: InternalAddRef ()
{
	return InterlockedIncrement ( & m_InternalReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderEvents :: InternalRelease ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_InternalReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderEvents :: Register (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	IUnknown *a_Unknown 
) 
{
	HRESULT t_Result = S_OK ;

	if ( a_Scope == NULL || a_Registration == NULL )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}
	try
	{
		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		try 
		{
			if ( m_Registered == FALSE )
			{
				IWbemLocator *t_Locator = NULL ;

				t_Result = CoCreateInstance (

					CLSID_WbemLocator ,
					NULL ,
					CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
					IID_IUnknown ,
					( void ** )  & t_Locator
				);

				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = NULL ;

					BSTR t_Namespace = SysAllocString ( a_Scope ) ;
					if ( t_Namespace )
					{
						t_Result = t_Locator->ConnectServer (

							t_Namespace ,
							NULL ,
							NULL,
							NULL ,
							0 ,
							NULL,
							NULL,
							&t_Service
						) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							m_Service = t_Service ;
						}

						SysFreeString ( t_Namespace ) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					t_Locator->Release () ;
				}

				if (FAILED(t_Result) && GetModuleHandleA("wbemcore.dll"))
				{
					t_Result = CoCreateInstance (
					CLSID_WbemAdministrativeLocator ,
					NULL ,
					CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
					IID_IUnknown ,
					( void ** )  & t_Locator);

				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = NULL ;

					BSTR t_Namespace = SysAllocString ( a_Scope ) ;
					if ( t_Namespace )
					{
						t_Result = t_Locator->ConnectServer (

							t_Namespace ,
							NULL ,
							NULL,
							NULL ,
							0 ,
							NULL,
							NULL,
							&t_Service
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							m_Service = t_Service ;
						}

						SysFreeString ( t_Namespace ) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					t_Locator->Release () ;
				}
				}




				if ( SUCCEEDED ( t_Result ) ) 
				{
					WmiHelper :: EnterCriticalSection ( & m_SinkCriticalSection ) ;

					m_ObjectSink = new CDecoupledRoot_IWbemObjectSink ( m_Allocator ) ;
					if ( m_ObjectSink )
					{
						m_ObjectSink->AddRef () ;
						t_Result = m_ObjectSink->SinkInitialize () ;
						if ( SUCCEEDED ( t_Result ) ) 
						{
						}
						else
						{
							m_ObjectSink->Release ();
							m_ObjectSink = NULL ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					WmiHelper :: LeaveCriticalSection ( & m_SinkCriticalSection ) ;
				}

				if ( SUCCEEDED ( t_Result ) ) 
				{
					m_Provider = new CEventProvider (

						m_Allocator ,
						this ,
						a_Unknown 
					) ;

					if ( m_Provider )
					{
						m_Provider->AddRef () ;

						t_Result = m_Provider->Initialize () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							IUnknown *t_Unknown = NULL ;
							t_Result = m_Provider->QueryInterface ( IID_IUnknown , ( void ** ) & t_Unknown ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = CServerObject_ProviderRegistrar_Base :: Register ( 

									a_Flags ,
									a_Context ,
									a_User ,
									a_Locale ,
									a_Scope ,
									a_Registration ,
									t_Unknown
								) ;

								t_Unknown->Release () ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					WmiHelper :: EnterCriticalSection ( & m_SinkCriticalSection ) ;

					if ( m_ObjectSink )
					{
						m_ObjectSink->Release () ;
						m_ObjectSink = NULL ;
					}

					WmiHelper :: LeaveCriticalSection ( & m_SinkCriticalSection ) ;

					if ( m_Provider )
					{
						m_Provider->Release () ;
						m_Provider = NULL ;
					}

					if ( m_Service ) 
					{
						m_Service->Release () ;
						m_Service = NULL ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderEvents :: UnRegister ()
{
	HRESULT t_Result = S_OK ;

	try
	{
		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		try 
		{
			if ( m_Registered )
			{
				t_Result = CServerObject_ProviderRegistrar_Base :: UnRegister () ; 

				if ( m_Provider ) 
				{
					m_Provider->UnRegister () ;
					m_Provider->Release () ;
					m_Provider = NULL ;
				}

				if ( m_Service )
				{
					m_Service->Release () ;
					m_Service = NULL ;
				}

				if ( m_ObjectSink )
				{
					m_ObjectSink->Release () ;
					m_ObjectSink = NULL ;
				}
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_NOT_REGISTERED ;
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderEvents :: GetSink (

	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink **a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	try
	{
		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		try 
		{
			if ( m_Registered )
			{
				if ( a_Sink )
				{	
					*a_Sink = m_ObjectSink ;
					m_ObjectSink->AddRef () ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_NOT_REGISTERED ;
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderEvents :: GetService (

	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_Service
) 
{
	HRESULT t_Result = S_OK ;

	try
	{
		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		try
		{
			if ( m_Registered )
			{
				if ( a_Service )
				{	
					*a_Service = m_Service ;
					m_Service->AddRef () ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_NOT_REGISTERED ;
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provregdecoupled.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"

#include <typeinfo.h>
#include <stdio.h>
#include <Aclapi.h>

#include <wbemint.h>
#include <HelperFuncs.h>
#include <Logging.h>

#include <HelperFuncs.h>
#include "CGlobals.h"
#include "ProvRegDeCoupled.h"
#include "DateTime.h"
#include "OS.h"
#include <scopeguard.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT SetSecurity ( HKEY a_Key , DWORD a_Access ) 
{
	if (!OS::secureOS_)
		return ERROR_SUCCESS;

	HRESULT t_Result = S_OK ;

	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

	PSID t_Administrator_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Administrator_ACE = NULL ;
	DWORD t_Administrator_ACESize = 0 ;

	BOOL t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		2 ,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Administrator_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Administrator_Sid );
		t_Administrator_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Administrator_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Administrator_ACESize ] ;
		if ( t_Administrator_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Administrator_ACE->SidStart, t_Administrator_Sid ) ;
			t_Administrator_ACE->Mask = 0x1F01FF;
			t_Administrator_ACE->Header.AceType = 0 ;
			t_Administrator_ACE->Header.AceFlags = 3 ;
			t_Administrator_ACE->Header.AceSize = t_Administrator_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	PSID t_System_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_System_ACE = NULL ;
	DWORD t_System_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_LOCAL_SYSTEM_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_System_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
		t_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_System_ACESize ] ;
		if ( t_System_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_System_ACE->SidStart, t_System_Sid ) ;
			t_System_ACE->Mask = 0x1F01FF;
			t_System_ACE->Header.AceType = 0 ;
			t_System_ACE->Header.AceFlags = 3 ;
			t_System_ACE->Header.AceSize = t_System_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	PSID t_PowerUsers_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_PowerUsers_ACE = NULL ;
	DWORD t_PowerUsers_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		2 ,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_POWER_USERS,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_PowerUsers_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_PowerUsers_Sid );
		t_PowerUsers_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_PowerUsers_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_PowerUsers_ACESize ] ;
		if ( t_PowerUsers_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_PowerUsers_ACE->SidStart, t_PowerUsers_Sid ) ;
			t_PowerUsers_ACE->Mask = GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE ;
			t_PowerUsers_ACE->Header.AceType = 0 ;
			t_PowerUsers_ACE->Header.AceFlags = 3 ;
			t_PowerUsers_ACE->Header.AceSize = t_PowerUsers_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	SID_IDENTIFIER_AUTHORITY t_WorldAuthoritySid = SECURITY_WORLD_SID_AUTHORITY ;

	PSID t_Everyone_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Everyone_ACE = NULL ;
	DWORD t_Everyone_ACESize = 0 ;
	
	t_BoolResult = AllocateAndInitializeSid (

		& t_WorldAuthoritySid ,
		1 ,
		SECURITY_WORLD_RID ,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Everyone_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Everyone_Sid );
		t_Everyone_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Everyone_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Everyone_ACESize ] ;
		if ( t_Everyone_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Everyone_ACE->SidStart, t_Everyone_Sid ) ;
			t_Everyone_ACE->Mask = a_Access ;
			t_Everyone_ACE->Header.AceType = 0 ;
			t_Everyone_ACE->Header.AceFlags = 3 ;
			t_Everyone_ACE->Header.AceSize = t_Everyone_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	// Now we need to set permissions on the registry: Everyone read; Admins full.
	// We have the sid for admins from the above code.  Now get the sid for "Everyone"

	DWORD t_TotalAclSize = sizeof(ACL) + t_Administrator_ACESize + t_System_ACESize + t_Everyone_ACESize ;
	PACL t_Dacl = (PACL) new BYTE [ t_TotalAclSize ] ;
	if ( t_Dacl )
	{
		if ( :: InitializeAcl ( t_Dacl, t_TotalAclSize, ACL_REVISION ) )
		{
			DWORD t_AceIndex = 0 ;

			if ( t_Everyone_ACESize && :: AddAce ( t_Dacl , ACL_REVISION, t_AceIndex , t_Everyone_ACE , t_Everyone_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			if ( t_System_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_System_ACE , t_System_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			
			if ( t_Administrator_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_Administrator_ACE , t_Administrator_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			SECURITY_INFORMATION t_SecurityInfo = 0L;

			t_SecurityInfo |= DACL_SECURITY_INFORMATION;
			t_SecurityInfo |= PROTECTED_DACL_SECURITY_INFORMATION;

			SECURITY_DESCRIPTOR t_SecurityDescriptor ;
			t_BoolResult = InitializeSecurityDescriptor ( & t_SecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
			if ( t_BoolResult )
			{
				t_BoolResult = SetSecurityDescriptorDacl (

				  & t_SecurityDescriptor ,
				  TRUE ,
				  t_Dacl ,
				  FALSE
				) ;

				if ( t_BoolResult )
				{
					LONG t_SetStatus = RegSetKeySecurity (

					  a_Key ,
					  t_SecurityInfo ,
					  & t_SecurityDescriptor
					) ;

					if ( t_SetStatus != ERROR_SUCCESS )
					{
						DWORD t_LastError = GetLastError () ;

						t_Result = WBEM_E_ACCESS_DENIED ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;	
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;	
			}
		}

		delete [] ( ( BYTE * ) t_Dacl ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_Administrator_ACE )
	{
		delete [] ( ( BYTE * ) t_Administrator_ACE ) ;
	}

	if ( t_PowerUsers_ACE )
	{
		delete [] ( ( BYTE * ) t_PowerUsers_ACE ) ;
	}

	if ( t_Everyone_ACE )
	{
		delete [] ( ( BYTE * ) t_Everyone_ACE ) ;
	}

	if ( t_System_ACE )
	{
		delete [] ( ( BYTE * ) t_System_ACE ) ;
	}

	if ( t_System_Sid )
	{
		FreeSid ( t_System_Sid ) ;
	}

	if ( t_Administrator_Sid )
	{
		FreeSid ( t_Administrator_Sid ) ;
	}
	
	if ( t_PowerUsers_Sid )
	{
		FreeSid ( t_PowerUsers_Sid ) ;
	}

	if ( t_Everyone_Sid )
	{
		FreeSid ( t_Everyone_Sid ) ;
	}

	return t_Result ;
}

HRESULT SetClientSecurity ( HKEY a_Key) 
{
	if (!OS::secureOS_)
		return ERROR_SUCCESS;

	HRESULT t_Result = S_OK ;

	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

	PSID t_Administrator_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Administrator_ACE = NULL ;
	DWORD t_Administrator_ACESize = 0 ;

	BOOL t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		2 ,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Administrator_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Administrator_Sid );
		t_Administrator_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Administrator_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Administrator_ACESize ] ;
		if ( t_Administrator_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Administrator_ACE->SidStart, t_Administrator_Sid ) ;
			t_Administrator_ACE->Mask = 0x1F01FF;
			t_Administrator_ACE->Header.AceType = 0 ;
			t_Administrator_ACE->Header.AceFlags = 3 ;
			t_Administrator_ACE->Header.AceSize = t_Administrator_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	PSID t_System_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_System_ACE = NULL ;
	DWORD t_System_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_LOCAL_SYSTEM_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_System_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
		t_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_System_ACESize ] ;
		if ( t_System_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_System_ACE->SidStart, t_System_Sid ) ;
			t_System_ACE->Mask = 0x1F01FF;
			t_System_ACE->Header.AceType = 0 ;
			t_System_ACE->Header.AceFlags = 3 ;
			t_System_ACE->Header.AceSize = t_System_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}


	SID_IDENTIFIER_AUTHORITY t_WorldAuthoritySid = SECURITY_WORLD_SID_AUTHORITY ;

	PSID t_Everyone_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Everyone_ACE = NULL ;
	DWORD t_Everyone_ACESize = 0 ;
	
	t_BoolResult = AllocateAndInitializeSid (

		& t_WorldAuthoritySid ,
		1 ,
		SECURITY_WORLD_RID ,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Everyone_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Everyone_Sid );
		t_Everyone_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Everyone_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Everyone_ACESize ] ;
		if ( t_Everyone_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Everyone_ACE->SidStart, t_Everyone_Sid ) ;
            		t_Everyone_ACE->Mask = KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS | KEY_SET_VALUE | READ_CONTROL | KEY_QUERY_VALUE ; // JeffCoop: added KEY_SET_VALUE | READ_CONTROL | KEY_QUERY_VALUE
			t_Everyone_ACE->Header.AceType = 0 ;
		        t_Everyone_ACE->Header.AceFlags = 0 ; // JeffCoop: was '3' ;
			t_Everyone_ACE->Header.AceSize = t_Everyone_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}


	SID_IDENTIFIER_AUTHORITY t_OwnerAuthoritySid = SECURITY_CREATOR_SID_AUTHORITY;
	PSID t_Owner_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Owner_ACE = NULL ;
	DWORD t_Owner_ACESize = 0 ;
	
	t_BoolResult = AllocateAndInitializeSid (

		& t_OwnerAuthoritySid ,
		1 ,
		SECURITY_CREATOR_OWNER_RID ,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Owner_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Owner_Sid );
		t_Owner_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Owner_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Owner_ACESize ] ;
		if ( t_Owner_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Owner_ACE->SidStart, t_Owner_Sid ) ;
			t_Owner_ACE->Mask = KEY_ALL_ACCESS ;
			t_Owner_ACE->Header.AceType = ACCESS_ALLOWED_ACE_TYPE ;
		        t_Owner_ACE->Header.AceFlags = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | NO_PROPAGATE_INHERIT_ACE | INHERIT_ONLY_ACE ; // JeffCoop: added NO_PROPAGATE_INHERIT_ACE | INHERIT_ONLY_ACE
			t_Owner_ACE->Header.AceSize = t_Owner_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	// Now we need to set permissions on the registry: Everyone read; Admins full.
	// We have the sid for admins from the above code.  Now get the sid for "Everyone"

	DWORD t_TotalAclSize = sizeof(ACL) + t_Administrator_ACESize + t_Owner_ACESize + t_Everyone_ACESize + t_System_ACESize;
	PACL t_Dacl = (PACL) new BYTE [ t_TotalAclSize ] ;
	if ( t_Dacl )
	{
		if ( :: InitializeAcl ( t_Dacl, t_TotalAclSize, ACL_REVISION ) )
		{
			DWORD t_AceIndex = 0 ;

			if ( t_Everyone_ACESize && :: AddAce ( t_Dacl , ACL_REVISION, t_AceIndex , t_Everyone_ACE , t_Everyone_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			if ( t_Owner_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_Owner_ACE , t_Owner_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			
			if ( t_Administrator_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_Administrator_ACE , t_Administrator_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			if ( t_Administrator_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_System_ACE , t_System_ACESize ) )
			{
				t_AceIndex ++ ;
			}


			SECURITY_INFORMATION t_SecurityInfo = 0L;

			t_SecurityInfo |= DACL_SECURITY_INFORMATION;

			SECURITY_DESCRIPTOR t_SecurityDescriptor ;
			t_BoolResult = InitializeSecurityDescriptor ( & t_SecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
			if ( t_BoolResult )
			{
				t_BoolResult = SetSecurityDescriptorDacl (

				  & t_SecurityDescriptor ,
				  TRUE ,
				  t_Dacl ,
				  FALSE
				) ;

				if ( t_BoolResult )
				{
					LONG t_SetStatus = RegSetKeySecurity (

					  a_Key ,
					  t_SecurityInfo ,
					  & t_SecurityDescriptor
					) ;

					if ( t_SetStatus != ERROR_SUCCESS )
					{
						DWORD t_LastError = GetLastError () ;

						t_Result = WBEM_E_ACCESS_DENIED ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;	
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;	
			}
		}

		delete [] ( ( BYTE * ) t_Dacl ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_Administrator_ACE )
	{
		delete [] ( ( BYTE * ) t_Administrator_ACE ) ;
	}

	if (t_Owner_ACE) delete [] ((BYTE *)t_Owner_ACE);
	if (t_Owner_Sid) FreeSid (t_Owner_Sid);

	if ( t_Everyone_ACE )
	{
		delete [] ( ( BYTE * ) t_Everyone_ACE ) ;
	}

	if ( t_System_ACE )
	{
		delete [] ( ( BYTE * ) t_System_ACE ) ;
	}

	if ( t_System_Sid )
	{
		FreeSid ( t_System_Sid ) ;
	}

	if ( t_Administrator_Sid )
	{
		FreeSid ( t_Administrator_Sid ) ;
	}
	


	if ( t_Everyone_Sid )
	{
		FreeSid ( t_Everyone_Sid ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Null = NULL ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Home = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_HomeClient = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled\\Client" ;

LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_CreationTime = L"CreationTime" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_User = L"User" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Locale = L"Locale" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Scope = L"Scope" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Provider = L"Provider" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_MarshaledProxy = L"MarshaledProxy" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_ProcessIdentifier = L"ProcessIdentifier" ;

LPCWSTR CServerObject_DecoupledClientRegistration :: s_Strings_Reg_Null = NULL ;
LPCWSTR CServerObject_DecoupledClientRegistration :: s_Strings_Reg_Home = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled" ;
LPCWSTR CServerObject_DecoupledClientRegistration :: s_Strings_Reg_HomeClient = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled\\Client" ;

LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_Null = NULL ;
LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_Home = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled" ;
LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_HomeServer = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled\\Server" ;

LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_CreationTime = L"CreationTime" ;
LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_ProcessIdentifier = L"ProcessIdentifier" ;
LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_MarshaledProxy = L"MarshaledProxy" ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration_Element :: CServerObject_DecoupledClientRegistration_Element ()

	:	m_Provider ( NULL ) ,
		m_Clsid ( NULL ) ,
		m_CreationTime ( NULL ) ,
		m_User ( NULL ) ,
		m_Locale ( NULL ) ,
		m_Scope ( NULL ) ,
		m_MarshaledProxy ( NULL ) ,
		m_MarshaledProxyLength ( 0 ) ,
		m_Result ( S_OK ) ,
		m_ProcessIdentifier ( 0 ) ,
		m_ReferenceCount ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration_Element :: ~CServerObject_DecoupledClientRegistration_Element ()
{
	Clear () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CServerObject_DecoupledClientRegistration_Element :: Clear () 
{
	if ( m_Provider )
	{
		SysFreeString ( m_Provider ) ;
		m_Provider = NULL ;
	}

	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
		m_CreationTime = NULL ;
	}

	if ( m_User )
	{
		SysFreeString ( m_User ) ;
		m_User = NULL ;
	}

	if ( m_Locale )
	{
		SysFreeString ( m_Locale ) ;
		m_Locale = NULL ;
	}

	if ( m_Scope )
	{
		SysFreeString ( m_Scope ) ;
		m_Scope = NULL ;
	}

	if ( m_Clsid ) 
	{
		SysFreeString ( m_Clsid ) ;
		m_Clsid = NULL ;
	}

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
		m_MarshaledProxy = NULL ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration_Element &CServerObject_DecoupledClientRegistration_Element :: operator= ( const CServerObject_DecoupledClientRegistration_Element &a_Key )
{
	if ( m_Provider )
	{
		SysFreeString ( m_Provider ) ;
		m_Provider = NULL ;
	}

	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
		m_CreationTime = NULL ;
	}

	if ( m_User )
	{
		SysFreeString ( m_User ) ;
		m_User = NULL ;
	}

	if ( m_Locale )
	{
		SysFreeString ( m_Locale ) ;
		m_Locale = NULL ;
	}

	if ( m_Scope )
	{
		SysFreeString ( m_Scope ) ;
		m_Scope = NULL ;
	}

	if ( m_Clsid ) 
	{
		SysFreeString ( m_Clsid ) ;
		m_Clsid = NULL ;
	}

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
		m_MarshaledProxy = NULL ;
	}

	if ( a_Key.m_Provider )
	{
		m_Provider = SysAllocString ( a_Key.m_Provider ) ;
	}

	if ( a_Key.m_CreationTime )
	{
		m_CreationTime = SysAllocString ( a_Key.m_CreationTime ) ;
	}

	if ( a_Key.m_User )
	{
		m_User = SysAllocString ( a_Key.m_User ) ;
	}

	if ( a_Key.m_Locale )
	{
		m_Locale = SysAllocString ( a_Key.m_Locale ) ;
	}

	if ( a_Key.m_Scope )
	{
		m_Scope = SysAllocString ( a_Key.m_Scope ) ;
	}

	if ( a_Key.m_Clsid ) 
	{
		m_Clsid = SysAllocString ( a_Key.m_Clsid ) ;
	}

	m_MarshaledProxyLength = a_Key.m_MarshaledProxyLength ;

	if ( a_Key.m_MarshaledProxy )
	{
		m_MarshaledProxy = new BYTE [ a_Key.m_MarshaledProxyLength ] ;
		if ( m_MarshaledProxy )
		{
			CopyMemory ( m_MarshaledProxy , a_Key.m_MarshaledProxy , a_Key.m_MarshaledProxyLength ) ;
		}
	}

	return *this ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetProcessIdentifier ( DWORD a_ProcessIdentifier )
{
	m_ProcessIdentifier = a_ProcessIdentifier ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetProvider ( BSTR a_Provider )
{
	HRESULT t_Result = S_OK ;

	if ( m_Provider )
	{
		SysFreeString ( m_Provider ) ;
	}

	m_Provider = SysAllocString ( a_Provider ) ;
	if ( m_Provider == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetLocale ( BSTR a_Locale )
{
	HRESULT t_Result = S_OK ;

	if ( m_Locale )
	{
		SysFreeString ( m_Locale ) ;
	}

	m_Locale = SysAllocString ( a_Locale ) ;
	if ( m_Locale == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetUser ( BSTR a_User )
{
	HRESULT t_Result = S_OK ;

	if ( m_User )
	{
		SysFreeString ( m_User ) ;
	}

	m_User = SysAllocString ( a_User ) ;
	if ( m_User == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetScope ( BSTR a_Scope )
{
	HRESULT t_Result = S_OK ;

	if ( m_Scope )
	{
		SysFreeString ( m_Scope ) ;
	}

	m_Scope = SysAllocString ( a_Scope ) ;
	if ( m_Scope == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetCreationTime ( BSTR a_CreationTime )
{
	HRESULT t_Result = S_OK ;

	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
	}

	m_CreationTime = SysAllocString ( a_CreationTime ) ;
	if ( m_CreationTime == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetClsid ( BSTR a_Clsid )
{
	HRESULT t_Result = S_OK ;

	if ( m_Clsid )
	{
		SysFreeString ( m_Clsid ) ;
	}

	m_Clsid = SysAllocString ( a_Clsid ) ;
	if ( m_Clsid == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetMarshaledProxy ( BYTE *a_MarshaledProxy , ULONG a_MarshaledProxyLength )
{
	HRESULT t_Result = S_OK ;

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
	}

	m_MarshaledProxyLength = a_MarshaledProxyLength ;
	m_MarshaledProxy = new BYTE [ a_MarshaledProxyLength ] ;
	if ( m_MarshaledProxy )
	{
		CopyMemory ( m_MarshaledProxy , a_MarshaledProxy , a_MarshaledProxyLength ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledClientRegistration_Element :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledClientRegistration_Element :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: Validate ()
{
	CWbemDateTime t_CreationTime ;

	HRESULT t_Result = t_CreationTime.PutValue ( m_CreationTime ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		HANDLE t_Handle = OpenProcess (

			PROCESS_QUERY_INFORMATION ,
			FALSE ,
			m_ProcessIdentifier
		) ;

		if ( t_Handle ) 
		{
			FILETIME t_CreationFileTime ;
			FILETIME t_ExitFileTime ;
			FILETIME t_KernelFileTime ;
			FILETIME t_UserFileTime ;

			BOOL t_Status = OS::GetProcessTimes (

			  t_Handle ,
			  & t_CreationFileTime,
			  & t_ExitFileTime,
			  & t_KernelFileTime,
			  & t_UserFileTime
			) ;

			if ( t_Status ) 
			{
				CWbemDateTime t_Time ;
				t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;

				if ( t_CreationTime.Preceeds ( t_Time ) )
				{
					t_Result = WBEM_E_NOT_FOUND ;
				}
			}

			CloseHandle ( t_Handle ) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: Load ( BSTR a_Clsid )
{
	HRESULT t_Result = S_OK ;

	Clear () ;

	t_Result = SetClsid ( a_Clsid ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		LPWSTR t_HomeClientClsid_String = NULL ;
		t_Result = WmiHelper :: ConcatenateStrings ( 

			3, 
			& t_HomeClientClsid_String , 
			s_Strings_Reg_HomeClient ,
			L"\\" ,
			a_Clsid
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			HKEY t_HomeClientClsid_Key ;

			LONG t_RegResult = OS::RegOpenKeyEx (

				HKEY_LOCAL_MACHINE ,
				t_HomeClientClsid_String ,
				0 ,
				KEY_READ ,
				& t_HomeClientClsid_Key 
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_CreationTime , m_CreationTime ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_Provider , m_Provider ) ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_Scope , m_Scope ) ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_Locale , m_Locale ) ;
					if ( t_Result == ERROR_FILE_NOT_FOUND )
					{	
						t_Result = S_OK ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_User , m_User ) ;
					if ( t_Result == ERROR_FILE_NOT_FOUND )
					{	
						t_Result = S_OK ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_ByteArray ( t_HomeClientClsid_Key , s_Strings_Reg_MarshaledProxy , m_MarshaledProxy , m_MarshaledProxyLength ) ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_DWORD ( t_HomeClientClsid_Key , s_Strings_Reg_ProcessIdentifier , m_ProcessIdentifier ) ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = Validate () ;
				}

				RegCloseKey ( t_HomeClientClsid_Key ) ;
			}
			else
			{
				t_Result = WBEM_E_NOT_FOUND ;
			}

			SysFreeString ( t_HomeClientClsid_String ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( FAILED ( t_Result ) )
	{
		Delete ( a_Clsid ) ;
	}

	return t_Result ;
}

HRESULT 
CServerObject_DecoupledClientRegistration_Element::VerifyClientKey(void)
{
	HKEY key;
	DWORD t_Disposition = 0 ;

	LONG t_RegResult = OS::RegCreateKeyEx (
		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeClient ,
		0 ,
		NULL ,
		0 ,
		KEY_ALL_ACCESS,
		NULL ,
		& key ,
		& t_Disposition                     
	) ;
	if (t_RegResult!=ERROR_SUCCESS) return HRESULT_FROM_WIN32(t_RegResult);

	SetClientSecurity(key);
	RegCloseKey(key);
	
	return S_OK;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT CServerObject_DecoupledClientRegistration_Element :: Save ( BSTR a_Clsid )
{
	HRESULT t_Result = S_OK ;

	t_Result = SetClsid ( a_Clsid ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		LPWSTR t_HomeClientClsid_String = NULL ;
		t_Result = WmiHelper :: ConcatenateStrings ( 

			2, 
			& t_HomeClientClsid_String , 
			s_Strings_Reg_HomeClient ,
			m_Clsid
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			HKEY t_HomeClient_Key ;
			DWORD t_Disposition = 0 ;
			
			LONG t_RegResult = OS::RegCreateKeyEx (
				HKEY_LOCAL_MACHINE ,
				s_Strings_Reg_HomeClient ,
				0 ,
				NULL ,
				0 ,
				KEY_WRITE,
				NULL ,
				&t_HomeClient_Key ,
				& t_Disposition                     
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				HKEY t_HomeClientClsid_Key ;

				LONG t_RegResult = OS::RegCreateKeyEx (

					t_HomeClient_Key ,
					m_Clsid ,
					0 ,
					NULL ,
					REG_OPTION_VOLATILE ,
					KEY_WRITE ,
					NULL ,
					& t_HomeClientClsid_Key ,
					& t_Disposition                     
				) ;

				if ( t_RegResult == ERROR_SUCCESS )
				{
					t_Result = SetSecurity ( t_HomeClientClsid_Key , KEY_READ ) ;

					if ( t_Disposition == REG_CREATED_NEW_KEY )
					{
						t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_CreationTime , m_CreationTime ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_Provider , m_Provider ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_Scope , m_Scope ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( m_Locale )
							{
								t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_Locale , m_Locale ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( m_User )
							{
								t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_User , m_User ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = ProviderSubSystem_Common_Globals :: Save_ByteArray ( t_HomeClientClsid_Key , s_Strings_Reg_MarshaledProxy , m_MarshaledProxy , m_MarshaledProxyLength ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = ProviderSubSystem_Common_Globals :: Save_DWORD ( t_HomeClientClsid_Key , s_Strings_Reg_ProcessIdentifier , m_ProcessIdentifier ) ;
						}
					}
					else
					{
						t_Result = WBEM_E_ALREADY_EXISTS ;
					}

					RegCloseKey ( t_HomeClientClsid_Key ) ;
				}

				RegCloseKey ( t_HomeClient_Key ) ;
			}

			SysFreeString ( t_HomeClientClsid_String ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: Delete ( BSTR a_Clsid )
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_HomeClientClsid_String = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		3, 
		& t_HomeClientClsid_String , 
		s_Strings_Reg_HomeClient ,
		L"\\" ,
		a_Clsid
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		HKEY t_HomeClientClsid_Key ;

		LONG t_RegResult = OS::RegOpenKeyEx (

			HKEY_LOCAL_MACHINE ,
			t_HomeClientClsid_String ,
			0 ,
			KEY_READ ,
			& t_HomeClientClsid_Key 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			BYTE *t_MarshaledProxy = NULL ;
			ULONG t_MarshaledProxyLength = 0 ;

			t_Result = ProviderSubSystem_Common_Globals :: Load_ByteArray (

				t_HomeClientClsid_Key , 
				s_Strings_Reg_MarshaledProxy , 
				t_MarshaledProxy , 
				t_MarshaledProxyLength
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = ProviderSubSystem_Common_Globals :: ReleaseRegistration ( 

					t_MarshaledProxy , 
					t_MarshaledProxyLength
				) ;

				if ( t_MarshaledProxy )
				{
					delete [] t_MarshaledProxy ;
				}
			}

			RegCloseKey ( t_HomeClientClsid_Key ) ;
		}

		t_RegResult = OS::RegDeleteKey (

			HKEY_LOCAL_MACHINE ,
			t_HomeClientClsid_String
		) ;

		if ( t_RegResult != ERROR_SUCCESS )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		SysFreeString ( t_HomeClientClsid_String ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration :: CServerObject_DecoupledClientRegistration (

	WmiAllocator &a_Allocator 

) : m_Queue ( a_Allocator ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration :: ~CServerObject_DecoupledClientRegistration ()
{
	m_Queue.UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledClientRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledClientRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration :: Load ()
{
	HRESULT t_Result = S_OK ;

	HKEY t_HomeClient_Key ;

	LONG t_RegResult = OS::RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeClient ,
		0 ,
		KEY_READ ,
		& t_HomeClient_Key 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		DWORD t_Count = 0 ;
		DWORD t_Size = 16 ;

		BSTR *t_Elements = ( BSTR * ) malloc ( sizeof ( BSTR ) * t_Size ) ;
		if ( t_Elements )
		{
			FILETIME t_FileTime ;
			DWORD t_Class ;
			BOOL t_Continue = TRUE ;

			while ( SUCCEEDED ( t_Result ) && t_Continue )
			{
				DWORD t_NameLength = 256 ;
				wchar_t t_Name [ 256 ] ;

				LONG t_RegResult = OS::RegEnumKeyEx (

					t_HomeClient_Key ,
					t_Count ,
					t_Name ,
					& t_NameLength ,            // size of subkey buffer
					NULL ,
					NULL ,
					NULL ,
					& t_FileTime
				) ;

				if ( t_RegResult == ERROR_SUCCESS )
				{
					if ( t_Count >= t_Size )
					{
						BSTR *t_NewElements = ( BSTR * ) realloc ( t_Elements , sizeof ( BSTR ) * ( t_Size + 16 ) ) ;
						if ( t_NewElements )
						{
							t_Elements = t_NewElements ;
							t_Size = t_Size + 16 ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Elements [ t_Count ] = SysAllocString ( t_Name ) ;
						if ( t_Elements [ t_Count ]  )
						{
                                                        t_Count ++ ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
				else if ( t_RegResult == ERROR_NO_MORE_ITEMS )
				{
					t_Continue = FALSE ;
				}
				else
				{
					t_Continue = FALSE ;
	// Generate message
				}
			}

			if ( t_Elements )
			{
				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_Elements [ t_Index ] )
					{
						CServerObject_DecoupledClientRegistration_Element t_Element ;
						HRESULT t_TempResult = t_Element.Load ( t_Elements [ t_Index ] ) ;
						if ( SUCCEEDED ( t_TempResult ) )
						{
							m_Queue.EnQueue ( t_Element ) ;
						}
						else
						{
			// Generate message
						}

						SysFreeString ( t_Elements [ t_Index ] ) ;
					}
				}

				free ( t_Elements ) ;
			}
		}
		else
		{

		}

		RegCloseKey ( t_HomeClient_Key ) ;
    }
    else
	{

    	    t_Result = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,t_RegResult);
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration :: Load (

	BSTR a_Provider ,
	BSTR a_User ,
	BSTR a_Locale ,
	BSTR a_Scope
)
{
	HRESULT t_Result = S_OK ;

	HKEY t_HomeClient_Key ;

	LONG t_RegResult = OS::RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeClient ,
		0 ,
		KEY_READ ,
		& t_HomeClient_Key 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		DWORD t_Index = 0 ;
		FILETIME t_FileTime ;
		DWORD t_Class ;
		BOOL t_Continue = TRUE ;

		while ( SUCCEEDED ( t_Result ) && t_Continue )
		{
			DWORD t_NameLength = 256 ;
			wchar_t t_Name [ 256 ] ;

			LONG t_RegResult = OS::RegEnumKeyEx (

				t_HomeClient_Key ,
				t_Index ,
				t_Name ,
				& t_NameLength ,            // size of subkey buffer
				NULL ,
				NULL ,
				NULL ,
				& t_FileTime
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				CServerObject_DecoupledClientRegistration_Element t_Element ;
				HRESULT t_TempResult = t_Element.Load ( t_Name ) ;
				if ( SUCCEEDED ( t_TempResult ) )
				{
					BOOL t_Compare = ( wbem_wcsicmp ( a_Provider , t_Element.GetProvider () ) == 0 ) ;
					t_Compare = t_Compare && ( wbem_wcsicmp ( a_Scope , t_Element.GetScope () ) == 0 ) ;

					if ( t_Compare )
					{
						if ( ( a_Locale == NULL ) && ( t_Element.GetLocale () == NULL ) )
						{
						}
						else
						{
							if ( ( a_Locale ) && ( t_Element.GetLocale () ) )
							{
								t_Compare = ( wbem_wcsicmp ( a_Locale , t_Element.GetLocale () ) == 0 ) ;
							}
							else
							{
								t_Compare = FALSE ;
							}
						}
					}

					if ( t_Compare )
					{
						if ( ( a_User == NULL ) && ( t_Element.GetUser () == NULL ) )
						{
						}
						else
						{
							if ( ( a_User ) && ( t_Element.GetUser () ) )
							{
								t_Compare = ( wbem_wcsicmp ( a_User , t_Element.GetUser () ) == 0 ) ;
							}
							else
							{
								t_Compare = FALSE ;
							}
						}
					}

					if ( t_Compare )
					{
						m_Queue.EnQueue ( t_Element ) ;
					}
				}
				else
				{
// Generate message
				}
			}
			else if ( t_RegResult == ERROR_NO_MORE_ITEMS )
			{
				t_Continue = FALSE ;
			}
			else
			{
				t_Continue = FALSE ;
// Generate message
			}

			t_Index ++ ;
		}

		RegCloseKey ( t_HomeClient_Key ) ;
	}
	else
	{

    	    t_Result = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,t_RegResult);
	}


	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledServerRegistration :: CServerObject_DecoupledServerRegistration ( WmiAllocator &a_Allocator )

	:	m_CreationTime ( NULL ) ,
		m_MarshaledProxy ( NULL ) ,
		m_MarshaledProxyLength ( 0 ) ,
		m_Result ( S_OK ) ,
		m_ProcessIdentifier ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledServerRegistration :: ~CServerObject_DecoupledServerRegistration ()
{
	Clear () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CServerObject_DecoupledServerRegistration :: Clear () 
{
	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
		m_CreationTime = NULL ;
	}

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
		m_MarshaledProxy = NULL ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledServerRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledServerRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: Validate ()
{
	CWbemDateTime t_CreationTime ;

	HRESULT t_Result = t_CreationTime.PutValue ( m_CreationTime ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		HANDLE t_Handle = OpenProcess (

			PROCESS_QUERY_INFORMATION ,
			FALSE ,
			m_ProcessIdentifier
		) ;

		if ( t_Handle ) 
		{
			FILETIME t_CreationFileTime ;
			FILETIME t_ExitFileTime ;
			FILETIME t_KernelFileTime ;
			FILETIME t_UserFileTime ;

			BOOL t_Status = OS::GetProcessTimes (

			  t_Handle ,
			  & t_CreationFileTime,
			  & t_ExitFileTime,
			  & t_KernelFileTime,
			  & t_UserFileTime
			) ;

			if ( t_Status ) 
			{
				CWbemDateTime t_Time ;
				t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;

				if ( t_CreationTime.Preceeds ( t_Time ) )
				{
					t_Result = WBEM_E_NOT_FOUND ;
				}
			}

			CloseHandle ( t_Handle ) ;
		}
		else if(GetLastError() == ERROR_ACCESS_DENIED)
		{
            // Expected if this process is runned as low right user
            t_Result = S_OK;

		} else
		{
			t_Result = WBEM_E_NOT_FOUND;
		}
	}

 	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: Load ()
{
	HRESULT t_Result = S_OK ;

	Clear () ;

	HKEY t_HomeServerClsid_Key ;

	LONG t_RegResult = OS::RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeServer ,
		0 ,
		KEY_READ ,
		& t_HomeServerClsid_Key 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		ON_BLOCK_EXIT(RegCloseKey, t_HomeServerClsid_Key);
		
		if (OS::secureOS_)
		{
		SECURITY_INFORMATION t_SecurityInformation = OWNER_SECURITY_INFORMATION ;
		SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;
		DWORD t_Length = 0 ;

		t_RegResult = RegGetKeySecurity (

			t_HomeServerClsid_Key ,
			t_SecurityInformation ,
			t_SecurityDescriptor ,
			& t_Length 
		) ;

		if ( t_RegResult == ERROR_INSUFFICIENT_BUFFER )
		{
			t_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_Length ] ;
			if ( t_SecurityDescriptor )
			{
				t_RegResult = RegGetKeySecurity (

					t_HomeServerClsid_Key ,
					t_SecurityInformation ,
					t_SecurityDescriptor ,
					& t_Length 
				) ;

				if ( t_RegResult == ERROR_SUCCESS )
				{
					SID *t_Sid = NULL ;
					BOOL t_Defaulted = FALSE ;

					BOOL t_Status = GetSecurityDescriptorOwner (

					  t_SecurityDescriptor ,
					  ( PSID * ) & t_Sid ,
					  & t_Defaulted
					) ;

					if ( t_Status )
					{
						SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

						PSID t_Administrator_Sid = NULL ;

						BOOL t_BoolResult = AllocateAndInitializeSid (

							& t_NtAuthoritySid ,
							2 ,
							SECURITY_BUILTIN_DOMAIN_RID,
							DOMAIN_ALIAS_RID_ADMINS,
							0,
							0,
							0,
							0,
							0,
							0,
							& t_Administrator_Sid
						);

						if ( t_BoolResult )
						{
							if ( EqualSid ( t_Administrator_Sid , t_Sid ) == FALSE )
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}

							if ( t_Administrator_Sid )
							{
								FreeSid ( t_Administrator_Sid ) ;
							}
						}
						else
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				delete [] ( BYTE * ) t_SecurityDescriptor ;
			}
		}
		else
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
		}
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeServerClsid_Key , s_Strings_Reg_CreationTime , m_CreationTime ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Load_ByteArray ( t_HomeServerClsid_Key , s_Strings_Reg_MarshaledProxy , m_MarshaledProxy , m_MarshaledProxyLength ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Load_DWORD ( t_HomeServerClsid_Key , s_Strings_Reg_ProcessIdentifier , m_ProcessIdentifier ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = Validate () ;
		}
	}
    else
	{
    	    t_Result = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,t_RegResult);
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: SetCreationTime ( BSTR a_CreationTime )
{
	HRESULT t_Result = S_OK ;

	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
	}

	m_CreationTime = SysAllocString ( a_CreationTime ) ;
	if ( m_CreationTime == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: SetProcessIdentifier ( DWORD a_ProcessIdentifier )
{
	m_ProcessIdentifier = a_ProcessIdentifier ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: SetMarshaledProxy ( BYTE *a_MarshaledProxy , ULONG a_MarshaledProxyLength )
{
	HRESULT t_Result = S_OK ;

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
	}

	m_MarshaledProxyLength = a_MarshaledProxyLength ;
	m_MarshaledProxy = new BYTE [ a_MarshaledProxyLength ] ;
	if ( m_MarshaledProxy )
	{
		CopyMemory ( m_MarshaledProxy , a_MarshaledProxy , a_MarshaledProxyLength ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: Save ()
{
	HRESULT t_Result = S_OK ;

	HKEY t_HomeServer_Key ;
	DWORD t_Disposition = 0 ;

	LONG t_RegResult = OS::RegCreateKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeServer ,
		0 ,
		NULL ,
		REG_OPTION_VOLATILE ,
		KEY_WRITE ,
		NULL ,
		& t_HomeServer_Key ,
		& t_Disposition                     
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		HRESULT t_TempResult = SetSecurity ( t_HomeServer_Key , KEY_READ ) ;

		t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeServer_Key , s_Strings_Reg_CreationTime , m_CreationTime ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Save_ByteArray ( t_HomeServer_Key , s_Strings_Reg_MarshaledProxy , m_MarshaledProxy , m_MarshaledProxyLength ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Save_DWORD ( t_HomeServer_Key , s_Strings_Reg_ProcessIdentifier , m_ProcessIdentifier ) ;
		}

		RegCloseKey ( t_HomeServer_Key ) ;
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: Delete ()
{
	HRESULT t_Result = S_OK ;

	HKEY t_HomeServerClsid_Key ;

	LONG t_RegResult = OS::RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeServer ,
		0 ,
		KEY_READ ,
		& t_HomeServerClsid_Key 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
        ON_BLOCK_EXIT(RegCloseKey, t_HomeServerClsid_Key);

		BYTE *t_MarshaledProxy = NULL ;
		ULONG t_MarshaledProxyLength = 0 ;

		t_Result = ProviderSubSystem_Common_Globals :: Load_ByteArray (

			t_HomeServerClsid_Key , 
			s_Strings_Reg_MarshaledProxy , 
			t_MarshaledProxy , 
			t_MarshaledProxyLength
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: ReleaseRegistration ( 

				t_MarshaledProxy , 
				t_MarshaledProxyLength
			) ;

			if ( t_MarshaledProxy )
			{
				delete [] t_MarshaledProxy ;
			}
		}
	}

	t_RegResult = OS::RegDeleteKey (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeServer
	) ;

	if ( t_RegResult != ERROR_SUCCESS )
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provregistrar.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include <PreComp.h>
#include <wbemint.h>
#include "Globals.h"
#include "CGlobals.h"
#include "Guids.h"
    
 #include "DateTime.h"
 #include "ProvRegDecoupled.h"
 #include "ProvInterceptor.h"
 #include "ProvRegistrar.h"
    
  #include <os.h>
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    CServerObject_ProviderRegistrar_Base :: CServerObject_ProviderRegistrar_Base (
    
    	WmiAllocator &a_Allocator 
    
    ) : 
    	m_Allocator ( a_Allocator ) ,
    	m_Clsid ( NULL ) ,
    	m_Provider ( NULL ) ,
    	m_User ( NULL ) ,
    	m_Locale ( NULL ) ,
    	m_Scope ( NULL ) ,
    	m_Registration ( NULL ) ,
    	m_Registered ( FALSE ),
		m_MarshaledProxy ( NULL ) ,
		m_MarshaledProxyLength ( 0 ) ,
    	m_CriticalSection(NOTHROW_LOCK)
    {
    	ZeroMemory ( & m_Identity , sizeof ( m_Identity ) ) ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    CServerObject_ProviderRegistrar_Base::~CServerObject_ProviderRegistrar_Base ()
    {
		if ( m_Provider )
    	{
    		m_Provider->Release () ;
    	}

    	if ( m_Clsid )
    	{
    		SysFreeString ( m_Clsid ) ;
    	}
    
    	if ( m_User )
    	{
    		SysFreeString ( m_User ) ;
    	}
    
    	if ( m_Locale ) 
    	{
    		SysFreeString ( m_Locale ) ;
    	}
    
    	if ( m_Scope ) 
    	{
    		SysFreeString ( m_Scope ) ;
    	}
    
    	if ( m_Registration )
    	{
    		SysFreeString ( m_Registration ) ;
    	}

    	if ( m_MarshaledProxy )
    	{
    		ProviderSubSystem_Common_Globals :: ReleaseRegistration (

    			m_MarshaledProxy ,
    			m_MarshaledProxyLength
    		) ;

    		delete [] m_MarshaledProxy ;
    		m_MarshaledProxy = NULL ;
    		m_MarshaledProxyLength = 0 ;
    	}

    	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    HRESULT CServerObject_ProviderRegistrar_Base :: Initialize ()
    {
    	WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
    	if ( t_StatusCode == e_StatusCode_Success )
    	{
    		return S_OK ;
    	}
    	else
    	{
    		return WBEM_E_OUT_OF_MEMORY ;
    	}
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    HRESULT CServerObject_ProviderRegistrar_Base :: SaveToRegistry (
    
    	long a_Flags ,
    	IWbemContext *a_Context ,
    	LPCWSTR a_User ,
    	LPCWSTR a_Locale ,
    	LPCWSTR a_Registration ,
    	LPCWSTR a_Scope ,
    	IUnknown *a_Unknown ,
    	BYTE *a_MarshaledProxy ,
    	DWORD a_MarshaledProxyLength
    )
    {
    	HRESULT t_Result = S_OK ;
    
    	CServerObject_DecoupledClientRegistration_Element t_Element ;
    
    	BSTR t_CreationTime = NULL ;
    
    	FILETIME t_CreationFileTime ;
    	FILETIME t_ExitFileTime ;
    	FILETIME t_KernelFileTime ;
    	FILETIME t_UserFileTime ;
    
  	BOOL t_Status = OS::GetProcessTimes (
 
    
    		  GetCurrentProcess (),
    		  & t_CreationFileTime,
    		  & t_ExitFileTime,
    		  & t_KernelFileTime,
    		  & t_UserFileTime
    	);
    
    	if ( t_Status ) 
    	{
    		CWbemDateTime t_Time ;
    		t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;
    
    		t_Result = t_Time.GetValue ( & t_CreationTime ) ;
    		if ( SUCCEEDED ( t_Result ) ) 
    		{
    			t_Result = t_Element.SetProcessIdentifier ( GetCurrentProcessId () ) ;
    
    			if ( SUCCEEDED ( t_Result ) ) 
    			{
    				if ( a_Locale ) 
    				{
    					t_Result = t_Element.SetLocale ( ( BSTR ) a_Locale ) ;
    				}
    			}
    
    			if ( SUCCEEDED ( t_Result ) ) 
    			{
    				if ( a_User ) 
    				{
    					t_Result = t_Element.SetUser ( ( BSTR ) a_User ) ;
    				}
    			}
    
    			if ( SUCCEEDED ( t_Result ) ) 
    			{
    				t_Result = t_Element.SetProvider ( ( BSTR ) a_Registration ) ;
    			}
    
    			if ( SUCCEEDED ( t_Result ) ) 
    			{
    				t_Result = t_Element.SetScope ( ( BSTR ) a_Scope ) ;
    			}
    
    			if ( SUCCEEDED ( t_Result ) ) 
    			{
    				t_Result = t_Element.SetCreationTime ( ( BSTR ) t_CreationTime ) ;
    			}
    
    			if ( SUCCEEDED ( t_Result ) ) 
    			{
    				t_Result = t_Element.SetMarshaledProxy ( a_MarshaledProxy , a_MarshaledProxyLength ) ;
    			}
    
    			if ( SUCCEEDED ( t_Result ) )
    			{
    				t_Result = t_Element.Save ( m_Clsid ) ;
    			}
    
    			SysFreeString ( t_CreationTime ) ;
    		}
    		else
    		{
    			t_Result = WBEM_E_UNEXPECTED ;
    		}
    	}
    	else
    	{
    		t_Result = WBEM_E_UNEXPECTED ;
    	}
    
    	return t_Result ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    HRESULT CServerObject_ProviderRegistrar_Base :: DirectRegister (
    
    	GUID &a_Identity ,
    	long a_Flags ,
    	IWbemContext *a_Context ,
    	LPCWSTR a_User ,
    	LPCWSTR a_Locale ,
    	LPCWSTR a_Registration ,
    	LPCWSTR a_Scope ,
    	IUnknown *a_Unknown ,
    	BYTE *a_MarshaledProxy ,
    	DWORD a_MarshaledProxyLength
    )
    {
    	HRESULT t_Result = S_OK ;
    
    	CServerObject_DecoupledServerRegistration t_Element ( m_Allocator ) ;
    
    	BSTR t_CreationTime = NULL ;
    
    	FILETIME t_CreationFileTime ;
    	FILETIME t_ExitFileTime ;
    	FILETIME t_KernelFileTime ;
    	FILETIME t_UserFileTime ;
    
  	BOOL t_Status = OS::GetProcessTimes (
 
    
    		  GetCurrentProcess (),
    		  & t_CreationFileTime,
    		  & t_ExitFileTime,
    		  & t_KernelFileTime,
    		  & t_UserFileTime
    	);
    
    	if ( t_Status ) 
    	{
    		CWbemDateTime t_Time ;
    		t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;
    
    		t_Result = t_Time.GetValue ( & t_CreationTime ) ;
    		if ( SUCCEEDED ( t_Result ) ) 
    		{
    			t_Result = t_Element.Load () ;
    			if ( SUCCEEDED ( t_Result ) )
    			{
    				BSTR t_ServerCreationTime = t_Element.GetCreationTime () ;
    				DWORD t_ProcessIdentifier = t_Element.GetProcessIdentifier () ;
    				BYTE *t_MarshaledProxy = t_Element.GetMarshaledProxy () ;
    				DWORD t_MarshaledProxyLength = t_Element.GetMarshaledProxyLength () ;
    
    				IUnknown *t_Unknown = NULL ;
 				HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: UnMarshalRegistration ( & t_Unknown , t_MarshaledProxy , t_MarshaledProxyLength ) ;
 
    				if ( SUCCEEDED ( t_TempResult ) )
    				{
    					_IWmiProviderSubsystemRegistrar *t_Registrar = NULL ;
    						
    					t_Result = t_Unknown->QueryInterface ( IID__IWmiProviderSubsystemRegistrar , ( void ** ) & t_Registrar ) ;
    					if ( SUCCEEDED ( t_Result ) )
    					{
    						BOOL t_Impersonating = FALSE ;
    						IUnknown *t_OldContext = NULL ;
    						IServerSecurity *t_OldSecurity = NULL ;
    
 						t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
 
    						if ( SUCCEEDED ( t_Result ) )
    						{
    							BOOL t_Revert = FALSE ;
    							IUnknown *t_Proxy = NULL ;
    
 							t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID__IWmiProviderSubsystemRegistrar , t_Registrar , t_Proxy , t_Revert ) ;
 
    							if ( t_Result == WBEM_E_NOT_FOUND )
    							{
    								try
    								{
    									t_Result = t_Registrar->Register ( 
    
    										0 ,
    										a_Context ,
    										a_User ,
    										a_Locale ,
    										a_Scope ,
    										a_Registration ,
    										GetCurrentProcessId () ,
    										a_Unknown ,
    										a_Identity 
    									) ;
    								}
    								catch ( ... )
    								{
    									t_Result = WBEM_E_PROVIDER_FAILURE ;
    								}
    							}
    							else
    							{
    								if ( SUCCEEDED ( t_Result ) )
    								{
    									_IWmiProviderSubsystemRegistrar *t_RegistrarProxy = ( _IWmiProviderSubsystemRegistrar * ) t_Proxy ;
    
    									// Set cloaking on the proxy
    									// =========================
    
  									DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;
    
  									t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (
    
    										t_RegistrarProxy ,
    										RPC_C_AUTHN_LEVEL_DEFAULT , 
    										t_ImpersonationLevel
    									) ;
    
    									if ( SUCCEEDED ( t_Result ) )
    									{
  										t_Result = OS::CoImpersonateClient () ;
    										if ( SUCCEEDED ( t_Result ) )
    										{
    											try
    											{
    												t_Result = t_RegistrarProxy->Register ( 
    
    													0 ,
    													a_Context ,
    													a_User ,
    													a_Locale ,
    													a_Scope ,
    													a_Registration ,
    													GetCurrentProcessId () ,
    													a_Unknown ,
    													a_Identity 
    												) ;
    											}
    											catch ( ... )
    											{
    												t_Result = WBEM_E_PROVIDER_FAILURE ;
    											}
    
    											CoRevertToSelf () ;
    										}
    										else
    										{
    											t_Result = WBEM_E_ACCESS_DENIED ;
    										}
    									}	
    
  									DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
    								}
    							}
    
  							DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
    						}
    
    						t_Registrar->Release () ;
    					}
    
    					t_Unknown->Release () ;
    				}
    			}
    			else
    			{
    				t_Result = S_OK ;
    			}
    
    			SysFreeString ( t_CreationTime ) ;
    		}
    		else
    		{
    			t_Result = WBEM_E_UNEXPECTED ;
    		}
    	}
    	else
    	{
    		t_Result = WBEM_E_UNEXPECTED ;
    	}
    
    	return t_Result ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    HRESULT CServerObject_ProviderRegistrar_Base :: DirectUnRegister (
    
    	long a_Flags ,
    	IWbemContext *a_Context ,
    	LPCWSTR a_User ,
    	LPCWSTR a_Locale ,
    	LPCWSTR a_Registration ,
    	LPCWSTR a_Scope ,
    	GUID &a_Identity  
    )
    {
    	HRESULT t_Result = S_OK ;
    
    	CServerObject_DecoupledServerRegistration t_Element ( m_Allocator ) ;
    
    	FILETIME t_CreationFileTime ;
    	FILETIME t_ExitFileTime ;
    	FILETIME t_KernelFileTime ;
    	FILETIME t_UserFileTime ;
    
  	BOOL t_Status = OS::GetProcessTimes (
    
    		  GetCurrentProcess (),
    		  & t_CreationFileTime,
    		  & t_ExitFileTime,
    		  & t_KernelFileTime,
    		  & t_UserFileTime
    	);
    
    	if ( t_Status ) 
    	{
    		t_Result = t_Element.Load () ;
    		if ( SUCCEEDED ( t_Result ) )
    		{
  			BSTR t_ServerCreationTime = t_Element.GetCreationTime () ;
    			DWORD t_ProcessIdentifier = t_Element.GetProcessIdentifier () ;
    			BYTE *t_MarshaledProxy = t_Element.GetMarshaledProxy () ;
    			DWORD t_MarshaledProxyLength = t_Element.GetMarshaledProxyLength () ;
    
    			IUnknown *t_Unknown = NULL ;
  			t_Result = DecoupledProviderSubSystem_Globals :: UnMarshalRegistration ( & t_Unknown , t_MarshaledProxy , t_MarshaledProxyLength ) ;
    			if ( SUCCEEDED ( t_Result ) )
    			{
    				_IWmiProviderSubsystemRegistrar *t_Registrar = NULL ;
    					
    				t_Result = t_Unknown->QueryInterface ( IID__IWmiProviderSubsystemRegistrar , ( void ** ) & t_Registrar ) ;
    				if ( SUCCEEDED ( t_Result ) )
    				{
    					BOOL t_Impersonating = FALSE ;
    					IUnknown *t_OldContext = NULL ;
    					IServerSecurity *t_OldSecurity = NULL ;
    
  					t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
    					if ( SUCCEEDED ( t_Result ) )
    					{
    						BOOL t_Revert = FALSE ;
    						IUnknown *t_Proxy = NULL ;
    
  						t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID__IWmiProviderSubsystemRegistrar , t_Registrar , t_Proxy , t_Revert ) ;
    						if ( t_Result == WBEM_E_NOT_FOUND )
    						{
    							try
    							{
    								t_Result = t_Registrar->UnRegister ( 
    
    									0 ,
    									a_Context ,
    									a_User ,
    									a_Locale ,
    									a_Scope ,
    									a_Registration ,
    									a_Identity 
    								) ;
    							}
    							catch ( ... )
    							{
    								t_Result = WBEM_E_PROVIDER_FAILURE ;
    							}
    						}
    						else
    						{
    							if ( SUCCEEDED ( t_Result ) )
    							{
    								_IWmiProviderSubsystemRegistrar *t_RegistrarProxy = ( _IWmiProviderSubsystemRegistrar * ) t_Proxy ;
    
    								// Set cloaking on the proxy
    								// =========================
    
  								DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;
    
  								t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (
    
    									t_RegistrarProxy ,
    									RPC_C_AUTHN_LEVEL_CONNECT , 
    									t_ImpersonationLevel
    								) ;
    
    								if ( SUCCEEDED ( t_Result ) )
    								{
  									t_Result = OS::CoImpersonateClient () ;
    									if ( SUCCEEDED ( t_Result ) )
    									{
    										try
    										{
    											t_Result = t_RegistrarProxy->UnRegister ( 
    
    												0 ,
    												a_Context ,
    												a_User ,
    												a_Locale ,
    												a_Scope ,
    												a_Registration ,
    												a_Identity 
    											) ;
    										}
    										catch ( ... )
    										{
    											t_Result = WBEM_E_PROVIDER_FAILURE ;
    										}
    
    										CoRevertToSelf () ;
    									}
    									else
    									{
    										t_Result = WBEM_E_ACCESS_DENIED ;
    									}
    								}	
    
  								HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
    							}
    						}
    
  						DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
    					}
    
    					t_Registrar->Release () ;
    				}
    
    				t_Unknown->Release () ;
    			}
    		}

			ProviderSubSystem_Common_Globals :: ReleaseRegistration (

				m_MarshaledProxy ,
				m_MarshaledProxyLength
			) ;

			delete [] m_MarshaledProxy ;
			m_MarshaledProxy = NULL ;
			m_MarshaledProxyLength = 0 ;

    	}
    	else
    	{
    		t_Result = WBEM_E_UNEXPECTED ;
  	}
  
  	return t_Result ;
  }
  
  /******************************************************************************
   *
   *	Name:
   *
   *	
   *  Description:
   *
   *	
   *****************************************************************************/
  
  HRESULT CServerObject_ProviderRegistrar_Base :: CreateInterceptor (
  
  	IWbemContext *a_Context ,
  	IUnknown *a_Unknown ,
  	BYTE *&a_MarshaledProxy ,
  	DWORD& a_MarshaledProxyLength ,
  	IUnknown *&a_MarshaledUnknown
  )
  {
  	IWbemLocator *t_Locator = NULL ;
  	IWbemServices *t_Service = NULL ;
  	CServerObject_ProviderRegistrationV1 *t_Registration = NULL ;
  
  	HRESULT t_Result = CoCreateInstance (
  
  		CLSID_WbemLocator ,
  		NULL ,
  		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
  		IID_IUnknown ,
  		( void ** )  & t_Locator
  	);
  
  	if ( SUCCEEDED ( t_Result ) )
  	{
  		t_Result = t_Locator->ConnectServer (
  
  			m_Scope ,
  			NULL ,
  			NULL,
  			NULL ,
  			0 ,
  			NULL,
  			NULL,
  			& t_Service
  		) ;
  
  		t_Locator->Release () ;
  	}
	
	if (FAILED(t_Result) && GetModuleHandleA("wbemcore.dll"))
	{
  	   t_Result = CoCreateInstance (
  		CLSID_WbemAdministrativeLocator,
  		NULL ,
  		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
  		IID_IUnknown ,
  		( void ** )  & t_Locator
  	);
	
	if ( SUCCEEDED ( t_Result ) )
  	{
  		t_Result = t_Locator->ConnectServer (
  
  			m_Scope ,
  			NULL ,
  			NULL,
  			NULL ,
  			0 ,
  			NULL,
  			NULL,
  			& t_Service
  		) ;
  
  		t_Locator->Release () ;
  	}
	}

 	if ( SUCCEEDED ( t_Result ) )
 	{
  		t_Registration = new CServerObject_ProviderRegistrationV1 ;
  		if ( t_Registration )
  		{
  			t_Registration->AddRef () ;
  
  			IWbemPath *t_NamespacePath = NULL ;
  
  			t_Result = CoCreateInstance (
  
  				CLSID_WbemDefPath ,
  				NULL ,
  				CLSCTX_INPROC_SERVER ,
  				IID_IWbemPath ,
  				( void ** )  & t_NamespacePath
  			) ;
  
  			if ( SUCCEEDED ( t_Result ) )
  			{
  				t_Result = t_NamespacePath->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , m_Scope ) ;
  			}
  
  			if ( SUCCEEDED( t_Result ) ) 
  			{
  				t_Result = t_Registration->SetContext ( 
  
  					a_Context ,
  					t_NamespacePath , 
  					t_Service
  				) ;
  				
  				if ( SUCCEEDED ( t_Result ) )
  				{
  					t_Result = t_Registration->Load ( 
  
  						e_All ,
  						NULL , 
  						m_Registration
  					) ;

  					if ( t_Result == WBEM_E_NOT_FOUND )
  					{
  						t_Result = WBEM_E_PROVIDER_NOT_FOUND ;
  					} 
  					if (SUCCEEDED(t_Result))
  					{
                        t_Result = ProviderSubSystem_Common_Globals::ValidateClientSecurity(*t_Registration);
                    };
  				}
  			}
                        if (t_NamespacePath) t_NamespacePath->Release();
  		}
  		else
  		{
  			t_Result = WBEM_E_OUT_OF_MEMORY ;
  		}
  	}
  
  	if ( SUCCEEDED ( t_Result ) )
  	{
  		CInterceptor_DecoupledClient *t_Provider = new CInterceptor_DecoupledClient ( 
  
  			m_Allocator ,
 			a_Unknown , 
  			t_Service ,
  			*t_Registration
  		) ;
  		
  		if ( t_Provider )
  		{
  			t_Provider->AddRef () ;
  
  			t_Result = t_Provider->ProviderInitialize () ;
  			if ( SUCCEEDED ( t_Result ) ) 
  			{
  				t_Result = t_Provider->QueryInterface ( IID_IUnknown , ( void ** ) & a_MarshaledUnknown ) ;
  				if ( SUCCEEDED ( t_Result ) )
  				{
  					t_Result = DecoupledProviderSubSystem_Globals :: MarshalRegistration ( 
  
  						a_MarshaledUnknown ,
  						a_MarshaledProxy ,
  						a_MarshaledProxyLength
  					) ;
  
  					if ( FAILED ( t_Result ) )
  					{
  						a_MarshaledUnknown->Release () ;
  						a_MarshaledUnknown = NULL ;
  					}
  				}
  			}
  
  			if ( SUCCEEDED ( t_Result ) )
  			{
  				m_Provider = t_Provider ;
  			}
  			else
  			{
  				t_Provider->Release () ;
  			}
  		}
  	}
  
  	if ( t_Registration )
  	{
  		t_Registration->Release () ;
  	}
  
  	if ( t_Service )
  	{
  		t_Service->Release () ;
    	}
    
    	return t_Result ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    HRESULT CServerObject_ProviderRegistrar_Base :: Register (
    
    	long a_Flags ,
    	IWbemContext *a_Context ,
    	LPCWSTR a_User ,
    	LPCWSTR a_Locale ,
    	LPCWSTR a_Scope ,
    	LPCWSTR a_Registration ,
    	IUnknown *a_Unknown
    )
    {
    	HRESULT t_Result = S_OK ;
    
 	if ( a_Scope == NULL || a_Registration == NULL || a_Unknown == NULL )
    	{
    		return WBEM_E_INVALID_PARAMETER ;
    	}
    		
    	WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;
    
    	try
    	{
    		if ( m_Registered == FALSE )
    		{
    			t_Result = CoCreateGuid ( & m_Identity ) ;
    			if ( SUCCEEDED ( t_Result ) )
    			{
    				BSTR t_Clsid = NULL ;
    
    				t_Result = StringFromCLSID (
    
    				  m_Identity ,
    				  & t_Clsid
    				) ;
    
    				if ( SUCCEEDED ( t_Result ) )
    				{
    					if ( m_Clsid ) 
    					{
    						SysFreeString ( m_Clsid ) ;
    						m_Clsid = NULL ;
    					}
    
    					if ( m_User )
    					{
    						SysFreeString ( m_User ) ;
    						m_User = NULL ;
    					}
    
    					if ( m_Locale ) 
    					{
    						SysFreeString ( m_Locale ) ;
    						m_Locale = NULL ;
    					}
    
    					if ( m_Scope ) 
    					{
    						SysFreeString ( m_Scope ) ;
    						m_Scope = NULL ;
    					}
    
    					if ( m_Registration )
    					{
    						SysFreeString ( m_Registration ) ;
    						m_Registration = NULL ;
    					}
    
    					m_Clsid = SysAllocString ( t_Clsid ) ;
    					if ( m_Clsid == NULL )
    					{
    						t_Result = WBEM_E_OUT_OF_MEMORY ;
    					}
    
    					if ( a_User )
    					{
    						m_User = SysAllocString ( a_User ) ;
    						if ( m_User == NULL )
    						{
    							t_Result = WBEM_E_OUT_OF_MEMORY ;
    						}
    					}
    
    					if ( m_Locale )
    					{
    						m_Locale = SysAllocString ( a_Locale ) ;
    						if ( m_Locale == NULL )
    						{
    							t_Result = WBEM_E_OUT_OF_MEMORY ;
    						}
    					}
    
    					m_Scope = SysAllocString ( a_Scope ) ;
    					if ( m_Scope == NULL )
    					{
    						t_Result = WBEM_E_OUT_OF_MEMORY ;
    					}
    
    					m_Registration = SysAllocString ( a_Registration ) ;
    					if ( m_Registration == NULL )
    					{
    						t_Result = WBEM_E_OUT_OF_MEMORY ;
    					}
    
    					if ( SUCCEEDED ( t_Result ) )
    					{
  						IUnknown *t_MarshaledUnknown = NULL ;
  
  						t_Result = CreateInterceptor (
  
  							a_Context ,
    							a_Unknown ,
    							m_MarshaledProxy ,
      							m_MarshaledProxyLength ,
      							t_MarshaledUnknown
       						) ;
    
    						if ( SUCCEEDED ( t_Result ) ) 
    						{
    							t_Result = DirectRegister (
    
    								m_Identity ,
    								a_Flags ,
    								a_Context ,
    								a_User ,
    								a_Locale ,
    								a_Registration ,
    								a_Scope ,
  								    t_MarshaledUnknown ,
    								m_MarshaledProxy ,
    								m_MarshaledProxyLength
    							) ;
    
 							t_Result = SaveToRegistry ( 
    
    								a_Flags ,
    								a_Context ,
    								a_User ,
    								a_Locale ,
    								a_Registration ,
    								a_Scope ,
	  								a_Unknown ,
    								m_MarshaledProxy ,
    								m_MarshaledProxyLength
    							) ;
    						}
    
  						if ( t_MarshaledUnknown )
  						{
  							t_MarshaledUnknown->Release () ;
    						}
    					}
    
    					CoTaskMemFree ( t_Clsid ) ;
    				}
    				else
    				{
    					t_Result = WBEM_E_OUT_OF_MEMORY ;
    				}
    			}
    			else
    			{
    				t_Result = WBEM_E_UNEXPECTED ;
    			}
    		}
    		else
    		{
    			t_Result = WBEM_E_PROVIDER_ALREADY_REGISTERED ;
    		}
    	}
    	catch ( ... )
    	{
    		t_Result = WBEM_E_PROVIDER_FAILURE ;
    	}
    
    	if ( SUCCEEDED ( t_Result ) )
    	{
    		m_Registered = TRUE ;
    	}
    
    	WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
    
    	return t_Result ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    HRESULT CServerObject_ProviderRegistrar_Base :: UnRegister ()
    {
    	HRESULT t_Result = S_OK ;
    
    	WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;
    
    	try
    	{
    		if ( m_Registered ) 
    		{
    			CServerObject_DecoupledClientRegistration_Element t_Element ;
  			t_Result = t_Element.Delete ( m_Clsid ) ;
    
    			HRESULT t_TempResult = DirectUnRegister ( 
    
    				0 ,
    				NULL ,
    				m_User ,
    				m_Locale ,
    				m_Registration ,
    				m_Scope ,
    				m_Identity
    			) ;
    
    			if ( m_Provider )
    			{
    				m_Provider->Release () ;
    				m_Provider = NULL ;
    			}
    
    			m_Registered = FALSE ;
    		}
    		else
    		{
    			t_Result = WBEM_E_PROVIDER_NOT_REGISTERED ;
    		}
    	}
    	catch ( ... )
    	{
    		t_Result = WBEM_E_PROVIDER_FAILURE ;
    	}
    
    	WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
    
    	return t_Result ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    CServerObject_ProviderRegistrar :: CServerObject_ProviderRegistrar (
    
    	WmiAllocator &a_Allocator 
    
    ) : CServerObject_ProviderRegistrar_Base ( a_Allocator ) ,
    	m_ReferenceCount ( 0 )
    {
    	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderRegistrar_ObjectsInProgress ) ;
    	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    CServerObject_ProviderRegistrar::~CServerObject_ProviderRegistrar ()
    {
    	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderRegistrar_ObjectsInProgress ) ;
    	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    STDMETHODIMP CServerObject_ProviderRegistrar::QueryInterface (
    
    	REFIID a_Riid , 
    	LPVOID FAR *a_Void 
    ) 
    {
    	*a_Void = NULL ;
    
    	if ( a_Riid == IID_IUnknown )
    	{
    		*a_Void = ( LPVOID ) this ;
    	}
    	else if ( a_Riid == IID_IWbemDecoupledRegistrar )
    	{
    		*a_Void = ( LPVOID ) ( IWbemDecoupledRegistrar * ) this ;		
    	}	
    
    	if ( *a_Void )
    	{
    		( ( LPUNKNOWN ) *a_Void )->AddRef () ;
    
    		return ResultFromScode ( S_OK ) ;
    	}
    	else
    	{
    		return ResultFromScode ( E_NOINTERFACE ) ;
    	}
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    STDMETHODIMP_( ULONG ) CServerObject_ProviderRegistrar :: AddRef ()
    {
    	return InterlockedIncrement ( & m_ReferenceCount ) ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    STDMETHODIMP_(ULONG) CServerObject_ProviderRegistrar :: Release ()
    {
    	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
    	if ( t_ReferenceCount == 0 )
    	{
    		delete this ;
    	}
    
    	return t_ReferenceCount ;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provwsvs.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include "ProvWsvS.h"


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemServices_Stub :: CInterceptor_IWbemServices_Stub (

	WmiAllocator &a_Allocator ,
	IWbemServices *a_Service 

) : m_ReferenceCount ( 0 ) , 
	m_CoreService ( a_Service ) ,
	m_RefreshingService ( NULL ) ,
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_Allocator ( a_Allocator ) ,
	m_ProxyContainer ( a_Allocator , 3 , MAX_PROXIES ),
	m_CriticalSection(NOTHROW_LOCK)
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Stub_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress)  ;

	HRESULT t_Result = m_CoreService->QueryInterface ( IID_IWbemRefreshingServices , ( void ** ) & m_RefreshingService ) ;

	m_CoreService->AddRef () ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemServices_Stub :: ~CInterceptor_IWbemServices_Stub ()
{

	if ( m_CoreService )
	{
		m_CoreService->Release () ; 
	}

	if ( m_RefreshingService )
	{
		m_RefreshingService->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Stub_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress)  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_Stub :: AddRef ( void )
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_Stub :: Release ( void )
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ReferenceCount;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemServices_Stub :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = static_cast<IWbemServices *>(this) ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = static_cast<IWbemServices *>(this) ;		
	}
	else if ( iid == IID_IWbemRefreshingServices )
	{
		*iplpv = static_cast<IWbemRefreshingServices *>(this) ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = static_cast<IWbemShutdown *>(this) ;		
	}	

	if ( *iplpv )
	{
		reinterpret_cast<IUnknown*>(*iplpv)->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->OpenNamespace (

					a_ObjectPath, 
					a_Flags, 
					a_Context ,
					a_NamespaceService, 
					a_CallResult
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Service->OpenNamespace (

							a_ObjectPath, 
							a_Flags, 
							a_Context ,
							a_NamespaceService, 
							a_CallResult
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->CancelAsyncCall (

					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Service->CancelAsyncCall (

							a_Sink
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->QueryObjectSink (

					a_Flags,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Service->QueryObjectSink (

							a_Flags,
							a_Sink
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->GetObject (

					a_ObjectPath,
					a_Flags,
					a_Context ,
					a_Object,
					a_CallResult
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( a_ObjectPath )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							if ( t_ObjectPath )
							{
								t_Result = t_Service->GetObject (

									t_ObjectPath,
									a_Flags,
									a_Context ,
									a_Object,
									a_CallResult
								) ;

								SysFreeString ( t_ObjectPath ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = t_Service->GetObject (

								a_ObjectPath,
								a_Flags,
								a_Context ,
								a_Object,
								a_CallResult
							) ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->GetObjectAsync (

					a_ObjectPath, 
					a_Flags, 
					a_Context ,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
						if ( t_ObjectPath )
						{
							t_Result = t_Service->GetObjectAsync (

								t_ObjectPath, 
								a_Flags, 
								a_Context ,
								a_Sink
							) ;

							SysFreeString ( t_ObjectPath ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->PutClass (

					a_Object, 
					a_Flags, 
					a_Context,
					a_CallResult
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Service->PutClass (

							a_Object, 
							a_Flags, 
							a_Context,
							a_CallResult
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->PutClassAsync (

					a_Object, 
					a_Flags, 
					a_Context ,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Service->PutClassAsync (

							a_Object, 
							a_Flags, 
							a_Context ,
							a_Sink
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->DeleteClass (

					a_Class, 
					a_Flags, 
					a_Context,
					a_CallResult
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_Class = SysAllocString ( a_Class ) ;
						if ( t_Class )
						{
							t_Result = t_Service->DeleteClass (

								t_Class, 
								a_Flags, 
								a_Context,
								a_CallResult
							) ;

							SysFreeString ( t_Class ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: DeleteClassAsync ( 
		
	const BSTR a_Class ,
	long a_Flags,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->DeleteClassAsync (

					a_Class , 
					a_Flags , 
					a_Context ,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_Class = SysAllocString ( a_Class ) ;
						if ( t_Class )
						{
							t_Result = t_Service->DeleteClassAsync (

								t_Class , 
								a_Flags , 
								a_Context ,
								a_Sink
							) ;

							SysFreeString ( t_Class ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->CreateClassEnum (

					a_Superclass, 
					a_Flags, 
					a_Context,
					a_Enum
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_Superclass = SysAllocString ( a_Superclass ) ;
						if ( t_Superclass )
						{
							t_Result = t_Service->CreateClassEnum (

								t_Superclass, 
								a_Flags, 
								a_Context,
								a_Enum
							) ;

							SysFreeString ( t_Superclass ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CInterceptor_IWbemServices_Stub :: CreateClassEnumAsync (

	const BSTR a_Superclass ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->CreateClassEnumAsync (

					a_Superclass, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_Superclass = SysAllocString ( a_Superclass ) ;
						if ( t_Superclass )
						{
							t_Result = t_Service->CreateClassEnumAsync (

								t_Superclass, 
								a_Flags, 
								a_Context,
								a_Sink
							) ;

							SysFreeString ( t_Superclass ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->PutInstance (

					a_Instance,
					a_Flags,
					a_Context,
					a_CallResult
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Service->PutInstance (

							a_Instance,
							a_Flags,
							a_Context,
							a_CallResult
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags, 
    IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->PutInstanceAsync (

					a_Instance, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Service->PutInstanceAsync (

							a_Instance, 
							a_Flags, 
							a_Context,
							a_Sink
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->DeleteInstance (

					a_ObjectPath,
					a_Flags,
					a_Context,
					a_CallResult
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
						if ( t_ObjectPath )
						{
							t_Result = t_Service->DeleteInstance (

								t_ObjectPath,
								a_Flags,
								a_Context,
								a_CallResult
							) ;

							SysFreeString ( t_ObjectPath ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Stub :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink	
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->DeleteInstanceAsync (

					a_ObjectPath,
					a_Flags,
					a_Context,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
						if ( t_ObjectPath )
						{
							t_Result = t_Service->DeleteInstanceAsync (

								t_ObjectPath,
								a_Flags,
								a_Context,
								a_Sink
							) ;

							SysFreeString ( t_ObjectPath ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->CreateInstanceEnum (

					a_Class, 
					a_Flags, 
					a_Context, 
					a_Enum
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_Class = SysAllocString ( a_Class ) ;
						if ( t_Class )
						{
							t_Result = t_Service->CreateInstanceEnum (

								t_Class, 
								a_Flags, 
								a_Context, 
								a_Enum
							) ;

							SysFreeString ( t_Class ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CreateInstanceEnumAsync (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink

) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->CreateInstanceEnumAsync (

 					a_Class, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_Class = SysAllocString ( a_Class ) ;
						if ( t_Class )
						{
							t_Result = t_Service->CreateInstanceEnumAsync (

 								a_Class, 
								a_Flags, 
								a_Context,
								a_Sink
							) ;

							SysFreeString ( t_Class ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->ExecQuery (

					a_QueryLanguage, 
					a_Query, 
					a_Flags, 
					a_Context,
					a_Enum
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
						BSTR t_Query = SysAllocString ( a_Query ) ;
						if ( t_QueryLanguage && t_Query )
						{
							t_Result = t_Service->ExecQuery (

								t_QueryLanguage, 
								t_Query, 
								a_Flags, 
								a_Context,
								a_Enum
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						if ( t_QueryLanguage )
						{
							SysFreeString ( t_QueryLanguage ) ;
						}

						if ( t_Query )
						{
							SysFreeString ( t_Query ) ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->ExecQueryAsync (

					a_QueryLanguage, 
					a_Query, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
						BSTR t_Query = SysAllocString ( a_Query ) ;
						if ( t_QueryLanguage && t_Query )
						{
							t_Result = t_Service->ExecQueryAsync (

								t_QueryLanguage, 
								t_Query, 
								a_Flags, 
								a_Context,
								a_Sink
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						if ( t_QueryLanguage )
						{
							SysFreeString ( t_QueryLanguage ) ;
						}

						if ( t_Query )
						{
							SysFreeString ( t_Query ) ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->ExecNotificationQuery (

					a_QueryLanguage,
					a_Query,
					a_Flags,
					a_Context,
					a_Enum
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
						BSTR t_Query = SysAllocString ( a_Query ) ;
						if ( t_QueryLanguage && t_Query )
						{
							t_Result = t_Service->ExecNotificationQuery (

								t_QueryLanguage,
								t_Query,
								a_Flags,
								a_Context,
								a_Enum
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						if ( t_QueryLanguage )
						{
							SysFreeString ( t_QueryLanguage ) ;
						}

						if ( t_Query )
						{
							SysFreeString ( t_Query ) ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Stub :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->ExecNotificationQueryAsync (

					a_QueryLanguage,
					a_Query,
					a_Flags,
					a_Context,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
						BSTR t_Query = SysAllocString ( a_Query ) ;
						if ( t_QueryLanguage && t_Query )
						{
							t_Result = t_Service->ExecNotificationQueryAsync (

								t_QueryLanguage,
								t_Query,
								a_Flags,
								a_Context,
								a_Sink
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						if ( t_QueryLanguage )
						{
							SysFreeString ( t_QueryLanguage ) ;
						}

						if ( t_Query )
						{
							SysFreeString ( t_Query ) ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CInterceptor_IWbemServices_Stub :: ExecMethod ( 

	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
    IWbemClassObject **a_OutParams,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->ExecMethod (

					a_ObjectPath,
					a_MethodName,
					a_Flags,
					a_Context,
					a_InParams,
					a_OutParams,
					a_CallResult
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
						BSTR t_MethodName = SysAllocString ( a_MethodName ) ;
						if ( t_ObjectPath && t_MethodName )
						{
							t_Result = t_Service->ExecMethod (

								t_ObjectPath,
								t_MethodName,
								a_Flags,
								a_Context,
								a_InParams,
								a_OutParams,
								a_CallResult
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						if ( t_ObjectPath )
						{
							SysFreeString ( t_ObjectPath ) ;
						}

						if ( t_MethodName )
						{
							SysFreeString ( t_MethodName ) ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CInterceptor_IWbemServices_Stub :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->ExecMethodAsync (

					a_ObjectPath,
					a_MethodName,
					a_Flags,
					a_Context,
					a_InParams,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
						BSTR t_MethodName = SysAllocString ( a_MethodName ) ;
						if ( t_ObjectPath && t_MethodName )
						{
							t_Result = t_Service->ExecMethodAsync (

								a_ObjectPath,
								a_MethodName,
								a_Flags,
								a_Context,
								a_InParams,
								a_Sink
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						if ( t_ObjectPath )
						{
							SysFreeString ( t_ObjectPath ) ;
						}

						if ( t_MethodName )
						{
							SysFreeString ( t_MethodName ) ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_Core ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;
			break ;
		}

		::Sleep(0);
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: AddObjectToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Path,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_RefreshingService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , IID_IWbemRefreshingServices , m_RefreshingService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_RefreshingService->AddObjectToRefresher (

						a_RefresherId ,
						a_Path,
						a_Flags ,
						a_Context,
						a_ClientRefresherVersion ,
						a_Information ,
						a_ServerRefresherVersion
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemRefreshingServices *t_RefreshingService = ( IWbemRefreshingServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_RefreshingService ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_RefreshingService->AddObjectToRefresher (

								a_RefresherId ,
								a_Path,
								a_Flags ,
								a_Context,
								a_ClientRefresherVersion ,
								a_Information ,
								a_ServerRefresherVersion
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: AddObjectToRefresherByTemplate (

	WBEM_REFRESHER_ID *a_RefresherId ,
	IWbemClassObject *a_Template ,
	long a_Flags ,
	IWbemContext *a_Context ,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_RefreshingService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , IID_IWbemRefreshingServices , m_RefreshingService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_RefreshingService->AddObjectToRefresherByTemplate (

						a_RefresherId ,
						a_Template ,
						a_Flags ,
						a_Context ,
						a_ClientRefresherVersion ,
						a_Information ,
						a_ServerRefresherVersion
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemRefreshingServices *t_RefreshingService = ( IWbemRefreshingServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_RefreshingService ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_RefreshingService->AddObjectToRefresherByTemplate (

								a_RefresherId ,
								a_Template ,
								a_Flags ,
								a_Context ,
								a_ClientRefresherVersion ,
								a_Information ,
								a_ServerRefresherVersion
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: AddEnumToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_RefreshingService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , IID_IWbemRefreshingServices , m_RefreshingService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_RefreshingService->AddEnumToRefresher (

						a_RefresherId ,
						a_Class ,
						a_Flags ,
						a_Context,
						a_ClientRefresherVersion ,
						a_Information ,
						a_ServerRefresherVersion
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemRefreshingServices *t_RefreshingService = ( IWbemRefreshingServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_RefreshingService ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_RefreshingService->AddEnumToRefresher (

								a_RefresherId ,
								a_Class ,
								a_Flags ,
								a_Context,
								a_ClientRefresherVersion ,
								a_Information ,
								a_ServerRefresherVersion
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: RemoveObjectFromRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Id ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_RefreshingService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , IID_IWbemRefreshingServices , m_RefreshingService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_RefreshingService->RemoveObjectFromRefresher (

						a_RefresherId ,
						a_Id ,
						a_Flags ,
						a_ClientRefresherVersion ,
						a_ServerRefresherVersion
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemRefreshingServices *t_RefreshingService = ( IWbemRefreshingServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_RefreshingService ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_RefreshingService->RemoveObjectFromRefresher (

								a_RefresherId ,
								a_Id ,
								a_Flags ,
								a_ClientRefresherVersion ,
								a_ServerRefresherVersion
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: GetRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	IWbemRemoteRefresher **a_RemoteRefresher ,
	GUID *a_Guid ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_RefreshingService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , IID_IWbemRefreshingServices , m_RefreshingService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_RefreshingService->GetRemoteRefresher (

						a_RefresherId ,
						a_Flags ,
						a_ClientRefresherVersion ,
						a_RemoteRefresher ,
						a_Guid ,
						a_ServerRefresherVersion
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemRefreshingServices *t_RefreshingService = ( IWbemRefreshingServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_RefreshingService ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_RefreshingService->GetRemoteRefresher (

								a_RefresherId ,
								a_Flags ,
								a_ClientRefresherVersion ,
								a_RemoteRefresher ,
								a_Guid ,
								a_ServerRefresherVersion
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ReconnectRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId,
	long a_Flags,
	long a_NumberOfObjects,
	DWORD a_ClientRefresherVersion ,
	WBEM_RECONNECT_INFO *a_ReconnectInformation ,
	WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_RefreshingService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , IID_IWbemRefreshingServices , m_RefreshingService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_RefreshingService->ReconnectRemoteRefresher (

						a_RefresherId,
						a_Flags,
						a_NumberOfObjects,
						a_ClientRefresherVersion ,
						a_ReconnectInformation ,
						a_ReconnectResults ,
						a_ServerRefresherVersion
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemRefreshingServices *t_RefreshingService = ( IWbemRefreshingServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_RefreshingService ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_RefreshingService->ReconnectRemoteRefresher (

								a_RefresherId,
								a_Flags,
								a_NumberOfObjects,
								a_ClientRefresherVersion ,
								a_ReconnectInformation ,
								a_ReconnectResults ,
								a_ServerRefresherVersion
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provreginfo.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"

#include <typeinfo.h>
#include <stdio.h>
#include <sddl.h>

#include <wbemint.h>
#include <genlex.h>
#include <sql_1.h>
#include <HelperFuncs.h>
#include <Logging.h>

#include <HelperFuncs.h>
#include "CGlobals.h"
#include "ProvDnf.h"
#include "ProvRegInfo.h"
#include "DateTime.h"
#include "ssdlhelper.h"



/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

GENERIC_MAPPING g_ProviderBindingMapping = {

	0 ,
	0 ,
	STANDARD_RIGHTS_REQUIRED | MASK_PROVIDER_BINDING_BIND ,
	STANDARD_RIGHTS_REQUIRED | MASK_PROVIDER_BINDING_BIND 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_Class = L"__CLASS" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi___ObjectProviderCacheControl = L"__ObjectProviderCacheControl" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi___EventProviderCacheControl = L"__EventProviderCacheControl" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_ClearAfter = L"ClearAfter" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_s_Strings_Query_Object = L"Select * from __ObjectProviderCacheControl" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_s_Strings_Path_Object = L"__ObjectProviderCacheControl=@" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_s_Strings_Query_Event = L"Select * from __EventProviderCacheControl" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_s_Strings_Path_Event = L"__EventProviderCacheControl=@" ;

LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_HostQuotas_Query = L"Select * from __ProviderHostQuotaConfiguration" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_HostQuotas_Path = L"__ProviderHostQuotaConfiguration=@" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_MemoryPerHost = L"MemoryPerHost" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_MemoryAllHosts = L"MemoryAllHosts" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_ThreadsPerHost = L"ThreadsPerHost" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_HandlesPerHost = L"HandlesPerHost" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_ProcessLimitAllHosts = L"ProcessLimitAllHosts" ;

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_ClsidKeyStr = L"CLSID\\" ;

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Null = NULL ;

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_ThreadingModel = L"ThreadingModel" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_InProcServer32 = L"InProcServer32" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_LocalServer32 = L"LocalServer32" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization = L"Synchronization" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_AppId = L"AppId" ;

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Apartment_Apartment = L"apartment" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Apartment_Both = L"both";
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Apartment_Free = L"free";
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Apartment_Neutral = L"neutral";

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_Ignored = L"ignored" ; 
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_None = L"none" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_Supported = L"supported" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_Required = L"required" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_RequiresNew = L"requiresnew" ;

LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Clsid = L"CLSID" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_ClientClsid = L"ClientLoadableCLSID" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Name = L"Name" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultMachineName = L"DefaultMachineName" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_UnloadTimeout = L"UnloadTimeout" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_ImpersonationLevel = L"ImpersonationLevel" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_InitializationReentrancy = L"InitializationReentrancy" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_InitializeAsAdminFirst = L"InitializeAsAdminFirst" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_PerUserInitialization = L"PerUserInitialization" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_PerLocaleInitialization = L"PerLocaleInitialization" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Pure = L"Pure" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Hosting = L"HostingModel" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_HostingGroup = L"HostingGroup" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SupportsThrottling = L"SupportsThrottling" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SupportsShutdown = L"SupportsShutdown" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_ConcurrentIndependantRequests = L"ConcurrentIndependantRequests";
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SupportsSendStatus = L"SupportsSendStatus" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_OperationTimeoutInterval = L"OperationTimeoutInterval" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_InitializationTimeoutInterval = L"InitializationTimeoutInterval" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SupportsQuotas = L"SupportsQuotas" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Enabled = L"Enabled" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Version = L"Version" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SecurityDescriptor = L"SecurityDescriptor" ;

WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_WmiCore [] = L"WmiCore" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_WmiCoreOrSelfHost [] = L"WmiCoreOrSelfHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SelfHost [] = L"SelfHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Decoupled [] = L"Decoupled:Com" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DecoupledColon [] = L"Decoupled:Com:" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedLocalSystemHost [] = L"LocalSystemHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedLocalSystemHostOrSelfHost [] = L"LocalSystemHostOrSelfHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedNetworkServiceHost [] = L"NetworkServiceHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedLocalServiceHost [] = L"LocalServiceHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedUserHost [] = L"UserHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_NonCom [] = L"Decoupled:NonCom" ;

WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedLocalSystemHost [] = L"DefaultLocalSystemHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedLocalSystemHostOrSelfHost [] = L"DefaultLocalSystemHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedNetworkServiceHost [] = L"DefaultNetworkServiceHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedLocalServiceHost [] = L"DefaultLocalServiceHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedUserHost [] = L"DefaultUserHost" ;

LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultHostingRegistryKey = L"Software\\Microsoft\\WBEM\\Providers\\Configuration\\" ;

LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InstanceProviderRegistration = L"__InstanceProviderRegistration" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsPut = L"SupportsPut" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsGet = L"SupportsGet" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsDelete = L"SupportsDelete" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsEnumeration = L"SupportsEnumeration" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels = L"QuerySupportLevels" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InteractionType = L"InteractionType" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsBatching = L"SupportsBatching" ;;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsTransactions = L"SupportsTransactions" ;;

LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels_UnarySelect = L"WQL:UnarySelect" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels_References = L"WQL:References" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels_Associators = L"WQL:Associators" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels_V1ProviderDefined = L"WQL:V1ProviderDefined" ;

LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InteractionType_Pull = L"Pull" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InteractionType_Push = L"Push" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InteractionType_PushVerify = L"PushVerify" ;

LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_ClassProviderRegistration = L"__ClassProviderRegistration" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsPut = L"SupportsPut" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsGet = L"SupportsGet" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsDelete = L"SupportsDelete" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsEnumeration = L"SupportsEnumeration" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels = L"QuerySupportLevels" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_InteractionType = L"InteractionType" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsBatching = L"SupportsBatching" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsTransactions = L"SupportsTransactions" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_CacheRefreshInterval = L"CacheRefreshInterval" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_PerUserSchema = L"PerUserSchema" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_ReSynchroniseOnNamespaceOpen = L"ReSynchroniseOnNamespaceOpen" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_Version = L"Version" ;

LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels_UnarySelect = L"WQL:UnarySelect" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels_References = L"WQL:References" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels_Associators = L"WQL:Associators" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels_V1ProviderDefined = L"WQL:V1ProviderDefined" ;

LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_InteractionType_Pull = L"Pull" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_InteractionType_Push = L"Push" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_InteractionType_PushVerify = L"PushVerify" ;

LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_ResultSetQueries = L"ResultSetQueries" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_UnSupportedQueries = L"UnSupportedQueries" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_ReferencedSetQueries = L"ReferencedSetQueries" ;

LPCWSTR CServerObject_MethodProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_MethodProviderRegistrationV1 :: s_Strings_MethodProviderRegistration = L"__MethodProviderRegistration" ;

LPCWSTR CServerObject_EventProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_EventProviderRegistrationV1 :: s_Strings_EventProviderRegistration = L"__EventProviderRegistration" ;

LPCWSTR CServerObject_EventConsumerProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_EventConsumerProviderRegistrationV1 :: s_Strings_EventConsumerProviderRegistration = L"__EventConsumerProviderRegistration" ;

LPCWSTR CServerObject_DynamicPropertyProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_DynamicPropertyProviderRegistrationV1 :: s_Strings_PropertyProviderRegistration = L"__PropertyProviderRegistration" ;
LPCWSTR CServerObject_DynamicPropertyProviderRegistrationV1 :: s_Strings_SupportsPut = L"SupportsPut" ;
LPCWSTR CServerObject_DynamicPropertyProviderRegistrationV1 :: s_Strings_SupportsGet = L"SupportsGet" ;

LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_ClassProviderRegistration = L"__ClassProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_InstanceProviderRegistration = L"__InstanceProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_MethodProviderRegistration = L"__MethodProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_PropertyProviderRegistration = L"__PropertyProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_EventProviderRegistration = L"__EventProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_EventConsumerProviderRegistration = L"__EventConsumerProviderRegistration" ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_GlobalRegistration :: CServerObject_GlobalRegistration () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Object_UnloadTimeout ( NULL ) ,
	m_Event_UnloadTimeout ( NULL ) ,
	m_Object_UnloadTimeoutMilliSeconds ( DEFAULT_PROVIDER_TIMEOUT ) ,
	m_Event_UnloadTimeoutMilliSeconds ( DEFAULT_PROVIDER_TIMEOUT ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_GlobalRegistration :: ~CServerObject_GlobalRegistration ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	if ( m_Object_UnloadTimeout )
	{
		SysFreeString ( m_Object_UnloadTimeout ) ;
	}

	if ( m_Event_UnloadTimeout )
	{
		SysFreeString ( m_Event_UnloadTimeout ) ;
	}

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_GlobalRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_GlobalRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_GlobalRegistration :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_GlobalRegistration :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object ,
	LPWSTR &a_UnloadTimeout ,
	ULONG &a_UnloadTimeoutMilliSeconds 
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Mask & e_ClearAfter )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		t_Result = a_Object->Get ( s_Strings_Wmi_ClearAfter , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BSTR )
			{
				if ( a_UnloadTimeout )
				{
					SysFreeString ( a_UnloadTimeout ) ;
				}

				a_UnloadTimeout = SysAllocString ( t_Variant.bstrVal ) ;
				if ( a_UnloadTimeout )
				{
					CWbemDateTime t_Interval ;
					t_Result = t_Interval.PutValue ( a_UnloadTimeout ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						VARIANT_BOOL t_Bool = VARIANT_FALSE ;
						t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
						if ( t_Bool == VARIANT_TRUE )
						{
							LONG t_MicroSeconds = 0 ;
							LONG t_Seconds = 0 ;
							LONG t_Minutes = 0 ;
							LONG t_Hours = 0 ;
							LONG t_Days = 0 ;

							t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
							t_Interval.GetSeconds ( & t_Seconds ) ;
							t_Interval.GetMinutes ( & t_Minutes ) ;
							t_Interval.GetHours ( & t_Hours ) ;
							t_Interval.GetDay ( & t_Days ) ;

							a_UnloadTimeoutMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
														  ( t_Hours * 60 * 60 * 1000 ) +
														  ( t_Minutes * 60 * 1000 ) +
														  ( t_Seconds * 1000 ) +
														  ( t_MicroSeconds / 1000 ) ;
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				if ( a_UnloadTimeout )
				{
					SysFreeString ( a_UnloadTimeout ) ;
					a_UnloadTimeout = NULL ;
				}
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_GlobalRegistration :: QueryRepository ( 

	Enum_PropertyMask a_Mask
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_ObjectPath = SysAllocString ( s_Strings_Wmi_s_Strings_Path_Object ) ;
	if ( t_ObjectPath ) 
	{
		IWbemClassObject *t_ClassObject = NULL ;

		t_Result = m_Repository->GetObject ( 

			t_ObjectPath ,
			0 ,
			m_Context , 
			& t_ClassObject , 
			NULL 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = QueryProperties ( 

				a_Mask ,
				t_ClassObject ,
				m_Object_UnloadTimeout ,
				m_Object_UnloadTimeoutMilliSeconds
			) ;

			t_ClassObject->Release () ;
		}

		SysFreeString ( t_ObjectPath ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		BSTR t_ObjectPath = SysAllocString ( s_Strings_Wmi_s_Strings_Path_Event ) ;
		if ( t_ObjectPath ) 
		{
			IWbemClassObject *t_ClassObject = NULL ;

			t_Result = m_Repository->GetObject ( 

				t_ObjectPath ,
				0 ,
				m_Context , 
				& t_ClassObject , 
				NULL 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = QueryProperties ( 

					a_Mask ,
					t_ClassObject ,
					m_Event_UnloadTimeout ,
					m_Event_UnloadTimeoutMilliSeconds
				) ;

				t_ClassObject->Release () ;
			}

			SysFreeString ( t_ObjectPath ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_GlobalRegistration :: Load ( 

	Enum_PropertyMask a_Mask
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_HostQuotaRegistration :: CServerObject_HostQuotaRegistration () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_MemoryPerHost ( 0 ) ,
	m_MemoryAllHosts ( 0 ) ,
	m_ThreadsPerHost ( 0 ) ,
	m_HandlesPerHost ( 0 ) ,
	m_ProcessLimitAllHosts ( 0 ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_HostQuotaRegistration :: ~CServerObject_HostQuotaRegistration ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_HostQuotaRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_HostQuotaRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostQuotaRegistration :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostQuotaRegistration :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object
)
{
	HRESULT t_Result = S_OK ;

	_IWmiObject *t_FastObject = NULL ;

	t_Result = a_Object->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastObject ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_MemoryAllHosts )
		{
			UINT64 t_Value = 0 ;

			BOOL t_IsNull = FALSE ;
			CIMTYPE t_VarType = CIM_EMPTY ;
			LONG t_Flavour = 0 ;
			ULONG t_Used = 0 ;

			t_Result = t_FastObject->ReadProp ( 

				s_Strings_Wmi_MemoryAllHosts ,
				0 ,
				sizeof ( UINT64 ) ,
				& t_VarType ,
				& t_Flavour ,
				& t_IsNull ,
				& t_Used ,
				& t_Value
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IsNull )
				{
					m_MemoryAllHosts = 0 ;
				}
				else 
				{
					if ( t_VarType == CIM_UINT64 )
					{
						m_MemoryAllHosts = t_Value ;
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
			}
		}

		if ( SUCCEEDED(t_Result) && (a_Mask & e_MemoryPerHost) )
		{
			UINT64 t_Value = 0 ;

			BOOL t_IsNull = FALSE ;
			CIMTYPE t_VarType = CIM_EMPTY ;
			LONG t_Flavour = 0 ;
			ULONG t_Used = 0 ;

			t_Result = t_FastObject->ReadProp ( 

				s_Strings_Wmi_MemoryPerHost ,
				0 ,
				sizeof ( UINT64 ) ,
				& t_VarType ,
				& t_Flavour ,
				& t_IsNull ,
				& t_Used ,
				& t_Value
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IsNull )
				{
					m_MemoryPerHost = 0 ;
				}
				else 
				{
					if ( t_VarType == CIM_UINT64 )
					{
						m_MemoryPerHost = t_Value ;
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
			}
		}

		t_FastObject->Release () ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_ThreadsPerHost) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		t_Result = a_Object->Get ( s_Strings_Wmi_ThreadsPerHost , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_ThreadsPerHost = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_ThreadsPerHost = 0 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_HandlesPerHost) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		t_Result = a_Object->Get ( s_Strings_Wmi_HandlesPerHost , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_HandlesPerHost = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_HandlesPerHost = 0 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_ProcessLimitAllHosts) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		t_Result = a_Object->Get ( s_Strings_Wmi_ProcessLimitAllHosts , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_ProcessLimitAllHosts = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_ProcessLimitAllHosts = 0 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostQuotaRegistration :: QueryRepository ( 

	Enum_PropertyMask a_Mask
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_ObjectPath = SysAllocString ( s_Strings_Wmi_HostQuotas_Path ) ;
	if ( t_ObjectPath ) 
	{
		IWbemClassObject *t_ClassObject = NULL ;

		t_Result = m_Repository->GetObject ( 

			t_ObjectPath ,
			0 ,
			m_Context , 
			& t_ClassObject , 
			NULL 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = QueryProperties ( 

				a_Mask ,
				t_ClassObject 
			) ;

			t_ClassObject->Release () ;
		}

		SysFreeString ( t_ObjectPath ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostQuotaRegistration :: Load ( 

	Enum_PropertyMask a_Mask
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ComRegistration :: CServerObject_ComRegistration ()

	:	m_ThreadingModel ( e_ThreadingModel_Unknown ) ,
		m_Synchronization ( e_Ignored ) ,
		m_InProcServer32 ( e_Boolean_Unknown ) ,
		m_LocalServer32 ( e_Boolean_Unknown ) ,
		m_Service ( e_Boolean_Unknown ) ,
		m_Loaded ( e_False ) ,
		m_Clsid ( NULL ) ,
		m_AppId ( NULL ) ,
		m_ProviderName ( NULL ) ,
		m_Result ( S_OK )
{
	m_InProcServer32_Path [ 0 ] = 0 ;
	m_LocalServer32_Path [ 0 ] = 0 ;
	m_Server_Name [ 0 ] = 0 ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ComRegistration :: ~CServerObject_ComRegistration ()
{
	if ( m_AppId )
	{
		SysFreeString ( m_AppId ) ;
	}

	if ( m_Clsid )
	{
		SysFreeString ( m_Clsid ) ;
	}

	if ( m_ProviderName )
	{
		SysFreeString ( m_ProviderName ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ComRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ComRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_ThreadingModel ( HKEY a_ClsidKey )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	wchar_t t_Data [ MAX_PATH ] ;
	DWORD t_DataSize = sizeof ( t_Data ) ;

	LONG t_RegResult = RegQueryValueEx (

	  a_ClsidKey ,
	  s_Strings_Reg_ThreadingModel ,
	  0 ,
	  & t_ValueType ,
	  LPBYTE ( & t_Data ) ,
	  & t_DataSize 
	);

	if ( t_RegResult == ERROR_SUCCESS )
	{
		if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Apartment_Apartment ) == 0 ) 
		{
			m_ThreadingModel = e_Apartment ;
		}
		else if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Apartment_Both ) == 0 ) 
		{
			m_ThreadingModel = e_Both ;
		}
		else if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Apartment_Free ) == 0 ) 
		{
			m_ThreadingModel = e_Free ;
		}
		else if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Apartment_Neutral ) == 0 )	
		{
			m_ThreadingModel = e_Neutral ;
		}
		else
		{
			m_ThreadingModel = e_ThreadingModel_Unknown ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_Synchronization ( HKEY a_ClsidKey )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	wchar_t t_Data [ MAX_PATH ] ;
	DWORD t_DataSize = sizeof ( t_Data ) ;

	LONG t_RegResult = RegQueryValueEx (

	  a_ClsidKey ,
	  s_Strings_Reg_Synchronization ,
	  0 ,
	  & t_ValueType ,
	  LPBYTE ( & t_Data ) ,
	  & t_DataSize 
	);

	if ( t_RegResult == ERROR_SUCCESS )
	{
		if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Synchronization_Ignored ) == 0 ) 
		{
			m_Synchronization = e_Ignored ;
		}
		else if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Synchronization_None ) == 0 ) 
		{
			m_Synchronization = e_None ;
		}
		else if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Synchronization_Supported ) == 0 )	
		{
			m_Synchronization = e_Supported ;
		}
		else if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Synchronization_Required ) == 0 )	
		{
			m_Synchronization = e_Required ;
		}
		else if ( wbem_wcsicmp ( t_Data , s_Strings_Reg_Synchronization_RequiresNew ) == 0 )	
		{
			m_Synchronization = e_RequiresNew ;
		}
		else
		{
			m_Synchronization = e_Synchronization_Unknown ;
		}
	}
	
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_InProcServer32 ( LPCWSTR a_ClsidStringKey )
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_Clsid_String_Key_InProcServer32 = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		2, 
		& t_Clsid_String_Key_InProcServer32 , 
		a_ClsidStringKey ,
		s_Strings_Reg_InProcServer32
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		HKEY t_Clsid_Key_InProcServer32 ;

		LONG t_RegResult = RegOpenKeyEx (

			HKEY_CLASSES_ROOT ,
			t_Clsid_String_Key_InProcServer32 ,
			0 ,
			KEY_READ ,
			& t_Clsid_Key_InProcServer32 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			m_InProcServer32 = e_True ;

			t_Result = Load_ThreadingModel ( t_Clsid_Key_InProcServer32 ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Load_Synchronization ( t_Clsid_Key_InProcServer32 ) ;
			}

			DWORD t_ValueType = REG_SZ ;
			DWORD t_DataSize = sizeof ( m_InProcServer32_Path ) ;

			t_RegResult = RegQueryValueEx (

			  t_Clsid_Key_InProcServer32 ,
			  s_Strings_Reg_Null ,
			  0 ,
			  & t_ValueType ,
			  LPBYTE ( & m_InProcServer32_Path ) ,
			  & t_DataSize 
			);

			if ( t_RegResult == ERROR_SUCCESS )
			{
			}


			RegCloseKey ( t_Clsid_Key_InProcServer32 ) ;
		}

		SysFreeString ( t_Clsid_String_Key_InProcServer32 ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_LocalServer32 ( LPCWSTR a_ClsidStringKey )
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_Clsid_String_Key_LocalServer32 = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		2, 
		& t_Clsid_String_Key_LocalServer32 , 
		a_ClsidStringKey ,
		s_Strings_Reg_LocalServer32
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		HKEY t_Clsid_Key_LocalServer32 ;

		LONG t_RegResult = RegOpenKeyEx (

			HKEY_CLASSES_ROOT ,
			t_Clsid_String_Key_LocalServer32 ,
			0 ,
			KEY_READ ,
			& t_Clsid_Key_LocalServer32 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			m_LocalServer32 = e_True ;
			m_ThreadingModel = e_Free ;
			m_Synchronization = e_Ignored ;

			DWORD t_ValueType = REG_SZ ;
			DWORD t_DataSize = sizeof ( m_LocalServer32_Path ) ;

			t_RegResult = RegQueryValueEx (

			  t_Clsid_Key_LocalServer32 ,
			  s_Strings_Reg_Null ,
			  0 ,
			  & t_ValueType ,
			  LPBYTE ( & m_LocalServer32_Path ) ,
			  & t_DataSize 
			);

			if ( t_RegResult == ERROR_SUCCESS )
			{
			}
			

			RegCloseKey ( t_Clsid_Key_LocalServer32 ) ;
		}

		SysFreeString ( t_Clsid_String_Key_LocalServer32 ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_ServerTypes ( LPCWSTR a_ClsidString )
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_Clsid_String_Key = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		2, 
		& t_Clsid_String_Key , 
		a_ClsidString ,
		L"\\"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Load_InProcServer32 ( t_Clsid_String_Key ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = Load_LocalServer32 ( t_Clsid_String_Key ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
		}

		SysFreeString ( t_Clsid_String_Key ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_AppId ( HKEY a_Clsid_Key )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	wchar_t t_Data [ MAX_PATH ] ;
	DWORD t_DataSize = sizeof ( t_Data ) ;

	LONG t_RegResult = RegQueryValueEx (

	  a_Clsid_Key ,
	  s_Strings_Reg_AppId ,
	  0 ,
	  & t_ValueType ,
	  LPBYTE ( & t_Data ) ,
	  & t_DataSize 
	);

	if ( t_RegResult == ERROR_SUCCESS )
	{
		if ( m_AppId )
		{
			SysFreeString ( m_AppId ) ;
		}

		m_AppId = SysAllocString ( t_Data ) ;
		if ( m_AppId )
		{
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}


	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load ( LPCWSTR a_Clsid , LPCWSTR a_ProviderName )
{
	HRESULT t_Result = S_OK ;

	if ( m_Clsid ) 
	{
		SysFreeString ( m_Clsid ) ;
		m_Clsid = 0;
	}

	if (0 != a_Clsid)
	{
    	m_Clsid = SysAllocString ( a_Clsid ) ;
        if (0 == m_Clsid ) return WBEM_E_OUT_OF_MEMORY;
    }

	if ( m_ProviderName ) 
	{
		SysFreeString ( m_ProviderName ) ;
		m_ProviderName = 0;
	}

	if (0!=a_ProviderName )
	{
    	m_ProviderName = SysAllocString ( a_ProviderName ) ;
	    if (0 == m_ProviderName) return WBEM_E_OUT_OF_MEMORY;
	}

	LPWSTR t_Clsid_String = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		2, 
		& t_Clsid_String , 
		s_Strings_Reg_ClsidKeyStr ,
		a_Clsid
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Load_ServerTypes ( t_Clsid_String ) ;

		HKEY t_Clsid_Key ;

		LONG t_RegResult = RegOpenKeyEx (

			HKEY_CLASSES_ROOT ,
			t_Clsid_String ,
			0 ,
			KEY_READ ,
			& t_Clsid_Key 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			DWORD t_ValueType = REG_SZ ;
			DWORD t_DataSize = sizeof ( m_Server_Name ) ;

			t_RegResult = RegQueryValueEx (

			  t_Clsid_Key ,
			  s_Strings_Reg_Null ,
			  0 ,
			  & t_ValueType ,
			  LPBYTE ( & m_Server_Name ) ,
			  & t_DataSize 
			);

			if ( t_RegResult == ERROR_SUCCESS )
			{
			}
			else
			{
        		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
    			t_Result = Load_AppId ( t_Clsid_Key	) ;
    			if ( SUCCEEDED ( t_Result ) )
    			{
    				if ( m_InProcServer32 != e_True && m_LocalServer32 != e_True )
    				{
    					m_Service = e_True ;
    					m_ThreadingModel = e_Free ;
    					m_Synchronization = e_Ignored ;
    				}
    			}
            }

			RegCloseKey ( t_Clsid_Key ) ;
			
		}

		SysFreeString ( t_Clsid_String ) ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		m_Loaded = e_True ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ComProviderRegistrationV1 :: CServerObject_ComProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Identity ( NULL ) ,
	m_DefaultMachineName ( NULL ) ,
	m_UnloadTimeout ( NULL ) ,
	m_UnloadTimeoutMilliSeconds ( DEFAULT_PROVIDER_TIMEOUT ) ,
	m_OperationTimeout ( NULL ) ,
	m_OperationTimeoutMilliSeconds ( INFINITE ) ,
	m_InitializationTimeout ( NULL ) ,
	m_InitializationTimeoutMilliSeconds ( DEFAULT_PROVIDER_LOAD_TIMEOUT ) ,
	m_Enabled ( TRUE ) ,
	m_SupportsQuotas ( FALSE ) ,
	m_SupportsThrottling ( FALSE ) ,
	m_SupportsSendStatus ( FALSE ) ,
	m_SupportsShutdown ( FALSE ) ,
	m_ConcurrentIndependantRequests ( 0 ) ,
	m_ImpersonationLevel ( e_ImpersonationLevel_Unknown ) ,
	m_InitializationReentrancy ( e_InitializationReentrancy_Namespace ) ,
	m_InitializeAsAdminFirst ( FALSE ) ,
	m_PerUserInitialization ( FALSE ) ,
	m_PerLocaleInitialization ( FALSE ) ,
	m_Pure ( FALSE ) ,
	m_Version ( 1 ) ,
	m_ProviderName ( NULL ) ,
	m_Hosting ( e_Hosting_Undefined ) , // e_Hosting_SharedLocalSystemHost e_Hosting_WmiCore
	m_HostingGroup ( NULL ) ,
	m_Result ( S_OK ) ,
	m_SecurityDescriptor ( NULL ) ,
	m_DecoupledImpersonationRestriction ( TRUE )
{
	ZeroMemory ( & m_CLSID , sizeof ( GUID ) ) ;
	ZeroMemory ( & m_ClientCLSID  , sizeof ( GUID ) ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ComProviderRegistrationV1 :: ~CServerObject_ComProviderRegistrationV1 ()
{
	if ( m_SecurityDescriptor )
	{
		LocalFree ( m_SecurityDescriptor ) ;
	}

	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	if ( m_Identity )
	{
		m_Identity->Release () ;
	}

	if ( m_DefaultMachineName ) 
	{
		SysFreeString ( m_DefaultMachineName ) ;
	}

	if ( m_UnloadTimeout )
	{
		SysFreeString ( m_UnloadTimeout ) ;
	}

	if ( m_HostingGroup )
	{
		SysFreeString ( m_HostingGroup ) ;
	}

	if ( m_InitializationTimeout )
	{
		SysFreeString ( m_InitializationTimeout ) ;
	}

	if ( m_ProviderName ) 
	{
		SysFreeString ( m_ProviderName ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ComProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ComProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: GetDefaultHostingGroup ( 

	Enum_Hosting a_HostingValue ,
	BSTR & a_HostingGroup 
)
{
	HRESULT t_Result = S_OK ;

	switch ( a_HostingValue )
	{
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalSystemHostOrSelfHost:
		{
			a_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedLocalSystemHost ) ;

		}
		break ;

		case e_Hosting_SharedNetworkServiceHost:
		{
			a_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedNetworkServiceHost ) ;
		}
		break ;

		case e_Hosting_SharedLocalServiceHost:
		{
			a_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedLocalServiceHost ) ;
		}
		break ;

		default:
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}
		break ;
	}
	if ( SUCCEEDED(t_Result) && (0 == a_HostingGroup) ) t_Result = WBEM_E_OUT_OF_MEMORY;
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: GetHostingGroup ( 

	LPCWSTR a_Hosting , 
	size_t a_Prefix ,
	Enum_Hosting a_ExpectedHostingValue ,
	Enum_Hosting & a_HostingValue ,
	BSTR & a_HostingGroup 
)
{
	HRESULT t_Result = S_OK ;

	size_t t_Length = wcslen ( a_Hosting ) ;

	if ( t_Length > a_Prefix )
	{
		if ( a_Hosting [ a_Prefix ] == L':' ) 
		{
			if ( t_Length > a_Prefix + 1 )
			{
				a_HostingGroup = SysAllocString ( & a_Hosting [ a_Prefix + 1 ] ) ;
				if ( a_HostingGroup )
				{
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				a_HostingValue = a_ExpectedHostingValue ;
			}
			else
			{
				t_Result = GetDefaultHostingGroup ( a_ExpectedHostingValue , a_HostingGroup ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}
	}
	else
	{
		t_Result = GetDefaultHostingGroup ( a_ExpectedHostingValue , a_HostingGroup ) ;

		a_HostingValue = a_ExpectedHostingValue ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define StateAction_Accept		1	// Add the char to the token
#define StateAction_Consume		2	// Consume the char without adding to token
#define StateAction_Pushback	4	// Place the char back in the source buffer for next token
#define StateAction_Not			8	// A match occurs if the char is NOT the one specified
#define StateAction_Linefeed	16	// Increase the source linecount
#define StateAction_Return		32	// Return the indicated token to caller
#define StateAction_Any			64	// wchar_t(0xFFFF) Any character
#define StateAction_Empty		128	// wchar_t(0xFFFE) When subrange is not specified

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

struct StateTableEntry
{
	wchar_t m_LowerRange ;
	wchar_t m_UpperRange ;

	ULONG m_Token ;
	ULONG m_GotoState ;
	ULONG m_Action ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum LexicalStatus
{
	Success ,
	Syntax_Error ,
	Lexical_Error ,
	Failed ,
	Buffer_Too_Small ,
	ImpossibleState ,
	UnexpectedEof ,
	OutOfMemory 
} ;	

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define TOKEN_IDENTITY			1
#define TOKEN_LEFTPARENTHESIS	2
#define TOKEN_RIGHTPARENTHESIS	3
#define TOKEN_TRUE				4
#define TOKEN_FALSE				5
#define TOKEN_EOF				6
#define TOKEN_ERROR				7

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

struct StateTableEntry g_StateTable [] = {

	' ',			65534 ,				0 ,							0 ,			StateAction_Consume		,		// 0
	'\t',			65534 ,				0 ,							0 ,			StateAction_Consume		,		// 1
	'a',			'z',				0 ,							8 ,			StateAction_Accept		,		// 2
	'A',			'Z',				0 ,							8 ,			StateAction_Accept		,		// 3
	'(',			65534 ,				TOKEN_LEFTPARENTHESIS ,		0 ,			StateAction_Return		,		// 4
	')',			65534 ,				TOKEN_RIGHTPARENTHESIS ,	0 ,			StateAction_Return		,		// 5
	0,				65534 ,				TOKEN_EOF ,					0 ,			StateAction_Return		,		// 6
	65535,			65534 ,				TOKEN_ERROR ,				0 ,			StateAction_Return		,		// 7

	'a',			'z',				0	,						8 ,			StateAction_Accept		,		// 8
	'A',			'Z',				0	,						8 ,			StateAction_Accept		,		// 9
	65535,			65534 ,				TOKEN_IDENTITY ,			0 ,			StateAction_Pushback | StateAction_Return	// 10
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LexicalStatus LexicalAnalyser_NextToken ( 

	StateTableEntry *a_Dfa , 
	ULONG a_DfaSize ,
	const wchar_t *a_Stream , 
	ULONG a_Position , 
	ULONG &a_Token , 
	ULONG &a_NextPosition , 
	wchar_t *&a_TokenText
)
{
	LexicalStatus t_Status = Success ;

	a_Token = 0 ;
	a_TokenText = NULL ;
	a_NextPosition = a_Position ;

	ULONG t_State = 0 ;
    BOOL t_Read = TRUE ;
	BOOL t_EndOfFile = FALSE ;
    wchar_t t_Current = 0 ;
	ULONG CurrentLine = 0 ;
	wchar_t *t_TokenText = NULL ;
	ULONG t_TokenTextActualSize = 0 ;
	ULONG t_TokenTextBufferSize = 0 ;

    while ( 1 )
	{
		wchar_t t_First = a_Dfa [ t_State ].m_LowerRange ;
		wchar_t t_Last = a_Dfa [ t_State ].m_UpperRange ;
		ULONG t_GotoState = a_Dfa [ t_State ].m_GotoState ;
		ULONG t_ReturnToken = a_Dfa [ t_State ].m_Token ;
		ULONG t_Action = a_Dfa [ t_State ].m_Action ;

        if ( t_Read )
		{
			if ( t_EndOfFile ) 
			{
				t_Status = UnexpectedEof ;

				delete [] t_TokenText ;

				return t_Status ;
			}

            if ( a_NextPosition > wcslen ( a_Stream ) )
			{
				t_Current = 0 ;

				t_EndOfFile = TRUE ;
			}
			else
			{
				t_Current = a_Stream [ a_NextPosition ] ;
			}
		}

        BOOL t_Match = FALSE ;

        if ( t_First == 65535 )
		{
            t_Match = TRUE ;
		}
		else
        {
			if ( t_Last == 65534 )
			{
				if ( t_Current == t_First ) 
				{
					t_Match = TRUE ;
				}
	            else 
				{
					if ( ( t_Action & StateAction_Not ) && ( t_Current != t_First ) )
					{
                		t_Match = TRUE ;
					}
				}
			}
			else
			{
				if ( ( t_Action & StateAction_Not ) && ( ! ( ( t_Current >= t_First ) && ( t_Current <= t_Last ) ) ) )
				{
					t_Match = TRUE ;
				}
				else 
				{
					if ( ( t_Current >= t_First ) && ( t_Current <= t_Last ) )
					{
						t_Match = TRUE ;
					}
				}
			}
        }

        t_Read = FALSE ;

        if ( t_Match )
		{
            if ( t_Action & StateAction_Accept )
			{
				if ( t_TokenText )
				{
					if ( t_TokenTextActualSize < t_TokenTextBufferSize - 1 )
					{
					}
					else
					{
						t_TokenTextBufferSize = t_TokenTextBufferSize + 32 ;
						wchar_t *t_TempTokenText = new wchar_t [ t_TokenTextBufferSize ] ;
						if ( t_TempTokenText )
						{
							CopyMemory ( t_TempTokenText , t_TokenText , ( t_TokenTextActualSize ) * sizeof ( wchar_t ) ) ;

							delete [] t_TokenText ;
							t_TokenText = t_TempTokenText ;
						}
						else
						{
							delete [] t_TokenText ;

							return OutOfMemory ;
						}
					}

					t_TokenText [ t_TokenTextActualSize ] = t_Current ;
					t_TokenText [ t_TokenTextActualSize + 1 ] = 0 ;

					t_TokenTextActualSize ++ ;
				}
				else
				{
					t_TokenTextActualSize = 1 ;
					t_TokenTextBufferSize = 32 ;

					t_TokenText = new wchar_t [ t_TokenTextBufferSize ] ;
					if ( t_TokenText