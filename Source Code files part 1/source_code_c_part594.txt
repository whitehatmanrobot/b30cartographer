ine DMUS_E_INVALIDOFFSET            MAKE_DMHRESULTERROR(0x0109)

/* DMUS_E_ALREADY_LOADED
 *
 * Second attempt to load a DLS collection that is currently open. 
 */
#define DMUS_E_ALREADY_LOADED           MAKE_DMHRESULTERROR(0x0111)

/* DMUS_E_INVALIDPOS
 *
 * Error reading wave data from DLS collection. Indicates bad file.
 */
#define DMUS_E_INVALIDPOS               MAKE_DMHRESULTERROR(0x0113)

/* DMUS_E_INVALIDPATCH
 *
 * There is no instrument in the collection that matches patch number.
 */
#define DMUS_E_INVALIDPATCH             MAKE_DMHRESULTERROR(0x0114)

/* DMUS_E_CANNOTSEEK
 *
 * The IStream* doesn't support Seek().
 */
#define DMUS_E_CANNOTSEEK               MAKE_DMHRESULTERROR(0x0115)

/* DMUS_E_CANNOTWRITE
 *
 * The IStream* doesn't support Write().
 */
#define DMUS_E_CANNOTWRITE              MAKE_DMHRESULTERROR(0x0116)

/* DMUS_E_CHUNKNOTFOUND
 *
 * The RIFF parser doesn't contain a required chunk while parsing file.
 */
#define DMUS_E_CHUNKNOTFOUND            MAKE_DMHRESULTERROR(0x0117)

/* DMUS_E_INVALID_DOWNLOADID
 *
 * Invalid download id was used in the process of creating a download buffer.
 */
#define DMUS_E_INVALID_DOWNLOADID       MAKE_DMHRESULTERROR(0x0119)

/* DMUS_E_NOT_DOWNLOADED_TO_PORT
 *
 * Tried to unload an object that was not downloaded or previously unloaded.
 */
#define DMUS_E_NOT_DOWNLOADED_TO_PORT   MAKE_DMHRESULTERROR(0x0120)

/* DMUS_E_ALREADY_DOWNLOADED
 *
 * Buffer was already downloaded to synth.
 */
#define DMUS_E_ALREADY_DOWNLOADED       MAKE_DMHRESULTERROR(0x0121)

/* DMUS_E_UNKNOWN_PROPERTY
 *
 * The specified property item was not recognized by the target object.
 */
#define DMUS_E_UNKNOWN_PROPERTY         MAKE_DMHRESULTERROR(0x0122)

/* DMUS_E_SET_UNSUPPORTED
 *
 * The specified property item may not be set on the target object.
 */
#define DMUS_E_SET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0123)

/* DMUS_E_GET_UNSUPPORTED
 *
 * The specified property item may not be retrieved from the target object.
 */ 
#define DMUS_E_GET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0124)

/* DMUS_E_NOTMONO
 *
 * Wave chunk has more than one interleaved channel. DLS format requires MONO.
 */
#define DMUS_E_NOTMONO                  MAKE_DMHRESULTERROR(0x0125)

/* DMUS_E_BADARTICULATION
 *
 * Invalid articulation chunk in DLS collection.
 */
#define DMUS_E_BADARTICULATION          MAKE_DMHRESULTERROR(0x0126)

/* DMUS_E_BADINSTRUMENT
 *
 * Invalid instrument chunk in DLS collection.
 */
#define DMUS_E_BADINSTRUMENT            MAKE_DMHRESULTERROR(0x0127)

/* DMUS_E_BADWAVELINK
 *
 * Wavelink chunk in DLS collection points to invalid wave.
 */
#define DMUS_E_BADWAVELINK              MAKE_DMHRESULTERROR(0x0128)

/* DMUS_E_NOARTICULATION
 *
 * Articulation missing from instrument in DLS collection.
 */
#define DMUS_E_NOARTICULATION           MAKE_DMHRESULTERROR(0x0129)

/* DMUS_E_NOTPCM
 *
 * Downoaded DLS wave is not in PCM format. 
*/
#define DMUS_E_NOTPCM                   MAKE_DMHRESULTERROR(0x012A)

/* DMUS_E_BADWAVE
 *
 * Bad wave chunk in DLS collection
 */
#define DMUS_E_BADWAVE                  MAKE_DMHRESULTERROR(0x012B)

/* DMUS_E_BADOFFSETTABLE
 *
 * Offset Table for download buffer has errors. 
 */
#define DMUS_E_BADOFFSETTABLE           MAKE_DMHRESULTERROR(0x012C)

/* DMUS_E_UNKNOWNDOWNLOAD
 *
 * Attempted to download unknown data type.
 */
#define DMUS_E_UNKNOWNDOWNLOAD          MAKE_DMHRESULTERROR(0x012D)

/* DMUS_E_NOSYNTHSINK
 *
 * The operation could not be completed because no sink was connected to
 * the synthesizer.
 */
#define DMUS_E_NOSYNTHSINK              MAKE_DMHRESULTERROR(0x012E)

/* DMUS_E_ALREADYOPEN
 *
 * An attempt was made to open the software synthesizer while it was already 
 * open.
 * ASSERT?
 */
#define DMUS_E_ALREADYOPEN              MAKE_DMHRESULTERROR(0x012F)

/* DMUS_E_ALREADYCLOSE
 *
 * An attempt was made to close the software synthesizer while it was already 
 * open.
 * ASSERT?
 */
#define DMUS_E_ALREADYCLOSED            MAKE_DMHRESULTERROR(0x0130)

/* DMUS_E_SYNTHNOTCONFIGURED
 *
 * The operation could not be completed because the software synth has not 
 * yet been fully configured.
 * ASSERT?
 */
#define DMUS_E_SYNTHNOTCONFIGURED       MAKE_DMHRESULTERROR(0x0131)

/* DMUS_E_SYNTHACTIVE
 *
 * The operation cannot be carried out while the synthesizer is active.
 */
#define DMUS_E_SYNTHACTIVE              MAKE_DMHRESULTERROR(0x0132)

/* DMUS_E_CANNOTREAD
 *
 * An error occurred while attempting to read from the IStream* object.
 */
#define DMUS_E_CANNOTREAD               MAKE_DMHRESULTERROR(0x0133)

/* DMUS_E_DMUSIC_RELEASED
 *
 * The operation cannot be performed because the final instance of the
 * DirectMusic object was released. Ports cannot be used after final 
 * release of the DirectMusic object.
 */
#define DMUS_E_DMUSIC_RELEASED          MAKE_DMHRESULTERROR(0x0134)

/* DMUS_E_BUFFER_EMPTY
 *
 * There was no data in the referenced buffer.
 */
#define DMUS_E_BUFFER_EMPTY             MAKE_DMHRESULTERROR(0x0135)

/* DMUS_E_BUFFER_FULL
 *
 * There is insufficient space to insert the given event into the buffer.
 */
#define DMUS_E_BUFFER_FULL              MAKE_DMHRESULTERROR(0x0136)

/* DMUS_E_PORT_NOT_CAPTURE
 *
 * The given operation could not be carried out because the port is a
 * capture port.
 */
#define DMUS_E_PORT_NOT_CAPTURE         MAKE_DMHRESULTERROR(0x0137)

/* DMUS_E_PORT_NOT_RENDER
 *
 * The given operation could not be carried out because the port is a
 * render port.
 */
#define DMUS_E_PORT_NOT_RENDER          MAKE_DMHRESULTERROR(0x0138)

/* DMUS_E_DSOUND_NOT_SET
 *
 * The port could not be created because no DirectSound has been specified.
 * Specify a DirectSound interface via the IDirectMusic::SetDirectSound
 * method; pass NULL to have DirectMusic manage usage of DirectSound.
 */
#define DMUS_E_DSOUND_NOT_SET           MAKE_DMHRESULTERROR(0x0139)

/* DMUS_E_ALREADY_ACTIVATED
 *
 * The operation cannot be carried out while the port is active.
 */
#define DMUS_E_ALREADY_ACTIVATED        MAKE_DMHRESULTERROR(0x013A)

/* DMUS_E_INVALIDBUFFER
 *
 * Invalid DirectSound buffer was handed to port. 
 */
#define DMUS_E_INVALIDBUFFER            MAKE_DMHRESULTERROR(0x013B)

/* DMUS_E_WAVEFORMATNOTSUPPORTED
 *
 * Invalid buffer format was handed to the synth sink.
 */
#define DMUS_E_WAVEFORMATNOTSUPPORTED   MAKE_DMHRESULTERROR(0x013C)

/* DMUS_E_SYNTHINACTIVE
 *
 * The operation cannot be carried out while the synthesizer is inactive.
 */
#define DMUS_E_SYNTHINACTIVE            MAKE_DMHRESULTERROR(0x013D)

/* DMUS_E_DSOUND_ALREADY_SET
 *
 * IDirectMusic::SetDirectSound has already been called. It may not be
 * changed while in use.
 */
#define DMUS_E_DSOUND_ALREADY_SET       MAKE_DMHRESULTERROR(0x013E)

/* DMUS_E_INVALID_EVENT
 *
 * The given event is invalid (either it is not a valid MIDI message
 * or it makes use of running status). The event cannot be packed
 * into the buffer.
 */
#define DMUS_E_INVALID_EVENT            MAKE_DMHRESULTERROR(0x013F)

/* DMUS_E_UNSUPPORTED_STREAM
 *
 * The IStream* object does not contain data supported by the loading object.
 */
#define DMUS_E_UNSUPPORTED_STREAM       MAKE_DMHRESULTERROR(0x0150)

/* DMUS_E_ALREADY_INITED
 *
 * The object has already been initialized.
 */
#define DMUS_E_ALREADY_INITED           MAKE_DMHRESULTERROR(0x0151)

/* DMUS_E_INVALID_BAND
 *
 * The file does not contain a valid band.
 */
#define DMUS_E_INVALID_BAND             MAKE_DMHRESULTERROR(0x0152)

/* DMUS_E_TRACK_HDR_NOT_FIRST_CK
 *
 * The IStream* object's data does not have a track header as the first chunk,
 * and therefore can not be read by the segment object.
 */
#define DMUS_E_TRACK_HDR_NOT_FIRST_CK   MAKE_DMHRESULTERROR(0x0155)

/* DMUS_E_TOOL_HDR_NOT_FIRST_CK
 *
 * The IStream* object's data does not have a tool header as the first chunk,
 * and therefore can not be read by the graph object.
 */
#define DMUS_E_TOOL_HDR_NOT_FIRST_CK    MAKE_DMHRESULTERROR(0x0156)

/* DMUS_E_INVALID_TRACK_HDR
 *
 * The IStream* object's data contains an invalid track header (ckid is 0 and
 * fccType is NULL,) and therefore can not be read by the segment object.
 */
#define DMUS_E_INVALID_TRACK_HDR        MAKE_DMHRESULTERROR(0x0157)

/* DMUS_E_INVALID_TOOL_HDR
 *
 * The IStream* object's data contains an invalid tool header (ckid is 0 and
 * fccType is NULL,) and therefore can not be read by the graph object.
 */
#define DMUS_E_INVALID_TOOL_HDR         MAKE_DMHRESULTERROR(0x0158)

/* DMUS_E_ALL_TOOLS_FAILED
 *
 * The graph object was unable to load all tools from the IStream* object data.
 * This may be due to errors in the stream, or the tools being incorrectly
 * registered on the client.
 */
#define DMUS_E_ALL_TOOLS_FAILED         MAKE_DMHRESULTERROR(0x0159)

/* DMUS_E_ALL_TRACKS_FAILED
 *
 * The segment object was unable to load all tracks from the IStream* object data.
 * This may be due to errors in the stream, or the tracks being incorrectly
 * registered on the client.
 */
#define DMUS_E_ALL_TRACKS_FAILED        MAKE_DMHRESULTERROR(0x0160)

/* DMUS_E_NOT_FOUND
 *
 * The requested item was not contained by the object.
 */
#define DMUS_E_NOT_FOUND                MAKE_DMHRESULTERROR(0x0161)

/* DMUS_E_NOT_INIT
 *
 * A required object is not initialized or failed to initialize.
 */
#define DMUS_E_NOT_INIT                 MAKE_DMHRESULTERROR(0x0162)

/* DMUS_E_TYPE_DISABLED
 *
 * The requested parameter type is currently disabled. Parameter types may
 * be enabled and disabled by certain calls to SetParam().
 */
#define DMUS_E_TYPE_DISABLED            MAKE_DMHRESULTERROR(0x0163)

/* DMUS_E_TYPE_UNSUPPORTED
 *
 * The requested parameter type is not supported on the object.
 */
#define DMUS_E_TYPE_UNSUPPORTED         MAKE_DMHRESULTERROR(0x0164)

/* DMUS_E_TIME_PAST
 *
 * The time is in the past, and the operation can not succeed.
 */
#define DMUS_E_TIME_PAST                MAKE_DMHRESULTERROR(0x0165)

/* DMUS_E_TRACK_NOT_FOUND
 *
 * The requested track is not contained by the segment.
 */
#define DMUS_E_TRACK_NOT_FOUND			MAKE_DMHRESULTERROR(0x0166)

/* DMUS_E_NO_MASTER_CLOCK
 *
 * There is no master clock in the performance. Be sure to call
 * IDirectMusicPerformance::Init().
 */
#define DMUS_E_NO_MASTER_CLOCK          MAKE_DMHRESULTERROR(0x0170)

/* DMUS_E_LOADER_NOCLASSID
 *
 * The class id field is required and missing in the DMUS_OBJECTDESC.
 */
#define DMUS_E_LOADER_NOCLASSID         MAKE_DMHRESULTERROR(0x0180)

/* DMUS_E_LOADER_BADPATH
 *
 * The requested file path is invalid.
 */
#define DMUS_E_LOADER_BADPATH           MAKE_DMHRESULTERROR(0x0181)

/* DMUS_E_LOADER_FAILEDOPEN
 *
 * File open failed - either file doesn't exist or is locked.
 */
#define DMUS_E_LOADER_FAILEDOPEN        MAKE_DMHRESULTERROR(0x0182)

/* DMUS_E_LOADER_FORMATNOTSUPPORTED
 *
 * Search data type is not supported.
 */
#define DMUS_E_LOADER_FORMATNOTSUPPORTED    MAKE_DMHRESULTERROR(0x0183)

/* DMUS_E_LOADER_FAILEDCREATE
 *
 * Unable to find or create object.
 */
#define DMUS_E_LOADER_FAILEDCREATE      MAKE_DMHRESULTERROR(0x0184)

/* DMUS_E_LOADER_OBJECTNOTFOUND
 *
 * Object was not found.
 */
#define DMUS_E_LOADER_OBJECTNOTFOUND    MAKE_DMHRESULTERROR(0x0185)

/* DMUS_E_LOADER_NOFILENAME
 *
 * The file name is missing from the DMUS_OBJECTDESC.
 */
#define DMUS_E_LOADER_NOFILENAME	    MAKE_DMHRESULTERROR(0x0186)

/* DMUS_E_INVALIDFILE
 *
 * The file requested is not a valid file.
 */
#define DMUS_E_INVALIDFILE              MAKE_DMHRESULTERROR(0x0200)

/* DMUS_E_ALREADY_EXISTS
 *
 * The tool is already contained in the graph. Create a new instance.
 */
#define DMUS_E_ALREADY_EXISTS           MAKE_DMHRESULTERROR(0x0201)

/* DMUS_E_OUT_OF_RANGE
 *
 * Value is out of range, for instance the requested length is longer than
 * the segment.
 */
#define DMUS_E_OUT_OF_RANGE             MAKE_DMHRESULTERROR(0x0202)

/* DMUS_E_SEGMENT_INIT_FAILED
 *
 * Segment initialization failed, most likely due to a critical memory situation.
 */
#define DMUS_E_SEGMENT_INIT_FAILED      MAKE_DMHRESULTERROR(0x0203)

/* DMUS_E_ALREADY_SENT
 *
 * The DMUS_PMSG has already been sent to the performance object via
 * IDirectMusicPerformance::SendPMsg().
 */
#define DMUS_E_ALREADY_SENT             MAKE_DMHRESULTERROR(0x0204)

/* DMUS_E_CANNOT_FREE
 *
 * The DMUS_PMSG was either not allocated by the performance via
 * IDirectMusicPerformance::AllocPMsg(), or it was already freed via
 * IDirectMusicPerformance::FreePMsg().
 */
#define DMUS_E_CANNOT_FREE              MAKE_DMHRESULTERROR(0x0205)

/* DMUS_E_CANNOT_OPEN_PORT
 *
 * The default system port could not be opened.
 */
#define DMUS_E_CANNOT_OPEN_PORT         MAKE_DMHRESULTERROR(0x0206)

/* DMUS_E_CONNOT_CONVERT
 *
 * A call to MIDIToMusic() or MusicToMIDI() resulted in an error because
 * the requested conversion could not happen. This usually occurs when the
 * provided DMUS_CHORD_KEY structure has an invalid chord or scale pattern.
 */
#define DMUS_E_CONNOT_CONVERT           MAKE_DMHRESULTERROR(0x0207)

/* DMUS_E_DESCEND_CHUNK_FAIL
 * 
 * DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file 
 * was reached before the desired chunk was found.
 */
#define DMUS_E_DESCEND_CHUNK_FAIL       MAKE_DMHRESULTERROR(0x0210)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\win9x\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\choosecolorobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       choosecolorobj.h
//
//--------------------------------------------------------------------------

// ChooseColorObj.h : Declaration of the CChooseColorObject


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CChooseColorObject : 
#ifdef USING_IDISPATCH
	public CComDualImpl<IChooseColor, &IID_IChooseColor, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public IChooseColor,
#endif
	public CComObjectBase<&CLSID_ChooseColor>
{
public:
	CChooseColorObject() ;
BEGIN_COM_MAP(CChooseColorObject)
	COM_INTERFACE_ENTRY(IChooseColor)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()
// Use DECLARE_NOT_AGGREGATABLE(CChooseColorObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CChooseColorObject)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif
// IChooseColor
public:
	STDMETHOD(setOwner)(long hwnd);
	STDMETHOD(setInitialColor)(COLORREF c);
	STDMETHOD(setFlags)(long flags);
	STDMETHOD(show)(int *selected);
	STDMETHOD(getColor)(COLORREF *c);
private:
	HWND m_hwnd;
	COLORREF m_color;
	DWORD m_flags;
	BOOL m_completed;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\inc\dmusbuff.h ===
/***************************************************************************
*                                                                          *
*   DMusBuff.h -- This module defines the buffer format for DirectMusic    *
*                 Shared file between user mode and kernel mode components *
*                                                                          *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.               *
*                                                                          *
***************************************************************************/

#ifndef _DMusBuff_
#define _DMusBuff_

/* Format of DirectMusic events in a buffer
 *
 * A buffer contains 1 or more events, each with the following header.
 * Immediately following the header is the event data. The header+data
 * size is rounded to the nearest quadword (8 bytes).
 */
 
#include <pshpack4.h>                       /* Do not pad at end - that's where the data is */ 
typedef struct _DMUS_EVENTHEADER *LPDMUS_EVENTHEADER;
typedef struct _DMUS_EVENTHEADER
{
    DWORD           cbEvent;                /* Unrounded bytes in event */
    DWORD           dwChannelGroup;         /* Channel group of event */
    REFERENCE_TIME  rtDelta;                /* Delta from start time of entire buffer */
    DWORD           dwFlags;                /* Flags DMUS_EVENT_xxx */
} DMUS_EVENTHEADER;
#include <poppack.h>

#define DMUS_EVENT_STRUCTURED   0x00000001  /* Unstructured data (SysEx, etc.) */

/* The number of bytes to allocate for an event with 'cb' data bytes.
 */ 
#define QWORD_ALIGN(x) (((x) + 7) & ~7)
#define DMUS_EVENT_SIZE(cb) QWORD_ALIGN(sizeof(DMUS_EVENTHEADER) + cb)


#endif /* _DMusBuff_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\inc\dmusicf.h ===
/************************************************************************
*                                                                       *
*   dmusicf.h -- This module defines the DirectMusic file formats       *
*                                                                       *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.            *
*                                                                       *
************************************************************************/

#ifndef _DMUSICF_
#define _DMUSICF_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

interface IDirectMusicCollection;
#ifndef __cplusplus 
typedef interface IDirectMusicCollection IDirectMusicCollection;
#endif

/* Common chunks */

#define DMUS_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DMUS_FOURCC_INFO_LIST         mmioFOURCC('I','N','F','O')
#define DMUS_FOURCC_UNFO_LIST         mmioFOURCC('U','N','F','O')
#define DMUS_FOURCC_UNAM_CHUNK         mmioFOURCC('U','N','A','M')
#define DMUS_FOURCC_UART_CHUNK         mmioFOURCC('U','A','R','T')
#define DMUS_FOURCC_UCOP_CHUNK         mmioFOURCC('U','C','O','P')
#define DMUS_FOURCC_USBJ_CHUNK         mmioFOURCC('U','S','B','J')
#define DMUS_FOURCC_UCMT_CHUNK         mmioFOURCC('U','C','M','T')
#define DMUS_FOURCC_CATEGORY_CHUNK    mmioFOURCC('c','a','t','g')
#define DMUS_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')

/* The following structures are used by the Tracks, and are the packed structures */
/* that are passed to the Tracks inside the IStream. */


typedef struct _DMUS_IO_SEQ_ITEM
{
    MUSIC_TIME    mtTime;
    MUSIC_TIME    mtDuration;
    DWORD         dwPChannel;
    short         nOffset; 
    BYTE          bStatus;
    BYTE          bByte1;
    BYTE          bByte2;
} DMUS_IO_SEQ_ITEM;


typedef struct _DMUS_IO_CURVE_ITEM
{
    MUSIC_TIME  mtStart;
    MUSIC_TIME  mtDuration;
    MUSIC_TIME  mtResetDuration;
    DWORD       dwPChannel;
    short       nOffset;
    short       nStartValue;
    short       nEndValue;
    short       nResetValue;
    BYTE        bType;
    BYTE        bCurveShape;
    BYTE        bCCData;
    BYTE        bFlags;
} DMUS_IO_CURVE_ITEM;


typedef struct _DMUS_IO_TEMPO_ITEM
{
    MUSIC_TIME    lTime;
    double        dblTempo;
} DMUS_IO_TEMPO_ITEM;


typedef struct _DMUS_IO_SYSEX_ITEM
{
    MUSIC_TIME    mtTime;
    DWORD         dwPChannel;
    DWORD         dwSysExLength;
} DMUS_IO_SYSEX_ITEM;


typedef struct _DMUS_IO_TIMESIGNATURE_ITEM
{
    MUSIC_TIME    lTime;
    BYTE          bBeatsPerMeasure;   /* beats per measure (top of time sig) */
    BYTE          bBeat;              /* what note receives the beat (bottom of time sig.) */
                                      /* we can assume that 0 means 256th note */
    WORD          wGridsPerBeat;      /* grids per beat */
} DMUS_IO_TIMESIGNATURE_ITEM;

/* PARAM structures, used by GetParam() and SetParam() */
typedef struct _DMUS_COMMAND_PARAM
{
    BYTE bCommand;
    BYTE bGrooveLevel;
    BYTE bGrooveRange;
} DMUS_COMMAND_PARAM;

typedef struct _DMUS_COMMAND_PARAM_2
{
	MUSIC_TIME mtTime;
    BYTE bCommand;
    BYTE bGrooveLevel;
    BYTE bGrooveRange;
} DMUS_COMMAND_PARAM_2;

typedef DMUS_CHORD_KEY DMUS_CHORD_PARAM; /* DMUS_CHORD_KEY defined in dmusici.h */

typedef struct _DMUS_RHYTHM_PARAM
{
    DMUS_TIMESIGNATURE  TimeSig;
    DWORD               dwRhythmPattern;
} DMUS_RHYTHM_PARAM;

typedef struct _DMUS_TEMPO_PARAM
{
    MUSIC_TIME  mtTime;
    double      dblTempo;
} DMUS_TEMPO_PARAM;


typedef struct _DMUS_MUTE_PARAM
{
    DWORD   dwPChannel;
    DWORD   dwPChannelMap;
    BOOL    fMute;
} DMUS_MUTE_PARAM;

/* Style chunks */

#define DMUS_FOURCC_STYLE_FORM        mmioFOURCC('D','M','S','T')
#define DMUS_FOURCC_STYLE_CHUNK       mmioFOURCC('s','t','y','h')
#define DMUS_FOURCC_PART_LIST         mmioFOURCC('p','a','r','t')
#define DMUS_FOURCC_PART_CHUNK        mmioFOURCC('p','r','t','h')
#define DMUS_FOURCC_NOTE_CHUNK        mmioFOURCC('n','o','t','e')
#define DMUS_FOURCC_CURVE_CHUNK       mmioFOURCC('c','r','v','e')
#define DMUS_FOURCC_PATTERN_LIST      mmioFOURCC('p','t','t','n')
#define DMUS_FOURCC_PATTERN_CHUNK     mmioFOURCC('p','t','n','h')
#define DMUS_FOURCC_RHYTHM_CHUNK      mmioFOURCC('r','h','t','m')
#define DMUS_FOURCC_PARTREF_LIST      mmioFOURCC('p','r','e','f')
#define DMUS_FOURCC_PARTREF_CHUNK     mmioFOURCC('p','r','f','c')
#define DMUS_FOURCC_STYLE_PERS_REF_LIST   mmioFOURCC('p', 'r', 'r', 'f')
#define DMUS_FOURCC_MOTIFSETTINGS_CHUNK   mmioFOURCC('m', 't', 'f', 's')

/* Flags used by variations: these make up the DWORDs in dwVariationChoices.               */

/* These flags determine the types of chords supported by a given variation in DirectMusic */
/* mode.  The first seven flags (bits 1-7) are set if the variation supports major chords  */
/* rooted in scale positions, so, e.g., if bits 1, 2, and 4 are set, the variation         */
/* supports major chords rooted in the tonic, second, and fourth scale positions.  The     */
/* next seven flags serve the same purpose, but for minor chords, and the following seven  */
/* flags serve the same purpose for chords that are not major or minor (e.g., SUS 4        */
/* chords).  Bits 22, 23, and 24 are set if the variation supports chords rooted in the    */
/* scale, chords rooted sharp of scale tones, and chords rooted flat of scale tones,       */
/* respectively.  For example, to support a C# minor chord in the scale of C Major,        */
/* bits 8 (for tonic minor) and 24 (for sharp) need to be set.  Bits 25, 26, an 27 handle  */
/* chords that are triads, 6th or 7th chords, and chords with extensions, respectively.    */
/* bits 28 and 29 handle chords that are followed by tonic and dominant chords,            */
/* respectively.                                                                           */
#define DMUS_VARIATIONF_MAJOR        0x0000007F /* Seven positions in the scale - major chords. */    
#define DMUS_VARIATIONF_MINOR        0x00003F80 /* Seven positions in the scale - minor chords. */    
#define DMUS_VARIATIONF_OTHER        0x001FC000 /* Seven positions in the scale - other chords. */    
#define DMUS_VARIATIONF_ROOT_SCALE   0x00200000 /* Handles chord roots in the scale. */         
#define DMUS_VARIATIONF_ROOT_FLAT    0x00400000 /* Handles flat chord roots (based on scale notes). */         
#define DMUS_VARIATIONF_ROOT_SHARP   0x00800000 /* Handles sharp chord roots (based on scale notes). */         
#define DMUS_VARIATIONF_TYPE_TRIAD   0x01000000 /* Handles simple chords - triads. */  
#define DMUS_VARIATIONF_TYPE_6AND7   0x02000000 /* Handles simple chords - 6 and 7. */  
#define DMUS_VARIATIONF_TYPE_COMPLEX 0x04000000 /* Handles complex chords. */  
#define DMUS_VARIATIONF_DEST_TO1     0x08000000 /* Handles transitions to 1 chord. */  
#define DMUS_VARIATIONF_DEST_TO5     0x10000000 /* Handles transitions to 5 chord. */  

/* The top three bits of the variation flags are the Mode bits.  If all are 0, it's IMA. */  
/* If the smallest is 1, it's Direct Music. */
#define DMUS_VARIATIONF_MODES        0xE0000000
#define DMUS_VARIATIONF_IMA25_MODE   0x00000000
#define DMUS_VARIATIONF_DMUS_MODE    0x20000000

#pragma pack(2)

typedef struct _DMUS_IO_TIMESIG
{
    /* Time signatures define how many beats per measure, which note receives */
    /* the beat, and the grid resolution. */
    BYTE    bBeatsPerMeasure;   /* beats per measure (top of time sig) */
    BYTE    bBeat;              /* what note receives the beat (bottom of time sig.) */
                                /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;      /* grids per beat */
} DMUS_IO_TIMESIG;

typedef struct _DMUS_IO_STYLE
{
    DMUS_IO_TIMESIG     timeSig;        /* Styles have a default Time Signature */
    double              dblTempo;   
} DMUS_IO_STYLE;

typedef struct _DMUS_IO_VERSION
{
    DWORD               dwVersionMS;        /* Version # high-order 32 bits */
    DWORD               dwVersionLS;        /* Version # low-order 32 bits  */
} DMUS_IO_VERSION;

typedef struct _DMUS_IO_PATTERN
{
    DMUS_IO_TIMESIG     timeSig;        /* Patterns can override the Style's Time sig. */
    BYTE                bGrooveBottom;  /* bottom of groove range */
    BYTE                bGrooveTop;     /* top of groove range */
    WORD                wEmbellishment; /* Fill, Break, Intro, End, Normal, Motif */
    WORD                wNbrMeasures;   /* length in measures */
} DMUS_IO_PATTERN;

typedef struct _DMUS_IO_STYLEPART
{
    DMUS_IO_TIMESIG     timeSig;        /* can override pattern's */
    DWORD               dwVariationChoices[32]; /* MOAW choice bitfield */
    GUID                guidPartID;     /* identifies the part */
    WORD                wNbrMeasures;   /* length of the Part */
    BYTE                bPlayModeFlags; /* see PLAYMODE flags */
    BYTE                bInvertUpper;   /* inversion upper limit */
    BYTE                bInvertLower;   /* inversion lower limit */
} DMUS_IO_STYLEPART;

typedef struct _DMUS_IO_PARTREF
{
    GUID    guidPartID;         /* unique ID for matching up with parts */
    WORD    wLogicalPartID;     /* corresponds to port/device/midi channel */
    BYTE    bVariationLockID;   /* parts with the same ID lock variations. */
                                /* high bit is used to identify master Part */
    BYTE    bSubChordLevel;     /* tells which sub chord level this part wants */
    BYTE    bPriority;          /* 256 priority levels. Parts with lower priority */
                                /* aren't played first when a device runs out of */
                                /* notes */
    BYTE    bRandomVariation;   /* when set, matching variations play in random order */
                                /* when clear, matching variations play sequentially */
} DMUS_IO_PARTREF;

typedef struct _DMUS_IO_STYLENOTE
{
    MUSIC_TIME  mtGridStart;    /* when this note occurs */
    DWORD       dwVariation;    /* variation bits */
    MUSIC_TIME  mtDuration;     /* how long this note lasts */
    short       nTimeOffset;    /* offset from mtGridStart */
    WORD        wMusicValue;    /* Position in scale. */
    BYTE        bVelocity;      /* Note velocity. */
    BYTE        bTimeRange;     /* Range to randomize start time. */
    BYTE        bDurRange;      /* Range to randomize duration. */
    BYTE        bVelRange;      /* Range to randomize velocity. */
    BYTE        bInversionID;   /* Identifies inversion group to which this note belongs */
    BYTE        bPlayModeFlags; /* Can override part */
} DMUS_IO_STYLENOTE;

typedef struct _DMUS_IO_STYLECURVE
{
    MUSIC_TIME  mtGridStart;    /* when this curve occurs */
    DWORD       dwVariation;    /* variation bits */
    MUSIC_TIME  mtDuration;     /* how long this curve lasts */
    MUSIC_TIME  mtResetDuration;/* how long after the end of the curve to reset the curve */
    short       nTimeOffset;    /* offset from mtGridStart */
    short       nStartValue;    /* curve's start value */
    short       nEndValue;      /* curve's end value */
    short       nResetValue;    /* the value to which to reset the curve */
    BYTE        bEventType;     /* type of curve */
    BYTE        bCurveShape;    /* shape of curve */
    BYTE        bCCData;        /* CC# */
    BYTE        bFlags;         /* Bit 1=TRUE means to send nResetValue. Otherwise, don't.
                                   Other bits are reserved. */
} DMUS_IO_STYLECURVE;

typedef struct _DMUS_IO_MOTIFSETTINGS
{
    DWORD       dwRepeats;      /* Number of repeats. By default, 0. */
    MUSIC_TIME  mtPlayStart;    /* Start of playback. By default, 0. */
    MUSIC_TIME  mtLoopStart;    /* Start of looping portion. By default, 0. */
    MUSIC_TIME  mtLoopEnd;      /* End of loop. Must be greater than mtLoopStart. By default equal to length of motif. */
    DWORD       dwResolution;   /* Default resolution. */
} DMUS_IO_MOTIFSETTINGS;

#pragma pack()


/*
RIFF
(
    'DMST'          // Style
    <styh-ck>       // Style header chunk
    <guid-ck>       // Every Style has a GUID
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<vers-ck>]     // version chunk
    <part-list>...  // List of parts in the Style, used by patterns
    <pttn-list>...  // List of patterns in the Style
    <DMBD-form>...  // List of bands in the Style
    [<motf-list>]   // List of motifs in the Style
    [<prrf-list>]   // List of chord map references in the Style
)

    // <styh-ck>
    styh
    (
        <DMUS_IO_STYLE>
    )

    // <guid-ck>
    guid
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <part-list>
    LIST
    (
        'part'
        <prth-ck>       // Part header chunk
        [<UNFO-list>]
        [<note-ck>]     // List of notes in Part
        [<crve-ck>]     // List of curves in Part
    )

        // <orth-ck>
        prth
        (
            <DMUS_IO_STYLEPART>
        )

        // <note-ck>
        'note'
        (
            // sizeof DMUS_IO_STYLENOTE:DWORD
            <DMUS_IO_STYLENOTE>...
        )

        // <crve-ck>
        'crve'
        (
            // sizeof DMUS_IO_STYLECURVE:DWORD
            <DMUS_IO_STYLECURVE>...
        )

    // <pttn-list>
    LIST
    (
        'pttn'
        <ptnh-ck>       // Pattern header chunk
        <rhtm-ck>       // List of rhythms for chord matching
        [<UNFO-list>]
        [<mtfs-ck>]     // Motif settings chunk
        <pref-list>...  // List of part reference id's
    )

        // <ptnh-ck>
        ptnh
        (
            <DMUS_IO_PATTERN>
        )

        // <rhtm-ck>
        'rhtm'
        (
            // DWORD's representing rhythms for chord matching based on number
            // of measures in the pattern
        )

        // pref-list
        LIST
        (
            'pref'
            <prfc-ck>   // part ref chunk
        )

        // <prfc-ck>
        prfc
        (
            <DMUS_IO_PARTREF>
        )

        // <mtfs-ck>
        mtfs
        (
            <DMUS_IO_MOTIFSETTINGS>
        )

    // <prrf-list>
    LIST
    (
        'prrf'
        // some number of <DMRF>
    )
*/

/* Chord and command file formats */

#define DMUS_FOURCC_CHORDTRACK_LIST         mmioFOURCC('c','o','r','d')
#define DMUS_FOURCC_CHORDTRACKHEADER_CHUNK  mmioFOURCC('c','r','d','h')
#define DMUS_FOURCC_CHORDTRACKBODY_CHUNK    mmioFOURCC('c','r','d','b')

#define DMUS_FOURCC_COMMANDTRACK_CHUNK      mmioFOURCC('c','m','n','d')

typedef struct _DMUS_IO_CHORD
{
    WCHAR       wszName[16];    /* Name of the chord */
    MUSIC_TIME  mtTime;         /* Time of this chord */
    WORD        wMeasure;       /* Measure this falls on */
    BYTE        bBeat;          /* Beat this falls on */
} DMUS_IO_CHORD;

typedef struct _DMUS_IO_SUBCHORD
{
    DWORD   dwChordPattern;     /* Notes in the subchord */
    DWORD   dwScalePattern;     /* Notes in the scale */
    DWORD   dwInversionPoints;  /* Where inversions can occur */
    DWORD   dwLevels;           /* Which levels are supported by this subchord */
    BYTE    bChordRoot;         /* Root of the subchord */
    BYTE    bScaleRoot;         /* Root of the scale */
} DMUS_IO_SUBCHORD;

typedef struct _DMUS_IO_COMMAND
{
    MUSIC_TIME  mtTime;         /* Time of this command */
    WORD        wMeasure;       /* Measure this falls on */
    BYTE        bBeat;          /* Beat this falls on */
    BYTE        bCommand;       /* Command type (see #defines below) */
    BYTE        bGrooveLevel;   /* Groove level (0 if command is not a groove) */
    BYTE        bGrooveRange;   /* Groove range  */
} DMUS_IO_COMMAND;


/*

    // <cord-list>
    LIST
    (
        'cord'
        <crdh-ck>
        <crdb-ck>       // Chord body chunk
    )

        // <crdh-ck>
        crdh
        (
            // Scale: dword (upper 8 bits for root, lower 24 for scale)
        )

        // <crdb-ck>
        crdb
        (
            // sizeof DMUS_IO_CHORD:dword
            <DMUS_IO_CHORD>
            // # of DMUS_IO_SUBCHORDS:dword
            // sizeof DMUS_IO_SUBCHORDS:dword
            // a number of <DMUS_IO_SUBCHORD>
        )


    // <cmnd-list>
    'cmnd'
    (
        //sizeof DMUS_IO_COMMAND: DWORD
        <DMUS_IO_COMMAND>...
    )

*/

/*  File io for DirectMusic Tool and ToolGraph objects
*/

/* RIFF ids: */

#define DMUS_FOURCC_TOOLGRAPH_FORM  mmioFOURCC('D','M','T','G')
#define DMUS_FOURCC_TOOL_LIST       mmioFOURCC('t','o','l','l')
#define DMUS_FOURCC_TOOL_FORM       mmioFOURCC('D','M','T','L')
#define DMUS_FOURCC_TOOL_CHUNK      mmioFOURCC('t','o','l','h')

/* io structures: */

typedef struct _DMUS_IO_TOOL_HEADER
{
    GUID        guidClassID;    /* Class id of tool. */
    long        lIndex;         /* Position in graph. */
    DWORD       cPChannels;     /* Number of items in channels array. */
    FOURCC      ckid;           /* chunk ID of tool's data chunk if 0 fccType valid. */
    FOURCC      fccType;        /* list type if NULL ckid valid. */
    DWORD       dwPChannels[1]; /* Array of PChannels, size determined by cPChannels. */
} DMUS_IO_TOOL_HEADER;

/*
RIFF
(
    'DMTG'          // DirectMusic ToolGraph chunk
    [<guid-ck>]     // GUID for ToolGraph
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <toll-list>     // List of Tools
)

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <toll-list>
    LIST
    (
        'toll'          // List of tools
        <DMTL-form>...  // Each tool is encapsulated in a RIFF chunk
    )

// <DMTL-form>      // Tools can be embedded in a graph or stored as separate files.
RIFF
(
    'DMTL'
    <tolh-ck>
    [<guid-ck>]     // Optional GUID for tool object instance (not to be confused with Class id in track header)
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Optional name, author, copyright info., comments
    [<data>]        // Tool data. Must be a RIFF readable chunk.
)

    // <tolh-ck>            // Tool header chunk
    (
        'tolh'
        <DMUS_IO_TOOL_HEADER>   // Tool header
    )
*/

/*  File io for DirectMusic Band Track object */


/* RIFF ids: */
#define DMUS_FOURCC_BANDTRACK_FORM  mmioFOURCC('D','M','B','T')
#define DMUS_FOURCC_BANDTRACK_CHUNK mmioFOURCC('b','d','t','h')
#define DMUS_FOURCC_BANDS_LIST      mmioFOURCC('l','b','d','l')
#define DMUS_FOURCC_BAND_LIST       mmioFOURCC('l','b','n','d')
#define DMUS_FOURCC_BANDITEM_CHUNK  mmioFOURCC('b','d','i','h')

/*  io structures */
typedef struct _DMUS_IO_BAND_TRACK_HEADER
{
    BOOL bAutoDownload;     /* Determines if Auto-Download is enabled. */
} DMUS_IO_BAND_TRACK_HEADER;

typedef struct _DMUS_IO_BAND_ITEM_HEADER
{
    MUSIC_TIME lBandTime;   /* Position in track list. */
} DMUS_IO_BAND_ITEM_HEADER;

/*
RIFF
(
    'DMBT'          // DirectMusic Band Track form-type
    [<bdth-ck>]     // Band track header
    [<guid-ck>]     // GUID for band track
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <lbdl-list>     // List of Band Lists
)

    // <bnth-ck>
    'bdth'
    (
        <DMUS_IO_BAND_TRACK_HEADER>
    )

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <lbdl-list>
    LIST
    (
        'lbdl'          // List of bands
        <lbnd-list>     // Each band is encapsulated in a list
    )

        // <lbnd-list>
        LIST
        (
            'lbnd'
            <bdih-ck>
            <DMBD-form> // Band
        )

            // <bdih-ck>            // band item header
            (
                <DMUS_IO_BAND_ITEM_HEADER>  // Band item header
            )
*/      


/*  File io for DirectMusic Band object
*/

/* RIFF ids: */

#define DMUS_FOURCC_BAND_FORM           mmioFOURCC('D','M','B','D')
#define DMUS_FOURCC_INSTRUMENTS_LIST    mmioFOURCC('l','b','i','l')
#define DMUS_FOURCC_INSTRUMENT_LIST     mmioFOURCC('l','b','i','n')
#define DMUS_FOURCC_INSTRUMENT_CHUNK    mmioFOURCC('b','i','n','s')

/* Flags for DMUS_IO_INSTRUMENT
 */
#define DMUS_IO_INST_PATCH          (1 << 0)        /* dwPatch is valid. */
#define DMUS_IO_INST_BANKSELECT     (1 << 1)        /* dwPatch contains a valid Bank Select MSB and LSB part */
#define DMUS_IO_INST_ASSIGN_PATCH   (1 << 3)        /* dwAssignPatch is valid */
#define DMUS_IO_INST_NOTERANGES     (1 << 4)        /* dwNoteRanges is valid */
#define DMUS_IO_INST_PAN            (1 << 5)        /* bPan is valid */
#define DMUS_IO_INST_VOLUME         (1 << 6 )       /* bVolume is valid */
#define DMUS_IO_INST_TRANSPOSE      (1 << 7)        /* nTranspose is valid */
#define DMUS_IO_INST_GM             (1 << 8)        /* Instrument is from GM collection */
#define DMUS_IO_INST_GS             (1 << 9)        /* Instrument is from GS collection */
#define DMUS_IO_INST_XG             (1 << 10)       /* Instrument is from XG collection */
#define DMUS_IO_INST_CHANNEL_PRIORITY (1 << 11)     /* dwChannelPriority is valid */
#define DMUS_IO_INST_USE_DEFAULT_GM_SET (1 << 12)   /* Always use the default GM set for this patch,  */
                                                    /* don't rely on the synth caps stating GM or GS in hardware. */

/*  io structures */
typedef struct _DMUS_IO_INSTRUMENT
{
    DWORD   dwPatch;            /* MSB, LSB and Program change to define instrument */
    DWORD   dwAssignPatch;      /* MSB, LSB and Program change to assign to instrument when downloading */
    DWORD   dwNoteRanges[4];    /* 128 bits; one for each MIDI note instrument needs to able to play */
    DWORD   dwPChannel;         /* PChannel instrument plays on */
    DWORD   dwFlags;            /* DMUS_IO_INST_ flags */
    BYTE    bPan;               /* Pan for instrument */
    BYTE    bVolume;            /* Volume for instrument */
    short   nTranspose;         /* Number of semitones to transpose notes */
    DWORD   dwChannelPriority;  /* Channel priority */
} DMUS_IO_INSTRUMENT;

/*
// <DMBD-form> bands can be embedded in other forms
RIFF
(
    'DMBD'          // DirectMusic Band chunk
    [<guid-ck>]     // GUID for band
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <lbil-list>     // List of Instruments
)

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <lbil-list>
    LIST
    (
        'lbil'          // List of instruments
        <lbin-list>     // Each instrument is encapsulated in a list
    )

        // <lbin-list>
        LIST
        (
            'lbin'
            <bins-ck>
            [<DMRF-list>]       // Optional reference to DLS Collection file.
        )

            // <bins-ck>            // Instrument chunk
            (
                'bins'
                <DMUS_IO_INSTRUMENT>    // Instrument header
            )
*/      

/*  File io for DirectMusic Segment object */

/* RIFF ids: */

#define DMUS_FOURCC_SEGMENT_FORM    mmioFOURCC('D','M','S','G')
#define DMUS_FOURCC_SEGMENT_CHUNK   mmioFOURCC('s','e','g','h')
#define DMUS_FOURCC_TRACK_LIST      mmioFOURCC('t','r','k','l')
#define DMUS_FOURCC_TRACK_FORM      mmioFOURCC('D','M','T','K')
#define DMUS_FOURCC_TRACK_CHUNK     mmioFOURCC('t','r','k','h')

/*  io structures:*/

typedef struct _DMUS_IO_SEGMENT_HEADER
{
    DWORD       dwRepeats;      /* Number of repeats. By default, 0. */
    MUSIC_TIME  mtLength;       /* Length, in music time. */
    MUSIC_TIME  mtPlayStart;    /* Start of playback. By default, 0. */
    MUSIC_TIME  mtLoopStart;    /* Start of looping portion. By default, 0. */
    MUSIC_TIME  mtLoopEnd;      /* End of loop. Must be greater than dwPlayStart. By default equal to length. */
    DWORD       dwResolution;   /* Default resolution. */
} DMUS_IO_SEGMENT_HEADER;

typedef struct _DMUS_IO_TRACK_HEADER
{
    GUID        guidClassID;    /* Class id of track. */
    DWORD       dwPosition;     /* Position in track list. */
    DWORD       dwGroup;        /* Group bits for track. */
    FOURCC      ckid;           /* chunk ID of track's data chunk if 0 fccType valid. */
    FOURCC      fccType;        /* list type if NULL ckid valid */
} DMUS_IO_TRACK_HEADER;

/*
RIFF
(
    'DMSG'          // DirectMusic Segment chunk
    <segh-ck>       // Segment header chunk
    [<guid-ck>]     // GUID for segment
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <trkl-list>     // List of Tracks
    [<DMTG-form>]   // Optional ToolGraph
)

    // <segh-ck>        
    'segh'
    (
        <DMUS_IO_SEGMENT_HEADER>
    )
    
    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <trkl-list>
    LIST
    (
        'trkl'          // List of tracks
        <DMTK-form>...  // Each track is encapsulated in a RIFF chunk
    )

// <DMTK-form>      // Tracks can be embedded in a segment or stored as separate files.
RIFF
(
    'DMTK'
    <trkh-ck>
    [<guid-ck>]     // Optional GUID for track object instance (not to be confused with Class id in track header)
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Optional name, author, copyright info., comments
    [<data>]        // Track data. Must be a RIFF readable chunk.
)

    // <trkh-ck>            // Track header chunk
    (
        'trkh'
        <DMUS_IO_TRACK_HEADER>  // Track header
    )
*/

/*  File io for DirectMusic reference chunk. 
    This is used to embed a reference to an object.
*/

/*  RIFF ids: */

#define DMUS_FOURCC_REF_LIST        mmioFOURCC('D','M','R','F')
#define DMUS_FOURCC_REF_CHUNK       mmioFOURCC('r','e','f','h')
#define DMUS_FOURCC_DATE_CHUNK      mmioFOURCC('d','a','t','e')
#define DMUS_FOURCC_NAME_CHUNK      mmioFOURCC('n','a','m','e')
#define DMUS_FOURCC_FILE_CHUNK      mmioFOURCC('f','i','l','e')

typedef struct _DMUS_IO_REFERENCE
{
    GUID    guidClassID;    /* Class id is always required. */
    DWORD   dwValidData;    /* Flags. */
} DMUS_IO_REFERENCE;

/*
LIST
(
    'DMRF'          // DirectMusic Reference chunk
    <refh-ck>       // Reference header chunk
    [<guid-ck>]     // Optional object GUID.
    [<date-ck>]     // Optional file date.
    [<name-ck>]     // Optional name.
    [<file-ck>]     // Optional file name.
    [<catg-ck>]     // Optional category name.
    [<vers-ck>]     // Optional version info.
)

    // <refh-ck>
    'refh'
    (
        <DMUS_IO_REFERENCE>
    )

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <date-ck>
    date
    (
        <FILETIME>
    )

    // <name-ck>
    name
    (
        // Name, stored as NULL terminated string of WCHARs
    )

    // <file-ck>
    file
    (
        // File name, stored as NULL terminated string of WCHARs
    )

    // <catg-ck>
    catg
    (
        // Category name, stored as NULL terminated string of WCHARs
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )
*/

/* Chord Maps */

/* runtime chunks */
#define DMUS_FOURCC_CHORDMAP_FORM       mmioFOURCC('D','M','P','R')
#define DMUS_FOURCC_IOCHORDMAP_CHUNK    mmioFOURCC('p','e','r','h')
#define DMUS_FOURCC_SUBCHORD_CHUNK      mmioFOURCC('c','h','d','t')
#define DMUS_FOURCC_CHORDENTRY_CHUNK    mmioFOURCC('c','h','e','h')
#define DMUS_FOURCC_SUBCHORDID_CHUNK    mmioFOURCC('s','b','c','n')
#define DMUS_FOURCC_IONEXTCHORD_CHUNK   mmioFOURCC('n','c','r','d')
#define DMUS_FOURCC_NEXTCHORDSEQ_CHUNK  mmioFOURCC('n','c','s','q')
#define DMUS_FOURCC_IOSIGNPOST_CHUNK    mmioFOURCC('s','p','s','h')
#define DMUS_FOURCC_CHORDNAME_CHUNK     mmioFOURCC('I','N','A','M')

/* runtime list chunks */
#define DMUS_FOURCC_CHORDENTRY_LIST     mmioFOURCC('c','h','o','e')
#define DMUS_FOURCC_CHORDMAP_LIST       mmioFOURCC('c','m','a','p')
#define DMUS_FOURCC_CHORD_LIST          mmioFOURCC('c','h','r','d')
#define DMUS_FOURCC_CHORDPALETTE_LIST   mmioFOURCC('c','h','p','l')
#define DMUS_FOURCC_CADENCE_LIST        mmioFOURCC('c','a','d','e')
#define DMUS_FOURCC_SIGNPOSTITEM_LIST   mmioFOURCC('s','p','s','t')

#define DMUS_FOURCC_SIGNPOST_LIST       mmioFOURCC('s','p','s','q')

/* values for dwChord field of DMUS_IO_PERS_SIGNPOST */
/* DMUS_SIGNPOSTF_ flags are also used in templates (DMUS_IO_SIGNPOST) */
#define DMUS_SIGNPOSTF_A        1      
#define DMUS_SIGNPOSTF_B        2
#define DMUS_SIGNPOSTF_C        4
#define DMUS_SIGNPOSTF_D        8
#define DMUS_SIGNPOSTF_E        0x10
#define DMUS_SIGNPOSTF_F        0x20
#define DMUS_SIGNPOSTF_LETTER   (DMUS_SIGNPOSTF_A | DMUS_SIGNPOSTF_B | DMUS_SIGNPOSTF_C | DMUS_SIGNPOSTF_D | DMUS_SIGNPOSTF_E | DMUS_SIGNPOSTF_F)
#define DMUS_SIGNPOSTF_1        0x100
#define DMUS_SIGNPOSTF_2        0x200
#define DMUS_SIGNPOSTF_3        0x400
#define DMUS_SIGNPOSTF_4        0x800
#define DMUS_SIGNPOSTF_5        0x1000
#define DMUS_SIGNPOSTF_6        0x2000
#define DMUS_SIGNPOSTF_7        0x4000
#define DMUS_SIGNPOSTF_ROOT     (DMUS_SIGNPOSTF_1 | DMUS_SIGNPOSTF_2 | DMUS_SIGNPOSTF_3 | DMUS_SIGNPOSTF_4 | DMUS_SIGNPOSTF_5 | DMUS_SIGNPOSTF_6 | DMUS_SIGNPOSTF_7)
#define DMUS_SIGNPOSTF_CADENCE  0x8000

/* values for dwChord field of DMUS_IO_PERS_SIGNPOST */
#define DMUS_SPOSTCADENCEF_1  2   /* Use the first cadence chord. */
#define DMUS_SPOSTCADENCEF_2  4   /* Use the second cadence chord. */

/* run time data structs */
typedef struct _DMUS_IO_CHORDMAP
{
    WCHAR   wszLoadName[20];
    DWORD   dwScalePattern;
    DWORD   dwFlags;
} DMUS_IO_CHORDMAP;

typedef struct _DMUS_IO_CHORDMAP_SUBCHORD
{
    DWORD   dwChordPattern;
    DWORD   dwScalePattern;
    DWORD   dwInvertPattern;
    BYTE    bChordRoot;
    BYTE    bScaleRoot;
    WORD    wCFlags;
    DWORD   dwLevels;   /* parts or which subchord levels this chord supports */
} DMUS_IO_CHORDMAP_SUBCHORD;

/* Legacy name... */
typedef DMUS_IO_CHORDMAP_SUBCHORD DMUS_IO_PERS_SUBCHORD;

typedef struct _DMUS_IO_CHORDENTRY
{
    DWORD   dwFlags;
    WORD    wConnectionID;  /* replaces runtime "pointer to this" */
} DMUS_IO_CHORDENTRY;

typedef struct _DMUS_IO_NEXTCHORD
{
    DWORD   dwFlags;
    WORD    nWeight;
    WORD    wMinBeats;
    WORD    wMaxBeats;
    WORD    wConnectionID;  /* points to an ioChordEntry */
} DMUS_IO_NEXTCHORD;

typedef struct _DMUS_IO_CHORDMAP_SIGNPOST
{
    DWORD   dwChords;   /* 1bit per group */
    DWORD   dwFlags;
} DMUS_IO_CHORDMAP_SIGNPOST;

/* Legacy name... */
typedef DMUS_IO_CHORDMAP_SIGNPOST DMUS_IO_PERS_SIGNPOST;

/*
RIFF
(
    'DMPR'
    <perh-ck>           // Chord map header chunk
    [<guid-ck>]         // guid chunk
    [<vers-ck>]         // version chunk (two DWORDS)
    [<UNFO-list>]       // Unfo chunk
    <chdt-ck>           // subchord database
    <chpl-list>         // chord palette
    <cmap-list>         // chord map
    <spsq-list>         // signpost list
 )

<cmap-list> ::= LIST('cmap' <choe-list> )

<choe-list> ::= LIST('choe'
                                <cheh-ck>   // chord entry data
                                <chrd-list> // chord definition
                                <ncsq-ck>   // connecting(next) chords
                     )

<chrd-list> ::= LIST('chrd' 
                                <INAM-ck>   // name of chord in wide char format
                                <sbcn-ck>   // list of subchords composing chord
                    )

<chpl-list> ::= LIST('chpl' 
                                <chrd-list> ... // chord definition
                    )

<spsq-list> ::== LIST('spsq' <spst-list> ... )

<spst-list> ::= LIST('spst'
                             <spsh-ck>
                             <chrd-list>
                             [<cade-list>]
                    )

<cade-list> ::= LIST('cade' <chrd-list> ...)

<perh-ck> ::= perh(<DMUS_IO_CHORDMAP>)

<chdt-ck> ::= chdt(<cbChordSize::WORD>
                   <DMUS_IO_PERS_SUBCHORD> ... )

<cheh-ck> ::= cheh(<DMUS_IO_CHORDENTRY>)

<sbcn-ck> ::= sbcn(<cSubChordID:WORD> ...)

<ncsq-ck> ::= ncsq(<wNextChordSize:WORD> 
                   <DMUS_IO_NEXTCHORD>...)

<spsh-ck> ::= spsh(<DMUS_IO_PERS_SIGNPOST>)

*/

/* Signpost tracks */

#define DMUS_FOURCC_SIGNPOST_TRACK_CHUNK     mmioFOURCC( 's', 'g', 'n', 'p' )


typedef struct _DMUS_IO_SIGNPOST
{
    MUSIC_TIME  mtTime;
    DWORD       dwChords;
    WORD        wMeasure;
} DMUS_IO_SIGNPOST;

/*

    // <sgnp-list>
    'sgnp'
    (
        //sizeof DMUS_IO_SIGNPOST: DWORD
        <DMUS_IO_SIGNPOST>...
    )

*/

#define DMUS_FOURCC_MUTE_CHUNK  mmioFOURCC('m','u','t','e')

typedef struct _DMUS_IO_MUTE
{
    MUSIC_TIME  mtTime;
    DWORD       dwPChannel;
    DWORD       dwPChannelMap;
} DMUS_IO_MUTE;

/*

    // <mute-list>
    'mute'
    (
        //sizeof DMUS_IO_MUTE:DWORD
        <DMUS_IO_MUTE>...
    )


*/

/* Used for both style and chord map tracks */

#define DMUS_FOURCC_TIME_STAMP_CHUNK    mmioFOURCC('s', 't', 'm', 'p')

/* Style tracks */

#define DMUS_FOURCC_STYLE_TRACK_LIST    mmioFOURCC('s', 't', 't', 'r')
#define DMUS_FOURCC_STYLE_REF_LIST      mmioFOURCC('s', 't', 'r', 'f')

/*

    // <sttr-list>
    LIST('sttr'
    (
        // some number of <strf-list>
    )

    // <strf-list>
    LIST('strf'
    (
        <stmp-ck>
        <DMRF>
    )

    // <stmp-ck> defined in ..\dmcompos\dmcompp.h

*/

/* Chord map tracks */

#define DMUS_FOURCC_PERS_TRACK_LIST mmioFOURCC('p', 'f', 't', 'r')
#define DMUS_FOURCC_PERS_REF_LIST   mmioFOURCC('p', 'f', 'r', 'f')

/*

    // <pftr-list>
    LIST('pftr'
    (
        // some number of <pfrf-list>
    )

    // <pfrf-list>
    LIST('pfrf'
    (
        <stmp-ck>
        <DMRF>
    )

  // <stmp-ck>
  'stmp'
  (
    // time:DWORD
  )



*/

#define DMUS_FOURCC_TEMPO_TRACK     mmioFOURCC('t','e','t','r')

/*
    // tempo list
    'tetr'
    (
        // sizeof DMUS_IO_TEMPO_ITEM: DWORD
        <DMUS_IO_TEMPO_ITEM>...
    )
  */

#define DMUS_FOURCC_SEQ_TRACK       mmioFOURCC('s','e','q','t')
#define DMUS_FOURCC_SEQ_LIST        mmioFOURCC('e','v','t','l')
#define DMUS_FOURCC_CURVE_LIST      mmioFOURCC('c','u','r','l')

/*
    // sequence track
    'seqt'
    (
        // sequence list
        'evtl'
        (
            // sizeof DMUS_IO_SEQ_ITEM: DWORD
            <DMUS_IO_SEQ_ITEM>...
        )
        // curve list
        'curl'
        (
            // sizeof DMUS_IO_CURVE_ITEM: DWORD
            <DMUS_IO_CURVE_ITEM>...
        )
    )
*/

#define DMUS_FOURCC_SYSEX_TRACK     mmioFOURCC('s','y','e','x')

/*
    // sysex track
    'syex'
    (
        // list of:
        // {
        //      <DMUS_IO_SYSEX_ITEM>
        //      sys-ex: data
        // }...
    )
*/

#define DMUS_FOURCC_TIMESIGNATURE_TRACK mmioFOURCC('t','i','m','s')

/*
    // time signature track
    'tims'
    (
        // size of DMUS_IO_TIMESIGNATURE_ITEM : DWORD
        <DMUS_IO_TIMESIGNATURE_ITEM>...
    )
*/

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICF_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\inc\dmusici.h ===
/************************************************************************
*                                                                       *
*   dmusici.h -- This module contains the API for the                   *
*                DirectMusic performance layer                          *
*                                                                       *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.            *
*                                                                       *
************************************************************************/

#ifndef _DMUSICI_
#define _DMUSICI_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>
#include "dmusicc.h"

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef WORD            TRANSITION_TYPE;
typedef __int64         REFERENCE_TIME;
typedef long            MUSIC_TIME;

#define DMUS_PPQ        768     /* parts per quarter note */

interface IDirectMusic;
interface IDirectMusicTrack;
interface IDirectMusicPerformance;
interface IDirectMusicTool;
interface IDirectMusicSegment;
interface IDirectMusicSegmentState;
interface IDirectMusicGraph;
interface IDirectMusicPort;
interface IDirectMusicBuffer;
interface IDirectMusicInstrument;
interface IDirectMusicDownloadedInstrument;
interface IDirectMusicBand;
interface IDirectMusicChordMap;
interface IDirectMusicLoader;
interface IDirectMusicObject;
#ifndef __cplusplus 
typedef interface IDirectMusic IDirectMusic;
typedef interface IDirectMusicTrack IDirectMusicTrack;
typedef interface IDirectMusicPerformance IDirectMusicPerformance;
typedef interface IDirectMusicTool IDirectMusicTool;
typedef interface IDirectMusicSegment IDirectMusicSegment;
typedef interface IDirectMusicSegmentState IDirectMusicSegmentState;
typedef interface IDirectMusicGraph IDirectMusicGraph;
typedef interface IDirectMusicPort IDirectMusicPort;
typedef interface IDirectMusicBuffer IDirectMusicBuffer;
typedef interface IDirectMusicInstrument IDirectMusicInstrument;
typedef interface IDirectMusicDownloadedInstrument IDirectMusicDownloadedInstrument;
typedef interface IDirectMusicBand IDirectMusicBand;
typedef interface IDirectMusicChordMap IDirectMusicChordMap;
typedef interface IDirectMusicObject IDirectMusicObject;
typedef interface IDirectMusicLoader IDirectMusicLoader;
#endif

typedef enum enumDMUS_COMMANDT_TYPES
{
    DMUS_COMMANDT_GROOVE            = 0,
    DMUS_COMMANDT_FILL              = 1,
    DMUS_COMMANDT_INTRO             = 2,
    DMUS_COMMANDT_BREAK             = 3,
    DMUS_COMMANDT_END               = 4,
    DMUS_COMMANDT_ENDANDINTRO       = 5
} DMUS_COMMANDT_TYPES;

typedef enum enumDMUS_SHAPET_TYPES
{
    DMUS_SHAPET_FALLING             = 0,
    DMUS_SHAPET_LEVEL               = 1,
    DMUS_SHAPET_LOOPABLE            = 2,
    DMUS_SHAPET_LOUD                = 3,
    DMUS_SHAPET_QUIET               = 4,
    DMUS_SHAPET_PEAKING             = 5,
    DMUS_SHAPET_RANDOM              = 6,
    DMUS_SHAPET_RISING              = 7,
    DMUS_SHAPET_SONG                = 8
}   DMUS_SHAPET_TYPES;

typedef enum enumDMUS_COMPOSEF_FLAGS
{       
    DMUS_COMPOSEF_NONE              = 0,
    DMUS_COMPOSEF_ALIGN             = 0x1,
    DMUS_COMPOSEF_OVERLAP           = 0x2,
    DMUS_COMPOSEF_IMMEDIATE         = 0x4,
    DMUS_COMPOSEF_GRID              = 0x8,
    DMUS_COMPOSEF_BEAT              = 0x10,
    DMUS_COMPOSEF_MEASURE           = 0x20,
    DMUS_COMPOSEF_AFTERPREPARETIME  = 0x40,
    DMUS_COMPOSEF_MODULATE          = 0x1000,
    DMUS_COMPOSEF_LONG              = 0x2000
}   DMUS_COMPOSEF_FLAGS;

#define DMUS_PMSG_PART                                                                              \
    DWORD               dwSize;                                                                     \
    REFERENCE_TIME      rtTime;             /* real time (in 100 nanosecond increments) */          \
    MUSIC_TIME          mtTime;             /* music time */                                        \
    DWORD               dwFlags;            /* various bits (see DMUS_PMSG_FLAGS enumeration) */    \
    DWORD               dwPChannel;         /* Performance Channel. The Performance can */          \
                                            /* use this to determine the port/channel. */           \
    DWORD               dwVirtualTrackID;   /* virtual track ID */                                  \
    IDirectMusicTool*   pTool;              /* tool interface pointer */                            \
    IDirectMusicGraph*  pGraph;             /* tool graph interface pointer */                      \
    DWORD               dwType;             /* PMSG type (see DMUS_PMSGT_TYPES defines) */              \
    DWORD               dwVoiceID;          /* unique voice id which allows synthesizers to */      \
                                            /* identify a specific event. For DirectX 6.0, */       \
                                            /* this field should always be 0. */                    \
    DWORD               dwGroupID;          /* Track group id */                                 \
    IUnknown*           punkUser;           /* user com pointer, auto released upon PMSG free */

/* every DMUS_PMSG is based off of this structure. The Performance needs 
   to access these members consistently in every PMSG that goes through it. */
typedef struct _DMUS_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

} DMUS_PMSG;

/* DMUS_PMSGF_FLAGS fill the DMUS_PMSG's dwFlags member */
typedef enum enumDMUS_PMSGF_FLAGS
{
    DMUS_PMSGF_REFTIME          = 1,      /* if rtTime is valid */
    DMUS_PMSGF_MUSICTIME        = 2,      /* if mtTime is valid */
    DMUS_PMSGF_TOOL_IMMEDIATE   = 4,      /* if PMSG should be processed immediately */ 
    DMUS_PMSGF_TOOL_QUEUE       = 8,      /* if PMSG should be processed a little early, at Queue time */
    DMUS_PMSGF_TOOL_ATTIME      = 16,     /* if PMSG should be processed at the time stamp */
    DMUS_PMSGF_TOOL_FLUSH       = 32      /* if PMSG is being flushed */
    /* The values of DMUS_TIME_RESOLVE_FLAGS may also be used inside the */
    /* DMUS_PMSG's dwFlags member. */
} DMUS_PMSGF_FLAGS;

/* DMUS_PMSGT_TYPES fill the DMUS_PMSG's dwType member */
typedef enum enumDMUS_PMSGT_TYPES
{
    DMUS_PMSGT_MIDI             = 0,      /* MIDI short message */
    DMUS_PMSGT_NOTE             = 1,      /* Interactive Music Note */
    DMUS_PMSGT_SYSEX            = 2,      /* MIDI long message (system exclusive message) */
    DMUS_PMSGT_NOTIFICATION     = 3,      /* Notification message */
    DMUS_PMSGT_TEMPO            = 4,      /* Tempo message */
    DMUS_PMSGT_CURVE            = 5,      /* Control change / pitch bend, etc. curve */
    DMUS_PMSGT_TIMESIG          = 6,      /* Time signature */
    DMUS_PMSGT_PATCH            = 7,      /* Patch changes */
    DMUS_PMSGT_TRANSPOSE        = 8,      /* Transposition messages */
    DMUS_PMSGT_CHANNEL_PRIORITY = 9,      /* Channel priority */
    DMUS_PMSGT_STOP             = 10,     /* Stop message */
    DMUS_PMSGT_DIRTY            = 11,     /* Tells Tools that cache GetParam() info to refresh */
    DMUS_PMSGT_USER             = 255     /* User message */
} DMUS_PMSGT_TYPES;

/* DMUS_SEGF_FLAGS correspond to IDirectMusicPerformance::PlaySegment, and other API */
typedef enum enumDMUS_SEGF_FLAGS
{
    DMUS_SEGF_REFTIME           = 64,     /* time parameter is in reference time  */
    DMUS_SEGF_SECONDARY         = 128,    /* secondary segment */
    DMUS_SEGF_QUEUE             = 256,    /* queue at the end of the primary segment queue (primary only) */
    DMUS_SEGF_CONTROL           = 512,    /* play as a control track (secondary segments only) */
    DMUS_SEGF_AFTERPREPARETIME  = 1<<10,  /* play after the prepare time (See IDirectMusicPerformance::GetPrepareTime) */
    DMUS_SEGF_GRID              = 1<<11,  /* play on grid boundary */
    DMUS_SEGF_BEAT              = 1<<12,  /* play on beat boundary */
    DMUS_SEGF_MEASURE           = 1<<13,  /* play on measure boundary */
    DMUS_SEGF_DEFAULT           = 1<<14,  /* use segment's default boundary */
    DMUS_SEGF_NOINVALIDATE      = 1<<15   /* play without invalidating the currently playing segment(s) */
} DMUS_SEGF_FLAGS;

/* DMUS_TIME_RESOLVE_FLAGS correspond to IDirectMusicPerformance::GetResolvedTime, and can */
/* also be used interchangeably with the corresponding DMUS_SEGF_FLAGS, since their values */
/* are intentionally the same */
typedef enum enumDMUS_TIME_RESOLVE_FLAGS
{
    DMUS_TIME_RESOLVE_AFTERPREPARETIME  = 1<<10,  /* resolve to a time after the prepare time */
    DMUS_TIME_RESOLVE_GRID              = 1<<11,  /* resolve to a time on a grid boundary */
    DMUS_TIME_RESOLVE_BEAT              = 1<<12,  /* resolve to a time on a beat boundary */
    DMUS_TIME_RESOLVE_MEASURE           = 1<<13   /* resolve to a time on a measure boundary */
} DMUS_TIME_RESOLVE_FLAGS;

/* The following flags are sent in the IDirectMusicTrack::Play() method */
/* inside the dwFlags parameter */
typedef enum enumDMUS_TRACKF_FLAGS
{
    DMUS_TRACKF_SEEK            = 1,      /* set on a seek */
    DMUS_TRACKF_LOOP            = 2,      /* set on a loop (repeat) */
    DMUS_TRACKF_START           = 4,      /* set on first call to Play */
    DMUS_TRACKF_FLUSH           = 8,      /* set when this call is in response to a flush on the perfomance */
    DMUS_TRACKF_DIRTY           = 16,     /* set when the track should consider any cached values from a previous call to GetParam to be invalidated */
} DMUS_TRACKF_FLAGS;

#define DMUS_MAXSUBCHORD 8

typedef struct _DMUS_SUBCHORD
{
    DWORD   dwChordPattern;     /* Notes in the subchord */
    DWORD   dwScalePattern;     /* Notes in the scale */
    DWORD   dwInversionPoints;  /* Where inversions can occur */
    DWORD   dwLevels;           /* Which levels are supported by this subchord */
    BYTE    bChordRoot;         /* Root of the subchord */
    BYTE    bScaleRoot;         /* Root of the scale */
} DMUS_SUBCHORD;

typedef struct _DMUS_CHORD_KEY
{
    WCHAR           wszName[16];        /* Name of the chord */
    WORD            wMeasure;           /* Measure this falls on */
    BYTE            bBeat;              /* Beat this falls on */
    BYTE            bSubChordCount;     /* Number of chords in the list of subchords */
    DMUS_SUBCHORD   SubChordList[DMUS_MAXSUBCHORD]; /* List of sub chords */
    DWORD           dwScale;            /* Scale underlying the entire chord */
    BYTE            bKey;               /* Key underlying the entire chord */
} DMUS_CHORD_KEY;

/* DMUS_NOTE_PMSG */
typedef struct _DMUS_NOTE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    MUSIC_TIME mtDuration;     /* duration */
    WORD    wMusicValue;       /* Description of note in chord and key. */
    WORD    wMeasure;          /* Measure in which this note occurs */
    short   nOffset;           /* Offset from grid at which this note occurs */
    BYTE    bBeat;             /* Beat (in measure) at which this note occurs */
    BYTE    bGrid;             /* Grid offset from beat at which this note occurs */
    BYTE    bVelocity;         /* Note velocity */
    BYTE    bFlags;            /* see DMUS_NOTE_FLAGS */
    BYTE    bTimeRange;        /* Range to randomize time. */
    BYTE    bDurRange;         /* Range to randomize duration. */
    BYTE    bVelRange;         /* Range to randomize velocity. */
    BYTE    bPlayModeFlags;    /* Play mode */
    BYTE    bSubChordLevel;    /* Which subchord level this note uses.  */
    BYTE    bMidiValue;        /* The MIDI note value, converted from wMusicValue */
    char    cTranspose;        /* Transposition to add to midi note value after converted from wMusicValue. */
} DMUS_NOTE_PMSG;

typedef enum enumDMUS_NOTEF_FLAGS
{
    DMUS_NOTEF_NOTEON = 1,     /* Set if this is a MIDI Note On. Otherwise, it is MIDI Note Off */
} DMUS_NOTEF_FLAGS;

/* The DMUS_PLAYMODE_FLAGS are used to determine how to convert wMusicValue
   into the appropriate bMidiValue.
*/

typedef enum enumDMUS_PLAYMODE_FLAGS
{
    DMUS_PLAYMODE_KEY_ROOT          = 1,  /* Transpose on top of the key root. */
    DMUS_PLAYMODE_CHORD_ROOT        = 2,  /* Transpose on top of the chord root. */
    DMUS_PLAYMODE_SCALE_INTERVALS   = 4,  /* Use scale intervals from scale pattern. */
    DMUS_PLAYMODE_CHORD_INTERVALS   = 8,  /* Use chord intervals from chord pattern. */
    DMUS_PLAYMODE_NONE              = 16, /* No mode. Indicates the parent part's mode should be used. */
} DMUS_PLAYMODE_FLAGS;

/* The following are playback modes that can be created by combining the DMUS_PLAYMODE_FLAGS
   in various ways:
*/

/* Fixed. wMusicValue holds final MIDI note value. This is used for drums, sound effects, and sequenced
   notes that should not be transposed by the chord or scale.
*/
#define DMUS_PLAYMODE_FIXED             0  
/* In fixed to key, the musicvalue is again a fixed MIDI value, but it
   is transposed on top of the key root. 
*/
#define DMUS_PLAYMODE_FIXEDTOKEY        DMUS_PLAYMODE_KEY_ROOT
/* In fixed to chord, the musicvalue is also a fixed MIDI value, but it
   is transposed on top of the chord root. 
*/
#define DMUS_PLAYMODE_FIXEDTOCHORD      DMUS_PLAYMODE_CHORD_ROOT
/* In Pedalpoint, the key root is used and the notes only track the intervals in
   the scale. The chord root and intervals are completely ignored. This is useful
   for melodic lines that play relative to the key root.
*/
#define DMUS_PLAYMODE_PEDALPOINT        (DMUS_PLAYMODE_KEY_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS)
/* In the Melodic mode, the chord root is used but the notes only track the intervals in
   the scale. The key root and chord intervals are completely ignored. This is useful
   for melodic lines that play relative to the chord root. 
*/
#define DMUS_PLAYMODE_MELODIC           (DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS)
/* Normal chord mode is the prevalent playback mode. 
   The notes track the intervals in the chord, which is based on the chord root. 
   If there is a scale component to the MusicValue, the additional intervals 
   are pulled from the scale and added.
   If the chord does not have an interval to match the chord component of
   the MusicValue, the note is silent.
*/
#define DMUS_PLAYMODE_NORMALCHORD       (DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_CHORD_INTERVALS)
/* If it is desirable to play a note that is above the top of the chord, the
   always play mode (known as "purpleized" in a former life) finds a position
   for the note by using intervals from the scale. Essentially, this mode is
   a combination of the Normal and Melodic playback modes, where a failure
   in Normal causes a second try in Melodic mode.
*/
#define DMUS_PLAYMODE_ALWAYSPLAY        (DMUS_PLAYMODE_MELODIC | DMUS_PLAYMODE_NORMALCHORD)

/*  Legacy names for modes... */
#define DMUS_PLAYMODE_PURPLEIZED        DMUS_PLAYMODE_ALWAYSPLAY
#define DMUS_PLAYMODE_SCALE_ROOT        DMUS_PLAYMODE_KEY_ROOT
#define DMUS_PLAYMODE_FIXEDTOSCALE      DMUS_PLAYMODE_FIXEDTOKEY


/* DMUS_MIDI_PMSG */
typedef struct _DMUS_MIDI_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    BYTE    bStatus;
    BYTE    bByte1;
    BYTE    bByte2;
    BYTE    bPad[1];
} DMUS_MIDI_PMSG;

/* DMUS_PATCH_PMSG */
typedef struct _DMUS_PATCH_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    BYTE    byInstrument;
    BYTE    byMSB;
    BYTE    byLSB;
    BYTE    byPad[1];
} DMUS_PATCH_PMSG;

/* DMUS_TRANSPOSE_PMSG */
typedef struct _DMUS_TRANSPOSE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    short   nTranspose;
} DMUS_TRANSPOSE_PMSG;

/* DMUS_CHANNEL_PRIORITY_PMSG */
typedef struct _DMUS_CHANNEL_PRIORITY_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DWORD   dwChannelPriority;
} DMUS_CHANNEL_PRIORITY_PMSG;

/* DMUS_TEMPO_PMSG */
typedef struct _DMUS_TEMPO_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    double  dblTempo;                       /* the tempo */
} DMUS_TEMPO_PMSG;

#define DMUS_TEMPO_MAX          1000
#define DMUS_TEMPO_MIN          1

#define DMUS_MASTERTEMPO_MAX    100.0f
#define DMUS_MASTERTEMPO_MIN    0.01f

/* DMUS_SYSEX_PMSG */
typedef struct _DMUS_SYSEX_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DWORD   dwLen;          /* length of the data */
    BYTE    abData[1];      /* array of data, length equal to dwLen */
} DMUS_SYSEX_PMSG;

/* DMUS_CURVE_PMSG */
typedef struct _DMUS_CURVE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    MUSIC_TIME      mtDuration;      /* how long this curve lasts */
    MUSIC_TIME      mtOriginalStart; /* must be set to either zero when this PMSG is created or to the original mtTime of the curve */
    MUSIC_TIME      mtResetDuration; /* how long after the curve is finished to reset to the
                                        reset value, nResetValue */
    short           nStartValue;     /* curve's start value */
    short           nEndValue;       /* curve's end value */
    short           nResetValue;     /* curve's reset value, sent after mtResetDuration or
                                        upon a flush or invalidation */
    WORD            wMeasure;        /* Measure in which this curve occurs */
    short           nOffset;         /* Offset from grid at which this curve occurs */
    BYTE            bBeat;           /* Beat (in measure) at which this curve occurs */
    BYTE            bGrid;           /* Grid offset from beat at which this curve occurs */
    BYTE            bType;           /* type of curve */
    BYTE            bCurveShape;     /* shape of curve */
    BYTE            bCCData;         /* CC# if this is a control change type */
    BYTE            bFlags;          /* set to 1 if the nResetValue must be sent when the 
                                        time is reached or an invalidate occurs because
                                        of a transition. If 0, the curve stays
                                        permanently stuck at the new value. All bits besides
                                        1 are reserved. */

} DMUS_CURVE_PMSG;

typedef enum enumDMUS_CURVE_FLAGS
{
    DMUS_CURVE_RESET = 1,           /* Set if the curve needs to be reset. */
} DMUS_CURVE_FLAGS;


#define DMUS_CURVE_RESET    1        

/* Curve shapes */
enum
{ 
    DMUS_CURVES_LINEAR  = 0,
    DMUS_CURVES_INSTANT = 1,
    DMUS_CURVES_EXP     = 2,
    DMUS_CURVES_LOG     = 3,
    DMUS_CURVES_SINE    = 4
};
/* curve types */
#define DMUS_CURVET_PBCURVE      0x03
#define DMUS_CURVET_CCCURVE      0x04
#define DMUS_CURVET_MATCURVE     0x05
#define DMUS_CURVET_PATCURVE     0x06

/* DMUS_TIMESIG_PMSG */
typedef struct _DMUS_TIMESIG_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    /* Time signatures define how many beats per measure, which note receives */
    /* the beat, and the grid resolution. */
    BYTE    bBeatsPerMeasure;       /* beats per measure (top of time sig) */
    BYTE    bBeat;                  /* what note receives the beat (bottom of time sig.) */
                                    /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;          /* grids per beat */
} DMUS_TIMESIG_PMSG;

/* notification type values */
/* The following correspond to GUID_NOTIFICATION_SEGMENT */
#define DMUS_NOTIFICATION_SEGSTART      0
#define DMUS_NOTIFICATION_SEGEND        1
#define DMUS_NOTIFICATION_SEGALMOSTEND  2
#define DMUS_NOTIFICATION_SEGLOOP       3
#define DMUS_NOTIFICATION_SEGABORT      4
/* The following correspond to GUID_NOTIFICATION_PERFORMANCE */
#define DMUS_NOTIFICATION_MUSICSTARTED  0
#define DMUS_NOTIFICATION_MUSICSTOPPED  1
/* The following corresponds to GUID_NOTIFICATION_MEASUREANDBEAT */
#define DMUS_NOTIFICATION_MEASUREBEAT   0
/* The following corresponds to GUID_NOTIFICATION_CHORD */
#define DMUS_NOTIFICATION_CHORD         0
/* The following correspond to GUID_NOTIFICATION_COMMAND */
#define DMUS_NOTIFICATION_GROOVE        0
#define DMUS_NOTIFICATION_EMBELLISHMENT 1

/* DMUS_NOTIFICATION_PMSG */
typedef struct _DMUS_NOTIFICATION_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    GUID    guidNotificationType;
    DWORD   dwNotificationOption;
    DWORD   dwField1;
    DWORD   dwField2;
} DMUS_NOTIFICATION_PMSG;


#define DMUS_MAX_NAME           64         /* Maximum object name length. */
#define DMUS_MAX_CATEGORY       64         /* Maximum object category name length. */
#define DMUS_MAX_FILENAME       MAX_PATH
    
typedef struct _DMUS_VERSION {
  DWORD    dwVersionMS;
  DWORD    dwVersionLS;
}DMUS_VERSION, FAR *LPDMUS_VERSION;

/* Time Signature structure, used by IDirectMusicStyle */
/* Also used as a parameter for GetParam() and SetParam */
typedef struct _DMUS_TIMESIGNATURE
{
    MUSIC_TIME mtTime;
    BYTE    bBeatsPerMeasure;       /* beats per measure (top of time sig) */
    BYTE    bBeat;                  /* what note receives the beat (bottom of time sig.) */
                                    /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;          /* grids per beat */
} DMUS_TIMESIGNATURE;

/*      The DMUSOBJECTDESC structure is used to communicate everything you could */
/*      possibly use to describe a DirectMusic object.  */

typedef struct _DMUS_OBJECTDESC
{
    DWORD          dwSize;                 /* Size of this structure. */
    DWORD          dwValidData;            /* Flags indicating which fields below are valid. */
    GUID           guidObject;             /* Unique ID for this object. */
    GUID           guidClass;              /* GUID for the class of object. */
    FILETIME       ftDate;                 /* Last edited date of object. */
    DMUS_VERSION   vVersion;               /* Version. */
    WCHAR          wszName[DMUS_MAX_NAME]; /* Name of object. */
    WCHAR          wszCategory[DMUS_MAX_CATEGORY]; /* Category for object (optional). */
    WCHAR          wszFileName[DMUS_MAX_FILENAME]; /* File path. */
    LONGLONG       llMemLength;            /* Size of Memory data. */
    LPBYTE         pbMemData;              /* Memory pointer for data. */
} DMUS_OBJECTDESC;

typedef DMUS_OBJECTDESC *LPDMUS_OBJECTDESC;

/*      Flags for dwValidData. When set, a flag indicates that the  */
/*      corresponding field in DMUSOBJECTDESC holds valid data. */

#define DMUS_OBJ_OBJECT         (1 << 0)     /* Object GUID is valid. */
#define DMUS_OBJ_CLASS          (1 << 1)     /* Class GUID is valid. */
#define DMUS_OBJ_NAME           (1 << 2)     /* Name is valid. */
#define DMUS_OBJ_CATEGORY       (1 << 3)     /* Category is valid. */
#define DMUS_OBJ_FILENAME       (1 << 4)     /* File path is valid. */
#define DMUS_OBJ_FULLPATH       (1 << 5)     /* Path is full path. */
#define DMUS_OBJ_URL            (1 << 6)     /* Path is URL. */
#define DMUS_OBJ_VERSION        (1 << 7)     /* Version is valid. */
#define DMUS_OBJ_DATE           (1 << 8)     /* Date is valid. */
#define DMUS_OBJ_LOADED         (1 << 9)     /* Object is currently loaded in memory. */
#define DMUS_OBJ_MEMORY         (1 << 10)    /* Object is pointed to by pbMemData. */

typedef IDirectMusicObject __RPC_FAR *LPDMUS_OBJECT;
typedef IDirectMusicLoader __RPC_FAR *LPDMUS_LOADER;
typedef IDirectMusicBand __RPC_FAR *LPDMUS_BAND;


#define DMUSB_LOADED    (1 << 0)        /* Set when band has been loaded */
#define DMUSB_DEFAULT   (1 << 1)        /* Set when band is default band for a style */

#undef  INTERFACE
#define INTERFACE  IDirectMusicBand
DECLARE_INTERFACE_(IDirectMusicBand, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicBand */
    STDMETHOD(CreateSegment)        (THIS_ IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(Download)             (THIS_ IDirectMusicPerformance* pPerformance) PURE;     
    STDMETHOD(Unload)               (THIS_ IDirectMusicPerformance* pPerformance) PURE;     
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicObject
DECLARE_INTERFACE_(IDirectMusicObject, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicObject */
    STDMETHOD(GetDescriptor)        (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetDescriptor)        (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(ParseDescriptor)      (THIS_ LPSTREAM pStream, 
                                           LPDMUS_OBJECTDESC pDesc) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicLoader
DECLARE_INTERFACE_(IDirectMusicLoader, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicLoader */
    STDMETHOD(GetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc,
                                           REFIID riid,
                                           LPVOID FAR *ppv) PURE;
    STDMETHOD(SetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetSearchDirectory)   (THIS_ REFGUID rguidClass, 
                                           WCHAR *pwzPath, 
                                           BOOL fClear) PURE;
    STDMETHOD(ScanDirectory)        (THIS_ REFGUID rguidClass, 
                                           WCHAR *pwzFileExtension, 
                                           WCHAR *pwzScanFileName) PURE;
    STDMETHOD(CacheObject)          (THIS_ IDirectMusicObject * pObject) PURE;
    STDMETHOD(ReleaseObject)        (THIS_ IDirectMusicObject * pObject) PURE;
    STDMETHOD(ClearCache)           (THIS_ REFGUID rguidClass) PURE;
    STDMETHOD(EnableCache)          (THIS_ REFGUID rguidClass, 
                                           BOOL fEnable) PURE;
    STDMETHOD(EnumObject)           (THIS_ REFGUID rguidClass, 
                                           DWORD dwIndex, 
                                           LPDMUS_OBJECTDESC pDesc) PURE;
};                                  

/*  Stream object supports IDirectMusicGetLoader interface to access loader while file parsing. */

#undef  INTERFACE
#define INTERFACE  IDirectMusicGetLoader
DECLARE_INTERFACE_(IDirectMusicGetLoader, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicGetLoader */
    STDMETHOD(GetLoader)            (THIS_ IDirectMusicLoader ** ppLoader) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicSegment */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegment
DECLARE_INTERFACE_(IDirectMusicSegment, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegment */
    STDMETHOD(GetLength)                (THIS_ MUSIC_TIME* pmtLength) PURE;
    STDMETHOD(SetLength)                (THIS_ MUSIC_TIME mtLength) PURE;
    STDMETHOD(GetRepeats)               (THIS_ DWORD* pdwRepeats) PURE;
    STDMETHOD(SetRepeats)               (THIS_ DWORD  dwRepeats) PURE;
    STDMETHOD(GetDefaultResolution)     (THIS_ DWORD* pdwResolution) PURE;
    STDMETHOD(SetDefaultResolution)     (THIS_ DWORD  dwResolution) PURE;
    STDMETHOD(GetTrack)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               IDirectMusicTrack** ppTrack) PURE;
    STDMETHOD(GetTrackGroup)            (THIS_ IDirectMusicTrack* pTrack, 
                                               DWORD* pdwGroupBits) PURE;
    STDMETHOD(InsertTrack)              (THIS_ IDirectMusicTrack* pTrack, 
                                               DWORD dwGroupBits) PURE;
    STDMETHOD(RemoveTrack)              (THIS_ IDirectMusicTrack* pTrack) PURE;
    STDMETHOD(InitPlay)                 (THIS_ IDirectMusicSegmentState** ppSegState, 
                                               IDirectMusicPerformance* pPerformance,
                                               DWORD dwFlags) PURE;
    STDMETHOD(GetGraph)                 (THIS_ IDirectMusicGraph** ppGraph) PURE;
    STDMETHOD(SetGraph)                 (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(AddNotificationType)      (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)   (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(GetParam)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               MUSIC_TIME mtTime, 
                                               MUSIC_TIME* pmtNext, 
                                               void* pParam) PURE; 
    STDMETHOD(SetParam)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               MUSIC_TIME mtTime, 
                                               void* pParam) PURE;
    STDMETHOD(Clone)                    (THIS_ MUSIC_TIME mtStart, 
                                               MUSIC_TIME mtEnd, 
                                               IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(SetStartPoint)            (THIS_ MUSIC_TIME mtStart) PURE;
    STDMETHOD(GetStartPoint)            (THIS_ MUSIC_TIME* pmtStart) PURE;
    STDMETHOD(SetLoopPoints)            (THIS_ MUSIC_TIME mtStart, 
                                               MUSIC_TIME mtEnd) PURE;
    STDMETHOD(GetLoopPoints)            (THIS_ MUSIC_TIME* pmtStart, 
                                               MUSIC_TIME* pmtEnd) PURE;
    STDMETHOD(SetPChannelsUsed)         (THIS_ DWORD dwNumPChannels, 
                                               DWORD* paPChannels) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegmentState
DECLARE_INTERFACE_(IDirectMusicSegmentState, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegmentState */
    STDMETHOD(GetRepeats)           (THIS_ DWORD* pdwRepeats) PURE;
    STDMETHOD(GetSegment )          (THIS_ IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetStartTime)         (THIS_ MUSIC_TIME* pmtStart) PURE;
    STDMETHOD(GetSeek)              (THIS_ MUSIC_TIME* pmtSeek) PURE;
    STDMETHOD(GetStartPoint)        (THIS_ MUSIC_TIME* pmtStart) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTrack */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTrack
DECLARE_INTERFACE_(IDirectMusicTrack, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)         (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)          (THIS) PURE;
    STDMETHOD_(ULONG,Release)         (THIS) PURE;

    /*  IDirectMusicTrack */
    STDMETHOD(Init)                   (THIS_ IDirectMusicSegment* pSegment) PURE;
    STDMETHOD(InitPlay)               (THIS_ IDirectMusicSegmentState* pSegmentState, 
                                             IDirectMusicPerformance* pPerformance, 
                                             void** ppStateData, 
                                             DWORD dwVirtualTrackID,
                                             DWORD dwFlags) PURE;
    STDMETHOD(EndPlay)                (THIS_ void* pStateData) PURE;
    STDMETHOD(Play)                   (THIS_ void* pStateData, 
                                             MUSIC_TIME mtStart, 
                                             MUSIC_TIME mtEnd, 
                                             MUSIC_TIME mtOffset, 
                                             DWORD dwFlags, 
                                             IDirectMusicPerformance* pPerf, 
                                             IDirectMusicSegmentState* pSegSt, 
                                             DWORD dwVirtualID) PURE;
    STDMETHOD(GetParam)               (THIS_ REFGUID rguidType, 
                                             MUSIC_TIME mtTime, 
                                             MUSIC_TIME* pmtNext, 
                                             void* pParam) PURE; 
    STDMETHOD(SetParam)               (THIS_ REFGUID rguidType, 
                                             MUSIC_TIME mtTime, 
                                             void* pParam) PURE;
    STDMETHOD(IsParamSupported)       (THIS_ REFGUID rguidType) PURE;
    STDMETHOD(AddNotificationType)    (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType) (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(Clone)                  (THIS_ MUSIC_TIME mtStart, 
                                             MUSIC_TIME mtEnd, 
                                             IDirectMusicTrack** ppTrack) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicPerformance */
#undef  INTERFACE
#define INTERFACE  IDirectMusicPerformance
DECLARE_INTERFACE_(IDirectMusicPerformance, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicPerformance */
    STDMETHOD(Init)                 (THIS_ IDirectMusic** ppDirectMusic,
                                           LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
    STDMETHOD(PlaySegment)          (THIS_ IDirectMusicSegment* pSegment, 
                                           DWORD dwFlags, 
                                           __int64 i64StartTime, 
                                           IDirectMusicSegmentState** ppSegmentState) PURE;
    STDMETHOD(Stop)                 (THIS_ IDirectMusicSegment* pSegment, 
                                           IDirectMusicSegmentState* pSegmentState, 
                                           MUSIC_TIME mtTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(GetSegmentState)      (THIS_ IDirectMusicSegmentState** ppSegmentState, 
                                           MUSIC_TIME mtTime) PURE;
    STDMETHOD(SetPrepareTime)       (THIS_ DWORD dwMilliSeconds) PURE;
    STDMETHOD(GetPrepareTime)       (THIS_ DWORD* pdwMilliSeconds) PURE;
    STDMETHOD(SetBumperLength)      (THIS_ DWORD dwMilliSeconds) PURE;
    STDMETHOD(GetBumperLength)      (THIS_ DWORD* pdwMilliSeconds) PURE;
    STDMETHOD(SendPMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(MusicToReferenceTime) (THIS_ MUSIC_TIME mtTime, 
                                           REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(ReferenceToMusicTime) (THIS_ REFERENCE_TIME rtTime, 
                                           MUSIC_TIME* pmtTime) PURE;
    STDMETHOD(IsPlaying)            (THIS_ IDirectMusicSegment* pSegment, 
                                           IDirectMusicSegmentState* pSegState) PURE;
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME* prtNow, 
                                           MUSIC_TIME* pmtNow) PURE;
    STDMETHOD(AllocPMsg)            (THIS_ ULONG cb, 
                                           DMUS_PMSG** ppPMSG) PURE;
    STDMETHOD(FreePMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(GetGraph)             (THIS_ IDirectMusicGraph** ppGraph) PURE;
    STDMETHOD(SetGraph)             (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hNotification, 
                                           REFERENCE_TIME rtMinimum) PURE;
    STDMETHOD(GetNotificationPMsg)  (THIS_ DMUS_NOTIFICATION_PMSG** ppNotificationPMsg) PURE;
    STDMETHOD(AddNotificationType)  (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)(THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(AddPort)              (THIS_ IDirectMusicPort* pPort) PURE;
    STDMETHOD(RemovePort)           (THIS_ IDirectMusicPort* pPort ) PURE;
    STDMETHOD(AssignPChannelBlock)  (THIS_ DWORD dwBlockNum, 
                                           IDirectMusicPort* pPort, 
                                           DWORD dwGroup ) PURE;
    STDMETHOD(AssignPChannel)       (THIS_ DWORD dwPChannel, 
                                           IDirectMusicPort* pPort, 
                                           DWORD dwGroup, 
                                           DWORD dwMChannel ) PURE;
    STDMETHOD(PChannelInfo)         (THIS_ DWORD dwPChannel, 
                                           IDirectMusicPort** ppPort, 
                                           DWORD* pdwGroup, 
                                           DWORD* pdwMChannel ) PURE;
    STDMETHOD(DownloadInstrument)   (THIS_ IDirectMusicInstrument* pInst, 
                                           DWORD dwPChannel, 
                                           IDirectMusicDownloadedInstrument** ppDownInst, 
                                           DMUS_NOTERANGE* pNoteRanges, 
                                           DWORD dwNumNoteRanges, 
                                           IDirectMusicPort** ppPort, 
                                           DWORD* pdwGroup, 
                                           DWORD* pdwMChannel ) PURE;
    STDMETHOD(Invalidate)           (THIS_ MUSIC_TIME mtTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(GetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           MUSIC_TIME* pmtNext, 
                                           void* pParam) PURE; 
    STDMETHOD(SetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           void* pParam) PURE;
    STDMETHOD(GetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(SetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(GetLatencyTime)       (THIS_ REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(GetQueueTime)         (THIS_ REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(AdjustTime)           (THIS_ REFERENCE_TIME rtAmount) PURE;
    STDMETHOD(CloseDown)            (THIS) PURE;
    STDMETHOD(GetResolvedTime)      (THIS_ REFERENCE_TIME rtTime,
                                           REFERENCE_TIME* prtResolved,
                                           DWORD dwTimeResolveFlags) PURE;
    STDMETHOD(MIDIToMusic)          (THIS_ BYTE bMIDIValue,
                                           DMUS_CHORD_KEY* pChord,
                                           BYTE bPlayMode,
                                           BYTE bChordLevel,
                                           WORD *pwMusicValue) PURE;
    STDMETHOD(MusicToMIDI)          (THIS_ WORD wMusicValue,
                                           DMUS_CHORD_KEY* pChord,
                                           BYTE bPlayMode,
                                           BYTE bChordLevel,
                                           BYTE *pbMIDIValue) PURE;
    STDMETHOD(TimeToRhythm)         (THIS_ MUSIC_TIME mtTime,
                                           DMUS_TIMESIGNATURE *pTimeSig,
                                           WORD *pwMeasure,
                                           BYTE *pbBeat,
                                           BYTE *pbGrid,
                                           short *pnOffset) PURE;
    STDMETHOD(RhythmToTime)         (THIS_ WORD wMeasure,
                                           BYTE bBeat,
                                           BYTE bGrid,
                                           short nOffset,
                                           DMUS_TIMESIGNATURE *pTimeSig,
                                           MUSIC_TIME *pmtTime) PURE;                                        
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTool */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTool
DECLARE_INTERFACE_(IDirectMusicTool, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicTool */
    STDMETHOD(Init)                 (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(GetMsgDeliveryType)   (THIS_ DWORD* pdwDeliveryType ) PURE;
    STDMETHOD(GetMediaTypeArraySize)(THIS_ DWORD* pdwNumElements ) PURE;
    STDMETHOD(GetMediaTypes)        (THIS_ DWORD** padwMediaTypes, 
                                           DWORD dwNumElements) PURE;
    STDMETHOD(ProcessPMsg)          (THIS_ IDirectMusicPerformance* pPerf, 
                                           DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(Flush)                (THIS_ IDirectMusicPerformance* pPerf, 
                                           DMUS_PMSG* pPMSG, 
                                           REFERENCE_TIME rtTime) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicGraph */
#undef  INTERFACE
#define INTERFACE  IDirectMusicGraph
DECLARE_INTERFACE_(IDirectMusicGraph, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicGraph */
    STDMETHOD(StampPMsg)            (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(InsertTool)           (THIS_ IDirectMusicTool* pTool, 
                                           DWORD* pdwPChannels, 
                                           DWORD cPChannels, 
                                           LONG lIndex) PURE;
    STDMETHOD(GetTool)              (THIS_ DWORD dwIndex, 
                                           IDirectMusicTool** ppTool) PURE;
    STDMETHOD(RemoveTool)           (THIS_ IDirectMusicTool* pTool) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicStyle */
#undef  INTERFACE
#define INTERFACE  IDirectMusicStyle
DECLARE_INTERFACE_(IDirectMusicStyle, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)         (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)          (THIS) PURE;
    STDMETHOD_(ULONG,Release)         (THIS) PURE;

    /*  IDirectMusicStyle */
    STDMETHOD(GetBand)                (THIS_ WCHAR* pwszName, 
                                             IDirectMusicBand** ppBand) PURE;
    STDMETHOD(EnumBand)               (THIS_ DWORD dwIndex, 
                                             WCHAR *pwszName) PURE;
    STDMETHOD(GetDefaultBand)         (THIS_ IDirectMusicBand** ppBand) PURE;
    STDMETHOD(EnumMotif)              (THIS_ DWORD dwIndex, 
                                             WCHAR* pwszName) PURE;
    STDMETHOD(GetMotif)               (THIS_ WCHAR* pwszName, 
                                             IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetDefaultChordMap)     (THIS_ IDirectMusicChordMap** ppChordMap) PURE;
    STDMETHOD(EnumChordMap)           (THIS_ DWORD dwIndex, 
                                             WCHAR *pwszName) PURE;
    STDMETHOD(GetChordMap)            (THIS_ WCHAR* pwszName, 
                                             IDirectMusicChordMap** ppChordMap) PURE;
    STDMETHOD(GetTimeSignature)       (THIS_ DMUS_TIMESIGNATURE* pTimeSig) PURE;
    STDMETHOD(GetEmbellishmentLength) (THIS_ DWORD dwType, 
                                             DWORD dwLevel, 
                                             DWORD* pdwMin, 
                                             DWORD* pdwMax) PURE;
    STDMETHOD(GetTempo)               (THIS_ double* pTempo) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicChordMap */
#undef  INTERFACE
#define INTERFACE  IDirectMusicChordMap
DECLARE_INTERFACE_(IDirectMusicChordMap, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicChordMap */
    STDMETHOD(GetScale)             (THIS_ DWORD* pdwScale) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicComposer */
#undef  INTERFACE
#define INTERFACE  IDirectMusicComposer
DECLARE_INTERFACE_(IDirectMusicComposer, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicComposer */
    STDMETHOD(ComposeSegmentFromTemplate)   (THIS_ IDirectMusicStyle* pStyle, 
                                                   IDirectMusicSegment* pTemplate, 
                                                   WORD wActivity, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(ComposeSegmentFromShape)      (THIS_ IDirectMusicStyle* pStyle, 
                                                   WORD wNumMeasures, 
                                                   WORD wShape, 
                                                   WORD wActivity, 
                                                   BOOL fIntro, 
                                                   BOOL fEnd, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppSegment ) PURE;
    STDMETHOD(ComposeTransition)            (THIS_ IDirectMusicSegment* pFromSeg, 
                                                   IDirectMusicSegment* pToSeg, 
                                                   MUSIC_TIME mtTime, 
                                                   WORD wCommand, 
                                                   DWORD dwFlags, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppTransSeg) PURE;
    STDMETHOD(AutoTransition)               (THIS_ IDirectMusicPerformance* pPerformance, 
                                                   IDirectMusicSegment* pToSeg, 
                                                   WORD wCommand, 
                                                   DWORD dwFlags, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppTransSeg, 
                                                   IDirectMusicSegmentState** ppToSegState, 
                                                   IDirectMusicSegmentState** ppTransSegState) PURE;
    STDMETHOD(ComposeTemplateFromShape)     (THIS_ WORD wNumMeasures, 
                                                   WORD wShape, 
                                                   BOOL fIntro, 
                                                   BOOL fEnd, 
                                                   WORD wEndLength, 
                                                   IDirectMusicSegment** ppTemplate) PURE;
    STDMETHOD(ChangeChordMap)            (THIS_ IDirectMusicSegment* pSegment, 
                                                   BOOL fTrackScale, 
                                                   IDirectMusicChordMap* pChordMap) PURE;
};

/* CLSID's */
DEFINE_GUID(CLSID_DirectMusicPerformance,0xd2ac2881, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSegment,0xd2ac2882, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSegmentState,0xd2ac2883, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicGraph,0xd2ac2884, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTempoTrack,0xd2ac2885, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSeqTrack,0xd2ac2886, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSysExTrack,0xd2ac2887, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTimeSigTrack,0xd2ac2888, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyle,0xd2ac288a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordTrack,0xd2ac288b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicCommandTrack,0xd2ac288c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyleTrack,0xd2ac288d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMotifTrack,0xd2ac288e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMap,0xd2ac288f, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicComposer,0xd2ac2890, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSignPostTrack,0xf17e8672, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicLoader,0xd2ac2892, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBandTrack,0xd2ac2894, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBand,0x79ba9e00, 0xb6ee, 0x11d1, 0x86, 0xbe, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(CLSID_DirectMusicChordMapTrack,0xd2ac2896, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMuteTrack,0xd2ac2898, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Special GUID for all object types. This is used by the loader. */
DEFINE_GUID(GUID_DirectMusicAllTypes,0xd2ac2893, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Notification guids */
DEFINE_GUID(GUID_NOTIFICATION_SEGMENT,0xd2ac2899, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_PERFORMANCE,0x81f75bc5, 0x4e5d, 0x11d2, 0xbc, 0xc7, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_NOTIFICATION_MEASUREANDBEAT,0xd2ac289a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_CHORD,0xd2ac289b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_COMMAND,0xd2ac289c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Track param type guids */
/* Use to get/set a DMUS_COMMAND_PARAM param in the Command track */
DEFINE_GUID(GUID_CommandParam,0xd2ac289d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_COMMAND_PARAM_2 param in the Command track */
DEFINE_GUID(GUID_CommandParam2, 0x28f97ef7, 0x9538, 0x11d2, 0x97, 0xa9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Use to get/set a DMUS_CHORD_PARAM param in the Chord track */
DEFINE_GUID(GUID_ChordParam,0xd2ac289e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_RHYTHM_PARAM param in the Chord track */
DEFINE_GUID(GUID_RhythmParam,0xd2ac289f, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set an IDirectMusicStyle param in the Style track */
DEFINE_GUID(GUID_IDirectMusicStyle,0xd2ac28a1, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_TIMESIGNATURE param in the Style and TimeSig tracks */
DEFINE_GUID(GUID_TimeSignature,0xd2ac28a4, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set a DMUS_TEMPO_PARAM param in the Tempo track */
DEFINE_GUID(GUID_TempoParam,0xd2ac28a5, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to set an IDirectMusicBand param in the Band track */
DEFINE_GUID(GUID_IDirectMusicBand,0xd2ac28ac, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set an IDirectMusicChordMap param in the ChordMap track */
DEFINE_GUID(GUID_IDirectMusicChordMap,0xd2ac28ad, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set a DMUS_MUTE_PARAM param in the Mute track */
DEFINE_GUID(GUID_MuteParam,0xd2ac28af, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* These guids are used in IDirectMusicSegment::SetParam to tell the band track to perform various actions.
 */
/* Download bands for the IDirectMusicSegment */
DEFINE_GUID(GUID_Download,0xd2ac28a7, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Unload bands for the IDirectMusicSegment */
DEFINE_GUID(GUID_Unload,0xd2ac28a8, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Connect segment's bands to an IDirectMusicCollection */
DEFINE_GUID(GUID_ConnectToDLSCollection, 0x1db1ae6b, 0xe92e, 0x11d1, 0xa8, 0xc5, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);

/* Enable/disable autodownloading of bands */
DEFINE_GUID(GUID_Enable_Auto_Download,0xd2ac28a9, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_Disable_Auto_Download,0xd2ac28aa, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Clear all bands */
DEFINE_GUID(GUID_Clear_All_Bands,0xd2ac28ab, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Set segment to manage all program changes, bank selects, etc. for simple playback of a standard MIDI file */
DEFINE_GUID(GUID_StandardMIDIFile, 0x6621075, 0xe92e, 0x11d1, 0xa8, 0xc5, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);
/* For compatibility with beta releases... */
#define GUID_IgnoreBankSelectForGM 	GUID_StandardMIDIFile

/* Disable/enable param guids. Use these in SetParam calls to disable or enable sending
 * specific PMsg types.
 */
DEFINE_GUID(GUID_DisableTimeSig, 0x45fc707b, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_EnableTimeSig, 0x45fc707c, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_DisableTempo, 0x45fc707d, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_EnableTempo, 0x45fc707e, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);

/* Used in SetParam calls for pattern-based tracks.  A nonzero value seeds the random number 
generator for variation selection; a value of zero reverts to the default behavior of 
getting the seed from the system clock.
*/
DEFINE_GUID(GUID_SeedVariations, 0x65b76fa5, 0xff37, 0x11d2, 0x81, 0x4e, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Global data guids */
DEFINE_GUID(GUID_PerfMasterTempo,0xd2ac28b0, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfMasterVolume,0xd2ac28b1, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfMasterGrooveLevel,0xd2ac28b2, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfAutoDownload, 0xfb09565b, 0x3631, 0x11d2, 0xbc, 0xb8, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);

/* GUID for default GM/GS dls collection. */
DEFINE_GUID(GUID_DefaultGMCollection, 0xf17e8673, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* IID's */
DEFINE_GUID(IID_IDirectMusicLoader, 0x2ffaaca2, 0x5dca, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicGetLoader,0x68a04844, 0xd13d, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicObject,0xd2ac28b5, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicSegment, 0xf96029a2, 0x4282, 0x11d2, 0x87, 0x17, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicSegmentState, 0xa3afdcc7, 0xd3ee, 0x11d1, 0xbc, 0x8d, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(IID_IDirectMusicTrack, 0xf96029a1, 0x4282, 0x11d2, 0x87, 0x17, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicPerformance,0x7d43d03, 0x6523, 0x11d2, 0x87, 0x1d, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicTool,0xd2ac28ba, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicGraph,0x2befc277, 0x5497, 0x11d2, 0xbc, 0xcb, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(IID_IDirectMusicStyle,0xd2ac28bd, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicChordMap,0xd2ac28be, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicComposer,0xd2ac28bf, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicBand,0xd2ac28c0, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Alternate interface IDs, available in DX7 release and after. */
DEFINE_GUID(IID_IDirectMusicPerformance2,0x6fc2cae0, 0xbc78, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicSegment2, 0xd38894d1, 0xc052, 0x11d2, 0x87, 0x2f, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICI_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\inc\dmusicc.h ===
/************************************************************************
*                                                                       *
*   dmusicc.h -- This module defines the DirectMusic core API's         *
*                                                                       *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.            *
*                                                                       *
************************************************************************/

#ifndef _DMUSICC_
#define _DMUSICC_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>

#include "dls1.h"
#include "dmerror.h"
#include "dmdls.h"
#include "dsound.h"
#include "dmusbuff.h"

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

#define DMUS_MAX_DESCRIPTION 128
#define DMUS_MAX_DRIVER 128

typedef struct _DMUS_BUFFERDESC *LPDMUS_BUFFERDESC;
typedef struct _DMUS_BUFFERDESC{
    DWORD dwSize;
    DWORD dwFlags;
    GUID guidBufferFormat;
    DWORD cbBuffer;
} DMUS_BUFFERDESC;

/* DMUS_EFFECT_ flags are used in the dwEffectFlags fields of both DMUS_PORTCAPS 
 * and DMUS_PORTPARAMS.
 */
#define DMUS_EFFECT_NONE             0x00000000
#define DMUS_EFFECT_REVERB           0x00000001
#define DMUS_EFFECT_CHORUS           0x00000002

/* For DMUS_PORTCAPS dwClass
 */ 
#define DMUS_PC_INPUTCLASS       (0)
#define DMUS_PC_OUTPUTCLASS      (1)

/* For DMUS_PORTCAPS dwFlags
 */
#define DMUS_PC_DLS              (0x00000001)
#define DMUS_PC_EXTERNAL         (0x00000002)
#define DMUS_PC_SOFTWARESYNTH    (0x00000004)
#define DMUS_PC_MEMORYSIZEFIXED  (0x00000008)
#define DMUS_PC_GMINHARDWARE     (0x00000010)
#define DMUS_PC_GSINHARDWARE     (0x00000020)
#define DMUS_PC_XGINHARDWARE     (0x00000040)
#define DMUS_PC_DIRECTSOUND      (0x00000080)
#define DMUS_PC_SHAREABLE        (0x00000100)
#define DMUS_PC_DLS2             (0x00000200)
#define DMUS_PC_SYSTEMMEMORY     (0x7FFFFFFF)


typedef struct _DMUS_PORTCAPS *LPDMUS_PORTCAPS;
typedef struct _DMUS_PORTCAPS
{
    DWORD   dwSize;
    DWORD   dwFlags;
    GUID    guidPort;
    DWORD   dwClass;
    DWORD   dwType;
    DWORD   dwMemorySize;
    DWORD   dwMaxChannelGroups;
    DWORD   dwMaxVoices;    
    DWORD   dwMaxAudioChannels;
    DWORD   dwEffectFlags;
    WCHAR   wszDescription[DMUS_MAX_DESCRIPTION];
} DMUS_PORTCAPS;

/* Values for DMUS_PORTCAPS dwType. This field indicates the underlying 
 * driver type of the port.
 */
#define DMUS_PORT_WINMM_DRIVER      (0)
#define DMUS_PORT_USER_MODE_SYNTH   (1)
#define DMUS_PORT_KERNEL_MODE       (2)

/* These flags (set in dwValidParams) indicate which other members of the */
/* DMUS_PORTPARAMS are valid. */
/* */
#define DMUS_PORTPARAMS_VOICES           0x00000001
#define DMUS_PORTPARAMS_CHANNELGROUPS    0x00000002
#define DMUS_PORTPARAMS_AUDIOCHANNELS    0x00000004
#define DMUS_PORTPARAMS_SAMPLERATE       0x00000008
#define DMUS_PORTPARAMS_EFFECTS          0x00000020
#define DMUS_PORTPARAMS_SHARE            0x00000040

typedef struct _DMUS_PORTPARAMS *LPDMUS_PORTPARAMS;
typedef struct _DMUS_PORTPARAMS
{
    DWORD   dwSize;
    DWORD   dwValidParams;
    DWORD   dwVoices;
    DWORD   dwChannelGroups;
    DWORD   dwAudioChannels;
    DWORD   dwSampleRate;
    DWORD   dwEffectFlags;
    BOOL    fShare;
} DMUS_PORTPARAMS;

typedef struct _DMUS_SYNTHSTATS *LPDMUS_SYNTHSTATS;
typedef struct _DMUS_SYNTHSTATS
{
    DWORD   dwSize;             /* Size in bytes of the structure */
    DWORD   dwValidStats;       /* Flags indicating which fields below are valid. */
    DWORD   dwVoices;           /* Average number of voices playing. */
    DWORD   dwTotalCPU;         /* Total CPU usage as percent * 100. */
    DWORD   dwCPUPerVoice;      /* CPU per voice as percent * 100. */
    DWORD   dwLostNotes;        /* Number of notes lost in 1 second. */
    DWORD   dwFreeMemory;       /* Free memory in bytes */
    long    lPeakVolume;        /* Decibel level * 100. */
} DMUS_SYNTHSTATS;

#define DMUS_SYNTHSTATS_VOICES          (1 << 0)
#define DMUS_SYNTHSTATS_TOTAL_CPU       (1 << 1)
#define DMUS_SYNTHSTATS_CPU_PER_VOICE   (1 << 2)
#define DMUS_SYNTHSTATS_LOST_NOTES      (1 << 3)
#define DMUS_SYNTHSTATS_PEAK_VOLUME     (1 << 4)
#define DMUS_SYNTHSTATS_FREE_MEMORY     (1 << 5)

#define DMUS_SYNTHSTATS_SYSTEMMEMORY    DMUS_PC_SYSTEMMEMORY

typedef struct _DMUS_WAVES_REVERB_PARAMS
{
    float   fInGain;        /* Input gain in dB (to avoid output overflows) */
    float   fReverbMix;     /* Reverb mix in dB. 0dB means 100% wet reverb (no direct signal)
                            Negative values gives less wet signal.
                            The coeficients are calculated so that the overall output level stays 
                            (approximately) constant regardless of the ammount of reverb mix. */
    float   fReverbTime;    /* The reverb decay time, in milliseconds. */
    float   fHighFreqRTRatio; /* The ratio of the high frequencies to the global reverb time. 
                            Unless very 'splashy-bright' reverbs are wanted, this should be set to 
                            a value < 1.0.
                            For example if dRevTime==1000ms and dHighFreqRTRatio=0.1 than the 
                            decay time for high frequencies will be 100ms.*/

} DMUS_WAVES_REVERB_PARAMS;

/*  Note: Default values for Reverb are:
    fInGain             = 0.0dB   (no change in level)
    fReverbMix          = -10.0dB   (a reasonable reverb mix)
    fReverbTime         = 1000.0ms (one second global reverb time)
    fHighFreqRTRatio    = 0.001    (the ratio of the high frequencies to the global reverb time) 
*/

typedef enum
{
    DMUS_CLOCK_SYSTEM = 0,
    DMUS_CLOCK_WAVE = 1
} DMUS_CLOCKTYPE;

typedef struct _DMUS_CLOCKINFO *LPDMUS_CLOCKINFO;
typedef struct _DMUS_CLOCKINFO
{
    DWORD           dwSize;
    DMUS_CLOCKTYPE  ctType;
    GUID            guidClock;          /* Identifies this time source */
    WCHAR           wszDescription[DMUS_MAX_DESCRIPTION];
} DMUS_CLOCKINFO;

interface IDirectMusic;
interface IDirectMusicBuffer;
interface IDirectMusicPort;
interface IDirectMusicThru;
interface IReferenceClock;

#ifndef __cplusplus 
typedef interface IDirectMusic IDirectMusic;
typedef interface IDirectMusicBuffer IDirectMusicBuffer;
typedef interface IDirectMusicPort IDirectMusicPort;
typedef interface IDirectMusicThru IDirectMusicThru;
typedef interface IReferenceClock IReferenceClock;
#endif

typedef IDirectMusic *LPDIRECTMUSIC;
typedef IDirectMusicBuffer *LPDIRECTMUSICBUFFER;
typedef IDirectMusicPort *LPDIRECTMUSICPORT;

#undef  INTERFACE
#define INTERFACE  IDirectMusic
DECLARE_INTERFACE_(IDirectMusic, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusic */
    STDMETHOD(EnumPort)             (THIS_ DWORD dwIndex, 
                                           LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(CreateMusicBuffer)    (THIS_ LPDMUS_BUFFERDESC pBufferDesc, 
                                           LPDIRECTMUSICBUFFER *ppBuffer, 
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(CreatePort)           (THIS_ REFCLSID rclsidPort, 
                                           LPDMUS_PORTPARAMS pPortParams, 
                                           LPDIRECTMUSICPORT *ppPort, 
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(EnumMasterClock)      (THIS_ DWORD dwIndex, 
                                           LPDMUS_CLOCKINFO lpClockInfo) PURE;
    STDMETHOD(GetMasterClock)       (THIS_ LPGUID pguidClock, 
                                           IReferenceClock **ppReferenceClock) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ REFGUID rguidClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(GetDefaultPort)       (THIS_ LPGUID pguidPort) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
    
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicBuffer
DECLARE_INTERFACE_(IDirectMusicBuffer, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicBuffer */
    STDMETHOD(Flush)                (THIS) PURE;
    STDMETHOD(TotalTime)            (THIS_ LPREFERENCE_TIME prtTime) PURE;
    
    STDMETHOD(PackStructured)       (THIS_ REFERENCE_TIME rt,
                                           DWORD dwChannelGroup,
                                           DWORD dwChannelMessage) PURE;
    
    STDMETHOD(PackUnstructured)     (THIS_ REFERENCE_TIME rt,
                                           DWORD dwChannelGroup,
                                           DWORD cb,
                                           LPBYTE lpb) PURE;
    
    STDMETHOD(ResetReadPtr)         (THIS) PURE;
    STDMETHOD(GetNextEvent)         (THIS_ LPREFERENCE_TIME prt,
                                           LPDWORD pdwChannelGroup,
                                           LPDWORD pdwLength,
                                           LPBYTE *ppData) PURE;

    STDMETHOD(GetRawBufferPtr)      (THIS_ LPBYTE *ppData) PURE;
    STDMETHOD(GetStartTime)         (THIS_ LPREFERENCE_TIME prt) PURE;
    STDMETHOD(GetUsedBytes)         (THIS_ LPDWORD pcb) PURE;
    STDMETHOD(GetMaxBytes)          (THIS_ LPDWORD pcb) PURE;
    STDMETHOD(GetBufferFormat)      (THIS_ LPGUID pGuidFormat) PURE;

    STDMETHOD(SetStartTime)         (THIS_ REFERENCE_TIME rt) PURE;
    STDMETHOD(SetUsedBytes)         (THIS_ DWORD cb) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicInstrument
DECLARE_INTERFACE_(IDirectMusicInstrument, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicInstrument */
    STDMETHOD(GetPatch)                 (THIS_ DWORD* pdwPatch) PURE;
    STDMETHOD(SetPatch)                 (THIS_ DWORD dwPatch) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownloadedInstrument
DECLARE_INTERFACE_(IDirectMusicDownloadedInstrument, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicDownloadedInstrument */
    /* None at this time */
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicCollection
DECLARE_INTERFACE_(IDirectMusicCollection, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicCollection */
    STDMETHOD(GetInstrument)            (THIS_ DWORD dwPatch, 
                                               IDirectMusicInstrument** ppInstrument) PURE;
    STDMETHOD(EnumInstrument)           (THIS_ DWORD dwIndex, 
                                               DWORD* pdwPatch, 
                                               LPWSTR pwszName, 
                                               DWORD dwNameLen) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownload 
DECLARE_INTERFACE_(IDirectMusicDownload , IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicDownload */
    STDMETHOD(GetBuffer)            (THIS_ void** ppvBuffer, 
                                           DWORD* pdwSize) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicPortDownload
DECLARE_INTERFACE_(IDirectMusicPortDownload, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicPortDownload */
    STDMETHOD(GetBuffer)            (THIS_ DWORD dwDLId, 
                                           IDirectMusicDownload** ppIDMDownload) PURE;
    STDMETHOD(AllocateBuffer)       (THIS_ DWORD dwSize, 
                                           IDirectMusicDownload** ppIDMDownload) PURE;
    STDMETHOD(GetDLId)              (THIS_ DWORD* pdwStartDLId, 
                                           DWORD dwCount) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;
    STDMETHOD(Download)             (THIS_ IDirectMusicDownload* pIDMDownload) PURE;
    STDMETHOD(Unload)               (THIS_ IDirectMusicDownload* pIDMDownload) PURE;
};

/* Standard values for voice priorities. Numerically higher priorities are higher in priority.
 * These priorities are used to set the voice priority for all voices on a channel. They are
 * used in the dwPriority parameter of IDirectMusicPort::GetPriority and returned in the
 * lpwPriority parameter of pdwPriority.
 *
 * These priorities are shared with DirectSound.
 */

#ifndef _DIRECTAUDIO_PRIORITIES_DEFINED_
#define _DIRECTAUDIO_PRIORITIES_DEFINED_

#define DAUD_CRITICAL_VOICE_PRIORITY    (0xF0000000)
#define DAUD_HIGH_VOICE_PRIORITY        (0xC0000000)
#define DAUD_STANDARD_VOICE_PRIORITY    (0x80000000)
#define DAUD_LOW_VOICE_PRIORITY         (0x40000000)
#define DAUD_PERSIST_VOICE_PRIORITY     (0x10000000) 

/* These are the default priorities assigned if not overridden. By default priorities are
 * equal across channel groups (e.g. channel 5 on channel group 1 has the same priority as
 * channel 5 on channel group 2).
 *
 * In accordance with DLS level 1, channel 10 has the highest priority, followed by 1 through 16
 * except for 10.
 */
#define DAUD_CHAN1_VOICE_PRIORITY_OFFSET    (0x0000000E)
#define DAUD_CHAN2_VOICE_PRIORITY_OFFSET    (0x0000000D)
#define DAUD_CHAN3_VOICE_PRIORITY_OFFSET    (0x0000000C)
#define DAUD_CHAN4_VOICE_PRIORITY_OFFSET    (0x0000000B)
#define DAUD_CHAN5_VOICE_PRIORITY_OFFSET    (0x0000000A)
#define DAUD_CHAN6_VOICE_PRIORITY_OFFSET    (0x00000009)
#define DAUD_CHAN7_VOICE_PRIORITY_OFFSET    (0x00000008)
#define DAUD_CHAN8_VOICE_PRIORITY_OFFSET    (0x00000007)
#define DAUD_CHAN9_VOICE_PRIORITY_OFFSET    (0x00000006)
#define DAUD_CHAN10_VOICE_PRIORITY_OFFSET   (0x0000000F)
#define DAUD_CHAN11_VOICE_PRIORITY_OFFSET   (0x00000005)
#define DAUD_CHAN12_VOICE_PRIORITY_OFFSET   (0x00000004)
#define DAUD_CHAN13_VOICE_PRIORITY_OFFSET   (0x00000003)
#define DAUD_CHAN14_VOICE_PRIORITY_OFFSET   (0x00000002)
#define DAUD_CHAN15_VOICE_PRIORITY_OFFSET   (0x00000001)
#define DAUD_CHAN16_VOICE_PRIORITY_OFFSET   (0x00000000)
 
 
#define DAUD_CHAN1_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN1_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN2_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN2_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN3_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN3_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN4_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN4_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN5_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN5_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN6_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN6_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN7_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN7_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN8_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN8_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN9_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN9_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN10_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN10_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN11_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN11_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN12_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN12_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN13_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN13_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN14_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN14_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN15_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN15_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN16_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN16_VOICE_PRIORITY_OFFSET)

#endif  /* _DIRECTAUDIO_PRIORITIES_DEFINED_ */


#undef  INTERFACE
#define INTERFACE  IDirectMusicPort
DECLARE_INTERFACE_(IDirectMusicPort, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicPort */
    /*  */
    STDMETHOD(PlayBuffer)           (THIS_ LPDIRECTMUSICBUFFER pBuffer) PURE;
    STDMETHOD(SetReadNotificationHandle) (THIS_ HANDLE hEvent) PURE;
    STDMETHOD(Read)                 (THIS_ LPDIRECTMUSICBUFFER pBuffer) PURE;
    STDMETHOD(DownloadInstrument)   (THIS_ IDirectMusicInstrument *pInstrument, 
                                     IDirectMusicDownloadedInstrument **ppDownloadedInstrument,
                                     DMUS_NOTERANGE *pNoteRanges,
                                     DWORD dwNumNoteRanges) PURE;
    STDMETHOD(UnloadInstrument)     (THIS_ IDirectMusicDownloadedInstrument *pDownloadedInstrument) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(DeviceIoControl)      (THIS_ DWORD dwIoControlCode, 
                                           LPVOID lpInBuffer, 
                                           DWORD nInBufferSize, 
                                           LPVOID lpOutBuffer, 
                                           DWORD nOutBufferSize, 
                                           LPDWORD lpBytesReturned, 
                                           LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwChannelGroups) PURE;
    STDMETHOD(GetNumChannelGroups)  (THIS_ LPDWORD pdwChannelGroups) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fActive) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicThru
DECLARE_INTERFACE_(IDirectMusicThru, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    
    /* IDirectMusicThru 
     */
    STDMETHOD(ThruChannel)          (THIS_ DWORD dwSourceChannelGroup, 
                                           DWORD dwSourceChannel, 
                                           DWORD dwDestinationChannelGroup,
                                           DWORD dwDestinationChannel,
                                           LPDIRECTMUSICPORT pDestinationPort) PURE;
};

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

DEFINE_GUID(IID_IReferenceClock,0x56a86897,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#undef  INTERFACE
#define INTERFACE  IReferenceClock
DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /*  IReferenceClock */
    /*  */
    
    /*  get the time now */
    STDMETHOD(GetTime)                  (THIS_ REFERENCE_TIME *pTime) PURE;

    /*  ask for an async notification that a time has elapsed */
    STDMETHOD(AdviseTime)               (THIS_ REFERENCE_TIME baseTime,         /*  base time */
                                               REFERENCE_TIME streamTime,       /*  stream offset time */
                                               HANDLE hEvent,                   /*  advise via this event */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  ask for an async periodic notification that a time has elapsed */
    STDMETHOD(AdvisePeriodic)           (THIS_ REFERENCE_TIME startTime,        /*  starting at this time */
                                               REFERENCE_TIME periodTime,       /*  time between notifications */
                                               HANDLE hSemaphore,               /*  advise via a semaphore */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  cancel a request for notification */
    STDMETHOD(Unadvise)                 (THIS_ DWORD dwAdviseCookie) PURE;
};

#endif /* __IReferenceClock_INTERFACE_DEFINED__ */

DEFINE_GUID(CLSID_DirectMusic,0x636b9f10,0x0c7d,0x11d1,0x95,0xb2,0x00,0x20,0xaf,0xdc,0x74,0x21);
DEFINE_GUID(CLSID_DirectMusicCollection,0x480ff4b0, 0x28b2, 0x11d1, 0xbe, 0xf7, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);

DEFINE_GUID(IID_IDirectMusic,0x6536115a,0x7b2d,0x11d2,0xba,0x18,0x00,0x00,0xf8,0x75,0xac,0x12);
DEFINE_GUID(IID_IDirectMusicBuffer,0xd2ac2878, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicPort, 0x08f2d8c9,0x37c2,0x11d2,0xb9,0xf9,0x00,0x00,0xf8,0x75,0xac,0x12);
DEFINE_GUID(IID_IDirectMusicThru, 0xced153e7, 0x3606, 0x11d2, 0xb9, 0xf9, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IDirectMusicPortDownload,0xd2ac287a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicDownload,0xd2ac287b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicCollection,0xd2ac287c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicInstrument,0xd2ac287d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicDownloadedInstrument,0xd2ac287e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Alternate interface ID for IID_IDirectMusic, available in DX7 release and after. */
DEFINE_GUID(IID_IDirectMusic2,0x6fc2cae1, 0xbc78, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);


/* Property Query GUID_DMUS_PROP_GM_Hardware - Local GM set, no need to download
 * Property Query GUID_DMUS_PROP_GS_Hardware - Local GS set, no need to download
 * Property Query GUID_DMUS_PROP_XG_Hardware - Local XG set, no need to download
 * Property Query GUID_DMUS_PROP_DLS1        - Support DLS level 1
 * Property Query GUID_DMUS_PROP_INSTRUMENT2 - Support new INSTRUMENT2 download format
 * Property Query GUID_DMUS_PROP_XG_Capable  - Support minimum requirements of XG
 * Property Query GUID_DMUS_PROP_GS_Capable  - Support minimum requirements of GS
 * Property Query GUID_DMUS_PROP_SynthSink_DSOUND - Synthsink talks to DSound
 * Property Query GUID_DMUS_PROP_SynthSink_WAVE - Synthsink talks to Wave device
 *
 * Item 0: Supported
 * Returns a DWORD which is non-zero if the feature is supported
 */
DEFINE_GUID(GUID_DMUS_PROP_GM_Hardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_GS_Hardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Hardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Capable,  0x6496aba1, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_GS_Capable,  0x6496aba2, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_DLS1,        0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_DLS2,        0xf14599e5, 0x4689, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_INSTRUMENT2, 0x865fd372, 0x9f67, 0x11d2, 0x87, 0x2a, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SynthSink_DSOUND,0xaa97844, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SynthSink_WAVE,0xaa97845, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SampleMemorySize, 0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_SamplePlaybackRate, 0x2a91f713, 0xa4bf, 0x11d2, 0xbb, 0xdf, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);

/* Property Get/Set GUID_DMUS_PROP_WriteLatency
 *
 * Item 0: Synth buffer write latency, in milliseconds
 * Get/Set SynthSink latency, the average time after the play head that the next buffer gets written.
 */
DEFINE_GUID(GUID_DMUS_PROP_WriteLatency,0x268a0fa0, 0x60f2, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Get/Set GUID_DMUS_PROP_WritePeriod
 *
 * Item 0: Synth buffer write period, in milliseconds
 * Get/Set SynthSink buffer write period, time span between successive writes.
 */
DEFINE_GUID(GUID_DMUS_PROP_WritePeriod,0x268a0fa1, 0x60f2, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Get GUID_DMUS_PROP_MemorySize
 *
 * Item 0: Memory size
 * Returns a DWORD containing the total number of bytes of sample RAM
 */
DEFINE_GUID(GUID_DMUS_PROP_MemorySize,  0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_WavesReverb
 *
 * Item 0: DMUS_WAVES_REVERB structure
 * Sets reverb parameters
 */
DEFINE_GUID(GUID_DMUS_PROP_WavesReverb,0x4cb5622, 0x32e5, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Set GUID_DMUS_PROP_Effects
 *
 * Item 0: DWORD with effects flags. 
 * Get/Set effects bits, same as dwEffectFlags in DMUS_PORTPARAMS and DMUS_PORTCAPS:
 * DMUS_EFFECT_NONE 
 * DMUS_EFFECT_REVERB 
 * DMUS_EFFECT_CHORUS 
 */
DEFINE_GUID(GUID_DMUS_PROP_Effects, 0xcda8d611, 0x684a, 0x11d2, 0x87, 0x1e, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Property Set GUID_DMUS_PROP_LegacyCaps
 *
 * Item 0: The MIDINCAPS or MIDIOUTCAPS which describes the port's underlying WinMM device. This property is only supported
 * by ports which wrap WinMM devices.
 */

DEFINE_GUID(GUID_DMUS_PROP_LegacyCaps,0xcfa7cdc2, 0x00a1, 0x11d2, 0xaa, 0xd5, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_Volume
 *
 * Item 0: A long which contains an offset, in 1/100 dB, to be added to the final volume
 *
 */
DEFINE_GUID(GUID_DMUS_PROP_Volume, 0xfedfae25L, 0xe46e, 0x11d1, 0xaa, 0xce, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Min and Max values for setting volume with GUID_DMUS_PROP_Volume */

#define DMUS_VOLUME_MAX     2000        /* +20 dB */
#define DMUS_VOLUME_MIN   -20000        /* -200 dB */

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICC_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3d7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3d7obj.h
//
//--------------------------------------------------------------------------

// d3dObj.h : Declaration of the C_dxj_Direct3dObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3d7 LPDIRECT3D7

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3d7Object : 
	public I_dxj_Direct3d7,
	//public CComCoClass<C_dxj_Direct3d7Object, &CLSID__dxj_Direct3d7>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3d7Object() ;
	virtual ~C_dxj_Direct3d7Object() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

BEGIN_COM_MAP(C_dxj_Direct3d7Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3d7)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_Direct3d7,				"DIRECT.Direct3d.3",                "DIRECT.Direct3d7.3",				IDS_D3D_DESC,				THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_Direct3d7Object)

// I_dxj_Direct3d
public:
		 //UPDATED
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

	        
        HRESULT STDMETHODCALLTYPE createDevice( 
            /* [in] */ BSTR guid,
            I_dxj_DirectDrawSurface7 __RPC_FAR *surf,
            /* [retval][out] */ I_dxj_Direct3dDevice7 __RPC_FAR *__RPC_FAR *ret);
        
     //   HRESULT STDMETHODCALLTYPE createTexture( 
     //       /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *dds,
     //       /* [retval][out] */ I_dxj_Direct3dTexture7 __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE createVertexBuffer( 
            /* [in] */ D3dVertexBufferDesc __RPC_FAR *desc,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *__RPC_FAR *f);
        
        HRESULT STDMETHODCALLTYPE evictManagedTextures( void);
        
       // HRESULT STDMETHODCALLTYPE findDevice( 
       //     /* [in] */ D3dFindDeviceSearch __RPC_FAR *ds,
       //     /* [out][in] */ D3dFindDeviceResult7 __RPC_FAR *findresult);
        
        HRESULT STDMETHODCALLTYPE getDevicesEnum( 
            /* [retval][out] */ I_dxj_Direct3DEnumDevices __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getDirectDraw( 
            /* [retval][out] */ I_dxj_DirectDraw7 __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getEnumZBufferFormats( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_Direct3DEnumPixelFormats __RPC_FAR *__RPC_FAR *retv);       
			

private:
    DECL_VARIABLE(_dxj_Direct3d7);


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3d7 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\inc\dmksctrl.h ===
/************************************************************************
*                                                                       *
*   dmksctrl.h -- Definition of IKsControl                              *
*                                                                       *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.            *
*                                                                       *
*                                                                       *
*   This header file contains the definition of IKsControl, which       *
*   duplicates definitions from ks.h and ksproxy.h. Your code should    *
*   include ks.h and ksproxy.h directly if you have them (they are      *
*   provided in the Windows 98 DDK and will be in the Windows NT 5      *
*   SDK).                                                               *
*                                                                       *
************************************************************************/

#ifndef _DMKSCTRL_
#define _DMKSCTRL_

#pragma warning(push)
#pragma warning(disable:4201)   /* Disable warnings on anonymous unions */

#include <pshpack8.h>

#include <objbase.h>

#if !defined(_NTRTL_)
    #ifndef DEFINE_GUIDEX
        #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
    #endif /* !defined(DEFINE_GUIDEX) */

    #ifndef STATICGUIDOF
        #define STATICGUIDOF(guid) STATIC_##guid
    #endif /* !defined(STATICGUIDOF) */
#endif /* !defined(_NTRTL_) */

#ifndef STATIC_IID_IKsControl
#define STATIC_IID_IKsControl\
    0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
#endif /* STATIC_IID_IKsControl */

/* 
 * Warning: This will prevent the rest of ks.h from being pulled in if ks.h is 
 * included after dmksctrl.h. Make sure you do not include both headers in
 * the same source file.
 */
#ifndef _KS_
#define _KS_

#if (defined(_MSC_EXTENSIONS) || defined(__cplusplus)) && !defined(CINTERFACE)
typedef struct {
    union {
        struct {
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        };
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;
#else
typedef struct {
    union {
        struct {
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        } Data;
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;
#endif

typedef KSIDENTIFIER KSPROPERTY, *PKSPROPERTY, KSMETHOD, *PKSMETHOD, KSEVENT, *PKSEVENT;

#define KSMETHOD_TYPE_NONE                  0x00000000
#define KSMETHOD_TYPE_READ                  0x00000001
#define KSMETHOD_TYPE_WRITE                 0x00000002
#define KSMETHOD_TYPE_MODIFY                0x00000003
#define KSMETHOD_TYPE_SOURCE                0x00000004

#define KSMETHOD_TYPE_SEND                  0x00000001
#define KSMETHOD_TYPE_SETSUPPORT            0x00000100
#define KSMETHOD_TYPE_BASICSUPPORT          0x00000200

#define KSPROPERTY_TYPE_GET                 0x00000001
#define KSPROPERTY_TYPE_SET                 0x00000002
#define KSPROPERTY_TYPE_SETSUPPORT          0x00000100
#define KSPROPERTY_TYPE_BASICSUPPORT        0x00000200
#define KSPROPERTY_TYPE_RELATIONS           0x00000400
#define KSPROPERTY_TYPE_SERIALIZESET        0x00000800
#define KSPROPERTY_TYPE_UNSERIALIZESET      0x00001000
#define KSPROPERTY_TYPE_SERIALIZERAW        0x00002000
#define KSPROPERTY_TYPE_UNSERIALIZERAW      0x00004000
#define KSPROPERTY_TYPE_SERIALIZESIZE       0x00008000
#define KSPROPERTY_TYPE_DEFAULTVALUES       0x00010000

#define KSPROPERTY_TYPE_TOPOLOGY            0x10000000
#endif  /* _KS_ */

#ifndef _IKsControl_
#define _IKsControl_

#ifdef DECLARE_INTERFACE_


#undef INTERFACE
#define INTERFACE IKsControl
DECLARE_INTERFACE_(IKsControl, IUnknown)
{
     /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*IKsControl*/
    STDMETHOD(KsProperty)(
        THIS_
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsMethod)(
        THIS_
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsEvent)(
        THIS_
        IN PKSEVENT Event OPTIONAL,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
};

#endif /* DECLARE_INTERFACE_ */
#endif /* _IKsControl_ */

#include <poppack.h>

DEFINE_GUID(IID_IKsControl, 0x28F54685, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96);

/* These formats are in ksmedia.h
 */
#ifndef _KSMEDIA_

DEFINE_GUID(KSDATAFORMAT_SUBTYPE_MIDI, 0x1D262760L, 0xE957, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00);
DEFINE_GUID(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC, 0x1a82f8bc,  0x3f8b, 0x11d2, 0xb7, 0x74, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1);

#endif

#pragma warning(pop)

#endif /* _DMKSCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\inc\dsound.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsound.h
 *  Content:    DirectSound include file
 *
 **************************************************************************/

#ifndef __DSOUND_INCLUDED__
#define __DSOUND_INCLUDED__

#include "d3dtypes.h"

#define COM_NO_WINDOWS_H
#include <objbase.h>

#define _FACDS  0x878
#define MAKE_DSHRESULT(code)  MAKE_HRESULT(1, _FACDS, code)

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef DIRECTSOUND_VERSION
#define DIRECTSOUND_VERSION  0x0700       /* version 7.0 */
#endif /* !DIRECTSOUND_VERSION */


// DirectSound Component GUID {47D4D946-62E8-11cf-93BC-444553540000}
DEFINE_GUID(CLSID_DirectSound, 0x47d4d946, 0x62e8, 0x11cf, 0x93, 0xbc, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

// DirectSound Capture Component GUID {B0210780-89CD-11d0-AF08-00A0C925CD16}
DEFINE_GUID(CLSID_DirectSoundCapture, 0xb0210780, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IDirectSound;
struct IDirectSoundBuffer;
struct IDirectSound3DListener;
struct IDirectSound3DBuffer;
struct IDirectSoundCapture;
struct IDirectSoundCaptureBuffer;
struct IDirectSoundNotify;
#endif // __cplusplus

typedef struct IDirectSound *LPDIRECTSOUND;
typedef struct IDirectSoundBuffer *LPDIRECTSOUNDBUFFER;
typedef struct IDirectSound3DListener *LPDIRECTSOUND3DLISTENER;
typedef struct IDirectSound3DBuffer *LPDIRECTSOUND3DBUFFER;
typedef struct IDirectSoundCapture *LPDIRECTSOUNDCAPTURE;
typedef struct IDirectSoundCaptureBuffer *LPDIRECTSOUNDCAPTUREBUFFER;
typedef struct IDirectSoundNotify *LPDIRECTSOUNDNOTIFY;

//
// Compatibility typedefs
//

#ifndef _LPCWAVEFORMATEX_DEFINED
#define _LPCWAVEFORMATEX_DEFINED
typedef const WAVEFORMATEX *LPCWAVEFORMATEX;
#endif // _LPCWAVEFORMATEX_DEFINED

#ifndef __LPCGUID_DEFINED__
#define __LPCGUID_DEFINED__
typedef const GUID *LPCGUID;
#endif // __LPCGUID_DEFINED__

typedef LPDIRECTSOUND *LPLPDIRECTSOUND;
typedef LPDIRECTSOUNDBUFFER *LPLPDIRECTSOUNDBUFFER;
typedef LPDIRECTSOUND3DLISTENER *LPLPDIRECTSOUND3DLISTENER;
typedef LPDIRECTSOUND3DBUFFER *LPLPDIRECTSOUND3DBUFFER;
typedef LPDIRECTSOUNDCAPTURE *LPLPDIRECTSOUNDCAPTURE;
typedef LPDIRECTSOUNDCAPTUREBUFFER *LPLPDIRECTSOUNDCAPTUREBUFFER;
typedef LPDIRECTSOUNDNOTIFY *LPLPDIRECTSOUNDNOTIFY;

//
// Structures
//

typedef struct _DSCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwMinSecondarySampleRate;
    DWORD           dwMaxSecondarySampleRate;
    DWORD           dwPrimaryBuffers;
    DWORD           dwMaxHwMixingAllBuffers;
    DWORD           dwMaxHwMixingStaticBuffers;
    DWORD           dwMaxHwMixingStreamingBuffers;
    DWORD           dwFreeHwMixingAllBuffers;
    DWORD           dwFreeHwMixingStaticBuffers;
    DWORD           dwFreeHwMixingStreamingBuffers;
    DWORD           dwMaxHw3DAllBuffers;
    DWORD           dwMaxHw3DStaticBuffers;
    DWORD           dwMaxHw3DStreamingBuffers;
    DWORD           dwFreeHw3DAllBuffers;
    DWORD           dwFreeHw3DStaticBuffers;
    DWORD           dwFreeHw3DStreamingBuffers;
    DWORD           dwTotalHwMemBytes;
    DWORD           dwFreeHwMemBytes;
    DWORD           dwMaxContigFreeHwMemBytes;
    DWORD           dwUnlockTransferRateHwBuffers;
    DWORD           dwPlayCpuOverheadSwBuffers;
    DWORD           dwReserved1;
    DWORD           dwReserved2;
} DSCAPS, *LPDSCAPS;

typedef const DSCAPS *LPCDSCAPS;

typedef struct _DSBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwUnlockTransferRate;
    DWORD           dwPlayCpuOverhead;
} DSBCAPS, *LPDSBCAPS;

typedef const DSBCAPS *LPCDSBCAPS;

typedef struct _DSBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0700
    GUID            guid3DAlgorithm;
#endif
} DSBUFFERDESC, *LPDSBUFFERDESC;

typedef const DSBUFFERDESC *LPCDSBUFFERDESC;

typedef struct _DSBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSBUFFERDESC1, *LPDSBUFFERDESC1;

typedef const DSBUFFERDESC1 *LPCDSBUFFERDESC1;

typedef struct _DS3DBUFFER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    DWORD           dwInsideConeAngle;
    DWORD           dwOutsideConeAngle;
    D3DVECTOR       vConeOrientation;
    LONG            lConeOutsideVolume;
    D3DVALUE        flMinDistance;
    D3DVALUE        flMaxDistance;
    DWORD           dwMode;
} DS3DBUFFER, *LPDS3DBUFFER;

typedef const DS3DBUFFER *LPCDS3DBUFFER;

typedef struct _DS3DLISTENER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    D3DVECTOR       vOrientFront;
    D3DVECTOR       vOrientTop;
    D3DVALUE        flDistanceFactor;
    D3DVALUE        flRolloffFactor;
    D3DVALUE        flDopplerFactor;
} DS3DLISTENER, *LPDS3DLISTENER;

typedef const DS3DLISTENER *LPCDS3DLISTENER;

typedef struct _DSCCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwFormats;
    DWORD           dwChannels;
} DSCCAPS, *LPDSCCAPS;

typedef const DSCCAPS *LPCDSCCAPS;

typedef struct _DSCBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSCBUFFERDESC, *LPDSCBUFFERDESC;

typedef const DSCBUFFERDESC *LPCDSCBUFFERDESC;

typedef struct _DSCBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
} DSCBCAPS, *LPDSCBCAPS;

typedef const DSCBCAPS *LPCDSCBCAPS;

typedef struct _DSBPOSITIONNOTIFY
{
    DWORD           dwOffset;
    HANDLE          hEventNotify;
} DSBPOSITIONNOTIFY, *LPDSBPOSITIONNOTIFY;

typedef const DSBPOSITIONNOTIFY *LPCDSBPOSITIONNOTIFY;

//
// DirectSound API
//

typedef BOOL (CALLBACK *LPDSENUMCALLBACKA)(LPGUID, LPCSTR, LPCSTR, LPVOID);
typedef BOOL (CALLBACK *LPDSENUMCALLBACKW)(LPGUID, LPCWSTR, LPCWSTR, LPVOID);

extern HRESULT WINAPI DirectSoundCreate(LPCGUID, LPDIRECTSOUND *, LPUNKNOWN);
extern HRESULT WINAPI DirectSoundEnumerateA(LPDSENUMCALLBACKA, LPVOID);
extern HRESULT WINAPI DirectSoundEnumerateW(LPDSENUMCALLBACKW, LPVOID);

extern HRESULT WINAPI DirectSoundCaptureCreate(LPCGUID, LPDIRECTSOUNDCAPTURE *, LPUNKNOWN);
extern HRESULT WINAPI DirectSoundCaptureEnumerateA(LPDSENUMCALLBACKA, LPVOID);
extern HRESULT WINAPI DirectSoundCaptureEnumerateW(LPDSENUMCALLBACKW, LPVOID);

#ifdef UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKW
#define DirectSoundEnumerate        DirectSoundEnumerateW
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateW
#else // UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKA
#define DirectSoundEnumerate        DirectSoundEnumerateA
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateA
#endif // UNICODE

//
// IUnknown
//

#if !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->lpVtbl->QueryInterface(p,a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->lpVtbl->AddRef(p)
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->lpVtbl->Release(p)
#endif // IUnknown_Release
#else // !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->QueryInterface(a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->AddRef()
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->Release()
#endif // IUnknown_Release
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound
//

DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound

DECLARE_INTERFACE_(IDirectSound, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC, LPDIRECTSOUNDBUFFER *, LPUNKNOWN) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER, LPDIRECTSOUNDBUFFER *) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND, DWORD) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID) PURE;
};

#define IDirectSound_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IDirectSound_AddRef(p)                   IUnknown_AddRef(p)
#define IDirectSound_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->lpVtbl->CreateSoundBuffer(p,a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->lpVtbl->GetCaps(p,a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->lpVtbl->DuplicateSoundBuffer(p,a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectSound_Compact(p)                  (p)->lpVtbl->Compact(p)
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->lpVtbl->GetSpeakerConfig(p,a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->lpVtbl->SetSpeakerConfig(p,b)
#define IDirectSound_Initialize(p,a)             (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->CreateSoundBuffer(a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->GetCaps(a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->DuplicateSoundBuffer(a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->SetCooperativeLevel(a,b)
#define IDirectSound_Compact(p)                  (p)->Compact()
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->GetSpeakerConfig(a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->SetSpeakerConfig(b)
#define IDirectSound_Initialize(p,a)             (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundBuffer
//

DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer

DECLARE_INTERFACE_(IDirectSoundBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD, LPDWORD) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX, DWORD, LPDWORD) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND, LPCDSBUFFERDESC) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD, DWORD, DWORD) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(Restore)              (THIS) PURE;
};

#define IDirectSoundBuffer_QueryInterface(p,a,b)        IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer_AddRef(p)                    IUnknown_AddRef(p)
#define IDirectSoundBuffer_Release(p)                   IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->lpVtbl->GetVolume(p,a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->lpVtbl->GetPan(p,a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->lpVtbl->GetFrequency(p,a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->lpVtbl->Play(p,a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->lpVtbl->SetCurrentPosition(p,a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->lpVtbl->SetFormat(p,a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->lpVtbl->SetVolume(p,a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->lpVtbl->SetPan(p,a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->lpVtbl->SetFrequency(p,a)
#define IDirectSoundBuffer_Stop(p)                      (p)->lpVtbl->Stop(p)
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->lpVtbl->Restore(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->GetCurrentPosition(a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->GetFormat(a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->GetVolume(a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->GetPan(a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->GetFrequency(a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->GetStatus(a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->Play(a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->SetCurrentPosition(a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->SetFormat(a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->SetVolume(a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->SetPan(a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->SetFrequency(a)
#define IDirectSoundBuffer_Stop(p)                      (p)->Stop()
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->Unlock(a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->Restore()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DListener
//

DEFINE_GUID(IID_IDirectSound3DListener, 0x279AFA84, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DListener

DECLARE_INTERFACE_(IDirectSound3DListener, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSound3DListener methods
    STDMETHOD(GetAllParameters)         (THIS_ LPDS3DLISTENER) PURE;
    STDMETHOD(GetDistanceFactor)        (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetDopplerFactor)         (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetOrientation)           (THIS_ LPD3DVECTOR, LPD3DVECTOR) PURE;
    STDMETHOD(GetPosition)              (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(GetRolloffFactor)         (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetVelocity)              (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(SetAllParameters)         (THIS_ LPCDS3DLISTENER, DWORD) PURE;
    STDMETHOD(SetDistanceFactor)        (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetDopplerFactor)         (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetOrientation)           (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(SetPosition)              (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(SetRolloffFactor)         (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetVelocity)              (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(CommitDeferredSettings)   (THIS) PURE;
};

#define IDirectSound3DListener_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DListener_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSound3DListener_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->lpVtbl->GetDistanceFactor(p,a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->lpVtbl->GetDopplerFactor(p,a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->lpVtbl->GetOrientation(p,a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->lpVtbl->GetRolloffFactor(p,a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->lpVtbl->SetDistanceFactor(p,a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->lpVtbl->SetDopplerFactor(p,a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->lpVtbl->SetOrientation(p,a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->lpVtbl->SetRolloffFactor(p,a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->lpVtbl->CommitDeferredSettings(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->GetDistanceFactor(a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->GetDopplerFactor(a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->GetOrientation(a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->GetPosition(a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->GetRolloffFactor(a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->GetVelocity(a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->SetAllParameters(a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->SetDistanceFactor(a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->SetDopplerFactor(a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->SetOrientation(a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->SetPosition(a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->SetRolloffFactor(a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->SetVelocity(a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->CommitDeferredSettings()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBuffer
//

DEFINE_GUID(IID_IDirectSound3DBuffer, 0x279AFA86, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DBuffer

DECLARE_INTERFACE_(IDirectSound3DBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound3DBuffer methods
    STDMETHOD(GetAllParameters)     (THIS_ LPDS3DBUFFER) PURE;
    STDMETHOD(GetConeAngles)        (THIS_ LPDWORD, LPDWORD) PURE;
    STDMETHOD(GetConeOrientation)   (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(GetConeOutsideVolume) (THIS_ LPLONG) PURE;
    STDMETHOD(GetMaxDistance)       (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetMinDistance)       (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetMode)              (THIS_ LPDWORD) PURE;
    STDMETHOD(GetPosition)          (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(GetVelocity)          (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDS3DBUFFER, DWORD) PURE;
    STDMETHOD(SetConeAngles)        (THIS_ DWORD, DWORD, DWORD) PURE;
    STDMETHOD(SetConeOrientation)   (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(SetConeOutsideVolume) (THIS_ LONG, DWORD) PURE;
    STDMETHOD(SetMaxDistance)       (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetMinDistance)       (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetMode)              (THIS_ DWORD, DWORD) PURE;
    STDMETHOD(SetPosition)          (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(SetVelocity)          (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
};

#define IDirectSound3DBuffer_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DBuffer_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSound3DBuffer_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->lpVtbl->GetConeAngles(p,a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->lpVtbl->GetConeOrientation(p,a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->lpVtbl->GetConeOutsideVolume(p,a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->lpVtbl->GetMinDistance(p,a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->lpVtbl->GetMaxDistance(p,a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->lpVtbl->GetMode(p,a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->lpVtbl->SetConeAngles(p,a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->lpVtbl->SetConeOrientation(p,a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->lpVtbl->SetConeOutsideVolume(p,a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->lpVtbl->SetMinDistance(p,a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->lpVtbl->SetMaxDistance(p,a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->lpVtbl->SetMode(p,a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->GetConeAngles(a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->GetConeOrientation(a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->GetConeOutsideVolume(a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->GetPosition(a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->GetMinDistance(a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->GetMaxDistance(a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->GetMode(a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->GetVelocity(a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->SetAllParameters(a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->SetConeAngles(a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->SetConeOrientation(a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->SetConeOutsideVolume(a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->SetPosition(a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->SetMinDistance(a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->SetMaxDistance(a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->SetMode(a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->SetVelocity(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCapture
//

DEFINE_GUID(IID_IDirectSoundCapture, 0xb0210781, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCapture

DECLARE_INTERFACE_(IDirectSoundCapture, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCapture methods
    STDMETHOD(CreateCaptureBuffer)  (THIS_ LPCDSCBUFFERDESC, LPDIRECTSOUNDCAPTUREBUFFER *, LPUNKNOWN) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCCAPS ) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID) PURE;
};

#define IDirectSoundCapture_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCapture_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundCapture_Release(p)                      IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->lpVtbl->CreateCaptureBuffer(p,a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->CreateCaptureBuffer(a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureBuffer
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer, 0xb0210782, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS ) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX, DWORD, LPDWORD ) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD ) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE, LPCDSCBUFFERDESC) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD) PURE;
    STDMETHOD(Start)                (THIS_ DWORD) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID, DWORD, LPVOID, DWORD) PURE;
};

#define IDirectSoundCaptureBuffer_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->lpVtbl->Unlock(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->Start(a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->Stop()
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->Unlock(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundNotify
//

DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundNotify

DECLARE_INTERFACE_(IDirectSoundNotify, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSoundNotify methods
    STDMETHOD(SetNotificationPositions) (THIS_ DWORD, LPCDSBPOSITIONNOTIFY) PURE;
};

#define IDirectSoundNotify_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundNotify_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundNotify_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->lpVtbl->SetNotificationPositions(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->SetNotificationPositions(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IKsPropertySet
//

#ifndef _IKsPropertySet_
#define _IKsPropertySet_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IKsPropertySet;
#endif // __cplusplus

typedef struct IKsPropertySet *LPKSPROPERTYSET;

#define KSPROPERTY_SUPPORT_GET  0x00000001
#define KSPROPERTY_SUPPORT_SET  0x00000002

DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);

#undef INTERFACE
#define INTERFACE IKsPropertySet

DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IKsPropertySet methods
    STDMETHOD(Get)              (THIS_ REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG, PULONG) PURE;
    STDMETHOD(Set)              (THIS_ REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG) PURE;
    STDMETHOD(QuerySupport)     (THIS_ REFGUID, ULONG, PULONG) PURE;
};

#define IKsPropertySet_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IKsPropertySet_AddRef(p)                   IUnknown_AddRef(p)
#define IKsPropertySet_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Get(p,a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->lpVtbl->Set(p,a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->lpVtbl->QuerySupport(p,a,b,c)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->Get(a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->Set(a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->QuerySupport(a,b,c)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IKsPropertySet_


//
// Return Codes
//

// The function completed successfully
#define DS_OK                           S_OK

// The function completed successfully, but we had to substitute the 3D algorithm
#define DS_NO_VIRTUALIZATION            MAKE_HRESULT(0, _FACDS, 10)

// The call failed because resources (such as a priority level)
// were already being used by another caller
#define DSERR_ALLOCATED                 MAKE_DSHRESULT(10)

// The control (vol,pan,etc.) requested by the caller is not available
#define DSERR_CONTROLUNAVAIL            MAKE_DSHRESULT(30)

// An invalid parameter was passed to the returning function
#define DSERR_INVALIDPARAM              E_INVALIDARG

// This call is not valid for the current state of this object
#define DSERR_INVALIDCALL               MAKE_DSHRESULT(50)

// An undetermined error occured inside the DirectSound subsystem
#define DSERR_GENERIC                   E_FAIL

// The caller does not have the priority level required for the function to
// succeed
#define DSERR_PRIOLEVELNEEDED           MAKE_DSHRESULT(70)

// Not enough free memory is available to complete the operation
#define DSERR_OUTOFMEMORY               E_OUTOFMEMORY

// The specified WAVE format is not supported
#define DSERR_BADFORMAT                 MAKE_DSHRESULT(100)

// The function called is not supported at this time
#define DSERR_UNSUPPORTED               E_NOTIMPL

// No sound driver is available for use
#define DSERR_NODRIVER                  MAKE_DSHRESULT(120)

// This object is already initialized
#define DSERR_ALREADYINITIALIZED        MAKE_DSHRESULT(130)

// This object does not support aggregation
#define DSERR_NOAGGREGATION             CLASS_E_NOAGGREGATION

// The buffer memory has been lost, and must be restored
#define DSERR_BUFFERLOST                MAKE_DSHRESULT(150)

// Another app has a higher priority level, preventing this call from
// succeeding
#define DSERR_OTHERAPPHASPRIO           MAKE_DSHRESULT(160)

// This object has not been initialized
#define DSERR_UNINITIALIZED             MAKE_DSHRESULT(170)

// The requested COM interface is not available
#define DSERR_NOINTERFACE               E_NOINTERFACE

// Access is denied
#define DSERR_ACCESSDENIED              E_ACCESSDENIED

//
// Flags
//

#define DSCAPS_PRIMARYMONO          0x00000001
#define DSCAPS_PRIMARYSTEREO        0x00000002
#define DSCAPS_PRIMARY8BIT          0x00000004
#define DSCAPS_PRIMARY16BIT         0x00000008
#define DSCAPS_CONTINUOUSRATE       0x00000010
#define DSCAPS_EMULDRIVER           0x00000020
#define DSCAPS_CERTIFIED            0x00000040
#define DSCAPS_SECONDARYMONO        0x00000100
#define DSCAPS_SECONDARYSTEREO      0x00000200
#define DSCAPS_SECONDARY8BIT        0x00000400
#define DSCAPS_SECONDARY16BIT       0x00000800

#define DSSCL_NORMAL                0x00000001
#define DSSCL_PRIORITY              0x00000002
#define DSSCL_EXCLUSIVE             0x00000003
#define DSSCL_WRITEPRIMARY          0x00000004

#define DSSPEAKER_HEADPHONE         0x00000001
#define DSSPEAKER_MONO              0x00000002
#define DSSPEAKER_QUAD              0x00000003
#define DSSPEAKER_STEREO            0x00000004
#define DSSPEAKER_SURROUND          0x00000005
#define DSSPEAKER_5POINT1           0x00000006

#define DSSPEAKER_GEOMETRY_MIN      0x00000005  //   5 degrees
#define DSSPEAKER_GEOMETRY_NARROW   0x0000000A  //  10 degrees
#define DSSPEAKER_GEOMETRY_WIDE     0x00000014  //  20 degrees
#define DSSPEAKER_GEOMETRY_MAX      0x000000B4  // 180 degrees

#define DSSPEAKER_COMBINED(c, g)    ((DWORD)(((BYTE)(c)) | ((DWORD)((BYTE)(g))) << 16))
#define DSSPEAKER_CONFIG(a)         ((BYTE)(a))
#define DSSPEAKER_GEOMETRY(a)       ((BYTE)(((DWORD)(a) >> 16) & 0x00FF))

#define DSBCAPS_PRIMARYBUFFER       0x00000001
#define DSBCAPS_STATIC              0x00000002
#define DSBCAPS_LOCHARDWARE         0x00000004
#define DSBCAPS_LOCSOFTWARE         0x00000008
#define DSBCAPS_CTRL3D              0x00000010
#define DSBCAPS_CTRLFREQUENCY       0x00000020
#define DSBCAPS_CTRLPAN             0x00000040
#define DSBCAPS_CTRLVOLUME          0x00000080
#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100
#define DSBCAPS_STICKYFOCUS         0x00004000
#define DSBCAPS_GLOBALFOCUS         0x00008000
#define DSBCAPS_GETCURRENTPOSITION2 0x00010000
#define DSBCAPS_MUTE3DATMAXDISTANCE 0x00020000
#define DSBCAPS_LOCDEFER            0x00040000

#define DSBPLAY_LOOPING             0x00000001
#define DSBPLAY_LOCHARDWARE         0x00000002
#define DSBPLAY_LOCSOFTWARE         0x00000004
#define DSBPLAY_TERMINATEBY_TIME    0x00000008
#define DSBPLAY_TERMINATEBY_DISTANCE    0x000000010
#define DSBPLAY_TERMINATEBY_PRIORITY    0x000000020

#define DSBSTATUS_PLAYING           0x00000001
#define DSBSTATUS_BUFFERLOST        0x00000002
#define DSBSTATUS_LOOPING           0x00000004
#define DSBSTATUS_LOCHARDWARE       0x00000008
#define DSBSTATUS_LOCSOFTWARE       0x00000010
#define DSBSTATUS_TERMINATED        0x00000020

#define DSBLOCK_FROMWRITECURSOR     0x00000001
#define DSBLOCK_ENTIREBUFFER        0x00000002

#define DSBFREQUENCY_MIN            100
#define DSBFREQUENCY_MAX            100000
#define DSBFREQUENCY_ORIGINAL       0

#define DSBPAN_LEFT                 -10000
#define DSBPAN_CENTER               0
#define DSBPAN_RIGHT                10000

#define DSBVOLUME_MIN               -10000
#define DSBVOLUME_MAX               0

#define DSBSIZE_MIN                 4
#define DSBSIZE_MAX                 0x0FFFFFFF

#define DS3DMODE_NORMAL             0x00000000
#define DS3DMODE_HEADRELATIVE       0x00000001
#define DS3DMODE_DISABLE            0x00000002

#define DS3D_IMMEDIATE              0x00000000
#define DS3D_DEFERRED               0x00000001

#define DS3D_MINDISTANCEFACTOR      FLT_MIN
#define DS3D_MAXDISTANCEFACTOR      FLT_MAX
#define DS3D_DEFAULTDISTANCEFACTOR  1.0f

#define DS3D_MINROLLOFFFACTOR       0.0f
#define DS3D_MAXROLLOFFFACTOR       10.0f
#define DS3D_DEFAULTROLLOFFFACTOR   1.0f

#define DS3D_MINDOPPLERFACTOR       0.0f
#define DS3D_MAXDOPPLERFACTOR       10.0f
#define DS3D_DEFAULTDOPPLERFACTOR   1.0f

#define DS3D_DEFAULTMINDISTANCE     1.0f
#define DS3D_DEFAULTMAXDISTANCE     1000000000.0f

#define DS3D_MINCONEANGLE           0
#define DS3D_MAXCONEANGLE           360
#define DS3D_DEFAULTCONEANGLE       360

#define DS3D_DEFAULTCONEOUTSIDEVOLUME DSBVOLUME_MAX

#define DSCCAPS_EMULDRIVER          DSCAPS_EMULDRIVER
#define DSCCAPS_CERTIFIED           DSCAPS_CERTIFIED

#define DSCBCAPS_WAVEMAPPED         0x80000000

#define DSCBLOCK_ENTIREBUFFER       0x00000001

#define DSCBSTATUS_CAPTURING        0x00000001
#define DSCBSTATUS_LOOPING          0x00000002

#define DSCBSTART_LOOPING           0x00000001

#define DSBPN_OFFSETSTOP            0xFFFFFFFF


//
// DirectSound3D Algorithms
//

// Default DirectSound3D algorithm {00000000-0000-0000-0000-000000000000}
#define DS3DALG_DEFAULT GUID_NULL

// No virtualization {C241333F-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_NO_VIRTUALIZATION, 0xc241333f, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// High-quality HRTF algorithm {C2413340-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_FULL, 0xc2413340, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// Lower-quality HRTF algorithm {C2413342-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_LIGHT, 0xc2413342, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

#ifdef __cplusplus
};
#endif // __cplusplus

#endif  // __DSOUND_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3denumdevices7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3denumdevices7obj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_Direct3DEnumDevices7Object : 
	public I_dxj_Direct3DEnumDevices,
	public CComObjectRoot
{
public:
	C_dxj_Direct3DEnumDevices7Object() ;
	virtual ~C_dxj_Direct3DEnumDevices7Object() ;

BEGIN_COM_MAP(C_dxj_Direct3DEnumDevices7Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3DEnumDevices)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_Direct3DEnumDevices7Object)

public:
	    HRESULT STDMETHODCALLTYPE getDesc( 
            /* [in] */ long index,
            /* [out][in] */ D3dDeviceDesc7 __RPC_FAR *hwDesc);
        
        
        HRESULT STDMETHODCALLTYPE getGuid( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        HRESULT STDMETHODCALLTYPE getDescription( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);

		static HRESULT C_dxj_Direct3DEnumDevices7Object::create(LPDIRECT3D7 pD3D7,I_dxj_Direct3DEnumDevices **ppRet);
		
	
public:
		DxDriverInfo	*m_pList;
		D3DDEVICEDESC7	*m_pListHW;
		
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3denumpixelformats7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       d3denumpixelformats7obj.h
//
//--------------------------------------------------------------------------




#include "resource.h"       

class C_dxj_Direct3DEnumPixelFormats7Object : 
	public I_dxj_Direct3DEnumPixelFormats,
	public CComObjectRoot
{
public:
	C_dxj_Direct3DEnumPixelFormats7Object() ;
	virtual ~C_dxj_Direct3DEnumPixelFormats7Object() ;

BEGIN_COM_MAP(C_dxj_Direct3DEnumPixelFormats7Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3DEnumPixelFormats)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_Direct3DEnumPixelFormats7Object)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, DDPixelFormat *info);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		static HRESULT C_dxj_Direct3DEnumPixelFormats7Object::create1(LPDIRECT3DDEVICE7 pd3d,  I_dxj_Direct3DEnumPixelFormats **ppRet);
		static HRESULT C_dxj_Direct3DEnumPixelFormats7Object::create2(LPDIRECT3D7 pd3d,  BSTR strGuid, I_dxj_Direct3DEnumPixelFormats **ppRet);
				                 
public:
		DDPIXELFORMAT	*m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3denumpixelformatsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3denumpixelformatsobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "D3DEnumPixelFormatsobj.h"

extern HRESULT CopyOutDDPixelFormat( DDPixelFormat *ddpfOut,DDPIXELFORMAT *pf);
extern HRESULT CopyInDDPixelFormat(DDPIXELFORMAT *ddpfOut,DDPixelFormat *pf);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR D3DGUIDtoBSTR(LPGUID pg);
extern HRESULT D3DBSTRtoGUID(LPGUID pGuid,BSTR str);

extern	BOOL IsAllZeros(void *pStruct,DWORD size); 

extern "C" HRESULT PASCAL objEnumPixelFormatsCallback(DDPIXELFORMAT  *pf, void *lpArg)
{

	DPF(1,"Entered objEnumPixelFormatsCallback\r\n");

	
	C_dxj_D3DEnumPixelFormatsObject *pObj=(C_dxj_D3DEnumPixelFormatsObject*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if (pObj->m_pList)
			pObj->m_pList=(DDPIXELFORMAT*)realloc(pObj->m_pList,sizeof(DDPixelFormat)* pObj->m_nMax);
		else
			pObj->m_pList=(DDPIXELFORMAT*)malloc(sizeof(DDPixelFormat)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),pf,sizeof(DDPIXELFORMAT));
		
	
	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_D3DEnumPixelFormatsObject::C_dxj_D3DEnumPixelFormatsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_D3DEnumPixelFormatsObject::~C_dxj_D3DEnumPixelFormatsObject()
{
	//empty list
	if (m_pList){
		free(m_pList);
	}

}


HRESULT C_dxj_D3DEnumPixelFormatsObject::create(LPDIRECT3DDEVICE3 pd3d,  I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_D3DEnumPixelFormatsObject *pNew=NULL;

	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_D3DEnumPixelFormatsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumTextureFormats(objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_D3DEnumPixelFormats,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_D3DEnumPixelFormatsObject::create2(LPDIRECT3D3 pd3d,  BSTR strGuid, I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_D3DEnumPixelFormatsObject *pNew=NULL;
	GUID guid;

	hr=D3DBSTRtoGUID(&guid,strGuid);
	if FAILED(hr) return hr;
	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_D3DEnumPixelFormatsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumZBufferFormats(guid,objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_D3DEnumPixelFormats,(void**)ppRet);
	return hr;
}



#if 0
HRESULT C_dxj_D3DEnumPixelFormatsObject::create3(LPDIRECT3DDEVICE7 pd3d,  I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_D3DEnumPixelFormatsObject *pNew=NULL;

	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_D3DEnumPixelFormatsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumTextureFormats(objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_D3DEnumPixelFormats,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_D3DEnumPixelFormatsObject::create4(LPDIRECT3D7 pd3d,  BSTR strGuid, I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_D3DEnumPixelFormatsObject *pNew=NULL;
	GUID guid;

	hr=D3DBSTRtoGUID(&guid,strGuid);
	if FAILED(hr) return hr;
	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_D3DEnumPixelFormatsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumZBufferFormats(guid,objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_D3DEnumPixelFormats,(void**)ppRet);
	return hr;
}
#endif


HRESULT C_dxj_D3DEnumPixelFormatsObject::getItem( long index, DDPixelFormat *desc)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	CopyOutDDPixelFormat(desc ,&(m_pList[index-1]));

	return S_OK;
}


HRESULT C_dxj_D3DEnumPixelFormatsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3ddevice7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3ddevice7obj.h
//
//--------------------------------------------------------------------------

// d3dDeviceObj.h : Declaration of the C_dxj_Direct3dDeviceObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dDevice7 LPDIRECT3DDEVICE7

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't
//          like references as template arguments.

class C_dxj_Direct3dDevice7Object : 
        public I_dxj_Direct3dDevice7,
		//public CComCoClass<C_dxj_Direct3dDevice7Object, &CLSID__dxj_Direct3dDevice7>,
		public CComObjectRoot
{
public:
        C_dxj_Direct3dDevice7Object();
        virtual ~C_dxj_Direct3dDevice7Object();
		DWORD InternalAddRef();
		DWORD InternalRelease();

BEGIN_COM_MAP(C_dxj_Direct3dDevice7Object)
        COM_INTERFACE_ENTRY(I_dxj_Direct3dDevice7)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_Direct3dDevice7,			"DIRECT.Direct3dDevice7.3",          "DIRECT.Direct3dDevice7.3",			IDS_D3DDEVICE_DESC,			THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_Direct3dDevice7Object)

// I_dxj_Direct3dDevice
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
          HRESULT STDMETHODCALLTYPE applyStateBlock( 
            /* [in] */ long blockHandle);
        
          HRESULT STDMETHODCALLTYPE beginScene( void);
        
          HRESULT STDMETHODCALLTYPE beginStateBlock( void);
        
          HRESULT STDMETHODCALLTYPE captureStateBlock( 
            /* [in] */ long blockHandle);
        
          HRESULT STDMETHODCALLTYPE clear( 
            /* [in] */ long count,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *recs,
            /* [in] */ long flags,
            /* [in] */ long color,
            /* [in] */ float z,
            /* [in] */ long stencil);
        
          HRESULT STDMETHODCALLTYPE computeSphereVisibility( 
            D3dVector __RPC_FAR *center,
            float __RPC_FAR *radius,
            /* [retval][out] */ long __RPC_FAR *returnVal);
        
          HRESULT STDMETHODCALLTYPE deleteStateBlock( 
            /* [in] */ long blockHandle);
        
          HRESULT STDMETHODCALLTYPE drawIndexedPrimitive( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ long d3dvt,
            /* [in] */ void __RPC_FAR *vertices,
            /* [in] */ long VertexCount,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indices,
            /* [in] */ long IndicesCount,
            /* [in] */ long flags);
        
          HRESULT STDMETHODCALLTYPE drawIndexedPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vertexBuffer,
            /* [in] */ long startVertex,
            /* [in] */ long numVertices,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indexArray,
            /* [in] */ long indexcount,
            /* [in] */ long flags);
        
          HRESULT STDMETHODCALLTYPE drawPrimitive( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ long d3dvt,
            /* [in] */ void __RPC_FAR *vertices,
            /* [in] */ long VertexCount,
            /* [in] */ long flags);
        
          HRESULT STDMETHODCALLTYPE drawPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vertexBuffer,
            /* [in] */ long startVertex,
            /* [in] */ long numVertices,
            /* [in] */ long flags);
                  
          HRESULT STDMETHODCALLTYPE endScene( void);
        
          HRESULT STDMETHODCALLTYPE endStateBlock( 
            /* [in] */ long __RPC_FAR *blockHandle);
        
          HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ D3dDeviceDesc7 __RPC_FAR *desc);
        
          HRESULT STDMETHODCALLTYPE getClipStatus( 
            /* [out][in] */ D3dClipStatus __RPC_FAR *clipStatus);
        
          HRESULT STDMETHODCALLTYPE getDirect3D( 
            /* [retval][out] */ I_dxj_Direct3d7 __RPC_FAR *__RPC_FAR *dev);
        
          HRESULT STDMETHODCALLTYPE getLight( 
            /* [in] */ long LightIndex,
            /* [out][in] */ D3dLight7 __RPC_FAR *Light);
        
          HRESULT STDMETHODCALLTYPE getLightEnable( 
            /* [in] */ long LightIndex,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *b);
        
          HRESULT STDMETHODCALLTYPE getMaterial( 
            /* [out][in] */ D3dMaterial7 __RPC_FAR *Material);
        
          HRESULT STDMETHODCALLTYPE getRenderState( 
            /* [in] */ d3dRenderStateType state,
            /* [retval][out] */ long __RPC_FAR *renderstate);
        
          HRESULT STDMETHODCALLTYPE getRenderTarget( 
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *ppval);
        
          HRESULT STDMETHODCALLTYPE getTexture( 
            /* [in] */ long stage,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv);
        
          HRESULT STDMETHODCALLTYPE getTextureFormatsEnum( 
            /* [retval][out] */ I_dxj_Direct3DEnumPixelFormats __RPC_FAR *__RPC_FAR *retval);
        
          HRESULT STDMETHODCALLTYPE getTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [retval][out] */ long __RPC_FAR *val);
        
          HRESULT STDMETHODCALLTYPE getTransform( 
            /* [in] */ d3dTransformStateType transformType,
            /* [out][in] */ D3dMatrix __RPC_FAR *matrix);
        
          HRESULT STDMETHODCALLTYPE getViewport( 
            /* [out][in] */ D3dViewport7 __RPC_FAR *viewport);
        
          HRESULT STDMETHODCALLTYPE lightEnable( 
            /* [in] */ long LightIndex,
            /* [in] */ VARIANT_BOOL b);
        
          HRESULT STDMETHODCALLTYPE load( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *DestTex,
            /* [in] */ long xDest,
            /* [in] */ long yDest,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *SrcTex,
            /* [in] */ Rect __RPC_FAR *rcSrcRect,
            /* [in] */ long flags);
        
          HRESULT STDMETHODCALLTYPE multiplyTransform( 
            /* [in] */ long dstTransfromStateType,
            /* [out][in] */ D3dMatrix __RPC_FAR *matrix);
        
        
          HRESULT STDMETHODCALLTYPE preLoad( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *surf);
        
          HRESULT STDMETHODCALLTYPE setClipStatus( 
            /* [in] */ D3dClipStatus __RPC_FAR *clipStatus);
        
          HRESULT STDMETHODCALLTYPE setLight( 
            /* [in] */ long LightIndex,
            /* [in] */ D3dLight7 __RPC_FAR *Light);
        
          HRESULT STDMETHODCALLTYPE setMaterial( 
            /* [in] */ D3dMaterial7 __RPC_FAR *mat);
        
          HRESULT STDMETHODCALLTYPE setRenderState( 
            /* [in] */ d3dRenderStateType state,
            /* [in] */ long renderstate);
        
          HRESULT STDMETHODCALLTYPE setRenderTarget( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *surface);
        
          HRESULT STDMETHODCALLTYPE setTexture( 
            /* [in] */ long stage,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *texture);
        
          HRESULT STDMETHODCALLTYPE setTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ long value);
        
          HRESULT STDMETHODCALLTYPE setTransform( 
            /* [in] */ d3dTransformStateType transformType,
            /* [in] */ D3dMatrix __RPC_FAR *matrix);
        
          HRESULT STDMETHODCALLTYPE setViewport( 
            /* [in] */ D3dViewport7 __RPC_FAR *viewport);
        
          HRESULT STDMETHODCALLTYPE validateDevice( 
            /* [retval][out] */ long __RPC_FAR *passes);
   

          HRESULT STDMETHODCALLTYPE setTextureStageStateSingle( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ float value);
        
          HRESULT STDMETHODCALLTYPE getTextureStageStateSingle( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ float *value);



		HRESULT STDMETHODCALLTYPE getInfo (             
            /* [in] */		long lDevInfoID,
            /* [out][in] */ void __RPC_FAR *DevInfoType,
            /* [in] */		long lSize);


        HRESULT STDMETHODCALLTYPE setRenderStateSingle( 
            /* [in] */ d3dRenderStateType state,
            /* [in] */ float renderstate);

        HRESULT STDMETHODCALLTYPE getRenderStateSingle( 
            /* [in] */ d3dRenderStateType state,
            /* [in] */ float *renderstate);



		HRESULT STDMETHODCALLTYPE	getDeviceGuid( 
			/* [out,retval] */	BSTR *ret);


		HRESULT STDMETHODCALLTYPE createStateBlock( long flags, long *retv);

        HRESULT STDMETHODCALLTYPE setClipPlane( long index, float A, float B, float C, float D);

        HRESULT STDMETHODCALLTYPE getClipPlane( long index, float *A, float *B, float *C, float *D);


////////////////////////////////////////////////////////////////////////////////////
private:
    DECL_VARIABLE(_dxj_Direct3dDevice7);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dDevice7)
	void *parent2; 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3ddevice3obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3ddevice3obj.cpp
//
//--------------------------------------------------------------------------

// d3dDeviceObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3d3Obj.h"
#include "d3dDevice3Obj.h"
#include "d3dTexture2Obj.h"
#include "d3dViewport3Obj.h"
#include "ddSurface4Obj.h"
#include "d3dEnumPixelFormatsObj.h"

//////////////////////////////////////////////////////////////////
// C_dxj_Direct3dDevice3Object
//////////////////////////////////////////////////////////////////
C_dxj_Direct3dDevice3Object::C_dxj_Direct3dDevice3Object(){
	m__dxj_Direct3dDevice3=NULL;
	parent=NULL;
	parent2=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	#ifdef DEBUG
	char buffer[256];
	wsprintf(buffer,"Constructor Creation  Direct3dDevice3[%d] \n",g_creationcount);
	OutputDebugString(buffer);
	#endif

	nextobj =  g_dxj_Direct3dDevice3;
	g_dxj_Direct3dDevice3 = (void *)this;
}

//////////////////////////////////////////////////////////////////
// ~C_dxj_Direct3dDevice3Object
//////////////////////////////////////////////////////////////////
C_dxj_Direct3dDevice3Object::~C_dxj_Direct3dDevice3Object()
{
    C_dxj_Direct3dDevice3Object *prev=NULL; 
	for(C_dxj_Direct3dDevice3Object *ptr=(C_dxj_Direct3dDevice3Object *)g_dxj_Direct3dDevice3; ptr; ptr=(C_dxj_Direct3dDevice3Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dDevice3 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dDevice3){
		int count = IUNK(m__dxj_Direct3dDevice3)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer, "DirectX IDirect3dDevice3 Ref count [%d] \n",count);
		#endif

		if(count==0) m__dxj_Direct3dDevice3 = NULL;
	} 
	if(parent) IUNK(parent)->Release();
	if(parent2) IUNK(parent2)->Release();
}


//////////////////////////////////////////////////////////////////
// InternalAddRef
//////////////////////////////////////////////////////////////////
DWORD C_dxj_Direct3dDevice3Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	#ifdef DEBUG
	char szBuf[MAX_PATH];
	wsprintf(szBuf,"Direct3dDevice3[%d] AddRef %d \n",creationid,i);
	OutputDebugString(szBuf);
	#endif
	return i;
}

//////////////////////////////////////////////////////////////////
// InternalRelease
//////////////////////////////////////////////////////////////////
DWORD C_dxj_Direct3dDevice3Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	#ifdef DEBUG
	char szBuf[MAX_PATH];
	wsprintf(szBuf,"Direct3dDevice3 [%d] Release %d \n",creationid,i);
	OutputDebugString(szBuf);
	#endif
	return i;
}

//////////////////////////////////////////////////////////////////
// InternalGetObject
// InternalSetObject
//////////////////////////////////////////////////////////////////
GETSET_OBJECT(_dxj_Direct3dDevice3);

//////////////////////////////////////////////////////////////////
// addViewport
// begin
// beginScene
// deleteViewport
// endScene
// setClipStatus
// setLightState
// setRenderState
// getClipStatus
// getStats
// getDirect3d
// getLightState
// getRenderState
// index
//////////////////////////////////////////////////////////////////
DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dDevice3, addViewport, AddViewport, _dxj_Direct3dViewport3);
PASS_THROUGH_CAST_3_R(_dxj_Direct3dDevice3, begin, Begin, d3dPrimitiveType, (D3DPRIMITIVETYPE),d3dVertexType, (D3DVERTEXTYPE),long,(DWORD));
PASS_THROUGH_R(_dxj_Direct3dDevice3, beginScene, BeginScene);
DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dDevice3, deleteViewport, DeleteViewport, _dxj_Direct3dViewport3);
PASS_THROUGH_R(_dxj_Direct3dDevice3, endScene, EndScene);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dDevice3, setClipStatus, SetClipStatus, D3dClipStatus*,(D3DCLIPSTATUS*));
PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice3, setLightState, SetLightState, long ,(D3DLIGHTSTATETYPE), long ,(DWORD));
PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice3, setRenderState, SetRenderState, long,(D3DRENDERSTATETYPE), long ,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dDevice3, getClipStatus, GetClipStatus, D3dClipStatus*, (D3DCLIPSTATUS *));


PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice3, getLightState, GetLightState, long ,(D3DLIGHTSTATETYPE), long*,(DWORD*));
PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice3, getRenderState, GetRenderState, long ,(D3DRENDERSTATETYPE), long*,(DWORD*));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dDevice3, index, Index, short,(WORD));

//////////////////////////////////////////////////////////////////
// end
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice3Object::end(){
	HRESULT hr;
	hr=m__dxj_Direct3dDevice3->End(0);
	return hr;
}

//////////////////////////////////////////////////////////////////
// getRenderTarget
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice3Object::getRenderTarget(I_dxj_DirectDrawSurface4 **ppsurf)
{
	#pragma message ("fix in Dx5 interface")

	LPDIRECTDRAWSURFACE4	lpSurf4=NULL;
	HRESULT hr;
	hr=m__dxj_Direct3dDevice3->GetRenderTarget(&lpSurf4);
	
	INTERNAL_CREATE(_dxj_DirectDrawSurface4, lpSurf4, ppsurf);
	
	return S_OK;
}


//////////////////////////////////////////////////////////////////
// getTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice3Object::getTransform(long transtype,
								D3dMatrix *m){	
	return m__dxj_Direct3dDevice3->GetTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX)m);
}

//////////////////////////////////////////////////////////////////
// multiplyTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice3Object::multiplyTransform(long transtype,
								D3dMatrix *m){	
	return m__dxj_Direct3dDevice3->MultiplyTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX) m);
}

//////////////////////////////////////////////////////////////////
// setTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice3Object::setTransform(long transtype,
								D3dMatrix  *m){	
	return m__dxj_Direct3dDevice3->SetTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX) m);
}

//////////////////////////////////////////////////////////////////
// nextViewport
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice3Object::nextViewport(I_dxj_Direct3dViewport3 *ref, long flags, I_dxj_Direct3dViewport3 **vp)
{
	if (!ref) return E_INVALIDARG;
	LPDIRECT3DVIEWPORT3	lpvp;
	DO_GETOBJECT_NOTNULL(LPDIRECT3DVIEWPORT3, lpref, ref);
	HRESULT hr=m__dxj_Direct3dDevice3->NextViewport(lpref, &lpvp, flags);
	if (hr != DD_OK )   return hr;		
	INTERNAL_CREATE(_dxj_Direct3dViewport3, lpvp, vp);
	return S_OK;
}

//////////////////////////////////////////////////////////////////
// setCurrentViewport
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::setCurrentViewport(I_dxj_Direct3dViewport3 *viewport)
{	
	if (!viewport) return E_INVALIDARG;
	DO_GETOBJECT_NOTNULL(LPDIRECT3DVIEWPORT3, lpref, viewport);
	return m__dxj_Direct3dDevice3->SetCurrentViewport(lpref);
}

//////////////////////////////////////////////////////////////////
// setRenderTarget
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::setRenderTarget(I_dxj_DirectDrawSurface4 *surf)
{		
	HRESULT hr;	
	if (!surf) return E_INVALIDARG;
	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE4, lpref, surf);
	hr= m__dxj_Direct3dDevice3->SetRenderTarget(lpref,0);
	return hr;
}
		

//////////////////////////////////////////////////////////////////
// getCurrentViewport
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::getCurrentViewport(I_dxj_Direct3dViewport3 **ppvp)
{
	LPDIRECT3DVIEWPORT3	lpvp=NULL;
	HRESULT hr=m__dxj_Direct3dDevice3->GetCurrentViewport(&lpvp);
	if (hr!= DD_OK )   return hr;
	
	INTERNAL_CREATE(_dxj_Direct3dViewport3, lpvp, ppvp);
	return S_OK;
}


//////////////////////////////////////////////////////////////////
// beginIndexed
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::beginIndexed(
								d3dPrimitiveType  d3dpt,								
								long d3dvt,
								void *verts,
								long vertexCount,
								long flags){

	HRESULT hr;

	__try 	{
		hr= m__dxj_Direct3dDevice3->BeginIndexed(
		  (D3DPRIMITIVETYPE) d3dpt,
		  (DWORD) d3dvt,
		  (void*) verts,
		  (DWORD) vertexCount,
		  (DWORD) flags);	
	}
	__except(1, 1){	
		return DDERR_EXCEPTION;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////
// drawIndexedPrimitive
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::drawIndexedPrimitive(
								d3dPrimitiveType  d3dpt,	
								long d3dvt,
								void *Verts,
								long vertexCount,
								SAFEARRAY **ppsaIndex,
								long indexArraySize,
								long flags){

	HRESULT hr;

	__try {
		hr=m__dxj_Direct3dDevice3->DrawIndexedPrimitive(
			(D3DPRIMITIVETYPE) d3dpt,
			(DWORD) d3dvt,
			(void*) Verts,
			(DWORD)vertexCount,
			(unsigned short*) ((SAFEARRAY*)*ppsaIndex)->pvData,
			(DWORD)indexArraySize,
			(DWORD) flags);
	}
	__except(1, 1){	
		return DDERR_EXCEPTION;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////
// drawPrimitive
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::drawPrimitive(
								d3dPrimitiveType  d3dpt,
								long d3dvt,								
								void* Verts,
								long vertexCount,
								long flags){
	HRESULT hr;
	__try {
		hr= m__dxj_Direct3dDevice3->DrawPrimitive(
			(D3DPRIMITIVETYPE) d3dpt,
			(DWORD) d3dvt,
			(void*) Verts,
			(DWORD)vertexCount,
			(DWORD) flags);
	}
	__except(1, 1){	
		return DDERR_EXCEPTION;
	}
	return hr;
}

//////////////////////////////////////////////////////////////////
// vertex
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::vertex(void *vert){		
	HRESULT hr;
	__try {
		hr=m__dxj_Direct3dDevice3->Vertex((void*)vert);
	}
	__except(1,1){
		return DDERR_EXCEPTION;
	}
	return hr;
};

//////////////////////////////////////////////////////////////////
// getTextureFormatsEnum
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::getTextureFormatsEnum(I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	hr=C_dxj_D3DEnumPixelFormatsObject::create(m__dxj_Direct3dDevice3,ppRet);
	return hr;
}



//////////////////////////////////////////////////////////////////
// computeSphereVisibility
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::computeSphereVisibility( 
            D3dVector __RPC_FAR *center,
            float __RPC_FAR *radi,
            /* [retval][out] */ long __RPC_FAR *returnVal)
{
		HRESULT hr=m__dxj_Direct3dDevice3->ComputeSphereVisibility((LPD3DVECTOR)center,radi,1,0,(DWORD*)returnVal);
		return hr;
}

//////////////////////////////////////////////////////////////////
// drawIndexedPrimitiveVB
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::drawIndexedPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer __RPC_FAR *vertexBuffer,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indexArray,
            /* [in] */ long indexcount,
            /* [in] */ long flags)
{
	HRESULT hr;

	if (!indexArray) return E_FAIL;

	DO_GETOBJECT_NOTNULL(  LPDIRECT3DVERTEXBUFFER , lpVB, vertexBuffer);
	__try{

		hr=m__dxj_Direct3dDevice3->DrawIndexedPrimitiveVB
			((D3DPRIMITIVETYPE)d3dpt,
			lpVB,
			(WORD*) ((SAFEARRAY*)*indexArray)->pvData,					
			(DWORD)indexcount,
			(DWORD)flags);

	}
	__except(1,1){
		return DDERR_EXCEPTION;
	}
	return hr;
}
        
//////////////////////////////////////////////////////////////////
// drawPrimitiveVB
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::drawPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer __RPC_FAR *vertexBuffer,            
            /* [in] */ long startVertex,
            /* [in] */ long numVertices,
            /* [in] */ long flags)
{
	HRESULT hr;


	DO_GETOBJECT_NOTNULL(  LPDIRECT3DVERTEXBUFFER , lpVB, vertexBuffer);
	__try{

		hr=m__dxj_Direct3dDevice3->DrawPrimitiveVB
			((D3DPRIMITIVETYPE)d3dpt,
			lpVB,
			(DWORD) startVertex,
			(DWORD) numVertices,
			(DWORD)flags);

	}
	__except(1,1){

		return DDERR_EXCEPTION;
	}
	return hr;
}



//////////////////////////////////////////////////////////////////
// validateDevice
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::validateDevice( 
            /* [retval][out] */ long __RPC_FAR *passes)
{
	HRESULT hr=m__dxj_Direct3dDevice3->ValidateDevice((DWORD*)passes);
	return hr;
}

//////////////////////////////////////////////////////////////////
// getTexture
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::getTexture( 
            /* [in] */ long stage,
            /* [retval][out] */ I_dxj_Direct3dTexture2 __RPC_FAR *__RPC_FAR *retv)
{
	LPDIRECT3DTEXTURE2 lpNew=NULL;
	HRESULT hr;

	*retv=NULL;
	hr=m__dxj_Direct3dDevice3->GetTexture((DWORD)stage,&lpNew);
	
	//null is valid
	if (lpNew==NULL) return S_OK;

	INTERNAL_CREATE(_dxj_Direct3dTexture2, lpNew, retv);	
	if (*retv==NULL) return E_OUTOFMEMORY;

	return hr;
}

//////////////////////////////////////////////////////////////////
// getTextureStageState
//////////////////////////////////////////////////////////////////			
STDMETHODIMP C_dxj_Direct3dDevice3Object::getTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [retval][out] */ long __RPC_FAR *retv)
{
	HRESULT hr;
	hr=m__dxj_Direct3dDevice3->GetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, (DWORD*)retv);
	return hr;
}

//////////////////////////////////////////////////////////////////
// setTexture
//////////////////////////////////////////////////////////////////			
STDMETHODIMP C_dxj_Direct3dDevice3Object::setTexture( 
             long stage,
             I_dxj_Direct3dTexture2  *tex)
{
	
	HRESULT hr;

	if (tex==NULL)
	{ 
		hr=m__dxj_Direct3dDevice3->SetTexture((DWORD)stage,NULL);
	}
	else 
	{
		DO_GETOBJECT_NOTNULL(LPDIRECT3DTEXTURE2, lpTex, tex);	
		hr=m__dxj_Direct3dDevice3->SetTexture((DWORD)stage,lpTex);
	}
	return hr;
}


//////////////////////////////////////////////////////////////////
// setTextureStageState
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice3Object::setTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ long val)
{
	HRESULT hr;
	hr=m__dxj_Direct3dDevice3->SetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, (DWORD)val);
	return hr;
}
        

//////////////////////////////////////////////////////////////////
// getCaps
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice3Object::getCaps( 
            D3dDeviceDesc *a,D3dDeviceDesc *b)
{
	if (a) a->lSize=sizeof(D3DDEVICEDESC);
	if (b) b->lSize=sizeof(D3DDEVICEDESC);

	HRESULT hr;
	hr=m__dxj_Direct3dDevice3->GetCaps((D3DDEVICEDESC*)a,(D3DDEVICEDESC*)b);
	return hr;
}


//////////////////////////////////////////////////////////////////
// getDirect3D
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice3Object::getDirect3D( I_dxj_Direct3d3 **ret)
{

	HRESULT hr;
	LPDIRECT3D3 lpD3D=NULL;
	hr=m__dxj_Direct3dDevice3->GetDirect3D(&lpD3D);
	if FAILED(hr) return hr;
	if (!lpD3D) return E_FAIL;
	INTERNAL_CREATE(_dxj_Direct3d3,lpD3D,ret);
	return hr;

}



//////////////////////////////////////////////////////////////////
// getStats
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice3Object::getStats( D3dStats *stats)
{

	HRESULT hr;
	if (!stats) return E_INVALIDARG;
	D3DSTATS *lpStats=(D3DSTATS*)stats;
	lpStats->dwSize=sizeof(D3DSTATS);
	hr=m__dxj_Direct3dDevice3->GetStats(lpStats);

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3ddevice7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3ddevice7obj.cpp
//
//--------------------------------------------------------------------------

// d3dDeviceObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3d7Obj.h"
#include "d3dDevice7Obj.h"
#include "ddSurface7Obj.h"
#include "d3dEnumPixelFormats7Obj.h"

extern BSTR D3DGUIDtoBSTR(LPGUID);


//////////////////////////////////////////////////////////////////
// C_dxj_Direct3dDevice7Object
//////////////////////////////////////////////////////////////////
C_dxj_Direct3dDevice7Object::C_dxj_Direct3dDevice7Object(){
	m__dxj_Direct3dDevice7=NULL;
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;
	DPF1(1,"Constructor Creation  Direct3dDevice7[%d] \n",g_creationcount);
	

	nextobj =  g_dxj_Direct3dDevice7;
	g_dxj_Direct3dDevice7 = (void *)this;
}

//////////////////////////////////////////////////////////////////
// ~C_dxj_Direct3dDevice7Object
//////////////////////////////////////////////////////////////////
C_dxj_Direct3dDevice7Object::~C_dxj_Direct3dDevice7Object()
{
    C_dxj_Direct3dDevice7Object *prev=NULL; 
	for(C_dxj_Direct3dDevice7Object *ptr=(C_dxj_Direct3dDevice7Object *)g_dxj_Direct3dDevice7; ptr; ptr=(C_dxj_Direct3dDevice7Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dDevice7 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dDevice7){
		int count = IUNK(m__dxj_Direct3dDevice7)->Release();
		
		DPF1(1, "DirectX IDirect3dDevice7 Ref count [%d] \n",count);

		if(count==0) m__dxj_Direct3dDevice7 = NULL;
	} 
	if(parent) IUNK(parent)->Release();
	if(parent2) IUNK(parent2)->Release();
	
	parent=NULL;
	parent2=NULL;
}


///////////////// /////////////////////////////////////////////////
// InternalAddRef
//////////////////////////////////////////////////////////////////
DWORD C_dxj_Direct3dDevice7Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dDevice7[%d] AddRef %d \n",creationid,i);
	
	return i;
}

//////////////////////////////////////////////////////////////////
// InternalRelease
//////////////////////////////////////////////////////////////////
DWORD C_dxj_Direct3dDevice7Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(szBuf,"Direct3dDevice7 [%d] Release %d \n",creationid,i);
	
	return i;
}

//////////////////////////////////////////////////////////////////
// InternalGetObject
// InternalSetObject
//////////////////////////////////////////////////////////////////
GETSET_OBJECT(_dxj_Direct3dDevice7);

//////////////////////////////////////////////////////////////////
// beginScene
// endScene
// setClipStatus
// setLightState
// setRenderState
// getClipStatus
// getLightState
// getRenderState
//////////////////////////////////////////////////////////////////
PASS_THROUGH_R(_dxj_Direct3dDevice7, beginScene, BeginScene);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dDevice7, setClipStatus, SetClipStatus, D3dClipStatus*,(D3DCLIPSTATUS*));
PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice7, setRenderState, SetRenderState, long,(D3DRENDERSTATETYPE), long ,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dDevice7, getClipStatus, GetClipStatus, D3dClipStatus*, (D3DCLIPSTATUS *));
PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice7, getRenderState, GetRenderState, long ,(D3DRENDERSTATETYPE), long*,(DWORD*));

//////////////////////////////////////////////////////////////////
// endScene
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::endScene()
{

	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->EndScene();


	#ifdef _X86_
		_asm FINIT
	#endif
	return hr;
}


//////////////////////////////////////////////////////////////////
// getRenderTarget
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::getRenderTarget(I_dxj_DirectDrawSurface7 **ppsurf)
{	

	LPDIRECTDRAWSURFACE7	lpSurf=NULL;
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->GetRenderTarget(&lpSurf);
	
	INTERNAL_CREATE(_dxj_DirectDrawSurface7, lpSurf, ppsurf);
	
	return S_OK;
}


//////////////////////////////////////////////////////////////////
// getTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTransform(long transtype,
								D3dMatrix *m){	
	return m__dxj_Direct3dDevice7->GetTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX)m);
}

//////////////////////////////////////////////////////////////////
// multiplyTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::multiplyTransform(long transtype,
								D3dMatrix *m){	
	return m__dxj_Direct3dDevice7->MultiplyTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX) m);
}

//////////////////////////////////////////////////////////////////
// setTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::setTransform(long transtype,
								D3dMatrix  *m){	
	return m__dxj_Direct3dDevice7->SetTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX) m);
}


//////////////////////////////////////////////////////////////////
// setRenderTarget
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::setRenderTarget(I_dxj_DirectDrawSurface7 *surf)
{		
	HRESULT hr;	
	if (!surf) return E_INVALIDARG;
	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7, lpref, surf);
	hr= m__dxj_Direct3dDevice7->SetRenderTarget(lpref,0);
	return hr;
}
		




//////////////////////////////////////////////////////////////////
// getTextureFormatsEnum
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTextureFormatsEnum(I_dxj_Direct3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	hr=C_dxj_Direct3DEnumPixelFormats7Object::create1(m__dxj_Direct3dDevice7,ppRet);
	return hr;
}





//////////////////////////////////////////////////////////////////
// validateDevice
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::validateDevice( 
            /* [retval][out] */ long __RPC_FAR *passes)
{
	HRESULT hr=m__dxj_Direct3dDevice7->ValidateDevice((DWORD*)passes);
	return hr;
}

//////////////////////////////////////////////////////////////////
// getTexture
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTexture( 
            /* [in] */ long stage,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv)
{
	LPDIRECTDRAWSURFACE7 lpNew=NULL;
	HRESULT hr;

	*retv=NULL;
	hr=m__dxj_Direct3dDevice7->GetTexture((DWORD)stage,&lpNew);
	
	//null is valid
	if (lpNew==NULL) return S_OK;

	INTERNAL_CREATE(_dxj_DirectDrawSurface7, lpNew, retv);	
	if (*retv==NULL) return E_OUTOFMEMORY;

	return hr;
}

//////////////////////////////////////////////////////////////////
// getTextureStageState
//////////////////////////////////////////////////////////////////			
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [retval][out] */ long __RPC_FAR *retv)
{
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->GetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, (DWORD*)retv);
	return hr;
}

//////////////////////////////////////////////////////////////////
// setTexture
//////////////////////////////////////////////////////////////////			
STDMETHODIMP C_dxj_Direct3dDevice7Object::setTexture( 
             long stage,
             I_dxj_DirectDrawSurface7  *tex)
{
	
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7, lpTex, tex);	
	hr=m__dxj_Direct3dDevice7->SetTexture((DWORD)stage,lpTex);

	return hr;
}


//////////////////////////////////////////////////////////////////
// setTextureStageState
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ long val)
{
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->SetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, (DWORD)val);
	return hr;
}
        

//////////////////////////////////////////////////////////////////
// getCaps
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getCaps( 
            D3dDeviceDesc7 *a)
{
	//if (a) a->lSize=sizeof(D3DDEVICEDESC7);
	

	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->GetCaps((D3DDEVICEDESC7*)a);
	return hr;
}


//////////////////////////////////////////////////////////////////
// getDirect3D
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getDirect3D( I_dxj_Direct3d7 **ret)
{

	HRESULT hr;
	LPDIRECT3D7 lpD3D=NULL;
	hr=m__dxj_Direct3dDevice7->GetDirect3D(&lpD3D);
	if FAILED(hr) return hr;
	if (!lpD3D) return E_FAIL;
	INTERNAL_CREATE(_dxj_Direct3d7,lpD3D,ret);
	return hr;

}



//////////////////////////////////////////////////////////////////
// setViewport
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setViewport( D3dViewport7 *viewport)
{

	HRESULT hr;	
	if(!viewport) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->SetViewport((D3DVIEWPORT7*)viewport);		
	return hr;

}

//////////////////////////////////////////////////////////////////
// getViewport
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getViewport( D3dViewport7 *viewport)
{

	HRESULT hr;	
	if(!viewport) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->GetViewport((D3DVIEWPORT7*)viewport);		
	return hr;

}

//////////////////////////////////////////////////////////////////
// setMaterial
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setMaterial( D3dMaterial7 *mat)
{

	HRESULT hr;	
	if(!mat) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->SetMaterial((D3DMATERIAL7*)mat);		
	return hr;

}

//////////////////////////////////////////////////////////////////
// getMaterial
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getMaterial( D3dMaterial7 *mat)
{

	HRESULT hr;	
	if(!mat) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->GetMaterial((D3DMATERIAL7*)mat);		
	return hr;

}



//////////////////////////////////////////////////////////////////
// setLight
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setLight( long i,D3dLight7 *lgt)
{

	HRESULT hr;	
	if(!lgt) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->SetLight((DWORD)i,(D3DLIGHT7*)lgt);		
	return hr;

}

//////////////////////////////////////////////////////////////////
// getLight
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getLight( long i,D3dLight7 *lgt)
{

	HRESULT hr;	
	if(!lgt) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->GetLight((DWORD)i,(D3DLIGHT7*)lgt);		
	return hr;

}


//////////////////////////////////////////////////////////////////
// beginStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::beginStateBlock()
{

	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->BeginStateBlock();		
	return hr;

}

//////////////////////////////////////////////////////////////////
// endStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::endStateBlock( long *retv)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->EndStateBlock((DWORD*)retv);		
	return hr;
}


//////////////////////////////////////////////////////////////////
// deleteStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::deleteStateBlock(long m)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->DeleteStateBlock((DWORD)m);		
	return hr;
}
        
//////////////////////////////////////////////////////////////////
// ApplyStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::applyStateBlock(long m)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->ApplyStateBlock((DWORD)m);		
	return hr;
}

//////////////////////////////////////////////////////////////////
// createStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::createStateBlock(long type, long *retval)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->CreateStateBlock((D3DSTATEBLOCKTYPE)type,(DWORD*)retval);		
	return hr;
}
        
//////////////////////////////////////////////////////////////////
// captureStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::captureStateBlock(long m)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->CaptureStateBlock((DWORD)m);		
	return hr;
}
    


//////////////////////////////////////////////////////////////////
// lightEnable
//////////////////////////////////////////////////////////////////					
STDMETHODIMP C_dxj_Direct3dDevice7Object::lightEnable( long index,  VARIANT_BOOL b){
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->LightEnable((DWORD)index,(b!=VARIANT_FALSE));
	return hr;
}

//////////////////////////////////////////////////////////////////
// lightEnable
//////////////////////////////////////////////////////////////////					
STDMETHODIMP C_dxj_Direct3dDevice7Object::getLightEnable( long index,  VARIANT_BOOL *bOut){
	HRESULT hr;
	BOOL	b;
	hr=m__dxj_Direct3dDevice7->GetLightEnable((DWORD)index,&b);
	if (b){
		*bOut=VARIANT_TRUE;
	}
	else {
		*bOut=VARIANT_FALSE;
	}
	return hr;
}


//////////////////////////////////////////////////////////////////
// drawIndexedPrimitive
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::drawIndexedPrimitive(
								d3dPrimitiveType  d3dpt,	
								long d3dvt,
								void *Verts,
								long vertexCount,
								SAFEARRAY **ppsaIndex,
								long indexArraySize,
								long flags){

	HRESULT hr;

	__try {
		hr=m__dxj_Direct3dDevice7->DrawIndexedPrimitive(
			(D3DPRIMITIVETYPE) d3dpt,
			(DWORD) d3dvt,
			(void*) Verts,
			(DWORD)vertexCount,
			(unsigned short*) ((SAFEARRAY*)*ppsaIndex)->pvData,
			(DWORD)indexArraySize,
			(DWORD) flags);
	}
	__except(1, 1){	
		return DDERR_EXCEPTION;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////
// drawPrimitive
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::drawPrimitive(
								d3dPrimitiveType  d3dpt,
								long d3dvt,								
								void* Verts,
								long vertexCount,
								long flags){
	HRESULT hr;
	__try {
		hr= m__dxj_Direct3dDevice7->DrawPrimitive(
			(D3DPRIMITIVETYPE) d3dpt,
			(DWORD) d3dvt,
			(void*) Verts,
			(DWORD)vertexCount,
			(DWORD) flags);
	}
	__except(1, 1){	
		return DDERR_EXCEPTION;
	}
	return hr;
}


//////////////////////////////////////////////////////////////////
// clear
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::clear(long count,SAFEARRAY **psa, long flags, long color, float z, long stencil )
{		 	
	if (!ISSAFEARRAY1D(psa,(DWORD)count)) return E_INVALIDARG;		
	return m__dxj_Direct3dDevice7->Clear( (DWORD)count,(D3DRECT*)((SAFEARRAY*)*psa)->pvData, flags ,color,z,stencil); 
}


//////////////////////////////////////////////////////////////////
// computeSphereVisibility
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::computeSphereVisibility( 
            D3dVector __RPC_FAR *center,
            float __RPC_FAR *radi,
            /* [retval][out] */ long __RPC_FAR *returnVal)
{
		HRESULT hr=m__dxj_Direct3dDevice7->ComputeSphereVisibility((LPD3DVECTOR)center,radi,1,0,(DWORD*)returnVal);
		return hr;
}

//////////////////////////////////////////////////////////////////
// drawIndexedPrimitiveVB
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::drawIndexedPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vertexBuffer,
					   long startIndex,
					   long numIndex,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indexArray,
            /* [in] */ long indexcount,
            /* [in] */ long flags)
{
	HRESULT hr;

	if (!indexArray) return E_FAIL;

	DO_GETOBJECT_NOTNULL(  LPDIRECT3DVERTEXBUFFER7 , lpVB, vertexBuffer);
	__try{

		hr=m__dxj_Direct3dDevice7->DrawIndexedPrimitiveVB
			((D3DPRIMITIVETYPE)d3dpt,
			lpVB,
			(DWORD) startIndex,
			(DWORD) numIndex,
			(WORD*) ((SAFEARRAY*)*indexArray)->pvData,					
			(DWORD)indexcount,
			(DWORD)flags);

	}
	__except(1,1){
		return DDERR_EXCEPTION;
	}
	return hr;
}
        
//////////////////////////////////////////////////////////////////
// drawPrimitiveVB
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::drawPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vertexBuffer,            
            /* [in] */ long startVertex,
            /* [in] */ long numVertices,
            /* [in] */ long flags)
{
	HRESULT hr;


	DO_GETOBJECT_NOTNULL(  LPDIRECT3DVERTEXBUFFER7 , lpVB, vertexBuffer);
	__try{

		hr=m__dxj_Direct3dDevice7->DrawPrimitiveVB
			((D3DPRIMITIVETYPE)d3dpt,
			lpVB,
			(DWORD) startVertex,
			(DWORD) numVertices,
			(DWORD)flags);

	}
	__except(1,1){

		return DDERR_EXCEPTION;
	}
	return hr;
}


STDMETHODIMP C_dxj_Direct3dDevice7Object::preLoad( I_dxj_DirectDrawSurface7 *surf)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(  LPDIRECTDRAWSURFACE7 , lpSurf, surf);
	hr= m__dxj_Direct3dDevice7->PreLoad(lpSurf);
	return hr;
}



//////////////////////////////////////////////////////////////////
// load
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::load( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *tex1,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *tex2,
            /* [in] */ Rect __RPC_FAR *rc,
            /* [in] */ long flags)
{
	HRESULT hr;	
	
	if (!tex1) return E_INVALIDARG;
	if (!tex2) return E_INVALIDARG;
	if (!rc) return E_INVALIDARG;

	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7,lpTex1,tex1);
	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7,lpTex2,tex2);

	//dont allow this as it gpfs some drivers and is invalid anyway
	if (lpTex1==lpTex2) return E_INVALIDARG;

	POINT p;
	p.x=x;
	p.y=y;

	hr=m__dxj_Direct3dDevice7->Load(lpTex1,&p,lpTex2,(LPRECT)rc,(DWORD)flags);

	return hr;
}


//PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice7, setRenderState, SetRenderState, long,(D3DRENDERSTATETYPE), long ,(DWORD));


//////////////////////////////////////////////////////////////////
// setRenderStateSingle
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setRenderStateSingle( 
            /* [in] */ long renderstate,            
            /* [in] */ float val)
{
	HRESULT hr;	 
	hr=m__dxj_Direct3dDevice7->SetRenderState((D3DRENDERSTATETYPE) renderstate, *((DWORD*)&val));
	return hr;
}


//////////////////////////////////////////////////////////////////
// getRenderStateSingle
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getRenderStateSingle( 
            /* [in] */ long renderstate,            
            /* [in] */ float *val)
{
	HRESULT hr;	 
	hr=m__dxj_Direct3dDevice7->GetRenderState((D3DRENDERSTATETYPE) renderstate, (DWORD*)val);
	return hr;
}



//////////////////////////////////////////////////////////////////
// setTextureStageStateSingle
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setTextureStageStateSingle( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ float val)
{
	HRESULT hr;
	 
	hr=m__dxj_Direct3dDevice7->SetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, *((DWORD*)&val));
	return hr;
}
        

//////////////////////////////////////////////////////////////////
// getTextureStageState
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTextureStageStateSingle( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ float *val)
{
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->GetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, (DWORD*)val);
	return hr;
}
        

//////////////////////////////////////////////////////////////////
// getInfo
//////////////////////////////////////////////////////////////////				
        
STDMETHODIMP C_dxj_Direct3dDevice7Object::getInfo( 
            /* [in] */ long lDevInfoID,
            /* [out][in] */ void __RPC_FAR *DevInfoType,
            /* [in] */ long lSize)
{
	HRESULT hr;
	__try 
	{
		hr=m__dxj_Direct3dDevice7->GetInfo((DWORD)lDevInfoID,DevInfoType, (DWORD)lSize);
	}
	__except(1,1)
	{
		return E_FAIL;
	}
	return hr;
}


//////////////////////////////////////////////////////////////////
// getDeviceGuid
//////////////////////////////////////////////////////////////////				
        
STDMETHODIMP C_dxj_Direct3dDevice7Object::getDeviceGuid( BSTR *ret)
{
	HRESULT hr;
	D3DDEVICEDESC7 desc;
	
	if (!ret) return E_INVALIDARG;

	//desc.dwSize=sizeof(D3DDEVICEDESC7);
		
	hr=m__dxj_Direct3dDevice7->GetCaps(&desc);
	if FAILED(hr) return hr;


	*ret=D3DGUIDtoBSTR(&desc.deviceGUID);
	return hr;

}



//////////////////////////////////////////////////////////////////
// setClipPlane
//////////////////////////////////////////////////////////////////				
        
STDMETHODIMP C_dxj_Direct3dDevice7Object::setClipPlane(long index,float A, float B, float C, float D)
{
    HRESULT hr;		
    float floats[4];
    
    floats[0]=A;
    floats[1]=B;
    floats[2]=C;
    floats[3]=D;

	hr=m__dxj_Direct3dDevice7->SetClipPlane((DWORD)index, floats);

	return hr;

}

//////////////////////////////////////////////////////////////////
// setClipPlane
//////////////////////////////////////////////////////////////////				
        
STDMETHODIMP C_dxj_Direct3dDevice7Object::getClipPlane(long index,float *A, float *B, float *C, float *D)
{
    HRESULT hr;		
    float floats[4];
    
	hr=m__dxj_Direct3dDevice7->GetClipPlane((DWORD)index, floats);
    if FAILED(hr) return hr;
    
    *A=floats[0];
    *B=floats[1];
    *C=floats[2];
    *D=floats[3];

	return hr;

}


        
#if 0 
//////////////////////////////////////////////////////////////////
// clear
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::clear( 
            /* [in] */ long l1,
            /* [in] */ D3dRect __RPC_FAR *rc,
            /* [in] */ long l2,
            /* [in] */ long color,
            /* [in] */ float z,
            /* [in] */ long l3)
{
	HRESULT hr;
	if (!rc) return E_INVALIDARG;
	__try{
		hr=m__dxj_Direct3dDevice7->Clear((DWORD)l1,(D3DRECT*)rc,(DWORD)l2,(DWORD)color,(float)z,(DWORD)l3);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	
	return hr;
}

//////////////////////////////////////////////////////////////////
// setVertexComponent
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setVertexComponent(  
  		    /* [in] */ long __RPC_FAR component,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vb,
            /* [in] */ long l1,
            /* [in] */ long l2)
{
	HRESULT hr;
	if (!vb) return E_INVALIDARG;
	DO_GETOBJECT_NOTNULL(LPDIRECT3DVERTEXBUFFER7,pVB,vb);

	hr=m__dxj_Direct3dDevice7->SetVertexComponent((D3DVERTEXCOMPONENT)component, pVB,(DWORD)l1,(DWORD)l2);
	return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3denumpixelformatsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3denumpixelformatsobj.h
//
//--------------------------------------------------------------------------




#include "resource.h"       

class C_dxj_D3DEnumPixelFormatsObject : 
	public I_dxj_Direct3DEnumPixelFormats7,
	public CComObjectRoot
{
public:
	C_dxj_D3DEnumPixelFormatsObject() ;
	virtual ~C_dxj_D3DEnumPixelFormatsObject() ;

BEGIN_COM_MAP(C_dxj_D3DEnumPixelFormatsObject)
	COM_INTERFACE_ENTRY(I_dxj_Direct3DEnumPixelFormats7)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_D3DEnumPixelFormatsObject)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, DDPixelFormat *info);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		static HRESULT C_dxj_D3DEnumPixelFormatsObject::create(LPDIRECT3DDEVICE3 pd3d,  I_dxj_Direct3DEnumPixelFormats7 **ppRet);
		static HRESULT C_dxj_D3DEnumPixelFormatsObject::create2(LPDIRECT3D3 pd3d,  BSTR strGuid, I_dxj_Direct3DEnumPixelFormats7 **ppRet);
		//static HRESULT C_dxj_D3DEnumPixelFormatsObject::create3(LPDIRECT3DDEVICE7 pd3d,  I_dxj_D3DEnumPixelFormats **ppRet);
		//static HRESULT C_dxj_D3DEnumPixelFormatsObject::create4(LPDIRECT3D7 pd3d,  BSTR strGuid, I_dxj_D3DEnumPixelFormats **ppRet);
				                 
public:
		DDPIXELFORMAT	*m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3d7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3d7obj.cpp
//
//--------------------------------------------------------------------------

// d3dObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3d7Obj.h"
#include "d3dDevice7Obj.h"
#include "d3dEnumDevices7Obj.h"
#include "ddSurface7Obj.h"
#include "D3DEnumPixelFormats7Obj.h"
#include "d3dVertexBuffer7Obj.h"
#include "dDraw7Obj.h"

typedef HRESULT (__stdcall *DDRAWCREATE)( GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter );

extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT D3DBSTRtoGUID(LPGUID,BSTR);
extern BSTR D3DGUIDtoBSTR(LPGUID);


C_dxj_Direct3d7Object::C_dxj_Direct3d7Object(){
	m__dxj_Direct3d7=NULL;
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3d3[%d] \n ",g_creationcount);
	
	nextobj =  g_dxj_Direct3d7;
	g_dxj_Direct3d7 = (void *)this;
}


C_dxj_Direct3d7Object::~C_dxj_Direct3d7Object()
{
    C_dxj_Direct3d7Object *prev=NULL; 
	for(C_dxj_Direct3d7Object *ptr=(C_dxj_Direct3d7Object *)g_dxj_Direct3d7; ptr; ptr=(C_dxj_Direct3d7Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3d7 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3d7){
		int count = IUNK(m__dxj_Direct3d7)->Release();
		
		DPF1(1,"DirectX IDirect3d7 Ref count [%d] \n",count);
		

		if(count==0) m__dxj_Direct3d7 = NULL;
	} 
	if(parent) IUNK(parent)->Release();
}



DWORD C_dxj_Direct3d7Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();	
	DPF2(1,"Direct3d3[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3d7Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3d7 [%d] Release %d \n",creationid,i);
	return i;
}


GETSET_OBJECT(_dxj_Direct3d7);

#if 0
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3d7Object::findDevice(D3dFindDeviceSearch *ds, D3dFindDeviceResult7 *dr )
{
	HRESULT hr;
	
	


	//Fixup FindDeviceSearch
	ds->lSize  = sizeof(D3DFINDDEVICESEARCH);
	ds->dpcPrimCaps.lSize =sizeof(D3DPRIMCAPS);		
	ZeroMemory((LPGUID)&(ds->guidStruct),sizeof(GUID));
	hr=BSTRtoGUID((LPGUID)&(ds->guidStruct), ds->strGuid);

	//if FAILED(hr) return E_INVALIDARG;
	
	//Fixup FindDeviceResult
	memset(dr,0,sizeof(D3DFINDDEVICERESULT7));
	dr->lSize = sizeof(D3DFINDDEVICERESULT7);
	dr->ddHwDesc.lSize=sizeof(D3DDEVICEDESC7);
	dr->ddSwDesc.lSize=sizeof(D3DDEVICEDESC7);
	


	// NOTE THE TOP PORTIONS OF D3dFindDeviceSearch and D3dFindDeviceResult
	// are the same As D3DFINDEVICSEARCH and D3DFINDRESULT
	// 
	hr = m__dxj_Direct3d7->FindDevice((D3DFINDDEVICESEARCH*)ds, (D3DFINDDEVICERESULT7*)dr);

	dr->strGuid=D3DGUIDtoBSTR((LPGUID) &(dr->guidStruct));
		
	return hr;
}
#endif

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3d7Object::getDevicesEnum(I_dxj_Direct3DEnumDevices **ppRet)
{
	HRESULT hr=E_FAIL;
	hr=C_dxj_Direct3DEnumDevices7Object::create(m__dxj_Direct3d7,ppRet);

	return hr;
}

//TODO tighter code produced if made into an inline function
//and use a for loop to compare byte by byte
#define GUIDISEQUAL(a,b) \
	((((DxGuid *)a)->data1==((DxGuid *)b)->data1) && \
	(((DxGuid *)a)->data2==((DxGuid *)b)->data2) && \
	(((DxGuid *)a)->data3==((DxGuid *)b)->data3) && \
	(((DxGuid *)a)->data4[0]==((DxGuid *)b)->data4[0]) && \
	(((DxGuid *)a)->data4[1]==((DxGuid *)b)->data4[1]) && \
	(((DxGuid *)a)->data4[2]==((DxGuid *)b)->data4[2]) && \
	(((DxGuid *)a)->data4[3]==((DxGuid *)b)->data4[3]) && \
	(((DxGuid *)a)->data4[4]==((DxGuid *)b)->data4[4]) && \
	(((DxGuid *)a)->data4[5]==((DxGuid *)b)->data4[5]) && \
	(((DxGuid *)a)->data4[6]==((DxGuid *)b)->data4[6]) && \
	(((DxGuid *)a)->data4[7]==((DxGuid *)b)->data4[7])) 




		
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3d7Object::createDevice(BSTR strClsid, I_dxj_DirectDrawSurface7 *surf,I_dxj_Direct3dDevice7 **retv)
{
	LPDIRECT3DDEVICE7 lpNew=NULL;
	HRESULT hr;

	GUID clsid;

	hr=D3DBSTRtoGUID(&clsid,strClsid);
	if FAILED(hr) return E_INVALIDARG;

	
	//CreateDevice wants a DirectDrawSurface as opposed to 
	//a DirectDrawSurface3 . we implement as cast
	//cause DX allows us to.
	//Consider - Is the cost of a QI call really to much?
	//AK

	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7, lpSurf, surf);
	

	hr=m__dxj_Direct3d7->CreateDevice(clsid,  lpSurf,  &lpNew);

	if FAILED(hr) return hr;
 
	//INTERNAL_CREATE(_dxj_Direct3dDevice3, lpNew, retv);
	INTERNAL_CREATE_2REFS(_dxj_Direct3dDevice7,_dxj_DirectDrawSurface7,surf, lpNew,retv) 
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3d7Object::getDirectDraw(I_dxj_DirectDraw7 **retv)
{
	IDirectDraw7 *pdd7;
	HRESULT hr;
	hr=m__dxj_Direct3d7->QueryInterface(IID_IDirectDraw7,(void**)&pdd7);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_DirectDraw7, pdd7, retv);
        
	return hr; 
}


STDMETHODIMP C_dxj_Direct3d7Object::createVertexBuffer( 
            /* [in] */ D3dVertexBufferDesc *desc,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *__RPC_FAR *f)
{
 
	LPDIRECT3DVERTEXBUFFER7 pBuff=NULL;
	HRESULT hr;
	
	if (!desc) return E_INVALIDARG;
	desc->lSize=sizeof(D3DVERTEXBUFFERDESC);

	hr=m__dxj_Direct3d7->CreateVertexBuffer((LPD3DVERTEXBUFFERDESC) desc,
				&pBuff,
				(DWORD)flags
				);

	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dVertexBuffer7, pBuff, f);


	DWORD fvf=(DWORD)desc->lFVF;
	long  n=0;

	if (fvf == D3DFVF_VERTEX)  n=sizeof(D3DVERTEX);
	else if (fvf == D3DFVF_LVERTEX)  n=sizeof(D3DLVERTEX);
	else if (fvf == D3DFVF_TLVERTEX)  n=sizeof(D3DLVERTEX);
	else 
	{
	 	if (fvf & D3DFVF_DIFFUSE ) n=n+sizeof(DWORD);
		if (fvf & D3DFVF_SPECULAR ) n=n+sizeof(DWORD);	
		if (fvf & D3DFVF_NORMAL  ) n=n+sizeof(float)*3;
		if (fvf & D3DFVF_XYZ   ) n=n+sizeof(float)*3;
		if (fvf & D3DFVF_XYZRHW    ) n=n+sizeof(float)*4;
		if (fvf & D3DFVF_TEX0 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX1 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX2 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX3 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX4 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX5 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX6 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX7 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX8 	    ) n=n+sizeof(float)*2;
	}

	(*f)->setVertexSize(n);

	return S_OK;
}
        
STDMETHODIMP C_dxj_Direct3d7Object::getEnumZBufferFormats( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_Direct3DEnumPixelFormats __RPC_FAR *__RPC_FAR *retval)
{
		
	HRESULT  hr=C_dxj_Direct3DEnumPixelFormats7Object::create2(m__dxj_Direct3d7, guid, retval);
	return hr;
}
        
STDMETHODIMP C_dxj_Direct3d7Object::evictManagedTextures( void)
{
	HRESULT hr;
	hr=m__dxj_Direct3d7->EvictManagedTextures();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3dvertexbuffer7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3dvertexbuffer7obj.h
//
//--------------------------------------------------------------------------

// d3dMaterialObj.h : Declaration of the C_dxj_Direct3dMaterialObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dVertexBuffer7 LPDIRECT3DVERTEXBUFFER7

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dVertexBuffer7Object : 
	public I_dxj_Direct3dVertexBuffer7,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dVertexBuffer7Object() ;
	virtual ~C_dxj_Direct3dVertexBuffer7Object() ;

BEGIN_COM_MAP(C_dxj_Direct3dVertexBuffer7Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dVertexBuffer7)
END_COM_MAP()



DECLARE_AGGREGATABLE(C_dxj_Direct3dVertexBuffer7Object)


public:
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
        HRESULT STDMETHODCALLTYPE getVertexBufferDesc( 
            /* [out][in] */ D3dVertexBufferDesc __RPC_FAR *desc);
        
        HRESULT STDMETHODCALLTYPE lock( 
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE unlock( void);
        
        HRESULT STDMETHODCALLTYPE optimize( 
            /* [in] */ I_dxj_Direct3dDevice7 __RPC_FAR *dev
            );
        
        HRESULT STDMETHODCALLTYPE processVertices( 
            /* [in] */ long vertexOp,
            /* [in] */ long destIndex,
            /* [in] */ long count,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *srcBuffer,
            /* [in] */ long srcIndex,
            /* [in] */ I_dxj_Direct3dDevice7 __RPC_FAR *dev,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE setVertices( 
            /* [in] */ long startIndex,
            /* [in] */ long count,
            /* [in] */ void __RPC_FAR *verts);
        
        HRESULT STDMETHODCALLTYPE getVertices( 
            /* [in] */ long startIndex,
            /* [in] */ long count,
            /* [in] */ void __RPC_FAR *verts);

		HRESULT STDMETHODCALLTYPE setVertexSize( /* [in] */ long n);

private:
    DECL_VARIABLE(_dxj_Direct3dVertexBuffer7);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dVertexBuffer7)
	void	*m_pData;
	DWORD	m_vertSize;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3ddevice3obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3ddevice3obj.h
//
//--------------------------------------------------------------------------

// d3dDeviceObj.h : Declaration of the C_dxj_Direct3dDeviceObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dDevice3 LPDIRECT3DDEVICE3

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't
//          like references as template arguments.

class C_dxj_Direct3dDevice3Object : 
        public I_dxj_Direct3dDevice3,
		//public CComCoClass<C_dxj_Direct3dDevice3Object, &CLSID__dxj_Direct3dDevice3>,
		public CComObjectRoot
{
public:
        C_dxj_Direct3dDevice3Object();
        virtual ~C_dxj_Direct3dDevice3Object();
		DWORD InternalAddRef();
		DWORD InternalRelease();

BEGIN_COM_MAP(C_dxj_Direct3dDevice3Object)
        COM_INTERFACE_ENTRY(I_dxj_Direct3dDevice3)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_Direct3dDevice3,			"DIRECT.Direct3dDevice3.3",          "DIRECT.Direct3dDevice3.3",			IDS_D3DDEVICE_DESC,			THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_Direct3dDevice3Object)

// I_dxj_Direct3dDevice
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE addViewport( 
            /* [in] */ I_dxj_Direct3dViewport3 __RPC_FAR *viewport);
        
         HRESULT STDMETHODCALLTYPE deleteViewport( 
            /* [in] */ I_dxj_Direct3dViewport3 __RPC_FAR *vport);
        
         HRESULT STDMETHODCALLTYPE beginIndexed( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ d3dVertexType d3dvt,
            /* [in] */ void __RPC_FAR *verts,
            /* [in] */ long vertexCount,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE drawIndexedPrimitive( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ d3dVertexType d3dvt,
            /* [in] */ void __RPC_FAR *vertices,
            /* [in] */ long VertexCount,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indices,
            /* [in] */ long IndicesCount,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE drawPrimitive( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ d3dVertexType d3dvt,
            /* [in] */ void __RPC_FAR *vertices,
            /* [in] */ long VertexCount,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE vertex( 
            /* [in] */ void __RPC_FAR *vertex);
        
         HRESULT STDMETHODCALLTYPE getDirect3D( 
            /* [retval][out] */ I_dxj_Direct3d3 __RPC_FAR *__RPC_FAR *dev);
        
         HRESULT STDMETHODCALLTYPE getCurrentViewport( 
            /* [retval][out] */ I_dxj_Direct3dViewport3 __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE nextViewport( 
            /* [in] */ I_dxj_Direct3dViewport3 __RPC_FAR *vp1,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_Direct3dViewport3 __RPC_FAR *__RPC_FAR *vp2);
        
         HRESULT STDMETHODCALLTYPE setCurrentViewport( 
            /* [in] */ I_dxj_Direct3dViewport3 __RPC_FAR *viewport);
        
         HRESULT STDMETHODCALLTYPE setRenderTarget( 
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *surface);
        
         HRESULT STDMETHODCALLTYPE getRenderTarget( 
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *ppval);
        
         HRESULT STDMETHODCALLTYPE begin( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ d3dVertexType d3dvt,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE beginScene( void);
        
         HRESULT STDMETHODCALLTYPE end();
        
         HRESULT STDMETHODCALLTYPE endScene( void);
        
         HRESULT STDMETHODCALLTYPE getTextureFormatsEnum( 
            /* [retval][out] */ I_dxj_D3DEnumPixelFormats __RPC_FAR *__RPC_FAR *retval);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ D3dDeviceDesc __RPC_FAR *hwDesc,
            /* [out][in] */ D3dDeviceDesc __RPC_FAR *helDesc);
        
         HRESULT STDMETHODCALLTYPE getClipStatus( 
            /* [out][in] */ D3dClipStatus __RPC_FAR *clipStatus);
        
         HRESULT STDMETHODCALLTYPE getLightState( 
            /* [in] */ long state,
            /* [retval][out] */ long __RPC_FAR *lightstate);
        
         HRESULT STDMETHODCALLTYPE getRenderState( 
            /* [in] */ long state,
            /* [retval][out] */ long __RPC_FAR *renderstate);
        
         HRESULT STDMETHODCALLTYPE getStats( 
            /* [out][in] */ D3dStats __RPC_FAR *stat);
        
         HRESULT STDMETHODCALLTYPE getTransform( 
            /* [in] */ long transformType,
            /* [out][in] */ D3dMatrix __RPC_FAR *matrix);
        
         HRESULT STDMETHODCALLTYPE index( 
            /* [in] */ short vertexIndex);
        
         HRESULT STDMETHODCALLTYPE multiplyTransform( 
            /* [in] */ long dstTransfromStateType,
            /* [out][in] */ D3dMatrix __RPC_FAR *matrix);
        
         HRESULT STDMETHODCALLTYPE setClipStatus( 
            /* [in] */ D3dClipStatus __RPC_FAR *clipStatus);
        
         HRESULT STDMETHODCALLTYPE setLightState( 
            /* [in] */ long state,
            /* [in] */ long lightstate);
        
         HRESULT STDMETHODCALLTYPE setRenderState( 
            /* [in] */ long state,
            /* [in] */ long renderstate);
        
         HRESULT STDMETHODCALLTYPE setTransform( 
            /* [in] */ d3dTransformStateType transformType,
            /* [in] */ D3dMatrix __RPC_FAR *matrix);
        
         HRESULT STDMETHODCALLTYPE computeSphereVisibility( 
            D3dVector __RPC_FAR *center,
            float __RPC_FAR *radi,
            /* [retval][out] */ long __RPC_FAR *returnVal);
        
         HRESULT STDMETHODCALLTYPE drawIndexedPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer __RPC_FAR *vertexBuffer,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indexArray,
            /* [in] */ long indexcount,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE drawPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer __RPC_FAR *vertexBuffer,
            /* [in] */ long startVertex,
            /* [in] */ long numVertices,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE validateDevice( 
            /* [retval][out] */ long __RPC_FAR *passes);
        
         HRESULT STDMETHODCALLTYPE getTexture( 
            /* [in] */ long stage,
            /* [retval][out] */ I_dxj_Direct3dTexture2 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setTexture( 
            /* [in] */ long stage,
            /* [in] */ I_dxj_Direct3dTexture2 __RPC_FAR *texture);
        
         HRESULT STDMETHODCALLTYPE setTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ long value);

////////////////////////////////////////////////////////////////////////////////////
private:
    DECL_VARIABLE(_dxj_Direct3dDevice3);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dDevice3)
	void *parent2; 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3denumpixelformats7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       d3denumpixelformats7obj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "D3DEnumPixelFormats7obj.h"

extern HRESULT CopyOutDDPixelFormat( DDPixelFormat *ddpfOut,DDPIXELFORMAT *pf);
extern HRESULT CopyInDDPixelFormat(DDPIXELFORMAT *ddpfOut,DDPixelFormat *pf);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR D3DGUIDtoBSTR(LPGUID pg);
extern HRESULT D3DBSTRtoGUID(LPGUID pGuid,BSTR str);

extern	BOOL IsAllZeros(void *pStruct,DWORD size); 

extern "C" HRESULT PASCAL objEnumPixelFormatsCallback(DDPIXELFORMAT  *pf, void *lpArg)
{

	DPF(1,"Entered objEnumPixelFormatsCallback\r\n");



	
	C_dxj_Direct3DEnumPixelFormats7Object *pObj=(C_dxj_Direct3DEnumPixelFormats7Object*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if (pObj->m_pList)
			pObj->m_pList=(DDPIXELFORMAT*)realloc(pObj->m_pList,sizeof(DDPixelFormat)* pObj->m_nMax);
		else
			pObj->m_pList=(DDPIXELFORMAT*)malloc(sizeof(DDPixelFormat)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),pf,sizeof(DDPIXELFORMAT));
		
	
	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_Direct3DEnumPixelFormats7Object::C_dxj_Direct3DEnumPixelFormats7Object()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_Direct3DEnumPixelFormats7Object::~C_dxj_Direct3DEnumPixelFormats7Object()
{
	//empty list
	if (m_pList){
		free(m_pList);
	}

}


HRESULT C_dxj_Direct3DEnumPixelFormats7Object::create1(LPDIRECT3DDEVICE7 pd3d,  I_dxj_Direct3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_Direct3DEnumPixelFormats7Object *pNew=NULL;

	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_Direct3DEnumPixelFormats7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumTextureFormats(objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_Direct3DEnumPixelFormats,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_Direct3DEnumPixelFormats7Object::create2(LPDIRECT3D7 pd3d,  BSTR strGuid, I_dxj_Direct3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_Direct3DEnumPixelFormats7Object *pNew=NULL;
	GUID guid;

	hr=D3DBSTRtoGUID(&guid,strGuid);
	if FAILED(hr) return hr;
	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_Direct3DEnumPixelFormats7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumZBufferFormats(guid,objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_Direct3DEnumPixelFormats,(void**)ppRet);
	return hr;
}




HRESULT C_dxj_Direct3DEnumPixelFormats7Object::getItem( long index, DDPixelFormat *desc)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	CopyOutDDPixelFormat(desc ,&(m_pList[index-1]));

	return S_OK;
}


HRESULT C_dxj_Direct3DEnumPixelFormats7Object::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3denumdevices7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3denumdevices7obj.cpp
//
//--------------------------------------------------------------------------

 
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "D3DEnumDevices7Obj.h"

extern  BSTR D3DGUIDtoBSTR(LPGUID pGuid);




/////////////////////////////////////////////////////////////////////////////
extern "C" HRESULT PASCAL objEnumDevices7Callback(
						//LPGUID lpGuid, 
						LPSTR DevDesc,
						LPSTR DevName, 
						LPD3DDEVICEDESC7 lpD3DDevDesc,
						void *lpArg)
{

	C_dxj_Direct3DEnumDevices7Object *pObj=(C_dxj_Direct3DEnumDevices7Object*)lpArg;
	if (pObj==NULL) return D3DENUMRET_OK;
	
	//if (!lpGuid) return D3DENUMRET_CANCEL;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		
		if (pObj->m_pList)
			pObj->m_pList=(DxDriverInfo*)realloc(pObj->m_pList,sizeof(DxDriverInfo)* pObj->m_nMax);
		else
			pObj->m_pList=(DxDriverInfo*)malloc(sizeof(DxDriverInfo)* pObj->m_nMax);


		if (pObj->m_pListHW)
			pObj->m_pListHW=(D3DDEVICEDESC7*)realloc(pObj->m_pListHW,sizeof(D3DDEVICEDESC7)* pObj->m_nMax);
		else
			pObj->m_pListHW=(D3DDEVICEDESC7*)malloc(sizeof(D3DDEVICEDESC7)* pObj->m_nMax);
		

	}
	
	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DxDriverInfo));
	pObj->m_pList[pObj->m_nCount].strGuid=D3DGUIDtoBSTR(&(lpD3DDevDesc->deviceGUID));
	
	if (DevDesc!=NULL) {
		pObj->m_pList[pObj->m_nCount].strDescription=T2BSTR(DevDesc);
	}
	if (DevName!=NULL){
		pObj->m_pList[pObj->m_nCount].strName=T2BSTR(DevName);
	}

	ZeroMemory(&(pObj->m_pListHW[pObj->m_nCount]),sizeof(D3DDEVICEDESC7));
	
	
	if (lpD3DDevDesc){
		memcpy(&(pObj->m_pListHW[pObj->m_nCount]),lpD3DDevDesc,sizeof(D3DDEVICEDESC7));
	}
	

	pObj->m_nCount++;
	
	return D3DENUMRET_OK;
}


C_dxj_Direct3DEnumDevices7Object::C_dxj_Direct3DEnumDevices7Object()
{	
	m_nMax=0;
	m_pList=NULL;
	m_pListHW=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_Direct3DEnumDevices7Object::~C_dxj_Direct3DEnumDevices7Object()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].strGuid) SysFreeString(m_pList[i].strGuid);
			if (m_pList[i].strDescription) SysFreeString(m_pList[i].strDescription);
			if (m_pList[i].strName) SysFreeString(m_pList[i].strName);
		}
		free(m_pList);
	}

}


HRESULT C_dxj_Direct3DEnumDevices7Object::create(LPDIRECT3D7 pD3D,I_dxj_Direct3DEnumDevices **ppRet)
{
	HRESULT hr;
	C_dxj_Direct3DEnumDevices7Object *pNew=NULL;

	*ppRet=NULL;

	pNew= new CComObject<C_dxj_Direct3DEnumDevices7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	hr=pD3D->EnumDevices(objEnumDevices7Callback, (void*)pNew);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		if (pNew->m_pList) free(pNew->m_pList);
		if (pNew->m_pListHW) free(pNew->m_pListHW);
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_Direct3DEnumDevices,(void**)ppRet);
	return hr;
}


        
HRESULT C_dxj_Direct3DEnumDevices7Object::getGuid( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strGuid);
	
	return S_OK;
}

HRESULT C_dxj_Direct3DEnumDevices7Object::getName( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strName);
	
	return S_OK;
}


HRESULT C_dxj_Direct3DEnumDevices7Object::getDescription( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strDescription);
	
	return S_OK;
}
        

HRESULT C_dxj_Direct3DEnumDevices7Object::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}

HRESULT C_dxj_Direct3DEnumDevices7Object::getDesc(long index, D3dDeviceDesc7 *desc)
{
	if (m_pListHW==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	memcpy(desc,&(m_pListHW[index-1]),sizeof(D3dDeviceDesc7));
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3dvertexbuffer7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3dvertexbuffer7obj.cpp
//
//--------------------------------------------------------------------------

// d3dMaterialObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3dVertexBuffer7Obj.h"

CONSTRUCTOR(_dxj_Direct3dVertexBuffer7,  {m_pData=NULL;m_vertSize=0;});
DESTRUCTOR(_dxj_Direct3dVertexBuffer7,  {});
GETSET_OBJECT(_dxj_Direct3dVertexBuffer7);


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::getVertexBufferDesc( 
            /* [out][in] */ D3dVertexBufferDesc __RPC_FAR *desc)
{
	HRESULT hr;
	((D3DVERTEXBUFFERDESC*)desc)->dwSize=sizeof(D3DVERTEXBUFFERDESC);
	hr=m__dxj_Direct3dVertexBuffer7->GetVertexBufferDesc((D3DVERTEXBUFFERDESC*)desc);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::processVertices( 
            /* [in] */ long vertexOp,
            /* [in] */ long destIndex,
            /* [in] */ long count,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *srcBuffer,
            /* [in] */ long srcIndex,
            /* [in] */ I_dxj_Direct3dDevice7 __RPC_FAR *dev,
			long flags
            )
{
	HRESULT hr;

	if (!srcBuffer) return E_INVALIDARG;
	if (!dev) return E_INVALIDARG;

	DO_GETOBJECT_NOTNULL( LPDIRECT3DVERTEXBUFFER7, realBuffer, srcBuffer);
	DO_GETOBJECT_NOTNULL( LPDIRECT3DDEVICE7, realDev, dev);

	hr=m__dxj_Direct3dVertexBuffer7->ProcessVertices(
		(DWORD) vertexOp,
		(DWORD) destIndex,
		(DWORD) count,
		realBuffer,
		(DWORD) srcIndex,
		realDev,
		(DWORD) flags);


	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::lock( 
            /* [in] */ long flags)
{
	HRESULT hr;
	

	hr=m__dxj_Direct3dVertexBuffer7->Lock((DWORD) flags, &m_pData,NULL);
		
	return hr;
}
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::setVertexSize( /* [in] */ long n)
{
	m_vertSize=(DWORD)n;
		
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::unlock()
{
	HRESULT hr;
	hr=m__dxj_Direct3dVertexBuffer7->Unlock();
	m_pData=NULL;
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::optimize(
		    /* [in] */ I_dxj_Direct3dDevice7 __RPC_FAR *dev
             )
        
{
	HRESULT hr;
	if (!dev) return E_INVALIDARG;
	
	DO_GETOBJECT_NOTNULL( LPDIRECT3DDEVICE7, realdev, dev);
	
	hr=m__dxj_Direct3dVertexBuffer7->Optimize(realdev,(DWORD) 0);
	
	return hr;
}
        
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::setVertices( 
            /* [in] */ long startIndex,
            /* [in] */ long count,
            /* [in] */ void __RPC_FAR *verts)        
{
		
	if (!m_vertSize) return E_FAIL;
	if (!m_pData) return E_FAIL;

	__try {
		memcpy(&(((char*)m_pData) [startIndex*m_vertSize]),verts,count*m_vertSize);
	}
	__except(1,1){
		return E_FAIL;
	}
	
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////        

STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::getVertices( 
            /* [in] */ long startIndex,
            /* [in] */ long count,
            /* [in] */ void __RPC_FAR *verts)        
{
	
	if (!m_vertSize) {				
		return E_FAIL;
	}
	if (!m_pData) {		
		return E_FAIL;
	}

	__try {
		memcpy(verts,&( ((char*)m_pData) [startIndex*m_vertSize]),count*m_vertSize);
	}
	__except(1,1){		
		return E_FAIL;
	}
	

	
	return S_OK;
}
           


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3dx8obj.h ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       D3DX8obj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_D3DX8Object : 
	public I_dxj_D3DX8,
	public CComCoClass<C_dxj_D3DX8Object, &CLSID_D3DX8>,
	public CComObjectRoot
{
public:


DECLARE_REGISTRY(CLSID_D3DX8,	"DIRECT.D3DX8.0",		"DIRECT.D3DX8.0",	IDS_D3DX8_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(C_dxj_D3DX8Object)
	COM_INTERFACE_ENTRY( I_dxj_D3DX8)
END_COM_MAP()



public:
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateFont( 
            /* [in] */ IUnknown *Device,
#ifdef _WIN64
	        /* [in] */ HANDLE hFont,
#else
	        /* [in] */ long hFont,
#endif
            /* [retval][out] */ D3DXFont **retFont);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE DrawText( 
            /* [in] */ D3DXFont *d3dFont,
            /* [in] */ long Color,
            /* [in] */ BSTR TextString,
            /* [in] */ RECT *Rect,
            /* [in] */ long Format);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE GetFVFVertexSize( 
            /* [in] */ long FVF,
            /* [retval][out] */ long *size);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE AssembleShaderFromFile( 
            /* [in] */ BSTR SrcFile,
            /* [in] */ long Flags,
            /* [in] */ BSTR *ErrLog,
            /* [out][in] */ D3DXBuffer **Constants,
            /* [retval][out] */ D3DXBuffer **ppVertexShader);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE AssembleShader( 
            /* [in] */ BSTR SrcData,
            /* [in] */ long Flags,
            /* [out][in] */ D3DXBuffer **Constants,
			/* [in][out][optional] */ BSTR *ErrLog,
            /* [retval][out] */ D3DXBuffer **ppVertexShader);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE GetErrorString( 
            /* [in] */ long hr,
            /* [retval][out] */ BSTR *retStr);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadSurfaceFromFile( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestRect,
            /* [in] */ BSTR SrcFile,
            /* [in] */ void *SrcRect,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadSurfaceFromFileInMemory( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestRect,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [in] */ void *SrcRect,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadSurfaceFromSurface( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestRect,
            /* [in] */ IUnknown *SrcSurface,
            /* [in] */ void *SrcPalette,
            /* [in] */ void *SrcRect,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadSurfaceFromMemory( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestRect,
            /* [in] */ void *SrcData,
            /* [in] */ long formatSrc,
            /* [in] */ long SrcPitch,
            /* [in] */ void *SrcPalette,
            /* [in] */ RECT_CDESC *SrcRect,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CheckTextureRequirements( 
            /* [out][in] */ IUnknown *Device,
            /* [out][in] */ long *Width,
            /* [out][in] */ long *Height,
            /* [out][in] */ long *NumMipLevels,
            /* [in] */ long Usage,
            /* [out][in] */ long *PixelFormat,
            /* [in] */ long Pool);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTexture( 
            /* [in] */ IUnknown *Device,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTextureFromResource( 
            /* [in] */ IUnknown *Device,
#ifdef _WIN64
	        /* [in] */ HANDLE hModule,
#else
	        /* [in] */ long hModule,
#endif
            /* [in] */ BSTR SrcResource,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTextureFromFile( 
            /* [in] */ IUnknown *Device,
            /* [in] */ BSTR SrcFile,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTextureFromFileEx( 
            /* [in] */ IUnknown *Device,
            /* [in] */ BSTR SrcFile,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void *Palette,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTextureFromFileInMemory( 
            /* [in] */ IUnknown *Device,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTextureFromFileInMemoryEx( 
            /* [in] */ IUnknown *Device,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void *Palette,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE FilterTexture( 
            /* [in] */ IUnknown *Texture,
            /* [in] */ void *Palette,
            /* [in] */ long SrcLevel,
            /* [in] */ long Filter);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CheckCubeTextureRequirements( 
            /* [in] */ IUnknown *Device,
            /* [out][in] */ long *Size,
            /* [out][in] */ long *NumMipLevels,
            /* [in] */ long Usage,
            /* [out][in] */ long *PixelFormat,
            /* [in] */ long Pool);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateCubeTexture( 
            /* [in] */ IUnknown *pDevice,
            /* [in] */ long Size,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [retval][out] */ IUnknown **ppCubeTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateCubeTextureFromFile( 
            /* [in] */ IUnknown *Device,
            /* [in] */ BSTR SrcFile,
            /* [retval][out] */ IUnknown **ppCubeTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateCubeTextureFromFileEx( 
            /* [in] */ IUnknown *Device,
            /* [in] */ BSTR SrcFile,
            /* [in] */ long TextureSize,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void *Palette,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateCubeTextureFromFileInMemory( 
            /* [in] */ IUnknown *Device,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateCubeTextureFromFileInMemoryEx( 
            /* [in] */ IUnknown *Device,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [in] */ long TextureSize,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void *Palette,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE FilterCubeTexture( 
            /* [in] */ IUnknown *CubeTexture,
            /* [in] */ void *Palette,
            /* [in] */ long SrcLevel,
            /* [in] */ long Filter);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CheckVolumeTextureRequirements( 
            /* [in] */ IUnknown *Device,
            /* [out] */ long *Width,
            /* [out] */ long *Height,
            /* [out] */ long *Depth,
            /* [out] */ long *NumMipLevels,
            /* [in] */ long Usage,
            /* [out][in] */ long *PixelFormat,
            /* [in] */ long Pool);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTextureFromResourceEx( 
            /* [in] */ IUnknown *Device,
#ifdef _WIN64
            /* [in] */ HANDLE hSrcModule,
#else
            /* [in] */ long hSrcModule,
#endif
            /* [in] */ BSTR SrcResource,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void *Palette,
            /* [retval][out] */ IUnknown **retTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateVolumeTexture( 
            /* [in] */ IUnknown *Device,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long Depth,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [retval][out] */ IUnknown **ppVolumeTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE FilterVolumeTexture( 
            /* [in] */ IUnknown *VolumeTexture,
            /* [in] */ void *Palette,
            /* [in] */ long SrcLevel,
            /* [in] */ long Filter);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadSurfaceFromResource( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestRect,
#ifdef _WIN64
            /* [in] */ HANDLE hSrcModule,
#else
            /* [in] */ long hSrcModule,
#endif
            /* [in] */ BSTR SrcResource,
            /* [in] */ void *SrcRect,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadVolumeFromVolume( 
            /* [in] */ IUnknown *DestVolume,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestBox,
            /* [in] */ IUnknown *SrcVolume,
            /* [in] */ void *SrcPalette,
            /* [in] */ void *SrcBox,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadVolumeFromMemory( 
            /* [in] */ IUnknown *DestVolume,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestRect,
            /* [in] */ void *SrcMemory,
            /* [in] */ long SrcFormat,
            /* [in] */ long SrcRowPitch,
            /* [in] */ long SrcSlicePitch,
            /* [in] */ void *SrcPalette,
            /* [in] */ void *SrcBox,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateMesh( 
            /* [in] */ long numFaces,
            /* [in] */ long numVertices,
            /* [in] */ long options,
            /* [in] */ void *declaration,
            /* [in] */ IUnknown *pD3D,
            /* [retval][out] */ D3DXMesh **ppMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateMeshFVF( 
            /* [in] */ long numFaces,
            /* [in] */ long numVertices,
            /* [in] */ long options,
            /* [in] */ long fvf,
            /* [in] */ IUnknown *pD3D,
            /* [retval][out] */ D3DXMesh **ppMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateSPMesh( 
            /* [in] */ D3DXMesh *pMesh,
            /* [in] */ void *adjacency,
            /* [in] */ void *VertexAttributeWeights,
            /* [in] */ void *VertexWeights,
            /* [retval][out] */ D3DXSPMesh **ppSMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE GeneratePMesh( 
            /* [in] */ D3DXMesh *Mesh,
            /* [in] */ void *Adjacency,
            /* [in] */ void *VertexAttributeWeights,
            /* [in] */ void *VertexWeights,
            /* [in] */ long minValue,
            /* [in] */ long options,
            /* [retval][out] */ D3DXPMesh **ppPMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE SimplifyMesh( 
            /* [in] */ D3DXMesh *Mesh,
            /* [in] */ void *Adjacency,
            /* [in] */ void *VertexAttributeWeights,
            /* [in] */ void *VertexWeights,
            /* [in] */ long minValue,
            /* [in] */ long options,
            /* [retval][out] */ D3DXMesh **ppMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE ComputeBoundingSphere( 
            /* [in] */ void *PointsFVF,
            /* [in] */ long numVertices,
            /* [in] */ long FVF,
            /* [in] */ D3DVECTOR_CDESC *Centers,
            /* [out][in] */ float *RadiusArray);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE ComputeBoundingBox( 
            /* [in] */ void *PointsFVF,
            /* [in] */ long numVertices,
            /* [in] */ long FVF,
            /* [out][in] */ D3DVECTOR_CDESC *MinVert,
            /* [out][in] */ D3DVECTOR_CDESC *MaxVert);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE ComputeNormals( 
            /* [in] */ D3DXBaseMesh *pMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE DeclaratorFromFVF( 
            /* [in] */ long FVF,
            /* [out] */ D3DXDECLARATOR_CDESC *Declarator);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE FVFFromDeclarator( 
            /* [in] */ D3DXDECLARATOR_CDESC *Declarator,
            /* [retval][out] */ long *fvf);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateBuffer( 
            /* [in] */ long numBytes,
            /* [retval][out] */ D3DXBuffer **ppBuffer);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadMeshFromX( 
            /* [in] */ BSTR Filename,
            /* [in] */ long options,
            /* [in] */ IUnknown *D3DDevice,
            /* [out][in] */ D3DXBuffer **retAdjacency,
            /* [out][in] */ D3DXBuffer **retMaterials,
            /* [out][in] */ long *retMaterialCount,
            /* [retval][out] */ D3DXMesh **retMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE SaveMeshToX( 
            /* [in] */ BSTR Filename,
            /* [in] */ D3DXMesh *Mesh,
            /* [in] */ void *AdjacencyArray,
            /* [in] */ D3DXMATERIAL_CDESC *MaterialArray,
            /* [in] */ long MaterialCount,
            /* [in] */ long xFormat);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadMeshFromXof( 
            /* [in] */ IUnknown *xofobjMesh,
            /* [in] */ long options,
            /* [in] */ IUnknown *D3DDevice,
            /* [out][in] */ D3DXBuffer **retBufAdjacency,
            /* [out][in] */ D3DXBuffer **retMaterials,
            /* [out][in] */ long *retMaterialCount,
            /* [retval][out] */ D3DXMesh **retMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE TessellateNPatches( 
            /* [in] */ D3DXMesh *MeshIn,
            /* [in] */ void *AdjacencyIn,
            /* [in] */ float NumSegs,
    	    /* [in] */ VARIANT_BOOL QuadraticInterpNormals,
	    /* [in,out, optional] */ D3DXBuffer **AdjacencyOut, 
            /* [retval][out] */ D3DXMesh **MeshOut);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BufferGetMaterial( 
            /* [in] */ D3DXBuffer *MaterialBuffer,
            /* [in] */ long index,
            /* [out] */ D3DMATERIAL8_CDESC *mat);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BufferGetTextureName( 
            /* [in] */ D3DXBuffer *MaterialBuffer,
            /* [in] */ long index,
            /* [retval][out] */ BSTR *retName);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BufferGetData( 
            /* [in] */ D3DXBuffer *Buffer,
            /* [in] */ long index,
            /* [in] */ long typesize,
            /* [in] */ long typecount,
            /* [out][in] */ void *data);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BufferSetData( 
            /* [in] */ D3DXBuffer *Buffer,
            /* [in] */ long index,
            /* [in] */ long typesize,
            /* [in] */ long typecount,
            /* [out][in] */ void *data);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE Intersect( 
            /* [in] */ D3DXMesh *MeshIn,
            /* [in] */ D3DVECTOR_CDESC *RayPos,
            /* [in] */ D3DVECTOR_CDESC *RayDir,
            /* [out] */ LONG *retHit,
            /* [out] */ LONG *retFaceIndex,
            /* [out] */ FLOAT *U,
            /* [out] */ FLOAT *V,
            /* [out] */ FLOAT *retDist,
            /* [out] */ LONG *countHits,
            /* [retval][out] */ D3DXBuffer **AllHits);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE SphereBoundProbe( 
            /* [in] */ D3DVECTOR_CDESC *Center,
            /* [in] */ float Radius,
            /* [in] */ D3DVECTOR_CDESC *RayPosition,
            /* [in] */ D3DVECTOR_CDESC *Raydirection,
            /* [retval][out] */ VARIANT_BOOL *retHit);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE ComputeBoundingSphereFromMesh( 
            /* [in] */ D3DXMesh *MeshIn,
            /* [out][in] */ D3DVECTOR_CDESC *Centers,
            /* [out][in] */ float *RadiusArray);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE ComputeBoundingBoxFromMesh( 
            /* [in] */ D3DXMesh *MeshIn,
            /* [out][in] */ D3DVECTOR_CDESC *MinArray,
            /* [out][in] */ D3DVECTOR_CDESC *MaxArray);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateSkinMesh( 
            /* [in] */ long numFaces,
            /* [in] */ long numVertices,
            /* [in] */ long numBones,
            /* [in] */ long options,
            /* [in] */ void *Declaration,
            /* [in] */ IUnknown *D3DDevice,
            /* [retval][out] */ D3DXSkinMesh **SkinMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateSkinMeshFVF( 
            /* [in] */ long numFaces,
            /* [in] */ long numVertices,
            /* [in] */ long numBones,
            /* [in] */ long options,
            /* [in] */ long fvf,
            /* [in] */ IUnknown *D3DDevice,
            /* [retval][out] */ D3DXSkinMesh **ppSkinMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateSkinMeshFromMesh( 
            /* [in] */ D3DXMesh *Mesh,
            /* [in] */ long numBones,
            /* [retval][out] */ D3DXSkinMesh **ppSkinMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadSkinMeshFromXof( 
            /* [in] */ IUnknown *xofobjMesh,
            /* [in] */ long options,
            /* [in] */ IUnknown *D3DDevice,
            /* [out][in] */ D3DXBuffer **AdjacencyOut,
            /* [out][in] */ D3DXBuffer **MaterialsOut,
            /* [out][in] */ long *NumMatOut,
            /* [out][in] */ D3DXBuffer **BoneNamesOut,
            /* [out][in] */ D3DXBuffer **BoneTransformsOut,
            /* [retval][out] */ D3DXSkinMesh **ppMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreatePolygon( 
            /* [in] */ IUnknown *D3DDevice,
            /* [in] */ float Length,
            /* [in] */ long Sides,
            /* [out][in] */ D3DXBuffer **RetAdjacency,
            /* [retval][out] */ D3DXMesh **RetMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateBox( 
            /* [in] */ IUnknown *D3DDevice,
            /* [in] */ float Width,
            /* [in] */ float Height,
            /* [in] */ float Depth,
            /* [out][in] */ D3DXBuffer **RetAdjacency,
            /* [retval][out] */ D3DXMesh **RetMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateCylinder( 
            /* [in] */ IUnknown *D3DDevice,
            /* [in] */ float Radius1,
            /* [in] */ float Radius2,
            /* [in] */ float Length,
            /* [in] */ long Slices,
            /* [in] */ long Stacks,
            /* [out][in] */ D3DXBuffer **RetAdjacency,
            /* [retval][out] */ D3DXMesh **RetMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateSphere( 
            /* [in] */ IUnknown *D3DDevice,
            /* [in] */ float Radius,
            /* [in] */ long Slices,
            /* [in] */ long Stacks,
            /* [out][in] */ D3DXBuffer **RetAdjacency,
            /* [retval][out] */ D3DXMesh **RetMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTorus( 
            /* [in] */ IUnknown *D3DDevice,
            /* [in] */ float InnerRadius,
            /* [in] */ float OuterRadius,
            /* [in] */ long Sides,
            /* [in] */ long Rings,
            /* [out][in] */ D3DXBuffer **RetAdjacency,
            /* [retval][out] */ D3DXMesh **RetMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTeapot( 
            /* [in] */ IUnknown *D3DDevice,
            /* [out][in] */ D3DXBuffer **RetAdjacency,
            /* [retval][out] */ D3DXMesh **RetMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateText( 
            /* [in] */ IUnknown *D3DDevice,
            /* [in] */ HDC hDC,
            /* [in] */ BSTR Text,
            /* [in] */ float Deviation,
            /* [in] */ float Extrusion,
            /* [out][in] */ D3DXMesh **RetMesh,
	    /* [in,out]  */ D3DXBuffer **AdjacencyOut, 
            /* [out][in] */ void *GlyphMetrics);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BufferGetBoneName( 
            /* [in] */ D3DXBuffer *BoneNameBuffer,
            /* [in] */ long index,
            /* [retval][out] */ BSTR *retName);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateSprite( 
            /* [in] */ IUnknown *D3DDevice,
            /* [retval][out] */ D3DXSprite **retSprite);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateRenderToSurface( 
            /* [in] */ IUnknown *D3DDevice,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long Format,
            /* [in] */ long DepthStencil,
            /* [in] */ long DepthStencilFormat,
            /* [retval][out] */ D3DXRenderToSurface **RetRenderToSurface);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CleanMesh( 
            /* [in] */ D3DXMesh *MeshIn,
            /* [in] */ void *Adjacency,
		/* [in][out][optional] */ BSTR *ErrLog,
		/* [in,out] */ D3DXBuffer *AdjacencyOut,
            /* [retval][out] */ D3DXMesh **MeshOut);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE ValidMesh( 
            /* [in] */ D3DXMesh *MeshIn,
            /* [in] */ void *Adjacency,
		/* [in][out][optional] */ BSTR *ErrLog,
            /* [retval][out] */ VARIANT_BOOL *ret);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BoxBoundProbe( 
            /* [in] */ D3DVECTOR_CDESC *MinVert,
            /* [in] */ D3DVECTOR_CDESC *MaxVert,
            /* [in] */ D3DVECTOR_CDESC *RayPosition,
            /* [in] */ D3DVECTOR_CDESC *RayDirection,
            /* [retval][out] */ VARIANT_BOOL *ret);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE SavePMeshToFile( 
            /* [in] */ BSTR Filename,
            /* [in] */ D3DXPMesh *Mesh,
            /* [in] */ D3DXMATERIAL_CDESC *MaterialArray,
            /* [in] */ long MaterialCount);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadPMeshFromFile( 
            /* [in] */ BSTR Filename,
	    /* [in] */ long options,
            /* [in] */ IUnknown *D3DDevice,
            /* [out] */ D3DXBuffer **RetMaterials,
            /* [out] */ long *RetNumMaterials,
            /* [retval][out] */ D3DXPMesh **RetPMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BufferGetBoneCombo( 
            /* [in] */ D3DXBuffer *BoneComboBuffer,
            /* [in] */ long index,
            /* [out][in] */ D3DXBONECOMBINATION_CDESC *boneCombo);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BufferGetBoneComboBoneIds( 
            /* [in] */ D3DXBuffer *BoneComboBuffer,
            /* [in] */ long index,
            /* [in] */ long PaletteSize,
            /* [in] */ void *BoneIds);

        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE SaveSurfaceToFile(
		/* [in] */ BSTR DestFile,
        /* [in] */ LONG DestFormat,
        /* [in] */ IUnknown*        SrcSurface,
        /* [in] */ PALETTEENTRY*       SrcPalette,
        /* [in] */ RECT*               SrcRect);

        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE SaveVolumeToFile(
        /* [in] */ BSTR DestFile,
        /* [in] */ LONG DestFormat,
        /* [in] */ IUnknown*         SrcVolume,
        /* [in] */ PALETTEENTRY*       SrcPalette,
        /* [in] */ void* SrcBox);
 
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE SaveTextureToFile(
        /* [in] */ BSTR DestFile,
        /* [in] */ LONG DestFormat,
        /* [in] */ IUnknown* SrcTexture,
        /* [in] */ PALETTEENTRY* SrcPalette);
        
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3dxerr.h ===
//----------------------------------------------------------------------
//                                                                      
//   d3dxerr.h --  0xC code definitions for the D3DX API                
//                                                                      
//   Copyright (c) 1991-1999, Microsoft Corp. All rights reserved.      
//                                                                      
//----------------------------------------------------------------------
#ifndef __D3DXERR_H__
#define __D3DXERR_H__

// 
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_D3DX    0x877



//
// MessageId: D3DXERR_NOMEMORY
//
// MessageText:
//
//  Out of memory.
// 
#define D3DXERR_NOMEMORY    ((HRESULT)0xC8770BB8L)


//
// MessageId: D3DXERR_NULLPOINTER
//
// MessageText:
//
//  A NULL pointer was passed as a parameter.
// 
#define D3DXERR_NULLPOINTER    ((HRESULT)0xC8770BB9L)


//
// MessageId: D3DXERR_INVALIDD3DXDEVICEINDEX
//
// MessageText:
//
//  The Device Index passed in is invalid.
// 
#define D3DXERR_INVALIDD3DXDEVICEINDEX    ((HRESULT)0xC8770BBAL)


//
// MessageId: D3DXERR_NODIRECTDRAWAVAILABLE
//
// MessageText:
//
//  DirectDraw has not been created.
// 
#define D3DXERR_NODIRECTDRAWAVAILABLE    ((HRESULT)0xC8770BBBL)


//
// MessageId: D3DXERR_NODIRECT3DAVAILABLE
//
// MessageText:
//
//  Direct3D has not been created.
// 
#define D3DXERR_NODIRECT3DAVAILABLE    ((HRESULT)0xC8770BBCL)


//
// MessageId: D3DXERR_NODIRECT3DDEVICEAVAILABLE
//
// MessageText:
//
//  Direct3D device has not been created.
// 
#define D3DXERR_NODIRECT3DDEVICEAVAILABLE    ((HRESULT)0xC8770BBDL)


//
// MessageId: D3DXERR_NOPRIMARYAVAILABLE
//
// MessageText:
//
//  Primary surface has not been created.
// 
#define D3DXERR_NOPRIMARYAVAILABLE    ((HRESULT)0xC8770BBEL)


//
// MessageId: D3DXERR_NOZBUFFERAVAILABLE
//
// MessageText:
//
//  Z buffer has not been created.
// 
#define D3DXERR_NOZBUFFERAVAILABLE    ((HRESULT)0xC8770BBFL)


//
// MessageId: D3DXERR_NOBACKBUFFERAVAILABLE
//
// MessageText:
//
//  Backbuffer has not been created.
// 
#define D3DXERR_NOBACKBUFFERAVAILABLE    ((HRESULT)0xC8770BC0L)


//
// MessageId: D3DXERR_COULDNTUPDATECAPS
//
// MessageText:
//
//  Failed to update caps database after changing display mode.
// 
#define D3DXERR_COULDNTUPDATECAPS    ((HRESULT)0xC8770BC1L)


//
// MessageId: D3DXERR_NOZBUFFER
//
// MessageText:
//
//  Could not create Z buffer.
// 
#define D3DXERR_NOZBUFFER    ((HRESULT)0xC8770BC2L)


//
// MessageId: D3DXERR_INVALIDMODE
//
// MessageText:
//
//  Display mode is not valid.
// 
#define D3DXERR_INVALIDMODE    ((HRESULT)0xC8770BC3L)


//
// MessageId: D3DXERR_INVALIDPARAMETER
//
// MessageText:
//
//  One or more of the parameters passed is invalid.
// 
#define D3DXERR_INVALIDPARAMETER    ((HRESULT)0xC8770BC4L)


//
// MessageId: D3DXERR_INITFAILED
//
// MessageText:
//
//  D3DX failed to initialize itself.
// 
#define D3DXERR_INITFAILED    ((HRESULT)0xC8770BC5L)


//
// MessageId: D3DXERR_STARTUPFAILED
//
// MessageText:
//
//  D3DX failed to start up.
// 
#define D3DXERR_STARTUPFAILED    ((HRESULT)0xC8770BC6L)


//
// MessageId: D3DXERR_D3DXNOTSTARTEDYET
//
// MessageText:
//
//  D3DXInitialize() must be called first.
// 
#define D3DXERR_D3DXNOTSTARTEDYET    ((HRESULT)0xC8770BC7L)


//
// MessageId: D3DXERR_NOTINITIALIZED
//
// MessageText:
//
//  D3DX is not initialized yet.
// 
#define D3DXERR_NOTINITIALIZED    ((HRESULT)0xC8770BC8L)


//
// MessageId: D3DXERR_FAILEDDRAWTEXT
//
// MessageText:
//
//  Failed to render text to the surface.
// 
#define D3DXERR_FAILEDDRAWTEXT    ((HRESULT)0xC8770BC9L)


//
// MessageId: D3DXERR_BADD3DXCONTEXT
//
// MessageText:
//
//  Bad D3DX context.
// 
#define D3DXERR_BADD3DXCONTEXT    ((HRESULT)0xC8770BCAL)


//
// MessageId: D3DXERR_CAPSNOTSUPPORTED
//
// MessageText:
//
//  The requested device capabilities are not supported.
// 
#define D3DXERR_CAPSNOTSUPPORTED    ((HRESULT)0xC8770BCBL)


//
// MessageId: D3DXERR_UNSUPPORTEDFILEFORMAT
//
// MessageText:
//
//  The image file format is unrecognized.
// 
#define D3DXERR_UNSUPPORTEDFILEFORMAT    ((HRESULT)0xC8770BCCL)


//
// MessageId: D3DXERR_IFLERROR
//
// MessageText:
//
//  The image file loading library error.
// 
#define D3DXERR_IFLERROR    ((HRESULT)0xC8770BCDL)


//
// MessageId: D3DXERR_FAILEDGETCAPS
//
// MessageText:
//
//  Could not obtain device caps.
// 
#define D3DXERR_FAILEDGETCAPS    ((HRESULT)0xC8770BCEL)


//
// MessageId: D3DXERR_CANNOTRESIZEFULLSCREEN
//
// MessageText:
//
//  Resize does not work for full-screen.
// 
#define D3DXERR_CANNOTRESIZEFULLSCREEN    ((HRESULT)0xC8770BCFL)


//
// MessageId: D3DXERR_CANNOTRESIZENONWINDOWED
//
// MessageText:
//
//  Resize does not work for non-windowed contexts.
// 
#define D3DXERR_CANNOTRESIZENONWINDOWED    ((HRESULT)0xC8770BD0L)


//
// MessageId: D3DXERR_FRONTBUFFERALREADYEXISTS
//
// MessageText:
//
//  Front buffer already exists.
// 
#define D3DXERR_FRONTBUFFERALREADYEXISTS    ((HRESULT)0xC8770BD1L)


//
// MessageId: D3DXERR_FULLSCREENPRIMARYEXISTS
//
// MessageText:
//
//  The app is using the primary in full-screen mode.
// 
#define D3DXERR_FULLSCREENPRIMARYEXISTS    ((HRESULT)0xC8770BD2L)


//
// MessageId: D3DXERR_GETDCFAILED
//
// MessageText:
//
//  Could not get device context.
// 
#define D3DXERR_GETDCFAILED    ((HRESULT)0xC8770BD3L)


//
// MessageId: D3DXERR_BITBLTFAILED
//
// MessageText:
//
//  Could not bitBlt.
// 
#define D3DXERR_BITBLTFAILED    ((HRESULT)0xC8770BD4L)


//
// MessageId: D3DXERR_NOTEXTURE
//
// MessageText:
//
//  There is no surface backing up this texture.
// 
#define D3DXERR_NOTEXTURE    ((HRESULT)0xC8770BD5L)


//
// MessageId: D3DXERR_MIPLEVELABSENT
//
// MessageText:
//
//  There is no such miplevel for this surface.
// 
#define D3DXERR_MIPLEVELABSENT    ((HRESULT)0xC8770BD6L)


//
// MessageId: D3DXERR_SURFACENOTPALETTED
//
// MessageText:
//
//  The surface is not paletted.
// 
#define D3DXERR_SURFACENOTPALETTED    ((HRESULT)0xC8770BD7L)


//
// MessageId: D3DXERR_ENUMFORMATSFAILED
//
// MessageText:
//
//  An error occured while enumerating surface formats.
// 
#define D3DXERR_ENUMFORMATSFAILED    ((HRESULT)0xC8770BD8L)


//
// MessageId: D3DXERR_COLORDEPTHTOOLOW
//
// MessageText:
//
//  D3DX only supports color depths of 16 bit or greater.
// 
#define D3DXERR_COLORDEPTHTOOLOW    ((HRESULT)0xC8770BD9L)


//
// MessageId: D3DXERR_INVALIDFILEFORMAT
//
// MessageText:
//
//  The file format is invalid.
// 
#define D3DXERR_INVALIDFILEFORMAT    ((HRESULT)0xC8770BDAL)


//
// MessageId: D3DXERR_NOMATCHFOUND
//
// MessageText:
//
//  No suitable match found.
// 
#define D3DXERR_NOMATCHFOUND    ((HRESULT)0xC8770BDBL)



#endif //__D3DXERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3dx8obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3dx8obj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3dx8Obj.h"
#include "d3dx8.h"
#include "filestrm.h"
#include "dxerr8.h"
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }


STDMETHODIMP C_dxj_D3DX8Object::CreateFont( 
            /* [in] */ IUnknown *Device,
#ifdef _WIN64
            /* [in] */ HANDLE hFont,
#else
            /* [in] */ long hFont,
#endif
            /* [retval][out] */ D3DXFont **retFont)
{
    HRESULT hr;
    hr= ::D3DXCreateFont( 
         (IDirect3DDevice8*) Device,
         (HFONT) hFont,
         (ID3DXFont**) retFont);
    return hr;
}



STDMETHODIMP C_dxj_D3DX8Object::DrawText( 
            /* [in] */ D3DXFont *BitmapFont,
            /* [in] */ long Color,
            /* [in] */ BSTR TextString,
            /* [in] */ RECT *Rect,
            /* [in] */ long Format)
{
    HRESULT hr;
    if (!BitmapFont) return E_INVALIDARG;

    USES_CONVERSION;
	char *szStr = NULL;
	__try { szStr=W2T(TextString); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

    
    ((ID3DXFont*)BitmapFont)->DrawTextA(szStr,-1, Rect, (DWORD) Format,(DWORD) Color);

    return S_OK;
}
        
STDMETHODIMP C_dxj_D3DX8Object::GetFVFVertexSize( 
            /* [in] */ long FVF,
            /* [retval][out] */ long*size)
{
    *size=(long)::D3DXGetFVFVertexSize((DWORD)FVF);
    return S_OK;
}
        

        
STDMETHODIMP C_dxj_D3DX8Object::AssembleShaderFromFile( 
            /* [in] */ BSTR SrcFile,
            /* [in] */ long flags,
            /* [in] */ BSTR *ErrLog,
	    /* [in] */ D3DXBuffer **Constants,
            /* [retval][out] */ D3DXBuffer **ppVertexShader)
{
    HRESULT hr;
    USES_CONVERSION;
	char *szFile = NULL;
	__try { szFile=W2T(SrcFile); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
    LPD3DXBUFFER pBuffer = NULL;
	WCHAR *wszData = NULL;

    hr=::D3DXAssembleShaderFromFile(
        szFile,
	(DWORD) flags,
	(ID3DXBuffer**) Constants,
        (ID3DXBuffer**) ppVertexShader,
        &pBuffer);

	if (FAILED(hr))
	{
		if (ErrLog)
		{
			if (*ErrLog)
				
			{
				SysFreeString(*ErrLog);
			}
		}
		
		if (pBuffer)
		{
			wszData = T2W((TCHAR*)pBuffer->GetBufferPointer());
			*ErrLog = SysAllocString(wszData);
		}
	}
	SAFE_RELEASE(pBuffer)
    //Wide string version still not exported
    //
    //hr=::D3DXAssembleVertexShaderFromFileW(
    //  (WCHAR*) SrcFile,
    //  (ID3DXBuffer**) ppVertexShader,
    //  NULL);
    
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::AssembleShader( 
            /* [in] */ BSTR  SrcData,
            /* [in] */ long flags,
	    /* [in] */ D3DXBuffer **Constants,
			/* [in][out][optional] */ BSTR *ErrLog,
            /* [retval][out] */ D3DXBuffer **ppVertexShader)
{
	WCHAR *wszData = NULL;
    char *szData=NULL;
    LPD3DXBUFFER pBuffer = NULL;
    DWORD dwLen=0;  
    HRESULT hr;
    USES_CONVERSION;        

    if (SrcData == NULL)
         return E_INVALIDARG;

    __try {
    szData=W2T((WCHAR*)SrcData);
    dwLen=strlen(szData);
    hr=::D3DXAssembleShader(
			szData,
			dwLen,
			(DWORD) flags,
			(ID3DXBuffer**) Constants,
			(ID3DXBuffer**) ppVertexShader,
			(ID3DXBuffer**) &pBuffer);

		if (FAILED(hr))
		{
			if (ErrLog)
			{
				if (*ErrLog)
				{
					SysFreeString(*ErrLog);
				}
			}
			
			if (pBuffer)
			{
				wszData = T2W((TCHAR*)pBuffer->GetBufferPointer());
				*ErrLog = SysAllocString(wszData);
			}
		}
		SAFE_RELEASE(pBuffer)
    }
    __except(1,1)
    {
		SAFE_RELEASE(pBuffer)
        return E_INVALIDARG;
    }
    return hr;
}

        

        
STDMETHODIMP C_dxj_D3DX8Object::GetErrorString( 
            /* [in] */ long hr,
            /* [retval][out] */ BSTR* retStr)
{
    if (!retStr) return E_INVALIDARG;

    //NOT SysAllocString return NULL if DXGetErrorString returns NULL
    *retStr=SysAllocString(DXGetErrorString8W(hr));
    return S_OK;
}
 


       
STDMETHODIMP C_dxj_D3DX8Object::LoadSurfaceFromFile( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void *DestPalette,
            /* [in] */ void*DestRect,
            /* [in] */ BSTR SrcFile,
            /* [in] */ void*SrcRect,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo)
{
    HRESULT hr;

    hr=::D3DXLoadSurfaceFromFileW( 
        (IDirect3DSurface8*) DestSurface,
        (PALETTEENTRY*) DestPalette,
        (RECT*)     DestRect,
        (WCHAR*)    SrcFile,
        (RECT*)     SrcRect,
        (DWORD)     Filter,
        (D3DCOLOR)  ColorKey,
        (D3DXIMAGE_INFO*)SrcInfo);

    return hr;
}
    
    
        
STDMETHODIMP C_dxj_D3DX8Object::LoadSurfaceFromFileInMemory( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void* DestPalette,
            /* [in] */ void* DestRect,
            /* [in] */ void* SrcData,
            /* [in] */ long  LengthInBytes,
            /* [in] */ void* SrcRect,
            /* [in] */ long  Filter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo)
{   
    HRESULT hr;
    __try { 

    hr=::D3DXLoadSurfaceFromFileInMemory( 
        (IDirect3DSurface8*) DestSurface,
        (PALETTEENTRY*) DestPalette,
        (RECT*)     DestRect,
                    SrcData,
        (DWORD)     LengthInBytes,
        (RECT*)     SrcRect,
        (DWORD)     Filter,
        (D3DCOLOR)  ColorKey,
        (D3DXIMAGE_INFO*)SrcInfo);
    }
    __except(1,1)
    {
        return E_INVALIDARG;
    }

    return hr;

}

// TODO: fix from RECT to void pointer
        
STDMETHODIMP C_dxj_D3DX8Object::LoadSurfaceFromSurface( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestRect,
            /* [in] */ IUnknown *SrcSurface,
            /* [in] */ void *SrcPalette,
            /* [in] */ void *SrcRect,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey)
{
    HRESULT hr;

    hr=::D3DXLoadSurfaceFromSurface( 
            (IDirect3DSurface8*) DestSurface,
            (PALETTEENTRY*) DestPalette,
            (RECT*)    DestRect,
            (IDirect3DSurface8*) SrcSurface,
            (PALETTEENTRY*) SrcPalette,
            (RECT*) SrcRect,
            (DWORD) Filter,
            (D3DCOLOR) ColorKey);

    return hr;
}
        
STDMETHODIMP C_dxj_D3DX8Object::LoadSurfaceFromMemory( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestRect,
            /* [in] */ void *SrcData,
            /* [in] */ long formatSrc,
            /* [in] */ long SrcPitch,
            /* [in] */ void *SrcPalette,
            /* [in] */ RECT_CDESC *SrcRect,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey)
{
    HRESULT hr;

    hr =::D3DXLoadSurfaceFromMemory( 
            (IDirect3DSurface8*) DestSurface,
            (PALETTEENTRY*) DestPalette,
            (RECT*)         DestRect,
                            SrcData,
            (D3DFORMAT)     formatSrc,
            (DWORD)         SrcPitch,
            (PALETTEENTRY*) SrcPalette,
            (RECT*)         SrcRect,
            (DWORD)         Filter,
            (D3DCOLOR)      ColorKey);

    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::LoadSurfaceFromResource(
        IUnknown *pDestSurface,
        void*     pDestPalette,
        void*     pDestRect,
#ifdef _WIN64
        HANDLE      hSrcModule,
#else
        long      hSrcModule,
#endif
        BSTR      SrcResource,
        void*     pSrcRect,
        long      Filter,
        long      ColorKey,
        void*     SrcInfo)
{
    HRESULT hr;

    hr=::D3DXLoadSurfaceFromResourceW(
            (LPDIRECT3DSURFACE8)pDestSurface,
            (PALETTEENTRY*)     pDestPalette,
            (RECT*)             pDestRect,
            (HMODULE)           hSrcModule,
            (LPCWSTR)           SrcResource,
            (RECT*)             pSrcRect,
            (DWORD)             Filter,
            (D3DCOLOR)          ColorKey,
            (D3DXIMAGE_INFO*)   SrcInfo);

    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::CheckTextureRequirements( 
            /* [out][in] */ IUnknown *Device,
            /* [out][in] */ long*Width,
            /* [out][in] */ long*Height,
            /* [out][in] */ long*NumMipLevels,
                            long Usage,
            /* [out][in] */ long*pPixelFormat,
                long Pool)
{
    HRESULT hr;

    hr=::D3DXCheckTextureRequirements( 
        (IDirect3DDevice8*) Device,
        (UINT*) Width,
        (UINT*) Height,
        (UINT*) NumMipLevels,
        (DWORD) Usage,
        (D3DFORMAT*) pPixelFormat,
        (D3DPOOL) Pool);


    return hr;


}
        
STDMETHODIMP C_dxj_D3DX8Object::CreateTexture( 
            /* [in] */ IUnknown *Device,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [retval][out] */ IUnknown **ppTexture)
{
    HRESULT hr;

    hr=::D3DXCreateTexture( 
        (IDirect3DDevice8*) Device,
        (DWORD) Width,
        (DWORD) Height,
        (DWORD) MipLevels,
        (DWORD) Usage,
        (D3DFORMAT) PixelFormat,
        (D3DPOOL) Pool,
        (IDirect3DTexture8**) ppTexture);

    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::CreateTextureFromResource( 
            /* [in] */ IUnknown *Device,
#ifdef _WIN64
			/* [in] */ HANDLE hSrcModule,
#else
			/* [in] */ long hSrcModule,
#endif
            /* [in] */ BSTR SrcResource,
            /* [retval][out] */ IUnknown **ppTexture)
{
    HRESULT hr;

    hr=::D3DXCreateTextureFromResourceW( 
        (IDirect3DDevice8*) Device,
        (HMODULE) hSrcModule,
        (WCHAR*) SrcResource,
        (IDirect3DTexture8**) ppTexture);

    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::CreateTextureFromResourceEx( 
            /* [in] */ IUnknown *Device,
#ifdef _WIN64
            /* [in] */ HANDLE hSrcModule,
#else
            /* [in] */ long hSrcModule,
#endif
            /* [in] */ BSTR SrcResource,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void *Palette,
            /* [retval][out] */ IUnknown **ppTexture)
{
    HRESULT hr;


    hr=::D3DXCreateTextureFromResourceExW( 
            (IDirect3DDevice8*)     Device,
            (HMODULE)               hSrcModule,
            (WCHAR*)                SrcResource,
            (UINT)                  Width,
            (UINT)                  Height,
            (UINT)                  MipLevels,
            (DWORD)                 Usage,
            (D3DFORMAT)             PixelFormat,
            (D3DPOOL)               Pool,
            (DWORD)                 Filter,
            (DWORD)                 MipFilter,
            (D3DCOLOR)              ColorKey,
            (D3DXIMAGE_INFO*)       SrcInfo,
            (PALETTEENTRY*)         Palette,
            (LPDIRECT3DTEXTURE8*)   ppTexture);

    return hr;
}
            
STDMETHODIMP C_dxj_D3DX8Object::CreateTextureFromFile( 
            /* [in] */ IUnknown *Device,
            /* [in] */ BSTR SrcFile,
            /* [retval][out] */ IUnknown **ppTexture)
{
    HRESULT hr;

    hr=::D3DXCreateTextureFromFileW( 
                (IDirect3DDevice8*)     Device,
                (WCHAR*)                SrcFile,
                (IDirect3DTexture8**)   ppTexture);

    return hr;
}
        
STDMETHODIMP C_dxj_D3DX8Object::CreateTextureFromFileEx( 
            /* [in] */ IUnknown *Device,
            /* [in] */ BSTR SrcFile,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
                       long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void*Palette,
            /* [retval][out] */ IUnknown **ppTexture)
{
    HRESULT hr;

    hr=::D3DXCreateTextureFromFileExW( 
        (IDirect3DDevice8*) Device,
        (WCHAR*) SrcFile,
        (DWORD) Width,
        (DWORD) Height,
        (DWORD) MipLevels,
        (DWORD) Usage,
        (D3DFORMAT) PixelFormat,
        (D3DPOOL) Pool,
        (DWORD) Filter,
        (DWORD) MipFilter,
        (D3DCOLOR) ColorKey,
        (D3DXIMAGE_INFO*) SrcInfo,
        (PALETTEENTRY*) Palette,
        (IDirect3DTexture8**) ppTexture);

    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::CreateTextureFromFileInMemory( 
            /* [in] */ IUnknown *Device,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [retval][out] */ IUnknown **ppTexture)

{
    HRESULT hr;

    hr=::D3DXCreateTextureFromFileInMemory( 
        (IDirect3DDevice8*) Device,
        (void*) SrcData,
        (DWORD) LengthInBytes,
        (IDirect3DTexture8**) ppTexture);

    return hr;
}
                
STDMETHODIMP C_dxj_D3DX8Object::CreateTextureFromFileInMemoryEx( 
            /* [in] */ IUnknown *Device,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void *Palette,
            /* [retval][out] */ IUnknown **ppTexture)
{

    HRESULT hr;

    hr=::D3DXCreateTextureFromFileInMemoryEx( 
        (IDirect3DDevice8*) Device,
        SrcData,
        (DWORD) LengthInBytes,
        (DWORD) Width,
        (DWORD) Height,
        (DWORD) MipLevels,
        (DWORD) Usage,
        (D3DFORMAT) PixelFormat,
        (D3DPOOL) Pool,
        (DWORD) Filter,
        (DWORD) MipFilter,
        (D3DCOLOR) ColorKey,
        (D3DXIMAGE_INFO*)   SrcInfo,
        (PALETTEENTRY*) Palette,
        (IDirect3DTexture8**) ppTexture);

    return hr;
}
               

STDMETHODIMP C_dxj_D3DX8Object::FilterTexture( 
            /* [in] */ IUnknown *Texture,
            /* [in] */ void *Palette,
            /* [in] */ long SrcLevel,
            /* [in] */ long Filter)
{
    HRESULT hr;

    hr =::D3DXFilterTexture(
        (IDirect3DTexture8*) Texture,
        (PALETTEENTRY*) Palette,
        (UINT) SrcLevel,
        (DWORD) Filter);

    return hr;
}


/************************************************/

STDMETHODIMP C_dxj_D3DX8Object::CheckCubeTextureRequirements( 
            /* [out][in] */ IUnknown *Device,
            /* [out][in] */ long *Size,
            /* [out][in] */ long *NumMipLevels,
                            long Usage,
            /* [out][in] */ long *pPixelFormat,
                            long Pool)
{
    HRESULT hr;

    hr=::D3DXCheckCubeTextureRequirements( 
        (IDirect3DDevice8*) Device,
        (UINT*) Size,
        (UINT*) NumMipLevels,
        (DWORD) Usage,
        (D3DFORMAT*) pPixelFormat,
        (D3DPOOL)Pool);

    return hr;
}

                                    
        
STDMETHODIMP C_dxj_D3DX8Object::CreateCubeTexture( 
            /* [in] */ IUnknown *Device,
            /* [in] */ long Size,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,   
            /* [retval][out] */ IUnknown **ppCubeTexture)
{
    HRESULT hr;

    hr=::D3DXCreateCubeTexture( 
        (IDirect3DDevice8*) Device,
        (DWORD) Size,
        (DWORD) MipLevels,
        (DWORD) Usage,
        (D3DFORMAT) PixelFormat,
        (D3DPOOL) Pool,
        (IDirect3DCubeTexture8**) ppCubeTexture);

    return hr;
}



STDMETHODIMP C_dxj_D3DX8Object::CreateCubeTextureFromFile( 
            /* [in] */ IUnknown *Device,
            /* [in] */ BSTR SrcFile,
            /* [retval][out] */ IUnknown **ppCubeTexture)
{
    HRESULT hr;
    hr=::D3DXCreateCubeTextureFromFileW( 
        (IDirect3DDevice8*) Device,
        (WCHAR*) SrcFile,
        (IDirect3DCubeTexture8**) ppCubeTexture);
    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::CreateCubeTextureFromFileEx( 
            /* [in] */ IUnknown *Device,
            /* [in] */ BSTR SrcFile,
            /* [in] */ long Width,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,   
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void*Palette,
            /* [retval][out] */ IUnknown **ppCubeTexture)
{
    HRESULT hr;
    hr=::D3DXCreateCubeTextureFromFileExW( 
        (IDirect3DDevice8*) Device,
        (WCHAR*) SrcFile,
        (DWORD) Width,
        (DWORD) MipLevels,
        (DWORD) Usage,
        (D3DFORMAT) PixelFormat,
        (D3DPOOL) Pool,
        (DWORD) Filter,
        (DWORD) MipFilter,
        (D3DCOLOR) ColorKey,
        (D3DXIMAGE_INFO*) SrcInfo,
        (PALETTEENTRY*) Palette,
        (IDirect3DCubeTexture8**) ppCubeTexture);

    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::CreateCubeTextureFromFileInMemory( 
            /* [in] */ IUnknown *Device,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [retval][out] */ IUnknown **ppCubeTexture)

{
    HRESULT hr;
    hr=::D3DXCreateCubeTextureFromFileInMemory( 
        (IDirect3DDevice8*) Device,
         SrcData,
        (DWORD) LengthInBytes,
        (IDirect3DCubeTexture8**) ppCubeTexture);
    return hr;
}
                
STDMETHODIMP C_dxj_D3DX8Object::CreateCubeTextureFromFileInMemoryEx( 
            /* [in] */ IUnknown *Device,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [in] */ long Width,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,   
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void *Palette,
            /* [retval][out] */ IUnknown **ppCubeTexture)
{

    HRESULT hr;
    hr=::D3DXCreateCubeTextureFromFileInMemoryEx( 
        (IDirect3DDevice8*) Device,
        SrcData,
        (DWORD) LengthInBytes,
        (DWORD) Width,
        (DWORD) MipLevels,
        (DWORD) Usage,
        (D3DFORMAT) PixelFormat,
        (D3DPOOL) Pool,
        (DWORD) Filter,
        (DWORD) MipFilter,
        (D3DCOLOR) ColorKey,
	(D3DXIMAGE_INFO*) SrcInfo,
        (PALETTEENTRY*) Palette,
        (IDirect3DCubeTexture8**) ppCubeTexture);

    return hr;
}



STDMETHODIMP C_dxj_D3DX8Object::FilterCubeTexture( 
            /* [in] */ IUnknown *CubeTexture,
            /* [in] */ void *Palette,
            /* [in] */ long SrcLevel,
            /* [in] */ long Filter)
{
    HRESULT hr;

    hr =::D3DXFilterCubeTexture(
        (IDirect3DCubeTexture8*) CubeTexture,
        (PALETTEENTRY*) Palette,
        (UINT) SrcLevel,
        (DWORD) Filter);

    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::CheckVolumeTextureRequirements(
        IUnknown          *Device,
        long*             Width,
        long*             Height,
        long*             Depth,
        long*             NumMipLevels,
        long              Usage,
        long*             Format,
        long              Pool)
{

    HRESULT hr;

    hr=::D3DXCheckVolumeTextureRequirements( 
                (IDirect3DDevice8*) Device,
                (UINT*) Width, (UINT*) Height, (UINT*) Depth,
                (UINT*) NumMipLevels,
                (DWORD) Usage,
                (D3DFORMAT*)Format,
                (D3DPOOL) Pool);


    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::CreateVolumeTexture(
    IUnknown            *Device,
    long            Width,
    long            Height,
    long            Depth,
    long            MipLevels,
    long            Usage,
    long            PixelFormat,
    long            Pool,   
    IUnknown        **ppVolumeTexture)
{
    HRESULT hr;

    hr=::D3DXCreateVolumeTexture(
            (IDirect3DDevice8*) Device,
            (UINT)              Width,
            (UINT)              Height,
            (UINT)              Depth,
            (UINT)              MipLevels,
            (DWORD)             Usage,
            (D3DFORMAT)         PixelFormat,
            (D3DPOOL)           Pool,
            (LPDIRECT3DVOLUMETEXTURE8*) ppVolumeTexture);

    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::FilterVolumeTexture(
    IUnknown  *pVolumeTexture,
    void      *pPalette,
    long      SrcLevel,
    long      Filter)
{
    HRESULT hr;

        hr=::D3DXFilterVolumeTexture(
            (LPDIRECT3DVOLUMETEXTURE8)  pVolumeTexture,
            (PALETTEENTRY*)             pPalette,
            (UINT)                      SrcLevel,
            (DWORD)                     Filter);

    return hr;

}

STDMETHODIMP C_dxj_D3DX8Object::LoadVolumeFromVolume(
    IUnknown          *pDestVolume,
    void              *pDestPalette,
    void              *pDestBox,
    IUnknown          *pSrcVolume,
    void              *pSrcPalette,
    void              *pSrcBox,
    long              Filter,
    long              ColorKey)
{ 

    HRESULT hr;

    hr=::D3DXLoadVolumeFromVolume(
            (LPDIRECT3DVOLUME8)     pDestVolume,
            (PALETTEENTRY*)         pDestPalette,
            (D3DBOX*)               pDestBox,
            (LPDIRECT3DVOLUME8)     pSrcVolume,
            (PALETTEENTRY*)         pSrcPalette,
            (D3DBOX*)               pSrcBox,
            (DWORD)                 Filter,
            (D3DCOLOR)              ColorKey);

    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::LoadVolumeFromMemory(
    IUnknown        *pDestVolume,
    void            *pDestPalette,
    void            *pDestRect,
    void            *pSrcMemory,
    long            SrcFormat,
    long            SrcRowPitch,
    long            SrcSlicePitch,
    void            *pSrcPalette,
    void            *pSrcBox,
    long            Filter,
    long            ColorKey)
{
    HRESULT hr;

    hr=::D3DXLoadVolumeFromMemory(
           (LPDIRECT3DVOLUME8)     pDestVolume,
           (PALETTEENTRY*)         pDestPalette,
           (D3DBOX*)               pDestRect,
           (LPVOID)                pSrcMemory,
           (D3DFORMAT)             SrcFormat,
           (UINT)                  SrcRowPitch,
           (UINT)                  SrcSlicePitch,
           (PALETTEENTRY*)         pSrcPalette,
           (D3DBOX*)               pSrcBox,
           (DWORD)                 Filter,
           (D3DCOLOR)              ColorKey);

    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::CreateMesh( 
            /* [in] */ long numFaces,
            /* [in] */ long numVertices,
            /* [in] */ long options,
            /* [in] */ void *Declaration,
            /* [in] */ IUnknown __RPC_FAR *pD3D,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *ppMesh)
{
    HRESULT hr;

    hr=::D3DXCreateMesh(
        (DWORD) numFaces,
        (DWORD) numVertices,
        (DWORD) options,
        (DWORD*) Declaration,
        (LPDIRECT3DDEVICE8)pD3D,
        (ID3DXMesh**)ppMesh);
        
    return hr;
}




STDMETHODIMP C_dxj_D3DX8Object::CreateMeshFVF( 
            /* [in] */ long numFaces,
            /* [in] */ long numVertices,
            /* [in] */ long options,
            /* [in] */ long fvf,
            /* [in] */ IUnknown __RPC_FAR *pD3D,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *ppMesh)
{
    HRESULT hr;
    hr=::D3DXCreateMeshFVF(
        (DWORD) numFaces,
        (DWORD) numVertices,
        (DWORD) options,
        (DWORD) fvf,
        (LPDIRECT3DDEVICE8)pD3D,
        (ID3DXMesh**)ppMesh);
        
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::CreateSPMesh( 
            /* [in] */ D3DXMesh __RPC_FAR *pMesh,
            void* Adjacency, 
            void* VertexAttributeWeights,
            void* VertexWeights,
            /* [retval][out] */ D3DXSPMesh __RPC_FAR *__RPC_FAR *ppSMesh)
{
    HRESULT hr;
    hr=::D3DXCreateSPMesh(
        (ID3DXMesh*)             pMesh,
        (DWORD*)                 Adjacency,
        (LPD3DXATTRIBUTEWEIGHTS) VertexAttributeWeights,
        (float *)                VertexWeights,
        (ID3DXSPMesh**)          ppSMesh);      
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::GeneratePMesh( 
            /* [in] */ D3DXMesh __RPC_FAR *pMesh,
            /* [in] */ void* Adjacency, 
            /* [in] */ void* VertexAttributeWeights,
            /* [in] */ void* VertexWeights,
            /* [in] */ long minValue,
            /* [in] */ long options,
            /* [retval][out] */ D3DXPMesh __RPC_FAR *__RPC_FAR *ppPMesh)
{
    HRESULT hr;
    hr=::D3DXGeneratePMesh(
        (ID3DXMesh*) pMesh,
        (DWORD*) Adjacency,
        (LPD3DXATTRIBUTEWEIGHTS) VertexAttributeWeights,
        (float *) VertexWeights,
        (DWORD) minValue,
        (DWORD) options,
        (ID3DXPMesh**)ppPMesh);     

    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::SimplifyMesh( 
            /* [in] */ D3DXMesh __RPC_FAR *pMesh,
            void* Adjacency, 
            void* VertexAttributeWeights,
            void* VertexWeights,
            long minValue,
            long options,
            D3DXMesh __RPC_FAR *__RPC_FAR *ppMesh)
{
    HRESULT hr;
    hr=::D3DXSimplifyMesh(
        (ID3DXMesh*) pMesh,
        (DWORD*) Adjacency,
        (LPD3DXATTRIBUTEWEIGHTS) VertexAttributeWeights,
        (float *) VertexWeights,
        (DWORD)  minValue,
        (DWORD) options,
        (ID3DXMesh**)ppMesh);       
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::ComputeBoundingSphere( 
            /* [in] */ void __RPC_FAR *PointsFVF,
            /* [in] */ long numVertices,
            /* [in] */ long FVF,
            /* [in] */ D3DVECTOR_CDESC __RPC_FAR *Centers,
            /* [out][in] */ float __RPC_FAR *RadiusArray)
{
    HRESULT hr;
    hr=::D3DXComputeBoundingSphere(
        PointsFVF,
        (DWORD) numVertices,
        (DWORD) FVF,
        (D3DXVECTOR3*) Centers,
        RadiusArray);
    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::ComputeBoundingBox( 
            /* [in] */ void __RPC_FAR *PointsFVF,
            /* [in] */ long numVertices,
            /* [in] */ long FVF,
            /* [out] */ D3DVECTOR_CDESC __RPC_FAR *MinVec,
            /* [out] */ D3DVECTOR_CDESC __RPC_FAR *MaxVec)
{
    HRESULT hr;
    hr=::D3DXComputeBoundingBox(
        PointsFVF,
        (DWORD) numVertices,
        (DWORD) FVF,
        (D3DXVECTOR3*) MinVec,
        (D3DXVECTOR3*) MaxVec);

    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::ComputeNormals( D3DXBaseMesh *pMesh)
{
    HRESULT hr;
    hr=::D3DXComputeNormals((ID3DXBaseMesh*)pMesh, NULL);
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::CreateBuffer( 
            /* [in] */ long numBytes,
            /* [retval][out] */ D3DXBuffer __RPC_FAR *__RPC_FAR *ppBuffer)
{
    HRESULT hr;
    hr=::D3DXCreateBuffer((DWORD) numBytes,(ID3DXBuffer**) ppBuffer);
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::LoadMeshFromX( 
            /* [in] */ BSTR Filename,
            /* [in] */ long options,
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [out] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retAdjacency,
            /* [out] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retMaterials,
            /* [out] */ long __RPC_FAR *retMaterialCount,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *retMesh)
{
    USES_CONVERSION;
    HRESULT hr;
    if (!D3DDevice) return E_INVALIDARG;

	char *szName = NULL;
	__try { szName=W2T(Filename); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
    hr=::D3DXLoadMeshFromX(
        szName,
        (DWORD) options,
        (IDirect3DDevice8*) D3DDevice,
        (ID3DXBuffer**) retAdjacency,
        (ID3DXBuffer**) retMaterials,
        (DWORD*)    retMaterialCount,
        (ID3DXMesh**) retMesh);
        
    return hr;
}



STDMETHODIMP C_dxj_D3DX8Object::SaveMeshToX( 
            /* [in] */ BSTR Filename,
            /* [in] */ D3DXMesh __RPC_FAR *Mesh,
            /* [in] */ void *AdjacencyArray,
            /* [in] */ D3DXMATERIAL_CDESC __RPC_FAR *MaterialArray,
            /* [in] */ long MaterialCount,
            /* [in] */ long xFormat)
{
    HRESULT hr;
    USES_CONVERSION;
	char *szName = NULL;
	__try { szName=W2T(Filename); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
    
    D3DXMATERIAL *pMaterials=NULL;
    if (MaterialCount > 0)  {

        //cleaned up when out of scope
		__try { pMaterials=(D3DXMATERIAL*)alloca(sizeof(D3DXMATERIAL)*MaterialCount);   }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
        if (!pMaterials) return E_OUTOFMEMORY;

        __try 
        {
            for (long i=0; i<MaterialCount; i++)
            {
                memcpy (&(pMaterials[i].MatD3D), &(MaterialArray[i].MatD3D),sizeof(D3DMATERIAL8));
				__try { pMaterials[i].pTextureFilename=W2T(MaterialArray[i].TextureFilename); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
            
            }
        }
        __except(1,1)
        {
           return E_INVALIDARG;
        }

    }


    
    hr=::D3DXSaveMeshToX(
        szName,
        (ID3DXMesh*) Mesh,
        (DWORD*) AdjacencyArray,
        (D3DXMATERIAL*) pMaterials,
        (DWORD) MaterialCount,
        (DWORD) xFormat);
        
    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::SavePMeshToFile( 
            /* [in] */ BSTR Filename,
            /* [in] */ D3DXPMesh __RPC_FAR *Mesh,
            /* [in] */ D3DXMATERIAL_CDESC __RPC_FAR *MaterialArray,
            /* [in] */ long MaterialCount)

{
    HRESULT hr=S_OK;

	if (!Filename)
		return E_INVALIDARG;

    USES_CONVERSION;
	char *szName = NULL;
	__try { szName=W2T(Filename); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

    if (!Mesh) return E_INVALIDARG;

    IStream *pStream= (IStream*) new CFileStream(szName, FALSE,TRUE,&hr);
    if (!pStream) return E_OUTOFMEMORY;
    if FAILED(hr) return hr;


    __try 
    {
	D3DXMATERIAL *pRealMaterials=NULL;
	if (MaterialCount > 0)
        {
                pRealMaterials= (D3DXMATERIAL *) malloc( sizeof(D3DXMATERIAL) * MaterialCount );
                if (!pRealMaterials) 
		{
			pStream->Release();
			return E_OUTOFMEMORY;
		}
        }
        for (long i=0;i<MaterialCount;i++)
	{
                memcpy (&(pRealMaterials[i].MatD3D), &(MaterialArray[i].MatD3D),sizeof (D3DMATERIAL8));

		//can be NULL - freed on return as they are allocated locally
				__try { pRealMaterials[i].pTextureFilename=W2T(MaterialArray[i].TextureFilename); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
        }

        hr=((ID3DXPMesh*)Mesh)->Save(pStream,pRealMaterials,(DWORD)MaterialCount);

	free(pRealMaterials);


    }
    __except(1,1)
    {
        pStream->Release();
        return E_INVALIDARG;
    }

    pStream->Release();
    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::LoadPMeshFromFile( 
            /* [in] */ BSTR Filename,
            /* [in] */ long options,
            /* [in] */ IUnknown __RPC_FAR *pD3DDevice,
            /* [out] */ D3DXBuffer **RetMaterials,
            /* [out] */ long __RPC_FAR *RetNumMaterials,
            /* [retval][out] */ D3DXPMesh __RPC_FAR *__RPC_FAR *RetPMesh) 

{
    HRESULT hr=S_OK;

    USES_CONVERSION;
    if (Filename == NULL)
	return E_INVALIDARG;

	char *szName = NULL;
	__try { szName=W2T(Filename); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

    IStream *pStream= (IStream*) new CFileStream(szName, TRUE,FALSE,&hr);
    if (!pStream) return E_OUTOFMEMORY;
    if FAILED(hr) 
    {
        pStream->Release();
        return hr;
    }

    hr=D3DXCreatePMeshFromStream(
            pStream, 
            (DWORD) options,
            (LPDIRECT3DDEVICE8) pD3DDevice, 
            (LPD3DXBUFFER *)RetMaterials,
            (DWORD*) RetNumMaterials,
            (LPD3DXPMESH *) RetPMesh);

    pStream->Release();
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::LoadMeshFromXof( 
            /* [in] */ IUnknown __RPC_FAR *xofobjMesh,
            /* [in] */ long options,
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [out] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retAdjacency,
            /* [out] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retMaterials,
            /* [out] */ long __RPC_FAR *retMaterialCount,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *retMesh)
{
    HRESULT hr=S_OK;

    IDirectXFileData    *pRealXFileData=NULL;
    I_dxj_DirectXFileData   *pCoverXFileData=NULL;

    if (!xofobjMesh) return E_INVALIDARG;

    hr= xofobjMesh->QueryInterface(IID_IDirectXFileData,(void**)&pRealXFileData);
    if FAILED(hr) 
    {
        hr=xofobjMesh->QueryInterface(IID_I_dxj_DirectXFileData,(void**)&pCoverXFileData);  
            if FAILED(hr) return hr;
    
        //beware does not addref but interface cant go away as long as we have 
        //ref count on cover object
        hr=pCoverXFileData->InternalGetObject((IUnknown**)&pRealXFileData);         
        if (FAILED(hr) || (!pRealXFileData))
        {
            //We should never get here but 
            //Consider changing this to an assert
            pCoverXFileData->Release();
            return E_FAIL;          
        }

        
        pRealXFileData->AddRef();

        pCoverXFileData->Release();
            if FAILED(hr) return hr;
    }


    hr=::D3DXLoadMeshFromXof(
        pRealXFileData,
        (DWORD) options,
        (IDirect3DDevice8*) D3DDevice,
        (ID3DXBuffer**) retAdjacency,
        (ID3DXBuffer**) retMaterials,
        (DWORD*)    retMaterialCount,
        (ID3DXMesh**) retMesh); 
        

    return hr;
}
 
        
STDMETHODIMP C_dxj_D3DX8Object::TessellateNPatches( 
            /* [in] */ D3DXMesh __RPC_FAR *MeshIn,
        /* [in] */ void*Adjacency,
            /* [in] */ float NumSegs,
		VARIANT_BOOL QuadraticInterpNormals,
		/*[in,out, optional] */ D3DXBuffer **AdjacencyOut, 
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *pptmMeshOut)
{
    HRESULT hr;
    BOOL bQuadraticInterpNormals=QuadraticInterpNormals ? TRUE : FALSE;

	
    hr=::D3DXTessellateNPatches(
        (ID3DXMesh*) MeshIn,
        (DWORD*) Adjacency,
        (float) NumSegs,
	bQuadraticInterpNormals,
        (ID3DXMesh**)pptmMeshOut,
	(ID3DXBuffer**)AdjacencyOut);
    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::DeclaratorFromFVF( 
            long FVF,
            D3DXDECLARATOR_CDESC *Declarator)
{
    HRESULT hr;
    hr=::D3DXDeclaratorFromFVF(
        (DWORD) FVF,
        (DWORD*) Declarator);
    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::FVFFromDeclarator( 
            D3DXDECLARATOR_CDESC *Declarator,
            long *FVF)
{
    HRESULT hr;
    hr=::D3DXFVFFromDeclarator(
        (DWORD*) Declarator,
        (DWORD*) FVF);
    return hr;
}




        
STDMETHODIMP C_dxj_D3DX8Object::BufferGetMaterial( 
            /* [in] */ D3DXBuffer __RPC_FAR  *MaterialBuffer,
            /* [in] */ long index,
            /* [retval][out] */ D3DMATERIAL8_CDESC __RPC_FAR *mat)
{
    if (!MaterialBuffer) return E_INVALIDARG;

    D3DXMATERIAL *pMatArray=(D3DXMATERIAL*) ((ID3DXBuffer*)MaterialBuffer)->GetBufferPointer();
    __try {
        memcpy(mat,&(pMatArray[index].MatD3D),sizeof(D3DMATERIAL8));
    }
    __except(1,1){
        return E_INVALIDARG;
    }
    return S_OK;
}

        
STDMETHODIMP C_dxj_D3DX8Object::BufferGetTextureName( 
            /* [in] */ D3DXBuffer __RPC_FAR  *MaterialBuffer,
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *retName)
{
    USES_CONVERSION;
    WCHAR *wszName=NULL;

    if (!MaterialBuffer) return E_INVALIDARG;

    D3DXMATERIAL *pMatArray=(D3DXMATERIAL*)((ID3DXBuffer*)MaterialBuffer)->GetBufferPointer();
    __try {
        wszName=T2W(pMatArray[index].pTextureFilename);
    }
    __except(1,1){
        return E_INVALIDARG;
    }

    *retName=SysAllocString(wszName);

    return S_OK;
}

        
STDMETHODIMP C_dxj_D3DX8Object::BufferGetBoneName( 
            /* [in] */ D3DXBuffer __RPC_FAR  *BoneNameBuffer,
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *retName)
{
    USES_CONVERSION;
    WCHAR *wszName=NULL;

    if (!BoneNameBuffer) return E_INVALIDARG;

    char **ppArray=(char**)((ID3DXBuffer*)BoneNameBuffer)->GetBufferPointer();
    __try {
        wszName=T2W(ppArray[index]);
    }
    __except(1,1){
        return E_INVALIDARG;
    }

    *retName=SysAllocString(wszName);

    return S_OK;
}
        
STDMETHODIMP C_dxj_D3DX8Object::BufferGetData( 
            /* [in] */ D3DXBuffer __RPC_FAR *Buffer,
            /* [in] */ long index,
            /* [in] */ long typesize,
            /* [in] */ long typecount,
            /* [out][in] */ void __RPC_FAR *data)
{

    if (!Buffer) return E_INVALIDARG;

    char *pData=(char*)((ID3DXBuffer*)Buffer)->GetBufferPointer();
    
    DWORD dwStart= (DWORD) index*typesize;
    DWORD dwCount= (DWORD) typecount*typesize;

    __try {
        memcpy(data,&(pData[dwStart]),dwCount);
    }
    __except(1,1){
        return E_INVALIDARG;
    }

    return S_OK;
}


STDMETHODIMP C_dxj_D3DX8Object:: BufferGetBoneCombo( 
            D3DXBuffer  *Buffer,
	    long index,
            D3DXBONECOMBINATION_CDESC *desc)
{

    if (!Buffer) return E_INVALIDARG;

    D3DXBONECOMBINATION_CDESC *pData=(D3DXBONECOMBINATION_CDESC*)((ID3DXBuffer*)Buffer)->GetBufferPointer();
    

    __try {
        memcpy(desc,&(pData[index]),sizeof (D3DXBONECOMBINATION_CDESC));
    }
    __except(1,1){
        return E_INVALIDARG;
    }

    return S_OK;
}

				 
STDMETHODIMP C_dxj_D3DX8Object::BufferGetBoneComboBoneIds( 
            D3DXBuffer  *Buffer,
	    long index,
	    long PaletteSize,
	    void *BoneIds)
{

    if (!Buffer) return E_INVALIDARG;
    if (PaletteSize <=0) return E_INVALIDARG;

    D3DXBONECOMBINATION *pData=(D3DXBONECOMBINATION*)((ID3DXBuffer*)Buffer)->GetBufferPointer();

    __try {
        memcpy(BoneIds,pData[index].BoneId,PaletteSize*sizeof(DWORD));
    }
    __except(1,1){
        return E_INVALIDARG;
    }

    return S_OK;
}


        
STDMETHODIMP C_dxj_D3DX8Object::BufferSetData( 
            /* [in] */ D3DXBuffer __RPC_FAR *Buffer,
            /* [in] */ long index,
            /* [in] */ long typesize,
            /* [in] */ long typecount,
            /* [out][in] */ void __RPC_FAR *data)
{

    if (!Buffer) return E_INVALIDARG;

    char *pData=(char*)((ID3DXBuffer*)Buffer)->GetBufferPointer();
    
    DWORD dwStart= (DWORD) index*typesize;
    DWORD dwCount= (DWORD) typecount*typesize;

    __try {
        memcpy(&(pData[dwStart]),data,dwCount);
    }
    __except(1,1){
        return E_INVALIDARG;
    }

    return S_OK;

}

STDMETHODIMP C_dxj_D3DX8Object::Intersect(
            /* [in] */ D3DXMesh *MeshIn,
            /* [in] */ D3DVECTOR_CDESC *RayPos,
            /* [in] */ D3DVECTOR_CDESC *RayDir,
            /* [out] */ LONG *retHit,
            /* [out] */ LONG *retFaceIndex,
            /* [out] */ FLOAT *U,
            /* [out] */ FLOAT *V,
            /* [out] */ FLOAT *retDist,
            /* [out] */ LONG *countHits,
            /* [retval][out] */ D3DXBuffer **AllHits)
{

    HRESULT hr;
    hr=D3DXIntersect(
            (LPD3DXMESH) MeshIn,
            (D3DXVECTOR3*) RayPos,
            (D3DXVECTOR3*) RayDir,
            (BOOL *)    retHit,
            (DWORD*)    retFaceIndex,
            (float*)    U,
            (float*)    V,
            (float*)    retDist,
			(LPD3DXBUFFER*) AllHits,
			(DWORD*)countHits);
    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::SphereBoundProbe(
    D3DVECTOR_CDESC *Center,
    float Radius,
        D3DVECTOR_CDESC *RayPosition,
        D3DVECTOR_CDESC *RayDirection,
    VARIANT_BOOL *retHit)
{
    BOOL bRet=FALSE;

    bRet=D3DXSphereBoundProbe(
        (D3DXVECTOR3 *) Center,
        Radius,
        (D3DXVECTOR3 *) RayPosition,
        (D3DXVECTOR3 *) RayDirection);
    if (bRet)
    {
    *retHit=VARIANT_TRUE;
    }
    else
    {
    *retHit=VARIANT_FALSE;
    }
    return S_OK;
}



STDMETHODIMP C_dxj_D3DX8Object::ComputeBoundingSphereFromMesh(
                /*[in]*/            D3DXMesh *MeshIn, 
                /*[in]*/            D3DVECTOR_CDESC *Centers, 
                /*[in,out]*/        float *RadiusArray)
{

    HRESULT hr;
    BYTE    *pPointsFVF=NULL;

    if (!MeshIn) return E_INVALIDARG;

    DWORD dwFVF= ((LPD3DXMESH)MeshIn)->GetFVF();
    DWORD dwVertices= ((LPD3DXMESH)MeshIn)->GetNumVertices();   

    hr=((LPD3DXMESH)MeshIn)->LockVertexBuffer(0,&pPointsFVF);
    if FAILED(hr) return hr;
            

    hr=::D3DXComputeBoundingSphere(
        pPointsFVF,
        dwVertices,
        dwFVF,
        (D3DXVECTOR3*) Centers,
        RadiusArray);

    ((LPD3DXMESH)MeshIn)->UnlockVertexBuffer();


    return hr;

}



STDMETHODIMP C_dxj_D3DX8Object::ComputeBoundingBoxFromMesh( 
            /*[in]*/     D3DXMesh *MeshIn, 
            /*[in,out]*/ D3DVECTOR_CDESC *MinArray, 
            /*[in,out]*/ D3DVECTOR_CDESC *MaxArray)

{

    HRESULT hr;
    BYTE    *pPointsFVF=NULL;

    if (!MeshIn) return E_INVALIDARG;

    DWORD dwFVF= ((LPD3DXMESH)MeshIn)->GetFVF();
    DWORD dwVertices= ((LPD3DXMESH)MeshIn)->GetNumVertices();   

    hr=((LPD3DXMESH)MeshIn)->LockVertexBuffer(0,&pPointsFVF);
    if FAILED(hr) return hr;
            

    hr=::D3DXComputeBoundingBox(
        pPointsFVF,
        dwVertices,
        dwFVF,
        (D3DXVECTOR3*) MinArray,
        (D3DXVECTOR3*) MaxArray);


    ((LPD3DXMESH)MeshIn)->UnlockVertexBuffer();


    return hr;

}


STDMETHODIMP C_dxj_D3DX8Object::CreateSkinMesh( 
            /* [in] */ long numFaces,
            /* [in] */ long numVertices,
            /* [in] */ long numBones,
            /* [in] */ long options,
            /* [in] */ void __RPC_FAR *Declaration,
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [retval][out] */ D3DXSkinMesh __RPC_FAR *__RPC_FAR *SkinMesh) 
{
    HRESULT hr;
    hr=::D3DXCreateSkinMesh((DWORD) numFaces,(DWORD)numVertices,
            (DWORD)numBones,(DWORD)options,
            (DWORD *)Declaration,(IDirect3DDevice8*) D3DDevice,
            (ID3DXSkinMesh**) SkinMesh);
    return hr;
}
        
STDMETHODIMP C_dxj_D3DX8Object::CreateSkinMeshFVF( 
            /* [in] */ long numFaces,
            /* [in] */ long numVertices,
            /* [in] */ long numBones,
            /* [in] */ long options,
            /* [in] */ long fvf,
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            D3DXSkinMesh __RPC_FAR *__RPC_FAR *SkinMeshRet) 
{
    HRESULT hr;
    hr =::D3DXCreateSkinMeshFVF((DWORD)numFaces,(DWORD)numVertices,(DWORD)numBones,
            (DWORD)options,(DWORD)fvf,(IDirect3DDevice8*)D3DDevice,
            (ID3DXSkinMesh**) SkinMeshRet);
    
    return hr;
}
        
STDMETHODIMP C_dxj_D3DX8Object::CreateSkinMeshFromMesh( 
            /* [in] */ D3DXMesh __RPC_FAR *Mesh,
            /* [in] */ long numBones,
            /* [retval][out] */ D3DXSkinMesh __RPC_FAR *__RPC_FAR *SkinMeshRet) 
{
    HRESULT hr;
	if (!Mesh)
		return E_INVALIDARG;

    hr=::D3DXCreateSkinMeshFromMesh((ID3DXMesh*) Mesh,(DWORD)numBones,(ID3DXSkinMesh**) SkinMeshRet);
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::LoadSkinMeshFromXof( 
            /* [in] */      IUnknown    *xofobjMesh,
            /* [in] */      long        options,
            /* [in] */      IUnknown    *D3DDevice,
            /* [out][in] */ D3DXBuffer  **RetAdjacency,
            /* [out][in] */ D3DXBuffer  **RetMaterials,
            /* [out][in] */ long        *RetMaterialCount,
            /* [out][in] */ D3DXBuffer  **RetBoneNames,
            /* [out][in] */ D3DXBuffer  **RetBoneTransforms,
            /* [retval][out] */ D3DXSkinMesh **RetMesh) 
{
    HRESULT hr=S_OK;

    IDirectXFileData    *pRealXFileData=NULL;
    I_dxj_DirectXFileData   *pCoverXFileData=NULL;

    if (!xofobjMesh) return E_INVALIDARG;

    hr= xofobjMesh->QueryInterface(IID_IDirectXFileData,(void**)&pRealXFileData);
    if FAILED(hr) 
    {
        hr=xofobjMesh->QueryInterface(IID_I_dxj_DirectXFileData,(void**)&pCoverXFileData);  
            if FAILED(hr) return hr;
    
        //beware does not addref but interface cant go away as long as we have 
        //ref count on cover object
        hr=pCoverXFileData->InternalGetObject((IUnknown**)&pRealXFileData);         
        if (FAILED(hr) || (!pRealXFileData))
        {
            //We should never get here but 
            //Consider changing this to an assert
            pCoverXFileData->Release();
            return E_FAIL;          
        }

        
        pRealXFileData->AddRef();

        pCoverXFileData->Release();
            if FAILED(hr) return hr;
    }


    hr=::D3DXLoadSkinMeshFromXof(
        pRealXFileData,
        (DWORD) options,
        (IDirect3DDevice8*) D3DDevice,
        (ID3DXBuffer**) RetAdjacency,
        (ID3DXBuffer**) RetMaterials,
        (DWORD*)    RetMaterialCount,
        (ID3DXBuffer**) RetBoneNames, 
        (ID3DXBuffer**) RetBoneTransforms,
        (ID3DXSkinMesh**) RetMesh); 
        

    return hr;

}



STDMETHODIMP C_dxj_D3DX8Object::CreatePolygon( 
            /* [in] */  IUnknown __RPC_FAR *D3DDevice,
            /* [in] */  float Length,
            /* [in] */  long Sides,
            /* [out][in] */     D3DXBuffer  **retAdjacency,
            /* [retval][out] */ D3DXMesh    **RetMesh) 
{
    HRESULT hr;
    hr=D3DXCreatePolygon(
        (IDirect3DDevice8*) D3DDevice,
        Length,
        (UINT) Sides,
        (ID3DXMesh**)RetMesh,
        (ID3DXBuffer**)retAdjacency);
    return hr;
}
        
STDMETHODIMP C_dxj_D3DX8Object::CreateBox( 
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [in] */ float Width,
            /* [in] */ float Height,
            /* [in] */ float Depth,
            /* [out][in] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retAdjacency,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *RetMesh) 
{
    HRESULT hr;
    hr=D3DXCreateBox(
        (IDirect3DDevice8*) D3DDevice,
        Width,
        Height,
        Depth,
        (ID3DXMesh**)RetMesh,
        (ID3DXBuffer**)retAdjacency);
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::CreateCylinder( 
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [in] */ float Radius1,
            /* [in] */ float Radius2,
            /* [in] */ float Length,
            /* [in] */ long Slices,
            /* [in] */ long Stacks,
            /* [out][in] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retAdjacency,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *RetMesh)
{
    HRESULT hr;
    hr=D3DXCreateCylinder(
        (IDirect3DDevice8*) D3DDevice,
        Radius1,
        Radius2,
        Length,
        (UINT)Slices,
        (UINT)Stacks,
        (ID3DXMesh**)RetMesh,
        (ID3DXBuffer**)retAdjacency);
    return hr;
}
 
       
STDMETHODIMP C_dxj_D3DX8Object::CreateSphere( 
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [in] */ float Radius,
            /* [in] */ long Slices,
            /* [in] */ long Stacks,
            /* [out][in] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retAdjacency,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *RetMesh)
{
    HRESULT hr;
    hr=D3DXCreateSphere(
        (IDirect3DDevice8*) D3DDevice,
        Radius,
        (UINT)Slices,
        (UINT)Stacks,
        (ID3DXMesh**)RetMesh,
        (ID3DXBuffer**)retAdjacency);
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::CreateTorus( 
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [in] */ float InnerRadius,
            /* [in] */ float OuterRadius,
            /* [in] */ long Sides,
            /* [in] */ long Rings,
            /* [out][in] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retAdjacency,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *RetMesh) 
{
    HRESULT hr;
    hr=D3DXCreateTorus(
        (IDirect3DDevice8*) D3DDevice,
        InnerRadius,
        OuterRadius,
        (UINT)Sides,
        (UINT)Rings,
        (ID3DXMesh**)RetMesh,
        (ID3DXBuffer**)retAdjacency);
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::CreateTeapot( 
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [out][in] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retAdjacency,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *RetMesh)
{
    HRESULT hr;
    hr=D3DXCreateTeapot(
        (IDirect3DDevice8*) D3DDevice,
        (ID3DXMesh**)RetMesh,
        (ID3DXBuffer**)retAdjacency);
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::CreateText( 
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [in] */ HDC hDC,
            /* [in] */ BSTR Text,
            /* [in] */ float Deviation,
            /* [in] */ float Extrusion,
            /* [out][in] */ D3DXMesh __RPC_FAR *__RPC_FAR *RetMesh,
	    /* [in,out] */ D3DXBuffer **AdjacencyOut, 
            /* [out][in] */ void __RPC_FAR *GlyphMetrics)
{
    HRESULT hr;
    hr=D3DXCreateTextW(
        (IDirect3DDevice8*) D3DDevice,
        hDC,
        (WCHAR*)Text,
        Deviation,
        Extrusion,
        (ID3DXMesh**)RetMesh,
	(ID3DXBuffer**)AdjacencyOut,
        (LPGLYPHMETRICSFLOAT) GlyphMetrics);
    return hr;
}

        

STDMETHODIMP C_dxj_D3DX8Object::CreateSprite(
        /* [in] */ IUnknown __RPC_FAR *D3DDevice,
        /* [retval][out] */  D3DXSprite **  retSprite)
{
    HRESULT hr;
    hr=D3DXCreateSprite(
        (IDirect3DDevice8*) D3DDevice,
        (ID3DXSprite **)retSprite);
    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::CreateRenderToSurface(
        IUnknown __RPC_FAR *D3DDevice,
        long Width,
        long Height, 
        long Format, 
        long DepthStencil,
        long DepthStencilFormat,
        D3DXRenderToSurface **RetRenderToSurface)

{
    HRESULT hr;
    hr=D3DXCreateRenderToSurface(
        (IDirect3DDevice8*) D3DDevice,
        (UINT) Width, (UINT) Height, (D3DFORMAT) Format, (BOOL) DepthStencil, (D3DFORMAT) DepthStencilFormat,
        (ID3DXRenderToSurface**) RetRenderToSurface);

    return hr;
}
        
STDMETHODIMP C_dxj_D3DX8Object::CleanMesh( 
                D3DXMesh  *MeshIn,
                void      *Adjacency,
		/* [in][out][optional] */ BSTR *ErrLog,
		/* [out] */ D3DXBuffer *AdjacencyOut,
                D3DXMesh  **MeshOut) 
{
    HRESULT hr;
    LPD3DXBUFFER pBuffer = NULL;
    WCHAR *wszData = NULL;
    USES_CONVERSION;

    hr=::D3DXCleanMesh( (ID3DXMesh*) MeshIn, (DWORD*) Adjacency, (ID3DXMesh**) MeshOut, (DWORD*)AdjacencyOut->GetBufferPointer(), &pBuffer);
			
    if (pBuffer)
    {
      wszData = T2W((TCHAR*)pBuffer->GetBufferPointer());
      *ErrLog = SysAllocString(wszData);
    }
    return hr;
}
        
STDMETHODIMP C_dxj_D3DX8Object::ValidMesh( 
            /* [in] */ D3DXMesh __RPC_FAR *MeshIn,
            /* [in] */ void __RPC_FAR *Adjacency,
		/* [in][out][optional] */ BSTR *ErrLog,
         VARIANT_BOOL *retHit) 
{
    BOOL bRet;
    LPD3DXBUFFER pBuffer = NULL;
    WCHAR *wszData = NULL;
    USES_CONVERSION;

    bRet =D3DXValidMesh( (ID3DXMesh*) MeshIn, (DWORD*) Adjacency, &pBuffer);
    if (bRet){
        *retHit=VARIANT_TRUE;
    }
    else{
        *retHit=VARIANT_FALSE;
    }
			
    if (pBuffer)
    {
      wszData = T2W((TCHAR*)pBuffer->GetBufferPointer());
      *ErrLog = SysAllocString(wszData);
    }
    return S_OK;
}
        
STDMETHODIMP C_dxj_D3DX8Object::BoxBoundProbe( 
            /* [in] */ D3DVECTOR_CDESC __RPC_FAR *MinVert,
            /* [in] */ D3DVECTOR_CDESC __RPC_FAR *MaxVert,
            /* [in] */ D3DVECTOR_CDESC __RPC_FAR *RayPosition,
            /* [in] */ D3DVECTOR_CDESC __RPC_FAR *RayDirection,
                       VARIANT_BOOL              *retHit) 
{

    BOOL bRet;
    
    bRet=::D3DXBoxBoundProbe( (D3DXVECTOR3*) MinVert, 
             (D3DXVECTOR3*) MaxVert,
             (D3DXVECTOR3*) RayPosition,
             (D3DXVECTOR3*) RayDirection);

    if (bRet)
    {
        *retHit=VARIANT_TRUE;
    }
    else
    {
        *retHit=VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP C_dxj_D3DX8Object::SaveSurfaceToFile(
		/* [in] */ BSTR DestFile,
        /* [in] */ LONG DestFormat,
        /* [in] */ IUnknown*        SrcSurface,
        /* [in] */ PALETTEENTRY*       SrcPalette,
        /* [in] */ RECT*               SrcRect)
{
    HRESULT hr;

    hr=::D3DXSaveSurfaceToFileW( 
                (WCHAR*)                DestFile,
				(D3DXIMAGE_FILEFORMAT)DestFormat,
				(LPDIRECT3DSURFACE8) SrcSurface,
				SrcPalette,
				SrcRect);

    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::SaveVolumeToFile(
        /* [in] */ BSTR DestFile,
        /* [in] */ LONG DestFormat,
        /* [in] */ IUnknown*         SrcVolume,
        /* [in] */ PALETTEENTRY*       SrcPalette,
        /* [in] */ void* SrcBox)
{
    HRESULT hr;

    hr=::D3DXSaveVolumeToFileW( 
                (WCHAR*)                DestFile,
				(D3DXIMAGE_FILEFORMAT)DestFormat,
				(LPDIRECT3DVOLUME8) SrcVolume,
				SrcPalette,
				(D3DBOX*)SrcBox);

    return hr;
}
 
STDMETHODIMP C_dxj_D3DX8Object::SaveTextureToFile(
        /* [in] */ BSTR DestFile,
        /* [in] */ LONG DestFormat,
        /* [in] */ IUnknown* SrcTexture,
        /* [in] */ PALETTEENTRY* SrcPalette)
{
    HRESULT hr;

    hr=::D3DXSaveTextureToFileW( 
                (WCHAR*)                DestFile,
				(D3DXIMAGE_FILEFORMAT)DestFormat,
				(LPDIRECT3DBASETEXTURE8) SrcTexture,
				SrcPalette);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3dxmathvb.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxmath.cpp
//  Content:    
//
//////////////////////////////////////////////////////////////////////////////


#include "pchmath.h"
#define EPSILON 0.00001f



#include "d3dxmathvb.inl"

//
// WithinEpsilon - Are two values within EPSILON of each other?
//

static inline BOOL 
WithinEpsilon(float a, float b)
{
    float f = a - b;
    return -EPSILON <= f && f <= EPSILON;
}


//
// sincosf - Compute the sin and cos of an angle at the same time
//

static inline void
sincosf(float angle, float *psin, float *pcos)
{
#ifdef _X86_
#define fsincos __asm _emit 0xd9 __asm _emit 0xfb
    __asm {
        mov eax, psin
        mov edx, pcos
        fld angle
        fsincos
        fstp DWORD ptr [edx]
        fstp DWORD ptr [eax]
    }
#undef fsincos
#else //!_X86_
    *psin = sinf(angle);
    *pcos = cosf(angle);
#endif //!_X86_
}


//--------------------------
// 2D Vector
//--------------------------

D3DXVECTOR2* WINAPI VB_D3DXVec2Normalize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = D3DXVec2LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }    
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
    }

    return pOut;
}

D3DXVECTOR2* WINAPI VB_D3DXVec2Hermite
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pT1, 
      const D3DXVECTOR2 *pV2, const D3DXVECTOR2 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    return pOut;
}

D3DXVECTOR2* WINAPI VB_D3DXVec2CatmullRom
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV0, const D3DXVECTOR2 *pV1,
      const D3DXVECTOR2 *pV2, const D3DXVECTOR2 *pV3, float s )
{
#if DBG
    if(!pOut || !pV0 || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV0 = -s3 + s2 + s2 - s;
    float sV1 = 3.0f * s3 - 5.0f * s2 + 2.0f;
    float sV2 = -3.0f * s3 + 4.0f * s2 + s;
    float sV3 = s3 - s2;

    pOut->x = 0.5f * (sV0 * pV0->x + sV1 * pV1->x + sV2 * pV2->x + sV3 * pV3->x);
    pOut->y = 0.5f * (sV0 * pV0->y + sV1 * pV1->y + sV2 * pV2->y + sV3 * pV3->y);
    return pOut;
}

D3DXVECTOR2* WINAPI VB_D3DXVec2BaryCentric
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      D3DXVECTOR2 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec2Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif


#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+2)*4] ; M32
        faddp st(3), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR4 v;
    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pM->_43;
    v.w = pV->x * pM->_14 + pV->y * pM->_24 + pM->_44;

    *pOut = v;
    return pOut;
#endif // !_X86_
}

D3DXVECTOR2* WINAPI VB_D3DXVec2TransformCoord
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

    float w;

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(2)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(3), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [w]
    }

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pM->_42;
    w   = pV->x * pM->_14 + pV->y * pM->_24 + pM->_44;

    *pOut = *((D3DXVECTOR2 *) &v);
#endif // !_X86_
    
    if(!WithinEpsilon(w, 1.0f))
        *pOut /= w;

    return pOut;
}

D3DXVECTOR2* WINAPI VB_D3DXVec2TransformNormal
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif


#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fxch  st(1)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fxch  st(1)

        faddp st(2), st
        faddp st(2), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR2 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21;
    v.y = pV->x * pM->_12 + pV->y * pM->_22;

    *pOut = v;
    return pOut;
#endif // !_X86_
}


//--------------------------
// 3D Vector
//--------------------------

D3DXVECTOR3* WINAPI VB_D3DXVec3Normalize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = D3DXVec3LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
    }

    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXVec3Hermite
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pT1, 
      const D3DXVECTOR3 *pV2, const D3DXVECTOR3 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    pOut->z = sV1 * pV1->z + sT1 * pT1->z + sV2 * pV2->z + sT2 * pT2->z;
    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXVec3CatmullRom
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV0, const D3DXVECTOR3 *pV1,
      const D3DXVECTOR3 *pV2, const D3DXVECTOR3 *pV3, float s )
{
#if DBG
    if(!pOut || !pV0 || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV0 = -s3 + s2 + s2 - s;
    float sV1 = 3.0f * s3 - 5.0f * s2 + 2.0f;
    float sV2 = -3.0f * s3 + 4.0f * s2 + s;
    float sV3 = s3 - s2;

    pOut->x = 0.5f * (sV0 * pV0->x + sV1 * pV1->x + sV2 * pV2->x + sV3 * pV3->x);
    pOut->y = 0.5f * (sV0 * pV0->y + sV1 * pV1->y + sV2 * pV2->y + sV3 * pV3->y);
    pOut->z = 0.5f * (sV0 * pV0->z + sV1 * pV1->z + sV2 * pV2->z + sV3 * pV3->z);
    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXVec3BaryCentric
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      const D3DXVECTOR3 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    pOut->z = pV1->z + f * (pV2->z - pV1->z) + g * (pV3->z - pV1->z);
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec3Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+2)*4] ; M32
        faddp st(3), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32 + pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33 + pM->_43;
    v.w = pV->x * pM->_14 + pV->y * pM->_24 + pV->z * pM->_34 + pM->_44;

    *pOut = v;
    return pOut;
#endif // !_X86_
}

D3DXVECTOR3* WINAPI VB_D3DXVec3TransformCoord
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

    float w;

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+2)*4] ; M32
        faddp st(3), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [w]
    }

#else // !_X86_
    D3DXVECTOR3 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32 + pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33 + pM->_43;
    w   = pV->x * pM->_14 + pV->y * pM->_24 + pV->z * pM->_34 + pM->_44;

    *pOut = v;
#endif // !_X86_
    
    if(!WithinEpsilon(w, 1.0f))
        *pOut /= w;

    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXVec3TransformNormal
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fxch  st(2)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR3 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33;

    *pOut = v;
    return pOut;
#endif // !_X86_
}

D3DXVECTOR3* WINAPI VB_D3DXVec3Project
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DVIEWPORT8 *pViewport,
      const D3DXMATRIX *pProjection, const D3DXMATRIX *pView, const D3DXMATRIX *pWorld)
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    D3DXMATRIX mat;
    const D3DXMATRIX *pMat = &mat;

    switch(((NULL != pWorld) << 2) | ((NULL != pView) << 1) | (NULL != pProjection))
    {
    case 0: // ---
        D3DXMatrixIdentity(&mat);
        break;

    case 1: // --P
        pMat = pProjection;
        break;

    case 2: // -V-
        pMat = pView;
        break;

    case 3: // -VP
        D3DXMatrixMultiply(&mat, pView, pProjection);
        break;

    case 4: // W--
        pMat = pWorld;
        break;

    case 5: // W-P
        D3DXMatrixMultiply(&mat, pWorld, pProjection);
        break;

    case 6: // WV-
        D3DXMatrixMultiply(&mat, pWorld, pView);
        break;

    case 7: // WVP
        D3DXMatrixMultiply(&mat, pWorld, pView);
        D3DXMatrixMultiply(&mat, &mat, pProjection);
        break;
    }


    D3DXVec3TransformCoord(pOut, pV, pMat);

    if(pViewport)
    {
        pOut->x = ( pOut->x + 1.0f) * 0.5f * (float) pViewport->Width  + (float) pViewport->X;
        pOut->y = (-pOut->y + 1.0f) * 0.5f * (float) pViewport->Height + (float) pViewport->Y;
        pOut->z = pOut->z * (pViewport->MaxZ - pViewport->MinZ) +  pViewport->MinZ;
    }

    return pOut;
}


D3DXVECTOR3* WINAPI VB_D3DXVec3Unproject
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DVIEWPORT8 *pViewport,
      const D3DXMATRIX *pProjection, const D3DXMATRIX *pView, const D3DXMATRIX *pWorld)
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    D3DXMATRIX mat;

    switch(((NULL != pWorld) << 2) | ((NULL != pView) << 1) | (NULL != pProjection))
    {
    case 0: // ---
        D3DXMatrixIdentity(&mat);
        break;

    case 1: // --P
        D3DXMatrixInverse(&mat, NULL, pProjection);
        break;

    case 2: // -V-
        D3DXMatrixInverse(&mat, NULL, pView);
        break;

    case 3: // -VP
        D3DXMatrixMultiply(&mat, pView, pProjection);
        D3DXMatrixInverse(&mat, NULL, &mat);
        break;

    case 4: // W--
        D3DXMatrixInverse(&mat, NULL, pWorld);
        break;

    case 5: // W-P
        D3DXMatrixMultiply(&mat, pWorld, pProjection);
        D3DXMatrixInverse(&mat, NULL, &mat);
        break;

    case 6: // WV-
        D3DXMatrixMultiply(&mat, pWorld, pView);
        D3DXMatrixInverse(&mat, NULL, &mat);
        break;

    case 7: // WVP
        D3DXMatrixMultiply(&mat, pWorld, pView);
        D3DXMatrixMultiply(&mat, &mat, pProjection);
        D3DXMatrixInverse(&mat, NULL, &mat);
        break;
    }


    if(pViewport)
    {
        pOut->x = (pV->x - (float) pViewport->X) / (float) pViewport->Width * 2.0f - 1.0f;
        pOut->y = -((pV->y - (float) pViewport->Y) / (float) pViewport->Height * 2.0f - 1.0f);
        pOut->z = (pV->z - pViewport->MinZ) / (pViewport->MaxZ - pViewport->MinZ);

        D3DXVec3TransformCoord(pOut, pOut, &mat);
    }
    else
    {
        D3DXVec3TransformCoord(pOut, pV, &mat);
    }

    return pOut;
}


//--------------------------
// 4D Vector
//--------------------------

D3DXVECTOR4* WINAPI VB_D3DXVec4Cross
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2, 
      const D3DXVECTOR4 *pV3)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    D3DXVECTOR4 v;

    v.x = pV1->y * (pV2->z * pV3->w - pV3->z * pV2->w) -
          pV1->z * (pV2->y * pV3->w - pV3->y * pV2->w) +
          pV1->w * (pV2->y * pV3->z - pV3->y * pV2->z);

    v.y = pV1->x * (pV3->z * pV2->w - pV2->z * pV3->w) -
          pV1->z * (pV3->x * pV2->w - pV2->x * pV3->w) +
          pV1->w * (pV3->x * pV2->z - pV2->x * pV3->z);

    v.z = pV1->x * (pV2->y * pV3->w - pV3->y * pV2->w) -
          pV1->y * (pV2->x * pV3->w - pV3->x * pV2->w) +
          pV1->w * (pV2->x * pV3->y - pV3->x * pV2->y);

    v.w = pV1->x * (pV3->y * pV2->z - pV2->y * pV3->z) -
          pV1->y * (pV3->x * pV2->z - pV2->x * pV3->z) +
          pV1->z * (pV3->x * pV2->y - pV2->x * pV3->y);

    *pOut = v;
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4Normalize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = D3DXVec4LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4Hermite
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pT1, 
      const D3DXVECTOR4 *pV2, const D3DXVECTOR4 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    pOut->z = sV1 * pV1->z + sT1 * pT1->z + sV2 * pV2->z + sT2 * pT2->z;
    pOut->w = sV1 * pV1->w + sT1 * pT1->w + sV2 * pV2->w + sT2 * pT2->w;
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4CatmullRom
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV0, const D3DXVECTOR4 *pV1,
      const D3DXVECTOR4 *pV2, const D3DXVECTOR4 *pV3, float s )
{
#if DBG
    if(!pOut || !pV0 || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV0 = -s3 + s2 + s2 - s;
    float sV1 = 3.0f * s3 - 5.0f * s2 + 2.0f;
    float sV2 = -3.0f * s3 + 4.0f * s2 + s;
    float sV3 = s3 - s2;

    pOut->x = 0.5f * (sV0 * pV0->x + sV1 * pV1->x + sV2 * pV2->x + sV3 * pV3->x);
    pOut->y = 0.5f * (sV0 * pV0->y + sV1 * pV1->y + sV2 * pV2->y + sV3 * pV3->y);
    pOut->z = 0.5f * (sV0 * pV0->z + sV1 * pV1->z + sV2 * pV2->z + sV3 * pV3->z);
    pOut->w = 0.5f * (sV0 * pV0->w + sV1 * pV1->w + sV2 * pV2->w + sV3 * pV3->w);
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4BaryCentric
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      const D3DXVECTOR4 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    pOut->z = pV1->z + f * (pV2->z - pV1->z) + g * (pV3->z - pV1->z);
    pOut->w = pV1->w + f * (pV2->w - pV1->w) + g * (pV3->w - pV1->w);
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+0)*4] ; M30
        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+2)*4] ; M32
        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+1)*4] ; M31
        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+3)*4] ; M33
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31 + pV->w * pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32 + pV->w * pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33 + pV->w * pM->_43;
    v.w = pV->x * pM->_14 + pV->y * pM->_24 + pV->z * pM->_34 + pV->w * pM->_44;

    *pOut = v;
    return pOut;
#endif // !_X86_
}


//--------------------------
// 4D Matrix
//--------------------------

float WINAPI VB_D3DXMatrixfDeterminant
    ( const D3DXMATRIX *pM )
{
#if DBG
    if(!pM)
        return 0.0f;
#endif

    return (pM->_11 * (pM->_22 * (pM->_33 * pM->_44 - pM->_43 * pM->_34) -
                       pM->_23 * (pM->_32 * pM->_44 - pM->_42 * pM->_34) +
                       pM->_24 * (pM->_32 * pM->_43 - pM->_42 * pM->_33)))

         - (pM->_12 * (pM->_21 * (pM->_33 * pM->_44 - pM->_43 * pM->_34) -
                       pM->_23 * (pM->_31 * pM->_44 - pM->_41 * pM->_34) +
                       pM->_24 * (pM->_31 * pM->_43 - pM->_41 * pM->_33)))

         + (pM->_13 * (pM->_21 * (pM->_32 * pM->_44 - pM->_42 * pM->_34) -
                       pM->_22 * (pM->_31 * pM->_44 - pM->_41 * pM->_34) +
                       pM->_24 * (pM->_31 * pM->_42 - pM->_41 * pM->_32)))

         - (pM->_14 * (pM->_21 * (pM->_32 * pM->_43 - pM->_42 * pM->_33) -
                       pM->_22 * (pM->_31 * pM->_43 - pM->_41 * pM->_33) +
                       pM->_23 * (pM->_31 * pM->_42 - pM->_41 * pM->_32)));
}


D3DXMATRIX* WINAPI VB_D3DXMatrixMultiply
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM1, const D3DXMATRIX *pM2 )
{
#if DBG
    if(!pOut || !pM1 || !pM2)
        return NULL;
#endif

#ifdef _X86_
#define MAT(m,a,b) DWORD PTR [(m)+(a)*4+(b)*4]

    D3DXMATRIX Out;

    if(pM2 != pOut)
        goto LRowByColumn;
    if(pM1 != pOut)
        goto LColumnByRow;

    Out = *pM2;
    pM2 = &Out;
    goto LRowByColumn;


LRowByColumn:
    __asm {     
        mov ebx, DWORD PTR[pOut]    // result
        mov ecx, DWORD PTR[pM1]     // a
        mov edx, DWORD PTR[pM2]     // b
        mov edi, -4

    LLoopRow:
        mov esi, -4

        fld MAT(ecx, 0, 0)          // a0
        fld MAT(ecx, 0, 1)          // a1 
        fld MAT(ecx, 0, 2)          // a2  
        fld MAT(ecx, 0, 3)          // a3

    LLoopColumn:
        fld st(3)                   // a0
        fmul MAT(edx, esi, 1*4)     // a0*b0
        fld st(3)                   // a1
        fmul MAT(edx, esi, 2*4)     // a1*b1
        fld st(3)                   // a2
        fmul MAT(edx, esi, 3*4)     // a2*b2
        fld st(3)                   // a3
        fmul MAT(edx, esi, 4*4)     // a3*b3

        fxch st(3)
        faddp st(1), st             // a2*b2+a0*b0
        fxch st(2)
        faddp st(1), st             // a3*b3+a1*b1
        faddp st(1), st             // a3*b3+a1*b1+a2*b2+a0*b0
        fstp MAT(ebx, esi, 4)

        inc esi
        jnz LLoopColumn

        ffree st(3)
        ffree st(2)
        ffree st(1)
        ffree st(0)

        lea ecx, MAT(ecx, 0, 4)
        lea ebx, MAT(ebx, 0, 4)

        inc edi
        jnz LLoopRow
    }

    return pOut;


LColumnByRow:
    __asm {     
        mov ebx, DWORD PTR[pOut]    // result
        mov ecx, DWORD PTR[pM1]     // a
        mov edx, DWORD PTR[pM2]     // b
        mov edi, -4

    LLoopColumn2:
        mov esi, -16

        fld MAT(edx, edi, 1*4);     // b0
        fld MAT(edx, edi, 2*4);     // b1
        fld MAT(edx, edi, 3*4);     // b2
        fld MAT(edx, edi, 4*4);     // b3

    LLoopRow2:
        fld st(3)                   // b0
        fmul MAT(ecx, esi, 0+16)    // a0*b0
        fld st(3)                   // b1
        fmul MAT(ecx, esi, 1+16)    // a1*b1
        fld st(3)                   // b2
        fmul MAT(ecx, esi, 2+16)    // a2*b2
        fld st(3)                   // b3
        fmul MAT(ecx, esi, 3+16)    // a3*b3

        fxch st(3)
        faddp st(1), st             // a2*b2+a0*b0
        fxch st(2)
        faddp st(1), st             // a3*b3+a1*b1
        faddp st(1), st             // a3*b3+a1*b1+a2*b2+a0*b0
        fstp MAT(ebx, esi, 0+16)

        add esi, 4
        jnz LLoopRow2

        ffree st(3)
        ffree st(2)
        ffree st(1)
        ffree st(0)

        lea ebx, MAT(ebx, 0, 1)
        inc edi
        jnz LLoopColumn2
    }

    return pOut;
#undef MAT
#else //!_X86_
    D3DXMATRIX Out;
    D3DXMATRIX *pM = (pOut == pM1 || pOut == pM2) ? &Out : pOut;

    pM->_11 = pM1->_11 * pM2->_11 + pM1->_12 * pM2->_21 + pM1->_13 * pM2->_31 + pM1->_14 * pM2->_41;
    pM->_12 = pM1->_11 * pM2->_12 + pM1->_12 * pM2->_22 + pM1->_13 * pM2->_32 + pM1->_14 * pM2->_42;
    pM->_13 = pM1->_11 * pM2->_13 + pM1->_12 * pM2->_23 + pM1->_13 * pM2->_33 + pM1->_14 * pM2->_43;
    pM->_14 = pM1->_11 * pM2->_14 + pM1->_12 * pM2->_24 + pM1->_13 * pM2->_34 + pM1->_14 * pM2->_44;

    pM->_21 = pM1->_21 * pM2->_11 + pM1->_22 * pM2->_21 + pM1->_23 * pM2->_31 + pM1->_24 * pM2->_41;
    pM->_22 = pM1->_21 * pM2->_12 + pM1->_22 * pM2->_22 + pM1->_23 * pM2->_32 + pM1->_24 * pM2->_42;
    pM->_23 = pM1->_21 * pM2->_13 + pM1->_22 * pM2->_23 + pM1->_23 * pM2->_33 + pM1->_24 * pM2->_43;
    pM->_24 = pM1->_21 * pM2->_14 + pM1->_22 * pM2->_24 + pM1->_23 * pM2->_34 + pM1->_24 * pM2->_44;

    pM->_31 = pM1->_31 * pM2->_11 + pM1->_32 * pM2->_21 + pM1->_33 * pM2->_31 + pM1->_34 * pM2->_41;
    pM->_32 = pM1->_31 * pM2->_12 + pM1->_32 * pM2->_22 + pM1->_33 * pM2->_32 + pM1->_34 * pM2->_42;
    pM->_33 = pM1->_31 * pM2->_13 + pM1->_32 * pM2->_23 + pM1->_33 * pM2->_33 + pM1->_34 * pM2->_43;
    pM->_34 = pM1->_31 * pM2->_14 + pM1->_32 * pM2->_24 + pM1->_33 * pM2->_34 + pM1->_34 * pM2->_44;

    pM->_41 = pM1->_41 * pM2->_11 + pM1->_42 * pM2->_21 + pM1->_43 * pM2->_31 + pM1->_44 * pM2->_41;
    pM->_42 = pM1->_41 * pM2->_12 + pM1->_42 * pM2->_22 + pM1->_43 * pM2->_32 + pM1->_44 * pM2->_42;
    pM->_43 = pM1->_41 * pM2->_13 + pM1->_42 * pM2->_23 + pM1->_43 * pM2->_33 + pM1->_44 * pM2->_43;
    pM->_44 = pM1->_41 * pM2->_14 + pM1->_42 * pM2->_24 + pM1->_43 * pM2->_34 + pM1->_44 * pM2->_44;

    if(pM != pOut)
        *pOut = *pM;

    return pOut;
#endif //!_X86_
}

D3DXMATRIX* WINAPI VB_D3DXMatrixTranspose
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif

    float f;

    f = pM->_12; pOut->_12 = pM->_21; pOut->_21 = f;
    f = pM->_13; pOut->_13 = pM->_31; pOut->_31 = f;
    f = pM->_14; pOut->_14 = pM->_41; pOut->_41 = f;
    f = pM->_23; pOut->_23 = pM->_32; pOut->_32 = f;
    f = pM->_24; pOut->_24 = pM->_42; pOut->_42 = f;
    f = pM->_34; pOut->_34 = pM->_43; pOut->_43 = f;

    if(pOut != pM)
    {
        pOut->_11 = pM->_11;
        pOut->_22 = pM->_22;
        pOut->_33 = pM->_33;
        pOut->_44 = pM->_44;
    }

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixInverse
    ( D3DXMATRIX *pOut, float *pfDeterminant, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif

    // XXXlorenmcq - The code was designed to work on a processor with more 
    //  than 4 general-purpose registers.  Is there a more optimal way of 
    //  doing this on X86?

    float fX00, fX01, fX02;
    float fX10, fX11, fX12;
    float fX20, fX21, fX22;
    float fX30, fX31, fX32;
    float fY01, fY02, fY03, fY12, fY13, fY23;
    float fZ02, fZ03, fZ12, fZ13, fZ22, fZ23, fZ32, fZ33;

#define fX03 fX01
#define fX13 fX11
#define fX23 fX21
#define fX33 fX31
#define fZ00 fX02
#define fZ10 fX12
#define fZ20 fX22
#define fZ30 fX32
#define fZ01 fX03
#define fZ11 fX13
#define fZ21 fX23
#define fZ31 fX33
#define fDet fY01
#define fRcp fY02

    // read 1st two columns of matrix
    fX00 = pM->_11;
    fX01 = pM->_12;
    fX10 = pM->_21;
    fX11 = pM->_22;
    fX20 = pM->_31;
    fX21 = pM->_32;
    fX30 = pM->_41;
    fX31 = pM->_42;

    // compute all six 2x2 determinants of 1st two columns
    fY01 = fX00 * fX11 - fX10 * fX01;
    fY02 = fX00 * fX21 - fX20 * fX01;
    fY03 = fX00 * fX31 - fX30 * fX01;
    fY12 = fX10 * fX21 - fX20 * fX11;
    fY13 = fX10 * fX31 - fX30 * fX11;
    fY23 = fX20 * fX31 - fX30 * fX21;

    // read 2nd two columns of matrix
    fX02 = pM->_13;
    fX03 = pM->_14;
    fX12 = pM->_23;
    fX13 = pM->_24;
    fX22 = pM->_33;
    fX23 = pM->_34;
    fX32 = pM->_43;
    fX33 = pM->_44;

    // compute all 3x3 cofactors for 2nd two columns
    fZ33 = fX02 * fY12 - fX12 * fY02 + fX22 * fY01;
    fZ23 = fX12 * fY03 - fX32 * fY01 - fX02 * fY13;
    fZ13 = fX02 * fY23 - fX22 * fY03 + fX32 * fY02;
    fZ03 = fX22 * fY13 - fX32 * fY12 - fX12 * fY23;
    fZ32 = fX13 * fY02 - fX23 * fY01 - fX03 * fY12;
    fZ22 = fX03 * fY13 - fX13 * fY03 + fX33 * fY01;
    fZ12 = fX23 * fY03 - fX33 * fY02 - fX03 * fY23;
    fZ02 = fX13 * fY23 - fX23 * fY13 + fX33 * fY12;

    // compute all six 2x2 determinants of 2nd two columns
    fY01 = fX02 * fX13 - fX12 * fX03;
    fY02 = fX02 * fX23 - fX22 * fX03;
    fY03 = fX02 * fX33 - fX32 * fX03;
    fY12 = fX12 * fX23 - fX22 * fX13;
    fY13 = fX12 * fX33 - fX32 * fX13;
    fY23 = fX22 * fX33 - fX32 * fX23;

    // read 1st two columns of matrix
    fX00 = pM->_11;
    fX01 = pM->_12;
    fX10 = pM->_21;
    fX11 = pM->_22;
    fX20 = pM->_31;
    fX21 = pM->_32;
    fX30 = pM->_41;
    fX31 = pM->_42;

    // compute all 3x3 cofactors for 1st two columns
    fZ30 = fX11 * fY02 - fX21 * fY01 - fX01 * fY12;
    fZ20 = fX01 * fY13 - fX11 * fY03 + fX31 * fY01;
    fZ10 = fX21 * fY03 - fX31 * fY02 - fX01 * fY23;
    fZ00 = fX11 * fY23 - fX21 * fY13 + fX31 * fY12;
    fZ31 = fX00 * fY12 - fX10 * fY02 + fX20 * fY01;
    fZ21 = fX10 * fY03 - fX30 * fY01 - fX00 * fY13;
    fZ11 = fX00 * fY23 - fX20 * fY03 + fX30 * fY02;
    fZ01 = fX20 * fY13 - fX30 * fY12 - fX10 * fY23;

    // compute 4x4 determinant & its reciprocal
    fDet = fX30 * fZ30 + fX20 * fZ20 + fX10 * fZ10 + fX00 * fZ00;

    if(pfDeterminant)
        *pfDeterminant = fDet;

    fRcp = 1.0f / fDet;

    if(!_finite(fRcp))
        return NULL;


    // multiply all 3x3 cofactors by reciprocal & transpose
    pOut->_11 = fZ00 * fRcp;
    pOut->_12 = fZ10 * fRcp;
    pOut->_13 = fZ20 * fRcp;
    pOut->_14 = fZ30 * fRcp;
    pOut->_21 = fZ01 * fRcp;
    pOut->_22 = fZ11 * fRcp;
    pOut->_23 = fZ21 * fRcp;
    pOut->_24 = fZ31 * fRcp;
    pOut->_31 = fZ02 * fRcp;
    pOut->_32 = fZ12 * fRcp;
    pOut->_33 = fZ22 * fRcp;
    pOut->_34 = fZ32 * fRcp;
    pOut->_41 = fZ03 * fRcp;
    pOut->_42 = fZ13 * fRcp;
    pOut->_43 = fZ23 * fRcp;
    pOut->_44 = fZ33 * fRcp;

    
    return pOut;
}



D3DXMATRIX* WINAPI VB_D3DXMatrixScaling
    ( D3DXMATRIX *pOut, float sx, float sy, float sz )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_12 = pOut->_13 = pOut->_14 =
    pOut->_21 = pOut->_23 = pOut->_24 =
    pOut->_31 = pOut->_32 = pOut->_34 =
    pOut->_41 = pOut->_42 = pOut->_43 = 0.0f;

    pOut->_11 = sx;
    pOut->_22 = sy;
    pOut->_33 = sz;
    pOut->_44 = 1.0f;
    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixTranslation
    ( D3DXMATRIX *pOut, float x, float y, float z )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_12 = pOut->_13 = pOut->_14 =
    pOut->_21 = pOut->_23 = pOut->_24 =
    pOut->_31 = pOut->_32 = pOut->_34 = 0.0f;

    pOut->_11 = pOut->_22 = pOut->_33 = pOut->_44 = 1.0f;

    pOut->_41 = x;
    pOut->_42 = y;
    pOut->_43 = z;
    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixRotationX
    ( D3DXMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->_11 = 1.0f; pOut->_12 = 0.0f; pOut->_13 = 0.0f; pOut->_14 = 0.0f;
    pOut->_21 = 0.0f; pOut->_22 =    c; pOut->_23 =    s; pOut->_24 = 0.0f;
    pOut->_31 = 0.0f; pOut->_32 =   -s; pOut->_33 =    c; pOut->_34 = 0.0f;
    pOut->_41 = 0.0f; pOut->_42 = 0.0f; pOut->_43 = 0.0f; pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationY
    ( D3DXMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->_11 =    c; pOut->_12 = 0.0f; pOut->_13 =   -s; pOut->_14 = 0.0f;
    pOut->_21 = 0.0f; pOut->_22 = 1.0f; pOut->_23 = 0.0f; pOut->_24 = 0.0f;
    pOut->_31 =    s; pOut->_32 = 0.0f; pOut->_33 =    c; pOut->_34 = 0.0f;
    pOut->_41 = 0.0f; pOut->_42 = 0.0f; pOut->_43 = 0.0f; pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationZ
    ( D3DXMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->_11 =    c; pOut->_12 =    s; pOut->_13 = 0.0f; pOut->_14 = 0.0f;
    pOut->_21 =   -s; pOut->_22 =    c; pOut->_23 = 0.0f; pOut->_24 = 0.0f;
    pOut->_31 = 0.0f; pOut->_32 = 0.0f; pOut->_33 = 1.0f; pOut->_34 = 0.0f;
    pOut->_41 = 0.0f; pOut->_42 = 0.0f; pOut->_43 = 0.0f; pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationAxis
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pV, float angle )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);
    float c1 = 1 - c;

    D3DXVECTOR3 v = *pV;
    VB_D3DXVec3Normalize(&v, &v);

    float xyc1 = v.x * v.y * c1;
    float yzc1 = v.y * v.z * c1;
    float zxc1 = v.z * v.x * c1;

    pOut->_11 = v.x * v.x * c1 + c;
    pOut->_12 = xyc1 + v.z * s;
    pOut->_13 = zxc1 - v.y * s;
    pOut->_14 = 0.0f;

    pOut->_21 = xyc1 - v.z * s;
    pOut->_22 = v.y * v.y * c1 + c;
    pOut->_23 = yzc1 + v.x * s;
    pOut->_24 = 0.0f;

    pOut->_31 = zxc1 + v.y * s;
    pOut->_32 = yzc1 - v.x * s;
    pOut->_33 = v.z * v.z * c1 + c;
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = 0.0f;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationQuaternion
    ( D3DXMATRIX *pOut, const D3DXQUATERNION *pQ)
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float x2 = pQ->x + pQ->x;
    float y2 = pQ->y + pQ->y;
    float z2 = pQ->z + pQ->z;

    float wx2 = pQ->w * x2;
    float wy2 = pQ->w * y2;
    float wz2 = pQ->w * z2;
    float xx2 = pQ->x * x2;
    float xy2 = pQ->x * y2;
    float xz2 = pQ->x * z2;
    float yy2 = pQ->y * y2;
    float yz2 = pQ->y * z2;
    float zz2 = pQ->z * z2;

    pOut->_11 = 1.0f - yy2 - zz2;
    pOut->_12 = xy2 + wz2;
    pOut->_13 = xz2 - wy2;
    pOut->_14 = 0.0f;

    pOut->_21 = xy2 - wz2;
    pOut->_22 = 1.0f - xx2 - zz2;
    pOut->_23 = yz2 + wx2;
    pOut->_24 = 0.0f;

    pOut->_31 = xz2 + wy2;
    pOut->_32 = yz2 - wx2;
    pOut->_33 = 1.0f - xx2 - yy2;
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = 0.0f;
    pOut->_44 = 1.0f;


    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationYawPitchRoll
    ( D3DXMATRIX *pOut, float yaw, float pitch, float roll )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    D3DXQUATERNION q;

    D3DXQuaternionRotationYawPitchRoll(&q, yaw, pitch, roll);
    D3DXMatrixRotationQuaternion(pOut, &q);

    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixTransformation
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pScalingCenter, 
      const D3DXQUATERNION *pScalingRotation, const D3DXVECTOR3 *pScaling,
      const D3DXVECTOR3 *pRotationCenter, const D3DXQUATERNION *pRotation,
      const D3DXVECTOR3 *pTranslation)
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    D3DXMATRIX matS, matR, matRI;

    if (pScaling)
    {
        if (pScalingRotation)
        {
            matS._12 = matS._13 = matS._14 =
            matS._21 = matS._23 = matS._24 =
            matS._31 = matS._32 = matS._34 =
            matS._41 = matS._42 = matS._43 = 0.0f;

            matS._11 = pScaling->x;
            matS._22 = pScaling->y;
            matS._33 = pScaling->z;
            matS._44 = 1.0f;

            D3DXMatrixRotationQuaternion(&matR, pScalingRotation);


            if (pScalingCenter)
            {
                // SC-1, SR-1, S, SR, SC
                D3DXMatrixTranspose(&matRI, &matR);
                D3DXMatrixIdentity(pOut);

                pOut->_41 -= pScalingCenter->x;
                pOut->_42 -= pScalingCenter->y;
                pOut->_43 -= pScalingCenter->z;

                D3DXMatrixMultiply(pOut, pOut, &matRI);
                D3DXMatrixMultiply(pOut, pOut, &matS);
                D3DXMatrixMultiply(pOut, pOut, &matR);

                pOut->_41 += pScalingCenter->x;
                pOut->_42 += pScalingCenter->y;
                pOut->_43 += pScalingCenter->z;
            }
            else
            {
                // SR-1, S, SR
                D3DXMatrixTranspose(pOut, &matR);
                D3DXMatrixMultiply(pOut, pOut, &matS);
                D3DXMatrixMultiply(pOut, pOut, &matR);
            }
        }
        else
        {
            // S
            pOut->_12 = pOut->_13 = pOut->_14 =
            pOut->_21 = pOut->_23 = pOut->_24 =
            pOut->_31 = pOut->_32 = pOut->_34 =
            pOut->_41 = pOut->_42 = pOut->_43 = 0.0f;

            pOut->_11 = pScaling->x;
            pOut->_22 = pScaling->y;
            pOut->_33 = pScaling->z;
            pOut->_44 = 1.0f;
        }

    }
    else
    {
        D3DXMatrixIdentity(pOut);
    }

    if (pRotation)
    {
        D3DXMatrixRotationQuaternion(&matR, pRotation);

        if (pRotationCenter)
        {
            // RC-1, R, RC
            pOut->_41 -= pRotationCenter->x;
            pOut->_42 -= pRotationCenter->y;
            pOut->_43 -= pRotationCenter->z;

            D3DXMatrixMultiply(pOut, pOut, &matR);

            pOut->_41 += pRotationCenter->x;
            pOut->_42 += pRotationCenter->y;
            pOut->_43 += pRotationCenter->z;
        }
        else
        {
            // R
            D3DXMatrixMultiply(pOut, pOut, &matR);
        }
    }

    if (pTranslation)
    {
        // T
        pOut->_41 += pTranslation->x;
        pOut->_42 += pTranslation->y;
        pOut->_43 += pTranslation->z;
    }
    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixAffineTransformation
    ( D3DXMATRIX *pOut, float Scaling, const D3DXVECTOR3 *pRotationCenter, 
      const D3DXQUATERNION *pRotation, const D3DXVECTOR3 *pTranslation)
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    // S
    pOut->_12 = pOut->_13 = pOut->_14 =
    pOut->_21 = pOut->_23 = pOut->_24 =
    pOut->_31 = pOut->_32 = pOut->_34 =
    pOut->_41 = pOut->_42 = pOut->_43 = 0.0f;

    pOut->_11 = Scaling;
    pOut->_22 = Scaling;
    pOut->_33 = Scaling;
    pOut->_44 = 1.0f;


    if (pRotation)
    {
        D3DXMATRIX matR;
        D3DXMatrixRotationQuaternion(&matR, pRotation);

        if (pRotationCenter)
        {
            // RC-1, R, RC
            pOut->_41 -= pRotationCenter->x;
            pOut->_42 -= pRotationCenter->y;
            pOut->_43 -= pRotationCenter->z;

            D3DXMatrixMultiply(pOut, pOut, &matR);

            pOut->_41 += pRotationCenter->x;
            pOut->_42 += pRotationCenter->y;
            pOut->_43 += pRotationCenter->z;
        }
        else
        {
            // R
            D3DXMatrixMultiply(pOut, pOut, &matR);
        }
    }


    if (pTranslation)
    {
        // T
        pOut->_41 += pTranslation->x;
        pOut->_42 += pTranslation->y;
        pOut->_43 += pTranslation->z;
    }

    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixLookAtRH
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp )
{
#if DBG
    if(!pOut || !pEye || !pAt || !pUp)
        return NULL;
#endif

    D3DXVECTOR3 XAxis, YAxis, ZAxis;

    // Compute direction of gaze. (-Z)
    D3DXVec3Subtract(&ZAxis, pEye, pAt);
    D3DXVec3Normalize(&ZAxis, &ZAxis);

    // Compute orthogonal axes from cross product of gaze and pUp vector.
    D3DXVec3Cross(&XAxis, pUp, &ZAxis);
    D3DXVec3Normalize(&XAxis, &XAxis);
    D3DXVec3Cross(&YAxis, &ZAxis, &XAxis);

    // Set rotation and translate by pEye
    pOut->_11 = XAxis.x;
    pOut->_21 = XAxis.y;
    pOut->_31 = XAxis.z;
    pOut->_41 = -D3DXVec3Dot(&XAxis, pEye);

    pOut->_12 = YAxis.x;
    pOut->_22 = YAxis.y;
    pOut->_32 = YAxis.z;
    pOut->_42 = -D3DXVec3Dot(&YAxis, pEye);

    pOut->_13 = ZAxis.x;
    pOut->_23 = ZAxis.y;
    pOut->_33 = ZAxis.z;
    pOut->_43 = -D3DXVec3Dot(&ZAxis, pEye);

    pOut->_14 = 0.0f;
    pOut->_24 = 0.0f;
    pOut->_34 = 0.0f;
    pOut->_44 = 1.0f;

    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixLookAtLH
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp )
{
#if DBG
    if(!pOut || !pEye || !pAt || !pUp)
        return NULL;
#endif

    D3DXVECTOR3 XAxis, YAxis, ZAxis;

    // Compute direction of gaze. (+Z)
    D3DXVec3Subtract(&ZAxis, pAt, pEye);
    D3DXVec3Normalize(&ZAxis, &ZAxis);

    // Compute orthogonal axes from cross product of gaze and pUp vector.
    D3DXVec3Cross(&XAxis, pUp, &ZAxis);
    D3DXVec3Normalize(&XAxis, &XAxis);
    D3DXVec3Cross(&YAxis, &ZAxis, &XAxis);

    // Set rotation and translate by pEye
    pOut->_11 = XAxis.x;
    pOut->_21 = XAxis.y;
    pOut->_31 = XAxis.z;
    pOut->_41 = -D3DXVec3Dot(&XAxis, pEye);

    pOut->_12 = YAxis.x;
    pOut->_22 = YAxis.y;
    pOut->_32 = YAxis.z;
    pOut->_42 = -D3DXVec3Dot(&YAxis, pEye);

    pOut->_13 = ZAxis.x;
    pOut->_23 = ZAxis.y;
    pOut->_33 = ZAxis.z;
    pOut->_43 = -D3DXVec3Dot(&ZAxis, pEye);

    pOut->_14 = 0.0f;
    pOut->_24 = 0.0f;
    pOut->_34 = 0.0f;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveRH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_11 = 2.0f * zn / w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * zn / h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = zf / (zn - zf);
    pOut->_34 = -1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{

#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_11 = 2.0f * zn / w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * zn / h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = zf / (zf - zn);
    pOut->_34 = 1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveFovRH
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(0.5f * fovy, &s, &c);

    float h = c / s;
    float w = aspect * h;

    pOut->_11 = w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = zf / (zn - zf);
    pOut->_34 = -1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 0.0f;
    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveFovLH
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(0.5f * fovy, &s, &c);

    float h = c / s;
    float w = aspect * h;

    pOut->_11 = w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = zf / (zf - zn);
    pOut->_34 = 1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveOffCenterRH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->_11 = 2.0f * zn * wInv;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * zn * hInv;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = (l + r) * wInv;
    pOut->_32 = (t + b) * hInv;
    pOut->_33 = zf / (zn - zf);
    pOut->_34 = -1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 0.0f;


    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->_11 = 2.0f * zn * wInv;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * zn * hInv;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = -(l + r) * wInv;
    pOut->_32 = -(t + b) * hInv;
    pOut->_33 = zf / (zf - zn);
    pOut->_34 = 1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 0.0f;


    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoRH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_11 = 2.0f / w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f / h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = 1.0f / (zn - zf);
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 1.0f;
    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_11 = 2.0f / w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f / h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = 1.0f / (zf - zn);
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoOffCenterRH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->_11 = 2.0f * wInv;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * hInv;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = 1.0f / (zn - zf);
    pOut->_34 = 0.0f;

    pOut->_41 = -(l + r) * wInv;
    pOut->_42 = -(t + b) * hInv;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->_11 = 2.0f * wInv;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * hInv;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = 1.0f / (zf - zn);
    pOut->_34 = 0.0f;

    pOut->_41 = -(l + r) * wInv;
    pOut->_42 = -(t + b) * hInv;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixShadow
    ( D3DXMATRIX *pOut, const D3DXVECTOR4 *pLight,
      const D3DXPLANE *pPlane )
{
#if DBG
    if(!pOut || !pLight || !pPlane)
        return NULL;
#endif

    D3DXPLANE p;
    D3DXPlaneNormalize(&p, pPlane);    
    float dot = D3DXPlaneDot(&p, pLight);
    p = -p;

    pOut->_11 = p.a * pLight->x + dot;
    pOut->_21 = p.b * pLight->x;
    pOut->_31 = p.c * pLight->x;
    pOut->_41 = p.d * pLight->x;

    pOut->_12 = p.a * pLight->y;
    pOut->_22 = p.b * pLight->y + dot;
    pOut->_32 = p.c * pLight->y;
    pOut->_42 = p.d * pLight->y;

    pOut->_13 = p.a * pLight->z;
    pOut->_23 = p.b * pLight->z;
    pOut->_33 = p.c * pLight->z + dot;
    pOut->_43 = p.d * pLight->z;

    pOut->_14 = p.a * pLight->w;
    pOut->_24 = p.b * pLight->w;
    pOut->_34 = p.c * pLight->w;
    pOut->_44 = p.d * pLight->w + dot;


    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixReflect
    ( D3DXMATRIX *pOut, const D3DXPLANE *pPlane )
{
#if DBG
    if(!pOut || !pPlane)
        return NULL;
#endif

    D3DXPLANE p;
    D3DXPlaneNormalize(&p, pPlane);
    
    float fa = -2.0f * p.a;
    float fb = -2.0f * p.b;
    float fc = -2.0f * p.c;

    pOut->_11 = fa * p.a + 1.0f;
    pOut->_12 = fb * p.a;
    pOut->_13 = fc * p.a;
    pOut->_14 = 0.0f;

    pOut->_21 = fa * p.b;
    pOut->_22 = fb * p.b + 1.0f;
    pOut->_23 = fc * p.b;
    pOut->_24 = 0.0f;

    pOut->_31 = fa * p.c;
    pOut->_32 = fb * p.c;
    pOut->_33 = fc * p.c + 1.0f;
    pOut->_34 = 0.0f;

    pOut->_41 = fa * p.d;
    pOut->_42 = fb * p.d;
    pOut->_43 = fc * p.d;
    pOut->_44 = 1.0f;

    return pOut;
}

//--------------------------
// Quaternion
//--------------------------

void WINAPI VB_D3DXQuaternionToAxisAngle
    ( const D3DXQUATERNION *pQ, D3DXVECTOR3 *pAxis, float *pAngle )
{
#if DBG
    if(!pQ)
        return;
#endif

    // expects unit quaternions!
	// q = cos(A/2), sin(A/2) * v

    float lsq = D3DXQuaternionLengthSq(pQ);

    if(lsq > EPSILON * EPSILON)
    {        
        if(pAxis)
        {
            float scale = 1.0f / sqrtf(lsq);
            pAxis->x = pQ->x * scale;
            pAxis->y = pQ->y * scale;
            pAxis->z = pQ->z * scale;
        }

        if(pAngle)
            *pAngle = 2.0f * acosf(pQ->w);

    }
    else
    {
        if(pAxis)
        {
            pAxis->x = 1.0;
            pAxis->y = 0.0;
            pAxis->z = 0.0;
        }

        if(pAngle)
            *pAngle = 0.0f;
    }
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationMatrix
    ( D3DXQUATERNION *pOut, const D3DXMATRIX *pM)
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif


    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".  (Taken from GDMAG feb'98 p38)

    float trace = pM->_11 + pM->_22 + pM->_33;
    float root;

    if ( trace > 0.0f )
    {
        // |w| > 1/2, may as well choose w > 1/2

        root = sqrtf(trace + 1.0f);  // 2w
        pOut->w = 0.5f * root;

        root = 0.5f / root;  // 1/(4w)
        pOut->x = (pM->_23 - pM->_32) * root;
        pOut->y = (pM->_31 - pM->_13) * root;
        pOut->z = (pM->_12 - pM->_21) * root;
    }
    else
    {
        // |w| <= 1/2
        static const int next[3] = { 1, 2, 0 };

        int i = 0;
        i += (pM->_22 > pM->_11);
        i += (pM->_33 > pM->m[i][i]);

        int j = next[i];
        int k = next[j];

        root = sqrtf(pM->m[i][i] - pM->m[j][j] - pM->m[k][k] + 1.0f);
        (*pOut)[i] = 0.5f * root;

        if(0.0f != root)
            root = 0.5f / root;

        pOut->w    = (pM->m[j][k] - pM->m[k][j]) * root;
        (*pOut)[j] = (pM->m[i][j] + pM->m[j][i]) * root;
        (*pOut)[k] = (pM->m[i][k] + pM->m[k][i]) * root;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationAxis
    ( D3DXQUATERNION *pOut, const D3DXVECTOR3 *pV, float angle )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    D3DXVECTOR3 v;
    D3DXVec3Normalize(&v, pV);

    float s;
    sincosf(0.5f * angle, &s, &pOut->w);

    pOut->x = v.x * s;
    pOut->y = v.y * s;
    pOut->z = v.z * s;

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationYawPitchRoll
    ( D3DXQUATERNION *pOut, float yaw, float pitch, float roll )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    //  Roll first, about axis the object is facing, then
    //  pitch upward, then yaw to face into the new heading

    float SR, CR, SP, CP, SY, CY;

    sincosf(0.5f * roll,  &SR, &CR);
    sincosf(0.5f * pitch, &SP, &CP);
    sincosf(0.5f * yaw,   &SY, &CY);

    pOut->x = CY*SP*CR + SY*CP*SR;
    pOut->y = SY*CP*CR - CY*SP*SR;
    pOut->z = CY*CP*SR - SY*SP*CR;
    pOut->w = CY*CP*CR + SY*SP*SR;

    return pOut;
}

/*
float WINAPI VB_D3DXQuaternionDot
    ( CONST D3DXQUATERNION *pQ1, CONST D3DXQUATERNION *pQ2 )
{
#ifdef DBG
    if(!pQ1 || !pQ2)
        return 0.0f;
#endif

    return pQ1->x * pQ2->x + pQ1->y * pQ2->y + pQ1->z * pQ2->z + pQ1->w * pQ2->w;
}
*/



D3DXQUATERNION* WINAPI VB_D3DXQuaternionMultiply
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2 )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2)
        return NULL;
#endif


#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pQ2]
        mov   edx, DWORD PTR [pQ1]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+0*4] ; wx
        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+2*4] ; wz
        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+1*4] ; wy
        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+3*4] ; ww
        fxch  st(3)
        // wx wy wz ww

        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+3*4] ; xw
        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+1*4] ; xy
        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+2*4] ; xz
        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+0*4] ; xx
        fxch  st(3)
        // xw xz xy xx  wx wy wz ww

        faddp st(4), st
        fsubp st(4), st
        faddp st(4), st
        fsubp st(4), st
        // wx-xw wy-xz wz+xy ww-xx

        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+2*4] ; yz
        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+0*4] ; yx
        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+3*4] ; yw
        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+1*4] ; yy
        fxch  st(3)
        // yz yw yx yy  wx-xw wy-xz wz+xy ww-xx

        faddp st(4), st
        faddp st(4), st
        fsubp st(4), st
        fsubp st(4), st
        // wx-xw+yz wy-xz+yw wz+xy-yx ww-xx-yy

        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+1*4] ; zy
        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+3*4] ; zw
        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+0*4] ; zx
        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+2*4] ; zz
        fxch  st(3)
        // zy zx zw zz wx-xw+yz wy-xz+yw wz+xy-yx ww-xx-yy

        fsubp st(4), st
        faddp st(4), st
        faddp st(4), st
        fsubp st(4), st
        // wx-xw+yz-zy wy-xz+yw+zx wz+xy-yx+zw ww-xx-yy-zz

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXQUATERNION Q;

    Q.x = pQ2->w * pQ1->x + pQ2->x * pQ1->w + pQ2->y * pQ1->z - pQ2->z * pQ1->y;
    Q.y = pQ2->w * pQ1->y - pQ2->x * pQ1->z + pQ2->y * pQ1->w + pQ2->z * pQ1->x;
    Q.z = pQ2->w * pQ1->z + pQ2->x * pQ1->y - pQ2->y * pQ1->x + pQ2->z * pQ1->w;
    Q.w = pQ2->w * pQ1->w - pQ2->x * pQ1->x - pQ2->y * pQ1->y - pQ2->z * pQ1->z;

    *pOut = Q;
    return pOut;
#endif // !_X86_
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionNormalize
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float f = D3DXQuaternionLengthSq(pQ);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pQ)
            *pOut = *pQ;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pQ / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionInverse
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float f = D3DXQuaternionLengthSq(pQ);

    if(f > EPSILON*EPSILON)
    {
        D3DXQuaternionConjugate(pOut, pQ);

        if(!WithinEpsilon(f, 1.0f))
            *pOut /= f;
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionLn
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    // expects unit quaternions!
    // q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)

    float theta, s;

    if(pQ->w < 1.0f)
    {
        theta = acosf(pQ->w);
        s = sinf(theta);

        if(!WithinEpsilon(s, 0.0f))
        {
            float scale = theta / s;
            pOut->x = pQ->x * scale;
            pOut->y = pQ->y * scale;
            pOut->z = pQ->z * scale;
            pOut->w = 0.0f;
        }
        else
        {
            pOut->x = pQ->x;
            pOut->y = pQ->y;
            pOut->z = pQ->z;
            pOut->w = 0.0f;
        }
    }
    else
    {
        pOut->x = pQ->x;
        pOut->y = pQ->y;
        pOut->z = pQ->z;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionExp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    // expects pure quaternions! (w == 0)
    // q = (0, theta * v) ; exp(q) = (cos(theta), sin(theta) * v)

    float theta, s;

    theta = sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z);
    sincosf(theta, &s, &pOut->w);

    if(WithinEpsilon(s, 0.0f))
    {
        if(pOut != pQ)
        {
            pOut->x = pQ->x;
            pOut->y = pQ->y;
            pOut->z = pQ->z;
        }
    }
    else
    {
        s /= theta;

        pOut->x = pQ->x * s;
        pOut->y = pQ->y * s;
        pOut->z = pQ->z * s;
    }

    return pOut;
}


D3DXQUATERNION* WINAPI VB_D3DXQuaternionSlerp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, float b )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2)
        return NULL;
#endif

    // expects unit quaternions!
    float a, c, flip, s, omega, sInv;

    a = 1.0f - b;
    c = D3DXQuaternionDot(pQ1, pQ2);
    flip = (c >= 0.0f) ? 1.0f : -1.0f;
    c *= flip;

	if(1.0f - c > EPSILON) {
        s = sqrtf(1.0f - c * c);
 		omega = atan2f(s, c);
 		sInv = 1.0f / s;

 		a = sinf(a * omega) * sInv;
 		b = sinf(b * omega) * sInv;
 	}

    b *= flip;

    pOut->x = a * pQ1->x + b * pQ2->x;
    pOut->y = a * pQ1->y + b * pQ2->y;
    pOut->z = a * pQ1->z + b * pQ2->z;
    pOut->w = a * pQ1->w + b * pQ2->w;

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionSquad
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      const D3DXQUATERNION *pQ4, float t )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2 || !pQ3 || !pQ4)
        return NULL;
#endif

    // expects unit quaternions!
    D3DXQUATERNION QA, QB;

    D3DXQuaternionSlerp(&QA, pQ1, pQ4, t);
    D3DXQuaternionSlerp(&QB, pQ2, pQ3, t);
    D3DXQuaternionSlerp(pOut, &QA, &QB, 2.0f * t * (1.0f - t));

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionBaryCentric
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      float f, float g )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2 || !pQ3)
        return NULL;
#endif

    // expects unit quaternions!
    D3DXQUATERNION QA, QB;
    float s = f + g;

    if(WithinEpsilon(s, 0.0f))
    {
        if(pOut != pQ1)
            *pOut = *pQ1;
    }
    else
    {
        D3DXQuaternionSlerp(&QA, pQ1, pQ2, s);
        D3DXQuaternionSlerp(&QB, pQ1, pQ3, s);
        D3DXQuaternionSlerp(pOut, &QA, &QB, g / s);
    }

    return pOut;
}


//--------------------------
// Plane
//--------------------------

D3DXPLANE* WINAPI VB_D3DXPlaneNormalize
    ( D3DXPLANE *pOut, const D3DXPLANE *pP )
{
#if DBG
    if(!pOut || !pP)
        return NULL;
#endif

    float f = pP->a * pP->a + pP->b * pP->b + pP->c * pP->c;

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pP)
            *pOut = *pP;
    }
    else if(f > EPSILON * EPSILON)
    {
        float fInv = 1.0f / sqrtf(f);

        pOut->a = pP->a * fInv;
        pOut->b = pP->b * fInv;
        pOut->c = pP->c * fInv;
        pOut->d = pP->d * fInv;
    }
    else
    {
        pOut->a = 0.0f;
        pOut->b = 0.0f;
        pOut->c = 0.0f;
        pOut->d = 0.0f;
    }

    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXPlaneIntersectLine
    ( D3DXVECTOR3 *pOut, const D3DXPLANE *pP, const D3DXVECTOR3 *pV1, 
      const D3DXVECTOR3 *pV2)
{
#if DBG
    if(!pOut || !pP || !pV1 || !pV2)
        return NULL;
#endif

    float d =  D3DXPlaneDotNormal(pP, pV1) - D3DXPlaneDotNormal(pP, pV2);

    if(d == 0.0f)
        return NULL;

    float f = D3DXPlaneDotCoord(pP, pV1) / d;

    if(!_finite(f))
        return NULL;

    D3DXVec3Lerp(pOut, pV1, pV2, f);
    return pOut;
}

D3DXPLANE* WINAPI VB_D3DXPlaneFromPointNormal
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pPoint, const D3DXVECTOR3 *pNormal)
{
#if DBG
    if(!pOut || !pPoint || !pNormal)
        return NULL;
#endif

    pOut->a = pNormal->x;
    pOut->b = pNormal->y;
    pOut->c = pNormal->z;
    pOut->d = -D3DXVec3Dot(pPoint, pNormal);
    return pOut;
}

D3DXPLANE* WINAPI VB_D3DXPlaneFromPoints
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2, 
      const D3DXVECTOR3 *pV3)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    D3DXVECTOR3 V12 = *pV1 - *pV2;
    D3DXVECTOR3 V13 = *pV1 - *pV3;

    D3DXVec3Cross((D3DXVECTOR3 *) pOut, &V12, &V13);
    D3DXVec3Normalize((D3DXVECTOR3 *) pOut, (D3DXVECTOR3 *) pOut);

    pOut->d = -D3DXPlaneDotNormal(pOut, pV1);
    return pOut;
}

D3DXPLANE* WINAPI VB_D3DXPlaneTransform
    ( D3DXPLANE *pOut, const D3DXPLANE *pP, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pP || !pM)
        return NULL;
#endif

    D3DXPLANE P;
    D3DXPlaneNormalize(&P, pP);

    D3DXVECTOR3 V(-P.a * P.d, -P.b * P.d, -P.c * P.d);
    D3DXVec3TransformCoord(&V, &V, pM);

    D3DXVec3TransformNormal((D3DXVECTOR3 *) pOut, (const D3DXVECTOR3 *) &P, pM);
    D3DXVec3Normalize((D3DXVECTOR3 *) pOut, (const D3DXVECTOR3 *) pOut);

    pOut->d = -D3DXPlaneDotNormal(pOut, &V);
    return pOut;
}


//--------------------------
// Color
//--------------------------

D3DXCOLOR* WINAPI VB_D3DXColorAdjustSaturation 
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s)
{
#if DBG
    if(!pOut || !pC)
        return NULL;
#endif

    // Approximate values for each component's contribution to luminance.
    // (Based upon the NTSC standard described in the comp.graphics.algorithms
    // colorspace FAQ)
    float grey = pC->r * 0.2125f + pC->g * 0.7154f + pC->b * 0.0721f;

    pOut->r = grey + s * (pC->r - grey);
    pOut->g = grey + s * (pC->g - grey);
    pOut->b = grey + s * (pC->b - grey);
    pOut->a = pC->a;
    return pOut;
}

D3DXCOLOR* WINAPI VB_D3DXColorAdjustContrast
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float c)
{
#if DBG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = 0.5f + c * (pC->r - 0.5f);
    pOut->g = 0.5f + c * (pC->g - 0.5f);
    pOut->b = 0.5f + c * (pC->b - 0.5f);
    pOut->a = pC->a;
    return pOut;
}

	


//--------------------------
// ColorAUX
//--------------------------

long WINAPI VB_D3DColorARGB(short a, short r, short g , short b)
{
	return D3DCOLOR_ARGB(a,r,g,b);
}

long WINAPI VB_D3DColorRGBA(short r, short g , short b, short a)
{
	return D3DCOLOR_RGBA(r,g,b,a);
}

long WINAPI VB_D3DColorXRGB(short r, short g , short b)
{
	return D3DCOLOR_XRGB(r,g,b);
}

long WINAPI VB_D3DColorMake(float r,float g, float b, float a)
{
	return D3DCOLOR_COLORVALUE(r,g,b,a);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3dxmath.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxmath.cpp
//  Content:    
//
//////////////////////////////////////////////////////////////////////////////

#include "pchmath.h"
#define EPSILON 0.00001f



//
// WithinEpsilon - Are two values within EPSILON of each other?
//

static inline BOOL 
WithinEpsilon(float a, float b)
{
    float f = a - b;
    return -EPSILON <= f && f <= EPSILON;
}


//
// sincosf - Compute the sin and cos of an angle at the same time
//

static inline void
sincosf(float angle, float *psin, float *pcos)
{
#ifdef _X86_
#define fsincos __asm _emit 0xd9 __asm _emit 0xfb
    __asm {
        mov eax, psin
        mov edx, pcos
        fld angle
        fsincos
        fstp DWORD ptr [edx]
        fstp DWORD ptr [eax]
    }
#undef fsincos
#else //!_X86_
    *psin = sinf(angle);
    *pcos = cosf(angle);
#endif //!_X86_
}


//--------------------------
// 2D Vector
//--------------------------

D3DXVECTOR2* WINAPI VB_D3DXVec2Normalize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = VB_D3DXVec2LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }    
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
    }

    return pOut;
}

D3DXVECTOR2* WINAPI VB_D3DXVec2Hermite
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pT1, 
      const D3DXVECTOR2 *pV2, const D3DXVECTOR2 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    return pOut;
}

D3DXVECTOR2* WINAPI VB_D3DXVec2BaryCentric
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      D3DXVECTOR2 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec2Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif


#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+2)*4] ; M32
        faddp st(3), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->m00 + pV->y * pM->m10 + pM->m30;
    v.y = pV->x * pM->m01 + pV->y * pM->m11 + pM->m31;
    v.z = pV->x * pM->m02 + pV->y * pM->m12 + pM->m32;
    v.w = pV->x * pM->m03 + pV->y * pM->m13 + pM->m33;

    *pOut = v;
    return pOut;
#endif // !_X86_
}

D3DXVECTOR2* WINAPI VB_D3DXVec2TransformCoord
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

    float w;

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(2)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(3), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [w]
    }

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->m00 + pV->y * pM->m10 + pM->m30;
    v.y = pV->x * pM->m01 + pV->y * pM->m11 + pM->m31;
    w   = pV->x * pM->m03 + pV->y * pM->m13 + pM->m33;

    *pOut = *((D3DXVECTOR2 *) &v);
#endif // !_X86_
    
    if(!WithinEpsilon(w, 1.0f))
        *pOut /= w;

    return pOut;
}

D3DXVECTOR2* WINAPI VB_D3DXVec2TransformNormal
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif


#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fxch  st(1)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fxch  st(1)

        faddp st(2), st
        faddp st(2), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR2 v;

    v.x = pV->x * pM->m00 + pV->y * pM->m10;
    v.y = pV->x * pM->m01 + pV->y * pM->m11;

    *pOut = v;
    return pOut;
#endif // !_X86_
}


//--------------------------
// 3D Vector
//--------------------------

D3DXVECTOR3* WINAPI VB_D3DXVec3Normalize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = VB_D3DXVec3LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
    }

    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXVec3Hermite
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pT1, 
      const D3DXVECTOR3 *pV2, const D3DXVECTOR3 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    pOut->z = sV1 * pV1->z + sT1 * pT1->z + sV2 * pV2->z + sT2 * pT2->z;
    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXVec3BaryCentric
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      const D3DXVECTOR3 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    pOut->z = pV1->z + f * (pV2->z - pV1->z) + g * (pV3->z - pV1->z);
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec3Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+2)*4] ; M32
        faddp st(3), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->m00 + pV->y * pM->m10 + pV->z * pM->m20 + pM->m30;
    v.y = pV->x * pM->m01 + pV->y * pM->m11 + pV->z * pM->m21 + pM->m31;
    v.z = pV->x * pM->m02 + pV->y * pM->m12 + pV->z * pM->m22 + pM->m32;
    v.w = pV->x * pM->m03 + pV->y * pM->m13 + pV->z * pM->m23 + pM->m33;

    *pOut = v;
    return pOut;
#endif // !_X86_
}

D3DXVECTOR3* WINAPI VB_D3DXVec3TransformCoord
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

    float w;

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+2)*4] ; M32
        faddp st(3), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [w]
    }

#else // !_X86_
    D3DXVECTOR3 v;

    v.x = pV->x * pM->m00 + pV->y * pM->m10 + pV->z * pM->m20 + pM->m30;
    v.y = pV->x * pM->m01 + pV->y * pM->m11 + pV->z * pM->m21 + pM->m31;
    v.z = pV->x * pM->m02 + pV->y * pM->m12 + pV->z * pM->m22 + pM->m32;
    w   = pV->x * pM->m03 + pV->y * pM->m13 + pV->z * pM->m23 + pM->m33;

    *pOut = v;
#endif // !_X86_
    
    if(!WithinEpsilon(w, 1.0f))
        *pOut /= w;

    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXVec3TransformNormal
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fxch  st(2)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR3 v;

    v.x = pV->x * pM->m00 + pV->y * pM->m10 + pV->z * pM->m20;
    v.y = pV->x * pM->m01 + pV->y * pM->m11 + pV->z * pM->m21;
    v.z = pV->x * pM->m02 + pV->y * pM->m12 + pV->z * pM->m22;

    *pOut = v;
    return pOut;
#endif // !_X86_
}



//--------------------------
// 4D Vector
//--------------------------

D3DXVECTOR4* WINAPI VB_D3DXVec4Cross
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2, 
      const D3DXVECTOR4 *pV3)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    D3DXVECTOR4 v;

    v.x = pV1->y * (pV2->z * pV3->w - pV3->z * pV2->w) -
          pV1->z * (pV2->y * pV3->w - pV3->y * pV2->w) +
          pV1->w * (pV2->y * pV3->z - pV3->y * pV2->z);

    v.y = pV1->x * (pV3->z * pV2->w - pV2->z * pV3->w) -
          pV1->z * (pV3->x * pV2->w - pV2->x * pV3->w) +
          pV1->w * (pV3->x * pV2->z - pV2->x * pV3->z);

    v.z = pV1->x * (pV2->y * pV3->w - pV3->y * pV2->w) -
          pV1->y * (pV2->x * pV3->w - pV3->x * pV2->w) +
          pV1->w * (pV2->x * pV3->y - pV3->x * pV2->y);

    v.w = pV1->x * (pV3->y * pV2->z - pV2->y * pV3->z) -
          pV1->y * (pV3->x * pV2->z - pV2->x * pV3->z) +
          pV1->z * (pV3->x * pV2->y - pV2->x * pV3->y);

    *pOut = v;
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4Normalize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = D3DXVec4LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4Hermite
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pT1, 
      const D3DXVECTOR4 *pV2, const D3DXVECTOR4 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    pOut->z = sV1 * pV1->z + sT1 * pT1->z + sV2 * pV2->z + sT2 * pT2->z;
    pOut->w = sV1 * pV1->w + sT1 * pT1->w + sV2 * pV2->w + sT2 * pT2->w;
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4BaryCentric
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      const D3DXVECTOR4 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    pOut->z = pV1->z + f * (pV2->z - pV1->z) + g * (pV3->z - pV1->z);
    pOut->w = pV1->w + f * (pV2->w - pV1->w) + g * (pV3->w - pV1->w);
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+0)*4] ; M30
        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+2)*4] ; M32
        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+1)*4] ; M31
        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+3)*4] ; M33
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->m00 + pV->y * pM->m10 + pV->z * pM->m20 + pV->w * pM->m30;
    v.y = pV->x * pM->m01 + pV->y * pM->m11 + pV->z * pM->m21 + pV->w * pM->m31;
    v.z = pV->x * pM->m02 + pV->y * pM->m12 + pV->z * pM->m22 + pV->w * pM->m32;
    v.w = pV->x * pM->m03 + pV->y * pM->m13 + pV->z * pM->m23 + pV->w * pM->m33;

    *pOut = v;
    return pOut;
#endif // !_X86_
}


//--------------------------
// 4D Matrix
//--------------------------

float WINAPI VB_D3DXMatrixfDeterminant
    ( const D3DXMATRIX *pM )
{
#if DBG
    if(!pM)
        return 0.0f;
#endif

    return (pM->m00 * (pM->m11 * (pM->m22 * pM->m33 - pM->m32 * pM->m23) -
                       pM->m12 * (pM->m21 * pM->m33 - pM->m31 * pM->m23) +
                       pM->m13 * (pM->m21 * pM->m32 - pM->m31 * pM->m22)))

         - (pM->m01 * (pM->m10 * (pM->m22 * pM->m33 - pM->m32 * pM->m23) -
                       pM->m12 * (pM->m20 * pM->m33 - pM->m30 * pM->m23) +
                       pM->m13 * (pM->m20 * pM->m32 - pM->m30 * pM->m22)))

         + (pM->m02 * (pM->m10 * (pM->m21 * pM->m33 - pM->m31 * pM->m23) -
                       pM->m11 * (pM->m20 * pM->m33 - pM->m30 * pM->m23) +
                       pM->m13 * (pM->m20 * pM->m31 - pM->m30 * pM->m21)))

         - (pM->m03 * (pM->m10 * (pM->m21 * pM->m32 - pM->m31 * pM->m22) -
                       pM->m11 * (pM->m20 * pM->m32 - pM->m30 * pM->m22) +
                       pM->m12 * (pM->m20 * pM->m31 - pM->m30 * pM->m21)));
}


D3DXMATRIX* WINAPI VB_D3DXMatrixMultiply
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM1, const D3DXMATRIX *pM2 )
{
#if DBG
    if(!pOut || !pM1 || !pM2)
        return NULL;
#endif

#ifdef _X86_
#define MAT(m,a,b) DWORD PTR [(m)+(a)*4+(b)*4]

    D3DXMATRIX Out;

    if(pM2 != pOut)
        goto LRowByColumn;
    if(pM1 != pOut)
        goto LColumnByRow;

    Out = *pM2;
    pM2 = &Out;
    goto LRowByColumn;


LRowByColumn:
    __asm {     
        mov ebx, DWORD PTR[pOut]    // result
        mov ecx, DWORD PTR[pM1]     // a
        mov edx, DWORD PTR[pM2]     // b
        mov edi, -4

    LLoopRow:
        mov esi, -4

        fld MAT(ecx, 0, 0)          // a0
        fld MAT(ecx, 0, 1)          // a1 
        fld MAT(ecx, 0, 2)          // a2  
        fld MAT(ecx, 0, 3)          // a3

    LLoopColumn:
        fld st(3)                   // a0
        fmul MAT(edx, esi, 1*4)     // a0*b0
        fld st(3)                   // a1
        fmul MAT(edx, esi, 2*4)     // a1*b1
        fld st(3)                   // a2
        fmul MAT(edx, esi, 3*4)     // a2*b2
        fld st(3)                   // a3
        fmul MAT(edx, esi, 4*4)     // a3*b3

        fxch st(3)
        faddp st(1), st             // a2*b2+a0*b0
        fxch st(2)
        faddp st(1), st             // a3*b3+a1*b1
        faddp st(1), st             // a3*b3+a1*b1+a2*b2+a0*b0
        fstp MAT(ebx, esi, 4)

        inc esi
        jnz LLoopColumn

        ffree st(3)
        ffree st(2)
        ffree st(1)
        ffree st(0)

        lea ecx, MAT(ecx, 0, 4)
        lea ebx, MAT(ebx, 0, 4)

        inc edi
        jnz LLoopRow
    }

    return pOut;


LColumnByRow:
    __asm {     
        mov ebx, DWORD PTR[pOut]    // result
        mov ecx, DWORD PTR[pM1]     // a
        mov edx, DWORD PTR[pM2]     // b
        mov edi, -4

    LLoopColumn2:
        mov esi, -16

        fld MAT(edx, edi, 1*4);     // b0
        fld MAT(edx, edi, 2*4);     // b1
        fld MAT(edx, edi, 3*4);     // b2
        fld MAT(edx, edi, 4*4);     // b3

    LLoopRow2:
        fld st(3)                   // b0
        fmul MAT(ecx, esi, 0+16)    // a0*b0
        fld st(3)                   // b1
        fmul MAT(ecx, esi, 1+16)    // a1*b1
        fld st(3)                   // b2
        fmul MAT(ecx, esi, 2+16)    // a2*b2
        fld st(3)                   // b3
        fmul MAT(ecx, esi, 3+16)    // a3*b3

        fxch st(3)
        faddp st(1), st             // a2*b2+a0*b0
        fxch st(2)
        faddp st(1), st             // a3*b3+a1*b1
        faddp st(1), st             // a3*b3+a1*b1+a2*b2+a0*b0
        fstp MAT(ebx, esi, 0+16)

        add esi, 4
        jnz LLoopRow2

        ffree st(3)
        ffree st(2)
        ffree st(1)
        ffree st(0)

        lea ebx, MAT(ebx, 0, 1)
        inc edi
        jnz LLoopColumn2
    }

    return pOut;
#undef MAT
#else //!_X86_
    D3DXMATRIX Out;
    D3DXMATRIX *pM = (pOut == pM1 || pOut == pM2) ? &Out : pOut;

    pM->m00 = pM1->m00 * pM2->m00 + pM1->m01 * pM2->m10 + pM1->m02 * pM2->m20 + pM1->m03 * pM2->m30;
    pM->m01 = pM1->m00 * pM2->m01 + pM1->m01 * pM2->m11 + pM1->m02 * pM2->m21 + pM1->m03 * pM2->m31;
    pM->m02 = pM1->m00 * pM2->m02 + pM1->m01 * pM2->m12 + pM1->m02 * pM2->m22 + pM1->m03 * pM2->m32;
    pM->m03 = pM1->m00 * pM2->m03 + pM1->m01 * pM2->m13 + pM1->m02 * pM2->m23 + pM1->m03 * pM2->m33;

    pM->m10 = pM1->m10 * pM2->m00 + pM1->m11 * pM2->m10 + pM1->m12 * pM2->m20 + pM1->m13 * pM2->m30;
    pM->m11 = pM1->m10 * pM2->m01 + pM1->m11 * pM2->m11 + pM1->m12 * pM2->m21 + pM1->m13 * pM2->m31;
    pM->m12 = pM1->m10 * pM2->m02 + pM1->m11 * pM2->m12 + pM1->m12 * pM2->m22 + pM1->m13 * pM2->m32;
    pM->m13 = pM1->m10 * pM2->m03 + pM1->m11 * pM2->m13 + pM1->m12 * pM2->m23 + pM1->m13 * pM2->m33;

    pM->m20 = pM1->m20 * pM2->m00 + pM1->m21 * pM2->m10 + pM1->m22 * pM2->m20 + pM1->m23 * pM2->m30;
    pM->m21 = pM1->m20 * pM2->m01 + pM1->m21 * pM2->m11 + pM1->m22 * pM2->m21 + pM1->m23 * pM2->m31;
    pM->m22 = pM1->m20 * pM2->m02 + pM1->m21 * pM2->m12 + pM1->m22 * pM2->m22 + pM1->m23 * pM2->m32;
    pM->m23 = pM1->m20 * pM2->m03 + pM1->m21 * pM2->m13 + pM1->m22 * pM2->m23 + pM1->m23 * pM2->m33;

    pM->m30 = pM1->m30 * pM2->m00 + pM1->m31 * pM2->m10 + pM1->m32 * pM2->m20 + pM1->m33 * pM2->m30;
    pM->m31 = pM1->m30 * pM2->m01 + pM1->m31 * pM2->m11 + pM1->m32 * pM2->m21 + pM1->m33 * pM2->m31;
    pM->m32 = pM1->m30 * pM2->m02 + pM1->m31 * pM2->m12 + pM1->m32 * pM2->m22 + pM1->m33 * pM2->m32;
    pM->m33 = pM1->m30 * pM2->m03 + pM1->m31 * pM2->m13 + pM1->m32 * pM2->m23 + pM1->m33 * pM2->m33;

    if(pM != pOut)
        *pOut = *pM;

    return pOut;
#endif //!_X86_
}

D3DXMATRIX* WINAPI VB_D3DXMatrixTranspose
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif

    float f;

    f = pM->m01; pOut->m01 = pM->m10; pOut->m10 = f;
    f = pM->m02; pOut->m02 = pM->m20; pOut->m20 = f;
    f = pM->m03; pOut->m03 = pM->m30; pOut->m30 = f;
    f = pM->m12; pOut->m12 = pM->m21; pOut->m21 = f;
    f = pM->m13; pOut->m13 = pM->m31; pOut->m31 = f;
    f = pM->m23; pOut->m23 = pM->m32; pOut->m32 = f;

    if(pOut != pM)
    {
        pOut->m00 = pM->m00;
        pOut->m11 = pM->m11;
        pOut->m22 = pM->m22;
        pOut->m33 = pM->m33;
    }

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixInverse
    ( D3DXMATRIX *pOut, float *pfDeterminant, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif

    // XXXlorenmcq - The code was designed to work on a processor with more 
    //  than 4 general-purpose registers.  Is there a more optimal way of 
    //  doing this on X86?

    float fX00, fX01, fX02;
    float fX10, fX11, fX12;
    float fX20, fX21, fX22;
    float fX30, fX31, fX32;
    float fY01, fY02, fY03, fY12, fY13, fY23;
    float fZ02, fZ03, fZ12, fZ13, fZ22, fZ23, fZ32, fZ33;

#define fX03 fX01
#define fX13 fX11
#define fX23 fX21
#define fX33 fX31
#define fZ00 fX02
#define fZ10 fX12
#define fZ20 fX22
#define fZ30 fX32
#define fZ01 fX03
#define fZ11 fX13
#define fZ21 fX23
#define fZ31 fX33
#define fDet fY01
#define fRcp fY02

    // read 1st two columns of matrix
    fX00 = pM->m00;
    fX01 = pM->m01;
    fX10 = pM->m10;
    fX11 = pM->m11;
    fX20 = pM->m20;
    fX21 = pM->m21;
    fX30 = pM->m30;
    fX31 = pM->m31;

    // compute all six 2x2 determinants of 1st two columns
    fY01 = fX00 * fX11 - fX10 * fX01;
    fY02 = fX00 * fX21 - fX20 * fX01;
    fY03 = fX00 * fX31 - fX30 * fX01;
    fY12 = fX10 * fX21 - fX20 * fX11;
    fY13 = fX10 * fX31 - fX30 * fX11;
    fY23 = fX20 * fX31 - fX30 * fX21;

    // read 2nd two columns of matrix
    fX02 = pM->m02;
    fX03 = pM->m03;
    fX12 = pM->m12;
    fX13 = pM->m13;
    fX22 = pM->m22;
    fX23 = pM->m23;
    fX32 = pM->m32;
    fX33 = pM->m33;

    // compute all 3x3 cofactors for 2nd two columns
    fZ33 = fX02 * fY12 - fX12 * fY02 + fX22 * fY01;
    fZ23 = fX12 * fY03 - fX32 * fY01 - fX02 * fY13;
    fZ13 = fX02 * fY23 - fX22 * fY03 + fX32 * fY02;
    fZ03 = fX22 * fY13 - fX32 * fY12 - fX12 * fY23;
    fZ32 = fX13 * fY02 - fX23 * fY01 - fX03 * fY12;
    fZ22 = fX03 * fY13 - fX13 * fY03 + fX33 * fY01;
    fZ12 = fX23 * fY03 - fX33 * fY02 - fX03 * fY23;
    fZ02 = fX13 * fY23 - fX23 * fY13 + fX33 * fY12;

    // compute all six 2x2 determinants of 2nd two columns
    fY01 = fX02 * fX13 - fX12 * fX03;
    fY02 = fX02 * fX23 - fX22 * fX03;
    fY03 = fX02 * fX33 - fX32 * fX03;
    fY12 = fX12 * fX23 - fX22 * fX13;
    fY13 = fX12 * fX33 - fX32 * fX13;
    fY23 = fX22 * fX33 - fX32 * fX23;

    // read 1st two columns of matrix
    fX00 = pM->m00;
    fX01 = pM->m01;
    fX10 = pM->m10;
    fX11 = pM->m11;
    fX20 = pM->m20;
    fX21 = pM->m21;
    fX30 = pM->m30;
    fX31 = pM->m31;

    // compute all 3x3 cofactors for 1st two columns
    fZ30 = fX11 * fY02 - fX21 * fY01 - fX01 * fY12;
    fZ20 = fX01 * fY13 - fX11 * fY03 + fX31 * fY01;
    fZ10 = fX21 * fY03 - fX31 * fY02 - fX01 * fY23;
    fZ00 = fX11 * fY23 - fX21 * fY13 + fX31 * fY12;
    fZ31 = fX00 * fY12 - fX10 * fY02 + fX20 * fY01;
    fZ21 = fX10 * fY03 - fX30 * fY01 - fX00 * fY13;
    fZ11 = fX00 * fY23 - fX20 * fY03 + fX30 * fY02;
    fZ01 = fX20 * fY13 - fX30 * fY12 - fX10 * fY23;

    // compute 4x4 determinant & its reciprocal
    fDet = fX30 * fZ30 + fX20 * fZ20 + fX10 * fZ10 + fX00 * fZ00;

    if(pfDeterminant)
        *pfDeterminant = fDet;

    fRcp = 1.0f / fDet;

    if(!_finite(fRcp))
        return NULL;


    // multiply all 3x3 cofactors by reciprocal & transpose
    pOut->m00 = fZ00 * fRcp;
    pOut->m01 = fZ10 * fRcp;
    pOut->m02 = fZ20 * fRcp;
    pOut->m03 = fZ30 * fRcp;
    pOut->m10 = fZ01 * fRcp;
    pOut->m11 = fZ11 * fRcp;
    pOut->m12 = fZ21 * fRcp;
    pOut->m13 = fZ31 * fRcp;
    pOut->m20 = fZ02 * fRcp;
    pOut->m21 = fZ12 * fRcp;
    pOut->m22 = fZ22 * fRcp;
    pOut->m23 = fZ32 * fRcp;
    pOut->m30 = fZ03 * fRcp;
    pOut->m31 = fZ13 * fRcp;
    pOut->m32 = fZ23 * fRcp;
    pOut->m33 = fZ33 * fRcp;
    
    return pOut;
}



D3DXMATRIX* WINAPI VB_D3DXMatrixScaling
    ( D3DXMATRIX *pOut, float sx, float sy, float sz )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->m01 = pOut->m02 = pOut->m03 = 
    pOut->m10 = pOut->m12 = pOut->m13 = 
    pOut->m20 = pOut->m21 = pOut->m23 = 
    pOut->m30 = pOut->m31 = pOut->m32 = 0.0f;

    pOut->m00 = sx;
    pOut->m11 = sy;
    pOut->m22 = sz;
    pOut->m33 = 1.0f;
    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixTranslation
    ( D3DXMATRIX *pOut, float x, float y, float z )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->m01 = pOut->m02 = pOut->m03 = 
    pOut->m10 = pOut->m12 = pOut->m13 = 
    pOut->m20 = pOut->m21 = pOut->m23 = 0.0f;

    pOut->m00 = pOut->m11 = pOut->m22 = pOut->m33 = 1.0f;

    pOut->m30 = x;
    pOut->m31 = y;
    pOut->m32 = z;
    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixRotationX
    ( D3DXMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->m00 = 1.0f; pOut->m01 = 0.0f; pOut->m02 = 0.0f; pOut->m03 = 0.0f;
    pOut->m10 = 0.0f; pOut->m11 =    c; pOut->m12 =    s; pOut->m13 = 0.0f;
    pOut->m20 = 0.0f; pOut->m21 =   -s; pOut->m22 =    c; pOut->m23 = 0.0f;
    pOut->m30 = 0.0f; pOut->m31 = 0.0f; pOut->m32 = 0.0f; pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationY
    ( D3DXMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->m00 =    c; pOut->m01 = 0.0f; pOut->m02 =   -s; pOut->m03 = 0.0f;
    pOut->m10 = 0.0f; pOut->m11 = 1.0f; pOut->m12 = 0.0f; pOut->m13 = 0.0f;
    pOut->m20 =    s; pOut->m21 = 0.0f; pOut->m22 =    c; pOut->m23 = 0.0f;
    pOut->m30 = 0.0f; pOut->m31 = 0.0f; pOut->m32 = 0.0f; pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationZ
    ( D3DXMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->m00 =    c; pOut->m01 =    s; pOut->m02 = 0.0f; pOut->m03 = 0.0f;
    pOut->m10 =   -s; pOut->m11 =    c; pOut->m12 = 0.0f; pOut->m13 = 0.0f;
    pOut->m20 = 0.0f; pOut->m21 = 0.0f; pOut->m22 = 1.0f; pOut->m23 = 0.0f;
    pOut->m30 = 0.0f; pOut->m31 = 0.0f; pOut->m32 = 0.0f; pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationAxis
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pV, float angle )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);
    float c1 = 1 - c;

    D3DXVECTOR3 v = *pV;
    VB_D3DXVec3Normalize(&v, &v);

    float xyc1 = v.x * v.y * c1;
    float yzc1 = v.y * v.z * c1;
    float zxc1 = v.z * v.x * c1;

    pOut->m00 = v.x * v.x * c1 + c;
    pOut->m01 = xyc1 + v.z * s;
    pOut->m02 = zxc1 - v.y * s;
    pOut->m03 = 0.0f;

    pOut->m10 = xyc1 - v.z * s;
    pOut->m11 = v.y * v.y * c1 + c;
    pOut->m12 = yzc1 + v.x * s;
    pOut->m13 = 0.0f;

    pOut->m20 = zxc1 + v.y * s;
    pOut->m21 = yzc1 - v.x * s;
    pOut->m22 = v.z * v.z * c1 + c;
    pOut->m23 = 0.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = 0.0f;
    pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationQuaternion
    ( D3DXMATRIX *pOut, const D3DXQUATERNION *pQ)
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float x2 = pQ->x + pQ->x;
    float y2 = pQ->y + pQ->y;
    float z2 = pQ->z + pQ->z;

    float wx2 = pQ->w * x2;
    float wy2 = pQ->w * y2;
    float wz2 = pQ->w * z2;
    float xx2 = pQ->x * x2;
    float xy2 = pQ->x * y2;
    float xz2 = pQ->x * z2;
    float yy2 = pQ->y * y2;
    float yz2 = pQ->y * z2;
    float zz2 = pQ->z * z2;

    pOut->m00 = 1.0f - yy2 - zz2;
    pOut->m01 = xy2 + wz2;
    pOut->m02 = xz2 - wy2;
    pOut->m03 = 0.0f;

    pOut->m10 = xy2 - wz2;
    pOut->m11 = 1.0f - xx2 - zz2;
    pOut->m12 = yz2 + wx2;
    pOut->m13 = 0.0f;
    
    pOut->m20 = xz2 + wy2;
    pOut->m21 = yz2 - wx2;
    pOut->m22 = 1.0f - xx2 - yy2;
    pOut->m23 = 0.0f;
    
    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = 0.0f;
    pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationYawPitchRoll
    ( D3DXMATRIX *pOut, float yaw, float pitch, float roll )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    D3DXQUATERNION q;

    VB_D3DXQuaternionRotationYawPitchRoll(&q, yaw, pitch, roll);
    D3DXMatrixRotationQuaternion(pOut, &q);

    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixTransformation
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pScalingCenter, 
      const D3DXQUATERNION *pScalingRotation, const D3DXVECTOR3 *pScaling,
      const D3DXVECTOR3 *pRotationCenter, const D3DXQUATERNION *pRotation,
      const D3DXVECTOR3 *pTranslation)
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    D3DXMATRIX matS, matR, matRI;

    if (pScaling)
    {
        if (pScalingRotation)
        {
            matS.m01 = matS.m02 = matS.m03 =
            matS.m10 = matS.m12 = matS.m13 =
            matS.m20 = matS.m21 = matS.m23 =
            matS.m30 = matS.m31 = matS.m32 = 0.0f;

            matS.m00 = pScaling->x;
            matS.m11 = pScaling->y;
            matS.m22 = pScaling->z;
            matS.m33 = 1.0f;

            D3DXMatrixRotationQuaternion(&matR, pScalingRotation);


            if (pScalingCenter)
            {
                // SC-1, SR-1, S, SR, SC
                D3DXMatrixTranspose(&matRI, &matR);
                D3DXMatrixIdentity(pOut);

                pOut->m30 -= pScalingCenter->x;
                pOut->m31 -= pScalingCenter->y;
                pOut->m32 -= pScalingCenter->z;

                D3DXMatrixMultiply(pOut, pOut, &matRI);
                D3DXMatrixMultiply(pOut, pOut, &matS);
                D3DXMatrixMultiply(pOut, pOut, &matR);

                pOut->m30 += pScalingCenter->x;
                pOut->m31 += pScalingCenter->y;
                pOut->m32 += pScalingCenter->z;
            }
            else
            {
                // SR-1, S, SR
                D3DXMatrixTranspose(pOut, &matR);
                D3DXMatrixMultiply(pOut, pOut, &matS);
                D3DXMatrixMultiply(pOut, pOut, &matR);
            }
        }
        else
        {
            // S
            pOut->m01 = pOut->m02 = pOut->m03 =
            pOut->m10 = pOut->m12 = pOut->m13 =
            pOut->m20 = pOut->m21 = pOut->m23 =
            pOut->m30 = pOut->m31 = pOut->m32 = 0.0f;

            pOut->m00 = pScaling->x;
            pOut->m11 = pScaling->y;
            pOut->m22 = pScaling->z;
            pOut->m33 = 1.0f;
        }

    }
    else
    {
        D3DXMatrixIdentity(pOut);
    }

    if (pRotation)
    {
        D3DXMatrixRotationQuaternion(&matR, pRotation);

        if (pRotationCenter)
        {
            // RC-1, R, RC
            pOut->m30 -= pRotationCenter->x;
            pOut->m31 -= pRotationCenter->y;
            pOut->m32 -= pRotationCenter->z;

            D3DXMatrixMultiply(pOut, pOut, &matR);

            pOut->m30 += pRotationCenter->x;
            pOut->m31 += pRotationCenter->y;
            pOut->m32 += pRotationCenter->z;
        }
        else
        {
            // R
            D3DXMatrixMultiply(pOut, pOut, &matR);
        }
    }

    if (pTranslation)
    {
        // T
        pOut->m30 += pTranslation->x;
        pOut->m31 += pTranslation->y;
        pOut->m32 += pTranslation->z;
    }

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixAffineTransformation
    ( D3DXMATRIX *pOut, float Scaling, const D3DXVECTOR3 *pRotationCenter, 
      const D3DXQUATERNION *pRotation, const D3DXVECTOR3 *pTranslation)
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    // S
    pOut->m01 = pOut->m02 = pOut->m03 =
    pOut->m10 = pOut->m12 = pOut->m13 =
    pOut->m20 = pOut->m21 = pOut->m23 =
    pOut->m30 = pOut->m31 = pOut->m32 = 0.0f;

    pOut->m00 = Scaling;
    pOut->m11 = Scaling;
    pOut->m22 = Scaling;
    pOut->m33 = 1.0f;


    if (pRotation)
    {
        D3DXMATRIX matR;
        D3DXMatrixRotationQuaternion(&matR, pRotation);

        if (pRotationCenter)
        {
            // RC-1, R, RC
            pOut->m30 -= pRotationCenter->x;
            pOut->m31 -= pRotationCenter->y;
            pOut->m32 -= pRotationCenter->z;

            D3DXMatrixMultiply(pOut, pOut, &matR);

            pOut->m30 += pRotationCenter->x;
            pOut->m31 += pRotationCenter->y;
            pOut->m32 += pRotationCenter->z;
        }
        else
        {
            // R
            D3DXMatrixMultiply(pOut, pOut, &matR);
        }
    }


    if (pTranslation)
    {
        // T
        pOut->m30 += pTranslation->x;
        pOut->m31 += pTranslation->y;
        pOut->m32 += pTranslation->z;
    }

    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixLookAt
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp )
{
#if DBG
    if(!pOut || !pEye || !pAt || !pUp)
        return NULL;
#endif

    D3DXVECTOR3 XAxis, YAxis, ZAxis;

    // Compute direction of gaze. (-Z)
    VB_D3DXVec3Subtract(&ZAxis, pEye, pAt);
    VB_D3DXVec3Normalize(&ZAxis, &ZAxis);

    // Compute orthogonal axes from cross product of gaze and pUp vector.
    VB_D3DXVec3Cross(&XAxis, pUp, &ZAxis);
    VB_D3DXVec3Normalize(&XAxis, &XAxis);
    VB_D3DXVec3Cross(&YAxis, &ZAxis, &XAxis);

    // Set rotation and translate by pEye
    pOut->m00 = XAxis.x;
    pOut->m10 = XAxis.y;
    pOut->m20 = XAxis.z;
    pOut->m30 = -VB_D3DXVec3Dot(&XAxis, pEye);

    pOut->m01 = YAxis.x;
    pOut->m11 = YAxis.y;
    pOut->m21 = YAxis.z;
    pOut->m31 = -VB_D3DXVec3Dot(&YAxis, pEye);

    pOut->m02 = ZAxis.x;
    pOut->m12 = ZAxis.y;
    pOut->m22 = ZAxis.z;
    pOut->m32 = -VB_D3DXVec3Dot(&ZAxis, pEye);
    
    pOut->m03 = 0.0f;
    pOut->m13 = 0.0f;
    pOut->m23 = 0.0f;
    pOut->m33 = 1.0f;
    
    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixLookAtLH
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp )
{
#if DBG
    if(!pOut || !pEye || !pAt || !pUp)
        return NULL;
#endif

    D3DXVECTOR3 XAxis, YAxis, ZAxis;

    // Compute direction of gaze. (+Z)
    VB_D3DXVec3Subtract(&ZAxis, pAt, pEye);
    VB_D3DXVec3Normalize(&ZAxis, &ZAxis);

    // Compute orthogonal axes from cross product of gaze and pUp vector.
    VB_D3DXVec3Cross(&XAxis, &ZAxis, pUp);
    VB_D3DXVec3Normalize(&XAxis, &XAxis);
    VB_D3DXVec3Cross(&YAxis, &XAxis, &ZAxis);

    // Set rotation and translate by pEye
    pOut->m00 = XAxis.x;
    pOut->m10 = XAxis.y;
    pOut->m20 = XAxis.z;
    pOut->m30 = -VB_D3DXVec3Dot(&XAxis, pEye);

    pOut->m01 = YAxis.x;
    pOut->m11 = YAxis.y;
    pOut->m21 = YAxis.z;
    pOut->m31 = -VB_D3DXVec3Dot(&YAxis, pEye);

    pOut->m02 = ZAxis.x;
    pOut->m12 = ZAxis.y;
    pOut->m22 = ZAxis.z;
    pOut->m32 = -VB_D3DXVec3Dot(&ZAxis, pEye);
    
    pOut->m03 = 0.0f;
    pOut->m13 = 0.0f;
    pOut->m23 = 0.0f;
    pOut->m33 = 1.0f;
    
    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspective
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->m00 = 2.0f * zn / w;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = 2.0f * zn / h;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = 0.0f;
    pOut->m21 = 0.0f;
    pOut->m22 = zf / (zn - zf);
    pOut->m23 = -1.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = pOut->m22 * zn;
    pOut->m33 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->m00 = 2.0f * zn / w;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = 2.0f * zn / h;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = 0.0f;
    pOut->m21 = 0.0f;
    pOut->m22 = zf / (zf - zn);
    pOut->m23 = 1.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = -pOut->m22 * zn;
    pOut->m33 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveFov
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(0.5f * fovy, &s, &c);

    float h = c / s;
    float w = aspect * h;

    pOut->m00 = w;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = h;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = 0.0f;
    pOut->m21 = 0.0f;
    pOut->m22 = zf / (zn - zf);
    pOut->m23 = -1.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = pOut->m22 * zn;
    pOut->m33 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveFovLH
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(0.5f * fovy, &s, &c);

    float h = c / s;
    float w = aspect * h;

    pOut->m00 = w;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = h;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = 0.0f;
    pOut->m21 = 0.0f;
    pOut->m22 = zf / (zf - zn);
    pOut->m23 = 1.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = -pOut->m22 * zn;
    pOut->m33 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveOffCenter
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->m00 = 2.0f * zn * wInv;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = 2.0f * zn * hInv;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = (l + r) * wInv;
    pOut->m21 = (t + b) * hInv;
    pOut->m22 = zf / (zn - zf);
    pOut->m23 = -1.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = pOut->m22 * zn;
    pOut->m33 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->m00 = 2.0f * zn * wInv;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = 2.0f * zn * hInv;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = -(l + r) * wInv;
    pOut->m21 = -(t + b) * hInv;
    pOut->m22 = zf / (zf - zn);
    pOut->m23 = 1.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = -pOut->m22 * zn;
    pOut->m33 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixOrtho
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->m00 = 2.0f / w;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = 2.0f / h;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = 0.0f;
    pOut->m21 = 0.0f;
    pOut->m22 = 1.0f / (zn - zf);
    pOut->m23 = 0.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = pOut->m22 * zn;
    pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->m00 = 2.0f / w;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = 2.0f / h;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = 0.0f;
    pOut->m21 = 0.0f;
    pOut->m22 = 1.0f / (zf - zn);
    pOut->m23 = 0.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = -pOut->m22 * zn;
    pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoOffCenter
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->m00 = 2.0f * wInv;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = 2.0f * hInv;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = 0.0f;
    pOut->m21 = 0.0f;
    pOut->m22 = 1.0f / (zn - zf);
    pOut->m23 = 0.0f;

    pOut->m30 = -(l + r) * wInv;
    pOut->m31 = -(t + b) * hInv;
    pOut->m32 = pOut->m22 * zn;
    pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->m00 = 2.0f * wInv;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = 2.0f * hInv;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = 0.0f;
    pOut->m21 = 0.0f;
    pOut->m22 = 1.0f / (zf - zn);
    pOut->m23 = 0.0f;

    pOut->m30 = -(l + r) * wInv;
    pOut->m31 = -(t + b) * hInv;
    pOut->m32 = -pOut->m22 * zn;
    pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixShadow
    ( D3DXMATRIX *pOut, const D3DXVECTOR4 *pLight,
      const D3DXPLANE *pPlane )
{
#if DBG
    if(!pOut || !pLight || !pPlane)
        return NULL;
#endif

    D3DXPLANE p;
    VB_D3DXPlaneNormalize(&p, pPlane);    
    float dot = VB_D3DXPlaneDot(&p, pLight);
    p = -p;

    pOut->m00 = p.a * pLight->x + dot;
    pOut->m10 = p.b * pLight->x;
    pOut->m20 = p.c * pLight->x;
    pOut->m30 = p.d * pLight->x;

    pOut->m01 = p.a * pLight->y;
    pOut->m11 = p.b * pLight->y + dot;
    pOut->m21 = p.c * pLight->y;
    pOut->m31 = p.d * pLight->y;

    pOut->m02 = p.a * pLight->z;
    pOut->m12 = p.b * pLight->z;
    pOut->m22 = p.c * pLight->z + dot;
    pOut->m32 = p.d * pLight->z;

    pOut->m03 = p.a * pLight->w;
    pOut->m13 = p.b * pLight->w;
    pOut->m23 = p.c * pLight->w;
    pOut->m33 = p.d * pLight->w + dot;

    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixReflect
    ( D3DXMATRIX *pOut, const D3DXPLANE *pPlane )
{
#if DBG
    if(!pOut || !pPlane)
        return NULL;
#endif

    D3DXPLANE p;
    VB_D3DXPlaneNormalize(&p, pPlane);
    
    float fa = -2.0f * p.a;
    float fb = -2.0f * p.b;
    float fc = -2.0f * p.c;

    pOut->m00 = fa * p.a + 1.0f;
    pOut->m01 = fb * p.a;
    pOut->m02 = fc * p.a;
    pOut->m03 = 0.0f;

    pOut->m10 = fa * p.b;
    pOut->m11 = fb * p.b + 1.0f;
    pOut->m12 = fc * p.b;
    pOut->m13 = 0.0f;

    pOut->m20 = fa * p.c;
    pOut->m21 = fb * p.c;
    pOut->m22 = fc * p.c + 1.0f;
    pOut->m23 = 0.0f;

    pOut->m30 = fa * p.d;
    pOut->m31 = fb * p.d;
    pOut->m32 = fc * p.d;
    pOut->m33 = 1.0f;

    return pOut;
}

//--------------------------
// Quaternion
//--------------------------

void WINAPI VB_D3DXQuaternionToAxisAngle
    ( const D3DXQUATERNION *pQ, D3DXVECTOR3 *pAxis, float *pAngle )
{
#if DBG
    if(!pQ)
        return;
#endif

    // expects unit quaternions!
	// q = cos(A/2), sin(A/2) * v

    float lsq = VB_D3DXQuaternionLengthSq(pQ);

    if(lsq > EPSILON * EPSILON)
    {        
        if(pAxis)
        {
            float scale = 1.0f / sqrtf(lsq);
            pAxis->x = pQ->x * scale;
            pAxis->y = pQ->y * scale;
            pAxis->z = pQ->z * scale;
        }

        if(pAngle)
            *pAngle = 2.0f * acosf(pQ->w);

    }
    else
    {
        if(pAxis)
        {
            pAxis->x = 1.0;
            pAxis->y = 0.0;
            pAxis->z = 0.0;
        }

        if(pAngle)
            *pAngle = 0.0f;
    }
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationMatrix
    ( D3DXQUATERNION *pOut, const D3DXMATRIX *pM)
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif

    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".  (Taken from GDMAG feb'98 p38)

    float trace = pM->m00 + pM->m11 + pM->m22;
    float root;

    if ( trace > 0.0f )
    {
        // |w| > 1/2, may as well choose w > 1/2

        root = sqrtf(trace + 1.0f);  // 2w
        pOut->w = 0.5f * root;

        root = 0.5f / root;  // 1/(4w)
        pOut->x = (pM->m12 - pM->m21) * root;
        pOut->y = (pM->m20 - pM->m02) * root;
        pOut->z = (pM->m01 - pM->m10) * root;
    }
    else
    {
        // |w| <= 1/2
        static const int next[3] = { 1, 2, 0 };

        int i = 0;
        i += (pM->m11 > pM->m00);
        i += (pM->m22 > pM->m[i][i]);

        int j = next[i];
        int k = next[j];

        root = sqrtf(pM->m[i][i] - pM->m[j][j] - pM->m[k][k] + 1.0f);
        (*pOut)[i] = 0.5f * root;

        if(0.0f != root)
            root = 0.5f / root;

        pOut->w    = (pM->m[j][k] - pM->m[k][j]) * root;
        (*pOut)[j] = (pM->m[i][j] + pM->m[j][i]) * root;
        (*pOut)[k] = (pM->m[i][k] + pM->m[k][i]) * root;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationAxis
    ( D3DXQUATERNION *pOut, const D3DXVECTOR3 *pV, float angle )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    D3DXVECTOR3 v;
    VB_D3DXVec3Normalize(&v, pV);

    float s;
    sincosf(0.5f * angle, &s, &pOut->w);

    pOut->x = v.x * s;
    pOut->y = v.y * s;
    pOut->z = v.z * s;

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationYawPitchRoll
    ( D3DXQUATERNION *pOut, float yaw, float pitch, float roll )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    //  Roll first, about axis the object is facing, then
    //  pitch upward, then yaw to face into the new heading

    float SR, CR, SP, CP, SY, CY;

    sincosf(0.5f * roll,  &SR, &CR);
    sincosf(0.5f * pitch, &SP, &CP);
    sincosf(0.5f * yaw,   &SY, &CY);

    pOut->x = CY*SP*CR + SY*CP*SR;
    pOut->y = SY*CP*CR - CY*SP*SR;
    pOut->z = CY*CP*SR - SY*SP*CR;
    pOut->w = CY*CP*CR + SY*SP*SR;

    return pOut;
}


D3DXQUATERNION* WINAPI VB_D3DXQuaternionMultiply
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2 )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2)
        return NULL;
#endif


#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pQ2]
        mov   edx, DWORD PTR [pQ1]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+0*4] ; wx
        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+2*4] ; wz
        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+1*4] ; wy
        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+3*4] ; ww
        fxch  st(3)
        // wx wy wz ww

        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+3*4] ; xw
        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+1*4] ; xy
        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+2*4] ; xz
        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+0*4] ; xx
        fxch  st(3)
        // xw xz xy xx  wx wy wz ww

        faddp st(4), st
        fsubp st(4), st
        faddp st(4), st
        fsubp st(4), st
        // wx-xw wy-xz wz+xy ww-xx

        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+2*4] ; yz
        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+0*4] ; yx
        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+3*4] ; yw
        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+1*4] ; yy
        fxch  st(3)
        // yz yw yx yy  wx-xw wy-xz wz+xy ww-xx

        faddp st(4), st
        faddp st(4), st
        fsubp st(4), st
        fsubp st(4), st
        // wx-xw+yz wy-xz+yw wz+xy-yx ww-xx-yy

        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+1*4] ; zy
        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+3*4] ; zw
        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+0*4] ; zx
        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+2*4] ; zz
        fxch  st(3)
        // zy zx zw zz wx-xw+yz wy-xz+yw wz+xy-yx ww-xx-yy

        fsubp st(4), st
        faddp st(4), st
        faddp st(4), st
        fsubp st(4), st
        // wx-xw+yz-zy wy-xz+yw+zx wz+xy-yx+zw ww-xx-yy-zz

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXQUATERNION Q;

    Q.x = pQ2->w * pQ1->x + pQ2->x * pQ1->w + pQ2->y * pQ1->z - pQ2->z * pQ1->y;
    Q.y = pQ2->w * pQ1->y - pQ2->x * pQ1->z + pQ2->y * pQ1->w + pQ2->z * pQ1->x;
    Q.z = pQ2->w * pQ1->z + pQ2->x * pQ1->y - pQ2->y * pQ1->x + pQ2->z * pQ1->w;
    Q.w = pQ2->w * pQ1->w - pQ2->x * pQ1->x - pQ2->y * pQ1->y - pQ2->z * pQ1->z;

    *pOut = Q;
    return pOut;
#endif // !_X86_
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionNormalize
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float f = VB_D3DXQuaternionLengthSq(pQ);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pQ)
            *pOut = *pQ;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pQ / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionInverse
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float f = VB_D3DXQuaternionLengthSq(pQ);

    if(f > EPSILON*EPSILON)
    {
        VB_D3DXQuaternionConjugate(pOut, pQ);

        if(!WithinEpsilon(f, 1.0f))
            *pOut /= f;
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionLn
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    // expects unit quaternions!
    // q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)

    float theta, s, scale;

    if(pQ->w < 1.0f)
    {
        theta = acosf(pQ->w);
        s = sinf(theta);

        if(!WithinEpsilon(s, 0.0f))
        {
            float scale = theta / s;
            pOut->x = pQ->x * scale;
            pOut->y = pQ->y * scale;
            pOut->z = pQ->z * scale;
            pOut->w = 0.0f;
        }
        else
        {
            pOut->x = pQ->x;
            pOut->y = pQ->y;
            pOut->z = pQ->z;
            pOut->w = 0.0f;
        }
    }
    else
    {
        pOut->x = pQ->x;
        pOut->y = pQ->y;
        pOut->z = pQ->z;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionExp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    // expects pure quaternions! (w == 0)
    // q = (0, theta * v) ; exp(q) = (cos(theta), sin(theta) * v)

    float theta, s;

    theta = sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z);
    sincosf(theta, &s, &pOut->w);

    if(WithinEpsilon(s, 0.0f))
    {
        if(pOut != pQ)
        {
            pOut->x = pQ->x;
            pOut->y = pQ->y;
            pOut->z = pQ->z;
        }
    }
    else
    {
        s /= theta;

        pOut->x = pQ->x * s;
        pOut->y = pQ->y * s;
        pOut->z = pQ->z * s;
    }

    return pOut;
}


D3DXQUATERNION* WINAPI VB_D3DXQuaternionSlerp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, float b )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2)
        return NULL;
#endif

    // expects unit quaternions!
    float a, c, flip, s, omega, sInv;

    a = 1.0f - b;
    c = VB_D3DXQuaternionDot(pQ1, pQ2);
    flip = (c >= 0.0f) ? 1.0f : -1.0f;
    c *= flip;

	if(1.0f - c > EPSILON) {
        s = sqrtf(1.0f - c * c);
 		omega = atan2f(s, c);
 		sInv = 1.0f / s;

 		a = sinf(a * omega) * sInv;
 		b = sinf(b * omega) * sInv;
 	}

    b *= flip;

    pOut->x = a * pQ1->x + b * pQ2->x;
    pOut->y = a * pQ1->y + b * pQ2->y;
    pOut->z = a * pQ1->z + b * pQ2->z;
    pOut->w = a * pQ1->w + b * pQ2->w;

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionSquad
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      const D3DXQUATERNION *pQ4, float t )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2 || !pQ3 || !pQ4)
        return NULL;
#endif

    // expects unit quaternions!
    D3DXQUATERNION QA, QB;

    VB_D3DXQuaternionSlerp(&QA, pQ1, pQ4, t);
    VB_D3DXQuaternionSlerp(&QB, pQ2, pQ3, t);
    VB_D3DXQuaternionSlerp(pOut, &QA, &QB, 2.0f * t * (1.0f - t));

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionBaryCentric
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      float f, float g )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2 || !pQ3)
        return NULL;
#endif

    // expects unit quaternions!
    D3DXQUATERNION QA, QB;
    float s = f + g;

    if(WithinEpsilon(s, 0.0f))
    {
        if(pOut != pQ1)
            *pOut = *pQ1;
    }
    else
    {
        VB_D3DXQuaternionSlerp(&QA, pQ1, pQ2, s);
        VB_D3DXQuaternionSlerp(&QB, pQ1, pQ3, s);
        VB_D3DXQuaternionSlerp(pOut, &QA, &QB, g / s);
    }

    return pOut;
}


//--------------------------
// Plane
//--------------------------

D3DXPLANE* WINAPI VB_D3DXPlaneNormalize
    ( D3DXPLANE *pOut, const D3DXPLANE *pP )
{
#if DBG
    if(!pOut || !pP)
        return NULL;
#endif

    float f = pP->a * pP->a + pP->b * pP->b + pP->c * pP->c;

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pP)
            *pOut = *pP;
    }
    else if(f > EPSILON * EPSILON)
    {
        float fInv = 1.0f / sqrtf(f);

        pOut->a = pP->a * fInv;
        pOut->b = pP->b * fInv;
        pOut->c = pP->c * fInv;
        pOut->d = pP->d * fInv;
    }
    else
    {
        pOut->a = 0.0f;
        pOut->b = 0.0f;
        pOut->c = 0.0f;
        pOut->d = 0.0f;
    }

    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXPlaneIntersectLine
    ( D3DXVECTOR3 *pOut, const D3DXPLANE *pP, const D3DXVECTOR3 *pV1, 
      const D3DXVECTOR3 *pV2)
{
#if DBG
    if(!pOut || !pP || !pV1 || !pV2)
        return NULL;
#endif

    float d =  VB_D3DXPlaneDotNormal(pP, pV1) - VB_D3DXPlaneDotNormal(pP, pV2);

    if(d == 0.0f)
        return NULL;

    float f = VB_D3DXPlaneDotCoord(pP, pV1) / d;

    if(!_finite(f))
        return NULL;

    VB_D3DXVec3Lerp(pOut, pV1, pV2, f);
    return pOut;
}

D3DXPLANE* WINAPI VB_D3DXPlaneFromPointNormal
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pPoint, const D3DXVECTOR3 *pNormal)
{
#if DBG
    if(!pOut || !pPoint || !pNormal)
        return NULL;
#endif

    pOut->a = pNormal->x;
    pOut->b = pNormal->y;
    pOut->c = pNormal->z;
    pOut->d = -VB_D3DXVec3Dot(pPoint, pNormal);
    return pOut;
}

D3DXPLANE* WINAPI VB_D3DXPlaneFromPoints
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2, 
      const D3DXVECTOR3 *pV3)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    D3DXVECTOR3 V12 = *pV1 - *pV2;
    D3DXVECTOR3 V13 = *pV1 - *pV3;

    VB_D3DXVec3Cross((D3DXVECTOR3 *) pOut, &V12, &V13);
    VB_D3DXVec3Normalize((D3DXVECTOR3 *) pOut, (D3DXVECTOR3 *) pOut);

    pOut->d = -VB_D3DXPlaneDotNormal(pOut, pV1);
    return pOut;
}

D3DXPLANE* WINAPI VB_D3DXPlaneTransform
    ( D3DXPLANE *pOut, const D3DXPLANE *pP, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pP || !pM)
        return NULL;
#endif

    D3DXPLANE P;
    VB_D3DXPlaneNormalize(&P, pP);

    D3DXVECTOR3 V(-P.a * P.d, -P.b * P.d, -P.c * P.d);
    VB_D3DXVec3TransformCoord(&V, &V, pM);

    VB_D3DXVec3TransformNormal((D3DXVECTOR3 *) pOut, (const D3DXVECTOR3 *) &P, pM);
    VB_D3DXVec3Normalize((D3DXVECTOR3 *) pOut, (const D3DXVECTOR3 *) pOut);

    pOut->d = -VB_D3DXPlaneDotNormal(pOut, &V);
    return pOut;
}


//--------------------------
// Color
//--------------------------

D3DXCOLOR* WINAPI VB_D3DXColorAdjustSaturation 
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s)
{
#if DBG
    if(!pOut || !pC)
        return NULL;
#endif

    // Approximate values for each component's contribution to luminance.
    // (Based upon the NTSC standard described in the comp.graphics.algorithms
    // colorspace FAQ)
    float grey = pC->r * 0.2125f + pC->g * 0.7154f + pC->b * 0.0721f;

    pOut->r = grey + s * (pC->r - grey);
    pOut->g = grey + s * (pC->g - grey);
    pOut->b = grey + s * (pC->b - grey);
    pOut->a = pC->a;
    return pOut;
}

D3DXCOLOR* WINAPI VB_D3DXColorAdjustContrast
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float c)
{
#if DBG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = 0.5f + c * (pC->r - 0.5f);
    pOut->g = 0.5f + c * (pC->g - 0.5f);
    pOut->b = 0.5f + c * (pC->b - 0.5f);
    pOut->a = pC->a;
    return pOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3dxmathvb.inl ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxmath.inl
//  Content:    D3DX math inline functions
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __D3DXMATHVB_INL__
#define __D3DXMATHVB_INL__





//===========================================================================
//
// Inline functions
//
//===========================================================================


//--------------------------
// 2D Vector
//--------------------------

float  D3DVBCALL VB_D3DXVec2Length
    ( const D3DXVECTOR2 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y);
#else
    return (float) sqrt(pV->x * pV->x + pV->y * pV->y);
#endif 
}

 float  D3DVBCALL VB_D3DXVec2LengthSq
    ( const D3DXVECTOR2 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y;
}

 float D3DVBCALL   VB_D3DXVec2Dot
    ( const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y;
}

 float D3DVBCALL  D3DVBINLINE VB_D3DXVec2CCW
    ( const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->y - pV1->y * pV2->x;
}

D3DVBINLINE D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Add
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    return pOut;
}

D3DVBINLINE D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Subtract
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    return pOut;
}

D3DVBINLINE D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Minimize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    return pOut;
}

D3DVBINLINE D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Maximize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    return pOut;
}

D3DVBINLINE D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Scale
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, float s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    return pOut;
}

D3DVBINLINE D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Lerp
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      float s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    return pOut;
}


//--------------------------
// 3D Vector
//--------------------------

D3DVBINLINE float D3DVBCALL VB_D3DXVec3Length
    ( const D3DXVECTOR3 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
#else
    return (float) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
#endif
}

D3DVBINLINE float D3DVBCALL VB_D3DXVec3LengthSq
    ( const D3DXVECTOR3 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
}

D3DVBINLINE float D3DVBCALL VB_D3DXVec3Dot
    ( const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;
}

D3DVBINLINE D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Cross
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
    D3DXVECTOR3 v;

#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    v.x = pV1->y * pV2->z - pV1->z * pV2->y;
    v.y = pV1->z * pV2->x - pV1->x * pV2->z;
    v.z = pV1->x * pV2->y - pV1->y * pV2->x;

    *pOut = v;
    return pOut;
}

D3DVBINLINE D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Add
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    pOut->z = pV1->z + pV2->z;
    return pOut;
}

D3DVBINLINE D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Subtract
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    pOut->z = pV1->z - pV2->z;
    return pOut;
}

D3DVBINLINE D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Minimize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
    return pOut;
}

D3DVBINLINE D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Maximize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
    return pOut;
}

D3DVBINLINE D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Scale
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, float s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    pOut->z = pV->z * s;
    return pOut;
}

D3DVBINLINE D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Lerp
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      float s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    pOut->z = pV1->z + s * (pV2->z - pV1->z);
    return pOut;
}


//--------------------------
// 4D Vector
//--------------------------

D3DVBINLINE float D3DVBCALL VB_D3DXVec4Length
    ( const D3DXVECTOR4 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
#else
    return (float) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
#endif
}

D3DVBINLINE float D3DVBCALL VB_D3DXVec4LengthSq
    ( const D3DXVECTOR4 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w;
}

D3DVBINLINE float D3DVBCALL VB_D3DXVec4Dot
    ( const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z + pV1->w * pV2->w;
}

D3DVBINLINE D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Add
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    pOut->z = pV1->z + pV2->z;
    pOut->w = pV1->w + pV2->w;
    return pOut;
}

D3DVBINLINE D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Subtract
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    pOut->z = pV1->z - pV2->z;
    pOut->w = pV1->w - pV2->w;
    return pOut;
}

D3DVBINLINE D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Minimize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
    pOut->w = pV1->w < pV2->w ? pV1->w : pV2->w;
    return pOut;
}

D3DVBINLINE D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Maximize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
    pOut->w = pV1->w > pV2->w ? pV1->w : pV2->w;
    return pOut;
}

D3DVBINLINE D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Scale
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, float s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    pOut->z = pV->z * s;
    pOut->w = pV->w * s;
    return pOut;
}

D3DVBINLINE D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Lerp
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      float s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    pOut->z = pV1->z + s * (pV2->z - pV1->z);
    pOut->w = pV1->w + s * (pV2->w - pV1->w);
    return pOut;
}


//--------------------------
// 4D Matrix
//--------------------------

D3DVBINLINE D3DXMATRIX* D3DVBCALL VB_D3DXMatrixIdentity
    ( D3DXMATRIX *pOut )
{
#ifdef D3DX_DEBUG
    if(!pOut)
        return NULL;
#endif

    pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] = 
    pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] = 
    pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] = 
    pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;

    pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;
    return pOut;
}


D3DVBINLINE BOOL D3DVBCALL  VB_D3DXMatrixIsIdentity
    ( const D3DXMATRIX *pM )
{
#ifdef D3DX_DEBUG
    if(!pM)
        return FALSE;
#endif

    return pM->m[0][0] == 1.0f && pM->m[0][1] == 0.0f && pM->m[0][2] == 0.0f && pM->m[0][3] == 0.0f &&
           pM->m[1][0] == 0.0f && pM->m[1][1] == 1.0f && pM->m[1][2] == 0.0f && pM->m[1][3] == 0.0f &&
           pM->m[2][0] == 0.0f && pM->m[2][1] == 0.0f && pM->m[2][2] == 1.0f && pM->m[2][3] == 0.0f &&
           pM->m[3][0] == 0.0f && pM->m[3][1] == 0.0f && pM->m[3][2] == 0.0f && pM->m[3][3] == 1.0f;
}


//--------------------------
// Quaternion
//--------------------------

D3DVBINLINE float D3DVBCALL VB_D3DXQuaternionLength
    ( const D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
#else
    return (float) sqrt(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
#endif
}

D3DVBINLINE float D3DVBCALL VB_D3DXQuaternionLengthSq
    ( const D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return 0.0f;
#endif

    return pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w;
}

D3DVBINLINE float D3DVBCALL VB_D3DXQuaternionDot
    ( const D3DXQUATERNION *pQ1, const D3DXQUATERNION *pQ2 )
{
#ifdef D3DX_DEBUG
    if(!pQ1 || !pQ2)
        return 0.0f;
#endif

    return pQ1->x * pQ2->x + pQ1->y * pQ2->y + pQ1->z * pQ2->z + pQ1->w * pQ2->w;
}


D3DVBINLINE D3DXQUATERNION* D3DVBCALL VB_D3DXQuaternionIdentity
    ( D3DXQUATERNION *pOut )
{
#ifdef D3DX_DEBUG
    if(!pOut)
        return NULL;
#endif

    pOut->x = pOut->y = pOut->z = 0.0f;
    pOut->w = 1.0f;
    return pOut;
}

D3DVBINLINE BOOL D3DVBCALL VB_D3DXQuaternionIsIdentity
    ( const D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return FALSE;
#endif

    return pQ->x == 0.0f && pQ->y == 0.0f && pQ->z == 0.0f && pQ->w == 1.0f;
}


D3DVBINLINE D3DXQUATERNION* D3DVBCALL VB_D3DXQuaternionConjugate
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pQ)
        return NULL;
#endif

    pOut->x = -pQ->x;
    pOut->y = -pQ->y;
    pOut->z = -pQ->z;
    pOut->w =  pQ->w;
    return pOut;
}


//--------------------------
// Plane
//--------------------------

D3DVBINLINE float D3DVBCALL VB_D3DXPlaneDot
    ( const D3DXPLANE *pP, const D3DXVECTOR4 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d * pV->w;
}

D3DVBINLINE float D3DVBCALL VB_D3DXPlaneDotCoord
    ( const D3DXPLANE *pP, const D3DXVECTOR3 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;
}

D3DVBINLINE float D3DVBCALL VB_D3DXPlaneDotNormal
    ( const D3DXPLANE *pP, const D3DXVECTOR3 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z;
}


//--------------------------
// Color
//--------------------------

D3DVBINLINE D3DXCOLOR* D3DVBCALL VB_D3DXColorNegative
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = 1.0f - pC->r;
    pOut->g = 1.0f - pC->g;
    pOut->b = 1.0f - pC->b;
    pOut->a = pC->a;
    return pOut;
}

D3DVBINLINE D3DXCOLOR* D3DVBCALL VB_D3DXColorAdd        
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r + pC2->r;
    pOut->g = pC1->g + pC2->g;
    pOut->b = pC1->b + pC2->b;
    pOut->a = pC1->a + pC2->a;
    return pOut;
}

D3DVBINLINE D3DXCOLOR* D3DVBCALL VB_D3DXColorSubtract   
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r - pC2->r;
    pOut->g = pC1->g - pC2->g;
    pOut->b = pC1->b - pC2->b;
    pOut->a = pC1->a - pC2->a;
    return pOut;
}

D3DVBINLINE D3DXCOLOR* D3DVBCALL VB_D3DXColorScale      
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = pC->r * s;
    pOut->g = pC->g * s;
    pOut->b = pC->b * s;
    pOut->a = pC->a * s;
    return pOut;
} 

D3DVBINLINE D3DXCOLOR* D3DVBCALL VB_D3DXColorModulate   
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r * pC2->r;
    pOut->g = pC1->g * pC2->g;
    pOut->b = pC1->b * pC2->b;
    pOut->a = pC1->a * pC2->a;
    return pOut;
}

D3DVBINLINE D3DXCOLOR* D3DVBCALL VB_D3DXColorLerp       
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2, float s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r + s * (pC2->r - pC1->r);
    pOut->g = pC1->g + s * (pC2->g - pC1->g);
    pOut->b = pC1->b + s * (pC2->b - pC1->b);
    pOut->a = pC1->a + s * (pC2->a - pC1->a);
    return pOut;
}


#endif // __D3DXMATHVB_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3dxmathvb.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxmath.h
//  Content:    D3DX math types and functions
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __D3DXMATHVB_H__
#define __D3DXMATHVB_H__

//#include <d3d.h>
#include <math.h>
#include <limits.h>
//#include "d3dxerr.h"

#ifndef D3DXINLINE
#ifdef __cplusplus
#define D3DXINLINE inline
#else
#define D3DXINLINE _inline
#endif
#endif

#pragma warning(disable:4201) // anonymous unions warning

//===========================================================================
//
// General purpose utilities
//
//===========================================================================
//#define D3DX_PI    ((float)  3.141592654f)
//#define D3DX_1BYPI ((float)  0.318309886f)

#define D3DXToRadian( degree ) ((degree) * (D3DX_PI / 180.0f))
#define D3DXToDegree( radian ) ((radian) * (180.0f / D3DX_PI))





//===========================================================================
//
// D3DX math functions:
//
// NOTE:
//  * All these functions can take the same object as in and out parameters.
//
//  * Out parameters are typically also returned as return values, so that
//    the output of one function may be used as a parameter to another.
//
//===========================================================================

//--------------------------
// 2D Vector
//--------------------------

// inline

float D3DVBCALL VB_D3DXVec2Length
    ( const D3DXVECTOR2 *pV );

float D3DVBCALL VB_D3DXVec2LengthSq
    ( const D3DXVECTOR2 *pV );

float D3DVBCALL VB_D3DXVec2Dot
    ( const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

// Z component of ((x1,y1,0) cross (x2,y2,0))
float D3DVBCALL VB_D3DXVec2CCW
    ( const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Add
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Subtract
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2)
D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Minimize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2)
D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Maximize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Scale
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, float s );

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Lerp
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      float s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

D3DXVECTOR2* WINAPI VB_D3DXVec2Normalize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR2* WINAPI VB_D3DXVec2Hermite
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pT1,
      const D3DXVECTOR2 *pV2, const D3DXVECTOR2 *pT2, float s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR2* WINAPI VB_D3DXVec2CatmullRom
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV0, const D3DXVECTOR2 *pV1,
      const D3DXVECTOR2 *pV2, const D3DXVECTOR2 *pV3, float s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR2* WINAPI VB_D3DXVec2BaryCentric
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      D3DXVECTOR2 *pV3, float f, float g);

// Transform (x, y, 0, 1) by matrix.
D3DXVECTOR4* WINAPI VB_D3DXVec2Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM );

// Transform (x, y, 0, 1) by matrix, project result back into w=1.
D3DXVECTOR2* WINAPI VB_D3DXVec2TransformCoord
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM );

// Transform (x, y, 0, 0) by matrix.
D3DXVECTOR2* WINAPI VB_D3DXVec2TransformNormal
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 3D Vector
//--------------------------

// inline

float D3DVBCALL  VB_D3DXVec3Length
    ( const D3DXVECTOR3 *pV );

float D3DVBCALL VB_D3DXVec3LengthSq
    ( const D3DXVECTOR3 *pV );

float D3DVBCALL VB_D3DXVec3Dot
    ( const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Cross
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Add
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Subtract
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Minimize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Maximize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Scale
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, float s);

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Lerp
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      float s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

D3DXVECTOR3* WINAPI VB_D3DXVec3Normalize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR3* WINAPI VB_D3DXVec3Hermite
    ( D3DXVECTOR3 *pOut,  const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pT1,
      const D3DXVECTOR3 *pV2, const D3DXVECTOR3 *pT2, float s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR3* WINAPI VB_D3DXVec3CatmullRom
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV0, const D3DXVECTOR3 *pV1,
      const D3DXVECTOR3 *pV2, const D3DXVECTOR3 *pV3, float s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR3* WINAPI VB_D3DXVec3BaryCentric
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      const D3DXVECTOR3 *pV3, float f, float g);

// Transform (x, y, z, 1) by matrix.
D3DXVECTOR4* WINAPI VB_D3DXVec3Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM );

// Transform (x, y, z, 1) by matrix, project result back into w=1.
D3DXVECTOR3* WINAPI VB_D3DXVec3TransformCoord
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM );

// Transform (x, y, z, 0) by matrix.
D3DXVECTOR3* WINAPI VB_D3DXVec3TransformNormal
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM );

// Project vector from object space into screen space
D3DXVECTOR3* WINAPI VB_D3DXVec3Project
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DVIEWPORT8 *pViewport,
      const D3DXMATRIX *pProjection, const D3DXMATRIX *pView, const D3DXMATRIX *pWorld);

// Project vector from screen space into object space
D3DXVECTOR3* WINAPI VB_D3DXVec3Unproject
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DVIEWPORT8 *pViewport,
      const D3DXMATRIX *pProjection, const D3DXMATRIX *pView, const D3DXMATRIX *pWorld);

#ifdef __cplusplus
}
#endif



//--------------------------
// 4D Vector
//--------------------------

// inline

float D3DVBCALL VB_D3DXVec4Length
    ( const D3DXVECTOR4 *pV );

float D3DVBCALL VB_D3DXVec4LengthSq
    ( const D3DXVECTOR4 *pV );

float D3DVBCALL VB_D3DXVec4Dot
    ( const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2 );

D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Add
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2);

D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Subtract
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2);

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Minimize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2);

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Maximize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2);

D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Scale
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, float s);

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Lerp
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      float s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Cross-product in 4 dimensions.
D3DXVECTOR4* WINAPI VB_D3DXVec4Cross
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      const D3DXVECTOR4 *pV3);

D3DXVECTOR4* WINAPI VB_D3DXVec4Normalize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR4* WINAPI VB_D3DXVec4Hermite
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pT1,
      const D3DXVECTOR4 *pV2, const D3DXVECTOR4 *pT2, float s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR4* WINAPI VB_D3DXVec4CatmullRom
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV0, const D3DXVECTOR4 *pV1,
      const D3DXVECTOR4 *pV2, const D3DXVECTOR4 *pV3, float s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR4* WINAPI VB_D3DXVec4BaryCentric
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      const D3DXVECTOR4 *pV3, float f, float g);

// Transform vector by matrix.
D3DXVECTOR4* WINAPI VB_D3DXVec4Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, const D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 4D Matrix
//--------------------------

// inline

D3DXMATRIX* D3DVBCALL VB_D3DXMatrixIdentity
    ( D3DXMATRIX *pOut );

BOOL D3DVBCALL VB_D3DXMatrixIsIdentity
    ( const D3DXMATRIX *pM );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

float WINAPI D3DXMatrixfDeterminant
    ( const D3DXMATRIX *pM );

// Matrix multiplication.  The result represents the transformation M2 
// followed by the transformation M1.  (Out = M1 * M2)
D3DXMATRIX* WINAPI VB_D3DXMatrixMultiply
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM1, const D3DXMATRIX *pM2 );

D3DXMATRIX* WINAPI VB_D3DXMatrixTranspose
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM );

// Calculate inverse of matrix.  Inversion my fail, in which case NULL will
// be returned.  The determinant of pM is also returned it pfDeterminant
// is non-NULL.
D3DXMATRIX* WINAPI VB_D3DXMatrixInverse
    ( D3DXMATRIX *pOut, float *pfDeterminant, const D3DXMATRIX *pM );

// Build a matrix which scales by (sx, sy, sz)
D3DXMATRIX* WINAPI VB_D3DXMatrixScaling
    ( D3DXMATRIX *pOut, float sx, float sy, float sz );

// Build a matrix which translates by (x, y, z)
D3DXMATRIX* WINAPI VB_D3DXMatrixTranslation
    ( D3DXMATRIX *pOut, float x, float y, float z );

// Build a matrix which rotates around the X axis
D3DXMATRIX* WINAPI VB_D3DXMatrixRotationX
    ( D3DXMATRIX *pOut, float angle );

// Build a matrix which rotates around the Y axis
D3DXMATRIX* WINAPI VB_D3DXMatrixRotationY
    ( D3DXMATRIX *pOut, float angle );

// Build a matrix which rotates around the Z axis
D3DXMATRIX* WINAPI VB_D3DXMatrixRotationZ
    ( D3DXMATRIX *pOut, float angle );

// Build a matrix which rotates around an arbitrary axis
D3DXMATRIX* WINAPI VB_D3DXMatrixRotationAxis
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pV, float angle );

// Build a matrix from a quaternion
D3DXMATRIX* WINAPI VB_D3DXMatrixRotationQuaternion
    ( D3DXMATRIX *pOut, const D3DXQUATERNION *pQ);

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
D3DXMATRIX* WINAPI VB_D3DXMatrixRotationYawPitchRoll
    ( D3DXMATRIX *pOut, float yaw, float pitch, float roll );


// Build transformation matrix.  NULL arguments are treated as identity.
// Mout = Msc-1 * Msr-1 * Ms * Msr * Msc * Mrc-1 * Mr * Mrc * Mt
D3DXMATRIX* WINAPI VB_D3DXMatrixTransformation
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pScalingCenter,
      const D3DXQUATERNION *pScalingRotation, const D3DXVECTOR3 *pScaling,
      const D3DXVECTOR3 *pRotationCenter, const D3DXQUATERNION *pRotation,
      const D3DXVECTOR3 *pTranslation);

// Build affine transformation matrix.  NULL arguments are treated as identity.
// Mout = Ms * Mrc-1 * Mr * Mrc * Mt
D3DXMATRIX* WINAPI VB_D3DXMatrixAffineTransformation
    ( D3DXMATRIX *pOut, float Scaling, const D3DXVECTOR3 *pRotationCenter,
      const D3DXQUATERNION *pRotation, const D3DXVECTOR3 *pTranslation);

// Build a lookat matrix. (right-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixLookAtRH
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp );

// Build a lookat matrix. (left-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixLookAtLH
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveRH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveFovRH
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveFovLH
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveOffCenterRH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf );

// Build an ortho projection matrix. (right-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoRH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf );

// Build an ortho projection matrix. (left-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf );

// Build an ortho projection matrix. (right-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoOffCenterRH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf );

// Build an ortho projection matrix. (left-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf );

// Build a matrix which flattens geometry into a plane, as if casting
// a shadow from a light.
D3DXMATRIX* WINAPI VB_D3DXMatrixShadow
    ( D3DXMATRIX *pOut, const D3DXVECTOR4 *pLight,
      const D3DXPLANE *pPlane );

// Build a matrix which reflects the coordinate system about a plane
D3DXMATRIX* WINAPI VB_D3DXMatrixReflect
    ( D3DXMATRIX *pOut, const D3DXPLANE *pPlane );

#ifdef __cplusplus
}
#endif


//--------------------------
// Quaternion
//--------------------------

// inline

float D3DVBCALL VB_D3DXQuaternionLength
    ( const D3DXQUATERNION *pQ );

// Length squared, or "norm"
float D3DVBCALL VB_D3DXQuaternionLengthSq
    ( const D3DXQUATERNION *pQ );

float D3DVBCALL VB_D3DXQuaternionDot
    ( const D3DXQUATERNION *pQ1, const D3DXQUATERNION *pQ2 );

// (0, 0, 0, 1)
D3DXQUATERNION* D3DVBCALL VB_D3DXQuaternionIdentity
    ( D3DXQUATERNION *pOut );

BOOL D3DVBCALL VB_D3DXQuaternionIsIdentity
    ( const D3DXQUATERNION *pQ );

// (-x, -y, -z, w)
D3DXQUATERNION* D3DVBCALL VB_D3DXQuaternionConjugate
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Compute a quaternin's axis and angle of rotation. Expects unit quaternions.
void WINAPI VB_D3DXQuaternionToAxisAngle
    ( const D3DXQUATERNION *pQ, D3DXVECTOR3 *pAxis, float *pAngle );

// Build a quaternion from a rotation matrix.
D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationMatrix
    ( D3DXQUATERNION *pOut, const D3DXMATRIX *pM);

// Rotation about arbitrary axis.
D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationAxis
    ( D3DXQUATERNION *pOut, const D3DXVECTOR3 *pV, float angle );

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationYawPitchRoll
    ( D3DXQUATERNION *pOut, float yaw, float pitch, float roll );

// Quaternion multiplication.  The result represents the rotation Q2 
// followed by the rotation Q1.  (Out = Q2 * Q1)
D3DXQUATERNION* WINAPI VB_D3DXQuaternionMultiply
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2 );

D3DXQUATERNION* WINAPI VB_D3DXQuaternionNormalize
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );

// Conjugate and re-norm
D3DXQUATERNION* WINAPI VB_D3DXQuaternionInverse
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );

// Expects unit quaternions.
// if q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)
D3DXQUATERNION* WINAPI VB_D3DXQuaternionLn
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );

// Expects pure quaternions. (w == 0)  w is ignored in calculation.
// if q = (0, theta * v); exp(q) = (cos(theta), sin(theta) * v)
D3DXQUATERNION* WINAPI VB_D3DXQuaternionExp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );

// Spherical linear interpolation between Q1 (s == 0) and Q2 (s == 1).
// Expects unit quaternions.
D3DXQUATERNION* WINAPI VB_D3DXQuaternionSlerp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, float t );

// Spherical quadrangle interpolation.
// Slerp(Slerp(Q1, Q4, t), Slerp(Q2, Q3, t), 2t(1-t))
D3DXQUATERNION* WINAPI VB_D3DXQuaternionSquad
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      const D3DXQUATERNION *pQ4, float t );

// Slerp(Slerp(Q1, Q2, f+g), Slerp(Q1, Q3, f+g), g/(f+g))
D3DXQUATERNION* WINAPI VB_D3DXQuaternionBaryCentric
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      float f, float g );

#ifdef __cplusplus
}
#endif


//--------------------------
// Plane
//--------------------------

// inline

// ax + by + cz + dw
float D3DVBCALL VB_D3DXPlaneDot
    ( const D3DXPLANE *pP, const D3DXVECTOR4 *pV);

// ax + by + cz + d
float D3DVBCALL VB_D3DXPlaneDotCoord
    ( const D3DXPLANE *pP, const D3DXVECTOR3 *pV);

// ax + by + cz
float D3DVBCALL VB_D3DXPlaneDotNormal
    ( const D3DXPLANE *pP, const D3DXVECTOR3 *pV);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Normalize plane (so that |a,b,c| == 1)
D3DXPLANE* WINAPI VB_D3DXPlaneNormalize
    ( D3DXPLANE *pOut, const D3DXPLANE *pP);

// Find the intersection between a plane and a line.  If the line is
// parallel to the plane, NULL is returned.
D3DXVECTOR3* WINAPI VB_D3DXPlaneIntersectLine
    ( D3DXVECTOR3 *pOut, const D3DXPLANE *pP, const D3DXVECTOR3 *pV1,
      const D3DXVECTOR3 *pV2);

// Construct a plane from a point and a normal
D3DXPLANE* WINAPI VB_D3DXPlaneFromPointNormal
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pPoint, const D3DXVECTOR3 *pNormal);

// Construct a plane from 3 points
D3DXPLANE* WINAPI VB_D3DXPlaneFromPoints
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      const D3DXVECTOR3 *pV3);

// Transform a plane by a matrix.  The vector (a,b,c) must be normal.
// M must be an affine transform.
D3DXPLANE* WINAPI VB_D3DXPlaneTransform
    ( D3DXPLANE *pOut, const D3DXPLANE *pP, const D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// Color
//--------------------------

// inline

// (1-r, 1-g, 1-b, a)
D3DXCOLOR* D3DVBCALL VB_D3DXColorNegative
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC);

D3DXCOLOR* D3DVBCALL VB_D3DXColorAdd
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2);

D3DXCOLOR* D3DVBCALL  VB_D3DXColorSubtract
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2);

D3DXCOLOR* D3DVBCALL VB_D3DXColorScale
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s);

// (r1*r2, g1*g2, b1*b2, a1*a2)
D3DXCOLOR* D3DVBCALL VB_D3DXColorModulate
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2);

// Linear interpolation of r,g,b, and a. C1 + s(C2-C1)
D3DXCOLOR* D3DVBCALL VB_D3DXColorLerp
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2, float s);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Interpolate r,g,b between desaturated color and color.
// DesaturatedColor + s(Color - DesaturatedColor)
D3DXCOLOR* WINAPI VB_D3DXColorAdjustSaturation
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s);

// Interpolate r,g,b between 50% grey and color.  Grey + s(Color - Grey)
D3DXCOLOR* WINAPI VB_D3DXColorAdjustContrast
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float c);

#ifdef __cplusplus
}
#endif



#pragma warning(default:4201)

#endif // __D3DXMATHVB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\didevinstobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       didevinstobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "diDevInstObj.h"
#include "dinputDeviceObj.h"


extern BSTR GUIDtoBSTR(LPGUID g);

extern BSTR DINPUTGUIDtoBSTR(LPGUID g);
       
	

STDMETHODIMP C_dxj_DIDeviceInstance8Object::getGuidInstance( BSTR __RPC_FAR *ret){
	*ret=DINPUTGUIDtoBSTR(&m_inst.guidInstance);
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceInstance8Object::getGuidProduct( BSTR __RPC_FAR *ret){
	*ret=GUIDtoBSTR( &(m_inst.guidProduct));
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceInstance8Object::getGuidFFDriver( BSTR __RPC_FAR *ret){
	*ret=DINPUTGUIDtoBSTR(&(m_inst.guidFFDriver));
	return S_OK;
}
        
        
//USES_CONVERSION;

STDMETHODIMP C_dxj_DIDeviceInstance8Object::getProductName( BSTR __RPC_FAR *ret){
	*ret=SysAllocString(m_inst.tszProductName);	//T2BSTR(m_inst.tszProductName);		
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceInstance8Object::getInstanceName( BSTR __RPC_FAR *ret){
	*ret=SysAllocString(m_inst.tszInstanceName);	//(m_inst.tszInstanceName);			
	return S_OK;
}

        

        
STDMETHODIMP C_dxj_DIDeviceInstance8Object::getUsagePage( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wUsagePage;
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceInstance8Object::getUsage( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wUsage;
	return S_OK;
}
        

STDMETHODIMP C_dxj_DIDeviceInstance8Object::getDevType( long __RPC_FAR *ret)
{
	*ret=(long)m_inst.dwDevType;
	return S_OK;
}        
        
C_dxj_DIDeviceInstance8Object::C_dxj_DIDeviceInstance8Object()
{	
	ZeroMemory(&m_inst,sizeof(DIDEVICEINSTANCEW));
}

void C_dxj_DIDeviceInstance8Object::init(DIDEVICEINSTANCEW *inst)
{
	memcpy(&m_inst,inst,sizeof(DIDEVICEINSTANCEW));
}



HRESULT C_dxj_DIDeviceInstance8Object::create(DIDEVICEINSTANCEW *inst,I_dxj_DirectInputDeviceInstance8 **ret)
{
	HRESULT hr;
	if (!ret) return E_INVALIDARG;

	C_dxj_DIDeviceInstance8Object *c=NULL;
	c=new CComObject<C_dxj_DIDeviceInstance8Object>;
	c->init(inst);

	if( c == NULL ) return E_FAIL;
	hr=c->QueryInterface(IID_I_dxj_DirectInputDeviceInstance8, (void**)ret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\d3dxtexvb.cpp ===
#include <windows.h>
#include <d3dx8tex.h>


DEFINE_GUID(g_GUIDDXVBLOCK, 0x5dd2e8da, 0x1c77, 0x4d40, 0xb0, 0xcf, 0x98, 0xfe, 0xfd, 0xff, 0x95, 0x12);


typedef struct _LOCKDATA {
	SAFEARRAY   *psaRealArray;
	BOOL	    bLocked;
	SAFEARRAY   *psaLockedArray;
} LOCKDATA;






HRESULT WINAPI DXLockArray8(IUnknown *resource, void *pBits,   SAFEARRAY **ppSafeArray)
{

		if (!resource) return E_INVALIDARG; 
		if (!ppSafeArray) return E_INVALIDARG;
		if (!*ppSafeArray) return E_INVALIDARG;

		
		
		LOCKDATA 		LockData;		//Structure we copy into resource
		HRESULT			hr;
		IDirect3DResource8 	*pResource=NULL;
		DWORD 			dwSize=sizeof(LOCKDATA);


		//See if we have a resource
		hr = resource->QueryInterface(IID_IDirect3DResource8,(void**)&pResource);
		if FAILED(hr) return E_INVALIDARG;	
		
		GUID g=g_GUIDDXVBLOCK;				//Guid to identify data in resource

		//See if there is any data in the resource
		ZeroMemory(&LockData,sizeof(LOCKDATA));		
		hr=pResource->GetPrivateData(g,&LockData,&dwSize);

		//if it was locked allready - we need to fail
		//and not lock it twice
		if (SUCCEEDED(hr) && (LockData.bLocked)){
			pResource->Release();
			return E_FAIL; 	//CONSIDER returning DDERR_LOCKEDSURFACES;
		}
		
		//SAVE the vb pointer to the safe array
		LockData.psaRealArray=*ppSafeArray;	//should be NULL

		//Set this flag to make sure we dont lock twice
		LockData.bLocked=TRUE;

		//Allocate our own new safe array
		LockData.psaLockedArray=(SAFEARRAY*)malloc(sizeof(SAFEARRAY));
		if (!LockData.psaLockedArray)
			return E_OUTOFMEMORY;

		ZeroMemory(LockData.psaLockedArray,sizeof(SAFEARRAY));


		memcpy(LockData.psaLockedArray,*ppSafeArray,sizeof(SAFEARRAY));
		LockData.psaLockedArray->pvData	= pBits;

		*ppSafeArray=LockData.psaLockedArray;
    
		hr=pResource->SetPrivateData(g,&LockData,dwSize,0);
		pResource->Release();


#if 0

		DWORD dwElemSize=0;
		D3DRESOURCETYPE resType=pResource->GetType();

		switch (resType)
		{
  		
		case D3DRESOURCETYPE_VERTEXBUFFER:


			LPDIRECT3DVERTEXBUFFER8 *pVertBuff=NULL;		


			//User must have created a 1d array
			if ((*ppSafeArray)->cbElements != 1) {
				pResource->Release();
				return E_INVALIDARG;
			}

			hr=pResource->QueryInterface(IID_IDirect3DVertexBuffer8,(void**)&pVertBuff);
			if FAILED(hr) {
				pResource->Release();
				return E_INVALIDARG;
			}

			D3DVERTEXBUFFER_DESC vbdesc =pVertBuff->GetVertexBufferDesc()
			dwElemSize=(*ppSafeArray)->cbElements;


			//Make sure our size is evenly divisible by the vertex format
			if ((vbdesc.Size %  dwElemSize) !=0) {
				pResource->Release();
				pVertBuff->Release();
				return E_INVALIDARG;
			}
			
			//Take Element size from our safearray
			LockData.psaLockedArray->cbElements =dwElemSize;
			LockData.psaLockedArray->cDims =1;
			LockData.psaLockedArray->rgsabound[0].lLbound =0;
			LockData.psaLockedArray->rgsabound[0].cElements = vdesc.Size / dwElemSize;
			LockData.psaLockedArray->pvData = pBits;

			pVertexBuffer->Release();
			break;

		case D3DRESOURCETYPE_INDEXBUFFER:


			LPDIRECT3DINDEXBUFFER8 *pIndBuff=NULL;		

			hr=pResource->QueryInterface(IID_IDirect3DIndexBuffer8,(void**)&pIndBuff);
			if FAILED(hr) {
				pResource->Release();
				return E_INVALIDARG;
			}


			D3DINDEXBUFFER_DESC ibdesc =pVertBuff->GetIndexBufferDesc()
			dwElemSize=(*ppSafeArray)->cbElements;

			//Make sure the created the right kind of array
			if ((ibdesc.Format==D3DFMT_INDEX_16)&&(dwElemSize!=2)){
				pResource->Release();
				pIndBuffer->Release();
				return E_INVALIDARG;
			}
			
			if ((ibdesc.Format==D3DFMT_INDEX_32)&&(dwElemSize!=4)){
				pResource->Release();
				pIndBuffer->Release();
				return E_INVALIDARG;
			}

			//User must have created a 1d array
			if ((*ppSafeArray)->cbElements != 1) {
				pResource->Release();
				pIndBuffer->Release();
				return E_INVALIDARG;
			}

			//Make sure our size is evenly divisible 
			if ((vbdesc.Size %  dwElemSize) !=0) {
				pResource->Release();
				pIndBuff->Release();
				return E_INVALIDARG;
			}
			
			//Take Element size from our safearray
			LockData.psaLockedArray->cbElements =dwElemSize;
			LockData.psaLockedArray->cDims =1;
			LockData.psaLockedArray->rgsabound[0].lLbound =0;
			LockData.psaLockedArray->rgsabound[0].cElements = vdesc.Size / dwElemSize;
			LockData.psaLockedArray->pvData = pBits;

			pIndBuffer->Release();
			break;
			


		}
#endif


		return hr;
}

HRESULT WINAPI DXUnlockArray8(IUnknown *resource,   SAFEARRAY **ppSafeArray)
{
		

		LOCKDATA 		LockData;		
		DWORD 			dwSize=sizeof(LOCKDATA);
		HRESULT			hr;
		LPDIRECT3DRESOURCE8 	pResource=NULL;

		if (!resource) return E_INVALIDARG; 
		if (!ppSafeArray) return E_INVALIDARG;
		if (!*ppSafeArray) return E_INVALIDARG;

		//See if we have a resource
		hr = resource->QueryInterface(IID_IDirect3DResource8,(void**)&pResource);
		if FAILED(hr) return E_INVALIDARG;	

		
		GUID g=g_GUIDDXVBLOCK;
		ZeroMemory(&LockData,sizeof(LOCKDATA));		
		hr=pResource->GetPrivateData(g,&LockData,&dwSize);
		if FAILED(hr) {
			pResource->Release();
			return E_FAIL;
		}

		if (!LockData.bLocked) {
			pResource->Release();
			return E_FAIL; //CONSIDER DDERR_LOCKEDSURFACES;
		}
				

		(*ppSafeArray)=LockData.psaRealArray;

		if (LockData.psaLockedArray) free(LockData.psaLockedArray);
		ZeroMemory(&LockData,sizeof(LOCKDATA));	
		hr=pResource->SetPrivateData(g,&LockData,dwSize,0);
		pResource->Release();

		return hr;
}


HRESULT WINAPI D3DVertexBuffer8SetData(IDirect3DVertexBuffer8 *pVBuffer,int offset, int size, DWORD flags, void *data)
{
		
 
		if (!pVBuffer) return E_INVALIDARG;

		HRESULT		hr;
		BYTE 		*pbData=NULL;

		hr=pVBuffer->Lock((UINT)offset,(UINT)size, &pbData,flags);
		if FAILED(hr) return hr;
		
		_try {
			memcpy ((void*)pbData,data,(DWORD)size);			
		}
		_except(1,1)
		{
			return E_INVALIDARG;
		}

		hr=pVBuffer->Unlock();

		return hr;
}


HRESULT WINAPI D3DVertexBuffer8GetData(IDirect3DVertexBuffer8 *pVBuffer,int offset,  int size, DWORD flags,void *data)
{
		
 
		if (!pVBuffer) return E_INVALIDARG;

		HRESULT		hr;
		BYTE 		*pbData=NULL;
		
		hr=pVBuffer->Lock((UINT)offset,(UINT)size, &pbData,flags);
		if FAILED(hr) return hr;
		
		_try {
			memcpy (data,(void*)pbData,(DWORD)size);			
		}
		_except(1,1)
		{
			return E_INVALIDARG;
		}

		hr=pVBuffer->Unlock();

		return hr;
}
	
		
		
HRESULT WINAPI D3DIndexBuffer8SetData(IDirect3DIndexBuffer8 *pIBuffer,int offset, int size,DWORD flags, void *data)
{
		
 
		if (!pIBuffer) return E_INVALIDARG;

		HRESULT		hr;
		BYTE 		*pbData=NULL;
		
		hr=pIBuffer->Lock((UINT)offset,(UINT)size, &pbData,flags);
		if FAILED(hr) return hr;
		
		_try {
			memcpy ((void*)pbData,data,(DWORD)size);			
		}
		_except(1,1)
		{
			return E_INVALIDARG;
		}

		hr=pIBuffer->Unlock();

		return hr;
}


HRESULT WINAPI D3DIndexBuffer8GetData(IDirect3DIndexBuffer8 *pIBuffer,int offset, int size,DWORD flags, void *data)
{
		
 
		if (!pIBuffer) return E_INVALIDARG;

		HRESULT		hr;
		BYTE 		*pbData=NULL;

		
		hr=pIBuffer->Lock((UINT)offset,(UINT)size, &pbData,flags);
		if FAILED(hr) return hr;
		
		_try {
			memcpy (data,(void*)pbData,(DWORD)size);		
		}
		_except(1,1)
		{
			return E_INVALIDARG;
		}

		hr=pIBuffer->Unlock();

		return hr;
}
	
//////////////////////////////////////////////////////////

HRESULT WINAPI D3DXMeshVertexBuffer8SetData(IUnknown *pObj,int offset, int size, DWORD flags, void *data)
{

		HRESULT			hr;
		BYTE 			*pbData=NULL;
		LPD3DXBASEMESH		pMesh=NULL;		
 		LPDIRECT3DVERTEXBUFFER8 pVBuffer=NULL;

		if (!pObj) return E_INVALIDARG;
		
		hr=pObj->QueryInterface(IID_ID3DXBaseMesh,(void**)&pMesh);
		if FAILED(hr) return E_INVALIDARG;

		hr=pMesh->GetVertexBuffer(&pVBuffer);
		pMesh->Release();
		if FAILED(hr) 	   return hr;			

		

	

		hr=pVBuffer->Lock((UINT)offset,(UINT)size, &pbData,flags);
		if FAILED(hr) return hr;
		
		_try {
			memcpy ((void*)pbData,data,(DWORD)size);		
		}
		_except(1,1)
		{
			pVBuffer->Release();
			return E_INVALIDARG;
		}

		hr=pVBuffer->Unlock();
		pVBuffer->Release();
		return hr;
}


HRESULT WINAPI D3DXMeshVertexBuffer8GetData(IUnknown *pObj,int offset,  int size, DWORD flags,void *data)
{
		HRESULT			hr;
		BYTE 			*pbData=NULL;
		LPD3DXBASEMESH		pMesh=NULL;		
 		LPDIRECT3DVERTEXBUFFER8 pVBuffer=NULL;

		if (!pObj) return E_INVALIDARG;
		
		hr=pObj->QueryInterface(IID_ID3DXBaseMesh,(void**)&pMesh);
		if FAILED(hr) return E_INVALIDARG;

		hr=pMesh->GetVertexBuffer(&pVBuffer);
		pMesh->Release();
		if FAILED(hr) 	   return hr;			

		
		
		hr=pVBuffer->Lock((UINT)offset,(UINT)size, &pbData,flags);
		if FAILED(hr) return hr;
		
		_try {
			memcpy (data,(void*)pbData,(DWORD)size);		
		}
		_except(1,1)
		{
			pVBuffer->Release();
			return E_INVALIDARG;
		}

		hr=pVBuffer->Unlock();

		pVBuffer->Release();
		return hr;
}
	

HRESULT WINAPI D3DXMeshIndexBuffer8SetData(IUnknown *pObj,int offset, int size, DWORD flags, void *data)
{

		HRESULT			hr;
		BYTE 			*pbData=NULL;
		LPD3DXBASEMESH		pMesh=NULL;		
 		LPDIRECT3DINDEXBUFFER8 	pIBuffer=NULL;

		if (!pObj) return E_INVALIDARG;
		
		hr=pObj->QueryInterface(IID_ID3DXBaseMesh,(void**)&pMesh);
		if FAILED(hr) return E_INVALIDARG;

		hr=pMesh->GetIndexBuffer(&pIBuffer);
		pMesh->Release();
		if FAILED(hr) 	   return hr;			


		
 		
		hr=pIBuffer->Lock((UINT)offset,(UINT)size, &pbData,flags);
		if FAILED(hr) return hr;
		
		_try {
			memcpy ((void*)pbData,data,(DWORD)size);	
		}
		_except(1,1)
		{
			pIBuffer->Release();
			return E_INVALIDARG;
		}

		hr=pIBuffer->Unlock();
		pIBuffer->Release();

		return hr;
}


HRESULT WINAPI D3DXMeshIndexBuffer8GetData(IUnknown *pObj,int offset, int size, DWORD flags, void *data)
{

		HRESULT			hr;
		BYTE 			*pbData=NULL;
		LPD3DXBASEMESH		pMesh=NULL;		
 		LPDIRECT3DINDEXBUFFER8 	pIBuffer=NULL;

		if (!pObj) return E_INVALIDARG;
		
		hr=pObj->QueryInterface(IID_ID3DXBaseMesh,(void**)&pMesh);
		if FAILED(hr) return E_INVALIDARG;

		hr=pMesh->GetIndexBuffer(&pIBuffer);
		pMesh->Release();
		if FAILED(hr) 	   return hr;			


		
		hr=pIBuffer->Lock((UINT)offset,(UINT)size, &pbData,flags);
		if FAILED(hr) return hr;
		
		_try {
			memcpy (data,(void*)pbData,(DWORD)size);
			//memcpy (data,(void*)&(pbData[offset]),(DWORD)size);
		}
		_except(1,1)
		{
			pIBuffer->Release();
			return E_INVALIDARG;
		}

		hr=pIBuffer->Unlock();
		pIBuffer->Release();

		return hr;
}


HRESULT WINAPI DXCopyMemory (void *Dest, void *Src, DWORD size)
{
	_try {
		memcpy (Dest,Src,size);
	}
	_except(1,1)
	{
		return E_INVALIDARG;
	}
	return S_OK;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\didevobjinstobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       didevobjinstobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "diDevObjInstObj.h"


extern BSTR GUIDtoBSTR(LPGUID g);

extern BSTR DINPUTGUIDtoBSTR(LPGUID g);


	
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getGuidType( BSTR __RPC_FAR *ret){
	*ret=DINPUTGUIDtoBSTR(&m_inst.guidType);
	return S_OK;
}

        
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getOfs(  long __RPC_FAR *ret){
	*ret=(long)m_inst.dwOfs;
	return S_OK;
}
        
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getType( long __RPC_FAR *ret)
{
	*ret=(long)m_inst.dwType;
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getFlags( long __RPC_FAR *ret)
{
	*ret=(long)m_inst.dwFlags;
	return S_OK;
}

//USES_CONVERSION;

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getName( BSTR __RPC_FAR *ret){
	*ret=SysAllocString(m_inst.tszName);	//T2BSTR(m_inst.tszName);		
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getCollectionNumber( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wCollectionNumber;
	return S_OK;
}
        

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getDesignatorIndex( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wDesignatorIndex;
	return S_OK;
}
        
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getUsagePage( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wUsagePage;
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getUsage( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wUsage;
	return S_OK;
}
        
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getExponent( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wExponent;
	return S_OK;
}


STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getDimension( long __RPC_FAR *ret)
{
	*ret=(long)m_inst.dwDimension;
	return S_OK;
}

        
        
C_dxj_DIDeviceObjectInstanceObject::C_dxj_DIDeviceObjectInstanceObject()
{	
	ZeroMemory(&m_inst,sizeof(DIDEVICEOBJECTINSTANCEW));
}

void C_dxj_DIDeviceObjectInstanceObject::init(DIDEVICEOBJECTINSTANCEW *inst)
{
	memcpy(&m_inst,inst,sizeof(DIDEVICEOBJECTINSTANCEW));
}

HRESULT C_dxj_DIDeviceObjectInstanceObject::create(DIDEVICEOBJECTINSTANCEW *inst,I_dxj_DirectInputDeviceObjectInstance **ret)
{
	HRESULT hr;
	if (!ret) return E_INVALIDARG;

	C_dxj_DIDeviceObjectInstanceObject *c=NULL;
	c=new CComObject<C_dxj_DIDeviceObjectInstanceObject>;
	if( c == NULL ) return E_FAIL;
	c->init(inst);
	hr=c->QueryInterface(IID_I_dxj_DirectInputDeviceObjectInstance, (void**)ret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\ddraw7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddraw7obj.cpp
//
//--------------------------------------------------------------------------

// dDrawObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dDraw7Obj.h"
#include "ddClipperObj.h"
#include "ddSurface7Obj.h"
#include "ddPaletteObj.h"
#include "ddEnumModesObj.h"
#include "ddEnumSurfacesObj.h"
#include "d3d7Obj.h"
#include "ddIdentifierObj.h"
					   

extern BOOL is4Bit;
extern HRESULT CopyInDDSurfaceDesc2(DDSURFACEDESC2 *,DDSurfaceDesc2*);
extern HRESULT CopyOutDDSurfaceDesc2(DDSurfaceDesc2*,DDSURFACEDESC2 *);


///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectDraw7Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DDraw7 [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectDraw7Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DDraw4 [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectDraw7Object
///////////////////////////////////////////////////////////////////
C_dxj_DirectDraw7Object::C_dxj_DirectDraw7Object(){ 
		
	DPF1(1,"Constructor Creation  DirectDraw7Object[%d] \n ",g_creationcount);

	m__dxj_DirectDraw7= NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectDraw7;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectDraw7 = (void *)this; 
	m_hwnd=NULL;
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectDraw7Object
///////////////////////////////////////////////////////////////////
C_dxj_DirectDraw7Object::~C_dxj_DirectDraw7Object()
{

	DPF(1,"Entering ~DirectDraw7Object destructor \n");

     C_dxj_DirectDraw7Object *prev=NULL; 
	for(C_dxj_DirectDraw7Object *ptr=(C_dxj_DirectDraw7Object *)g_dxj_DirectDraw7; ptr; ptr=(C_dxj_DirectDraw7Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectDraw7 = (void*)ptr->nextobj; 
			
			DPF(1,"DirectDraw7Object found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectDraw7){
		int count = IUNK(m__dxj_DirectDraw7)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectDraw7 Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectDraw7 = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}



///////////////////////////////////////////////////////////////////
// InternalGetObject
// InternalSetObject
// restoreDisplayMode
// flipToGDISurface
// setDisplayMode
///////////////////////////////////////////////////////////////////
GETSET_OBJECT(_dxj_DirectDraw7);
PASS_THROUGH_R(_dxj_DirectDraw7, restoreDisplayMode, RestoreDisplayMode)
PASS_THROUGH_R(_dxj_DirectDraw7, flipToGDISurface, FlipToGDISurface)
PASS_THROUGH5_R(_dxj_DirectDraw7, setDisplayMode, SetDisplayMode, long,long,long,long,long)


///////////////////////////////////////////////////////////////////
// getMonitorFrequency
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getMonitorFrequency(long *ret)
{
	HRESULT hr;
	hr=m__dxj_DirectDraw7->GetMonitorFrequency((DWORD*)ret);
	return hr;
}
														  


///////////////////////////////////////////////////////////////////
// getGDISurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getGDISurface(I_dxj_DirectDrawSurface7 **rv)
{ 
	
	LPDIRECTDRAWSURFACE7 lp4=NULL;	

	if ( is4Bit )
		return E_FAIL;

	*rv = NULL;
	HRESULT hr = DD_OK;

	if( ( hr=m__dxj_DirectDraw7->GetGDISurface(&lp4) ) != DD_OK) 
		return hr;
	 		
	INTERNAL_CREATE(_dxj_DirectDrawSurface7, lp4, rv);

	return hr; 
}

///////////////////////////////////////////////////////////////////
// getVerticalBlankStatus
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getVerticalBlankStatus( long *status)
{
	if ( is4Bit )
		return E_FAIL;

	return m__dxj_DirectDraw7->GetVerticalBlankStatus((int *)status);
}

///////////////////////////////////////////////////////////////////
// setCooperativeLevel
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::setCooperativeLevel( HWnd hwn, long flags)
{
	if ( is4Bit )
		return E_FAIL;

	m_hwnd = (HWND)hwn;

	return m__dxj_DirectDraw7->SetCooperativeLevel((HWND)hwn, (DWORD)flags);
}

///////////////////////////////////////////////////////////////////
// waitForVerticalBlank
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::waitForVerticalBlank(long flags,long handle, long *status)
{
	if ( is4Bit )
		return E_FAIL;

	*status = m__dxj_DirectDraw7->WaitForVerticalBlank(flags, (void *)handle);
	return S_OK;
}



///////////////////////////////////////////////////////////////////
// createClipper
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::createClipper(long flags, I_dxj_DirectDrawClipper **val)
{
	if ( is4Bit )
		return E_FAIL;

	DPF1(1,"enter DDraw4[%d]::createClipper ",creationid);

	//
	// need to create one of MY surfaces!
	//
	LPDIRECTDRAWCLIPPER		ddc;
	HRESULT hr = DD_OK;
	if( (hr=m__dxj_DirectDraw7->CreateClipper( flags, &ddc, NULL)) != DD_OK )
		return hr;

	INTERNAL_CREATE(_dxj_DirectDrawClipper, ddc, val);

	DPF1(1,"exit DDraw4[%d]::createClipper ",creationid);

	return hr;
}

///////////////////////////////////////////////////////////////////
// createPalette
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::createPalette(long flags, SAFEARRAY **pe, I_dxj_DirectDrawPalette **val)
{
	LPPALETTEENTRY ppe;
	
	if ( is4Bit )
		return E_FAIL;


	if (!ISSAFEARRAY1D(pe,(DWORD)256)) return E_INVALIDARG;

	ppe = (LPPALETTEENTRY)((SAFEARRAY*)*pe)->pvData;

	LPDIRECTDRAWPALETTE		ddp;
	HRESULT hr = DD_OK;
	
	*val = NULL;

	if( (hr=m__dxj_DirectDraw7->CreatePalette( flags, (LPPALETTEENTRY)ppe, &ddp, NULL)) == DD_OK )
	{
		INTERNAL_CREATE( _dxj_DirectDrawPalette, ddp, val);
	}

	return hr;
}

///////////////////////////////////////////////////////////////////
// createSurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::createSurface(DDSurfaceDesc2 *dd, I_dxj_DirectDrawSurface7 **retval)
{
	HRESULT retv;
	LPDIRECTDRAWSURFACE7	  dds7; // DirectX object pointer
	DDSURFACEDESC2			  ddsd;
	DPF1(1,"enter DDraw7[%d]::createSurface ",creationid);
	
	

	if ( is4Bit )
		return E_FAIL;

	if(! (dd && retval) )
		return E_POINTER;
		
	CopyInDDSurfaceDesc2(&ddsd,dd);

	//docdoc: CreateSurface returns error if 'punk' is anything but NULL
	retv = m__dxj_DirectDraw7->CreateSurface( &ddsd, &dds7, NULL);
	if FAILED(retv)	return retv;
	
	INTERNAL_CREATE(_dxj_DirectDrawSurface7, dds7, retval);

	dd->lpSurface = NULL;

	
	DPF1(1,"exit DDraw7[%d]::createSurface ",creationid);
	
	


	return S_OK;
}

///////////////////////////////////////////////////////////////////
// duplicateSurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::duplicateSurface(I_dxj_DirectDrawSurface7 *ddIn, I_dxj_DirectDrawSurface7 **ddOut)
{
	HRESULT retval;

	if ( is4Bit )
		return E_FAIL;

	//
	// need to create one of MY surfaces!
	//	
	LPDIRECTDRAWSURFACE7 lpddout7=NULL;


	DO_GETOBJECT_NOTNULL( LPDIRECTDRAWSURFACE7, lpddin, ddIn);

	if( (retval = m__dxj_DirectDraw7->DuplicateSurface(lpddin, &lpddout7)) != DD_OK )
		return retval;

	INTERNAL_CREATE( _dxj_DirectDrawSurface7, lpddout7, ddOut);

	return S_OK;
}

///////////////////////////////////////////////////////////////////
// getCaps
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getCaps(DDCaps *driverCaps,  DDCaps *HELcaps)
{
	if ( is4Bit )
		return E_FAIL;
	if (!driverCaps) return E_INVALIDARG;
	if (!HELcaps) return E_INVALIDARG;

	((DDCAPS*)driverCaps)->dwSize=sizeof(DDCAPS);
	((DDCAPS*)HELcaps)->dwSize=sizeof(DDCAPS);

	HRESULT hr = m__dxj_DirectDraw7->GetCaps((DDCAPS*)driverCaps, (DDCAPS*)HELcaps);

	return hr;
}

///////////////////////////////////////////////////////////////////
// getDisplayMode
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getDisplayMode(DDSurfaceDesc2 *desc)
{
	HRESULT retval;
	DDSURFACEDESC2 ddsd;

	if (!desc) return E_INVALIDARG;

	CopyInDDSurfaceDesc2(&ddsd,desc);

	retval = m__dxj_DirectDraw7->GetDisplayMode(&ddsd);

	if( retval != S_OK)		
		return retval;

	CopyOutDDSurfaceDesc2(desc,&ddsd);

	desc->lpSurface = NULL;

	return S_OK;
}

///////////////////////////////////////////////////////////////////
// getAvailableTotalMem
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getAvailableTotalMem(DDSCaps2 *ddsCaps, long *m)
{
	return m__dxj_DirectDraw7->GetAvailableVidMem((LPDDSCAPS2)ddsCaps, (unsigned long *)m, NULL);
}

///////////////////////////////////////////////////////////////////
// getFreeMem
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getFreeMem(DDSCaps2 *ddsCaps, long *m)
{
	return m__dxj_DirectDraw7->GetAvailableVidMem((LPDDSCAPS2)ddsCaps, NULL, (unsigned long *)m);
}


///////////////////////////////////////////////////////////////////
// getDirect3D
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getDirect3D(I_dxj_Direct3d7 **retval)
{
    LPDIRECT3D7 lpD3D;
	HRESULT hr = DD_OK;

	if ( is4Bit )
		return E_FAIL;

    if( (hr=m__dxj_DirectDraw7->QueryInterface(IID_IDirect3D7, (void**) &lpD3D)) != DD_OK)
		return hr;

  	INTERNAL_CREATE(_dxj_Direct3d7, lpD3D, retval);

	return hr;
}

///////////////////////////////////////////////////////////////////
// getNumFourCCCodes
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getNumFourCCCodes(long *retval)
{
    return m__dxj_DirectDraw7->GetFourCCCodes((DWORD*)retval, NULL);
}


///////////////////////////////////////////////////////////////////
// getScanLine
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getScanLine(long *lines, long *status)
{ 
	*status = (long)m__dxj_DirectDraw7->GetScanLine((DWORD*)lines);
	return S_OK;
}

///////////////////////////////////////////////////////////////////
// loadPaletteFromBitmap
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::loadPaletteFromBitmap(BSTR bName, I_dxj_DirectDrawPalette **retval)
{
	USES_CONVERSION;
    IDirectDrawPalette* ddpal;
    int                 i;
    int                 n;
    int                 fh;
    HRSRC               h;
    LPBITMAPINFOHEADER  lpbi;
    PALETTEENTRY        ape[256];
    RGBQUAD *           prgb;
	

	HRESULT hr=S_OK;

	if ( is4Bit )
		return E_FAIL;

	LPCTSTR szBitmap = W2T(bName);
	


    for (i=0; i<256; i++)		// build a 332 palette as the default
    {
        ape[i].peRed   = (BYTE)(((i >> 5) & 0x07) * 255 / 7);
        ape[i].peGreen = (BYTE)(((i >> 2) & 0x07) * 255 / 7);
        ape[i].peBlue  = (BYTE)(((i >> 0) & 0x03) * 255 / 3);
        ape[i].peFlags = (BYTE)0;
    }

    //
    // get a pointer to the bitmap resource.
    //
    if (szBitmap && (h = FindResource(NULL, szBitmap, RT_BITMAP)))
    {
        lpbi = (LPBITMAPINFOHEADER)LockResource(LoadResource(NULL, h));
        if (!lpbi){
		DPF(1,"lock resource failed\n");
	}
        prgb = (RGBQUAD*)((BYTE*)lpbi + lpbi->biSize);

        if (lpbi == NULL || lpbi->biSize < sizeof(BITMAPINFOHEADER))
            n = 0;
        else if (lpbi->biBitCount > 8)
            n = 0;
        else if (lpbi->biClrUsed == 0)
            n = 1 << lpbi->biBitCount;
        else
            n = lpbi->biClrUsed;

        //
        //  a DIB color table has its colors stored BGR not RGB
        //  so flip them around.
        //
        for(i=0; i<n; i++ )
        {
            ape[i].peRed   = prgb[i].rgbRed;
            ape[i].peGreen = prgb[i].rgbGreen;
            ape[i].peBlue  = prgb[i].rgbBlue;
            ape[i].peFlags = 0;
        }
    }
    else if (szBitmap && (fh = _lopen(szBitmap, OF_READ)) != -1)
    {
        BITMAPFILEHEADER bf;
        BITMAPINFOHEADER bi;

        _lread(fh, &bf, sizeof(bf));
        _lread(fh, &bi, sizeof(bi));
        _lread(fh, ape, sizeof(ape));
        _lclose(fh);

        if (bi.biSize != sizeof(BITMAPINFOHEADER))
            n = 0;
        else if (bi.biBitCount > 8)
            n = 0;
        else if (bi.biClrUsed == 0)
            n = 1 << bi.biBitCount;
        else
            n = bi.biClrUsed;

        //
        //  a DIB color table has its colors stored BGR not RGB
        //  so flip them around.
        //
        for(i=0; i<n; i++ )
        {
            BYTE r = ape[i].peRed;
            ape[i].peRed  = ape[i].peBlue;
            ape[i].peBlue = r;
        }
    }

    m__dxj_DirectDraw7->CreatePalette(DDPCAPS_8BIT, ape, &ddpal, NULL);

	if( ddpal )
	{
		INTERNAL_CREATE(_dxj_DirectDrawPalette, ddpal, retval);
	}
	else
	{
		//
		// no object, set the return value to NULL as well.
		//
		*retval = NULL;
		hr = E_FAIL;
	}

    return hr;
}


///////////////////////////////////////////////////////////////////
// createSurfaceFromFile
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::createSurfaceFromFile(BSTR file, DDSurfaceDesc2 *desc, I_dxj_DirectDrawSurface7 **surf)
{

	DPF1(1,"enter DDraw7[%d]::createSurfaceFromFile ",creationid);


	HDC							hdc;
	HDC							hdcImage;
    BITMAP						bm;
    HRESULT						hr;
	HBITMAP						hbm;
	HRESULT						retv;
	LPDIRECTDRAWSURFACE7		dds7; // DirectX object pointer	
	LPSTR						szFileName=NULL;
    int							width=0;
    int							height=0;


	if ( is4Bit )
		return E_FAIL;

	if(! (desc && surf) )
		return E_POINTER;
	
	
	USES_CONVERSION;
	szFileName=W2T(file);

	
	


	//If width and height are zero then we will generate our own width and
	//height from the bitmap.
	//The LoadImage api however doesnt work propery without size params
	//Consider there must be a way to make it work.
	if ((desc->lWidth!=0)&&(desc->lHeight!=0)&&(desc->lFlags & DDSD_WIDTH)&&(desc->lFlags & DDSD_HEIGHT))
	{
		width=desc->lWidth ;
		height=desc->lHeight; 
	}

	if (desc->lFlags==0) {
		desc->lFlags=DDSD_CAPS;
		((DDSURFACEDESC*)desc)->ddsCaps.dwCaps=DDSCAPS_OFFSCREENPLAIN;
	}
	
    //hbm = (HBITMAP)LoadImageW((HINSTANCE)NULL, file, IMAGE_BITMAP, 
	//				width, height, 
	//				LR_LOADFROMFILE|LR_CREATEDIBSECTION);

	hbm = (HBITMAP)LoadImage((HINSTANCE)NULL, szFileName, IMAGE_BITMAP, 
				width, height, 
					LR_LOADFROMFILE|LR_CREATEDIBSECTION);

	DWORD dwErr=GetLastError();		
	if (!hbm){
		
		//often users pass in width and height in twips and not pixels
		//loadimage compails and returns  ERROR_NOT_ENOUGH_MEMORY		
		

		if (dwErr==ERROR_NOT_ENOUGH_MEMORY)
		{
			return E_OUTOFMEMORY;
		}
		else if (dwErr==ERROR_INVALID_PARAMETER)
		{
			return E_INVALIDARG;
		}
		else {
			return CTL_E_FILENOTFOUND;
		}
	}

	// get size of the bitmap
    //	
	GetObject(hbm, sizeof(bm), &bm);      // get size of bitmap
	width=bm.bmWidth;
	height=bm.bmHeight; 
	desc->lFlags = desc->lFlags | DDSD_WIDTH | DDSD_HEIGHT;

	if ((desc->lWidth==0)||(desc->lHeight==0))
	{
		desc->lWidth  =width;
		desc->lHeight =height; 
	}

	DDSURFACEDESC2 ddsd;
	CopyInDDSurfaceDesc2(&ddsd,desc);
	
	if( (retv = m__dxj_DirectDraw7->CreateSurface(&ddsd, &dds7, NULL)) != DD_OK )
		return retv;

	CopyOutDDSurfaceDesc2(desc,&ddsd);


	INTERNAL_CREATE(_dxj_DirectDrawSurface7, dds7, surf);


	desc->lpSurface = NULL;

    //
    // make sure this surface is restored.
    //
     dds7->Restore();

    //
    //  select bitmap into a memoryDC so we can use it.
    //
    hdcImage = CreateCompatibleDC(NULL);

	SelectObject(hdcImage, hbm);		

    if (!hdcImage){
		DeleteObject(hbm);
		return E_FAIL;
	}
	

    if ((hr = dds7->GetDC(&hdc)) == DD_OK)
    {
        StretchBlt(hdc, 0, 0, desc->lWidth , desc->lHeight, hdcImage,
						 0, 0, width, height, SRCCOPY);
        
        dds7->ReleaseDC(hdc);
    }

    DeleteDC(hdcImage);

	if (hbm) DeleteObject(hbm);

	
	DPF1(buffer,"exit DDraw7[%d]::createSurfaceFromFile",creationid);	

	return S_OK;
}


///////////////////////////////////////////////////////////////////
// createSurfaceFromResource
///////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectDraw7Object::createSurfaceFromResource(BSTR resFile, BSTR resourceName, DDSurfaceDesc2 *desc, I_dxj_DirectDrawSurface7 **surf)
{

	DPF1(1,"enter DDraw4[%d]::createSurfaceFromResource ",creationid);

	if ( is4Bit )
		return E_FAIL;

	if(! (desc && surf) )
		return E_POINTER;


	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;

	HDC							hdc;
	HDC							hdcImage;
    BITMAP						bm;
	HBITMAP						hbm;
	HRESULT						retv;		
	LPDIRECTDRAWSURFACE7		dds7; // DirectX object pointer	
	LPSTR						szResName=NULL;

	if (!resourceName)	return E_INVALIDARG;
	if (!surf)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	
	USES_CONVERSION;
		
	if  ((resFile) &&(resFile[0]!=0)){
		// NOTE:
		// seems that GetModuleHandleW is
		// always returning 0 on w98
		// converting to ansi first
		 LPCTSTR pszName = W2T(resFile);
		 hMod= GetModuleHandle(pszName);
	}
	else {
		hMod= GetModuleHandle(NULL);
	}


	
	LPCTSTR pszName2 = W2T(resourceName);

    //hbm = (HBITMAP)LoadImageW((HINSTANCE)hMod, resourceName, 
	//				IMAGE_BITMAP, 
	//				0, 0, 
	//				LR_CREATEDIBSECTION);
	

    hbm = (HBITMAP)LoadImage((HINSTANCE)hMod, 
					pszName2, 
					IMAGE_BITMAP, 
					0, 0, 
					LR_CREATEDIBSECTION);


	if (!hbm){
		//MessageBox(NULL,"FAILED ON LOAD IMAGE","TEST",MB_OK);
		return E_FAIL;
	}


	// get size of the bitmap
    //	
	GetObject(hbm, sizeof(bm), &bm);      // get size of bitmap
	DWORD width=bm.bmWidth;
	DWORD height=bm.bmHeight; 
	desc->lFlags = desc->lFlags | DDSD_WIDTH | DDSD_HEIGHT;

	if ((desc->lWidth==0)||(desc->lHeight==0))
	{
		desc->lWidth  =width;
		desc->lHeight =height; 
	}

	DDSURFACEDESC2 ddsd;
	CopyInDDSurfaceDesc2(&ddsd,desc);
	
	if( (retv = m__dxj_DirectDraw7->CreateSurface(&ddsd, &dds7, NULL)) != DD_OK )
		return retv;

	CopyOutDDSurfaceDesc2(desc,&ddsd);


	INTERNAL_CREATE(_dxj_DirectDrawSurface7, dds7, surf);


	desc->lpSurface = NULL;

    //
    // make sure this surface is restored.
    //
    dds7->Restore();

    //
    //  select bitmap into a memoryDC so we can use it.
    //
    hdcImage = CreateCompatibleDC(NULL);

	SelectObject(hdcImage, hbm);		

    if (!hdcImage){
		DeleteObject(hbm);
		return E_FAIL;
	}
	

    if ((hr = dds7->GetDC(&hdc)) == DD_OK)
    {
        StretchBlt(hdc, 0, 0, desc->lWidth , desc->lHeight, hdcImage,
						 0, 0, width, height, SRCCOPY);
        
        dds7->ReleaseDC(hdc);
    }

    DeleteDC(hdcImage);

	if (hbm) DeleteObject(hbm);

	
	DPF1(1r,"exit DDraw4[%d]::createSurfaceFromFile",creationid);
	

	return S_OK;
}


///////////////////////////////////////////////////////////////////
// getFourCCCodes
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getFourCCCodes(SAFEARRAY **ppsa)
{
	DWORD count= ((SAFEARRAY*)*ppsa)->rgsabound[0].cElements;
	if ( ((SAFEARRAY*)*ppsa)->cDims!=1) return E_INVALIDARG;

    return m__dxj_DirectDraw7->GetFourCCCodes(&count,(DWORD*)((SAFEARRAY*)*ppsa)->pvData);

}

///////////////////////////////////////////////////////////////////
// getDisplayModesEnum
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getDisplayModesEnum( 
            /* [in] */ long flags,
            /* [in] */ DDSurfaceDesc2 *ddsd,
            /* [retval][out] */ I_dxj_DirectDrawEnumModes __RPC_FAR *__RPC_FAR *retval)
{
	HRESULT hr;	
	hr=C_dxj_DirectDrawEnumModesObject::create(m__dxj_DirectDraw7,flags, ddsd,  retval);
	return hr;	
}

///////////////////////////////////////////////////////////////////
// testCooperativeLevel
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::testCooperativeLevel( 
            /* [in,out] */ long *status)
{
	HRESULT hr;	
	hr=m__dxj_DirectDraw7->TestCooperativeLevel();
	*status=(long)hr;
	return S_OK;	
}

///////////////////////////////////////////////////////////////////
// restoreAllSurfaces
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::restoreAllSurfaces()
{
	HRESULT hr;	
	hr=m__dxj_DirectDraw7->RestoreAllSurfaces();
	return hr;	
}

STDMETHODIMP C_dxj_DirectDraw7Object::getSurfaceFromDC(long hdc, I_dxj_DirectDrawSurface7 **ret)
{
	HRESULT hr;	
	LPDIRECTDRAWSURFACE7 pDDS=NULL;
	hr=m__dxj_DirectDraw7->GetSurfaceFromDC((HDC)hdc,&pDDS);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_DirectDrawSurface7,pDDS,ret);
	return hr;	
}




STDMETHODIMP C_dxj_DirectDraw7Object::getSurfacesEnum( 
            /* [in] */ long flags,
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *desc,
            /* [retval][out] */ I_dxj_DirectDrawEnumSurfaces __RPC_FAR *__RPC_FAR *ret)  
 
{
	HRESULT hr=C_dxj_DirectDrawEnumSurfacesObject::create((I_dxj_DirectDraw7*)this , flags, desc,ret);
	return hr;
}


STDMETHODIMP C_dxj_DirectDraw7Object::getDeviceIdentifier( 
             long flags,I_dxj_DirectDrawIdentifier **ret) 
{
	HRESULT hr;				
	hr=C_dxj_DirectDrawIdentifierObject::Create(m__dxj_DirectDraw7,(DWORD)flags,ret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\didevinstobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       didevinstobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DIDeviceInstance8Object :
		public I_dxj_DirectInputDeviceInstance8,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DIDeviceInstance8Object)
		COM_INTERFACE_ENTRY(I_dxj_DirectInputDeviceInstance8)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DIDeviceInstance8Object)

public:
	C_dxj_DIDeviceInstance8Object();	
  

        /* [propget] */ HRESULT STDMETHODCALLTYPE getGuidInstance( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getGuidProduct( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
		/* [propget] */ HRESULT STDMETHODCALLTYPE getProductName( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getInstanceName( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getGuidFFDriver( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getUsagePage( 
            /* [retval][out] */ short __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getUsage( 
            /* [retval][out] */ short __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getDevType( 
            /* [retval][out] */ long __RPC_FAR *ret);


		void init(DIDEVICEINSTANCEW *inst);
		static HRESULT C_dxj_DIDeviceInstance8Object::create(DIDEVICEINSTANCEW  *inst,I_dxj_DirectInputDeviceInstance8 **ret);


private:
		DIDEVICEINSTANCEW m_inst;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\didevobjinstobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       didevobjinstobj.h
//
//--------------------------------------------------------------------------


#include "resource.h"

class C_dxj_DIDeviceObjectInstanceObject :
		public I_dxj_DirectInputDeviceObjectInstance,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DIDeviceObjectInstanceObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectInputDeviceObjectInstance)
	END_COM_MAP()


	DECLARE_AGGREGATABLE(C_dxj_DIDeviceObjectInstanceObject)

public:
	C_dxj_DIDeviceObjectInstanceObject();	


	/* [propget] */ HRESULT STDMETHODCALLTYPE getGuidType( 
		/* [retval][out] */ BSTR __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getOfs( 
		/* [retval][out] */ long __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getType( 
		/* [retval][out] */ long __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getFlags( 
		/* [retval][out] */ long __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getName( 
		/* [retval][out] */ BSTR __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getCollectionNumber( 
		/* [retval][out] */ short __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getDesignatorIndex( 
		/* [retval][out] */ short __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getUsagePage( 
		/* [retval][out] */ short __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getUsage( 
		/* [retval][out] */ short __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getDimension( 
		/* [retval][out] */ long __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getExponent( 
		/* [retval][out] */ short __RPC_FAR *ret);

  
		static HRESULT C_dxj_DIDeviceObjectInstanceObject::create(DIDEVICEOBJECTINSTANCEW *inst,I_dxj_DirectInputDeviceObjectInstance **ret);

		void init(DIDEVICEOBJECTINSTANCEW *inst);
private:
		DIDEVICEOBJECTINSTANCEW m_inst;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dienumdeviceobjectsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dienumdeviceobjectsobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DIEnumDeviceObjectsObj.h"
#include "didevObjInstOBj.h"

extern BSTR DINPUTGUIDtoBSTR(LPGUID pGuid);


extern "C" BOOL CALLBACK DIEnumDeviceObjectsProc(
  LPCDIDEVICEOBJECTINSTANCEW lpddoi,  
  LPVOID lpArg                       
  )
{
 
	if (!lpddoi) return FALSE;

	C_dxj_DIEnumDeviceObjectsObject *pObj=(C_dxj_DIEnumDeviceObjectsObject*)lpArg;
	if (pObj==NULL) return FALSE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if (pObj->m_pList){
			void* tmp = realloc(pObj->m_pList,sizeof(DIDEVICEOBJECTINSTANCEW)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DIDEVICEOBJECTINSTANCEW *)tmp;
			else
				return FALSE;
		}
		else {
			pObj->m_pList=(DIDEVICEOBJECTINSTANCEW *)malloc(sizeof(DIDEVICEOBJECTINSTANCEW)* pObj->m_nMax);
		}

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),lpddoi,sizeof(DIDEVICEOBJECTINSTANCEW));
	

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DIEnumDeviceObjectsObject::C_dxj_DIEnumDeviceObjectsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DIEnumDeviceObjectsObject::~C_dxj_DIEnumDeviceObjectsObject()
{
	//empty list
	if (m_pList) free(m_pList);

}
		

HRESULT C_dxj_DIEnumDeviceObjectsObject::create(LPDIRECTINPUTDEVICE8W pDI,  long flags,I_dxj_DIEnumDeviceObjects **ppRet)
{
	HRESULT hr;
	C_dxj_DIEnumDeviceObjectsObject *pNew=NULL;


	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DIEnumDeviceObjectsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;


  	hr = pDI->EnumObjects(
		(LPDIENUMDEVICEOBJECTSCALLBACKW)DIEnumDeviceObjectsProc,
		(void*)pNew,
		(DWORD) flags);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		if (pNew->m_pList) free(pNew->m_pList);
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DIEnumDeviceObjects,(void**)ppRet);
	return hr;
}



HRESULT C_dxj_DIEnumDeviceObjectsObject::getItem( long index, I_dxj_DirectInputDeviceObjectInstance **ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	DIDEVICEOBJECTINSTANCEW *inst=&m_pList[index-1];

	if (!inst) return E_INVALIDARG;

	HRESULT hr;
	hr=C_dxj_DIDeviceObjectInstanceObject::create(inst,ret);
	return hr;
}

HRESULT C_dxj_DIEnumDeviceObjectsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dienumdeviceobjectsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dienumdeviceobjectsobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DIEnumDeviceObjectsObject : 
	public I_dxj_DIEnumDeviceObjects,
	public CComObjectRoot
{
public:
	C_dxj_DIEnumDeviceObjectsObject() ;
	virtual ~C_dxj_DIEnumDeviceObjectsObject() ;

BEGIN_COM_MAP(C_dxj_DIEnumDeviceObjectsObject)
	COM_INTERFACE_ENTRY(I_dxj_DIEnumDeviceObjects)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DIEnumDeviceObjectsObject)


public:
        HRESULT STDMETHODCALLTYPE getItem( 
            /* [in] */ long index,
            /* [out][in] */ I_dxj_DirectInputDeviceObjectInstance __RPC_FAR **info);
        
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);
		
				
		static HRESULT C_dxj_DIEnumDeviceObjectsObject::create(LPDIRECTINPUTDEVICE8W pDI,  long flags,I_dxj_DIEnumDeviceObjects **ppRet);
public:
		DIDEVICEOBJECTINSTANCEW *m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dienumdevicesobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dienumdevicesobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DIEnumDevicesObject : 
	public I_dxj_DIEnumDevices8,
	public CComObjectRoot
{
public:
	C_dxj_DIEnumDevicesObject() ;
	virtual ~C_dxj_DIEnumDevicesObject() ;

BEGIN_COM_MAP(C_dxj_DIEnumDevicesObject)
	COM_INTERFACE_ENTRY(I_dxj_DIEnumDevices8)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DIEnumDevicesObject)

public:

        HRESULT STDMETHODCALLTYPE getItem( long index, I_dxj_DirectInputDeviceInstance8 **ret);
        HRESULT STDMETHODCALLTYPE getCount( long __RPC_FAR *count);
		
		
		static HRESULT C_dxj_DIEnumDevicesObject::create(LPDIRECTINPUT8W pDI,long deviceType, long flags,I_dxj_DIEnumDevices8 **ppRet)	;
    	static HRESULT C_dxj_DIEnumDevicesObject::createSuitable(LPDIRECTINPUT8W pDI,BSTR str1, DIACTIONFORMAT_CDESC *format, long actionCount,SAFEARRAY **actionArray,long flags, I_dxj_DIEnumDevices8 **ppRet);
			   
public:
		DIDEVICEINSTANCEW *m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dienumdevicesobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dienumdevicesobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dIEnumDevicesObj.h"
#include "diDevInstObj.h"

extern BSTR DINPUTGUIDtoBSTR(LPGUID pGuid);
extern  HRESULT DINPUTBSTRtoGUID(LPGUID pGuid,BSTR bstr);
extern HRESULT FillRealActionFormat(DIACTIONFORMATW *real, DIACTIONFORMAT_CDESC *cover, SAFEARRAY **actionArray,long ActionCount );

//dienumdevicesobj.cpp(105) : error C2664: 'EnumDevicesBySemantics' : cannot convert parameter 3 from 
//'int (struct DIDEVICEINSTANCEW *const ,struct IDirectInputDevice8W *,unsigned long,unsigned long,void *)' to 
//              'int (__stdcall *)(const struct DIDEVICEINSTANCEW *,struct IDirectInputDevice8W *,unsigned long,unsigned long,void *)'

//CALLBACK
/////////////////////////////////////////////////////////////////////////////
//extern "C" 
BOOL _stdcall objEnumInputDevicesCallback(
  const struct DIDEVICEINSTANCEW * lpddi,  
  //IDirectInputDevice8W *pDev,
  //unsigned long UnknownVar1,
  //unsigned long UnknownVar2,
  LPVOID lpArg               
  )
{

	DPF(1,"Entered objEnumInputDevicesCallback\r\n");

	if (!lpddi) return FALSE;

	C_dxj_DIEnumDevicesObject *pObj=(C_dxj_DIEnumDevicesObject*)lpArg;
	if (pObj==NULL) return FALSE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList){
			void* tmp = realloc(pObj->m_pList,sizeof(DIDEVICEINSTANCEW)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DIDEVICEINSTANCEW*)tmp;
			else
				return FALSE;
		}
		else {
			pObj->m_pList=(DIDEVICEINSTANCEW*)malloc(   sizeof(DIDEVICEINSTANCEW)* pObj->m_nMax);
		}
		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),lpddi,sizeof(DIDEVICEINSTANCEW));
	

	pObj->m_nCount++;
	
	return TRUE;
}


BOOL _stdcall objEnumInputDevicesBySemanticsCallback(
  const struct DIDEVICEINSTANCEW * lpddi,  
  IDirectInputDevice8W *pDev,
  unsigned long UnknownVar1,
  unsigned long UnknownVar2,
  LPVOID lpArg               
  )
{

	DPF(1,"Entered objEnumInputDevicesCallback\r\n");

	if (!lpddi) return FALSE;

	C_dxj_DIEnumDevicesObject *pObj=(C_dxj_DIEnumDevicesObject*)lpArg;
	if (pObj==NULL) return FALSE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList){
			void* tmp = realloc(pObj->m_pList,sizeof(DIDEVICEINSTANCEW)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DIDEVICEINSTANCEW*)tmp;
			else
				return FALSE;
		}
		else {
			pObj->m_pList=(DIDEVICEINSTANCEW*)malloc(   sizeof(DIDEVICEINSTANCEW)* pObj->m_nMax);
		}
		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),lpddi,sizeof(DIDEVICEINSTANCEW));
	

	pObj->m_nCount++;
	
	return TRUE;
}

C_dxj_DIEnumDevicesObject::C_dxj_DIEnumDevicesObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DIEnumDevicesObject::~C_dxj_DIEnumDevicesObject()
{
	//empty list
	if (m_pList) free(m_pList);

}


HRESULT C_dxj_DIEnumDevicesObject::createSuitable(LPDIRECTINPUT8W pDI,BSTR str1, DIACTIONFORMAT_CDESC *format, long actionCount,SAFEARRAY **actionArray,long flags, I_dxj_DIEnumDevices8 **ppRet)
{

	HRESULT hr;
	DIACTIONFORMATW frmt;

	C_dxj_DIEnumDevicesObject *pNew=NULL;


	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DIEnumDevicesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;


	hr=FillRealActionFormat(&frmt, format, actionArray,actionCount );
	if FAILED(hr) return hr;


	hr=pDI->EnumDevicesBySemantics((LPWSTR)str1,&frmt, objEnumInputDevicesBySemanticsCallback,pNew,(DWORD)flags);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;


	if FAILED(hr) 
	{
	
		if (pNew->m_pList) free(pNew->m_pList);
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DIEnumDevices8,(void**)ppRet);

	return hr;
}


HRESULT C_dxj_DIEnumDevicesObject::create(LPDIRECTINPUT8W pDI,long deviceType, long flags,I_dxj_DIEnumDevices8 **ppRet)
{
	HRESULT hr;
	C_dxj_DIEnumDevicesObject *pNew=NULL;


	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DIEnumDevicesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;


  	hr = pDI->EnumDevices((DWORD)deviceType, 
			objEnumInputDevicesCallback,
		(void*)pNew,
		(DWORD) flags);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		if (pNew->m_pList) free(pNew->m_pList);
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DIEnumDevices8,(void**)ppRet);
	return hr;
}



HRESULT C_dxj_DIEnumDevicesObject::getItem( long index, I_dxj_DirectInputDeviceInstance8 **ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	HRESULT hr;
	
	hr=C_dxj_DIDeviceInstance8Object::create(&m_pList[index-1],ret);		
	return hr;
}


HRESULT C_dxj_DIEnumDevicesObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dienumeffectsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dienumeffectsobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DirectInputEnumEffectsObject : 
	public I_dxj_DirectInputEnumEffects,
	public CComObjectRoot
{
public:
	C_dxj_DirectInputEnumEffectsObject() ;
	virtual ~C_dxj_DirectInputEnumEffectsObject() ;

BEGIN_COM_MAP(C_dxj_DirectInputEnumEffectsObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectInputEnumEffects)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectInputEnumEffectsObject)

public:

         HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getEffectGuid( 
            /* [in] */ long i,
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ long i,
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getStaticParams( 
            /* [in] */ long i,
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getDynamicParams( 
            /* [in] */ long i,
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long i,
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
		
		static HRESULT C_dxj_DirectInputEnumEffectsObject::create(LPDIRECTINPUTDEVICE8W pDI,long effType,I_dxj_DirectInputEnumEffects **ppRet)	;

public:
		DIEFFECTINFOW  *m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dienumeffectsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dienumeffectsobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dIEnumEffectsObj.h"


extern BSTR DINPUTGUIDtoBSTR(LPGUID pGuid);
extern  HRESULT DINPUTBSTRtoGUID(LPGUID pGuid,BSTR bstr);



////////////////////////////////////////////////////////////////////////////

/*extern "C"*/ BOOL CALLBACK  objEnumInputEffectsCallback(
  LPCDIEFFECTINFOW pdei,  
  LPVOID lpArg           
  )
{

	DPF(1,"Entered objEnumInputEffectsCallback\r\n");

	if (!pdei) return FALSE;

	C_dxj_DirectInputEnumEffectsObject *pObj=(C_dxj_DirectInputEnumEffectsObject*)lpArg;
	if (pObj==NULL) return FALSE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList){
			void* tmp = realloc(pObj->m_pList,sizeof(DIEFFECTINFOW)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DIEFFECTINFOW*)tmp;
			else
				return FALSE;
		}
		else {
			pObj->m_pList=(DIEFFECTINFOW*)malloc(   sizeof(DIEFFECTINFOW)* pObj->m_nMax);
		}
		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),pdei,sizeof(DIEFFECTINFOW));
	
	DPF1(1,"objEnumInputEffects '%s'\n",pdei->tszName);

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DirectInputEnumEffectsObject::C_dxj_DirectInputEnumEffectsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DirectInputEnumEffectsObject::~C_dxj_DirectInputEnumEffectsObject()
{
	//empty list
	if (m_pList) free(m_pList);

}


HRESULT C_dxj_DirectInputEnumEffectsObject::create(LPDIRECTINPUTDEVICE8W pDI,long effectType,I_dxj_DirectInputEnumEffects **ppRet)
{
	HRESULT hr;
	C_dxj_DirectInputEnumEffectsObject *pNew=NULL;


	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DirectInputEnumEffectsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;


  	hr = pDI->EnumEffects(
		objEnumInputEffectsCallback,
		(void*)pNew,
		(DWORD) effectType);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		if (pNew->m_pList) free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DirectInputEnumEffects,(void**)ppRet);
	return hr;
}



HRESULT C_dxj_DirectInputEnumEffectsObject::getEffectGuid( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	*ret=DINPUTGUIDtoBSTR(&(m_pList[index-1].guid));
		
	return S_OK;
}



HRESULT C_dxj_DirectInputEnumEffectsObject::getName( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	USES_CONVERSION;

	*ret=SysAllocString(m_pList[index-1].tszName); //T2BSTR(m_pList[index-1].tszName);
		
	return S_OK;
}

HRESULT C_dxj_DirectInputEnumEffectsObject::getType( long index, long *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	

	*ret=(long)m_pList[index-1].dwEffType;
		
	return S_OK;
}


HRESULT C_dxj_DirectInputEnumEffectsObject::getStaticParams( long index, long *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	

	*ret=(long)m_pList[index-1].dwStaticParams;
		
	return S_OK;
}

HRESULT C_dxj_DirectInputEnumEffectsObject::getDynamicParams( long index, long *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	

	*ret=(long)m_pList[index-1].dwDynamicParams;
		
	return S_OK;
}

HRESULT C_dxj_DirectInputEnumEffectsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\directinput.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       directinput.cpp
//
//--------------------------------------------------------------------------

// dInputDevice.cpp : Implementation of dInputDevice and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DirectInput.h"

CONSTRUCTOR(dInputDevice, {});
DESTRUCTOR(dInputDevice, {});
GETSET_OBJECT(dInputDevice);

/////////////////////////////////////////////////////////////////////////////
// Direct Input Device Object 
//

#ifdef USING_IDISPATCH
STDMETHODIMP dInputDevice::InterfaceSupportsErrorInfo(REFIID riid)
{
	if (riid == IID_IdInputDevice)
		return S_OK;
	return S_FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\directinput.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       directinput.h
//
//--------------------------------------------------------------------------

// DiectInput.h : Declaration of the dInputDevice

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// Input Device Ojbect

#define typedef_dInputDevice LPDIRECTINPUTDEVICE

class CdInputDeviceObject : 
#ifdef USING_IDISPATCH
	public CComDualImpl<IdInputDevice, &IID_IdInputDevice, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public IdInputDevice,
#endif
	public CComObjectBase<&CLSID_dInputDevice>
{
public:
	CdInputDeviceObject() ;
BEGIN_COM_MAP(CdInputDeviceObject)
	COM_INTERFACE_ENTRY(IdInputDevice)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()
// Use DECLARE_NOT_AGGREGATABLE(CdInputDeviceObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CdInputDeviceObject)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// IdInputDevice
public:
	// MUST BE FIRST!!
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

private:
    DECL_VARIABLE(dInputDevice);

public:
	DX3J_GLOBAL_LINKS( dInputDevice )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dinput1obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dinput1obj.cpp
//
//--------------------------------------------------------------------------

    // dDrawColorControlObj.cpp : Implementation of CDirectApp and DLL registration.
    // DHF_DS entire file
    
    #include "stdafx.h"
    #include "Direct.h"
    #include "dms.h"
    #include "dInput1Obj.h"
    #include "dInputDeviceObj.h"
    #include "dinput.h"
    #include "DIEnumDevicesObj.h"
    
    extern HRESULT BSTRtoGUID(LPGUID,BSTR);
    extern HRESULT DINPUTBSTRtoGUID(LPGUID,BSTR);
    
    CONSTRUCTOR(_dxj_DirectInput8, {});
    DESTRUCTOR(_dxj_DirectInput8, {});
    GETSET_OBJECT(_dxj_DirectInput8);

    HRESULT FillRealActionFormat(DIACTIONFORMATW *real, DIACTIONFORMAT_CDESC *cover, SAFEARRAY **actionArray,long ActionCount );                                      
       
    STDMETHODIMP C_dxj_DirectInput8Object::createDevice(BSTR strGuid, I_dxj_DirectInputDevice8 **dev)
    {    
    
    	HRESULT hr = S_OK;
  		GUID		rguid;
    	LPDIRECTINPUTDEVICE8W realdevice=NULL;
    
    	
	hr = DINPUTBSTRtoGUID(&rguid,strGuid);	
    	if FAILED(hr) return hr;	
    
    
     	hr=m__dxj_DirectInput8->CreateDevice(rguid,&realdevice,NULL);
    	if FAILED(hr) return hr;
    
    
    	INTERNAL_CREATE(_dxj_DirectInputDevice8,realdevice,dev);
    	if (*dev==NULL) {
    		realdevice->Release();
    		return E_OUTOFMEMORY;
    	}
    	
    
    	if (0==_wcsicmp(strGuid,L"guid_syskeyboard")){		
    		hr=realdevice->SetDataFormat(&c_dfDIKeyboard);
    	}
    	else if (0==_wcsicmp(strGuid,L"guid_sysmouse")){		
    		hr=realdevice->SetDataFormat(&c_dfDIMouse);
    	}
    	else {
    		hr=realdevice->SetDataFormat(&c_dfDIJoystick2);
    	}
    
    	return hr;
    }
    
    
#ifdef _WIN64
    STDMETHODIMP C_dxj_DirectInput8Object::RunControlPanel( HWND hwndOwner )
#else
    STDMETHODIMP C_dxj_DirectInput8Object::RunControlPanel( long hwndOwner )
#endif
    {
       HRESULT hr;
       hr = m__dxj_DirectInput8->RunControlPanel((HWND)hwndOwner,  (DWORD)0);    
       return hr;
    }
    
    STDMETHODIMP C_dxj_DirectInput8Object::GetDeviceStatus( BSTR strGuid, VARIANT_BOOL *status){
       HRESULT hr;
       GUID g;
	   hr = DINPUTBSTRtoGUID(&g,strGuid);	       
       if FAILED(hr) return hr;

	   if (!status) return E_INVALIDARG;

       hr = m__dxj_DirectInput8->GetDeviceStatus((REFGUID)g);    
    
	   if (hr==DI_OK)
			*status=VARIANT_TRUE;
	   else
			*status=VARIANT_FALSE;

       return S_OK;
    }
    
    
    STDMETHODIMP C_dxj_DirectInput8Object::getDIDevices(
    	long deviceType, long flags, I_dxj_DIEnumDevices8 **ppRet)
    
    {    
    	HRESULT hr;
    	hr = C_dxj_DIEnumDevicesObject::create(m__dxj_DirectInput8,deviceType,flags,ppRet);
    	return hr;
    }


	    
    STDMETHODIMP C_dxj_DirectInput8Object::getDevicesBySemantics(
		 /* [in] */ BSTR str1,
        /* [in] */ DIACTIONFORMAT_CDESC __RPC_FAR *format,
        /* [in] */ long flags,
        /* [retval][out] */ I_dxj_DIEnumDevices8 __RPC_FAR *__RPC_FAR *ret)
    {    
    	HRESULT hr;
    	hr = C_dxj_DIEnumDevicesObject::createSuitable(m__dxj_DirectInput8,str1,format,format->lActionCount,&format->ActionArray,flags,ret);
    	return hr;
    }

	BOOL CALLBACK DIConfigureDevicesCallback(
		  IUnknown FAR * lpDDSTarget,  
		  LPVOID pvRef   
	)
	{
		HANDLE eventID=(HANDLE)pvRef;
		::SetEvent((HANDLE)eventID);	//CONSIDER 64 bit ramification of casting to a handle
		return TRUE;
	}


    STDMETHODIMP C_dxj_DirectInput8Object::ConfigureDevices   (
#ifdef _WIN64
						HANDLE hEvent,
#else
						long hEvent,
#endif
						DICONFIGUREDEVICESPARAMS_CDESC *CDParams,
						long flags
						)
    {

	HRESULT hr;
	BSTR bstr;
	long lElements;
	long i;


	DICONFIGUREDEVICESPARAMSW RealCDParams;

	if (CDParams->ActionFormats==0) return E_INVALIDARG;

	ZeroMemory(&RealCDParams,sizeof(DICONFIGUREDEVICESPARAMSW));
	RealCDParams.dwSize=sizeof(DICONFIGUREDEVICESPARAMSW);
	RealCDParams.dwcUsers=CDParams->UserCount;
	RealCDParams.dwcFormats=CDParams->FormatCount;
	RealCDParams.hwnd=(HWND)CDParams->hwnd;

	//CONSIDER if we need to ADDREF 
	RealCDParams.lpUnkDDSTarget=CDParams->DDSTarget;
	memcpy(&RealCDParams.dics,&CDParams->dics,sizeof(DICOLORSET));
	
	lElements=(long)CDParams->UserNames->rgsabound[0].cElements;
	if (lElements==0){
		RealCDParams.lptszUserNames=NULL;
	}
	else {
		if (lElements < CDParams->UserCount) return E_INVALIDARG;

		DWORD dwMemSize=MAX_PATH*sizeof(WCHAR)*CDParams->UserCount;		
		RealCDParams.lptszUserNames=(WCHAR*)malloc(dwMemSize);
		if (!RealCDParams.lptszUserNames) return E_OUTOFMEMORY;

		ZeroMemory(RealCDParams.lptszUserNames,dwMemSize);

		WCHAR *pCharbuff=RealCDParams.lptszUserNames;
		for (i=0;i<CDParams->UserCount;i++)
		{		
			bstr=((BSTR*) (CDParams->UserNames->pvData))[i];
			if (bstr) wcscpy(pCharbuff,(WCHAR*)bstr);
			pCharbuff+=MAX_PATH;	//advance 1024 wchars
		}
		
	}

	lElements=(long)CDParams->ActionFormats->rgsabound[0].cElements;
	if (lElements < CDParams->FormatCount) {
		if ( RealCDParams.lptszUserNames) free(RealCDParams.lptszUserNames);
		return E_INVALIDARG;
	}

	DIACTIONFORMATW *pRealActionFormats=(DIACTIONFORMATW*)malloc(CDParams->FormatCount*sizeof(DIACTIONFORMATW));
	if (!pRealActionFormats) {
		if ( RealCDParams.lptszUserNames) free(RealCDParams.lptszUserNames);
		return E_OUTOFMEMORY;
	}

	RealCDParams.lprgFormats=pRealActionFormats;

	DIACTIONFORMAT_CDESC *pCoverFormats=(DIACTIONFORMAT_CDESC *) (CDParams->ActionFormats->pvData);	
	if (!pCoverFormats) {
		if (RealCDParams.lptszUserNames) free(RealCDParams.lptszUserNames);
		if (pRealActionFormats) free (pRealActionFormats);
		return E_INVALIDARG;
	}	



	for (i=0;i<CDParams->FormatCount;i++)
	{
		FillRealActionFormat(				
			&(pRealActionFormats[i]), 
			&(pCoverFormats[i]),
			&(pCoverFormats[i].ActionArray),
			pCoverFormats[i].lActionCount);
	}
	

	if (hEvent)
	{
	       	hr = m__dxj_DirectInput8->ConfigureDevices(
			DIConfigureDevicesCallback,
		   	&RealCDParams,
			(DWORD)flags,
			(void*)hEvent);
	}
	else 
	{
	       	hr = m__dxj_DirectInput8->ConfigureDevices(
			NULL,
		   	&RealCDParams,
			(DWORD)flags,
			NULL);
	}
	
	if ( RealCDParams.lptszUserNames) free(RealCDParams.lptszUserNames);

	//TODO make sure action format info is deallocated correctly
	if (pRealActionFormats) free (pRealActionFormats);

	return hr;
    }




    HRESULT FillRealActionFormat(DIACTIONFORMATW *real, DIACTIONFORMAT_CDESC *cover, SAFEARRAY **actionArray,long ActionCount )
    {
		HRESULT hr;
		ZeroMemory(real,sizeof(DIACTIONFORMATW));
		real->dwSize=sizeof(DIACTIONFORMATW);
		real->dwActionSize=sizeof(DIACTIONW);
		real->dwDataSize=(DWORD)ActionCount*sizeof(DWORD);
		real->dwGenre= (DWORD)cover->lGenre;
		real->lAxisMin= cover->lAxisMin;
		real->lAxisMax= cover->lAxisMax;
		real->dwBufferSize= (DWORD)cover->lBufferSize;
		real->dwNumActions=(DWORD)ActionCount;
		real->rgoAction= ((LPDIACTIONW) (*actionArray)->pvData);
		if (cover->ActionMapName)
		{
			wcscpy(real->tszActionMap,(WCHAR*)cover->ActionMapName);
		}		
		hr=DINPUTBSTRtoGUID(&real->guidActionMap,cover->guidActionMap);
		if FAILED(hr) return hr;

		return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dinputeffectobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dinputeffectobj.h
//
//--------------------------------------------------------------------------

	

#include "resource.h"       // main symbols
extern void* g_dxj_DirectInputEffect;

#define typedef__dxj_DirectInputEffect LPDIRECTINPUTEFFECT

/////////////////////////////////////////////////////////////////////////////
// Direct


class C_dxj_DirectInputEffectObject : 
	public I_dxj_DirectInputEffect,
	public CComObjectRoot
{
public:
	C_dxj_DirectInputEffectObject() ;
	virtual ~C_dxj_DirectInputEffectObject();

BEGIN_COM_MAP(C_dxj_DirectInputEffectObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectInputEffect)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectInputEffectObject)


public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd) ;
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd) ;
        
         HRESULT STDMETHODCALLTYPE download( void) ;
        
         HRESULT STDMETHODCALLTYPE getEffectGuid( 
            /* [retval][out] */ BSTR *guid) ;
        
         HRESULT STDMETHODCALLTYPE getEffectStatus( 
            /* [retval][out] */ long __RPC_FAR *ret) ;
        
         HRESULT STDMETHODCALLTYPE start( 
            /* [in] */ long iterations,
            /* [in] */ long flags) ;
        
         HRESULT STDMETHODCALLTYPE stop( void) ;
        
         HRESULT STDMETHODCALLTYPE unload( void) ;
        
         HRESULT STDMETHODCALLTYPE setParameters( 
            /* [in] */ DIEFFECT_CDESC __RPC_FAR *effectinfo, long flags) ;
        
         HRESULT STDMETHODCALLTYPE getParameters( 
            /* [out][in] */ DIEFFECT_CDESC __RPC_FAR *effectinfo) ;
        
   
             

private:
    DECL_VARIABLE(_dxj_DirectInputEffect);

public:
	DX3J_GLOBAL_LINKS(_dxj_DirectInputEffect);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dinputeffectobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dinputeffectobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dInputEffectObj.h"

extern HRESULT FixUpCoverEffect(GUID g, DIEFFECT_CDESC *cover,DIEFFECT *realEffect);
extern HRESULT FixUpRealEffect(GUID g,DIEFFECT *realEffect,DIEFFECT_CDESC *cover);
extern BSTR DINPUTGUIDtoBSTR(LPGUID g);

CONSTRUCTOR(_dxj_DirectInputEffect, {});
DESTRUCTOR(_dxj_DirectInputEffect, {});
GETSET_OBJECT(_dxj_DirectInputEffect);
                                  
   
STDMETHODIMP C_dxj_DirectInputEffectObject::download()
{
	HRESULT hr;
    hr=m__dxj_DirectInputEffect->Download();
	return hr;
}

STDMETHODIMP C_dxj_DirectInputEffectObject::getEffectGuid(BSTR *guid)
{
	HRESULT hr;
	GUID g;
	if (!guid) return E_INVALIDARG;
    hr=m__dxj_DirectInputEffect->GetEffectGuid(&g);
	*guid=DINPUTGUIDtoBSTR(&g);
	return hr;
}

   
STDMETHODIMP C_dxj_DirectInputEffectObject::getEffectStatus(long *ret)
{
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
    hr=m__dxj_DirectInputEffect->GetEffectStatus((DWORD*)ret);
	return hr;
}

STDMETHODIMP C_dxj_DirectInputEffectObject::start(
			/* [in] */ long iterations,
            /* [in] */ long flags) 
     
{
	HRESULT hr;
    hr=m__dxj_DirectInputEffect->Start((DWORD)iterations,(DWORD)flags);
	return hr;
}


STDMETHODIMP C_dxj_DirectInputEffectObject::stop()
{
	HRESULT hr;
    hr=m__dxj_DirectInputEffect->Stop();
	return hr;
}


STDMETHODIMP C_dxj_DirectInputEffectObject::unload()
{
	HRESULT hr;
    hr=m__dxj_DirectInputEffect->Unload();
	return hr;
}
         
STDMETHODIMP C_dxj_DirectInputEffectObject::setParameters( 
            /* [in] */ DIEFFECT_CDESC __RPC_FAR *effectInfo, long flags) 
{
	DIEFFECT realEffect;
	HRESULT hr;
	GUID g;
	m__dxj_DirectInputEffect->GetEffectGuid(&g);
	
	hr=FixUpRealEffect(g,&realEffect,effectInfo);
	if FAILED(hr) return hr;

    hr=m__dxj_DirectInputEffect->SetParameters(&realEffect,(DWORD) flags);
	return hr;
}

#define DICONDITION_USE_BOTH_AXIS 1
#define DICONDITION_USE_DIRECTION 2


STDMETHODIMP C_dxj_DirectInputEffectObject::getParameters( 
            /* [in] */ DIEFFECT_CDESC __RPC_FAR *effectInfo) 
{
	
	HRESULT hr;
	GUID g;
	DIEFFECT *pRealEffect=(DIEFFECT*)effectInfo;
	DWORD dwFlags= DIEP_ALLPARAMS;
	
 
	if (!effectInfo) return E_INVALIDARG;



	ZeroMemory(pRealEffect,sizeof(DIEFFECT_CDESC));
	if (!pRealEffect->dwFlags) pRealEffect->dwFlags = DIEFF_OBJECTOFFSETS | DIEFF_POLAR;
	pRealEffect->dwSize =sizeof(DIEFFECT);
	pRealEffect->lpEnvelope =(DIENVELOPE*)&(effectInfo->envelope);
	pRealEffect->lpEnvelope->dwSize=sizeof(DIENVELOPE);
	pRealEffect->cAxes = 2;
	pRealEffect->rglDirection =(long*)&(effectInfo->x);
	
	hr=m__dxj_DirectInputEffect->GetEffectGuid(&g);
	if FAILED(hr) return hr;
			
	if (g==GUID_ConstantForce)
	{
		pRealEffect->lpvTypeSpecificParams =&(effectInfo->constantForce);
		pRealEffect->cbTypeSpecificParams =sizeof(DICONSTANTFORCE);		
	}		
	else if ((g==GUID_Square)||(g==GUID_Triangle)||(g==GUID_SawtoothUp)||(g==GUID_SawtoothDown)||(g==GUID_Sine))
	{
		pRealEffect->lpvTypeSpecificParams =&(effectInfo->periodicForce);
		pRealEffect->cbTypeSpecificParams =sizeof(DIPERIODIC);				
	}
	else if ((g==GUID_Spring)|| (g==GUID_Damper)|| (g==GUID_Inertia)|| (g==GUID_Friction)){		
			pRealEffect->cbTypeSpecificParams =sizeof(DICONDITION)*2;
			pRealEffect->lpvTypeSpecificParams =&(effectInfo->conditionX);
	}	
	else if (g==GUID_RampForce){		
		pRealEffect->lpvTypeSpecificParams =&(effectInfo->rampForce);
		pRealEffect->cbTypeSpecificParams =sizeof(DIRAMPFORCE);				
	}
	else {
		pRealEffect->lpvTypeSpecificParams =NULL;
		pRealEffect->cbTypeSpecificParams =0;
		dwFlags= dwFlags -DIEP_TYPESPECIFICPARAMS;
	}


	effectInfo->axisOffsets.x=DIJOFS_X;
	effectInfo->axisOffsets.y=DIJOFS_Y;
	pRealEffect->rgdwAxes=(DWORD*)&(effectInfo->axisOffsets);

	hr=m__dxj_DirectInputEffect->GetParameters(pRealEffect, dwFlags);

	if FAILED(hr) return hr;

	if (pRealEffect->cbTypeSpecificParams == sizeof(DICONDITION)*2)
		effectInfo->conditionFlags=DICONDITION_USE_BOTH_AXIS;
	else
		effectInfo->conditionFlags=DICONDITION_USE_DIRECTION;

	if (pRealEffect->lpEnvelope){
		effectInfo->bUseEnvelope=VARIANT_TRUE;
	}
	
	    
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\direct.cpp ===
// Direct.cpp : Implementation of DLL Exports.
    
    // To fully complete this project follow these steps
    
    // You will need the new MIDL compiler to build this project.  Additionally,
    // if you are building the proxy stub DLL, you will need new headers and libs.
    
    // 1) Add a custom build step to Direct.idl
    //		You can select all of the .IDL files by holding Ctrl and clicking on
    //		each of them.
    //
    //		Description
    //			Running MIDL
    //		Build Command(s)
    //			midl Direct.idl
    //		Outputs 
    //			Direct.tlb
    //			Direct.h
    //			Direct_i.c
    //
    // NOTE: You must use the MIDL compiler from NT 4.0,
    // preferably 3.00.15 or greater
    //
    // 2) Add a custom build step to the project to register the DLL
    //		For this, you can select all projects at once
    //		Description
    //			Registering OLE Server...
    //		Build Command(s)
    //			regsvr32 /s /c "$(TargetPath)"
    //			echo regsvr32 exec. time > "$(OutDir)\regsvr32.trg"
    //		Outputs
    //			$(OutDir)\regsvr32.trg
    
    // 3) To add UNICODE support, follow these steps
    //		Select Build|Configurations...
    //		Press Add...
    //		Change the configuration name to Unicode Release
    //		Change the "Copy Settings From" combo to Direct - Win32 Release
    //		Press OK
    //		Press Add...
    //		Change the configuration name to Unicode Debug
    //		Change the "Copy Settings From" combo to Direct - Win32 Debug
    //		Press OK
    //		Press "Close"
    //		Select Build|Settings...
    //		Select the two UNICODE projects and press the C++ tab.
    //		Select the "General" category
    //		Add _UNICODE to the Preprocessor definitions
    //		Select the Unicode Debug project
    //		Press the "General" tab
    //		Specify DebugU for the intermediate and output directories
    //		Select the Unicode Release project
    //		Press the "General" tab
    //		Specify ReleaseU for the intermediate and output directories
    
    // 4) Proxy stub DLL
    //		To build a separate proxy/stub DLL,
    //		run nmake -f ps.mak in the project directory.
    

    
    #include "stdafx.h"
    #include "d3d8.h"    

    #include "resource.h"
    #include "initguid.h"
    #include "Direct.h"
    #include "dms.h"
    
    #include "DxGlob7Obj.h"
    #include "d3dx8obj.h"	    
    #include "dSoundObj.h"
    #include "dSoundBufferObj.h"
    #include "dSound3DListener.h"
    #include "dSound3DBuffer.h"
    #include "dSoundCaptureObj.h"
    #include "dSoundCaptureBufferObj.h"


    #include "DPlayPeerObj.h"
    #include "dPlayVoiceClientObj.h"
    
    #include "dInput1Obj.h"
    #include "dInputDeviceObj.h"
    
    #define IID_DEFINED
    #include "Direct_i.c"
    
    // When floating-point types are used, the compiler emits a reference to
    // _fltused to initialize the CRT's floating-point package.  We're not
    // using any of that support and the OS is responsible for initializing
    // the FPU, so we'll link to the following _fltused instead to avoid CRT
    // bloat.
    //
    // win2k doesnt like this so its been removed
    // #ifdef NDEBUG
    // extern "C" int _fltused = 0;
    // #endif
    
    
    
    // ATL COM OBJECT MAP
    CComModule _Module;
    BEGIN_OBJECT_MAP(ObjectMap)
    	OBJECT_ENTRY(CLSID__dxj_DirectX8,				 C_dxj_DirectX7Object)
	OBJECT_ENTRY(CLSID_D3DX8,				 	 C_dxj_D3DX8Object)
    END_OBJECT_MAP()
    
    //
    // thanks to precompiled headers, we never get this properly!
    //
    #undef DEFINE_GUID
    #define __based(a)
    #define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID CDECL __based(__segname("_CODE")) name \
                        = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
    
    
    
    // MISC GLOBALS
    static const char	c_szWav[] = "WAVE";
    long				g_debuglevel=0;
    extern "C" int		nObjects = 0;
    BOOL				is4Bit = FALSE;
    int					g_creationcount=0;
    CRITICAL_SECTION	g_cbCriticalSection;
    OSVERSIONINFOW		sysinfo;
    
    // HANDLES TO DX DLLS
    HINSTANCE			g_hDSoundHandle=NULL;
    HINSTANCE			g_hDPlay=NULL;
    HINSTANCE			g_hInstDINPUTDLL=NULL;
    HINSTANCE			g_hInstD3DXOFDLL=NULL;
    HINSTANCE			g_hInst=NULL;
    HINSTANCE			g_hD3D8=NULL;
    
    
    
    void *g_dxj_DirectSound3dListener		= 0;
    void *g_dxj_DirectSoundBuffer			= 0;
    void *g_dxj_DirectSoundPrimaryBuffer	= 0;
    void *g_dxj_DirectSound3dBuffer			= 0;
    void *g_dxj_DirectSound					= 0;
    void *g_dxj_DirectSoundCapture			= 0;
    void *g_dxj_DirectSoundCaptureBuffer	= 0;
#if 0
    void *g_dxj_DirectMusic					= 0;
    void *g_dxj_DirectSoundWave				= 0;
    void *g_dxj_DirectSoundDownloadedWave	= 0;
    void *g_dxj_DirectSoundSink				= 0;
    void *g_dxj_DirectSoundSource			= 0;
	void *g_dxj_ReferenceClock				= 0;
    void *g_dxj_DirectMusicVoice			= 0;
    void *g_dxj_DirectMusicPort				= 0;
    void *g_dxj_DirectMusicBuffer			= 0;
#endif

	void *g_dxj_DirectSoundFXSend			= 0;
	void *g_dxj_DirectSoundFXChorus			= 0;
	void *g_dxj_DirectSoundFXFlanger		= 0;
	void *g_dxj_DirectSoundFXEcho			= 0;
	void *g_dxj_DirectSoundFXDistortion		= 0;
	void *g_dxj_DirectSoundFXGargle			= 0;
	void *g_dxj_DirectSoundFXCompressor		= 0;
	void *g_dxj_DirectSoundFXI3DL2Source	= 0;
	void *g_dxj_DirectSoundFXI3DL2Reverb	= 0;
	void *g_dxj_DirectSoundFXParamEQ		= 0;
    void *g_dxj_DirectSoundFXWavesReverb	= 0;
    
    void *g_dxj_DirectInput8				= 0;
    void *g_dxj_DirectInputDevice8			= 0;
    void *g_dxj_DirectInputEffect			= 0;
    
    void *g_dxj_DirectMusicLoader			= 0;
    void *g_dxj_DirectMusicPerformance		= 0;
    void *g_dxj_DirectMusicComposer			= 0;
    void *g_dxj_DirectMusicStyle			= 0;
    void *g_dxj_DirectMusicBand				= 0;
    void *g_dxj_DirectMusicChordMap			= 0;
    void *g_dxj_DirectMusicSegment			= 0;
    void *g_dxj_DirectMusicSegmentState		= 0;
    void *g_dxj_DirectMusicCollection		= 0;
	void *g_dxj_DirectMusicAudioPath		= 0;
	void *g_dxj_DirectMusicSong				= 0;

    void *g_dxj_DirectPlayVoiceClient		= 0;
    void *g_dxj_DirectPlayVoiceServer		= 0;
    void *g_dxj_DirectPlayVoiceSetup		= 0;
	void *g_dxj_DirectPlay					= 0;
	void *g_dxj_DirectPlayPeer				= 0;
	void *g_dxj_DirectPlayServer			= 0;
	void *g_dxj_DirectPlayClient			= 0;
	void *g_dxj_DirectPlayAddress			= 0;    
	void *g_dxj_DirectPlayLobbyClient		= 0;
	void *g_dxj_DirectPlayLobbiedApplication= 0;

    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    //
    // DLL LOADING
    //
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    
    HINSTANCE LoadD3DXOFDLL()
    {
    	//char  Path[MAX_PATH];
    	//if (!g_hInstD3DXOFDLL) 
    	//{
    	//	GetSystemDirectory( Path, MAX_PATH );
    	//	strcat(Path, "\\d3dXOF.dll" );
    	//	g_hInstD3DXOFDLL=LoadLibrary(Path);	
    	//}

	if (!g_hInstD3DXOFDLL) g_hInstD3DXOFDLL=LoadLibrary("d3dXOF.dll");
    	return g_hInstD3DXOFDLL;
    }

    
    HINSTANCE LoadD3D8DLL()
    {
    
	if (!g_hD3D8) g_hD3D8=LoadLibrary("d3d8.dll");
    	return g_hD3D8;
    }
    
    HINSTANCE LoadDSoundDLL()
    {
    	//char  Path[MAX_PATH];
    	//if (!g_hDSoundHandle) 
    	//{
    	//	GetSystemDirectory( Path, MAX_PATH );
    	//	strcat(Path, "\\dsound.dll" );
    	//	g_hDSoundHandle=LoadLibrary( Path );
    	//}
	if (!g_hDSoundHandle) g_hDSoundHandle=LoadLibrary("dsound.dll");
    	return g_hDSoundHandle;
    }
    
    HINSTANCE LoadDPlayDLL()
    {
    	//char  Path[MAX_PATH];
    	//if (!g_hDPlay)
    	//{
    	//	GetSystemDirectory( Path, MAX_PATH );
    	//	strcat(Path, "\\dplayx.dll" );
    	//	g_hDPlay=LoadLibrary( Path );
    	//}
	if (!g_hDPlay) g_hDPlay=LoadLibrary("dplayx.dll");
    	return g_hDPlay;
    }
    
    
    HINSTANCE LoadDINPUTDLL()
    {
    	//if (!g_hInstDINPUTDLL) {
    	//	char  Path[MAX_PATH];
    	//	GetSystemDirectory( Path, MAX_PATH );
    	//	strcat(Path, "\\dinput8.dll" );
    	//	g_hInstDINPUTDLL=LoadLibrary( Path );
    	//}
	if (!g_hInstDINPUTDLL) g_hInstDINPUTDLL=LoadLibrary("dinput8.dll");
    	return g_hInstDINPUTDLL;
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    //
    // DLL ENTRY POINTS
    //
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    
    /////////////////////////////////////////////////////////////////////////////
    // DLL Entry Point
    extern "C" BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
    {
    
    	g_hInst=hInstance;
    
    	if (dwReason == DLL_PROCESS_ATTACH)
    	{
    		//
    		// Get the current display pixel depth
    		// If it is 4-bit we are in trouble.
    		//
            HDC hDisplayIC;
            BOOL bPalette = FALSE;
            hDisplayIC = CreateIC("DISPLAY", NULL, NULL, NULL);
    		if (hDisplayIC)
            {
    			if (GetDeviceCaps(hDisplayIC, BITSPIXEL) < 8)
    				is4Bit = TRUE;
    			DeleteDC(hDisplayIC);
            }
    
    		_Module.Init(ObjectMap, hInstance);
    		DisableThreadLibraryCalls(hInstance);
    		InitializeCriticalSection(&g_cbCriticalSection);

			HKEY hk=0;
    		DWORD type=REG_DWORD;
			LONG res;
			DWORD cbSize = sizeof(DWORD);
			
    		res=RegOpenKey(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Directx\\DXVB",&hk);
			if (hk)
			{
	    		res=RegQueryValueEx(hk,"DebugLevel",NULL,&type,(LPBYTE)&g_debuglevel,&cbSize);
			}

    		RegCloseKey(hk);

    		nObjects = 0;
    		
    
    	}
    	else if (dwReason == DLL_PROCESS_DETACH)
    	{
    
		DeleteCriticalSection(&g_cbCriticalSection);    

    		//FREE DLLS
    		if ( g_hDPlay ) 
    			FreeLibrary(g_hDPlay);
    		if ( g_hDSoundHandle )
    			FreeLibrary(g_hDSoundHandle);
    		if ( g_hInstDINPUTDLL )
    			FreeLibrary(g_hInstDINPUTDLL);	
    		if (g_hInstD3DXOFDLL)
    			FreeLibrary(g_hInstD3DXOFDLL);	
    		if (g_hD3D8)
    			FreeLibrary(g_hD3D8);	
    		
    		_Module.Term();
    
    	}
    	return TRUE;    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Used to determine whether the DLL can be unloaded by OLE
    STDAPI DllCanUnloadNow(void)
    {
    	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Returns a class factory to create an object of the requested type
    STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
    {
    	return _Module.GetClassObject(rclsid, riid, ppv);
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // DllRegisterServer - Adds entries to the system registry
    STDAPI DllRegisterServer(void)
    {
    	HRESULT hRes = S_OK;
    	// registers object, typelib and all interfaces in typelib
    	hRes = _Module.RegisterServer(TRUE);
    	if(hRes == S_OK)
    	{
    		//hRes = RegSecurityClass();
    	}
    
    	//now look
    	HKEY hk=0;
    	char szDocPath[MAX_PATH];
    	DWORD cb=MAX_PATH;
    	LONG res;
    	DWORD type=REG_SZ;
    
    	ZeroMemory(szDocPath,MAX_PATH);
    	
    	res=RegOpenKey(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Directx SDK",&hk);
    	if ((ERROR_SUCCESS!=res)||(hk==0) )
    		return hRes;
    
    	
    	
    	res=RegQueryValueEx(hk,"DX81SDK Doc Path",NULL,&type,(LPBYTE)szDocPath,&cb);
    	RegCloseKey(hk);
    
    	if (ERROR_SUCCESS!=res) return hRes;
    
    	hk=0;
    
    	res=RegOpenKey(HKEY_LOCAL_MACHINE,"Software\\CLASSES\\TypeLib\\{E1211242-8E94-11d1-8808-00C04FC2C603}\\1.0\\HELPDIR",&hk);
    	if (ERROR_SUCCESS!=res) return hRes;
    
    	RegSetValueEx(hk,NULL,0,REG_SZ,(LPBYTE)szDocPath,cb);
    	RegCloseKey(hk);
    
    
    	return hRes;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // DllUnregisterServer - Adds entries to the system registry
    STDAPI DllUnregisterServer(void)
    {
    	HRESULT hRes = S_OK;
    	hRes = _Module.UnregisterServer();
    	if(hRes == S_OK)
    	{
    		//hRes = UnRegSecurityClass();
    	}
    
    	return hRes;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    //
    // GUID CONVERSION FUNCTIONS
    //
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    
    /////////////////////////////////////////////////////////////////////////////
    // GUIDS_EQUAL - consider moving to dms.h
    
    #define GUIDS_EQUAL(g,g2) (\
    	(g.Data1==g2->Data1) && \
    	(g.Data2==g2->Data2) && \
    	(g.Data3==g2->Data3) && \
    	(g.Data4[0]==g2->Data4[0]) && \
    	(g.Data4[1]==g2->Data4[1]) && \
    	(g.Data4[2]==g2->Data4[2]) && \
    	(g.Data4[3]==g2->Data4[3]) && \
    	(g.Data4[4]==g2->Data4[4]) && \
    	(g.Data4[5]==g2->Data4[5]) && \
    	(g.Data4[6]==g2->Data4[6]) && \
    	(g.Data4[7]==g2->Data4[7]) )
    
    
    /////////////////////////////////////////////////////////////////////////////
    // GUIDtoBSTR - does conversion
    
    BSTR GUIDtoBSTR(LPGUID pGuid){
    	char  szOut[256];	
    	char  szTemp[10];
    	char  *pAt=NULL;
    	int	  i;
    	BSTR  bstrOut;
    
    	// 00000000001111111111222222222233333333
    	// 01234567890123456789012345678901234567
    	// {XXXXXXXX-XXXX-XXXX-X  XXX-XXXXXXXXXXXX}
    	if (pGuid!=NULL){
    
    		szOut[0]='{';
    		
    		wsprintf(&(szOut)[1],"%.8X",pGuid->Data1);
    		
    		szOut[9]='-';
    		
    		wsprintf(szTemp,"%.4X",pGuid->Data2);
    		memcpy(&(szOut[10]),szTemp,4);
    
    		szOut[14]='-';
    
    		wsprintf(szTemp,"%.4X",pGuid->Data3);
    		memcpy(&(szOut[15]),szTemp,4);
    
    		szOut[19]='-';
    
    		for (i=0;i<2;i++){
    			wsprintf(szTemp,"%.2X",pGuid->Data4[i]);
    			memcpy(&(szOut[20+i*2]),szTemp,2);
    			
    		}
    
    		szOut[24]='-';
    
    		for (i=2;i<8;i++){
    			wsprintf(szTemp,"%.2X",pGuid->Data4[i]);
    			memcpy(&(szOut[21+i*2]),szTemp,2);
    			
    		}
    
    		szOut[37]='}';
    		szOut[38]='\0';
    
    		USES_CONVERSION;
    		bstrOut = T2BSTR(szOut);
    
    	}
    	else {
    		bstrOut = T2BSTR("");
    	}
    		
    
    	
    	return bstrOut;
    }
    
    //////////////////////////////////////////////////////////////////////////////
    // convertChar
    // helper for GUIDtoBSTR
    HRESULT convertChar(char *szIn,int i,char *valOut){
    	int val[2];	//using int for easy out of bounds check
    	
    	char c;
    	int j;
    	
    	for (j=0;j<2;j++){
    	   c= szIn[i+j];
    	   switch (c)
    	   {
    		case 'a':
    		case 'A':
    			val[j]=10;
    			break;
    		case 'b':
    		case 'B':
    			val[j]=11;
    			break;
    		case 'c':
    		case 'C':
    			val[j]=12;
    			break;
    		case 'd':
    		case 'D':
    			val[j]=13;
    			break;
    
    		case 'e':
    		case 'E':
    			val[j]=14;
    			break;
    		case 'f':
    		case 'F':
    			val[j]=15;
    			break;
    		default:
    			val[j]=c-'0';
    			if (val[j]<0) return E_INVALIDARG;
    			if (val[j]>15) return E_INVALIDARG;
    			break;
    	   }
    	}
    
    
    	*valOut=(char)((val[0]<<4)|val[1]);
    	return S_OK;
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // BSTRtoGUID - does conversion
    //
    HRESULT BSTRtoGUID(LPGUID pGuid, BSTR bstr){
    	HRESULT hr;
    	//byte
    	// 
    	// 
    	//char
    	//           1111111111222222222233333333
    	// 01234567890123456789012345678901234567
    	// {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}	
    	USES_CONVERSION;
    	if(!pGuid) return E_INVALIDARG;
    	ZeroMemory(pGuid,sizeof(GUID));	
    	if (!bstr) return S_OK;
    		
    	if (bstr[0]==0x00) return S_OK;
    
		LPSTR szGuid = NULL;
		__try { szGuid=W2T(bstr); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
    	
    	//first and last char should be { }
    	if ((szGuid[0]!='{')||(szGuid[37]!='}'))
    		return E_INVALIDARG;
    	if ((szGuid[9]!='-')||(szGuid[14]!='-')||(szGuid[19]!='-')||(szGuid[24]!='-'))
    		return E_INVALIDARG;
    	
    	char val;
    	char *pData=(char*)pGuid;
    	int j=0;
    	int i;
    	
    	//FIRST DWORD
    	for ( i=7;i>=1;i=i-2){
    		hr=convertChar(szGuid,i,&val);
    		if FAILED(hr) return hr;				
    		pData[j++]=val;
    	}
    
    	//FIRST WORD
    	for ( i=12;i>=10;i=i-2){
    		hr=convertChar(szGuid,i,&val);
    		if FAILED(hr) return hr;
    		pData[j++]=val;
    	}
    
    	//2nd WORD
    	for ( i=17;i>=15;i=i-2){
    		hr=convertChar(szGuid,i,&val);
    		if FAILED(hr) return hr;
    		pData[j++]=val;
    	}
    
    
    	//3rd DWORD - BYTE ARRAY
    	for ( i=20;i<24;i=i+2){
    		hr=convertChar(szGuid,i,&val);
    		if FAILED(hr) return hr;
    		pData[j++]=val;
    	}
    
    	//BYTE ARRAY
    	for ( i=25;i<37;i=i+2){
    		hr=convertChar(szGuid,i,&val);
    		if FAILED(hr) return hr;
    		pData[j++]=val;
    	}
    
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // 
    //
    HRESULT BSTRtoPPGUID(LPGUID *ppGuid, BSTR bstr){
    	if (!ppGuid) return E_INVALIDARG;
    	if ((bstr==NULL)||(bstr[0]=='\0')){
    		*ppGuid=NULL;
    		return S_OK;
    	}
    	return BSTRtoGUID(*ppGuid,bstr);
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // D3DBSTRtoGUID - does conversion
    //
    HRESULT D3DBSTRtoGUID(LPGUID pGuid,BSTR str){
    	HRESULT hr=S_OK;
    
    	if (!pGuid) return E_INVALIDARG;
    	if (!str) {
    		ZeroMemory(pGuid,sizeof(GUID));
    		return S_OK;
    	}
    	//if( 0==_wcsicmp(str,L"iid_idirect3drgbdevice")){
    	//		memcpy(pGuid,&IID_IDirect3DRGBDevice,sizeof(GUID));
    	//}
    	//else if( 0==_wcsicmp(str,L"iid_idirect3dhaldevice")){
    	//		memcpy(pGuid,&IID_IDirect3DHALDevice,sizeof(GUID));
    	//}
    	//else if( 0==_wcsicmp(str,L"iid_idirect3dmmxdevice")){
    	//		memcpy(pGuid,&IID_IDirect3DMMXDevice,sizeof(GUID));
    	//}
    	//else if( 0==_wcsicmp(str,L"iid_idirect3drefdevice")){
    	//		memcpy(pGuid,&IID_IDirect3DRefDevice,sizeof(GUID));
    	//}
    	//else if( 0==_wcsicmp(str,L"iid_idirect3dnulldevice")){
    	//		memcpy(pGuid,&IID_IDirect3DNullDevice,sizeof(GUID));
    	//}
    	//else {
    	//	hr = BSTRtoGUID(pGuid,str);
    	//}
    
    	return hr;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // D3DGUIDtoBSTR - does conversion
    //
    BSTR D3DGUIDtoBSTR(LPGUID pg){
    
    	HRESULT hr=S_OK;
    	WCHAR *pStr=NULL;
    
    	if (!pg)
    		return NULL;
    	//else if (GUIDS_EQUAL(IID_IDirect3DNullDevice,pg)){
    	//	pStr=L"IID_IDirect3DNullDevice";
    	//}
    	//else if (GUIDS_EQUAL(IID_IDirect3DRefDevice,pg)){
    	//	pStr=L"IID_IDirect3DRefDevice";
    	//}
    	//else if (GUIDS_EQUAL(IID_IDirect3DMMXDevice,pg)){
    	//	pStr=L"IID_IDirect3DMMXDevice";
    	//}
    	//
    	//else if (GUIDS_EQUAL(IID_IDirect3DHALDevice,pg)){
    	//	pStr=L"IID_IDirect3DHALDevice";
    	//}
    	//else if (GUIDS_EQUAL(IID_IDirect3DRGBDevice,pg)){
    	//	pStr=L"IID_IDirect3DRGBDevice";
    	//}
    	//

    	if (pStr){
    		return DXALLOCBSTR(pStr);
    	}
    	else {
    		return GUIDtoBSTR(pg);
    	}
    
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // DSOUNDEFFECTSBSTRtoGUID - does conversion
    //
    HRESULT AudioBSTRtoGUID(LPGUID pGuid,BSTR str){
    	HRESULT hr=S_OK;
    
    	if (!pGuid) return E_INVALIDARG;
    
    	if (!str) {
    		ZeroMemory(pGuid,sizeof(GUID));
    		return S_OK;
    	}
#if 0
    	if( 0==_wcsicmp(str,L"guid_dsfx_send")){
    			memcpy(pGuid,&GUID_DSFX_SEND,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxsend")){
    			memcpy(pGuid,&IID_IDirectSoundFXSend,sizeof(GUID));
    	}
#endif
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_chorus")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_CHORUS,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_flanger")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_FLANGER,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_echo")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_ECHO,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_distortion")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_DISTORTION,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_compressor")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_COMPRESSOR,sizeof(GUID));
    	}
#if 0
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_i3dl2source")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_I3DL2SOURCE,sizeof(GUID));
    	}
#endif
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_i3dl2reverb")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_I3DL2REVERB,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_gargle")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_GARGLE,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_parameq")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_PARAMEQ,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_dsfx_waves_reverb")){
    			memcpy(pGuid,&GUID_DSFX_WAVES_REVERB,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxgargle")){
    			memcpy(pGuid,&IID_IDirectSoundFXGargle,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxchorus")){
    			memcpy(pGuid,&IID_IDirectSoundFXChorus,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxcompressor")){
    			memcpy(pGuid,&IID_IDirectSoundFXCompressor,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxdistortion")){
    			memcpy(pGuid,&IID_IDirectSoundFXDistortion,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxecho")){
    			memcpy(pGuid,&IID_IDirectSoundFXEcho,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxflanger")){
    			memcpy(pGuid,&IID_IDirectSoundFXFlanger,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxi3dl2reverb")){
    			memcpy(pGuid,&IID_IDirectSoundFXI3DL2Reverb,sizeof(GUID));
    	}
#if 0
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxi3dl2source")){
    			memcpy(pGuid,&IID_IDirectSoundFXI3DL2Source,sizeof(GUID));
    	}
#endif
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxparameq")){
    			memcpy(pGuid,&IID_IDirectSoundFXParamEq,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxwavesreverb")){
    			memcpy(pGuid,&IID_IDirectSoundFXWavesReverb,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"ds3dalg_default")){
    			memcpy(pGuid,&DS3DALG_DEFAULT,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"ds3dalg_no_virtualization")){
    			memcpy(pGuid,&DS3DALG_NO_VIRTUALIZATION,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"ds3dalg_hrtf_full")){
    			memcpy(pGuid,&DS3DALG_HRTF_FULL,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"ds3dalg_hrtf_light")){
    			memcpy(pGuid,&DS3DALG_HRTF_LIGHT,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"dsdevid_defaultplayback")){
    			memcpy(pGuid,&DSDEVID_DefaultPlayback,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"dsdevid_defaultcapture")){
    			memcpy(pGuid,&DSDEVID_DefaultCapture,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"dsdevid_defaultvoiceplayback")){
    			memcpy(pGuid,&DSDEVID_DefaultVoicePlayback,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"dsdevid_defaultvoicecapture")){
    			memcpy(pGuid,&DSDEVID_DefaultVoiceCapture,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_idirectsoundbuffer8")){
    			memcpy(pGuid,&IID_IDirectSoundBuffer8,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_idirectsoundbuffer")){
    			memcpy(pGuid,&IID_IDirectSoundBuffer,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_idirectsound3dlistener")){
    			memcpy(pGuid,&IID_IDirectSound3DListener,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_all_objects")){
    			memcpy(pGuid,&GUID_All_Objects,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_idirectsound3dbuffer")){
    			memcpy(pGuid,&IID_IDirectSound3DBuffer,sizeof(GUID));
    	}
    	else {
    		hr = BSTRtoGUID(pGuid,str);
    	}
    
    	return hr;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // DPLAYBSTRtoGUID - does conversion
    //
    HRESULT DPLAYBSTRtoGUID(LPGUID pGuid,BSTR str){
    	HRESULT hr=S_OK;
    
    	if (!pGuid) return E_INVALIDARG;
    
    	if (!str) {
    		ZeroMemory(pGuid,sizeof(GUID));
    		return S_OK;
    	}
    	if( 0==_wcsicmp(str,L"clsid_dp8sp_tcpip")){
    			memcpy(pGuid,&CLSID_DP8SP_TCPIP,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"clsid_dp8sp_ipx")){
    			memcpy(pGuid,&CLSID_DP8SP_IPX,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"clsid_dp8sp_modem")){
    			memcpy(pGuid,&CLSID_DP8SP_MODEM,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"clsid_dp8sp_serial")){
    			memcpy(pGuid,&CLSID_DP8SP_SERIAL,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"dsdevid_defaultplayback")){
    			memcpy(pGuid,&DSDEVID_DefaultPlayback,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"dsdevid_defaultcapture")){
    			memcpy(pGuid,&DSDEVID_DefaultCapture,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"dsdevid_defaultvoiceplayback")){
    			memcpy(pGuid,&DSDEVID_DefaultVoicePlayback,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"dsdevid_defaultvoicecapture")){
    			memcpy(pGuid,&DSDEVID_DefaultVoiceCapture,sizeof(GUID));
    	}
    	else {
    		hr = BSTRtoGUID(pGuid,str);
    	}
    
    	return hr;
    }

    /////////////////////////////////////////////////////////////////////////////
    // DINPUTGUIDtoBSTR
    //
    BSTR DINPUTGUIDtoBSTR(LPGUID pg){
    
    	HRESULT hr=S_OK;
    	WCHAR *pStr=NULL;
    
    	if (!pg)
    		return NULL;
    	else if (GUIDS_EQUAL(GUID_XAxis,pg)){
    		pStr=L"GUID_XAxis";
    	}
    	else if (GUIDS_EQUAL(GUID_YAxis,pg)){
    		pStr=L"GUID_YAxis";
    	}
    	else if (GUIDS_EQUAL(GUID_ZAxis,pg)){
    		pStr=L"GUID_ZAxis";
    	}
    	
    	else if (GUIDS_EQUAL(GUID_RxAxis,pg)){
    		pStr=L"GUID_RxAxis";
    	}
    	else if (GUIDS_EQUAL(GUID_RyAxis,pg)){
    		pStr=L"GUID_RyAxis";
    	}
    	else if (GUIDS_EQUAL(GUID_RzAxis,pg)){
    		pStr=L"GUID_RzAxis";
    	}
    
    	else if (GUIDS_EQUAL(GUID_Slider,pg)){
    		pStr=L"GUID_Slider";
    	}
    	else if (GUIDS_EQUAL(GUID_Button,pg)){
    		pStr=L"GUID_Button";
    	}
    	else if (GUIDS_EQUAL(GUID_Key,pg)){
    		pStr=L"GUID_Key";
    	}
    	else if (GUIDS_EQUAL(GUID_POV,pg)){
    		pStr=L"GUID_POV";
    	}
    	else if (GUIDS_EQUAL(GUID_Unknown,pg)){
    		pStr=L"GUID_Unknown";
    	}
    	else if (GUIDS_EQUAL(GUID_SysMouse,pg)){
    		pStr=L"GUID_SysMouse";
    	}
    	else if (GUIDS_EQUAL(GUID_SysKeyboard,pg)){
    		pStr=L"GUID_SysKeyboard";
    	}
    
    
    	else if (GUIDS_EQUAL(GUID_ConstantForce,pg)){
    		pStr=L"GUID_ConstantForce";
    	}
    	else if (GUIDS_EQUAL(GUID_Square,pg)){
    		pStr=L"GUID_Square";
    	}
    	else if (GUIDS_EQUAL(GUID_Sine,pg)){
    		pStr=L"GUID_Sine";
    	}
    	else if (GUIDS_EQUAL(GUID_Triangle,pg)){
    		pStr=L"GUID_Triangle";
    	}
    	else if (GUIDS_EQUAL(GUID_SawtoothUp,pg)){
    		pStr=L"GUID_SawtoothUp";
    	}
    	else if (GUIDS_EQUAL(GUID_SawtoothDown,pg)){
    		pStr=L"GUID_SawtoothDown";
    	}
    	else if (GUIDS_EQUAL(GUID_Spring,pg)){
    		pStr=L"GUID_Spring";
    	}
    	else if (GUIDS_EQUAL(GUID_Damper,pg)){
    		pStr=L"GUID_Damper";
    	}
    	else if (GUIDS_EQUAL(GUID_Inertia,pg)){
    		pStr=L"GUID_Inertia";
    	}
    	else if (GUIDS_EQUAL(GUID_Friction,pg)){
    		pStr=L"GUID_Friction";
    	}
    	else if (GUIDS_EQUAL(GUID_CustomForce,pg)){
    		pStr=L"GUID_CustomForce";
    	}
    	else if (GUIDS_EQUAL(GUID_RampForce,pg)){
    		pStr=L"GUID_RampForce";
    	}
    
    
    
    
    	//else if (GUIDS_EQUAL(GUID_Joystick,pg)){
    	//	pStr=L"GUID_JoyStick";
    	//}
    
    	if (pStr){
    		return DXALLOCBSTR(pStr);
    	}
    	else {
    		return GUIDtoBSTR(pg);
    	}
    
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // DINPUTBSTRtoGUID
    //
    HRESULT DINPUTBSTRtoGUID(LPGUID pGuid,BSTR str){
    	HRESULT hr=S_OK;
    
    	if (!pGuid) return E_INVALIDARG;
    
    	if (!str) {
    		ZeroMemory(pGuid,sizeof(GUID));
    		return S_OK;
    	}
    	if( 0==_wcsicmp(str,L"guid_xaxis")){
    			memcpy(pGuid,&GUID_XAxis,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_yaxis")){
    			memcpy(pGuid,&GUID_YAxis,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_zaxis")){
    			memcpy(pGuid,&GUID_ZAxis,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_rxaxis")){
    			memcpy(pGuid,&GUID_RxAxis,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_ryaxis")){
    			memcpy(pGuid,&GUID_RyAxis,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_rzaxis")){
    			memcpy(pGuid,&GUID_RzAxis,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_slider")){
    			memcpy(pGuid,&GUID_Slider,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_button")){
    			memcpy(pGuid,&GUID_Button,sizeof(GUID));
    	}
    
    	else if( 0==_wcsicmp(str,L"guid_key")){
    			memcpy(pGuid,&GUID_Key,sizeof(GUID));
    	}
    
    	else if( 0==_wcsicmp(str,L"guid_pov")){
    			memcpy(pGuid,&GUID_POV,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_unknown")){
    			memcpy(pGuid,&GUID_Unknown,sizeof(GUID));
    	}
    
    	else if( 0==_wcsicmp(str,L"guid_sysmouse")){
    			memcpy(pGuid,&GUID_SysMouse,sizeof(GUID));
    	}
    
    	else if( 0==_wcsicmp(str,L"guid_syskeyboard")){
    			memcpy(pGuid,&GUID_SysKeyboard,sizeof(GUID));
    	}
    
    	else if( 0==_wcsicmp(str,L"guid_constantforce")){
    			memcpy(pGuid,&GUID_ConstantForce,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_square")){
    			memcpy(pGuid,&GUID_Square,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_sine")){
    			memcpy(pGuid,&GUID_Sine,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_triangle")){
    			memcpy(pGuid,&GUID_Triangle,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_sawtoothup")){
    			memcpy(pGuid,&GUID_SawtoothUp,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_sawtoothdown")){
    			memcpy(pGuid,&GUID_SawtoothDown,sizeof(GUID));
    	}
    
    	else if( 0==_wcsicmp(str,L"guid_spring")){
    			memcpy(pGuid,&GUID_Spring,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_damper")){
    			memcpy(pGuid,&GUID_Damper,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_inertia")){
    			memcpy(pGuid,&GUID_Inertia,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_friction")){
    			memcpy(pGuid,&GUID_Friction,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_customforce")){
    			memcpy(pGuid,&GUID_CustomForce,sizeof(GUID));
    	}
    
    	else if( 0==_wcsicmp(str,L"guid_rampforce")){
    			memcpy(pGuid,&GUID_RampForce,sizeof(GUID));
    	}
    
    	//else if( 0==_wcsicmp(str,L"guid_joystick")){
    	//		memcpy(pGuid,&GUID_Joystick,sizeof(GUID));
    	//}
    	else {
    		hr = BSTRtoGUID(pGuid,str);
    	}
    
    	return hr;
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    //
    // GENERAL HELPER FUNCTIONS
    //
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Given an ANSI string, pass back a UNICODE string
    // SysAllocString is your big friend here.
    //
    // CONSIDER finding all occerence of use and replacint with the
    // T2BSTR macro .. much cleaner
    //
    extern "C" void PassBackUnicode(LPSTR str, BSTR *Name, DWORD cnt)
    {
    	//docdoc: length header is required to be filled, but the BSTR pointer
    	//        points to the first character, not the length.
    	// note, the count can never be too small as we get that from the string
    	// before we pass it in!
    	USES_CONVERSION;
    	LPWSTR lpw = (LPWSTR)malloc((cnt+1)*2);
		if (!lpw)
			return;

    	void *l = (void *)lpw;
    	lpw = AtlA2WHelper(lpw, str, cnt);
    	lpw[cnt] = 0;
    	*Name = SysAllocString(lpw);
    	free(l);
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IsAllZeros
    //
    BOOL IsEmptyString(BSTR szString)
	{
		__try {
			if (*szString)
				return FALSE;
			else
				return TRUE;
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			return TRUE;
		}
	}

    
    /////////////////////////////////////////////////////////////////////////////
    // IsAllZeros
    //
    BOOL IsAllZeros(void *pStruct,DWORD size){
    	for (DWORD i=0;i<size;i++){
    		if (((char*)pStruct)[i]!='\0'){
    			return FALSE;
    		}
    	}
    	return TRUE;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // CopyFloats
    //
    extern "C" void CopyFloats(D3DVALUE *dst, D3DVALUE *src, DWORD count)
    {
    	D3DVALUE *ptr1 = dst, *ptr2 = src;
    
    	if (!count)		return;
    
    	for (; count; count--)  *ptr1++ = *ptr2++;
    	return;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IsWin95
    //
    // no longer needed since we support w95 now
    #if 0
    BOOL IsWin95(void)
    {
    	return FALSE;
        
    
    
    	//We work on win95
        OSVERSIONINFO osvi;
        ZeroMemory(&osvi, sizeof(osvi));
        osvi.dwOSVersionInfoSize = sizeof(osvi);
        if (!GetVersionEx(&osvi))
        {
            DPF(1,"GetVersionEx failed - assuming Win95");
            return TRUE;
        }
    
        if ( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId )
        {
    
            if( ( osvi.dwMajorVersion > 4UL ) ||
                ( ( osvi.dwMajorVersion == 4UL ) &&
                  ( osvi.dwMinorVersion >= 10UL ) &&
                  ( LOWORD( osvi.dwBuildNumber ) >= 1373 ) ) )
            {
                // is Win98
                DPF(2,"Detected Win98");
                return FALSE;
            }
            else
            {
                // is Win95
                DPF(2,"Detected Win95");
                return TRUE;
            }
        }
        else if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
        {
            DPF(2,"Detected WinNT");
            return FALSE;
        }
        DPF(2,"OS Detection failed");
        return TRUE;
    
    }
    #endif
    
    #define DICONDITION_USE_BOTH_AXIS 1
    #define DICONDITION_USE_DIRECTION 2
    
    /////////////////////////////////////////////////////////////////////////////
    // FixUpRealEffect  cover->real
    //
    HRESULT FixUpRealEffect(GUID g,DIEFFECT *realEffect,DIEFFECT_CDESC *cover)
    {
    	if (!cover) return E_INVALIDARG;
    
    	
    	memcpy(realEffect,cover,sizeof(DIEFFECT));
    
    	realEffect->dwSize =sizeof(DIEFFECT);	
    	realEffect->lpEnvelope =NULL;
    	realEffect->cbTypeSpecificParams =0;
    	realEffect->lpvTypeSpecificParams =NULL;
    	realEffect->cAxes =2;
    	realEffect->dwFlags=realEffect->dwFlags | DIEFF_OBJECTOFFSETS ;
    	realEffect->rglDirection =(long*)&(cover->x);
    	realEffect->rgdwAxes =(DWORD*)&(cover->axisOffsets);	
    	
    	
    	if (cover->bUseEnvelope){
    		realEffect->lpEnvelope=(DIENVELOPE*)&(cover->envelope);
    		
    		((DIENVELOPE*)&(cover->envelope))->dwSize=sizeof(DIENVELOPE);
    	}
    	
    	if (!cover->lFlags)
    		realEffect->dwFlags= DIEFF_POLAR | DIEFF_OBJECTOFFSETS ;
    	
    	//constant
    	if (g==GUID_ConstantForce)
    	{
    		realEffect->cbTypeSpecificParams =sizeof (DICONSTANTFORCE);
    		realEffect->lpvTypeSpecificParams =&(cover->constantForce);
    	}
    	
    	//periodic
    	else if ((g==GUID_Square)||(g==GUID_Triangle)||(g==GUID_SawtoothUp)||(g==GUID_SawtoothDown)||(g==GUID_Sine))
    	{
    
    		realEffect->cbTypeSpecificParams =sizeof (DIPERIODIC);
    		realEffect->lpvTypeSpecificParams =&(cover->periodicForce);
    
    	}
    	else if ((g==GUID_Spring)|| (g==GUID_Damper)|| (g==GUID_Inertia)|| (g==GUID_Friction)){
    
    		if (cover->conditionFlags==DICONDITION_USE_BOTH_AXIS){
    			realEffect->cbTypeSpecificParams =sizeof(DICONDITION)*2;
    			realEffect->lpvTypeSpecificParams =&(cover->conditionX);			
    		}
    		else{
    			realEffect->cbTypeSpecificParams =sizeof(DICONDITION);
    			realEffect->lpvTypeSpecificParams =&(cover->conditionX);
    		}
    
    	}
    	else if (g==GUID_RampForce){
    		realEffect->cbTypeSpecificParams =sizeof(DIRAMPFORCE);
    		realEffect->lpvTypeSpecificParams =&(cover->rampForce);
    	}
    
    	cover->axisOffsets.x=DIJOFS_X;
    	cover->axisOffsets.y=DIJOFS_Y;
    	realEffect->rgdwAxes=(DWORD*)&(cover->axisOffsets);
    
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // FixUpCoverEffect  real->cover
    //
    HRESULT FixUpCoverEffect(GUID g, DIEFFECT_CDESC *cover,DIEFFECT *realEffect)
    {
    	
    
    	ZeroMemory(cover,sizeof(DIEFFECT_CDESC));
    	memcpy(cover,realEffect,sizeof(DIEFFECT));
    	
    	
    	if (realEffect->lpEnvelope){
    		memcpy(&cover->envelope,realEffect->lpEnvelope ,sizeof(DIENVELOPE));
    		cover->bUseEnvelope=VARIANT_TRUE;
    	}
    
    	if (realEffect->rglDirection){
    		cover->x=realEffect->rglDirection[0];
    		cover->y=realEffect->rglDirection[1];
    	}	
    	
    
    	
    	if (realEffect->lpvTypeSpecificParams){
    		
    		if (g==GUID_ConstantForce)
    		{
    			memcpy(&(cover->constantForce),realEffect->lpvTypeSpecificParams,sizeof(DICONSTANTFORCE));
    		}		
    		//periodic
    		else if ((g==GUID_Square)||(g==GUID_Triangle)||(g==GUID_SawtoothUp)||(g==GUID_SawtoothDown)||(g==GUID_Sine))
    		{
    			memcpy(&(cover->periodicForce),realEffect->lpvTypeSpecificParams,sizeof(DIPERIODIC));
    		}
    	
    		else if ((g==GUID_Spring)|| (g==GUID_Damper)|| (g==GUID_Inertia)|| (g==GUID_Friction)){
    			
    			if (realEffect->cbTypeSpecificParams ==sizeof(DICONDITION)*2){
    				memcpy(&(cover->conditionY),realEffect->lpvTypeSpecificParams,sizeof(DICONDITION)*2);
    				cover->conditionFlags=DICONDITION_USE_BOTH_AXIS;
    			}
    			else{
    				memcpy(&(cover->conditionX),realEffect->lpvTypeSpecificParams,sizeof(DICONDITION));
    				cover->conditionFlags=DICONDITION_USE_DIRECTION;
    			}
    
    		}
    		
    		else if (g==GUID_RampForce){
    			memcpy(&(cover->rampForce),realEffect->lpvTypeSpecificParams,sizeof(DIRAMPFORCE));			
    		}
    
    	}
    
    
    	return S_OK;
    }
    
    
    
    #define MYVARIANTINIT(inArg,puser) \
    	VariantInit(puser); \
    	user.vt=VT_UNKNOWN; \
    	user.punkVal = inArg; \
    	user.punkVal->AddRef();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dinput1obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dinput1obj.h
//
//--------------------------------------------------------------------------

	// ddPaletteObj.h : Declaration of the C_dxj_DirectDrawColorControlObject


#include "resource.h"       // main symbols

#define typedef__dxj_DirectInput8 LPDIRECTINPUT8W

/////////////////////////////////////////////////////////////////////////////
// Direct


class C_dxj_DirectInput8Object : 
	public I_dxj_DirectInput8,
	public CComObjectRoot
{
public:
	C_dxj_DirectInput8Object() ;
	virtual ~C_dxj_DirectInput8Object();

BEGIN_COM_MAP(C_dxj_DirectInput8Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectInput8)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectInput8Object)


public:
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
        HRESULT STDMETHODCALLTYPE createDevice( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DirectInputDevice8 __RPC_FAR *__RPC_FAR *dev);
        
        HRESULT STDMETHODCALLTYPE getDIDevices( 
            /* [in] */ long deviceType,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DIEnumDevices8 __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE GetDeviceStatus( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ VARIANT_BOOL *status);
        
#ifdef _WIN64
		HRESULT STDMETHODCALLTYPE RunControlPanel( 
            /* [in] */ HWND hwndOwner
            ///* [in] */ long flags
			);
#else
		HRESULT STDMETHODCALLTYPE RunControlPanel( 
            /* [in] */ LONG hwndOwner
            ///* [in] */ long flags
			);
#endif
                

	HRESULT STDMETHODCALLTYPE getDevicesBySemantics( 
        	/* [in] */ BSTR str1,
	        /* [in] */ DIACTIONFORMAT_CDESC __RPC_FAR *format,
        	
	        /* [in] */ long flags,
        	/* [retval][out] */ I_dxj_DIEnumDevices8 __RPC_FAR *__RPC_FAR *ret);
		
	HRESULT STDMETHODCALLTYPE ConfigureDevices   (
#ifdef _WIN64
					HANDLE hEvent,
#else
					long hEvent,
#endif
				   DICONFIGUREDEVICESPARAMS_CDESC *CDParams,
				   long flags);   							


private:
    DECL_VARIABLE(_dxj_DirectInput8);

public:
	DX3J_GLOBAL_LINKS(_dxj_DirectInput8)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmchordmapobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmchordmapobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmChordMapObj.h"


extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicChordMap;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicChordMap, {});
DESTRUCTOR(_dxj_DirectMusicChordMap, {});
GETSET_OBJECT(_dxj_DirectMusicChordMap);


	

HRESULT C_dxj_DirectMusicChordMapObject::getScale(long *scale)
{  
	HRESULT hr;				
	hr=m__dxj_DirectMusicChordMap->GetScale((DWORD*)scale);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmcollectionobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmcollectionobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmCollectionObj.h"


extern void *g_dxj_DirectMusicCollection;


CONSTRUCTOR(_dxj_DirectMusicCollection, {});
DESTRUCTOR(_dxj_DirectMusicCollection, {});
GETSET_OBJECT(_dxj_DirectMusicCollection);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dinputdeviceobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dinputdeviceobj.h
//
//--------------------------------------------------------------------------

	// ddPaletteObj.h : Declaration of the C_dxj_DirectDrawColorControlObject
#include "direct.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectInputDevice8 LPDIRECTINPUTDEVICE8W

/////////////////////////////////////////////////////////////////////////////
// Direct


class C_dxj_DirectInputDevice8Object : 
	public I_dxj_DirectInputDevice8,	
	public CComObjectRoot
{
public:
	C_dxj_DirectInputDevice8Object() ;
	~C_dxj_DirectInputDevice8Object();

BEGIN_COM_MAP(C_dxj_DirectInputDevice8Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectInputDevice8)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectInputDevice8Object)


public:
	/* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE acquire( void);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceObjectsEnum( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DIEnumDeviceObjects __RPC_FAR *__RPC_FAR *ppret);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getCapabilities( 
            /* [out][in] */ DIDEVCAPS_CDESC __RPC_FAR *caps);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceData( 
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *deviceObjectDataArray,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceInfo( 
            /* [retval][out] */ I_dxj_DirectInputDeviceInstance8 __RPC_FAR *__RPC_FAR *deviceInstance);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceStateKeyboard( 
            /* [out][in] */ DIKEYBOARDSTATE_CDESC __RPC_FAR *state);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceStateMouse( 
            /* [out][in] */ DIMOUSESTATE_CDESC __RPC_FAR *state);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceStateMouse2( 
            /* [out][in] */ DIMOUSESTATE2_CDESC __RPC_FAR *state);

        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceStateJoystick( 
            /* [out][in] */ DIJOYSTATE_CDESC __RPC_FAR *state);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceStateJoystick2( 
            /* [out][in] */ DIJOYSTATE2_CDESC __RPC_FAR *state);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceState( 
            /* [in] */ long cb,
            /* [in] */ void __RPC_FAR *state);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getObjectInfo( 
            /* [in] */ long obj,
            /* [in] */ long how,
            /* [retval][out] */ I_dxj_DirectInputDeviceObjectInstance __RPC_FAR *__RPC_FAR *ret);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ BSTR guid,
            /* [out] */ void __RPC_FAR *propertyInfo);
        
#ifdef _WIN64
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE runControlPanel( 
	    /* [in] */ HWND hwnd);

	    /* [helpcontext] */ HRESULT STDMETHODCALLTYPE setCooperativeLevel( 
            /* [in] */ HWND hwnd,
            /* [in] */ long flags);
#else
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE runControlPanel( 
	    /* [in] */ long hwnd);

	    /* [helpcontext] */ HRESULT STDMETHODCALLTYPE setCooperativeLevel( 
            /* [in] */ long hwnd,
            /* [in] */ long flags);
#endif
        
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE setCommonDataFormat( 
            /* [in] */ long format);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE setDataFormat( 
            /* [in] */ DIDATAFORMAT_CDESC __RPC_FAR *format,
            SAFEARRAY __RPC_FAR * __RPC_FAR *formatArray);
        
#ifdef _WIN64
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE setEventNotification( 
            /* [in] */ HANDLE hEvent);
#else
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE setEventNotification( 
            /* [in] */ long hEvent);
#endif
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE setProperty( 
            /* [in] */ BSTR guid,
            /* [in] */ void __RPC_FAR *propertyInfo);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE unacquire( void);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE poll( void);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE createEffect( 
            /* [in] */ BSTR effectGuid,
            /* [in] */ DIEFFECT_CDESC __RPC_FAR *effectinfo,
            /* [retval][out] */ I_dxj_DirectInputEffect __RPC_FAR *__RPC_FAR *ret);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE createCustomEffect( 
            /* [in] */ DIEFFECT_CDESC __RPC_FAR *effectinfo,
            /* [in] */ long channels,
            /* [in] */ long samplePeriod,
            /* [in] */ long nSamples,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *sampledata,
            /* [retval][out] */ I_dxj_DirectInputEffect __RPC_FAR *__RPC_FAR *ret);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE sendDeviceData( 
            /* [in] */ long count,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *data,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *retcount);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE sendForceFeedbackCommand( 
            /* [in] */ long flags);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getForceFeedbackState( 
            /* [retval][out] */ long __RPC_FAR *state);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getEffectsEnum( 
            /* [in] */ long effType,
            /* [retval][out] */ I_dxj_DirectInputEnumEffects __RPC_FAR *__RPC_FAR *ret);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BuildActionMap( 
            /* [out][in] */ DIACTIONFORMAT_CDESC __RPC_FAR *format,
            /* [in] */ BSTR username,
            /* [in] */ long flags);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE SetActionMap( 
            /* [out][in] */ DIACTIONFORMAT_CDESC __RPC_FAR *format,
            /* [in] */ BSTR username,
            /* [in] */ long flags);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE GetImageInfo( 
            /* [out] */ DIDEVICEIMAGEINFOHEADER_CDESC __RPC_FAR *info);

        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE GetImageInfoCount( 
			long *count);

        
	 HRESULT STDMETHODCALLTYPE WriteEffectToFile( 
		/*[in]*/ BSTR filename,
		/*[in]*/ long flags,
		/*[in]*/ BSTR guid, 
		/*[in]*/ BSTR name, 
		/*[in]*/ DIEFFECT_CDESC *CoverEffect);

	HRESULT STDMETHODCALLTYPE CreateEffectFromFile(
		/*[in]*/ BSTR filename, 
		/*[in]*/ long flags, 
		/*[in]*/ BSTR effectName,
		/*[out,retval]*/	I_dxj_DirectInputEffect **ret);
        

private:
        DECL_VARIABLE(_dxj_DirectInputDevice8);
	//IDirectInputDevice8 *m__dxj_DirectInputDevice8;	
	HRESULT cleanup();
	HRESULT init();
public:
	DX3J_GLOBAL_LINKS(_dxj_DirectInputDevice8)
	DWORD	nFormat;
};

typedef struct EFFECTSINFILE
{
	char szEffect[MAX_PATH];
	IDirectInputDevice8W 	*pDev;
	IDirectInputEffect 	*pEff;
	HRESULT 		hr;	
} EFFECTSINFILE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dinputdeviceobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dinputdeviceobj.cpp
//
//--------------------------------------------------------------------------




// dDrawColorControlObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dienumDeviceObjectsObj.h"
#include "dIEnumEffectsObj.h"
#include "dInputdeviceObj.h"
#include "dInputEffectObj.h"
#include "didevInstObj.h"
#include "didevObjInstObj.h"


//TODO move to typlib enum
#define dfDIKeyboard  1
#define dfDIMouse     2
#define dfDIJoystick  3
#define dfDIJoystick2 4
#define dfDIMouse2    5

extern HRESULT FixUpCoverEffect(GUID  g, DIEFFECT_CDESC *cover,DIEFFECT *realEffect);
extern HRESULT FixUpRealEffect(GUID g,DIEFFECT *realEffect,DIEFFECT_CDESC *cover);


extern HRESULT DINPUTBSTRtoGUID(LPGUID pGuid,BSTR str);
extern BSTR DINPUTGUIDtoBSTR(LPGUID pg);
extern HRESULT FillRealActionFormat(DIACTIONFORMATW *real, DIACTIONFORMAT_CDESC *cover, SAFEARRAY **actionArray,long ActionCount );
#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }

HRESULT C_dxj_DirectInputDevice8Object::init()
{
	nFormat=0;
	return S_OK;
}
HRESULT C_dxj_DirectInputDevice8Object::cleanup()
{
	return S_OK;
}

CONSTRUCTOR(_dxj_DirectInputDevice8, {init();});
DESTRUCTOR(_dxj_DirectInputDevice8, {cleanup();});

//NOTE get set for Device object
// must use QI to get at other objects.
GETSET_OBJECT(_dxj_DirectInputDevice8);
                                  
   
STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceObjectsEnum( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DIEnumDeviceObjects  **ppret)
{
	HRESULT hr;
	hr=C_dxj_DIEnumDeviceObjectsObject::create(m__dxj_DirectInputDevice8,flags,ppret);
	return hr;
}


STDMETHODIMP C_dxj_DirectInputDevice8Object::acquire(){
	return m__dxj_DirectInputDevice8->Acquire();	
}


STDMETHODIMP C_dxj_DirectInputDevice8Object::getCapabilities(DIDEVCAPS_CDESC *caps)
{
	//DIDevCaps same in VB/Java as in C
	caps->lSize=sizeof(DIDEVCAPS);
	HRESULT hr=m__dxj_DirectInputDevice8->GetCapabilities((DIDEVCAPS*)caps);		
	return hr;
}

//VB cant return sucess codes so we will return an error code
#define VB_DI_BUFFEROVERFLOW 0x80040260
        

STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceData(            
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *deviceObjectDataArray,            
            /* [in] */ long flags,
			long *ret)

{
	HRESULT hr;
	
	if ((*deviceObjectDataArray)->cDims!=1) return E_INVALIDARG;
	if ((*deviceObjectDataArray)->cbElements!=sizeof(DIDEVICEOBJECTDATA)) return E_INVALIDARG;
	
	DWORD dwC= (*deviceObjectDataArray)->rgsabound[0].cElements;

	if (dwC==0) return E_INVALIDARG;
	
	LPDIDEVICEOBJECTDATA  pobjData=(LPDIDEVICEOBJECTDATA)((SAFEARRAY*)*deviceObjectDataArray)->pvData;
	hr=m__dxj_DirectInputDevice8->GetDeviceData(sizeof(DIDEVICEOBJECTDATA), pobjData, (DWORD*)&dwC,flags);		
	
	*ret=dwC;

	if (hr==DI_BUFFEROVERFLOW) hr= VB_DI_BUFFEROVERFLOW;
		

	return hr;
}


STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceInfo(        
            /* [out] */ I_dxj_DirectInputDeviceInstance8 __RPC_FAR **info)
{
	HRESULT hr;


	DIDEVICEINSTANCEW inst;
	ZeroMemory(&inst,sizeof(DIDEVICEINSTANCEW));
	inst.dwSize=sizeof(DIDEVICEINSTANCEW);

	hr=m__dxj_DirectInputDevice8->GetDeviceInfo(&inst);
	if FAILED(hr) return hr;

	hr=C_dxj_DIDeviceInstance8Object::create(&inst,info);
	return hr;


}

STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceStateKeyboard(        
            /* [out] */ DIKEYBOARDSTATE_CDESC __RPC_FAR *state)
{
	HRESULT hr;

	if ((nFormat!= dfDIKeyboard) && (nFormat!=-1)) return DIERR_NOTINITIALIZED    ;

	hr=m__dxj_DirectInputDevice8->GetDeviceState(256,(void*)state->key);	
	
	return hr;
}



        
STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceStateMouse( 
            /* [out] */ DIMOUSESTATE_CDESC __RPC_FAR *state)
{
	HRESULT hr;

	if ((nFormat!= dfDIMouse) && (nFormat!=-1)) return DIERR_NOTINITIALIZED;

	hr=m__dxj_DirectInputDevice8->GetDeviceState(sizeof(DIMOUSESTATE),(void*)state);	
	return hr;
}


        
STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceStateMouse2( 
            /* [out] */ DIMOUSESTATE2_CDESC __RPC_FAR *state)
{
	HRESULT hr;

	if ((nFormat!= dfDIMouse2) && (nFormat!=-1)) return DIERR_NOTINITIALIZED;

	hr=m__dxj_DirectInputDevice8->GetDeviceState(sizeof(DIMOUSESTATE2),(void*)state);	
	return hr;
}
        
STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceStateJoystick( 
            /* [out] */ DIJOYSTATE_CDESC __RPC_FAR *state)
{
	HRESULT hr;

	//note Joystick1 or Joystick2 are valid formats since
	//one is a superset of the other
	if ((nFormat!= dfDIJoystick)&&(nFormat!= dfDIJoystick2) && (nFormat!=-1)) return DIERR_NOTINITIALIZED;
	hr=m__dxj_DirectInputDevice8->GetDeviceState(sizeof(DIJOYSTATE),(void*)state);	
	return hr;
}

STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceStateJoystick2( 
            /* [out] */ DIJOYSTATE2_CDESC __RPC_FAR *state)
{
	HRESULT hr;

	//only for format2
	if ((nFormat!= dfDIJoystick2) && (nFormat!=-1)) return DIERR_NOTINITIALIZED;
	hr=m__dxj_DirectInputDevice8->GetDeviceState(sizeof(DIJOYSTATE2),(void*)state);	
	return hr;
}


STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceState( 
            /* [in] */ long cb,
            /* [in] */ void *pFormat)

{
	HRESULT hr;
	__try {
		hr=m__dxj_DirectInputDevice8->GetDeviceState((DWORD) cb,(void*)pFormat);	
	}
	__except(1,1){
		hr=E_INVALIDARG;
	}
	return hr;
}

STDMETHODIMP C_dxj_DirectInputDevice8Object::getObjectInfo(                         
            /* [in] */ long obj,
            /* [in] */ long how,
				I_dxj_DirectInputDeviceObjectInstance **ret)
{
	

	DIDEVICEOBJECTINSTANCEW inst;
	ZeroMemory(&inst,sizeof(DIDEVICEOBJECTINSTANCEW));
	inst.dwSize=sizeof(DIDEVICEOBJECTINSTANCEW);

	HRESULT hr;
	hr=m__dxj_DirectInputDevice8->GetObjectInfo(&inst,(DWORD) obj,(DWORD)how);
	if FAILED(hr) return hr;
	
	hr=C_dxj_DIDeviceObjectInstanceObject::create(&inst,ret);

	return hr;

	/* DEAD

	//TODO - consider what is going on here carefully
	if (instCover->strGuidType) SysFreeString(instCover->strGuidType);
	if (instCover->strName) SysFreeString(instCover->strName);

	

	//TODO - consider localization	
	if (inst.tszName){
		instCover->strName=T2BSTR(inst.tszName);
	}

	instCover->strGuidType=DINPUTGUIDtoBSTR(&inst.guidType);
	instCover->lOfs=inst.dwOfs;
	instCover->lType=inst.dwType;
	instCover->lFlags=inst.dwFlags;
	
	instCover->lFFMaxForce=inst.dwFFMaxForce;
	instCover->lFFForceResolution=inst.dwFFForceResolution;
	instCover->nCollectionNumber=inst.wCollectionNumber;
	instCover->nDesignatorIndex=inst.wDesignatorIndex;
	instCover->nUsagePage=inst.wUsagePage;
	instCover->nUsage=inst.wUsage;
	instCover->lDimension=inst.dwDimension;
	instCover->nExponent=inst.wExponent;
	instCover->nReserved=inst.wReserved;
	
	return hr;
	*/
}


 
        
STDMETHODIMP C_dxj_DirectInputDevice8Object::runControlPanel( 
#ifdef _WIN64
									/* [in] */ HWND hwnd)
#else
									/* [in] */ long hwnd)
#endif
{
	HRESULT hr;
        hr=m__dxj_DirectInputDevice8->RunControlPanel((HWND) hwnd,(DWORD)0); 
	return hr;
}

STDMETHODIMP C_dxj_DirectInputDevice8Object::setCooperativeLevel( 
#ifdef _WIN64
            /* [in] */ HWND hwnd,
#else
            /* [in] */ long hwnd,
#endif
            /* [in] */ long flags)
{
	HRESULT hr;
        hr=m__dxj_DirectInputDevice8->SetCooperativeLevel((HWND) hwnd,(DWORD)flags); 
	return hr;
}
    
STDMETHODIMP C_dxj_DirectInputDevice8Object::poll()
{
	HRESULT hr;
	hr=m__dxj_DirectInputDevice8->Poll();	
	return hr;
}





    
STDMETHODIMP C_dxj_DirectInputDevice8Object::setCommonDataFormat( 
            /* [in] */ long format)
{
	//variant so that when structs can be packed in VARIANTS we can take care of it
	HRESULT hr;
	
	//	c_dfDIKeyboard 
	//	c_dfDIMouse 
	//	c_dfDIJoystick
	//	c_dfDIJoystick2
	nFormat=format;

	switch(format){
		case dfDIKeyboard:
			hr=m__dxj_DirectInputDevice8->SetDataFormat(&c_dfDIKeyboard);
			break;
		case dfDIMouse:
			hr=m__dxj_DirectInputDevice8->SetDataFormat(&c_dfDIMouse);
			break;
		case dfDIJoystick:
			hr=m__dxj_DirectInputDevice8->SetDataFormat(&c_dfDIJoystick);
			break;
		case dfDIJoystick2:
			hr=m__dxj_DirectInputDevice8->SetDataFormat(&c_dfDIJoystick2);
			break;
		case dfDIMouse2:
			hr=m__dxj_DirectInputDevice8->SetDataFormat(&c_dfDIMouse2);
			break;

		default:
			return E_INVALIDARG;
	}

		
	return hr;
}
        		

STDMETHODIMP C_dxj_DirectInputDevice8Object::setDataFormat( 
            /* [in] */ DIDATAFORMAT_CDESC __RPC_FAR *format,
            SAFEARRAY __RPC_FAR * __RPC_FAR *formatArray)
{
	HRESULT		   hr;
	LPDIDATAFORMAT pFormat=(LPDIDATAFORMAT)format;
	GUID		   *pGuid = NULL;
	GUID		   *pGuidArray = NULL;
	DIOBJECTDATAFORMAT_CDESC	*pDiDataFormat=NULL;


	if ((!format) || (!formatArray)) 
	{
		DPF(1,"------ DXVB: Nothing passed in.. \n");
		return E_INVALIDARG;
	}

	if  (((SAFEARRAY*)*formatArray)->cDims != 1)
	{
		return E_INVALIDARG;
	}
	if (((SAFEARRAY*)*formatArray)->rgsabound[0].cElements < pFormat->dwNumObjs)
	{
		return E_INVALIDARG;
	}

	__try {
		pFormat->dwSize=sizeof(DIDATAFORMAT);
		pFormat->rgodf = NULL;
		pFormat->rgodf = new DIOBJECTDATAFORMAT[pFormat->dwNumObjs];
		
		if (!pFormat->rgodf) 
		{
			DPF(1,"------ DXVB: Out of memory (pFormat->rgodf) \n");
			return E_OUTOFMEMORY;
		}

		pGuidArray=new GUID[pFormat->dwNumObjs];
		if (!pGuidArray){
			DPF(1,"------ DXVB: Out of memory (pGuidArray), Freeing pFormat->rgodf \n");
			SAFE_DELETE(pFormat->rgodf);
			return E_OUTOFMEMORY;
		}

		for (DWORD i=0; i< pFormat->dwNumObjs;i++){
			DPF1(1,"------ DXVB: Filling array item %d \n",i);
			pGuid=&(pGuidArray[i]);
			pDiDataFormat=&(((DIOBJECTDATAFORMAT_CDESC*)((SAFEARRAY*)*formatArray)->pvData)[i]);
			hr=DINPUTBSTRtoGUID(pGuid, pDiDataFormat->strGuid);
			if FAILED(hr) {
				DPF(1,"------ DXVB: DInputBstrToGuid Failed, free memory \n");
				SAFE_DELETE(pGuidArray);
				SAFE_DELETE(pFormat->rgodf);
				pFormat->rgodf=NULL;
				return hr;
			}		
			pFormat->rgodf[i].pguid=pGuid;
			pFormat->rgodf[i].dwOfs=pDiDataFormat->lOfs;
			pFormat->rgodf[i].dwType=pDiDataFormat->lType;
			pFormat->rgodf[i].dwFlags=pDiDataFormat->lFlags;
		}
		DPF(1,"------ DXVB: Call SetDataFormat \n");
		hr=m__dxj_DirectInputDevice8->SetDataFormat(pFormat);
		DPF(1,"------ DXVB: Free Memory \n");

		SAFE_DELETE(pGuidArray);
		SAFE_DELETE(pFormat->rgodf);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		SAFE_DELETE(pGuidArray);
		SAFE_DELETE(pFormat->rgodf);
		return E_INVALIDARG;
	}	


	//indicate we have a custom format
	nFormat=-1;

	return hr;

}
        

#ifdef _WIN64
STDMETHODIMP C_dxj_DirectInputDevice8Object::setEventNotification( 
            /* [in] */ HANDLE hEvent)
#else
STDMETHODIMP C_dxj_DirectInputDevice8Object::setEventNotification( 
            /* [in] */ long hEvent)
#endif
{

	HRESULT hr=m__dxj_DirectInputDevice8->SetEventNotification((HANDLE)hEvent);	
	return hr;
}










//  NOTE: - current working implemtation promotes
//			code bloat
//			might want to revist this and do it in a more
//			tidy fasion
//        
STDMETHODIMP C_dxj_DirectInputDevice8Object::getProperty( 
            /* [in] */ BSTR str,
            /* [out] */ void __RPC_FAR *propertyInfo)
{

	HRESULT hr;		


	if (!propertyInfo) return E_INVALIDARG;

	DIPROPDWORD dipdw;	
	DIPROPRANGE dipr;
	DIPROPSTRING dips;
	
	//For bug #41819
	DIPROPGUIDANDPATH	dipgap;
	DIPROPCPOINTS		dipcp;
	DIPROPPOINTER		dipp;
	//End bug #41819

	dipdw.diph.dwSize=sizeof(DIPROPDWORD);
	dipdw.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipdw.diph.dwObj=((DIPROPLONG_CDESC*)propertyInfo)->lObj;
	dipdw.diph.dwHow=((DIPROPLONG_CDESC*)propertyInfo)->lHow;

	dipr.diph.dwSize=sizeof(DIPROPRANGE);
	dipr.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipr.diph.dwObj=((DIPROPLONG_CDESC*)propertyInfo)->lObj;
	dipr.diph.dwHow=((DIPROPLONG_CDESC*)propertyInfo)->lHow;

	dips.diph.dwSize=sizeof(DIPROPSTRING);
	dips.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dips.diph.dwObj=((DIPROPSTRING_CDESC *)propertyInfo)->lObj;
	dips.diph.dwHow=((DIPROPSTRING_CDESC *)propertyInfo)->lHow;


	//For bug #41819
	dipgap.diph.dwSize=sizeof(DIPROPGUIDANDPATH);
	dipgap.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipgap.diph.dwObj=0;
	dipgap.diph.dwHow=((DIPROPLONG_CDESC *)propertyInfo)->lHow;
	
	dipcp.diph.dwSize=sizeof(DIPROPCPOINTS);
	dipcp.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipcp.diph.dwObj=((DIPROPLONG_CDESC *)propertyInfo)->lObj;
	dipcp.diph.dwHow=((DIPROPLONG_CDESC *)propertyInfo)->lHow;

	dipp.diph.dwSize=sizeof(DIPROPPOINTER);
	dipp.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipp.diph.dwObj=((DIPROPLONG_CDESC *)propertyInfo)->lObj;
	dipp.diph.dwHow=((DIPROPLONG_CDESC *)propertyInfo)->lHow;
	//End bug #41819

	
	if( 0==_wcsicmp(str,L"diprop_buffersize")){
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_BUFFERSIZE,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if( 0==_wcsicmp(str,L"diprop_axismode")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_AXISMODE,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if( 0==_wcsicmp(str,L"diprop_granularity")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_GRANULARITY,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;

	}

	//else if( 0==_wcsicmp(str,L"diprop_getlogicalrange")){			
	//		hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_GETLOGICALRANGE,(DIPROPHEADER*)&dipr);
	//		((DIPROPRANGE_CDESC*)propertyInfo)->lMin=(long)dipdw.lMin;
	//		((DIPROPRANGE_CDESC*)propertyInfo)->lMax=(long)dipdw.lMax;
	//}

	//else if( 0==_wcsicmp(str,L"diprop_getlogicalrange")){			
	//		hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_GETPHYSICALLRANGE,(DIPROPHEADER*)&dipr);
	//		((DIPROPRANGE_CDESC*)propertyInfo)->lMin=(long)dipdw.lMin;
	//		((DIPROPRANGE_CDESC*)propertyInfo)->lMax=(long)dipdw.lMax;
	//}

	else if( 0==_wcsicmp(str,L"diprop_range")){
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_RANGE,(DIPROPHEADER*)&dipr);
			((DIPROPRANGE_CDESC*)propertyInfo)->lMin=(long)dipr.lMin;
			((DIPROPRANGE_CDESC*)propertyInfo)->lMax=(long)dipr.lMax;
	}
	else if( 0==_wcsicmp(str,L"diprop_deadzone")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_DEADZONE,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if( 0==_wcsicmp(str,L"diprop_ffgain")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_FFGAIN,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if( 0==_wcsicmp(str,L"diprop_ffload")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_FFLOAD,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if( 0==_wcsicmp(str,L"diprop_getportdisplayname")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_GETPORTDISPLAYNAME,(DIPROPHEADER*)&dips);
			if FAILED(hr) return hr;
			((DIPROPSTRING_CDESC*)propertyInfo)->PropString=SysAllocString(dips.wsz);
	}
	else if( 0==_wcsicmp(str,L"diprop_instancename")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_INSTANCENAME,(DIPROPHEADER*)&dips);
			if FAILED(hr) return hr;
			((DIPROPSTRING_CDESC*)propertyInfo)->PropString=SysAllocString(dips.wsz);
	}
	else if( 0==_wcsicmp(str,L"diprop_keyname")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_KEYNAME,(DIPROPHEADER*)&dips);
			if FAILED(hr) return hr;
			((DIPROPSTRING_CDESC*)propertyInfo)->PropString=SysAllocString(dips.wsz);
	}
	else if( 0==_wcsicmp(str,L"diprop_productname")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_PRODUCTNAME,(DIPROPHEADER*)&dips);
			if FAILED(hr) return hr;
			((DIPROPSTRING_CDESC*)propertyInfo)->PropString=SysAllocString(dips.wsz);
	}
	else if( 0==_wcsicmp(str,L"diprop_username")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_USERNAME,(DIPROPHEADER*)&dips);
			if FAILED(hr) return hr;
			((DIPROPSTRING_CDESC*)propertyInfo)->PropString=SysAllocString(dips.wsz);
	}

	else if( 0==_wcsicmp(str,L"diprop_saturation")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_SATURATION,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if( 0==_wcsicmp(str,L"diprop_scancode")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_SCANCODE,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if( 0==_wcsicmp(str,L"diprop_autocenter")){		
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_AUTOCENTER,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if( 0==_wcsicmp(str,L"diprop_joystickid")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_JOYSTICKID,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	
	
//Added for bug #41819

	else if(0==_wcsicmp(str, L"diprop_calibration")){
		hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_CALIBRATION,(DIPROPHEADER*)&dipdw);
		if (hr == S_OK) ((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if (0==_wcsicmp(str, L"diprop_guidandpath")){
		hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_GUIDANDPATH,(DIPROPHEADER*)&dipgap);
		if (hr == S_OK)
		{
			((DIPROPGUIDANDPATH_CDESC*)propertyInfo)->Guid=DINPUTGUIDtoBSTR(&dipgap.guidClass);
			((DIPROPGUIDANDPATH_CDESC*)propertyInfo)->Path=SysAllocString(dipgap.wszPath);
		}
	}
	else if (0==_wcsicmp(str, L"diprop_physicalrange")){
		hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_PHYSICALRANGE,(DIPROPHEADER*)&dipr);
		if (hr == S_OK)
		{
			((DIPROPRANGE_CDESC*)propertyInfo)->lMin=(long)dipr.lMin;
			((DIPROPRANGE_CDESC*)propertyInfo)->lMax=(long)dipr.lMax;
		}
	}
	else if( 0==_wcsicmp(str,L"diprop_logicalrange")){			
		hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_LOGICALRANGE,(DIPROPHEADER*)&dipr);
		if (hr == S_OK)
		{
			((DIPROPRANGE_CDESC*)propertyInfo)->lMin=(long)dipr.lMin;
			((DIPROPRANGE_CDESC*)propertyInfo)->lMax=(long)dipr.lMax;
		}
	}
	else if( 0==_wcsicmp(str,L"diprop_cpoints")){			
		hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_CPOINTS,(DIPROPHEADER*)&dipcp);
		if (hr == S_OK)
		{
			((DIPROPCPOINTS_CDESC*)propertyInfo)->dwCPointsNum=(long)dipcp.dwCPointsNum;			

			__try{
				memcpy( (void*) (((DIPROPCPOINTS_CDESC*)propertyInfo)->cp), (void*)dipcp.cp, sizeof(CPOINT_CDESC) * dipcp.dwCPointsNum);
			}
			__except(1,1){
				return E_INVALIDARG;
			}
		}
	}

	else if(0==_wcsicmp(str,L"diprop_appdata")){
		hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_APPDATA,(DIPROPHEADER*)&dipp);	
		if (hr == S_OK)
		{
			if FAILED(hr) return hr;
			((DIPROPPOINTER_CDESC*)propertyInfo)->uData=(long)dipp.uData;
		}
	}
	
//End bug #41819

	else { 
			DPF(1, "DXVB: Invalid arguments passed in.\n");
			return E_INVALIDARG;
	}

	/*
	__try{
		((DIPROPHEADER*)propertyInfo)->dwHeaderSize=sizeof(DIPROPHEADER);	
		hr=m__dxj_DirectInputDevice8->GetProperty((REFGUID)g,(DIPROPHEADER*)propertyInfo);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	*/
	
	if (FAILED(hr))	{
		DPF1(1, "DXVB: GetProperty returned: %d \n", hr);
	}

	return hr;
}



STDMETHODIMP C_dxj_DirectInputDevice8Object::setProperty( 
            /* [in] */ BSTR __RPC_FAR str,
            /* [out] */ void __RPC_FAR *propertyInfo)
{

	if (!propertyInfo) return E_INVALIDARG;

	HRESULT hr;			
	DIPROPDWORD dipdw;
	dipdw.diph.dwSize=sizeof(DIPROPDWORD);
	dipdw.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipdw.diph.dwObj=((DIPROPLONG_CDESC*)propertyInfo)->lObj;
	dipdw.diph.dwHow=((DIPROPLONG_CDESC*)propertyInfo)->lHow;

	DIPROPSTRING dips;
	dips.diph.dwSize=sizeof(DIPROPSTRING);
	dips.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dips.diph.dwObj=((DIPROPSTRING_CDESC *)propertyInfo)->lObj;
	dips.diph.dwHow=((DIPROPSTRING_CDESC *)propertyInfo)->lHow;
		
	DIPROPRANGE dipr;
	dipr.diph.dwSize=sizeof(DIPROPRANGE);
	dipr.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipr.diph.dwObj=((DIPROPLONG_CDESC*)propertyInfo)->lObj;
	dipr.diph.dwHow=((DIPROPLONG_CDESC*)propertyInfo)->lHow;
	

//Added for bug #41819
	DIPROPPOINTER dipp;
	dipp.diph.dwSize=sizeof(DIPROPPOINTER);
	dipp.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipp.diph.dwObj=((DIPROPLONG_CDESC*)propertyInfo)->lObj;
	dipp.diph.dwHow=((DIPROPLONG_CDESC*)propertyInfo)->lHow;

	DIPROPCPOINTS dipcp;
	dipcp.diph.dwSize=sizeof(DIPROPCPOINTS);
	dipcp.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipcp.diph.dwObj=((DIPROPLONG_CDESC*)propertyInfo)->lObj;
	dipcp.diph.dwHow=((DIPROPLONG_CDESC*)propertyInfo)->lHow;
//End bug #41819

	if( 0==_wcsicmp(str,L"diprop_buffersize")){
		dipdw.dwData=((DIPROPLONG_CDESC*)propertyInfo)->lData;
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_BUFFERSIZE,(DIPROPHEADER*)&dipdw);
	}
	else if( 0==_wcsicmp(str,L"diprop_axismode")){
		dipdw.dwData=((DIPROPLONG_CDESC*)propertyInfo)->lData;
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_AXISMODE,(DIPROPHEADER*)&dipdw);		
	}
	else if( 0==_wcsicmp(str,L"diprop_range")){
		dipr.lMin=((DIPROPRANGE_CDESC*)propertyInfo)->lMin;
		dipr.lMax=((DIPROPRANGE_CDESC*)propertyInfo)->lMax;

		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_RANGE,(DIPROPHEADER*)&dipr);		
	}
	else if( 0==_wcsicmp(str,L"diprop_deadzone")){
		dipdw.dwData=((DIPROPLONG_CDESC*)propertyInfo)->lData;
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_DEADZONE,(DIPROPHEADER*)&dipdw);		
	}
	else if( 0==_wcsicmp(str,L"diprop_ffgain")){
		dipdw.dwData=((DIPROPLONG_CDESC*)propertyInfo)->lData;
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_FFGAIN,(DIPROPHEADER*)&dipdw);		
	}
	else if( 0==_wcsicmp(str,L"diprop_saturation")){
		dipdw.dwData=((DIPROPLONG_CDESC*)propertyInfo)->lData;
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_SATURATION,(DIPROPHEADER*)&dipdw);		
	}
	else if( 0==_wcsicmp(str,L"diprop_autocenter")){
		dipdw.dwData=((DIPROPLONG_CDESC*)propertyInfo)->lData;
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_AUTOCENTER,(DIPROPHEADER*)&dipdw);		
	}
	else if( 0==_wcsicmp(str,L"diprop_calibrationmode")){
		dipdw.dwData=((DIPROPLONG_CDESC*)propertyInfo)->lData;
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_CALIBRATIONMODE,(DIPROPHEADER*)&dipdw);		
	}

//Added for bug #41819

	else if( 0==_wcsicmp(str,L"diprop_appdata")){
		dipp.uData=((DIPROPPOINTER_CDESC *)propertyInfo)->uData;
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_APPDATA,(DIPROPHEADER*)&dipp);		
	}
	else if( 0==_wcsicmp(str,L"diprop_instancename")){
		wcscpy(dips.wsz,((DIPROPSTRING_CDESC *)propertyInfo)->PropString);
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_INSTANCENAME,(DIPROPHEADER*)&dips);		
	}
	else if( 0==_wcsicmp(str,L"diprop_productname")){
		wcscpy(dips.wsz, ((DIPROPSTRING_CDESC *)propertyInfo)->PropString);
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_PRODUCTNAME,(DIPROPHEADER*)&dips);		
	}
	else if( 0==_wcsicmp(str,L"diprop_cpoints")){
		dipcp.dwCPointsNum=((DIPROPCPOINTS_CDESC *)propertyInfo)->dwCPointsNum;
		__try{
			memcpy( (void*)dipcp.cp, (void*)((DIPROPCPOINTS_CDESC*)propertyInfo)->cp, sizeof(CPOINT_CDESC) * MAXCPOINTSNUM);
		}
		__except(1,1){
			DPF(1, "Invalid arguments passed in.\n");
			return E_INVALIDARG;
		}

		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_CPOINTS,(DIPROPHEADER*)&dipcp);		
	}
//End bug #41819

	else { 
		DPF(1, "Invalid arguments passed in.\n");
		return E_INVALIDARG;		
	}

	/*
	__try {
		((DIPROPHEADER*)propertyInfo)->dwHeaderSize=sizeof(DIPROPHEADER);
		hr=m__dxj_DirectInputDevice8->SetProperty((REFGUID)g,(DIPROPHEADER*)propertyInfo);
	}
	__except (1,1){
		return E_INVALIDARG;
	}
	*/
	if (FAILED(hr))	{
		DPF1(1, "DXVB: SetProperty returned: %d \n", hr);
	}
	return hr;
}


STDMETHODIMP C_dxj_DirectInputDevice8Object::unacquire()
{
	HRESULT hr=m__dxj_DirectInputDevice8->Unacquire();	
	return hr;
}
        



STDMETHODIMP C_dxj_DirectInputDevice8Object::createEffect( 
            /* [in] */ BSTR effectGuid,
            /* [in] */ DIEFFECT_CDESC __RPC_FAR *effectInfo,
            /* [retval][out] */ I_dxj_DirectInputEffect __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	GUID g;
	
	DIEFFECT realEffect;
	LPDIRECTINPUTEFFECT pRealEffect=NULL;

	hr=DINPUTBSTRtoGUID(&g,effectGuid);
	if FAILED(hr) return hr;

	hr=FixUpRealEffect(g,&realEffect,effectInfo);
	if FAILED(hr) return hr;

	hr=m__dxj_DirectInputDevice8->CreateEffect(g,&realEffect,&pRealEffect,NULL);
	if FAILED(hr) return hr;	

	INTERNAL_CREATE(_dxj_DirectInputEffect,pRealEffect,ret)

	return hr;
}

STDMETHODIMP C_dxj_DirectInputDevice8Object::createCustomEffect( 
            /* [in] */ DIEFFECT_CDESC __RPC_FAR *effectInfo,
            /* [in] */ long channels,
            /* [in] */ long samplePeriod,
            /* [in] */ long nSamples,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *sampledata,
            /* [retval][out] */ I_dxj_DirectInputEffect __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	GUID g=GUID_CustomForce;
	
	DIEFFECT realEffect;
	LPDIRECTINPUTEFFECT pRealEffect=NULL;

	hr=FixUpRealEffect(g,&realEffect,effectInfo);
	if FAILED(hr) return hr;

	
	DICUSTOMFORCE customData;
	customData.cChannels =(DWORD)channels;
	customData.cSamples  =(DWORD)nSamples; 
	customData.dwSamplePeriod =(DWORD)samplePeriod;
	customData.rglForceData = (long*)(*sampledata)->pvData;
	
	realEffect.lpvTypeSpecificParams=&customData;
	realEffect.cbTypeSpecificParams=sizeof(DICUSTOMFORCE);
	
	__try {
		hr=m__dxj_DirectInputDevice8->CreateEffect(g,&realEffect,&pRealEffect,NULL);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	if FAILED(hr) return hr;	

	INTERNAL_CREATE(_dxj_DirectInputEffect,pRealEffect,ret)

	return hr;
}



        
STDMETHODIMP C_dxj_DirectInputDevice8Object::sendDeviceData( 
            /* [in] */ long count,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *data,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *retcount)
{
	DWORD dwCount=count;
	HRESULT hr;
    __try {
		hr=m__dxj_DirectInputDevice8->SendDeviceData(
			sizeof(DIDEVICEOBJECTDATA),
			(DIDEVICEOBJECTDATA*)(*data)->pvData,
			&dwCount,
			(DWORD)flags);

	}
	__except(1,1){
		return E_INVALIDARG;
	}
	return hr;
}    

STDMETHODIMP C_dxj_DirectInputDevice8Object::sendForceFeedbackCommand( 
            /* [in] */ long flags) 
{
	HRESULT hr;
	hr=m__dxj_DirectInputDevice8->SendForceFeedbackCommand((DWORD)flags);
	return hr;
}
        
STDMETHODIMP C_dxj_DirectInputDevice8Object::getForceFeedbackState( 
            /* [retval][out] */ long __RPC_FAR *state)
{
	if (!state) return E_INVALIDARG;
	HRESULT hr;
	hr=m__dxj_DirectInputDevice8->GetForceFeedbackState((DWORD*)state);
	return hr;

}

STDMETHODIMP C_dxj_DirectInputDevice8Object::getEffectsEnum( long effType,
			I_dxj_DirectInputEnumEffects **ret)
{
	HRESULT hr=C_dxj_DirectInputEnumEffectsObject::create(m__dxj_DirectInputDevice8,effType,ret);
	return hr;
}



   
STDMETHODIMP C_dxj_DirectInputDevice8Object::BuildActionMap( 
            /* [out][in] */ DIACTIONFORMAT_CDESC __RPC_FAR *format,
		BSTR userName,
            /* [in] */ long flags)

{
	HRESULT hr;
	DIACTIONFORMATW frmt;
	hr=FillRealActionFormat(&frmt, format, &(format->ActionArray), format->lActionCount);
	
	if FAILED(hr) return hr;

	hr=m__dxj_DirectInputDevice8->BuildActionMap(&frmt,(WCHAR*)userName,(DWORD) flags);
	return hr;

}
        
STDMETHODIMP C_dxj_DirectInputDevice8Object::SetActionMap( 
            /* [out][in] */ DIACTIONFORMAT_CDESC __RPC_FAR *format,
            /* [in] */ BSTR username,
            /* [in] */ long flags) 
{
	HRESULT hr;
	DIACTIONFORMATW frmt;

	
	hr=FillRealActionFormat(&frmt, format, &(format->ActionArray), format->lActionCount);
	if FAILED(hr) return hr;

	hr=m__dxj_DirectInputDevice8->SetActionMap(&frmt,(LPWSTR) username,(DWORD) flags);
	return hr;

}


STDMETHODIMP C_dxj_DirectInputDevice8Object::GetImageInfoCount( 
		long *retCount)
{
	HRESULT hr;

	DIDEVICEIMAGEINFOHEADERW RealHeader;
	ZeroMemory(&RealHeader,sizeof(DIDEVICEIMAGEINFOHEADERW));
	RealHeader.dwSize= sizeof(DIDEVICEIMAGEINFOHEADERW);
	RealHeader.dwSizeImageInfo= sizeof(DIDEVICEIMAGEINFOW);

	//figure out how big to make our buffer
	hr=m__dxj_DirectInputDevice8->GetImageInfo(&RealHeader);
	if FAILED(hr) return hr;

	*retCount=RealHeader.dwBufferUsed / sizeof(DIDEVICEIMAGEINFOW);
	return S_OK;
}

STDMETHODIMP C_dxj_DirectInputDevice8Object::GetImageInfo( 
            /* [out] */ DIDEVICEIMAGEINFOHEADER_CDESC __RPC_FAR *info)
{
	HRESULT hr;

	if (!info) return E_INVALIDARG;
	DIDEVICEIMAGEINFOHEADERW RealHeader;
	ZeroMemory(&RealHeader,sizeof(DIDEVICEIMAGEINFOHEADERW));
	RealHeader.dwSize= sizeof(DIDEVICEIMAGEINFOHEADERW);
	RealHeader.dwSizeImageInfo= sizeof(DIDEVICEIMAGEINFOW);

	//figure out how big to make our buffer
	hr=m__dxj_DirectInputDevice8->GetImageInfo(&RealHeader);
	if FAILED(hr) return hr;
		
	//allocate the buffer
	RealHeader.lprgImageInfoArray =(DIDEVICEIMAGEINFOW*)malloc(RealHeader.dwBufferSize);
	if (!RealHeader.lprgImageInfoArray) return E_OUTOFMEMORY;	


	//TODO validate that the safe array passed to us is large enough

	info->ImageCount =RealHeader.dwBufferSize / sizeof(DIDEVICEIMAGEINFOW);

	if (info->Images->rgsabound[0].cElements <	(DWORD)info->ImageCount)
	{
		free(RealHeader.lprgImageInfoArray);
		return E_INVALIDARG;
	}
	for (long i =0 ;i<info->ImageCount;i++)
	{
		DIDEVICEIMAGEINFO_CDESC *pInfo=&( ( (DIDEVICEIMAGEINFO_CDESC*)  (info->Images->pvData) )[i]);
		DIDEVICEIMAGEINFOW 	*pRealInfo= &(RealHeader.lprgImageInfoArray[i]);
		pInfo->ImagePath=SysAllocString(pRealInfo->tszImagePath);
		pInfo->Flags=		(long)pRealInfo->dwFlags;
		pInfo->ViewID=		(long)pRealInfo->dwViewID;
		pInfo->ObjId=		(long)pRealInfo->dwObjID;
		pInfo->ValidPts=	(long)pRealInfo->dwcValidPts;
		pInfo->TextAlign=	(long)pRealInfo->dwTextAlign;
		

		memcpy(&(pInfo->OverlayRect),&(pRealInfo->rcOverlay),sizeof(RECT));
		memcpy(&(pInfo->CalloutLine[0]),&(pRealInfo->rgptCalloutLine[0]),sizeof(POINT)*5);
		memcpy(&(pInfo->CalloutRect),&(pRealInfo->rcCalloutRect),sizeof(RECT));
	}

	info->Views=RealHeader.dwcViews;
	info->Buttons=RealHeader.dwcButtons;
	info->Axes=RealHeader.dwcAxes;
	info->POVs=RealHeader.dwcPOVs;
			
	free(RealHeader.lprgImageInfoArray);

	return S_OK;
}



BOOL CALLBACK DIEnumEffectsInFileCallback( LPCDIFILEEFFECT lpDiFileEf, LPVOID pvRef)
{
	HRESULT hr;

	EFFECTSINFILE *pData=(EFFECTSINFILE*)pvRef;

	if (0==lstrcmp(lpDiFileEf->szFriendlyName,pData->szEffect))
	{
		pData->hr=pData->pDev->CreateEffect(
			lpDiFileEf->GuidEffect,
			lpDiFileEf->lpDiEffect,
			&pData->pEff,
			NULL);

		return DIENUM_STOP;
	}

	return DIENUM_CONTINUE;
}

STDMETHODIMP C_dxj_DirectInputDevice8Object::CreateEffectFromFile(
		BSTR filename,
		long flags,
		BSTR effectName,
		I_dxj_DirectInputEffect **ret)
{
	HRESULT hr;
	USES_CONVERSION;
	EFFECTSINFILE data;
	ZeroMemory(&data,sizeof(EFFECTSINFILE));

	data.hr=E_INVALIDARG;	//returned if we dont find the file
	data.pDev=m__dxj_DirectInputDevice8;
	
	if (!effectName) return E_INVALIDARG;
	if (effectName[0]==0) return E_INVALIDARG;

	ZeroMemory(data.szEffect,sizeof(MAX_PATH));
	char *szOut = NULL;
	__try { szOut=W2T(effectName); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	strcpy (data.szEffect, szOut);

	hr=m__dxj_DirectInputDevice8->EnumEffectsInFile((WCHAR*)filename,DIEnumEffectsInFileCallback,(void*)&data ,(DWORD)flags);
	if FAILED(hr) return hr;
	if FAILED(data.hr) return data.hr;

	INTERNAL_CREATE(_dxj_DirectInputEffect,data.pEff,ret);

	return hr;
}

        
STDMETHODIMP C_dxj_DirectInputDevice8Object::WriteEffectToFile( 
		BSTR filename, long flags, BSTR guid,BSTR name, DIEFFECT_CDESC *CoverEffect)
{

	USES_CONVERSION;

	
	HRESULT hr;
	DIEFFECT RealEffect;
	DIFILEEFFECT FileEffect;

	if (!filename) return E_INVALIDARG;
	if (!guid) return E_INVALIDARG;
	if (!name) return E_INVALIDARG;
	
	FileEffect.dwSize=sizeof(DIFILEEFFECT);	
	FileEffect.lpDiEffect=&RealEffect;

	ZeroMemory(FileEffect.szFriendlyName,sizeof(MAX_PATH));
	char *szOut = NULL;
	__try { szOut=W2T(name); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	strcpy (FileEffect.szFriendlyName, szOut);
	

	hr=DINPUTBSTRtoGUID(&FileEffect.GuidEffect,guid);
	if FAILED(hr) return hr;

	hr=FixUpRealEffect(FileEffect.GuidEffect,&RealEffect,CoverEffect);
	if FAILED(hr) return hr;

	hr=m__dxj_DirectInputDevice8->WriteEffectToFile(
		 (WCHAR*) filename,
		  1,
		  &FileEffect,
		  (DWORD) flags);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmcomposerobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmcomposerobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmChordMapObj.h"
#include "dmStyleObj.h"
#include "dmComposerObj.h"
#include "dmSegmentObj.h"

extern void *g_dxj_DirectMusicComposer;
extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicChordMap;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicComposer, {});
DESTRUCTOR(_dxj_DirectMusicComposer, {});
GETSET_OBJECT(_dxj_DirectMusicComposer);

typedef IDirectMusicSegment*		LPDIRECTMUSICSEGMENT;
typedef IDirectMusicPerformance*	LPDIRECTMUSICPERFORMANCE;
typedef IDirectMusicChordMap*		LPDIRECTMUSICCHORDMAP;
typedef IDirectMusicStyle*			LPDIRECTMUSICSTYLE;

HRESULT C_dxj_DirectMusicComposerObject::autoTransition( 
        /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *Performance,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *ToSeg,
        /* [in] */ long lCommand,
        /* [in] */ long lFlags,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ppTransSeg)
{
	HRESULT hr;			
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPERFORMANCE, pPerf,Performance);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pToSeg,ToSeg);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,chordmap);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->AutoTransition(pPerf,pToSeg,(WORD)lCommand,(DWORD)lFlags,pMap,&pNewSeg,NULL,NULL);
	if FAILED(hr) return hr;
	if (pNewSeg)	{
		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,ppTransSeg);
	}
	else{
		*ppTransSeg=NULL;
	}

	return hr;
}

HRESULT C_dxj_DirectMusicComposerObject::composeSegmentFromTemplate( 
		/* [in] */ I_dxj_DirectMusicStyle __RPC_FAR *style,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *TemplateSeg,
        /* [in] */ short activity,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg)
{
	HRESULT hr;		
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSTYLE, pStyle,style);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pTemp,TemplateSeg);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,chordmap);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->ComposeSegmentFromTemplate(pStyle,pTemp,activity,pMap,&pNewSeg);
	if FAILED(hr) return hr;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,SectionSeg);

	return hr;
}

HRESULT C_dxj_DirectMusicComposerObject::composeSegmentFromShape( 
        /* [in] */ I_dxj_DirectMusicStyle __RPC_FAR *style,
        /* [in] */ short numberOfMeasures,
        /* [in] */ short shape,
        /* [in] */ short activity,
        /* [in] */ VARIANT_BOOL bIntro,
        /* [in] */ VARIANT_BOOL bEnd,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg)
{
	HRESULT hr;	
	
	BOOL bi= (bIntro==VARIANT_TRUE);
	BOOL be= (bEnd==VARIANT_TRUE);

	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSTYLE, pStyle,style);	
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,chordmap);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->ComposeSegmentFromShape(pStyle,numberOfMeasures,shape,activity,bi,be,pMap,&pNewSeg);
	if FAILED(hr) return hr;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,SectionSeg);

	return hr;
}



HRESULT C_dxj_DirectMusicComposerObject::composeTransition( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *FromSeg,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *ToSeg,
        /* [in] */ long mtTime,
        /* [in] */ long lCommand,
        /* [in] */ long lFlags,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg)
{
	HRESULT hr;		
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pFromSeg,FromSeg);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pToSeg,ToSeg);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,chordmap);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->ComposeTransition(pFromSeg,pToSeg,(MUSIC_TIME)mtTime,(WORD)lCommand,(DWORD)lFlags,pMap,&pNewSeg);
	if FAILED(hr) return hr;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,SectionSeg);

	return hr;
}
    


HRESULT C_dxj_DirectMusicComposerObject::composeTemplateFromShape( 
        /* [in] */ short numMeasures,
        /* [in] */ short shape,
        /* [in] */ VARIANT_BOOL bIntro,
        /* [in] */ VARIANT_BOOL bEnd,
        /* [in] */ short endLength,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *TempSeg)
{
	HRESULT hr;		
	BOOL bi=(bIntro==VARIANT_TRUE);
	BOOL be=(bEnd==VARIANT_TRUE);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->ComposeTemplateFromShape(numMeasures,shape,bi,be,endLength,&pNewSeg);
	if FAILED(hr) return hr;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,TempSeg);

	return hr;
}
        


HRESULT C_dxj_DirectMusicComposerObject::changeChordMap( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ VARIANT_BOOL trackScale,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR  *ChordMap)
{
	HRESULT hr;		
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pSeg,segment);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,ChordMap);
	BOOL bs=(trackScale==VARIANT_TRUE);	

	
	hr=m__dxj_DirectMusicComposer->ChangeChordMap(pSeg,bs,pMap);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmbandobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmbandobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmSegmentObj.h"
#include "dmPerformanceObj.h"
#include "dmBandObj.h"


extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicBand;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicBand, {});
DESTRUCTOR(_dxj_DirectMusicBand, {});
GETSET_OBJECT(_dxj_DirectMusicBand);

typedef IDirectMusicSegment8*		LPDIRECTMUSICSEGMENT;
typedef IDirectMusicPerformance8*	LPDIRECTMUSICPERFORMANCE;


HRESULT C_dxj_DirectMusicBandObject::createSegment( 
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret)
{  
	HRESULT hr;			
	LPDIRECTMUSICSEGMENT pSeg=NULL;
	IDirectMusicSegment*	pSegment = NULL;

	hr=m__dxj_DirectMusicBand->CreateSegment(&pSegment);
	if FAILED(hr) return hr;

	if (!pSegment) return E_FAIL;

	hr = pSegment->QueryInterface(IID_IDirectMusicSegment8, (void**)&pSeg);
	pSegment->Release();
	if (FAILED (hr) ) return hr;

	if (!pSeg) return E_FAIL;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pSeg,ret);
	return hr;
}


HRESULT C_dxj_DirectMusicBandObject::download( 
		/* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *downloadpath)
{  
	HRESULT hr;	

	IDirectMusicPerformance	*lpPerf = NULL;
	DO_GETOBJECT_NOTNULL(IDirectMusicPerformance8*,pPer,downloadpath);

	hr = pPer->QueryInterface(IID_IDirectMusicPerformance,(void**)&lpPerf);
	if (FAILED(hr))
	{
		pPer->Release();
		return hr;
	}
	pPer->Release();

	hr=m__dxj_DirectMusicBand->Download(lpPerf);
	return hr;
}

HRESULT C_dxj_DirectMusicBandObject::unload( 
		/* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *downloadpath)
{  
	HRESULT hr;	

	IDirectMusicPerformance	*lpPerf = NULL;
	DO_GETOBJECT_NOTNULL(IDirectMusicPerformance8*,pPer,downloadpath);

	hr = pPer->QueryInterface(IID_IDirectMusicPerformance,(void**)&lpPerf);
	if (FAILED(hr))
	{
		pPer->Release();
		return hr;
	}
	pPer->Release();

	hr=m__dxj_DirectMusicBand->Unload(lpPerf);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\directxhelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       directxhelp.h
//
//--------------------------------------------------------------------------

#ifndef __VBHELP_CAFD484C_C86F_11D2_A5A6_00C04FB92CC1_DEFINED__
#define __VBHELP_CAFD484C_C86F_11D2_A5A6_00C04FB92CC1_DEFINED__

#define _vbd3drm_Direct3DRMAnimation2 867001                                        //  Direct3DRMAnimation2
#define _vbd3drm_Direct3DRMAnimationArray 867002                                    //  Direct3DRMAnimationArray
#define _vbd3drm_Direct3DRMAnimationSet2 867003                                     //  Direct3DRMAnimationSet2
#define _vbd3drm_Visual_Basic_Callback_Interfaces 867004                            //  Visual Basic Callback Interfaces
#define _vbd3drm_Direct3DRMClippedVisual 867005                                     //  Direct3DRMClippedVisual
#define _vbd3drm_Direct3DRMDevice3 867006                                           //  Direct3DRMDevice3
#define _vbd3drm_Direct3DRMDeviceArray 867007                                       //  Direct3DRMDeviceArray
#define _vbd3drm_Visual_Basic_Enumerations 867008                                   //  Visual Basic Enumerations
#define _vbd3drm_Direct3DRMFace2 867009                                             //  Direct3DRMFace2
#define _vbd3drm_Direct3DRMFaceArray 867010                                         //  Direct3DRMFaceArray
#define _vbd3drm_Direct3DRMFrame3_Methods_A_to_M 867011                             //  Direct3DRMFrame3 Methods A to M
#define _vbd3drm_Direct3DRMFrame3_Methods_N_to_Z 867012                             //  Direct3DRMFrame3 Methods N to Z
#define _vbd3drm_Direct3DRMFrame3 867013                                            //  Direct3DRMFrame3
#define _vbd3drm_Direct3DRMFrameArray 867014                                        //  Direct3DRMFrameArray
#define _vbd3drm_Direct3DRMFrameInterpolator 867015                                 //  Direct3DRMFrameInterpolator
#define _vbd3drm_Further_Reading_for_Visual_Basic_Programmers 867016                //  Further Reading for Visual Basic Programmers
#define _vbd3drm_Direct3DRM3 867017                                                 //  Direct3DRM3
#define _vbd3drm_Visual_Basic_Interfaces 867018                                     //  Visual Basic Interfaces
#define _vbd3drm_Direct3DRMLight 867019                                             //  Direct3DRMLight
#define _vbd3drm_Direct3DRMLightArray 867020                                        //  Direct3DRMLightArray
#define _vbd3drm_Direct3DRMLightInterpolator 867021                                 //  Direct3DRMLightInterpolator
#define _vbd3drm_Direct3DRMMaterial2 867022                                         //  Direct3DRMMaterial2
#define _vbd3drm_Direct3DRMMaterialInterpolator 867023                              //  Direct3DRMMaterialInterpolator
#define _vbd3drm_Direct3DRMMesh 867024                                              //  Direct3DRMMesh
#define _vbd3drm_Direct3DRMMeshBuilder3 867025                                      //  Direct3DRMMeshBuilder3
#define _vbd3drm_Direct3DRMMeshInterpolator 867026                                  //  Direct3DRMMeshInterpolator
#define _vbd3drm_Direct3DRMObject 867027                                            //  Direct3DRMObject
#define _vbd3drm_Direct3DRMObjectArray 867028                                       //  Direct3DRMObjectArray
#define _vbd3drm_Direct3DRMPick2Array 867029                                        //  Direct3DRMPick2Array
#define _vbd3drm_Direct3DRMPickArray 867030                                         //  Direct3DRMPickArray
#define _vbd3drm_Direct3DRMProgressiveMesh 867031                                   //  Direct3DRMProgressiveMesh
#define _vbd3drm_Reference 867032                                                   //  Reference
#define _D3DRM_Error_Values 867033                                                  //  Visual Basic Error Values
#define _vbd3drm_Direct3DRMShadow2 867034                                           //  Direct3DRMShadow2
#define _vbd3drm_Visual_Basic_Types 867035                                          //  Visual Basic Types
#define _vbd3drm_Direct3DRMTexture3 867036                                          //  Direct3DRMTexture3
#define _vbd3drm_Direct3DRMTextureInterpolator 867037                               //  Direct3DRMTextureInterpolator
#define _vbd3drm_Direct3DRMUserVisual 867038                                        //  Direct3DRMUserVisual
#define _vbd3drm_Direct3DRMViewport2 867039                                         //  Direct3DRMViewport2
#define _vbd3drm_Direct3DRMViewportArray 867040                                     //  Direct3DRMViewportArray
#define _vbd3drm_Direct3DRMViewportInterpolator 867041                              //  Direct3DRMViewportInterpolator
#define _vbd3drm_Direct3DRMVisual 867042                                            //  Direct3DRMVisual
#define _vbd3drm_Direct3DRMVisualArray 867043                                       //  Direct3DRMVisualArray
#define _vbd3drm_Direct3DRMWrap 867044                                              //  Direct3DRMWrap
#define idh__dx_direct3d3_d3d_vb 867045                                             //  Direct3D3
#define idh__dx_direct3d3_createdevice_d3d_vb 867046                                //  Direct3D3.CreateDevice
#define idh__dx_direct3d3_createlight_d3d_vb 867047                                 //  Direct3D3.CreateLight
#define idh__dx_direct3d3_creatematerial_d3d_vb 867048                              //  Direct3D3.CreateMaterial
#define idh__dx_direct3d3_createvertexbuffer_d3d_vb 867049                          //  Direct3D3.CreateVertexBuffer
#define idh__dx_direct3d3_createviewport_d3d_vb 867050                              //  Direct3D3.CreateViewport
#define idh__dx_direct3d3_evictmanagedtextures_d3d_vb 867051                        //  Direct3D3.EvictManagedTextures
#define idh__dx_direct3d3_finddevice_d3d_vb 867052                                  //  Direct3D3.FindDevice
#define idh__dx_direct3d3_getdevicesenum_d3d_vb 867053                              //  Direct3D3.GetDevicesEnum
#define idh__dx_direct3d3_getdirectdraw_d3d_vb 867054                               //  Direct3D3.GetDirectDraw
#define idh__dx_direct3d3_getenumzbufferformats_d3d_vb 867055                       //  Direct3D3.GetEnumZBufferFormats
#define idh__dx_direct3ddevice3_d3d_vb 867056                                       //  Direct3DDevice3
#define idh__dx_direct3ddevice3_addviewport_d3d_vb 867057                           //  Direct3DDevice3.AddViewport
#define idh__dx_direct3ddevice3_begin_d3d_vb 867058                                 //  Direct3DDevice3.Begin
#define idh__dx_direct3ddevice3_beginindexed_d3d_vb 867059                          //  Direct3DDevice3.BeginIndexed
#define idh__dx_direct3ddevice3_beginscene_d3d_vb 867060                            //  Direct3DDevice3.BeginScene
#define idh__dx_direct3ddevice3_computespherevisibility_d3d_vb 867061               //  Direct3DDevice3.ComputeSphereVisibility
#define idh__dx_direct3ddevice3_deleteviewport_d3d_vb 867062                        //  Direct3DDevice3.DeleteViewport
#define idh__dx_direct3ddevice3_drawindexedprimitive_d3d_vb 867063                  //  Direct3DDevice3.DrawIndexedPrimitive
#define idh__dx_direct3ddevice3_drawindexedprimitivevb_d3d_vb 867064                //  Direct3DDevice3.DrawIndexedPrimitiveVB
#define idh__dx_direct3ddevice3_drawprimitive_d3d_vb 867065                         //  Direct3DDevice3.DrawPrimitive
#define idh__dx_direct3ddevice3_drawprimitivevb_d3d_vb 867066                       //  Direct3DDevice3.DrawPrimitiveVB
#define idh__dx_direct3ddevice3_end_d3d_vb 867067                                   //  Direct3DDevice3.End
#define idh__dx_direct3ddevice3_endscene_d3d_vb 867068                              //  Direct3DDevice3.EndScene
#define idh__dx_direct3ddevice3_getcaps_d3d_vb 867069                               //  Direct3DDevice3.GetCaps
#define idh__dx_direct3ddevice3_getclipstatus_d3d_vb 867070                         //  Direct3DDevice3.GetClipStatus
#define idh__dx_direct3ddevice3_getcurrentviewport_d3d_vb 867071                    //  Direct3DDevice3.GetCurrentViewport
#define idh__dx_direct3ddevice3_getdirect3d_d3d_vb 867072                           //  Direct3DDevice3.GetDirect3D
#define idh__dx_direct3ddevice3_getlightstate_d3d_vb 867073                         //  Direct3DDevice3.GetLightState
#define idh__dx_direct3ddevice3_getrenderstate_d3d_vb 867074                        //  Direct3DDevice3.GetRenderState
#define idh__dx_direct3ddevice3_getrendertarget_d3d_vb 867075                       //  Direct3DDevice3.GetRenderTarget
#define idh__dx_direct3ddevice3_getstats_d3d_vb 867076                              //  Direct3DDevice3.GetStats
#define idh__dx_direct3ddevice3_gettexture_d3d_vb 867077                            //  Direct3DDevice3.GetTexture
#define idh__dx_direct3ddevice3_gettextureformatsenum_d3d_vb 867078                 //  Direct3DDevice3.GetTextureFormatsEnum
#define idh__dx_direct3ddevice3_gettexturestagestate_d3d_vb 867079                  //  Direct3DDevice3.GetTextureStageState
#define idh__dx_direct3ddevice3_gettransform_d3d_vb 867080                          //  Direct3DDevice3.GetTransform
#define idh__dx_direct3ddevice3_index_d3d_vb 867081                                 //  Direct3DDevice3.Index
#define idh__dx_direct3ddevice3_multiplytransform_d3d_vb 867082                     //  Direct3DDevice3.MultiplyTransform
#define idh__dx_direct3ddevice3_nextviewport_d3d_vb 867083                          //  Direct3DDevice3.NextViewport
#define idh__dx_direct3ddevice3_setclipstatus_d3d_vb 867084                         //  Direct3DDevice3.SetClipStatus
#define idh__dx_direct3ddevice3_setcurrentviewport_d3d_vb 867085                    //  Direct3DDevice3.SetCurrentViewport
#define idh__dx_direct3ddevice3_setlightstate_d3d_vb 867086                         //  Direct3DDevice3.SetLightState
#define idh__dx_direct3ddevice3_setrenderstate_d3d_vb 867087                        //  Direct3DDevice3.SetRenderState
#define idh__dx_direct3ddevice3_setrendertarget_d3d_vb 867088                       //  Direct3DDevice3.SetRenderTarget
#define idh__dx_direct3ddevice3_settexture_d3d_vb 867089                            //  Direct3DDevice3.SetTexture
#define idh__dx_direct3ddevice3_settexturestagestate_d3d_vb 867090                  //  Direct3DDevice3.SetTextureStageState
#define idh__dx_direct3ddevice3_settransform_d3d_vb 867091                          //  Direct3DDevice3.SetTransform
#define idh__dx_direct3ddevice3_validatedevice_d3d_vb 867092                        //  Direct3DDevice3.ValidateDevice
#define idh__dx_direct3ddevice3_vertex_d3d_vb 867093                                //  Direct3DDevice3.Vertex
#define idh__dx_direct3denumdevices_d3d_vb 867094                                   //  Direct3DEnumDevices
#define idh__dx_direct3denumdevices_getcount_d3d_vb 867095                          //  Direct3DEnumDevices.GetCount
#define idh__dx_direct3denumdevices_getdescription_d3d_vb 867096                    //  Direct3DEnumDevices.GetDescription
#define idh__dx_direct3denumdevices_getguid_d3d_vb 867097                           //  Direct3DEnumDevices.GetGuid
#define idh__dx_direct3denumdevices_getheldesc_d3d_vb 867098                        //  Direct3DEnumDevices.GetHELDesc
#define idh__dx_direct3denumdevices_gethwdesc_d3d_vb 867099                         //  Direct3DEnumDevices.GetHWDesc
#define idh__dx_direct3denumdevices_getname_d3d_vb 867100                           //  Direct3DEnumDevices.GetName
#define idh__dx_direct3denumpixelformats_d3d_vb 867101                              //  Direct3DEnumPixelFormats
#define idh__dx_direct3denumpixelformats_getcount_d3d_vb 867102                     //  Direct3DEnumPixelFormats.GetCount
#define idh__dx_direct3denumpixelformats_getitem_d3d_vb 867103                      //  Direct3DEnumPixelFormats.GetItem
#define idh__dx_direct3dlight_d3d_vb 867104                                         //  Direct3DLight
#define idh__dx_direct3dlight_getlight_d3d_vb 867105                                //  Direct3DLight.GetLight
#define idh__dx_direct3dlight_setlight_d3d_vb 867106                                //  Direct3DLight.SetLight
#define idh__dx_direct3dmaterial3_d3d_vb 867107                                     //  Direct3DMaterial3
#define idh__dx_direct3dmaterial3_gethandle_d3d_vb 867108                           //  Direct3DMaterial3.GetHandle
#define idh__dx_direct3dmaterial3_getmaterial_d3d_vb 867109                         //  Direct3DMaterial3.GetMaterial
#define idh__dx_direct3dmaterial3_setmaterial_d3d_vb 867110                         //  Direct3DMaterial3.SetMaterial
#define idh__dx_direct3dtexture2_d3d_vb 867111                                      //  Direct3DTexture2
#define idh__dx_direct3dtexture2_gethandle_d3d_vb 867112                            //  Direct3DTexture2.GetHandle
#define idh__dx_direct3dtexture2_getsurface_d3d_vb 867113                           //  Direct3DTexture2.GetSurface
#define idh__dx_direct3dtexture2_load_d3d_vb 867114                                 //  Direct3DTexture2.Load
#define idh__dx_direct3dtexture2_palettechanged_d3d_vb 867115                       //  Direct3DTexture2.PaletteChanged
#define idh__dx_direct3dvertexbuffer_d3d_vb 867116                                  //  Direct3DVertexBuffer
#define idh__dx_direct3dvertexbuffer_getvertexbufferdesc_d3d_vb 867117              //  Direct3DVertexBuffer.GetVertexBufferDesc
#define idh__dx_direct3dvertexbuffer_getvertices_d3d_vb 867118                      //  Direct3DVertexBuffer.GetVertices
#define idh__dx_direct3dvertexbuffer_lock_d3d_vb 867119                             //  Direct3DVertexBuffer.Lock
#define idh__dx_direct3dvertexbuffer_optimize_d3d_vb 867120                         //  Direct3DVertexBuffer.Optimize
#define idh__dx_direct3dvertexbuffer_processvertices_d3d_vb 867121                  //  Direct3DVertexBuffer.ProcessVertices
#define idh__dx_direct3dvertexbuffer_setvertices_d3d_vb 867122                      //  Direct3DVertexBuffer.SetVertices
#define idh__dx_direct3dvertexbuffer_unlock_d3d_vb 867123                           //  Direct3DVertexBuffer.Unlock
#define idh__dx_direct3dviewport3_d3d_vb 867124                                     //  Direct3DViewport3
#define idh__dx_direct3dviewport3_addlight_d3d_vb 867125                            //  Direct3DViewport3.AddLight
#define idh__dx_direct3dviewport3_clear_d3d_vb 867126                               //  Direct3DViewport3.Clear
#define idh__dx_direct3dviewport3_clear2_d3d_vb 867127                              //  Direct3DViewport3.Clear2
#define idh__dx_direct3dviewport3_deletelight_d3d_vb 867128                         //  Direct3DViewport3.DeleteLight
#define idh__dx_direct3dviewport3_getbackground_d3d_vb 867129                       //  Direct3DViewport3.GetBackground
#define idh__dx_direct3dviewport3_getbackgrounddepth_d3d_vb 867130                  //  Direct3DViewport3.GetBackgroundDepth
#define idh__dx_direct3dviewport3_getviewport_d3d_vb 867131                         //  Direct3DViewport3.GetViewport
#define idh__dx_direct3dviewport3_getviewport2_d3d_vb 867132                        //  Direct3DViewport3.GetViewport2
#define idh__dx_direct3dviewport3_lightelements_d3d_vb 867133                       //  Direct3DViewport3.LightElements
#define idh__dx_direct3dviewport3_nextlight_d3d_vb 867134                           //  Direct3DViewport3.NextLight
#define idh__dx_direct3dviewport3_setbackground_d3d_vb 867135                       //  Direct3DViewport3.SetBackground
#define idh__dx_direct3dviewport3_setbackgrounddepth_d3d_vb 867136                  //  Direct3DViewport3.SetBackgroundDepth
#define idh__dx_direct3dviewport3_setviewport_d3d_vb 867137                         //  Direct3DViewport3.SetViewport
#define idh__dx_direct3dviewport3_setviewport2_d3d_vb 867138                        //  Direct3DViewport3.SetViewport2
#define idh__dx_direct3dviewport3_transformvertices_d3d_vb 867139                   //  Direct3DViewport3.TransformVertices
#define idh__dx_d3dclipstatus_d3d_vb 867140                                         //  D3DCLIPSTATUS
#define idh__dx_d3dcolorvalue_d3d_vb 867141                                         //  D3DCOLORVALUE
#define idh__dx_d3ddevicedesc_d3d_vb 867142                                         //  D3DDEVICEDESC
#define idh__dx_d3dfinddeviceresult2_d3d_vb 867143                                  //  D3DFINDDEVICERESULT2
#define idh__dx_d3dfinddevicesearch_d3d_vb 867144                                   //  D3DFINDDEVICESEARCH
#define idh__dx_d3dhvertex_d3d_vb 867145                                            //  D3DHVERTEX
#define idh__dx_d3dlight2_d3d_vb 867146                                             //  D3DLIGHT2
#define idh__dx_d3dlightdata_d3d_vb 867147                                          //  D3DLIGHTDATA
#define idh__dx_d3dlightingcaps_d3d_vb 867148                                       //  D3DLIGHTINGCAPS
#define idh__dx_d3dlvertex_d3d_vb 867149                                            //  D3DLVERTEX
#define idh__dx_d3dmaterial_d3d_vb 867150                                           //  D3DMATERIAL
#define idh__dx_d3dmatrix_d3d_vb 867151                                             //  D3DMATRIX
#define idh__dx_d3dprimcaps_d3d_vb 867152                                           //  D3DPRIMCAPS
#define idh__dx_d3drect_d3d_vb 867153                                               //  D3DRECT
#define idh__dx_d3drotation_d3d_vb 867154                                           //  D3DROTATION
#define idh__dx_d3dstats_d3d_vb 867155                                              //  D3DSTATS
#define idh__dx_d3dstatus_d3d_vb 867156                                             //  D3DSTATUS
#define idh__dx_d3dtlvertex_d3d_vb 867157                                           //  D3DTLVERTEX
#define idh__dx_d3dtransformdata_d3d_vb 867158                                      //  D3DTRANSFORMDATA
#define idh__dx_d3dvector_d3d_vb 867159                                             //  D3DVECTOR
#define idh__dx_d3dvertex_d3d_vb 867160                                             //  D3DVERTEX
#define idh__dx_d3dvertexbufferdesc_d3d_vb 867161                                   //  D3DVERTEXBUFFERDESC
#define idh__dx_d3dviewport_d3d_vb 867162                                           //  D3DVIEWPORT
#define idh__dx_d3dviewport2_d3d_vb 867163                                          //  D3DVIEWPORT2
#define idh__dx_dxdriverinfo_d3d_vb 867164                                          //  DXDRIVERINFO
#define idh__dx_const_d3d_d3d_vb 867165                                             //  CONST_D3D
#define idh__dx_const_d3dantialiasmode_d3d_vb 867166                                //  CONST_D3DANTIALIASMODE
#define idh__dx_const_d3dblend_d3d_vb 867167                                        //  CONST_D3DBLEND
#define idh__dx_const_d3dcapsblend_d3d_vb 867168                                    //  CONST_D3DCAPSBLEND
#define idh__dx_const_d3dcapscmp_d3d_vb 867169                                      //  CONST_D3DCAPSCMP
#define idh__dx_const_d3dcapsmisc_d3d_vb 867170                                     //  CONST_D3DCAPSMISC
#define idh__dx_const_d3dcapsraster_d3d_vb 867171                                   //  CONST_D3DCAPSRASTER
#define idh__dx_const_d3dcapsshade_d3d_vb 867172                                    //  CONST_D3DCAPSSHADE
#define idh__dx_const_d3dcapstexture_d3d_vb 867173                                  //  CONST_D3DCAPSTEXTURE
#define idh__dx_const_d3dcapstextureaddress_d3d_vb 867174                           //  CONST_D3DCAPSTEXTUREADDRESS
#define idh__dx_const_d3dcapstextureblend_d3d_vb 867175                             //  CONST_D3DCAPSTEXTUREBLEND
#define idh__dx_const_d3dcapstexturefilter_d3d_vb 867176                            //  CONST_D3DCAPSTEXTUREFILTER
#define idh__dx_const_d3dclearflags_d3d_vb 867177                                   //  CONST_D3DCLEARFLAGS
#define idh__dx_const_d3dclipflags_d3d_vb 867178                                    //  CONST_D3DCLIPFLAGS
#define idh__dx_const_d3dclipstatusflags_d3d_vb 867179                              //  CONST_D3DCLIPSTATUSFLAGS
#define idh__dx_const_d3dcmpfunc_d3d_vb 867180                                      //  CONST_D3DCMPFUNC
#define idh__dx_const_d3dcolormodel_d3d_vb 867181                                   //  CONST_D3DCOLORMODEL
#define idh__dx_const_d3dcull_d3d_vb 867182                                         //  CONST_D3DCULL
#define idh__dx_const_d3ddevicedesccaps_d3d_vb 867183                               //  CONST_D3DDEVICEDESCCAPS
#define idh__dx_const_d3ddevicedescflags_d3d_vb 867184                              //  CONST_D3DDEVICEDESCFLAGS
#define idh__dx_const_d3ddpflags_d3d_vb 867185                                      //  CONST_D3DDPFLAGS
#define idh__dx_const_d3dfillmode_d3d_vb 867186                                     //  CONST_D3DFILLMODE
#define idh__dx_const_d3dfinddevicesearchflags_d3d_vb 867187                        //  CONST_D3DFINDDEVICESEARCHFLAGS
#define idh__dx_const_d3dfogmode_d3d_vb 867188                                      //  CONST_D3DFOGMODE
#define idh__dx_const_d3dfvfcapsflags_d3d_vb 867189                                 //  CONST_D3DFVFCAPSFLAGS
#define idh__dx_const_d3dfvfflags_d3d_vb 867190                                     //  CONST_D3DFVFFLAGS
#define idh__dx_const_d3dimerr_d3d_vb 867191                                        //  CONST_D3DIMERR
#define idh__dx_const_d3dlight2flags_d3d_vb 867192                                  //  CONST_D3DLIGHT2FLAGS
#define idh__dx_const_d3dlightcapsflags_d3d_vb 867193                               //  CONST_D3DLIGHTCAPSFLAGS
#define idh__dx_const_d3dlightingmodelflags_d3d_vb 867194                           //  CONST_D3DLIGHTINGMODELFLAGS
#define idh__dx_const_d3dlightstatetype_d3d_vb 867195                               //  CONST_D3DLIGHTSTATETYPE
#define idh__dx_const_d3dlighttype_d3d_vb 867196                                    //  CONST_D3DLIGHTTYPE
#define idh__dx_const_d3dnextflags_d3d_vb 867197                                    //  CONST_D3DNEXTFLAGS
#define idh__dx_const_d3dpalflags_d3d_vb 867198                                     //  CONST_D3DPALFLAGS
#define idh__dx_const_d3dprimitivetype_d3d_vb 867199                                //  CONST_D3DPRIMITIVETYPE
#define idh__dx_const_d3drenderstatetype_d3d_vb 867200                              //  CONST_D3DRENDERSTATETYPE
#define idh__dx_const_d3dsetstatusflags_d3d_vb 867201                               //  CONST_D3DSETSTATUSFLAGS
#define idh__dx_const_d3dshademode_d3d_vb 867202                                    //  CONST_D3DSHADEMODE
#define idh__dx_const_d3dstencilcapsflags_d3d_vb 867203                             //  CONST_D3DSTENCILCAPSFLAGS
#define idh__dx_const_d3dstencilop_d3d_vb 867204                                    //  CONST_D3DSTENCILOP
#define idh__dx_const_d3dtaflags_d3d_vb 867205                                      //  CONST_D3DTAFLAGS
#define idh__dx_const_d3dtexopcapsflags_d3d_vb 867206                               //  CONST_D3DTEXOPCAPSFLAGS
#define idh__dx_const_d3dtextureaddress_d3d_vb 867207                               //  CONST_D3DTEXTUREADDRESS
#define idh__dx_const_d3dtextureblend_d3d_vb 867208                                 //  CONST_D3DTEXTUREBLEND
#define idh__dx_const_d3dtexturefilter_d3d_vb 867209                                //  CONST_D3DTEXTUREFILTER
#define idh__dx_const_d3dtexturemagfilter_d3d_vb 867210                             //  CONST_D3DTEXTUREMAGFILTER
#define idh__dx_const_d3dtextureminfilter_d3d_vb 867211                             //  CONST_D3DTEXTUREMINFILTER
#define idh__dx_const_d3dtexturemipfilter_d3d_vb 867212                             //  CONST_D3DTEXTUREMIPFILTER
#define idh__dx_const_d3dtextureop_d3d_vb 867213                                    //  CONST_D3DTEXTUREOP
#define idh__dx_const_d3dtexturestagestatetype_d3d_vb 867214                        //  CONST_D3DTEXTURESTAGESTATETYPE
#define idh__dx_const_d3dtransformcaps_d3d_vb 867215                                //  CONST_D3DTRANSFORMCAPS
#define idh__dx_const_d3dtransformflags_d3d_vb 867216                               //  CONST_D3DTRANSFORMFLAGS
#define idh__dx_const_d3dtransformstatetype_d3d_vb 867217                           //  CONST_D3DTRANSFORMSTATETYPE
#define idh__dx_const_d3dvbcapsflags_d3d_vb 867218                                  //  CONST_D3DVBCAPSFLAGS
#define idh__dx_const_d3dvertextype_d3d_vb 867219                                   //  CONST_D3DVERTEXTYPE
#define idh__dx_const_d3dvisflags_d3d_vb 867220                                     //  CONST_D3DVISFLAGS
#define idh__dx_const_d3dvopflags_d3d_vb 867221                                     //  CONST_D3DVOPFLAGS
#define idh__dx_const_d3dzbuffertype_d3d_vb 867222                                  //  CONST_D3DZBUFFERTYPE
#define idh__dx_directdraw4_ddraw_vb 867223                                         //  DirectDraw4
#define idh__dx_directdraw4_createclipper_ddraw_vb 867224                           //  DirectDraw4.CreateClipper
#define idh__dx_directdraw4_createpalette_ddraw_vb 867225                           //  DirectDraw4.CreatePalette
#define idh__dx_directdraw4_createsurface_ddraw_vb 867226                           //  DirectDraw4.CreateSurface
#define idh__dx_directdraw4_createsurfacefromfile_ddraw_vb 867227                   //  DirectDraw4.CreateSurfaceFromFile
#define idh__dx_directdraw4_createsurfacefromresource_ddraw_vb 867228               //  DirectDraw4.CreateSurfaceFromResource
#define idh__dx_directdraw4_duplicatesurface_ddraw_vb 867229                        //  DirectDraw4.DuplicateSurface
#define idh__dx_directdraw4_fliptogdisurface_ddraw_vb 867230                        //  DirectDraw4.FlipToGDISurface
#define idh__dx_directdraw4_getavailabletotalmem_ddraw_vb 867231                    //  DirectDraw4.GetAvailableTotalMem
#define idh__dx_directdraw4_getcaps_ddraw_vb 867232                                 //  DirectDraw4.GetCaps
#define idh__dx_directdraw4_getdirect3d_ddraw_vb 867233                             //  DirectDraw4.GetDirect3D
#define idh__dx_directdraw4_getdisplaymode_ddraw_vb 867234                          //  DirectDraw4.GetDisplayMode
#define idh__dx_directdraw4_getdisplaymodesenum_ddraw_vb 867235                     //  DirectDraw4.GetDisplayModesEnum
#define idh__dx_directdraw4_getfourcccodes_ddraw_vb 867236                          //  DirectDraw4.GetFourCCCodes
#define idh__dx_directdraw4_getfreemem_ddraw_vb 867237                              //  DirectDraw4.GetFreeMem
#define idh__dx_directdraw4_getgdisurface_ddraw_vb 867238                           //  DirectDraw4.GetGDISurface
#define idh__dx_directdraw4_getmonitorfrequency_ddraw_vb 867239                     //  DirectDraw4.GetMonitorFrequency
#define idh__dx_directdraw4_getnumfourcccodes_ddraw_vb 867240                       //  DirectDraw4.GetNumFourCCCodes
#define idh__dx_directdraw4_getscanline_ddraw_vb 867241                             //  DirectDraw4.GetScanLine
#define idh__dx_directdraw4_getsurfacefromdc_ddraw_vb 867242                        //  DirectDraw4.GetSurfaceFromDC
#define idh__dx_directdraw4_getsurfacesenum_ddraw_vb 867243                         //  DirectDraw4.GetSurfacesEnum
#define idh__dx_directdraw4_getverticalblankstatus_ddraw_vb 867244                  //  DirectDraw4.GetVerticalBlankStatus
#define idh__dx_directdraw4_loadpalettefrombitmap_ddraw_vb 867245                   //  DirectDraw4.LoadPaletteFromBitmap
#define idh__dx_directdraw4_restoreallsurfaces_ddraw_vb 867246                      //  DirectDraw4.RestoreAllSurfaces
#define idh__dx_directdraw4_restoredisplaymode_ddraw_vb 867247                      //  DirectDraw4.RestoreDisplayMode
#define idh__dx_directdraw4_setcooperativelevel_ddraw_vb 867248                     //  DirectDraw4.SetCooperativeLevel
#define idh__dx_directdraw4_setdisplaymode_ddraw_vb 867249                          //  DirectDraw4.SetDisplayMode
#define idh__dx_directdraw4_testcooperativelevel_ddraw_vb 867250                    //  DirectDraw4.TestCooperativeLevel
#define idh__dx_directdraw4_waitforverticalblank_ddraw_vb 867251                    //  DirectDraw4.WaitForVerticalBlank
#define idh__dx_directdrawclipper_ddraw_vb 867252                                   //  DirectDrawClipper
#define idh__dx_directdrawclipper_getcliplist_ddraw_vb 867253                       //  DirectDrawClipper.GetClipList
#define idh__dx_directdrawclipper_getcliplistsize_ddraw_vb 867254                   //  DirectDrawClipper.GetClipListSize
#define idh__dx_directdrawclipper_gethwnd_ddraw_vb 867255                           //  DirectDrawClipper.GetHWnd
#define idh__dx_directdrawclipper_iscliplistchanged_ddraw_vb 867256                 //  DirectDrawClipper.IsClipListChanged
#define idh__dx_directdrawclipper_setcliplist_ddraw_vb 867257                       //  DirectDrawClipper.SetClipList
#define idh__dx_directdrawclipper_sethwnd_ddraw_vb 867258                           //  DirectDrawClipper.SetHWnd
#define idh__dx_directdrawcolorcontrol_ddraw_vb 867259                              //  DirectDrawColorControl
#define idh__dx_directdrawcolorcontrol_getcolorcontrols_ddraw_vb 867260             //  DirectDrawColorControl.GetColorControls
#define idh__dx_directdrawcolorcontrol_setcolorcontrols_ddraw_vb 867261             //  DirectDrawColorControl.SetColorControls
#define idh__dx_directdrawenum_ddraw_vb 867262                                      //  DirectDrawEnum
#define idh__dx_directdrawenum_getcount_ddraw_vb 867263                             //  DirectDrawEnum.GetCount
#define idh__dx_directdrawenum_getdescription_ddraw_vb 867264                       //  DirectDrawEnum.GetDescription
#define idh__dx_directdrawenum_getguid_ddraw_vb 867265                              //  DirectDrawEnum.GetGuid
#define idh__dx_directdrawenum_getname_ddraw_vb 867266                              //  DirectDrawEnum.GetName
#define idh__dx_directdrawenummodes_ddraw_vb 867267                                 //  DirectDrawEnumModes
#define idh__dx_directdrawenummodes_getcount_ddraw_vb 867268                        //  DirectDrawEnumModes.GetCount
#define idh__dx_directdrawenummodes_getitem_ddraw_vb 867269                         //  DirectDrawEnumModes.GetItem
#define idh__dx_directdrawenumsurfaces_ddraw_vb 867270                              //  DirectDrawEnumSurfaces
#define idh__dx_directdrawenumsurfaces_getcount_ddraw_vb 867271                     //  DirectDrawEnumSurfaces.GetCount
#define idh__dx_directdrawenumsurfaces_getitem_ddraw_vb 867272                      //  DirectDrawEnumSurfaces.GetItem
#define idh__dx_directdrawgammacontrol_ddraw_vb 867273                              //  DirectDrawGammaControl
#define idh__dx_directdrawgammacontrol_getgammaramp_ddraw_vb 867274                 //  DirectDrawGammaControl.GetGammaRamp
#define idh__dx_directdrawgammacontrol_setgammaramp_ddraw_vb 867275                 //  DirectDrawGammaControl.SetGammaRamp
#define idh__dx_directdrawpalette_ddraw_vb 867276                                   //  DirectDrawPalette
#define idh__dx_directdrawpalette_getcaps_ddraw_vb 867277                           //  DirectDrawPalette.GetCaps
#define idh__dx_directdrawpalette_getentries_ddraw_vb 867278                        //  DirectDrawPalette.GetEntries
#define idh__dx_directdrawpalette_setentries_ddraw_vb 867279                        //  DirectDrawPalette.SetEntries
#define idh__dx_directdrawsurface4_ddraw_vb 867280                                  //  DirectDrawSurface4
#define idh__dx_directdrawsurface4_addattachedsurface_ddraw_vb 867281               //  DirectDrawSurface4.AddAttachedSurface
#define idh__dx_directdrawsurface4_addoverlaydirtyrect_ddraw_vb 867282              //  DirectDrawSurface4.AddOverlayDirtyRect
#define idh__dx_directdrawsurface4_blt_ddraw_vb 867283                              //  DirectDrawSurface4.Blt
#define idh__dx_directdrawsurface4_bltcolorfill_ddraw_vb 867284                     //  DirectDrawSurface4.BltColorFill
#define idh__dx_directdrawsurface4_bltfast_ddraw_vb 867285                          //  DirectDrawSurface4.BltFast
#define idh__dx_directdrawsurface4_bltfx_ddraw_vb 867286                            //  DirectDrawSurface4.BltFx
#define idh__dx_directdrawsurface4_changeuniquenessvalue_ddraw_vb 867287            //  DirectDrawSurface4.ChangeUniquenessValue
#define idh__dx_directdrawsurface4_deleteattachedsurface_ddraw_vb 867288            //  DirectDrawSurface4.DeleteAttachedSurface
#define idh__dx_directdrawsurface4_flip_ddraw_vb 867289                             //  DirectDrawSurface4.Flip
#define idh__dx_directdrawsurface4_freeprivatedata_ddraw_vb 867290                  //  DirectDrawSurface4.FreePrivateData
#define idh__dx_directdrawsurface4_getattachedsurface_ddraw_vb 867291               //  DirectDrawSurface4.GetAttachedSurface
#define idh__dx_directdrawsurface4_getattachedsurfaceenum_ddraw_vb 867292           //  DirectDrawSurface4.GetAttachedSurfaceEnum
#define idh__dx_directdrawsurface4_getbltstatus_ddraw_vb 867293                     //  DirectDrawSurface4.GetBltStatus
#define idh__dx_directdrawsurface4_getcaps_ddraw_vb 867294                          //  DirectDrawSurface4.GetCaps
#define idh__dx_directdrawsurface4_getclipper_ddraw_vb 867295                       //  DirectDrawSurface4.GetClipper
#define idh__dx_directdrawsurface4_getcolorkey_ddraw_vb 867296                      //  DirectDrawSurface4.GetColorKey
#define idh__dx_directdrawsurface4_getdc_ddraw_vb 867297                            //  DirectDrawSurface4.GetDC
#define idh__dx_directdrawsurface4_getdirectdraw_ddraw_vb 867298                    //  DirectDrawSurface4.GetDirectDraw
#define idh__dx_directdrawsurface4_getdirectdrawcolorcontrol_ddraw_vb 867299        //  DirectDrawSurface4.GetDirectDrawColorControl
#define idh__dx_directdrawsurface4_getdirectdrawgammacontrol_ddraw_vb 867300        //  DirectDrawSurface4.GetDirectDrawGammaControl
#define idh__dx_directdrawsurface4_getflipstatus_ddraw_vb 867301                    //  DirectDrawSurface4.GetFlipStatus
#define idh__dx_directdrawsurface4_getlockedpixel_ddraw_vb 867302                   //  DirectDrawSurface4.GetLockedPixel
#define idh__dx_directdrawsurface4_getlockedsurfacebits_ddraw_vb 867303             //  DirectDrawSurface4.GetLockedSurfaceBits
#define idh__dx_directdrawsurface4_getoverlaypositionx_ddraw_vb 867304              //  DirectDrawSurface4.GetOverlayPositionX
#define idh__dx_directdrawsurface4_getoverlaypositiony_ddraw_vb 867305              //  DirectDrawSurface4.GetOverlayPositionY
#define idh__dx_directdrawsurface4_getoverlayzordersenum_ddraw_vb 867306            //  DirectDrawSurface4.GetOverlayZOrdersEnum
#define idh__dx_directdrawsurface4_getpalette_ddraw_vb 867307                       //  DirectDrawSurface4.GetPalette
#define idh__dx_directdrawsurface4_getpixelformat_ddraw_vb 867308                   //  DirectDrawSurface4.GetPixelFormat
#define idh__dx_directdrawsurface4_getprivatedata_ddraw_vb 867309                   //  DirectDrawSurface4.GetPrivateData
#define idh__dx_directdrawsurface4_getprivatedatasize_ddraw_vb 867310               //  DirectDrawSurface4.GetPrivateDataSize
#define idh__dx_directdrawsurface4_getsurfacedesc_ddraw_vb 867311                   //  DirectDrawSurface4.GetSurfaceDesc
#define idh__dx_directdrawsurface4_gettexture_ddraw_vb 867312                       //  DirectDrawSurface4.GetTexture
#define idh__dx_directdrawsurface4_getuniquenessvalue_ddraw_vb 867313               //  DirectDrawSurface4.GetUniquenessValue
#define idh__dx_directdrawsurface4_islost_ddraw_vb 867314                           //  DirectDrawSurface4.IsLost
#define idh__dx_directdrawsurface4_lock_ddraw_vb 867315                             //  DirectDrawSurface4.Lock
#define idh__dx_directdrawsurface4_releasedc_ddraw_vb 867316                        //  DirectDrawSurface4.ReleaseDC
#define idh__dx_directdrawsurface4_restore_ddraw_vb 867317                          //  DirectDrawSurface4.Restore
#define idh__dx_directdrawsurface4_setclipper_ddraw_vb 867318                       //  DirectDrawSurface4.SetClipper
#define idh__dx_directdrawsurface4_setcolorkey_ddraw_vb 867319                      //  DirectDrawSurface4.SetColorKey
#define idh__dx_directdrawsurface4_setlockedpixel_ddraw_vb 867320                   //  DirectDrawSurface4.SetLockedPixel
#define idh__dx_directdrawsurface4_setlockedsurfacebits_ddraw_vb 867321             //  DirectDrawSurface4.SetLockedSurfaceBits
#define idh__dx_directdrawsurface4_setoverlayposition_ddraw_vb 867322               //  DirectDrawSurface4.SetOverlayPosition
#define idh__dx_directdrawsurface4_setpalette_ddraw_vb 867323                       //  DirectDrawSurface4.SetPalette
#define idh__dx_directdrawsurface4_setprivatedata_ddraw_vb 867324                   //  DirectDrawSurface4.SetPrivateData
#define idh__dx_directdrawsurface4_unlock_ddraw_vb 867325                           //  DirectDrawSurface4.Unlock
#define idh__dx_directdrawsurface4_updateoverlay_ddraw_vb 867326                    //  DirectDrawSurface4.UpdateOverlay
#define idh__dx_directdrawsurface4_updateoverlayzorder_ddraw_vb 867327              //  DirectDrawSurface4.UpdateOverlayZOrder
#define idh__dx_directx7_ddraw_vb 867328                                            //  DirectX7
#define idh__dx_ddbltfx_ddraw_vb 867329                                             //  DDBLTFX
#define idh__dx_ddcaps_ddraw_vb 867330                                              //  DDCAPS
#define idh__dx_ddcolorcontrol_ddraw_vb 867331                                      //  DDCOLORCONTROL
#define idh__dx_ddcolorkey_ddraw_vb 867332                                          //  DDCOLORKEY
#define idh__dx_ddgammaramp_ddraw_vb 867333                                         //  DDGAMMARAMP
#define idh__dx_ddoverlayfx_ddraw_vb 867334                                         //  DDOVERLAYFX
#define idh__dx_ddpixelformat_ddraw_vb 867335                                       //  DDPIXELFORMAT
#define idh__dx_ddscaps2_ddraw_vb 867336                                            //  DDSCAPS2
#define idh__dx_ddsurfacedesc2_ddraw_vb 867337                                      //  DDSURFACEDESC2
#define idh__dx_dxdriverinfo_ddraw_vb 867338                                        //  DXDRIVERINFO
#define idh__dx_paletteentry_ddraw_vb 867339                                        //  PALETTEENTRY
#define idh__dx_rect_ddraw_vb 867340                                                //  RECT
#define idh__dx_const_ddbitdepthflags_ddraw_vb 867341                               //  CONST_DDBITDEPTHFLAGS
#define idh__dx_const_ddbltfastflags_ddraw_vb 867342                                //  CONST_DDBLTFASTFLAGS
#define idh__dx_const_ddbltflags_ddraw_vb 867343                                    //  CONST_DDBLTFLAGS
#define idh__dx_const_ddbltfxflags_ddraw_vb 867344                                  //  CONST_DDBLTFXFLAGS
#define idh__dx_const_ddcaps1flags_ddraw_vb 867345                                  //  CONST_DDCAPS1FLAGS
#define idh__dx_const_ddcaps2flags_ddraw_vb 867346                                  //  CONST_DDCAPS2FLAGS
#define idh__dx_const_ddckeycapsflags_ddraw_vb 867347                               //  CONST_DDCKEYCAPSFLAGS
#define idh__dx_const_ddckeyflags_ddraw_vb 867348                                   //  CONST_DDCKEYFLAGS
#define idh__dx_const_ddcolorflags_ddraw_vb 867349                                  //  CONST_DDCOLORFLAGS
#define idh__dx_const_ddedmflags_ddraw_vb 867350                                    //  CONST_DDEDMFLAGS
#define idh__dx_const_ddenumoverlayzflags_ddraw_vb 867351                           //  CONST_DDENUMOVERLAYZFLAGS
#define idh__dx_const_ddenumsurfacesflags_ddraw_vb 867352                           //  CONST_DDENUMSURFACESFLAGS
#define idh__dx_const_ddflipflags_ddraw_vb 867353                                   //  CONST_DDFLIPFLAGS
#define idh__dx_const_ddfxalphacapsflags_ddraw_vb 867354                            //  CONST_DDFXALPHACAPSFLAGS
#define idh__dx_const_ddfxcapsflags_ddraw_vb 867355                                 //  CONST_DDFXCAPSFLAGS
#define idh__dx_const_ddgbsflags_ddraw_vb 867356                                    //  CONST_DDGBSFLAGS
#define idh__dx_const_ddgfsflags_ddraw_vb 867357                                    //  CONST_DDGFSFLAGS
#define idh__dx_const_ddlockflags_ddraw_vb 867358                                   //  CONST_DDLOCKFLAGS
#define idh__dx_const_ddoverflags_ddraw_vb 867359                                   //  CONST_DDOVERFLAGS
#define idh__dx_const_ddoverlayfxflags_ddraw_vb 867360                              //  CONST_DDOVERLAYFXFLAGS
#define idh__dx_const_ddoverzflags_ddraw_vb 867361                                  //  CONST_DDOVERZFLAGS
#define idh__dx_const_ddpcapsflags_ddraw_vb 867362                                  //  CONST_DDPCAPSFLAGS
#define idh__dx_const_ddpixelformatflags_ddraw_vb 867363                            //  CONST_DDPIXELFORMATFLAGS
#define idh__dx_const_ddraw_ddraw_vb 867364                                         //  CONST_DDRAW
#define idh__dx_const_ddsclflags_ddraw_vb 867365                                    //  CONST_DDSCLFLAGS
#define idh__dx_const_ddsdmflags_ddraw_vb 867366                                    //  CONST_DDSDMFLAGS
#define idh__dx_const_ddsgrflags_ddraw_vb 867367                                    //  CONST_DDSGRFLAGS
#define idh__dx_const_ddstereocapsflags_ddraw_vb 867368                             //  CONST_DDSTEREOCAPSFLAGS
#define idh__dx_const_ddsurfacecaps2flags_ddraw_vb 867369                           //  CONST_DDSURFACECAPS2FLAGS
#define idh__dx_const_ddsurfacecapsflags_ddraw_vb 867370                            //  CONST_DDSURFACECAPSFLAGS
#define idh__dx_const_ddsurfacedescflags_ddraw_vb 867371                            //  CONST_DDSURFACEDESCFLAGS
#define idh__dx_const_ddwaitvbflags_ddraw_vb 867372                                 //  CONST_DDWAITVBFLAGS
#define idh__dx_directinput_dinput_vb 867373                                        //  DirectInput
#define idh__dx_directinput_createdevice_dinput_vb 867374                           //  DirectInput.CreateDevice
#define idh__dx_directinput_getdevicestatus_dinput_vb 867375                        //  DirectInput.GetDeviceStatus
#define idh__dx_directinput_getdienumdevices_dinput_vb 867376                       //  DirectInput.GetDIEnumDevices
#define idh__dx_directinput_runcontrolpanel_dinput_vb 867377                        //  DirectInput.RunControlPanel
#define idh__dx_directinputdevice_dinput_vb 867378                                  //  DirectInputDevice
#define idh__dx_directinputdevice_acquire_dinput_vb 867379                          //  DirectInputDevice.Acquire
#define idh__dx_directinputdevice_getcapabilities_dinput_vb 867380                  //  DirectInputDevice.GetCapabilities
#define idh__dx_directinputdevice_getdevicedata_dinput_vb 867381                    //  DirectInputDevice.GetDeviceData
#define idh__dx_directinputdevice_getdeviceinfo_dinput_vb 867382                    //  DirectInputDevice.GetDeviceInfo
#define idh__dx_directinputdevice_getdienumdeviceobjects_dinput_vb 867383           //  DirectInputDevice.GetDeviceObjectsEnum
#define idh__dx_directinputdevice_getdevicestate_dinput_vb 867384                   //  DirectInputDevice.GetDeviceState
#define idh__dx_directinputdevice_getdevicestatejoystick_dinput_vb 867385           //  DirectInputDevice.GetDeviceStateJoystick
#define idh__dx_directinputdevice_getdevicestatejoystick2_dinput_vb 867386          //  DirectInputDevice.GetDeviceStateJoystick2
#define idh__dx_directinputdevice_getdevicestatekeyboard_dinput_vb 867387           //  DirectInputDevice.GetDeviceStateKeyboard
#define idh__dx_directinputdevice_getdevicestatemouse_dinput_vb 867388              //  DirectInputDevice.GetDeviceStateMouse
#define idh__dx_directinputdevice_getobjectinfo_dinput_vb 867389                    //  DirectInputDevice.GetObjectInfo
#define idh__dx_directinputdevice_getproperty_dinput_vb 867390                      //  DirectInputDevice.GetProperty
#define idh__dx_directinputdevice_poll_dinput_vb 867391                             //  DirectInputDevice.Poll
#define idh__dx_directinputdevice_runcontrolpanel_dinput_vb 867392                  //  DirectInputDevice.RunControlPanel
#define idh__dx_directinputdevice_setcooperativelevel_dinput_vb 867393              //  DirectInputDevice.SetCooperativeLevel
#define idh__dx_directinputdevice_setdataformat_dinput_vb 867394                    //  DirectInputDevice.SetDataFormat
#define idh__dx_directinputdevice_seteventnotification_dinput_vb 867395             //  DirectInputDevice.SetEventNotification
#define idh__dx_directinputdevice_setproperty_dinput_vb 867396                      //  DirectInputDevice.SetProperty
#define idh__dx_directinputdevice_unacquire_dinput_vb 867397                        //  DirectInputDevice.Unacquire
#define idh__dx_directinputenumdeviceobjects_dinput_vb 867398                       //  DirectInputEnumDeviceObjects
#define idh__dx_directinputenumdeviceobjects_getcount_dinput_vb 867399              //  DirectInputEnumDeviceObjects.GetCount
#define idh__dx_directinputenumdeviceobjects_getitem_dinput_vb 867400               //  DirectInputEnumDeviceObjects.GetItem
#define idh__dx_directinputenumdevices_dinput_vb 867401                             //  DirectInputEnumDevices
#define idh__dx_directinputenumdevices_getcount_dinput_vb 867402                    //  DirectInputEnumDevices.GetCount
#define idh__dx_directinputenumdevices_getitem_dinput_vb 867403                     //  DirectInputEnumDevices.GetItem
#define idh__dx_didataformat_dinput_vb 867404                                       //  DIDATAFORMAT
#define idh__dx_didevcaps_dinput_vb 867405                                          //  DIDEVCAPS
#define idh__dx_dideviceobjectdata_dinput_vb 867406                                 //  DIDEVICEOBJECTDATA
#define idh__dx_dijoystate_dinput_vb 867407                                         //  DIJOYSTATE
#define idh__dx_dijoystate2_desc_dinput_vb 867408                                   //  DIJOYSTATE2
#define idh__dx_dikeyboardstate_dinput_vb 867409                                    //  DIKEYBOARDSTATE
#define idh__dx_dimousestate_dinput_vb 867410                                       //  DIMOUSESTATE
#define idh__dx_diobjectdataformat_dinput_vb 867411                                 //  DIOBJECTDATAFORMAT
#define idh__dx_const_didataformatflags_dinput_vb 867412                            //  CONST_DIDATAFORMATFLAGS
#define idh__dx_const_didevcapsflags_dinput_vb 867413                               //  CONST_DIDEVCAPSFLAGS
#define idh__dx_const_dideviceobjinstaceflags_dinput_vb 867414                      //  CONST_DIDEVICEOBJINSTANCEFLAGS
#define idh__dx_const_didevicetype_dinput_vb 867415                                 //  CONST_DIDEVICETYPE
#define idh__dx_const_didftflags_dinput_vb 867416                                   //  CONST_DIDFTFLAGS
#define idh__dx_const_didgddflags_dinput_vb 867417                                  //  CONST_DIDGDDFLAGS
#define idh__dx_const_dienumdevicesflags_dinput_vb 867418                           //  CONST_DIENUMDEVICESFLAGS
#define idh__dx_const_dikeyflags_dinput_vb 867419                                   //  CONST_DIKEYFLAGS
#define idh__dx_const_dinputerr_dinput_vb 867420                                    //  CONST_DINPUTERR
#define idh__dx_const_diphflags_dinput_vb 867421                                    //  CONST_DIPHFLAGS
#define idh__dx_const_disclflags_dinput_vb 867422                                   //  CONST_DISCLFLAGS
#define idh__dx_keyboard_device_constants_dinput_vb 867423                          //  Keyboard Device Constants
#define idh__dx_directinput_and_japanese_keyboards_dinput_vb 867424                 //  DirectInput and Japanese Keyboards
#define idh__dx_mouse_device_constants_dinput_vb 867425                             //  Mouse Device Constants
#define idh__dx_joystick_device_constants_dinput_vb 867426                          //  Joystick Device Constants
#define idh__dx_directmusicband_dmusic_vb 867427                                    //  DirectMusicBand
#define idh__dx_directmusicband_createsegment_dmusic_vb 867428                      //  DirectMusicBand.CreateSegment
#define idh__dx_directmusicband_download_dmusic_vb 867429                           //  DirectMusicBand.Download
#define idh__dx_directmusicband_unload_dmusic_vb 867430                             //  DirectMusicBand.Unload
#define idh__dx_directmusicchordmap_dmusic_vb 867431                                //  DirectMusicChordMap
#define idh__dx_directmusiccollection_dmusic_vb 867432                              //  DirectMusicCollection
#define idh__dx_directmusiccomposer_dmusic_vb 867433                                //  DirectMusicComposer
#define idh__dx_directmusiccomposer_autotransition_dmusic_vb 867434                 //  DirectMusicComposer.AutoTransition
#define idh__dx_directmusiccomposer_changechordmap_dmusic_vb 867435                 //  DirectMusicComposer.ChangeChordMap
#define idh__dx_directmusiccomposer_composesegmentfromshape_dmusic_vb 867436        //  DirectMusicComposer.ComposeSegmentFromShape
#define idh__dx_directmusiccomposer_composesegmentfromtemplate_dmusic_vb 867437     //  DirectMusicComposer.ComposeSegmentFromTemplate
#define idh__dx_directmusiccomposer_composetemplatefromshape_dmusic_vb 867438       //  DirectMusicComposer.ComposeTemplateFromShape
#define idh__dx_directmusiccomposer_composetransition_dmusic_vb 867439              //  DirectMusicComposer.ComposeTransition
#define idh__dx_directmusicloader_dmusic_vb 867440                                  //  DirectMusicLoader
#define idh__dx_directmusicloader_loadband_dmusic_vb 867441                         //  DirectMusicLoader.LoadBand
#define idh__dx_directmusicloader_loadbandfromresource_dmusic_vb 867442             //  DirectMusicLoader.LoadBandFromResource
#define idh__dx_directmusicloader_loadcollection_dmusic_vb 867443                   //  DirectMusicLoader.LoadCollection
#define idh__dx_directmusicloader_loadcollectionfromresource_dmusic_vb 867444       //  DirectMusicLoader.LoadCollectionFromResource
#define idh__dx_directmusicloader_loadsegment_dmusic_vb 867445                      //  DirectMusicLoader.LoadSegment
#define idh__dx_directmusicloader_loadsegmentfromresource_dmusic_vb 867446          //  DirectMusicLoader.LoadSegmentFromResource
#define idh__dx_directmusicloader_loadstyle_dmusic_vb 867447                        //  DirectMusicLoader.LoadStyle
#define idh__dx_directmusicloader_loadstylefromresource_dmusic_vb 867448            //  DirectMusicLoader.LoadStyleFromResource
#define idh__dx_directmusicloader_setsearchdirectory_dmusic_vb 867449               //  DirectMusicLoader.SetSearchDirectory
#define idh__dx_directmusicperformance_dmusic_vb 867450                             //  DirectMusicPerformance
#define idh__dx_directmusicperformance_addnotificationtype_dmusic_vb 867451         //  DirectMusicPerformance.AddNotificationType
#define idh__dx_directmusicperformance_adjusttime_dmusic_vb 867452                  //  DirectMusicPerformance.AdjustTime
#define idh__dx_directmusicperformance_clocktomusictime_dmusic_vb 867453            //  DirectMusicPerformance.ClockToMusicTime
#define idh__dx_directmusicperformance_closedown_dmusic_vb 867454                   //  DirectMusicPerformance.CloseDown
#define idh__dx_directmusicperformance_getbumperlength_dmusic_vb 867455             //  DirectMusicPerformance.GetBumperLength
#define idh__dx_directmusicperformance_getchordmap_dmusic_vb 867456                 //  DirectMusicPerformance.GetChordmap
#define idh__dx_directmusicperformance_getclocktime_dmusic_vb 867457                //  DirectMusicPerformance.GetClockTime
#define idh__dx_directmusicperformance_getcommand_dmusic_vb 867458                  //  DirectMusicPerformance.GetCommand
#define idh__dx_directmusicperformance_getgroovelevel_dmusic_vb 867459              //  DirectMusicPerformance.GetGrooveLevel
#define idh__dx_directmusicperformance_getlatencytime_dmusic_vb 867460              //  DirectMusicPerformance.GetLatencyTime
#define idh__dx_directmusicperformance_getmasterautodownload_dmusic_vb 867461       //  DirectMusicPerformance.GetMasterAutoDownload
#define idh__dx_directmusicperformance_getmastergroovelevel_dmusic_vb 867462        //  DirectMusicPerformance.GetMasterGrooveLevel
#define idh__dx_directmusicperformance_getmastertempo_dmusic_vb 867463              //  DirectMusicPerformance.GetMasterTempo
#define idh__dx_directmusicperformance_getmastervolume_dmusic_vb 867464             //  DirectMusicPerformance.GetMasterVolume
#define idh__dx_directmusicperformance_getmusictime_dmusic_vb 867465                //  DirectMusicPerformance.GetMusicTime
#define idh__dx_directmusicperformance_getnotificationpmsg_dmusic_vb 867466         //  DirectMusicPerformance.GetNotificationPMsg
#define idh__dx_directmusicperformance_getportcaps_dmusic_vb 867467                 //  DirectMusicPerformance.GetPortCaps
#define idh__dx_directmusicperformance_getportcount_dmusic_vb 867468                //  DirectMusicPerformance.GetPortCount
#define idh__dx_directmusicperformance_getportname_dmusic_vb 867469                 //  DirectMusicPerformance.GetPortName
#define idh__dx_directmusicperformance_getpreparetime_dmusic_vb 867470              //  DirectMusicPerformance.GetPrepareTime
#define idh__dx_directmusicperformance_getqueuetime_dmusic_vb 867471                //  DirectMusicPerformance.GetQueueTime
#define idh__dx_directmusicperformance_getresolvedtime_dmusic_vb 867472             //  DirectMusicPerformance.GetResolvedTime
#define idh__dx_directmusicperformance_getsegmentstate_dmusic_vb 867473             //  DirectMusicPerformance.GetSegmentState
#define idh__dx_directmusicperformance_getstyle_dmusic_vb 867474                    //  DirectMusicPerformance.GetStyle
#define idh__dx_directmusicperformance_gettempo_dmusic_vb 867475                    //  DirectMusicPerformance.GetTempo
#define idh__dx_directmusicperformance_gettimesig_dmusic_vb 867476                  //  DirectMusicPerformance.GetTimeSig
#define idh__dx_directmusicperformance_gmreset_dmusic_vb 867477                     //  DirectMusicPerformance.GMReset
#define idh__dx_directmusicperformance_init_dmusic_vb 867478                        //  DirectMusicPerformance.Init
#define idh__dx_directmusicperformance_invalidate_dmusic_vb 867479                  //  DirectMusicPerformance.Invalidate
#define idh__dx_directmusicperformance_isplaying_dmusic_vb 867480                   //  DirectMusicPerformance.IsPlaying
#define idh__dx_directmusicperformance_musictoclocktime_dmusic_vb 867481            //  DirectMusicPerformance.MusicToClockTime
#define idh__dx_directmusicperformance_playsegment_dmusic_vb 867482                 //  DirectMusicPerformance.PlaySegment
#define idh__dx_directmusicperformance_removenotificationtype_dmusic_vb 867483      //  DirectMusicPerformance.RemoveNotificationType
#define idh__dx_directmusicperformance_sendcurvepmsg_dmusic_vb 867484               //  DirectMusicPerformance.SendCurvePMSG
#define idh__dx_directmusicperformance_sendmidipmsg_dmusic_vb 867485                //  DirectMusicPerformance.SendMIDIPMSG
#define idh__dx_directmusicperformance_sendnotepmsg_dmusic_vb 867486                //  DirectMusicPerformance.SendNotePMSG
#define idh__dx_directmusicperformance_sendpatchpmsg_dmusic_vb 867487               //  DirectMusicPerformance.SendPatchPMSG
#define idh__dx_directmusicperformance_sendtempopmsg_dmusic_vb 867488               //  DirectMusicPerformance.SendTempoPMSG
#define idh__dx_directmusicperformance_sendtimesigpmsg_dmusic_vb 867489             //  DirectMusicPerformance.SendTimeSigPMSG
#define idh__dx_directmusicperformance_sendtransposepmsg_dmusic_vb 867490           //  DirectMusicPerformance.SendTransposePMSG
#define idh__dx_directmusicperformance_setbumperlength_dmusic_vb 867491             //  DirectMusicPerformance.SetBumperLength
#define idh__dx_directmusicperformance_setmasterautodownload_dmusic_vb 867492       //  DirectMusicPerformance.SetMasterAutoDownload
#define idh__dx_directmusicperformance_setmastergroovelevel_dmusic_vb 867493        //  DirectMusicPerformance.SetMasterGrooveLevel
#define idh__dx_directmusicperformance_setmastertempo_dmusic_vb 867494              //  DirectMusicPerformance.SetMasterTempo
#define idh__dx_directmusicperformance_setmastervolume_dmusic_vb 867495             //  DirectMusicPerformance.SetMasterVolume
#define idh__dx_directmusicperformance_setnotificationhandle_dmusic_vb 867496       //  DirectMusicPerformance.SetNotificationHandle
#define idh__dx_directmusicperformance_setport_dmusic_vb 867497                     //  DirectMusicPerformance.SetPort
#define idh__dx_directmusicperformance_setpreparetime_dmusic_vb 867498              //  DirectMusicPerformance.SetPrepareTime
#define idh__dx_directmusicperformance_stop_dmusic_vb 867499                        //  DirectMusicPerformance.Stop
#define idh__dx_directmusicsegment_dmusic_vb 867500                                 //  DirectMusicSegment
#define idh__dx_directmusicsegment_clone_dmusic_vb 867501                           //  DirectMusicSegment.Clone
#define idh__dx_directmusicsegment_connecttocollection_dmusic_vb 867502             //  DirectMusicSegment.ConnectToCollection
#define idh__dx_directmusicsegment_download_dmusic_vb 867503                        //  DirectMusicSegment.Download
#define idh__dx_directmusicsegment_getlength_dmusic_vb 867504                       //  DirectMusicSegment.GetLength
#define idh__dx_directmusicsegment_getlooppointend_dmusic_vb 867505                 //  DirectMusicSegment.GetLoopPointEnd
#define idh__dx_directmusicsegment_getlooppointstart_dmusic_vb 867506               //  DirectMusicSegment.GetLoopPointStart
#define idh__dx_directmusicsegment_getrepeats_dmusic_vb 867507                      //  DirectMusicSegment.GetRepeats
#define idh__dx_directmusicsegment_getstartpoint_dmusic_vb 867508                   //  DirectMusicSegment.GetStartPoint
#define idh__dx_directmusicsegment_setautodownloadenable_dmusic_vb 867509           //  DirectMusicSegment.SetAutoDownloadEnable
#define idh__dx_directmusicsegment_setlength_dmusic_vb 867510                       //  DirectMusicSegment.SetLength
#define idh__dx_directmusicsegment_setlooppoints_dmusic_vb 867511                   //  DirectMusicSegment.SetLoopPoints
#define idh__dx_directmusicsegment_setrepeats_dmusic_vb 867512                      //  DirectMusicSegment.SetRepeats
#define idh__dx_directmusicsegment_setstandardmidifile_dmusic_vb 867513             //  DirectMusicSegment.SetStandardMidiFile
#define idh__dx_directmusicsegment_setstartpoint_dmusic_vb 867514                   //  DirectMusicSegment.SetStartPoint
#define idh__dx_directmusicsegment_settempoenable_dmusic_vb 867515                  //  DirectMusicSegment.SetTempoEnable
#define idh__dx_directmusicsegment_settimesigenable_dmusic_vb 867516                //  DirectMusicSegment.SetTimeSigEnable
#define idh__dx_directmusicsegment_unload_dmusic_vb 867517                          //  DirectMusicSegment.Unload
#define idh__dx_directmusicsegmentstate_dmusic_vb 867518                            //  DirectMusicSegmentState
#define idh__dx_directmusicsegmentstate_getrepeats_dmusic_vb 867519                 //  DirectMusicSegmentState.GetRepeats
#define idh__dx_directmusicsegmentstate_getseek_dmusic_vb 867520                    //  DirectMusicSegmentState.GetSeek
#define idh__dx_directmusicsegmentstate_getsegment_dmusic_vb 867521                 //  DirectMusicSegmentState.GetSegment
#define idh__dx_directmusicsegmentstate_getstartpoint_dmusic_vb 867522              //  DirectMusicSegmentState.GetStartPoint
#define idh__dx_directmusicsegmentstate_getstarttime_dmusic_vb 867523               //  DirectMusicSegmentState.GetStartTime
#define idh__dx_directmusicstyle_dmusic_vb 867524                                   //  DirectMusicStyle
#define idh__dx_directmusicstyle_getband_dmusic_vb 867525                           //  DirectMusicStyle.GetBand
#define idh__dx_directmusicstyle_getbandcount_dmusic_vb 867526                      //  DirectMusicStyle.GetBandCount
#define idh__dx_directmusicstyle_getbandname_dmusic_vb 867527                       //  DirectMusicStyle.GetBandName
#define idh__dx_directmusicstyle_getchordmap_dmusic_vb 867528                       //  DirectMusicStyle.GetChordmap
#define idh__dx_directmusicstyle_getchordmapcount_dmusic_vb 867529                  //  DirectMusicStyle.GetChordmapCount
#define idh__dx_directmusicstyle_getchordmapname_dmusic_vb 867530                   //  DirectMusicStyle.GetChordmapName
#define idh__dx_directmusicstyle_getdefaultband_dmusic_vb 867531                    //  DirectMusicStyle.GetDefaultBand
#define idh__dx_directmusicstyle_getdefaultchordmap_dmusic_vb 867532                //  DirectMusicStyle.GetDefaultChordMap
#define idh__dx_directmusicstyle_getmotif_dmusic_vb 867533                          //  DirectMusicStyle.GetMotif
#define idh__dx_directmusicstyle_getmotifcount_dmusic_vb 867534                     //  DirectMusicStyle.GetMotifCount
#define idh__dx_directmusicstyle_getmotifname_dmusic_vb 867535                      //  DirectMusicStyle.GetMotifName
#define idh__dx_directmusicstyle_gettempo_dmusic_vb 867536                          //  DirectMusicStyle.GetTempo
#define idh__dx_directmusicstyle_gettimesignature_dmusic_vb 867537                  //  DirectMusicStyle.GetTimeSignature
#define idh__dx_dmus_curve_pmsg_dmusic_vb 867538                                    //  DMUS_CURVE_PMSG
#define idh__dx_dmus_note_pmsg_dmusic_vb 867539                                     //  DMUS_NOTE_PMSG
#define idh__dx_dmus_notification_pmsg_dmusic_vb 867540                             //  DMUS_NOTIFICATION_PMSG
#define idh__dx_dmus_portcaps_dmusic_vb 867541                                      //  DMUS_PORTCAPS
#define idh__dx_dmus_timesignature_dmusic_vb 867542                                 //  DMUS_TIMESIGNATURE
#define idh__dx_const_dmus_notificationtype_dmusic_vb 867543                        //  CONST_DMUS_NOTIFICATIONTYPE
#define idh__dx_enumdmus_commandt_types_dmusic_vb 867544                            //  enumDMUS_COMMANDT_TYPES
#define idh__dx_enumdmus_composef_flags_dmusic_vb 867545                            //  enumDMUS_COMPOSEF_FLAGS
#define idh__dx_enumdmus_playmode_flags_dmusic_vb 867546                            //  enumDMUS_PLAYMODE_FLAGS
#define idh__dx_enumdmus_pmsgf_flags_dmusic_vb 867547                               //  enumDMUS_PMSGF_FLAGS
#define idh__dx_enumdmus_segf_flags_dmusic_vb 867548                                //  enumDMUS_SEGF_FLAGS
#define idh__dx_enumdmus_shapet_types_dmusic_vb 867549                              //  enumDMUS_SHAPET_TYPES
#define idh__dx_directplay4_dplay_vb 867550                                         //  DirectPlay4
#define idh__dx_directplay4_addgrouptogroup_dplay_vb 867551                         //  DirectPlay4.AddGroupToGroup
#define idh__dx_directplay4_addplayertogroup_dplay_vb 867552                        //  DirectPlay4.AddPlayerToGroup
#define idh__dx_directplay4_cancelmessage_dplay_vb 867553                           //  DirectPlay4.CancelMessage
#define idh__dx_directplay4_cancelpriority_dplay_vb 867554                          //  DirectPlay4.CancelPriority
#define idh__dx_directplay4_close_dplay_vb 867555                                   //  DirectPlay4.Close
#define idh__dx_directplay4_creategroup_dplay_vb 867556                             //  DirectPlay4.CreateGroup
#define idh__dx_directplay4_creategroupingroup_dplay_vb 867557                      //  DirectPlay4.CreateGroupInGroup
#define idh__dx_directplay4_createmessage_dplay_vb 867558                           //  DirectPlay4.CreateMessage
#define idh__dx_directplay4_createplayer_dplay_vb 867559                            //  DirectPlay4.CreatePlayer
#define idh__dx_directplay4_createsessiondata_dplay_vb 867560                       //  DirectPlay4.CreateSessionData
#define idh__dx_directplay4_deletegroupfromgroup_dplay_vb 867561                    //  DirectPlay4.DeleteGroupFromGroup
#define idh__dx_directplay4_deleteplayerfromgroup_dplay_vb 867562                   //  DirectPlay4.DeletePlayerFromGroup
#define idh__dx_directplay4_destroygroup_dplay_vb 867563                            //  DirectPlay4.DestroyGroup
#define idh__dx_directplay4_destroyplayer_dplay_vb 867564                           //  DirectPlay4.DestroyPlayer
#define idh__dx_directplay4_getcaps_dplay_vb 867565                                 //  DirectPlay4.GetCaps
#define idh__dx_directplay4_getdpenumconnections_dplay_vb 867566                    //  DirectPlay4.GetDPEnumConnections
#define idh__dx_directplay4_getdpenumgroupplayers_dplay_vb 867567                   //  DirectPlay4.GetDPEnumGroupPlayers
#define idh__dx_directplay4_getdpenumgroups_dplay_vb 867568                         //  DirectPlay4.GetDPEnumGroups
#define idh__dx_directplay4_getdpenumgroupsingroup_dplay_vb 867569                  //  DirectPlay4.GetDPEnumGroupsInGroup
#define idh__dx_directplay4_getdpenumplayers_dplay_vb 867570                        //  DirectPlay4.GetDPEnumPlayers
#define idh__dx_directplay4_getdpenumsessions_dplay_vb 867571                       //  DirectPlay4.GetDPEnumSessions
#define idh__dx_directplay4_getgroupdata_dplay_vb 867572                            //  DirectPlay4.GetGroupData
#define idh__dx_directplay4_getgroupflags_dplay_vb 867573                           //  DirectPlay4.GetGroupFlags
#define idh__dx_directplay4_getgrouplongname_dplay_vb 867574                        //  DirectPlay4.GetGroupLongName
#define idh__dx_directplay4_getgroupowner_dplay_vb 867575                           //  DirectPlay4.GetGroupOwner
#define idh__dx_directplay4_getgroupparent_dplay_vb 867576                          //  DirectPlay4.GetGroupParent
#define idh__dx_directplay4_getgroupshortname_dplay_vb 867577                       //  DirectPlay4.GetGroupShortName
#define idh__dx_directplay4_getmessagecount_dplay_vb 867578                         //  DirectPlay4.GetMessageCount
#define idh__dx_directplay4_getmessagequeue_dplay_vb 867579                         //  DirectPlay4.GetMessageQueue
#define idh__dx_directplay4_getplayeraccountid_dplay_vb 867580                      //  DirectPlay4.GetPlayerAccountId
#define idh__dx_directplay4_getplayeraddress_dplay_vb 867581                        //  DirectPlay4.GetPlayerAddress
#define idh__dx_directplay4_getplayercaps_dplay_vb 867582                           //  DirectPlay4.GetPlayerCaps
#define idh__dx_directplay4_getplayerdata_dplay_vb 867583                           //  DirectPlay4.GetPlayerData
#define idh__dx_directplay4_getplayerflags_dplay_vb 867584                          //  DirectPlay4.GetPlayerFlags
#define idh__dx_directplay4_getplayerformalname_dplay_vb 867585                     //  DirectPlay4.GetPlayerFormalName
#define idh__dx_directplay4_getplayerfriendlyname_dplay_vb 867586                   //  DirectPlay4.GetPlayerFriendlyName
#define idh__dx_directplay4_getsessiondesc_dplay_vb 867587                          //  DirectPlay4.GetSessionDesc
#define idh__dx_directplay4_initializeconnection_dplay_vb 867588                    //  DirectPlay4.InitializeConnection
#define idh__dx_directplay4_open_dplay_vb 867589                                    //  DirectPlay4.Open
#define idh__dx_directplay4_receive_dplay_vb 867590                                 //  DirectPlay4.Receive
#define idh__dx_directplay4_secureopen_dplay_vb 867591                              //  DirectPlay4.SecureOpen
#define idh__dx_directplay4_send_dplay_vb 867592                                    //  DirectPlay4.Send
#define idh__dx_directplay4_sendchatmessage_dplay_vb 867593                         //  DirectPlay4.SendChatMessage
#define idh__dx_directplay4_sendex_dplay_vb 867594                                  //  DirectPlay4.SendEx
#define idh__dx_directplay4_setgroupconnectionsettings_dplay_vb 867595              //  DirectPlay4.SetGroupConnectionSettings
#define idh__dx_directplay4_setgroupdata_dplay_vb 867596                            //  DirectPlay4.SetGroupData
#define idh__dx_directplay4_setgroupname_dplay_vb 867597                            //  DirectPlay4.SetGroupName
#define idh__dx_directplay4_setgroupowner_dplay_vb 867598                           //  DirectPlay4.SetGroupOwner
#define idh__dx_directplay4_setplayerdata_dplay_vb 867599                           //  DirectPlay4.SetPlayerData
#define idh__dx_directplay4_setplayername_dplay_vb 867600                           //  DirectPlay4.SetPlayerName
#define idh__dx_directplay4_setsessiondesc_dplay_vb 867601                          //  DirectPlay4.SetSessionDesc
#define idh__dx_directplay4_startsession_dplay_vb 867602                            //  DirectPlay4.StartSession
#define idh__dx_directplayaddress_dplay_vb 867603                                   //  DirectPlayAddress
#define idh__dx_directplayenumaddress_dplay_vb 867604                               //  DirectPlayEnumAddress
#define idh__dx_directplayenumaddress_getcount_dplay_vb 867605                      //  DirectPlayEnumAddress.GetCount
#define idh__dx_directplayenumaddress_getdata_dplay_vb 867606                       //  DirectPlayEnumAddress.GetData
#define idh__dx_directplayenumaddress_gettype_dplay_vb 867607                       //  DirectPlayEnumAddress.GetType
#define idh__dx_directplayenumaddresstypes_dplay_vb 867608                          //  DirectPlayEnumAddressTypes
#define idh__dx_directplayenumaddresstypes_getcount_dplay_vb 867609                 //  DirectPlayEnumAddressTypes.GetCount
#define idh__dx_directplayenumaddresstypes_gettype_dplay_vb 867610                  //  DirectPlayEnumAddressTypes.GetType
#define idh__dx_directplayenumconnections_dplay_vb 867611                           //  DirectPlayEnumConnections
#define idh__dx_directplayenumconnections_getaddress_dplay_vb 867612                //  DirectPlayEnumConnections.GetAddress
#define idh__dx_directplayenumconnections_getcount_dplay_vb 867613                  //  DirectPlayEnumConnections.GetCount
#define idh__dx_directplayenumconnections_getflags_dplay_vb 867614                  //  DirectPlayEnumConnections.GetFlags
#define idh__dx_directplayenumconnections_getguid_dplay_vb 867615                   //  DirectPlayEnumConnections.GetGuid
#define idh__dx_directplayenumconnections_getshortname_dplay_vb 867616              //  DirectPlayEnumConnections.GetName
#define idh__dx_directplayenumlocalapplications_dplay_vb 867617                     //  DirectPlayEnumLocalApplications
#define idh__dx_directplayenumlocalapplications_getcount_dplay_vb 867618            //  DirectPlayEnumLocalApplications.GetCount
#define idh__dx_directplayenumlocalapplications_getguid_dplay_vb 867619             //  DirectPlayEnumLocalApplications.GetGuid
#define idh__dx_directplayenumlocalapplications_getname_dplay_vb 867620             //  DirectPlayEnumLocalApplications.GetName
#define idh__dx_directplayenumplayers_dplay_vb 867621                               //  DirectPlayEnumPlayers
#define idh__dx_directplayenumplayers_getcount_dplay_vb 867622                      //  DirectPlayEnumPlayers.GetCount
#define idh__dx_directplayenumplayers_getdpid_dplay_vb 867623                       //  DirectPlayEnumPlayers.GetDPID
#define idh__dx_directplayenumplayers_getflags_dplay_vb 867624                      //  DirectPlayEnumPlayers.GetFlags
#define idh__dx_directplayenumplayers_getlongname_dplay_vb 867625                   //  DirectPlayEnumPlayers.GetLongName
#define idh__dx_directplayenumplayers_getshortname_dplay_vb 867626                  //  DirectPlayEnumPlayers.GetShortName
#define idh__dx_directplayenumplayers_gettype_dplay_vb 867627                       //  DirectPlayEnumPlayers.GetType
#define idh__dx_directplayenumserviceproviders_dplay_vb 867628                      //  DirectPlayEnumServiceProviders
#define idh__dx_directplayenumserviceproviders_getcount_dplay_vb 867629             //  DirectPlayEnumServiceProviders.GetCount
#define idh__dx_directplayenumserviceproviders_getguid_dplay_vb 867630              //  DirectPlayEnumServiceProviders.GetGuid
#define idh__dx_directplayenumserviceproviders_getname_dplay_vb 867631              //  DirectPlayEnumServiceProviders.GetName
#define idh__dx_directplayenumserviceproviders_getversion_dplay_vb 867632           //  DirectPlayEnumServiceProviders.GetVersion
#define idh__dx_directplayenumsessions_dplay_vb 867633                              //  DirectPlayEnumSessions
#define idh__dx_directplayenumsessions_getcount_dplay_vb 867634                     //  DirectPlayEnumSessions.GetCount
#define idh__dx_directplayenumsessions_getitem_dplay_vb 867635                      //  DirectPlayEnumSessions.GetItem
#define idh__dx_directplaylobby3_dplay_vb 867636                                    //  DirectPlayLobby3
#define idh__dx_directplaylobby3_connect_dplay_vb 867637                            //  DirectPlayLobby3.Connect
#define idh__dx_directplaylobby3_createaddress_dplay_vb 867638                      //  DirectPlayLobby3.CreateAddress
#define idh__dx_directplaylobby3_createcompoundaddress_dplay_vb 867639              //  DirectPlayLobby3.CreateCompoundAddress
#define idh__dx_directplaylobby3_createconnectiondata_dplay_vb 867640               //  DirectPlayLobby3.CreateConnectionData
#define idh__dx_directplaylobby3_createmessage_dplay_vb 867641                      //  DirectPlayLobby3.CreateMessage
#define idh__dx_directplaylobby3_getconnectionsettings_dplay_vb 867642              //  DirectPlayLobby3.GetConnectionSettings
#define idh__dx_directplaylobby3_getdpenumaddress_dplay_vb 867643                   //  DirectPlayLobby3.GetDPEnumAddress
#define idh__dx_directplaylobby3_getdpenumaddresstypes_dplay_vb 867644              //  DirectPlayLobby3.GetDPEnumAddressTypes
#define idh__dx_directplaylobby3_getdpenumlocalapplications_dplay_vb 867645         //  DirectPlayLobby3.GetDPEnumLocalApplications
#define idh__dx_directplaylobby3_receivelobbymessage_dplay_vb 867646                //  DirectPlayLobby3.ReceiveLobbyMessage
#define idh__dx_directplaylobby3_registerapplication_dplay_vb 867647                //  DirectPlayLobby3.RegisterApplication
#define idh__dx_directplaylobby3_runapplication_dplay_vb 867648                     //  DirectPlayLobby3.RunApplication
#define idh__dx_directplaylobby3_sendlobbymessage_dplay_vb 867649                   //  DirectPlayLobby3.SendLobbyMessage
#define idh__dx_directplaylobby3_setconnectionsettings_dplay_vb 867650              //  DirectPlayLobby3.SetConnectionSettings
#define idh__dx_directplaylobby3_setlobbymessageevent_dplay_vb 867651               //  DirectPlayLobby3.SetLobbyMessageEvent
#define idh__dx_directplaylobby3_unregisterapplication_dplay_vb 867652              //  DirectPlayLobby3.UnregisterApplication
#define idh__dx_directplaylobby3_waitforconnectionsettings_dplay_vb 867653          //  DirectPlayLobby3.WaitForConnectionSettings
#define idh__dx_directplaylobbyconnection_dplay_vb 867654                           //  DirectPlayLobbyConnection
#define idh__dx_directplaylobbyconnection_getaddress_dplay_vb 867655                //  DirectPlayLobbyConnection.GetAddress
#define idh__dx_directplaylobbyconnection_getflags_dplay_vb 867656                  //  DirectPlayLobbyConnection.GetFlags
#define idh__dx_directplaylobbyconnection_getguidsp_dplay_vb 867657                 //  DirectPlayLobbyConnection.GetGuidSP
#define idh__dx_directplaylobbyconnection_getplayerlongname_dplay_vb 867658         //  DirectPlayLobbyConnection.GetPlayerLongName
#define idh__dx_directplaylobbyconnection_getplayershortname_dplay_vb 867659        //  DirectPlayLobbyConnection.GetPlayerShortName
#define idh__dx_directplaylobbyconnection_getsessiondesc_dplay_vb 867660            //  DirectPlayLobbyConnection.GetSessionDesc
#define idh__dx_directplaylobbyconnection_setaddress_dplay_vb 867661                //  DirectPlayLobbyConnection.SetAddress
#define idh__dx_directplaylobbyconnection_setflags_dplay_vb 867662                  //  DirectPlayLobbyConnection.SetFlags
#define idh__dx_directplaylobbyconnection_setguidsp_dplay_vb 867663                 //  DirectPlayLobbyConnection.SetGuidSP
#define idh__dx_directplaylobbyconnection_setplayerlongname_dplay_vb 867664         //  DirectPlayLobbyConnection.SetPlayerLongName
#define idh__dx_directplaylobbyconnection_setplayershortname_dplay_vb 867665        //  DirectPlayLobbyConnection.SetPlayerShortName
#define idh__dx_directplaylobbyconnection_setsessiondesc_dplay_vb 867666            //  DirectPlayLobbyConnection.SetSessionDesc
#define idh__dx_directplaymessage_dplay_vb 867667                                   //  DirectPlayMessage
#define idh__dx_directplaymessage_clear_dplay_vb 867668                             //  DirectPlayMessage.Clear
#define idh__dx_directplaymessage_getmessagedata_dplay_vb 867669                    //  DirectPlayMessage.GetMessageData
#define idh__dx_directplaymessage_getmessagesize_dplay_vb 867670                    //  DirectPlayMessage.GetMessageSize
#define idh__dx_directplaymessage_movetotop_dplay_vb 867671                         //  DirectPlayMessage.MoveToTop
#define idh__dx_directplaymessage_readbyte_dplay_vb 867672                          //  DirectPlayMessage.ReadByte
#define idh__dx_directplaymessage_readdouble_dplay_vb 867673                        //  DirectPlayMessage.ReadDouble
#define idh__dx_directplaymessage_readguid_dplay_vb 867674                          //  DirectPlayMessage.ReadGuid
#define idh__dx_directplaymessage_readlong_dplay_vb 867675                          //  DirectPlayMessage.ReadLong
#define idh__dx_directplaymessage_readshort_dplay_vb 867676                         //  DirectPlayMessage.ReadShort
#define idh__dx_directplaymessage_readsingle_dplay_vb 867677                        //  DirectPlayMessage.ReadSingle
#define idh__dx_directplaymessage_readstring_dplay_vb 867678                        //  DirectPlayMessage.ReadString
#define idh__dx_directplaymessage_setmessagedata_dplay_vb 867679                    //  DirectPlayMessage.SetMessageData
#define idh__dx_directplaymessage_writebyte_dplay_vb 867680                         //  DirectPlayMessage.WriteByte
#define idh__dx_directplaymessage_writedouble_dplay_vb 867681                       //  DirectPlayMessage.WriteDouble
#define idh__dx_directplaymessage_writeguid_dplay_vb 867682                         //  DirectPlayMessage.WriteGuid
#define idh__dx_directplaymessage_writelong_dplay_vb 867683                         //  DirectPlayMessage.WriteLong
#define idh__dx_directplaymessage_writeshort_dplay_vb 867684                        //  DirectPlayMessage.WriteShort
#define idh__dx_directplaymessage_writesingle_dplay_vb 867685                       //  DirectPlayMessage.WriteSingle
#define idh__dx_directplaymessage_writestring_dplay_vb 867686                       //  DirectPlayMessage.WriteString
#define idh__dx_directplaysessiondata_dplay_vb 867687                               //  DirectPlaySessionData
#define idh__dx_directplaysessiondata_getcurrentplayers_dplay_vb 867688             //  DirectPlaySessionData.GetCurrentPlayers
#define idh__dx_directplaysessiondata_getflags_dplay_vb 867689                      //  DirectPlaySessionData.GetFlags
#define idh__dx_directplaysessiondata_getguidapplication_dplay_vb 867690            //  DirectPlaySessionData.GetGuidApplication
#define idh__dx_directplaysessiondata_getguidinstance_dplay_vb 867691               //  DirectPlaySessionData.GetGuidInstance
#define idh__dx_directplaysessiondata_getmaxplayers_dplay_vb 867692                 //  DirectPlaySessionData.GetMaxPlayers
#define idh__dx_directplaysessiondata_getsessionname_dplay_vb 867693                //  DirectPlaySessionData.GetSessionName
#define idh__dx_directplaysessiondata_getsessionpassword_dplay_vb 867694            //  DirectPlaySessionData.GetSessionPassword
#define idh__dx_directplaysessiondata_getuser_n__dplay_vb 867695                    //  DirectPlaySessionData.GetUser(n)
#define idh__dx_directplaysessiondata_setflags_dplay_vb 867696                      //  DirectPlaySessionData.SetFlags
#define idh__dx_directplaysessiondata_setguidapplication_dplay_vb 867697            //  DirectPlaySessionData.SetGuidApplication
#define idh__dx_directplaysessiondata_setguidinstance_dplay_vb 867698               //  DirectPlaySessionData.SetGuidInstance
#define idh__dx_directplaysessiondata_setmaxplayers_dplay_vb 867699                 //  DirectPlaySessionData.SetMaxPlayers
#define idh__dx_directplaysessiondata_setsessionname_dplay_vb 867700                //  DirectPlaySessionData.SetSessionName
#define idh__dx_directplaysessiondata_setsessionpassword_dplay_vb 867701            //  DirectPlaySessionData.SetSessionPassword
#define idh__dx_directplaysessiondata_setuser_n__dplay_vb 867702                    //  DirectPlaySessionData.SetUser(n)
#define idh__dx_dpapplicationdesc_dplay_vb 867703                                   //  DPAPPLICATIONDESC
#define idh__dx_dpcaps_dplay_vb 867704                                              //  DPCAPS
#define idh__dx_dpcompoundaddresselement_dplay_vb 867705                            //  DPCOMPOUNDADDRESSELEMENT
#define idh__dx_dpcredentials_dplay_vb 867706                                       //  DPCREDENTIALS
#define idh__dx_dpplayerids_dplay_vb 867707                                         //  DPPLAYERIDS
#define idh__dx_dpsecuritydesc_dplay_vb 867708                                      //  DPSECURITYDESC
#define idh__dx_const_dpcapsflags_dplay_vb 867709                                   //  CONST_DPCAPSFLAGS
#define idh__dx_const_dpconnectflags_dplay_vb 867710                                //  CONST_DPCONNECTFLAGS
#define idh__dx_const_dpenumconnectionflags_dplay_vb 867711                         //  CONST_DPENUMCONNECTIONFLAGS
#define idh__dx_const_dpenumgroupflags_dplay_vb 867712                              //  CONST_DPENUMGROUPFLAGS
#define idh__dx_const_dpenumplayerflags_dplay_vb 867713                             //  CONST_DPENUMPLAYERFLAGS
#define idh__dx_const_dpenumsessionflags_dplay_vb 867714                            //  CONST_DPENUMSESSIONFLAGS
#define idh__dx_const_dpgetcapsflags_dplay_vb 867715                                //  CONST_DPGETCAPSFLAGS
#define idh__dx_const_dpgetflags_dplay_vb 867716                                    //  CONST_DPGETFLAGS
#define idh__dx_const_dpgroupflags_dplay_vb 867717                                  //  CONST_DPGROUPFLAGS
#define idh__dx_const_dpidflags_dplay_vb 867718                                     //  CONST_DPIDFLAGS
#define idh__dx_const_dpplayerflags_dplay_vb 867719                                 //  CONST_DPPLAYERFLAGS
#define idh__dx_const_dpsessionflags_dplay_vb 867720                                //  CONST_DPSESSIONFLAGS
#define idh__dx_const_dpsetflags_dplay_vb 867721                                    //  CONST_DPSETFLAGS
#define idh__dx_directsound_dsound_vb 867722                                        //  DirectSound
#define idh__dx_directsound_compact_dsound_vb 867723                                //  DirectSound.Compact
#define idh__dx_directsound_createsoundbuffer_dsound_vb 867724                      //  DirectSound.CreateSoundBuffer
#define idh__dx_directsound_createsoundbufferfromfile_dsound_vb 867725              //  DirectSound.CreateSoundBufferFromFile
#define idh__dx_directsound_createsoundbufferfromresource_dsound_vb 867726          //  DirectSound.CreateSoundBufferFromResource
#define idh__dx_directsound_duplicatesoundbuffer_dsound_vb 867727                   //  DirectSound.DuplicateSoundBuffer
#define idh__dx_directsound_getcaps_dsound_vb 867728                                //  DirectSound.GetCaps
#define idh__dx_directsound_getspeakerconfig_dsound_vb 867729                       //  DirectSound.GetSpeakerConfig
#define idh__dx_directsound_setcooperativelevel_dsound_vb 867730                    //  DirectSound.SetCooperativeLevel
#define idh__dx_directsound_setspeakerconfig_dsound_vb 867731                       //  DirectSound.SetSpeakerConfig
#define idh__dx_directsound3dbuffer_dsound_vb 867732                                //  DirectSounD3DBuffer
#define idh__dx_directsound3dbuffer_getallparameters_dsound_vb 867733               //  DirectSounD3DBuffer.GetAllParameters
#define idh__dx_directsound3dbuffer_getconeangles_dsound_vb 867734                  //  DirectSounD3DBuffer.GetConeAngles
#define idh__dx_directsound3dbuffer_getconeorientation_dsound_vb 867735             //  DirectSounD3DBuffer.GetConeOrientation
#define idh__dx_directsound3dbuffer_getconeoutsidevolume_dsound_vb 867736           //  DirectSounD3DBuffer.GetConeOutsideVolume
#define idh__dx_directsound3dbuffer_getdirectsound3dlistener_dsound_vb 867737       //  DirectSounD3DBuffer.GetDirectSounD3DListener
#define idh__dx_directsound3dbuffer_getdirectsoundbuffer_dsound_vb 867738           //  DirectSounD3DBuffer.GetDirectSoundBuffer
#define idh__dx_directsound3dbuffer_getmaxdistance_dsound_vb 867739                 //  DirectSounD3DBuffer.GetMaxDistance
#define idh__dx_directsound3dbuffer_getmindistance_dsound_vb 867740                 //  DirectSounD3DBuffer.GetMinDistance
#define idh__dx_directsound3dbuffer_getmode_dsound_vb 867741                        //  DirectSounD3DBuffer.GetMode
#define idh__dx_directsound3dbuffer_getposition_dsound_vb 867742                    //  DirectSounD3DBuffer.GetPosition
#define idh__dx_directsound3dbuffer_getvelocity_dsound_vb 867743                    //  DirectSounD3DBuffer.GetVelocity
#define idh__dx_directsound3dbuffer_setallparameters_dsound_vb 867744               //  DirectSounD3DBuffer.SetAllParameters
#define idh__dx_directsound3dbuffer_setconeangles_dsound_vb 867745                  //  DirectSounD3DBuffer.SetConeAngles
#define idh__dx_directsound3dbuffer_setconeorientation_dsound_vb 867746             //  DirectSounD3DBuffer.SetConeOrientation
#define idh__dx_directsound3dbuffer_setconeoutsidevolume_dsound_vb 867747           //  DirectSounD3DBuffer.SetConeOutsideVolume
#define idh__dx_directsound3dbuffer_setmaxdistance_dsound_vb 867748                 //  DirectSounD3DBuffer.SetMaxDistance
#define idh__dx_directsound3dbuffer_setmindistance_dsound_vb 867749                 //  DirectSounD3DBuffer.SetMinDistance
#define idh__dx_directsound3dbuffer_setmode_dsound_vb 867750                        //  DirectSounD3DBuffer.SetMode
#define idh__dx_directsound3dbuffer_setposition_dsound_vb 867751                    //  DirectSounD3DBuffer.SetPosition
#define idh__dx_directsound3dbuffer_setvelocity_dsound_vb 867752                    //  DirectSounD3DBuffer.SetVelocity
#define idh__dx_directsound3dlistener_dsound_vb 867753                              //  DirectSounD3DListener
#define idh__dx_directsound3dlistener_commitdeferredsettings_dsound_vb 867754       //  DirectSounD3DListener.CommitDeferredSettings
#define idh__dx_directsound3dlistener_getallparameters_dsound_vb 867755             //  DirectSounD3DListener.GetAllParameters
#define idh__dx_directsound3dlistener_getdirectsoundbuffer_dsound_vb 867756         //  DirectSounD3DListener.GetDirectSoundBuffer
#define idh__dx_directsound3dlistener_getdistancefactor_dsound_vb 867757            //  DirectSounD3DListener.GetDistanceFactor
#define idh__dx_directsound3dlistener_getdopplerfactor_dsound_vb 867758             //  DirectSounD3DListener.GetDopplerFactor
#define idh__dx_directsound3dlistener_getorientation_dsound_vb 867759               //  DirectSounD3DListener.GetOrientation
#define idh__dx_directsound3dlistener_getposition_dsound_vb 867760                  //  DirectSounD3DListener.GetPosition
#define idh__dx_directsound3dlistener_getrollofffactor_dsound_vb 867761             //  DirectSounD3DListener.GetRolloffFactor
#define idh__dx_directsound3dlistener_getvelocity_dsound_vb 867762                  //  DirectSounD3DListener.GetVelocity
#define idh__dx_directsound3dlistener_setallparameters_dsound_vb 867763             //  DirectSounD3DListener.SetAllParameters
#define idh__dx_directsound3dlistener_setdistancefactor_dsound_vb 867764            //  DirectSounD3DListener.SetDistanceFactor
#define idh__dx_directsound3dlistener_setdopplerfactor_dsound_vb 867765             //  DirectSounD3DListener.SetDopplerFactor
#define idh__dx_directsound3dlistener_setorientation_dsound_vb 867766               //  DirectSounD3DListener.SetOrientation
#define idh__dx_directsound3dlistener_setposition_dsound_vb 867767                  //  DirectSounD3DListener.SetPosition
#define idh__dx_directsound3dlistener_setrollofffactor_dsound_vb 867768             //  DirectSounD3DListener.SetRolloffFactor
#define idh__dx_directsound3dlistener_setvelocity_dsound_vb 867769                  //  DirectSounD3DListener.SetVelocity
#define idh__dx_directsoundbuffer_dsound_vb 867770                                  //  DirectSoundBuffer
#define idh__dx_directsoundbuffer_getcaps_dsound_vb 867771                          //  DirectSoundBuffer.GetCaps
#define idh__dx_directsoundbuffer_getcurrentposition_dsound_vb 867772               //  DirectSoundBuffer.GetCurrentPosition
#define idh__dx_directsoundbuffer_getdirectsound3dbuffer_dsound_vb 867773           //  DirectSoundBuffer.GetDirectSounD3DBuffer
#define idh__dx_directsoundbuffer_getdirectsound3dlistener_dsound_vb 867774         //  DirectSoundBuffer.GetDirectSounD3DListener
#define idh__dx_directsoundbuffer_getformat_dsound_vb 867775                        //  DirectSoundBuffer.GetFormat
#define idh__dx_directsoundbuffer_getfrequency_dsound_vb 867776                     //  DirectSoundBuffer.GetFrequency
#define idh__dx_directsoundbuffer_getpan_dsound_vb 867777                           //  DirectSoundBuffer.GetPan
#define idh__dx_directsoundbuffer_getstatus_dsound_vb 867778                        //  DirectSoundBuffer.GetStatus
#define idh__dx_directsoundbuffer_getvolume_dsound_vb 867779                        //  DirectSoundBuffer.GetVolume
#define idh__dx_directsoundbuffer_play_dsound_vb 867780                             //  DirectSoundBuffer.Play
#define idh__dx_directsoundbuffer_readbuffer_dsound_vb 867781                       //  DirectSoundBuffer.ReadBuffer
#define idh__dx_directsoundbuffer_restore_dsound_vb 867782                          //  DirectSoundBuffer.Restore
#define idh__dx_directsoundbuffer_setcurrentposition_dsound_vb 867783               //  DirectSoundBuffer.SetCurrentPosition
#define idh__dx_directsoundbuffer_setformat_dsound_vb 867784                        //  DirectSoundBuffer.SetFormat
#define idh__dx_directsoundbuffer_setfrequency_dsound_vb 867785                     //  DirectSoundBuffer.SetFrequency
#define idh__dx_directsoundbuffer_setnotificationpositions_dsound_vb 867786         //  DirectSoundBuffer.SetNotificationPositions
#define idh__dx_directsoundbuffer_setpan_dsound_vb 867787                           //  DirectSoundBuffer.SetPan
#define idh__dx_directsoundbuffer_setvolume_dsound_vb 867788                        //  DirectSoundBuffer.SetVolume
#define idh__dx_directsoundbuffer_stop_dsound_vb 867789                             //  DirectSoundBuffer.Stop
#define idh__dx_directsoundbuffer_writebuffer_dsound_vb 867790                      //  DirectSoundBuffer.WriteBuffer
#define idh__dx_directsoundcapture_dsound_vb 867791                                 //  DirectSoundCapture
#define idh__dx_directsoundcapture_createcapturebuffer_dsound_vb 867792             //  DirectSoundCapture.CreateCaptureBuffer
#define idh__dx_directsoundcapture_getcaps_dsound_vb 867793                         //  DirectSoundCapture.GetCaps
#define idh__dx_directsoundcapturebuffer_dsound_vb 867794                           //  DirectSoundCaptureBuffer
#define idh__dx_directsoundcapturebuffer_getcaps_dsound_vb 867795                   //  DirectSoundCaptureBuffer.GetCaps
#define idh__dx_directsoundcapturebuffer_getcurrentposition_dsound_vb 867796        //  DirectSoundCaptureBuffer.GetCurrentPosition
#define idh__dx_directsoundcapturebuffer_getformat_dsound_vb 867797                 //  DirectSoundCaptureBuffer.GetFormat
#define idh__dx_directsoundcapturebuffer_getstatus_dsound_vb 867798                 //  DirectSoundCaptureBuffer.GetStatus
#define idh__dx_directsoundcapturebuffer_readbuffer_dsound_vb 867799                //  DirectSoundCaptureBuffer.ReadBuffer
#define idh__dx_directsoundcapturebuffer_setnotificationpositions_dsound_vb 867800  //  DirectSoundCaptureBuffer.SetNotificationPositions
#define idh__dx_directsoundcapturebuffer_start_dsound_vb 867801                     //  DirectSoundCaptureBuffer.Start
#define idh__dx_directsoundcapturebuffer_stop_dsound_vb 867802                      //  DirectSoundCaptureBuffer.Stop
#define idh__dx_directsoundcapturebuffer_writebuffer_dsound_vb 867803               //  DirectSoundCaptureBuffer.WriteBuffer
#define idh__dx_directsoundenum_dsound_vb 867804                                    //  DirectSoundEnum
#define idh__dx_directsoundenum_getcount_dsound_vb 867805                           //  DirectSoundEnum.GetCount
#define idh__dx_directsoundenum_getitem_dsound_vb 867806                            //  DirectSoundEnum.GetItem
#define idh__dx_directx7_dsound_vb 867807                                           //  DirectX7
#define idh__dx_ds3dbuffer_dsound_vb 867808                                         //  DS3DBUFFER
#define idh__dx_ds3dlistener_dsound_vb 867809                                       //  DS3DLISTENER
#define idh__dx_dsbcaps_dsound_vb 867810                                            //  DSBCAPS
#define idh__dx_dsbpositionnotify_dsound_vb 867811                                  //  DSBPOSITIONNOTIFY
#define idh__dx_dsbufferdesc_dsound_vb 867812                                       //  DSBUFFERDESC
#define idh__dx_dscaps_dsound_vb 867813                                             //  DSCAPS
#define idh__dx_dscbcaps_dsound_vb 867814                                           //  DSCBCAPS
#define idh__dx_dscbufferdesc_dsound_vb 867815                                      //  DSCBUFFERDESC
#define idh__dx_dsccaps_dsound_vb 867816                                            //  DSCCAPS
#define idh__dx_dscursors_dsound_vb 867817                                          //  DSCURSORS
#define idh__dx_dxdriverinfo_dsound_vb 867818                                       //  DXDRIVERINFO
#define idh__dx_waveformatex_dsound_vb 867819                                       //  WAVEFORMATEX
#define idh__dx_const_ds3dapplyflags_dsound_vb 867820                               //  CONST_DS3DAPPLYFLAGS
#define idh__dx_const_ds3dmodeflags_dsound_vb 867821                                //  CONST_DS3DMODEFLAGS
#define idh__dx_const_dsbcapsflags_dsound_vb 867822                                 //  CONST_DSBCAPSFLAGS
#define idh__dx_const_dsblockflags_dsound_vb 867823                                 //  CONST_DSBLOCKFLAGS
#define idh__dx_const_dsbplayflags_dsound_vb 867824                                 //  CONST_DSBPLAYFLAGS
#define idh__dx_const_dsbstatusflags_dsound_vb 867825                               //  CONST_DSBSTATUSFLAGS
#define idh__dx_const_dscapsflags_dsound_vb 867826                                  //  CONST_DSCAPSFLAGS
#define idh__dx_const_dscbcapsflags_dsound_vb 867827                                //  CONST_DSCBCAPSFLAGS
#define idh__dx_const_dscblockflags_dsound_vb 867828                                //  CONST_DSCBLOCKFLAGS
#define idh__dx_const_dscbstartflags_dsound_vb 867829                               //  CONST_DSCBSTARTFLAGS
#define idh__dx_const_dscbstatusflags_dsound_vb 867830                              //  CONST_DSCBSTATUSFLAGS
#define idh__dx_const_dsccapsflags_dsound_vb 867831                                 //  CONST_DSCCAPSFLAGS
#define idh__dx_const_dsound_dsound_vb 867832                                       //  CONST_DSOUND
#define idh__dx_const_dssclflags_dsound_vb 867833                                   //  CONST_DSSCLFLAGS
#define idh__dx_const_dsspeakerflags_dsound_vb 867834                               //  CONST_DSSPEAKERFLAGS
#define idh__dx_const_waveformatflags_dsound_vb 867835                              //  CONST_WAVEFORMATFLAGS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmchordmapobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmchordmapobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicChordMapObject

#include "resource.h"       // main symbols
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#define typedef__dxj_DirectMusicChordMap IDirectMusicChordMap8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicChordMapObject : 
	public I_dxj_DirectMusicChordMap,
	//public CComCoClass<C_dxj_DirectMusicChordMapObject, &CLSID__dxj_DirectMusicChordMap>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicChordMapObject();
	virtual ~C_dxj_DirectMusicChordMapObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicChordMapObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicChordMap)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicChordMap,		"DIRECT.DirectMusicChordMap.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicChordMapObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

  
    HRESULT STDMETHODCALLTYPE getScale(long *s); 
    

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicChordMap);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicChordMap)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmcollectionobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmcollectionobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicCollectionObject

#include "resource.h"       // main symbols
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#define typedef__dxj_DirectMusicCollection IDirectMusicCollection8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicCollectionObject : 
	public I_dxj_DirectMusicCollection,
	//public CComCoClass<C_dxj_DirectMusicCollectionObject, &CLSID__dxj_DirectMusicCollection>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicCollectionObject();
	virtual ~C_dxj_DirectMusicCollectionObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicCollectionObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicCollection)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicCollection,		"DIRECT.DirectMusicCollection.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicCollectionObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

      
    

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicCollection);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicCollection)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmbandobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmbandobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicBandObject

#include "resource.h"       // main symbols
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#define typedef__dxj_DirectMusicBand IDirectMusicBand8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicBandObject : 
	public I_dxj_DirectMusicBand,
	//public CComCoClass<C_dxj_DirectMusicBandObject, &CLSID__dxj_DirectMusicBand>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicBandObject();
	virtual ~C_dxj_DirectMusicBandObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicBandObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicBand)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicBand,		"DIRECT.DirectMusicBand.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicBandObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	HRESULT STDMETHODCALLTYPE createSegment( 
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE download( 
		/* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *downloadpath);

	HRESULT STDMETHODCALLTYPE unload( 
		/* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *downloadpath);

  

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicBand);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicBand)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmloaderobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmloaderobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicLoaderObject

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicLoader IDirectMusicLoader8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicLoaderObject : 
	public I_dxj_DirectMusicLoader,
	//public CComCoClass<C_dxj_DirectMusicLoaderObject, &CLSID__dxj_DirectMusicLoader>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicLoaderObject();
	virtual ~C_dxj_DirectMusicLoaderObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicLoaderObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicLoader)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicLoader,		"DIRECT.DirectMusicLoader.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicLoaderObject)


// I_dxj_Direct3dRMLight
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	 HRESULT STDMETHODCALLTYPE loadSegment( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadStyle( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadBand( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret);

 	 HRESULT STDMETHODCALLTYPE loadCollection( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicCollection __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadSegmentFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadStyleFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadBandFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadCollectionFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicCollection __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE setSearchDirectory( BSTR path);

 	 HRESULT STDMETHODCALLTYPE loadChordMap( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadChordMapFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);

#if 0
	HRESULT STDMETHODCALLTYPE LoadSong(BSTR filename, I_dxj_DirectMusicSong **ret);
#endif


////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicLoader);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicLoader)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmloaderobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmloaderobj.cpp
//
//--------------------------------------------------------------------------

// dmLoaderObj.cpp

#include "stdafx.h"
#include "Direct.h"
#include "dmusici.h"
#include "dms.h"
#include "dmLoaderObj.h"
#include "dmBandObj.h"
#include "dmSegmentObj.h"
#include "dmStyleObj.h"
#include "dmCollectionObj.h"
#include "dmChordMapObj.h"
#if 0
#include "DMusSongObj.h"

extern void *g_dxj_DirectMusicSong;
#endif
extern void *g_dxj_DirectMusicLoader;
extern void *g_dxj_DirectMusicBand;
extern void *g_dxj_DirectMusicStyle;
extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicCollection;
extern void *g_dxj_DirectMusicChordMap;
	

CONSTRUCTOR(_dxj_DirectMusicLoader, {});
DESTRUCTOR(_dxj_DirectMusicLoader, {});
GETSET_OBJECT(_dxj_DirectMusicLoader);


extern HRESULT CREATE_DMSEGMENT_NOADDREF(IDirectMusicSegment8 *pSeg,I_dxj_DirectMusicSegment **segment) ;
extern BOOL IsEmptyString(BSTR szString);


BOOL HasBackslash(BSTR b){
	
	DWORD cbLen=SysStringLen(b);
	
	for (DWORD i=0;i<cbLen;i++) 
	{
		if (b[i]==((unsigned short)'\\'))
			 return TRUE;
	}
	return FALSE;
}


HRESULT C_dxj_DirectMusicLoaderObject::loadSegment( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (IsEmptyString(filename))	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

    WCHAR          wszFileName[DMUS_MAX_FILENAME];
	IDirectMusicSegment8 *pOut=NULL;
	wcscpy(wszFileName, filename);	

	if (FAILED ( hr = m__dxj_DirectMusicLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, IID_IDirectMusicSegment8,wszFileName, (void**)&pOut) ) )
		return hr;
		
	hr=CREATE_DMSEGMENT_NOADDREF(pOut,ret);
	if FAILED(hr) return hr;

	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}

HRESULT C_dxj_DirectMusicLoaderObject::loadStyle( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (IsEmptyString(filename))	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

    WCHAR          wszFileName[DMUS_MAX_FILENAME];
	IDirectMusicStyle8 *pOut=NULL;
	wcscpy(wszFileName, filename);	

	if (FAILED ( hr = m__dxj_DirectMusicLoader->LoadObjectFromFile(CLSID_DirectMusicStyle, IID_IDirectMusicStyle8,wszFileName, (void**)&pOut) ) )
		return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicStyle,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}
HRESULT C_dxj_DirectMusicLoaderObject::loadBand( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (IsEmptyString(filename))	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

    WCHAR          wszFileName[DMUS_MAX_FILENAME];
	IDirectMusicBand8 *pOut=NULL;
	wcscpy(wszFileName, filename);	

	if (FAILED ( hr = m__dxj_DirectMusicLoader->LoadObjectFromFile(CLSID_DirectMusicBand, IID_IDirectMusicBand8,wszFileName, (void**)&pOut) ) )
		return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicBand,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}

HRESULT C_dxj_DirectMusicLoaderObject::loadCollection( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicCollection __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (IsEmptyString(filename))	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

    WCHAR          wszFileName[DMUS_MAX_FILENAME];
	IDirectMusicCollection8 *pOut=NULL;
	wcscpy(wszFileName, filename);	

	if (FAILED ( hr = m__dxj_DirectMusicLoader->LoadObjectFromFile(CLSID_DirectMusicCollection, IID_IDirectMusicCollection8,wszFileName, (void**)&pOut) ) )
		return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicCollection,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}

HRESULT C_dxj_DirectMusicLoaderObject::loadChordMap( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (IsEmptyString(filename))	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

    WCHAR          wszFileName[DMUS_MAX_FILENAME];
	IDirectMusicChordMap8 *pOut=NULL;
	wcscpy(wszFileName, filename);	

	if (FAILED ( hr = m__dxj_DirectMusicLoader->LoadObjectFromFile(CLSID_DirectMusicChordMap, IID_IDirectMusicChordMap8,wszFileName, (void**)&pOut) ) )
		return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}

#if 0
HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::LoadSong(BSTR filename, I_dxj_DirectMusicSong **ret)
{
	HRESULT hr;
	
	if (IsEmptyString(filename))	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

    WCHAR          wszFileName[DMUS_MAX_FILENAME];
	IDirectMusicSong *pOut=NULL;
	wcscpy(wszFileName, filename);	

	if (FAILED ( hr = m__dxj_DirectMusicLoader->LoadObjectFromFile(CLSID_DirectMusicSong, IID_IDirectMusicSong,wszFileName, (void**)&pOut) ) )
		return hr;
		
	INTERNAL_CREATE(_dxj_DirectMusicSong ,pOut,ret);

	if (!*ret)return E_OUTOFMEMORY;
	
	return S_OK;

}
#endif
HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadSegmentFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret)
{

	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;
	

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	USES_CONVERSION;
	
	
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE: - 
		// seems that GetModuleHandleW is
		// always returning 0 on w98??			
		// hMod= GetModuleHandleW(moduleName);
		LPCTSTR pszName = NULL;
		__try { pszName = W2T(moduleName); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		hMod= GetModuleHandle(pszName);
	}


	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMSEG");
	if (!hres) return E_FAIL;
	

	pMem=(void*)LoadResource(hMod,hres);
	if (!pMem) return E_FAIL;


	dwSize=SizeofResource(hMod,hres); 
	
	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicSegment;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment8 *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicSegment8,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;	
	return hr;
}

HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadStyleFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret)
{
    HRESULT hr;
	HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	USES_CONVERSION;
	
	
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE: - 
		// seems that GetModuleHandleW is
		// always returning 0 on w98??			
		// hMod= GetModuleHandleW(moduleName);
		LPCTSTR pszName = NULL;
		__try { pszName = W2T(moduleName); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		hMod= GetModuleHandle(pszName);

	}

	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMSTYLE");


	if (!hres) return E_FAIL;


	pMem=(void*)LoadResource(hMod,hres);


	if (!pMem) return E_FAIL;

	dwSize=SizeofResource(hMod,hres); 
 

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicStyle;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment8 *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicStyle8,(void**)&pOut);	
	
	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicStyle,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;
}

HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadBandFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	USES_CONVERSION;
	
	
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE: - 
		// seems that GetModuleHandleW is
		// always returning 0 on w98??			
		// hMod= GetModuleHandleW(moduleName);
		LPCTSTR pszName = NULL;
		__try { pszName = W2T(moduleName); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		hMod= GetModuleHandle(pszName);
	}


	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMBAND");
	if (!hres) return E_FAIL;
	
	pMem=(void*)LoadResource(hMod,hres);
	if (!pMem) return E_FAIL;

	dwSize=SizeofResource(hMod,hres); 
 
	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicBand;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment8 *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicBand8,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicBand,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}


 HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadCollectionFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicCollection __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	USES_CONVERSION;
	
	
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE: - 
		// seems that GetModuleHandleW is
		// always returning 0 on w98??			
		// hMod= GetModuleHandleW(moduleName);
		LPCTSTR pszName = NULL;
		__try { pszName = W2T(moduleName); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		hMod= GetModuleHandle(pszName);
	}


	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMCOL");
	if (!hres) return E_FAIL;
	
	pMem=(void*)LoadResource(hMod,hres);
	if (!pMem) return E_FAIL;

	dwSize=SizeofResource(hMod,hres); 
 

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicCollection;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment8 *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicCollection8,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicCollection,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;
	

}

 
HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadChordMapFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	
	USES_CONVERSION;
		
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE: - 
		// seems that GetModuleHandleW is
		// always returning 0 on w98??			
		// hMod= GetModuleHandleW(moduleName);
		LPCTSTR pszName = NULL;
		__try { pszName = W2T(moduleName); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		 hMod= GetModuleHandle(pszName);
	}

	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMCHORD");
	if (!hres) {
		//MessageBox(NULL,"FindResourceW Failed","test",MB_OK);
		return E_FAIL;
	}

	pMem=(void*)LoadResource(hMod,hres);
	if (!pMem){
		//MessageBox(NULL,"LoadResource Failed","test",MB_OK);
		return E_FAIL;
	}

	dwSize=SizeofResource(hMod,hres); 
 

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicChordMap;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment8 *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicChordMap8,(void**)&pOut);	
	if FAILED(hr) {
		//MessageBox(NULL,"GetObject Failed","test",MB_OK);
		return hr;
	}

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;
	

}


 HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::setSearchDirectory( BSTR dir)
 {
	HRESULT hr;
	hr=m__dxj_DirectMusicLoader->SetSearchDirectory(GUID_DirectMusicAllTypes,dir, TRUE);    //?
	return hr;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmperformanceobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmperformanceobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmPerformanceObj.h"
#include "dmSegmentStateObj.h"
#include "dmSegmentObj.h"
#include "dmStyleObj.h"
#include "dmChordMapObj.h"
#include "dMusAudioPathObj.h"					   
#include "dsoundobj.h"

extern void *g_dxj_DirectMusicPerformance;
extern void *g_dxj_DirectMusicSegmentState;
extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicStyle;
extern void *g_dxj_DirectMusicAudioPath;
extern void *g_dxj_DirectMusicChordMap;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern CRITICAL_SECTION g_cbCriticalSection;
extern BOOL IsEmptyString(BSTR szString);
extern BSTR GUIDtoBSTR(LPGUID);

CONSTRUCTOR(_dxj_DirectMusicPerformance, {InternalInit();});
DESTRUCTOR(_dxj_DirectMusicPerformance, {InternalCleanup();});
GETSET_OBJECT(_dxj_DirectMusicPerformance);

typedef IDirectMusicSegment* LPDIRECTMUSICSEGMENT;
typedef IDirectMusicSegmentState* LPDIRECTMUSICSEGMENTSTATE ;

HRESULT C_dxj_DirectMusicPerformanceObject::InternalInit(){
	return S_OK;
}
HRESULT C_dxj_DirectMusicPerformanceObject::InternalCleanup(){	
	__try {
		m__dxj_DirectMusicPerformance->CloseDown();
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return S_OK;
	}
	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::closeDown( )
{
	HRESULT hr;	
	__try {
		hr=m__dxj_DirectMusicPerformance->CloseDown();
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}
 

#define VBREF_TO_REALREFTIME(startTime) ((__int64)startTime*10000)
#define REALREF_TO_VBREFTIME(startTime) ((long)(startTime/10000))

HRESULT C_dxj_DirectMusicPerformanceObject::getSegmentState( 
		/* [in] */ long mtTime,
		/* [retval][out] */ I_dxj_DirectMusicSegmentState __RPC_FAR *__RPC_FAR *segmentState)
{
	HRESULT hr;	

	__try {
		IDirectMusicSegmentState *pState=NULL;
		hr=m__dxj_DirectMusicPerformance->GetSegmentState(&pState,(MUSIC_TIME)mtTime);
		if FAILED(hr) return hr;
		if (!pState) return E_FAIL;

		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegmentState,pState,segmentState);
		if (*segmentState==NULL) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::invalidate( 
		/* [in] */ long mtTime,
		/* [in] */ long flags)

{
	HRESULT hr;		
	__try {
		hr=m__dxj_DirectMusicPerformance->Invalidate((MUSIC_TIME)mtTime,(DWORD)flags);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}



HRESULT C_dxj_DirectMusicPerformanceObject::isPlaying( 
		/* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
		/* [in] */ I_dxj_DirectMusicSegmentState __RPC_FAR *segmentState,
		/* [retval][out] */ VARIANT_BOOL __RPC_FAR *b)
		
{
	HRESULT hr;	
	
	__try {
		DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT,pSeg,segment);
		DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENTSTATE,pSegState,segmentState);
				
		hr=m__dxj_DirectMusicPerformance->IsPlaying(pSeg,pSegState);	
		if (hr==S_FALSE){
			*b=VARIANT_FALSE;
		}
		else if (hr==S_OK){
			*b=VARIANT_TRUE;
		}
		else{
			return hr;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}



HRESULT C_dxj_DirectMusicPerformanceObject::addNotificationType(CONST_DMUS_NOTIFICATION_TYPE t)		
{
	HRESULT hr;	
	GUID g;
	__try {
		switch (t){	
		 case DMUS_NOTIFY_ON_CHORD:
			g=GUID_NOTIFICATION_CHORD;
			break;

		 case DMUS_NOTIFY_ON_COMMAND:
			g=GUID_NOTIFICATION_COMMAND;
			break;
		 case DMUS_NOTIFY_ON_MEASUREANDBEAT:
			g=GUID_NOTIFICATION_MEASUREANDBEAT;
			break;
		 case DMUS_NOTIFY_ON_PERFORMANCE:
			g=GUID_NOTIFICATION_PERFORMANCE;
			break;
		 case DMUS_NOTIFY_ON_SEGMENT:
			g=GUID_NOTIFICATION_SEGMENT;
			break;
		 case DMUS_NOTIFY_ON_RECOMPOSE:
			 g=GUID_NOTIFICATION_RECOMPOSE;
		 default:
			return E_INVALIDARG;
		}
		
		hr=m__dxj_DirectMusicPerformance->AddNotificationType(g);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}


HRESULT C_dxj_DirectMusicPerformanceObject::removeNotificationType( /* [in] */CONST_DMUS_NOTIFICATION_TYPE t)		
{
	HRESULT hr;	
	GUID g;
	__try {
		switch (t){	
		 case DMUS_NOTIFY_ON_CHORD:
			g=GUID_NOTIFICATION_CHORD;
			break;

		 case DMUS_NOTIFY_ON_COMMAND:
			g=GUID_NOTIFICATION_COMMAND;
			break;
		 case DMUS_NOTIFY_ON_MEASUREANDBEAT:
			g=GUID_NOTIFICATION_MEASUREANDBEAT;
			break;
		 case DMUS_NOTIFY_ON_PERFORMANCE:
			g=GUID_NOTIFICATION_PERFORMANCE;
			break;
		 case DMUS_NOTIFY_ON_SEGMENT:
			g=GUID_NOTIFICATION_SEGMENT;
			break;
		 case DMUS_NOTIFY_ON_RECOMPOSE:
			 g=GUID_NOTIFICATION_RECOMPOSE;
		 default:
			return E_INVALIDARG;
		}
		hr=m__dxj_DirectMusicPerformance->RemoveNotificationType(g);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	


#ifdef _WIN64
HRESULT C_dxj_DirectMusicPerformanceObject::setNotificationHandle( 	/* [in] */ HWND hnd)		
#else
HRESULT C_dxj_DirectMusicPerformanceObject::setNotificationHandle( 	/* [in] */ long hnd)		
#endif
{
	HRESULT hr;	
	__try {
		hr=m__dxj_DirectMusicPerformance->SetNotificationHandle((HWND)hnd,0);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	
	

HRESULT C_dxj_DirectMusicPerformanceObject::getNotificationPMSG( DMUS_NOTIFICATION_PMSG_CDESC *pMsgOut, VARIANT_BOOL *bOut)				
{
	HRESULT hr;	
	DMUS_NOTIFICATION_PMSG *pMsg=NULL;
	IDirectMusicSegmentState	*lpState = NULL;
	
	__try {
		if (!pMsgOut) return E_INVALIDARG;
		if (!bOut) return E_INVALIDARG;

		hr=m__dxj_DirectMusicPerformance->GetNotificationPMsg(&pMsg);	
		if FAILED(hr) return hr;
		
		*bOut=VARIANT_FALSE;	

		if (!pMsg) 	return S_OK;

		if (hr!=S_FALSE) 	*bOut=VARIANT_TRUE;	
		

		pMsgOut->mtTime=(long)pMsg->mtTime;
		pMsgOut->ctTime=(long)REALREF_TO_VBREFTIME(pMsg->rtTime);
		pMsgOut->lFlags=(long)pMsg->dwFlags;
		
		pMsgOut->lNotificationOption =pMsg->dwNotificationOption;
		pMsgOut->lField1=pMsg->dwField1;
		pMsgOut->lField2=pMsg->dwField2;

		if (pMsg->punkUser)
		{
			if (SUCCEEDED( hr = pMsg->punkUser->QueryInterface(IID_IDirectMusicSegmentState, (void**)&lpState) ) )
			{
				// Create an instance of the segment state and return it to VB
				INTERNAL_CREATE(_dxj_DirectMusicSegmentState,lpState,&pMsgOut->User);
			}
		}

		if (0==memcmp(&GUID_NOTIFICATION_CHORD,&pMsg->guidNotificationType,sizeof(GUID))){
			pMsgOut->lNotificationType=DMUS_NOTIFY_ON_CHORD;
		}
		else if (0==memcmp(&GUID_NOTIFICATION_COMMAND,&pMsg->guidNotificationType,sizeof(GUID))){
			pMsgOut->lNotificationType=DMUS_NOTIFY_ON_COMMAND;
		}
		else if (0==memcmp(&GUID_NOTIFICATION_MEASUREANDBEAT,&pMsg->guidNotificationType,sizeof(GUID))){
			pMsgOut->lNotificationType=DMUS_NOTIFY_ON_MEASUREANDBEAT;
		}
		else if (0==memcmp(&GUID_NOTIFICATION_PERFORMANCE,&pMsg->guidNotificationType,sizeof(GUID))){
			pMsgOut->lNotificationType=DMUS_NOTIFY_ON_PERFORMANCE;
		}
		else if (0==memcmp(&GUID_NOTIFICATION_SEGMENT,&pMsg->guidNotificationType,sizeof(GUID))){
			pMsgOut->lNotificationType=DMUS_NOTIFY_ON_SEGMENT;
		}
		else if (0==memcmp(&GUID_NOTIFICATION_RECOMPOSE,&pMsg->guidNotificationType,sizeof(GUID))){
			pMsgOut->lNotificationType=DMUS_NOTIFY_ON_RECOMPOSE;
		}
		else {
			pMsgOut->lNotificationType=0;		
		}

		m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG *)pMsg);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	


HRESULT C_dxj_DirectMusicPerformanceObject::musicToClockTime( /* [in] */ long mtTime,
		/* [retval][out] */ long __RPC_FAR *rtTime)				
{
	HRESULT hr;	
	__int64 outTime;
	__try {
		hr=m__dxj_DirectMusicPerformance->MusicToReferenceTime((MUSIC_TIME)mtTime,&outTime);
		if FAILED(hr) return hr;
		*rtTime=REALREF_TO_VBREFTIME(outTime);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	


HRESULT C_dxj_DirectMusicPerformanceObject::clockToMusicTime( 	/* [in] */ long rtTime,
		/* [retval][out] */ long __RPC_FAR *mtTime)				
{
	HRESULT hr;	
	__try {
		__int64 outTime=VBREF_TO_REALREFTIME(rtTime);;
		hr=m__dxj_DirectMusicPerformance->ReferenceToMusicTime(outTime,(MUSIC_TIME*)mtTime);		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	
	 


HRESULT C_dxj_DirectMusicPerformanceObject::getMusicTime( /* [retval][out] */ long __RPC_FAR *mtTime)		
{
	HRESULT hr;		

	__try {
		hr=m__dxj_DirectMusicPerformance->GetTime(NULL,(MUSIC_TIME*)mtTime);		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	
	 

HRESULT C_dxj_DirectMusicPerformanceObject::getClockTime( /* [retval][out] */ long __RPC_FAR *rtTime)		
{
	HRESULT hr;	
	__try {
		__int64 outTime=0;
		hr=m__dxj_DirectMusicPerformance->GetTime(&outTime,NULL);
		*rtTime=REALREF_TO_VBREFTIME(outTime);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	


HRESULT C_dxj_DirectMusicPerformanceObject::getPrepareTime( /* [retval][out] */ long __RPC_FAR *pTime)		
{
	HRESULT hr;		
	__try {
		hr=m__dxj_DirectMusicPerformance->GetPrepareTime((DWORD*)pTime);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::getBumperLength(/* [retval][out] */ long __RPC_FAR *pTime)		
{
	HRESULT hr;		
	__try {
		hr=m__dxj_DirectMusicPerformance->GetBumperLength((DWORD*)pTime);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::getLatencyTime( /* [retval][out] */ long __RPC_FAR *pTime)		
{
	HRESULT hr;		
	__int64 t;
	__try {
		if (!pTime) return E_INVALIDARG;
		hr=m__dxj_DirectMusicPerformance->GetLatencyTime(&t);	
		*pTime=REALREF_TO_VBREFTIME(t);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::getQueueTime( /* [retval][out] */ long __RPC_FAR *pTime)		
{
	HRESULT hr;		
	__int64 t;

	__try {
		if (!pTime) return E_INVALIDARG;
		hr=m__dxj_DirectMusicPerformance->GetQueueTime(&t);	
		*pTime=REALREF_TO_VBREFTIME(t);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::getResolvedTime( /* [in] */ long rtTime, /* [in] */ long flags,	/* [retval][out] */ long __RPC_FAR *ret)
{
	HRESULT hr;		

	__try {
		__int64 outtime1= VBREF_TO_REALREFTIME(rtTime);
		__int64 outtime2=0;
		hr=m__dxj_DirectMusicPerformance->GetResolvedTime(outtime1,&outtime2,(DWORD)flags);	
		*ret=REALREF_TO_VBREFTIME(outtime2);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	

	 

HRESULT C_dxj_DirectMusicPerformanceObject::setPrepareTime( /* [retval][out] */ long  t)		
{
	HRESULT hr;		
	__try {
		hr=m__dxj_DirectMusicPerformance->SetPrepareTime((DWORD)t);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::setBumperLength(/* [retval][out] */ long  t)		
{
	HRESULT hr;		

	__try {
		hr=m__dxj_DirectMusicPerformance->SetBumperLength((DWORD)t);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	



HRESULT C_dxj_DirectMusicPerformanceObject::adjustTime( 		
		/* [retval][out] */ long  t)		
{
	HRESULT hr;		
	
	__try {
		REFERENCE_TIME rt =(REFERENCE_TIME)t;
		hr=m__dxj_DirectMusicPerformance->AdjustTime(rt);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::setMasterAutoDownload( /* [in] */ VARIANT_BOOL bval)
{
	HRESULT hr;
	
	__try {
		BOOL b=(BOOL)(bval==VARIANT_TRUE);

		hr=m__dxj_DirectMusicPerformance->SetGlobalParam(GUID_PerfAutoDownload,(void*)&b,sizeof(BOOL));
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getMasterAutoDownload( /* [in] */ VARIANT_BOOL *bIn)
{
	HRESULT hr;
	BOOL	b;

	__try {
		hr=m__dxj_DirectMusicPerformance->GetGlobalParam(GUID_PerfAutoDownload,(void*) &b,sizeof(BOOL));
		if (b){
			*bIn=VARIANT_TRUE;
		}
		else{
			*bIn=VARIANT_FALSE;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::setMasterTempo( /* [in] */ float tempo)
{
	HRESULT hr;
	__try {
		hr=m__dxj_DirectMusicPerformance->SetGlobalParam( GUID_PerfMasterTempo ,(void*) &tempo,sizeof(float));
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getMasterTempo( /* [in] */ float *tempo)
{
	HRESULT hr;
	__try {
		hr=m__dxj_DirectMusicPerformance->GetGlobalParam( GUID_PerfMasterTempo ,(void*) tempo,sizeof(float));
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}


HRESULT C_dxj_DirectMusicPerformanceObject::setMasterVolume( /* [in] */ long vol)
{
	HRESULT hr;
	__try {
		hr=m__dxj_DirectMusicPerformance->SetGlobalParam(GUID_PerfMasterVolume  ,(void*) &vol,sizeof(long));
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getMasterVolume( /* [in] */ long *vol)
{
	HRESULT hr;
	__try {
		hr=m__dxj_DirectMusicPerformance->GetGlobalParam(GUID_PerfMasterVolume ,(void*) vol,sizeof(long));
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}



HRESULT C_dxj_DirectMusicPerformanceObject::setMasterGrooveLevel( /* [in] */ short level)
{
	HRESULT hr;
	
	__try {
		char l=(char)level;

		hr=m__dxj_DirectMusicPerformance->SetGlobalParam(GUID_PerfMasterGrooveLevel  ,(void*) &l,sizeof(char));
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getMasterGrooveLevel( /* [in] */ short *level)
{
	HRESULT hr;

	__try {
		if (!level) return E_INVALIDARG;
		char l=0;

		hr=m__dxj_DirectMusicPerformance->GetGlobalParam(GUID_PerfMasterGrooveLevel ,(void*) &l,sizeof(char));
		*level=(short)l;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::Reset(long resetFlags)
{
    DMUS_SYSEX_PMSG     *pGMReset;
    BYTE                abGMReset[] = {0xF0,0x7E,0x7F,0x09,0x01,0xF7};
    DWORD               dwLen;
	HRESULT				hr=S_OK;

	__try {
		if (!resetFlags){
			dwLen = sizeof(abGMReset)/sizeof(abGMReset[0]);

			if(SUCCEEDED( m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_SYSEX_PMSG) + dwLen,
																	(DMUS_PMSG**)&pGMReset )))
			{
				ZeroMemory(pGMReset, sizeof(pGMReset));
				pGMReset->dwSize = sizeof(DMUS_SYSEX_PMSG);
				pGMReset->dwPChannel = 0;
				pGMReset->dwVirtualTrackID = 0;
				pGMReset->dwType = DMUS_PMSGT_SYSEX ;
				pGMReset->dwVoiceID = 0;
				pGMReset->dwGroupID = 0xFFFFFFFF;

				pGMReset->dwLen = dwLen;
				memcpy(pGMReset->abData, abGMReset, dwLen);

				if (SUCCEEDED(m__dxj_DirectMusicPerformance->GetTime(NULL, &pGMReset->mtTime)))
				{
					pGMReset->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_IMMEDIATE;
				}

				hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pGMReset);
				if (FAILED(hr))
					m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG*)pGMReset);
			}
		}
		else if(resetFlags==1){

			//1) Find out what port we're playing through
			//2)  Close the port
			//3) Open the port back up.
			
			//hr=setPort(m_portid,m_number_of_groups);
		}
		else {
			hr=E_INVALIDARG;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getStyle( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret)
{				
		HRESULT hr;	
		IDirectMusicStyle *pStyle=NULL;

	__try {
		if (!ret) return E_INVALIDARG;
		*ret=NULL;
		
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_IDirectMusicStyle,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&pStyle );	
		if FAILED(hr) return hr;
				
		
		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicStyle,pStyle,ret);
		if (*ret==NULL) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getChordMap( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
		HRESULT hr;	
		IDirectMusicChordMap *pMap=NULL;

	__try {
		if (!ret) return E_INVALIDARG;
		*ret=NULL;
		
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_IDirectMusicChordMap,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&pMap );	
		if FAILED(hr) return hr;
				
		
		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pMap,ret);
		if (*ret==NULL) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getCommand( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ Byte __RPC_FAR *command)
{
		HRESULT hr;	
		DMUS_COMMAND_PARAM cmd;								
		
	__try {
		if (!command) return E_INVALIDARG;
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_CommandParam,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&cmd );	
		if FAILED(hr) return hr;		
		*command=cmd.bCommand;		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getGrooveLevel( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ Byte __RPC_FAR *level)
{
		HRESULT hr;	
		DMUS_COMMAND_PARAM cmd;			
	__try {
		if (!level) return E_INVALIDARG;
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_CommandParam,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&cmd );	
		if FAILED(hr) return hr;		
		*level=cmd.bGrooveLevel;		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getTempo( 		
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ double __RPC_FAR *tempo)
{
	HRESULT hr;	
	DMUS_TEMPO_PARAM tmp;
	
	__try {
		if (!tempo) return E_INVALIDARG;
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_TempoParam,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&tmp );	
		if FAILED(hr) return hr;		
		*tempo=tmp.dblTempo;		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getTimeSig( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [out][in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timeSig)
{
	
	HRESULT hr;	
	__try {
		if (!timeSig) return E_INVALIDARG;
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_TimeSignature,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,(DMUS_TIMESIGNATURE*)timeSig);		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendNotePMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ DMUS_NOTE_PMSG_CDESC __RPC_FAR *msg)
{


	HRESULT		hr;
	DMUS_NOTE_PMSG	*pPMSG=NULL;
	__try {
		if (!msg) return E_INVALIDARG;
		hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_NOTE_PMSG),(DMUS_PMSG**)&pPMSG);
		if FAILED(hr) return hr;

		//memcpy(pPMSG,msg,sizeof(DMUS_NOTE_PMSG));
		//depends on alignment settings
		//and how dll is compiled to work right.
		//copy member by member instead..
		ZeroMemory(pPMSG,sizeof(DMUS_NOTE_PMSG));
		pPMSG->dwSize=sizeof(DMUS_NOTE_PMSG);
		pPMSG->mtTime=(MUSIC_TIME)mtTime;
		pPMSG->dwFlags=(DWORD)flags;
		pPMSG->dwType=DMUS_PMSGT_NOTE;	
		pPMSG->dwPChannel =(DWORD)channel;
		pPMSG->dwVirtualTrackID  =(DWORD)0;
		pPMSG->dwGroupID=(DWORD)-1;
		
		
		pPMSG->mtDuration=(MUSIC_TIME)msg->mtDuration;
		pPMSG->wMusicValue=(WORD)msg->musicValue;
		pPMSG->wMeasure=(WORD)msg->measure;
		pPMSG->nOffset=(short)msg->offset;
		pPMSG->bBeat=(BYTE)msg->beat;
		pPMSG->bGrid=(BYTE)msg->grid;
		pPMSG->bVelocity=(BYTE)msg->velocity;
		pPMSG->bFlags=(BYTE)msg->flags;
		pPMSG->bTimeRange=(BYTE)msg->timeRange;
		pPMSG->bDurRange=(BYTE)msg->durRange;
		pPMSG->bVelRange=(BYTE)msg->velRange;
		pPMSG->bPlayModeFlags=(BYTE)msg->playModeFlags;
		pPMSG->bSubChordLevel=(BYTE)msg->subChordLevel;
		pPMSG->bMidiValue=(BYTE)msg->midiValue;
		pPMSG->cTranspose=(char)msg->transpose;


		if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
		hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
		if (FAILED(hr))
			m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG*)pPMSG);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;

}

HRESULT C_dxj_DirectMusicPerformanceObject::sendCurvePMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ DMUS_CURVE_PMSG_CDESC __RPC_FAR *msg)
{
	HRESULT		hr;
	DMUS_CURVE_PMSG	*pPMSG=NULL;
	if (!msg) return E_INVALIDARG;

	__try {
		hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG**)&pPMSG);

		
		pPMSG->dwSize=sizeof(DMUS_CURVE_PMSG);
		pPMSG->mtTime=(MUSIC_TIME)mtTime;
		pPMSG->dwFlags=(DWORD)flags;
		pPMSG->dwType=DMUS_PMSGT_CURVE;	
		pPMSG->dwPChannel =(DWORD)channel;
		pPMSG->dwVirtualTrackID  =(DWORD)0;
		pPMSG->dwGroupID=(DWORD)-1;
		if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;

		pPMSG->mtDuration=msg->mtDuration;
		pPMSG->mtOriginalStart=msg->mtOriginalStart;
		pPMSG->mtResetDuration=msg->mtResetDuration;	
		pPMSG->nStartValue =(short)msg->startValue;
		pPMSG->nEndValue =(short)msg->endValue;
		pPMSG->nResetValue =(short)msg->resetValue;
		pPMSG->wMeasure =(short)msg->measure;
		pPMSG->nOffset =(short)msg->offset;
		pPMSG->bBeat =(Byte)msg->beat;
		pPMSG->bGrid =(Byte)msg->grid;
		pPMSG->bType =(Byte)msg->type;
		pPMSG->bCurveShape =(Byte)msg->curveShape;
		pPMSG->bCCData =(Byte)msg->ccData;
		pPMSG->bFlags =(Byte)msg->flags | DMUS_PMSGF_DX8;
		pPMSG->wParamType = (short) msg->ParamType;
		pPMSG->wMergeIndex = (short) msg->MergeIndex;

		hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
		if (FAILED(hr))
			m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG*)pPMSG);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendMIDIPMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ Byte status,
		/* [in] */ Byte byte1,
		/* [in] */ Byte byte2)
{
	HRESULT		hr;
	DMUS_MIDI_PMSG	*pPMSG=NULL;
	
	__try {
		hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG),(DMUS_PMSG**)&pPMSG);	
		ZeroMemory(pPMSG,sizeof(DMUS_MIDI_PMSG));
		pPMSG->dwSize=sizeof(DMUS_MIDI_PMSG);
		pPMSG->mtTime=(MUSIC_TIME)mtTime;
		pPMSG->dwFlags=(DWORD)flags;
		pPMSG->dwType=DMUS_PMSGT_MIDI;	
		pPMSG->dwPChannel =(DWORD)channel;
		pPMSG->dwVirtualTrackID  =(DWORD)0;
		pPMSG->dwGroupID=(DWORD)-1;
		pPMSG->bStatus=status;
		pPMSG->bByte1=byte1;
		pPMSG->bByte2=byte2;
		if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
		hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
		if (FAILED(hr))
			m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG*)pPMSG);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendPatchPMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ Byte instrument,
		/* [in] */ Byte byte1,
		/* [in] */ Byte byte2)
{
	HRESULT		hr;
	DMUS_PATCH_PMSG	*pPMSG=NULL; 
	__try {
		hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_PATCH_PMSG),(DMUS_PMSG**)&pPMSG);	
		ZeroMemory(pPMSG,sizeof(DMUS_PATCH_PMSG));
		pPMSG->dwSize=sizeof(DMUS_PATCH_PMSG);
		pPMSG->mtTime=(MUSIC_TIME)mtTime;
		pPMSG->dwFlags=(DWORD)flags;
		pPMSG->dwType=DMUS_PMSGT_PATCH;	
		pPMSG->dwPChannel =(DWORD)channel;
		pPMSG->dwVirtualTrackID  =(DWORD)0;
		pPMSG->dwGroupID=(DWORD)-1;
		pPMSG->byInstrument=instrument;
		pPMSG->byMSB=byte1;
		pPMSG->byLSB=byte2;
		if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
		hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
		if (FAILED(hr))
			m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG*)pPMSG);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendTempoPMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		///* [in] */ long channel,
		/* [in] */ double tempo)
{
	HRESULT		hr;
	DMUS_TEMPO_PMSG	*pPMSG=NULL;
	__try {
		hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_TEMPO_PMSG),(DMUS_PMSG**)&pPMSG);	
		ZeroMemory(pPMSG,sizeof(DMUS_TEMPO_PMSG));
		pPMSG->dwSize=sizeof(DMUS_TEMPO_PMSG);
		pPMSG->mtTime=(MUSIC_TIME)mtTime;
		pPMSG->dwFlags=(DWORD)flags;
		pPMSG->dwType=DMUS_PMSGT_TEMPO;	
		pPMSG->dwPChannel =(DWORD)0;
		pPMSG->dwVirtualTrackID  =(DWORD)0;
		pPMSG->dwGroupID=(DWORD)-1;
		pPMSG->dblTempo=tempo;
		if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
		hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG); 
		if (FAILED(hr))
			m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG*)pPMSG);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendTransposePMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ short transpose)
{
	
	HRESULT		hr;
	DMUS_TRANSPOSE_PMSG	*pPMSG=NULL;
	__try {
		hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_TRANSPOSE_PMSG),(DMUS_PMSG**)&pPMSG);	
		ZeroMemory(pPMSG,sizeof(DMUS_TRANSPOSE_PMSG));
		pPMSG->dwSize=sizeof(DMUS_TRANSPOSE_PMSG);
		pPMSG->mtTime=(MUSIC_TIME)mtTime;
		pPMSG->dwFlags=(DWORD)flags;
		pPMSG->dwType=DMUS_PMSGT_TRANSPOSE;	
		pPMSG->dwPChannel =(DWORD)channel;
		pPMSG->dwVirtualTrackID  =(DWORD)0;
		pPMSG->dwGroupID=(DWORD)-1;
		pPMSG->nTranspose=transpose;
		if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
		hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG); 
		if (FAILED(hr))
			m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG*)pPMSG);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendTimeSigPMSG( 
		/* [in] */ long mtTime,		
		/* [in] */ long flags,
		/* [in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timesig)
{
	HRESULT		hr;
	DMUS_TIMESIG_PMSG	*pPMSG=NULL;
	if (!timesig) return E_INVALIDARG;

	__try {
		hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_TIMESIG_PMSG),(DMUS_PMSG**)&pPMSG);
		ZeroMemory(pPMSG,sizeof(DMUS_TIMESIG_PMSG));
		pPMSG->dwSize=sizeof(DMUS_TIMESIG_PMSG);
		pPMSG->mtTime=(MUSIC_TIME)mtTime;	
		pPMSG->dwFlags=(DWORD)flags;
		pPMSG->dwType=DMUS_PMSGT_TIMESIG;	
		pPMSG->dwPChannel =(DWORD)0;
		pPMSG->dwVirtualTrackID  =(DWORD)0;
		pPMSG->dwGroupID=(DWORD)-1;
		if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;

		pPMSG->bBeatsPerMeasure   =timesig->beatsPerMeasure; 
		pPMSG->bBeat=timesig->beat;  
		pPMSG->wGridsPerBeat=timesig->gridsPerBeat;

		hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
		if (FAILED(hr))
			m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG*)pPMSG);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

#ifdef _WIN64
HRESULT C_dxj_DirectMusicPerformanceObject::InitAudio(HWND hWnd,
										long lFlags,
										DMUS_AUDIOPARAMS_CDESC *AudioParams,
                                        I_dxj_DirectSound **DirectSound,  
                                        long lDefaultPathType,           
                                        long lPChannelCount)
#else
HRESULT C_dxj_DirectMusicPerformanceObject::InitAudio(long hWnd,
										long lFlags,
										DMUS_AUDIOPARAMS_CDESC *AudioParams,
                                        I_dxj_DirectSound **DirectSound,  
                                        long lDefaultPathType,           
                                        long lPChannelCount)
#endif
{
	HRESULT hr;
	IDirectSound8	*pDS8 = NULL;
	LPDIRECTSOUND	pSound = NULL;
	DMUS_AUDIOPARAMS *pAudioParams = NULL;

	__try {
		if (*DirectSound)
		{
			((I_dxj_DirectSound*)*DirectSound)->InternalGetObject((IUnknown **)(&pSound));
		}

		// Do we have any Audio params to use?
		if (AudioParams->lValidData)
		{
			pAudioParams = new DMUS_AUDIOPARAMS;
			if (!pAudioParams)
			{
				return E_OUTOFMEMORY;
			}
			ZeroMemory(pAudioParams, sizeof(pAudioParams));
			pAudioParams->dwSize = sizeof(pAudioParams);
			pAudioParams->fInitNow = (AudioParams->fInitNow == VARIANT_TRUE);
			pAudioParams->dwValidData = AudioParams->lValidData;
			pAudioParams->dwFeatures = AudioParams->lFeatures;
			pAudioParams->dwVoices = AudioParams->lVoices;
			pAudioParams->dwSampleRate = AudioParams->lSampleRate;
			if (FAILED ( hr = BSTRtoGUID(&pAudioParams->clsidDefaultSynth,AudioParams->clsidDefaultSynth) ) )
			{
				return hr;
			}
		}

		hr = m__dxj_DirectMusicPerformance->InitAudio(NULL, &pSound,(HWND) hWnd,(DWORD)	lDefaultPathType ,(DWORD) lPChannelCount,(DWORD)lFlags , pAudioParams);
		if FAILED(hr) {
			return hr;
		}

		//Now that we've finished, make sure our returned audio params struct is right
		if (pAudioParams)
		{
			AudioParams->fInitNow = pAudioParams->fInitNow ? VARIANT_TRUE : VARIANT_FALSE;

			AudioParams->lValidData = pAudioParams->dwValidData;
			AudioParams->lFeatures = pAudioParams->dwFeatures;
			AudioParams->lVoices = pAudioParams->dwVoices;
			AudioParams->lSampleRate = pAudioParams->dwSampleRate;
			AudioParams->clsidDefaultSynth = GUIDtoBSTR(&pAudioParams->clsidDefaultSynth);
		}

		if (FAILED( hr = pSound->QueryInterface(IID_IDirectSound8,(void**) &pDS8) ) )
			return hr;

		if (pDS8)
		{
			INTERNAL_CREATE(_dxj_DirectSound,pDS8,DirectSound);
		}

		if (pSound) pSound->Release();

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
HRESULT C_dxj_DirectMusicPerformanceObject::PlaySegmentEx(IUnknown *Source,
											long lFlags,
											long StartTime,
											IUnknown *From,
											IUnknown *AudioPath,
#if 0
											BSTR SegmentName,
											IUnknown *Transition, 
#endif
											I_dxj_DirectMusicSegmentState **ppSegmentState)
{
	HRESULT hr;	
    WCHAR wszSegName[MAX_PATH];

	if (!Source) return E_INVALIDARG;
	if (!ppSegmentState) return E_INVALIDARG;

	__try {
		IDirectMusicSegmentState	*pState=NULL;
		I_dxj_DirectMusicAudioPath	*pAudio = NULL;
		I_dxj_DirectMusicAudioPath	*pFrom = NULL;
		I_dxj_DirectMusicSegment	*pSeg = NULL;
#if 0
		I_dxj_DirectMusicSong		*pSong = NULL;
		I_dxj_DirectMusicSegment	*pTrans = NULL;

		if (Transition)
			DO_GETOBJECT_NOTNULL(IDirectMusicSegment8*,Transition,pTrans);
		if (!IsEmptyString(SegmentName)) wcscpy(wszSegName, SegmentName);	
#endif

		if (AudioPath)
		{
			if (FAILED ( hr = AudioPath->QueryInterface(IID_I_dxj_DirectMusicAudioPath, (void**)&pAudio) ) )
				return hr;
		}
		DO_GETOBJECT_NOTNULL(IDirectMusicAudioPath8*,pPath,pAudio);

		if (From)
		{
			if (FAILED ( hr = From->QueryInterface(IID_I_dxj_DirectMusicAudioPath, (void**)&pFrom) ) )
				return hr;
		}
		DO_GETOBJECT_NOTNULL(IDirectMusicAudioPath8*,pFromPath,pFrom);


		__int64 outTime=(__int64)StartTime;
		if (lFlags & DMUS_SEGF_REFTIME)  outTime=VBREF_TO_REALREFTIME(StartTime);
		

		//We need to determine if the source is a segment or a song
		// First check to see if it's a segment
		if (SUCCEEDED ( hr = Source->QueryInterface(IID_I_dxj_DirectMusicSegment, (void**)&pSeg) ) )
		{	
			if (!pSeg) return E_INVALIDARG;
			DO_GETOBJECT_NOTNULL(IDirectMusicSegment8*,pPlaySeg,pSeg);

			if (FAILED ( hr = m__dxj_DirectMusicPerformance->PlaySegmentEx(pPlaySeg,wszSegName, NULL, (DWORD)lFlags,outTime,&pState, pFromPath,pPath)) )
				return hr;
		} 
#if 0
		else
			// Next check to see if it's a song
			if (SUCCEEDED ( hr = Source->QueryInterface(IID_I_dxj_DirectMusicSong, (void**)&pSong) ) )
			{	
				if (!pSong) return E_INVALIDARG;
				DO_GETOBJECT_NOTNULL(IDirectMusicSong8*,pPlaySong,pSong);

				if (!IsEmptyString(SegmentName))
				{
					if (FAILED ( hr = m__dxj_DirectMusicPerformance->PlaySegmentEx(pPlaySong,wszSegName, pTrans, (DWORD)lFlags,outTime,&pState, pFromPath,pPath)) )
						return hr;
				}
				else
				{
					if (FAILED ( hr = m__dxj_DirectMusicPerformance->PlaySegmentEx(pPlaySong,NULL, pTrans, (DWORD)lFlags,outTime,&pState, pFromPath,pPath)) )
						return hr;
				}
			}
#endif
			else
				return E_INVALIDARG;

		if (!pState) return E_FAIL;

		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegmentState,pState,ppSegmentState);
		
		if (*ppSegmentState==NULL) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}


HRESULT C_dxj_DirectMusicPerformanceObject::StopEx(IUnknown *ObjectToStop,
										long lStopTime, 
										long lFlags)
{
	HRESULT hr;	
	if (!ObjectToStop) return E_INVALIDARG;
	I_dxj_DirectMusicSegment	*pSeg = NULL;
#if 0
	I_dxj_DirectMusicSong		*pSong = NULL;
#endif
	I_dxj_DirectMusicSegmentState	*pSegState = NULL;
	I_dxj_DirectMusicAudioPath	*pPath = NULL;
					     
	__try {
		//We need to determine if the source is a segment or a song
		__int64 outTime=(__int64)lStopTime;
		if (lFlags & DMUS_SEGF_REFTIME)  outTime=VBREF_TO_REALREFTIME(lStopTime);
		
		if (SUCCEEDED ( hr = ObjectToStop->QueryInterface(IID_I_dxj_DirectMusicSegment, (void**)&pSeg) ) )
		{	
			if (!pSeg) return E_INVALIDARG;
			DO_GETOBJECT_NOTNULL(IDirectMusicSegment8*,pPlaySeg,pSeg);

			if (FAILED (hr = m__dxj_DirectMusicPerformance->StopEx(pPlaySeg, outTime, (DWORD) lFlags) ) )
				return hr;
		} 
#if 0
		else if (SUCCEEDED ( hr = ObjectToStop->QueryInterface(IID_I_dxj_DirectMusicSong, (void**)&pSong) ) )
		{	
			if (!pSong) return E_INVALIDARG;
			DO_GETOBJECT_NOTNULL(IDirectMusicSong8*,pPlaySong,pSong);

			if (FAILED (hr = m__dxj_DirectMusicPerformance->StopEx(pPlaySong, outTime, (DWORD) lFlags) ) )
				return hr;
		}
#endif
		else if (SUCCEEDED ( hr = ObjectToStop->QueryInterface(IID_I_dxj_DirectMusicSegmentState, (void**)&pSegState) ) )
		{	
			if (!pSegState) return E_INVALIDARG;
			DO_GETOBJECT_NOTNULL(IDirectMusicSegmentState8*,pPlayState,pSegState);

			if (FAILED (hr = m__dxj_DirectMusicPerformance->StopEx(pPlayState, outTime, (DWORD) lFlags) ) )
				return hr;
		}
		else if (SUCCEEDED ( hr = ObjectToStop->QueryInterface(IID_I_dxj_DirectMusicAudioPath, (void**)&pPath) ) )
		{	
			if (!pPath) return E_INVALIDARG;
			DO_GETOBJECT_NOTNULL(IDirectMusicAudioPath*,pPlayPath,pPath);

			if (FAILED (hr = m__dxj_DirectMusicPerformance->StopEx(pPlayPath, outTime, (DWORD) lFlags) ) )
				return hr;
		}
			else
				return E_INVALIDARG;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::CreateAudioPath(IUnknown *SourceConfig, VARIANT_BOOL fActive, 
                                           		I_dxj_DirectMusicAudioPath **ppNewPath)
{
	HRESULT hr;
	IDirectMusicAudioPath	*lpPath = NULL;
	BOOL					bActive = FALSE;

	__try {
		if (fActive == VARIANT_TRUE)
			bActive = TRUE;
		else
			bActive = FALSE;

		if (FAILED (hr = m__dxj_DirectMusicPerformance->CreateAudioPath(SourceConfig, bActive, &lpPath) ) )
			return hr;

		INTERNAL_CREATE(_dxj_DirectMusicAudioPath,lpPath,ppNewPath);
		if (!ppNewPath) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::CreateStandardAudioPath(long lType, long lPChannelCount, VARIANT_BOOL fActive, 
	                                           I_dxj_DirectMusicAudioPath **ppNewPath)
{
	HRESULT hr;
	IDirectMusicAudioPath	*lpPath = NULL;

	__try {
		//First let's create our standard path
		if (FAILED ( hr = m__dxj_DirectMusicPerformance->CreateStandardAudioPath((DWORD) lType, (DWORD) lPChannelCount, (BOOL) fActive, &lpPath) ) )
			return hr;

		INTERNAL_CREATE(_dxj_DirectMusicAudioPath,lpPath,ppNewPath);
		if (!ppNewPath) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::SetDefaultAudioPath(I_dxj_DirectMusicAudioPath *AudioPath)
{
	HRESULT hr;

	__try {
		DO_GETOBJECT_NOTNULL(IDirectMusicAudioPath8*,pPath,AudioPath);
		
		if (FAILED(hr = m__dxj_DirectMusicPerformance->SetDefaultAudioPath(pPath) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::GetDefaultAudioPath(I_dxj_DirectMusicAudioPath **ppAudioPath)
{
	HRESULT hr;
	IDirectMusicAudioPath	*lpPath = NULL;

	__try {
		//First let's create our standard path
		if (FAILED ( hr = m__dxj_DirectMusicPerformance->GetDefaultAudioPath(&lpPath) ) )
			return hr;

		INTERNAL_CREATE(_dxj_DirectMusicAudioPath,lpPath,ppAudioPath);
		if (!ppAudioPath) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}


//DEAD CODE left here for reference
#if 0

	HRESULT C_dxj_DirectMusicPerformanceObject::addCommandParam( 
			/* [in] */ long trackIndex,
			/* [in] */ long mtTime,
			/* [in] */ Byte command,
			/* [in] */ Byte grooveLevel)
	{	
		HRESULT hr;	
		DMUS_COMMAND_PARAM cmd;
		cmd.bCommand=(BYTE)command;
		cmd.bGrooveLevel=(BYTE)grooveLevel;
		cmd.bGrooveRange=0;
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_CommandParam,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)mtTime,&cmd);	
		return hr;
	}


	HRESULT C_dxj_DirectMusicPerformanceObject::addBandChange(  /* [in] */ long trackIndex, /* [in] */ long mtTime, /* [in] */ I_dxj_DirectMusicBand __RPC_FAR *band)
	{
		if (!band) return E_INVALIDARG;	
		DO_GETOBJECT_NOTNULL(IDirectMusicBand*,pBand,band);
		HRESULT hr;	
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_IDirectMusicBand,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)mtTime,pBand);	
		return hr;
	}
 
	HRESULT C_dxj_DirectMusicPerformanceObject::addTempoChange( 
			/* [in] */ long trackIndex,
			/* [in] */ long mtTime,
			/* [in] */  double tempo)
	{
		HRESULT hr;	
		DMUS_TEMPO_PARAM tmp;
		tmp.dblTempo=tempo;
		tmp.mtTime=(MUSIC_TIME)mtTime;	
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_TempoParam,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)mtTime,&tmp);	
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::addTimeSigChange( /* [in] */ long trackIndex,/* [in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timeSignature)
	{
		HRESULT hr;	
		if (!timeSignature) return E_INVALIDARG;
		MUSIC_TIME mtTime=((DMUS_TIMESIGNATURE*)timeSignature)->mtTime;
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_TimeSignature,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)mtTime,(DMUS_TIMESIGNATURE*)timeSignature);	
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::setAutoDownloadEnable( /* [in] */ long trackIndex, /* [retval][out] */ VARIANT_BOOL b)
	{
		HRESULT hr;	
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Disable_Auto_Download,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Enable_Auto_Download,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}		
		return hr;
	}

     
	HRESULT C_dxj_DirectMusicPerformanceObject::setTempoEnable( /* [in] */ long trackIndex,/* [retval][out] */ VARIANT_BOOL b)
	{
		HRESULT hr;	
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_DisableTempo,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_EnableTempo,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}		
		return hr;
	}


	HRESULT C_dxj_DirectMusicPerformanceObject::setTimeSigEnable( /* [in] */ long trackIndex,/* [retval][out] */ VARIANT_BOOL b)
	{
		HRESULT hr;	
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_DisableTimeSig,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_EnableTimeSig,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}		
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::clearAllBands ()
	{
		HRESULT hr;
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Clear_All_Bands,0xFFFFFFFF,0,0,NULL);	
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::download(  /* [in] */ long trackIndex,    /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance)
	{
		if (!performance) return E_INVALIDARG;	
		DO_GETOBJECT_NOTNULL(IDirectMusicPerformance*,pPerformance,performance);
		HRESULT hr;	
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Download,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,pPerformance);	
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::unload( /* [in] */ long trackIndex,   /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance)
	{
		if (!performance) return E_INVALIDARG;	
		DO_GETOBJECT_NOTNULL(IDirectMusicPerformance*,pPerformance,performance);
		HRESULT hr;	
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Unload,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,pPerformance);	
		return hr;
	}

HRESULT C_dxj_DirectMusicPerformanceObject::AddPort(I_dxj_DirectMusicPort *port)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPORT, lpPort, port);
	
	if (FAILED (hr = m__dxj_DirectMusicPerformance->AddPort(lpPort) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::RemovePort(I_dxj_DirectMusicPort *port)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPORT, lpPort, port);
	
	if (FAILED (hr = m__dxj_DirectMusicPerformance->RemovePort(lpPort) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::AssignPChannel(long lPChannel, I_dxj_DirectMusicPort *Port, long lGroup, long lMChannel)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPORT, lpPort, Port);
	
	if (FAILED (hr = m__dxj_DirectMusicPerformance->AssignPChannel((DWORD)lPChannel, lpPort, (DWORD)lGroup, (DWORD) lMChannel) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::AssignPChannelBlock(long lPChannel, I_dxj_DirectMusicPort *Port, long lGroup)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPORT, lpPort, Port);
	
	if (FAILED (hr = m__dxj_DirectMusicPerformance->AssignPChannelBlock((DWORD)lPChannel, lpPort, (DWORD)lGroup) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::PChannelInfo(long lPChannel, I_dxj_DirectMusicPort *Port, long *lGroup, long *lMChannel)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPORT, lpPort, Port);
	
	if (FAILED (hr = m__dxj_DirectMusicPerformance->PChannelInfo((DWORD)lPChannel, &lpPort, (DWORD*)lGroup, (DWORD*) lMChannel) ) )
		return hr;

	return S_OK;
}
HRESULT C_dxj_DirectMusicPerformanceObject::init( 
		/* [in] */ I_dxj_DirectSound __RPC_FAR *DirectSound,
		/* [in] */ long hWnd,
					I_dxj_DirectMusic **ret)
{
	HRESULT hr;	
	IDirectMusic	*lpDMTemp = NULL;

	DO_GETOBJECT_NOTNULL(LPDIRECTSOUND,pSound,DirectSound);
    
	hr=m__dxj_DirectMusicPerformance->Init(&lpDMTemp,pSound,(HWND)hWnd);
	if FAILED(hr) return hr;

	if (FAILED( hr = lpDMTemp->QueryInterface(IID_IDirectMusic8,(void**) &m_pDM) ) )
		return hr;
	lpDMTemp->Release();

	m_pDM->AddRef();
	INTERNAL_CREATE(_dxj_DirectMusic,m_pDM,ret);
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::setPort( 
		/* [in] */ long portid,
		/* [in] */ long number_of_groups)
{
	if (!m_pDM) return DMUS_E_NOT_INIT;

	HRESULT             hr;
    DMUS_PORTPARAMS     dmos;
	GUID				guidSink;
	IDirectMusicPort	*port = NULL;
	DWORD				j=0;
	
    // Initialize the performance. Have the performance create the
    // DirectMusic object by setting pDM to NULL. It is needed to
    // create the port.

	// Set Port Params
    ZeroMemory( &dmos, sizeof(DMUS_PORTPARAMS) );
    dmos.dwSize = sizeof(DMUS_PORTPARAMS);  
    dmos.dwChannelGroups = number_of_groups;
    dmos.dwEffectFlags = DMUS_EFFECT_REVERB;
    dmos.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS | DMUS_PORTPARAMS_EFFECTS;
	
	if (m_pPort){

		// We've already got this port, lets get rid of it
		
		hr = m_pPort->Release();

		if ( FAILED(hr= m__dxj_DirectMusicPerformance->RemovePort(m_pPort) ))
			return hr;
	}


	if (portid<=0) {
		guidSink = GUID_NULL;
	}
	else {
		DMUS_PORTCAPS       caps;

		ZeroMemory(&caps,sizeof(DMUS_PORTCAPS));
		caps.dwSize=sizeof(DMUS_PORTCAPS);

		hr=m_pDM->EnumPort(  (DWORD) portid-1,   &caps );
		if FAILED(hr) return hr;
		memcpy(&guidSink,&caps.guidPort,sizeof(GUID));
	}

	// Create the port
    if (FAILED(hr = m_pDM->CreatePort( guidSink, &dmos, &port, NULL )))
		return hr;

	//Now get our DirectMusicPort8
	hr = port->QueryInterface(IID_IDirectMusicPort8, (void **) &m_pPort );
	port->Release();
	if ( FAILED ( hr ) ) return hr;

	// Activate all ports
    if ( FAILED (hr = m_pDM->Activate( TRUE ) ) )
		return hr;

	// Add the port to the performance.
    if (FAILED (hr = m__dxj_DirectMusicPerformance->AddPort( m_pPort ) ))
		return hr;

	// Assign PChannel blocks for the number of groups we want.

	for( long i = 0; i < number_of_groups; i++ )
	{
		m__dxj_DirectMusicPerformance->AssignPChannelBlock( i, m_pPort, i+1 );
	}

	m_portid=portid;
	m_number_of_groups=number_of_groups;
	return S_OK;

}

HRESULT C_dxj_DirectMusicPerformanceObject::playSegment( 
		/* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
		/* [in] */ long lFlags,
		/* [in] */ long startTime,
		/* [retval][out] */ I_dxj_DirectMusicSegmentState __RPC_FAR *__RPC_FAR *segmentState)
{
	HRESULT hr;	
	if (!segment) return E_INVALIDARG;
	if (!segmentState) return E_INVALIDARG;
					     
	DO_GETOBJECT_NOTNULL(IDirectMusicSegment*,pSeg,segment);
	IDirectMusicSegmentState *pState=NULL;
	
	__int64 outTime=(__int64)startTime;
	if (lFlags & DMUS_SEGF_REFTIME)  outTime=VBREF_TO_REALREFTIME(startTime);
	
	hr=m__dxj_DirectMusicPerformance->PlaySegment(pSeg,(DWORD)lFlags,outTime,&pState);
	if FAILED(hr) return hr;
	if (!pState) return E_FAIL;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegmentState,pState,segmentState);
	
	if (*segmentState==NULL) return E_OUTOFMEMORY;
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::stop( 
		/* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
		/* [in] */ I_dxj_DirectMusicSegmentState __RPC_FAR *segmentState,		
		/* [in] */ long endTime,
		/* [in] */ long lFlags)
		
{
	HRESULT hr;	
	
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT,pSeg,segment);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENTSTATE,pSegState,segmentState);
	
	
	
	__int64 outTime=(__int64)endTime;
	if (lFlags & DMUS_SEGF_REFTIME)  outTime=VBREF_TO_REALREFTIME(endTime);
	
	hr=m__dxj_DirectMusicPerformance->Stop(pSeg,pSegState,(MUSIC_TIME)outTime,(DWORD)lFlags);	
	
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getPortName( 
		/* [in] */ long i,
		/* [retval][out] */ BSTR __RPC_FAR *name)
{
	HRESULT hr;	
	DMUS_PORTCAPS caps;
	if (!m_pDM) return CO_E_NOTINITIALIZED;
	if (i<=0) return E_INVALIDARG;

	if (!name) return E_INVALIDARG;
	ZeroMemory(&caps,sizeof(DMUS_PORTCAPS));
	caps.dwSize=sizeof(DMUS_PORTCAPS);
	hr=m_pDM->EnumPort(  (DWORD) i-1,   &caps );
	
	if (hr!=S_OK) return E_INVALIDARG;	//happens when we are out of bounds
										//manbug23240
	if FAILED(hr) return hr;			//for other resason ?

	*name=SysAllocString(caps.wszDescription);
	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getPortCount( 
		/* [retval][out] */ long __RPC_FAR *c)
{
	HRESULT hr=S_OK;	
	DMUS_PORTCAPS caps;
	DWORD i=0;
	if (!m_pDM) return CO_E_NOTINITIALIZED;
	if (!c) return E_INVALIDARG;
	while (hr==S_OK){
		caps.dwSize=sizeof(DMUS_PORTCAPS);
		hr=m_pDM->EnumPort(  i++,   &caps );
		if FAILED(hr) return hr;
	}
	*c=(long)i-1;
	return S_OK;
}
HRESULT C_dxj_DirectMusicPerformanceObject::getPortCaps( long i,
		/* [retval][out] */ DMUS_PORTCAPS_CDESC __RPC_FAR *c)
{
	HRESULT hr;		
	if (!c) return E_INVALIDARG;
	if (!m_pDM) return CO_E_NOTINITIALIZED;
	if (i<=0) return E_INVALIDARG;

	ZeroMemory(c,sizeof(DMUS_PORTCAPS));
	((DMUS_PORTCAPS*)c)->dwSize=sizeof(DMUS_PORTCAPS);
	hr=m_pDM->EnumPort(  (DWORD) i-1,   (DMUS_PORTCAPS*)c );
	if (hr==S_FALSE) return E_INVALIDARG;

	return hr;		
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmcomposerobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmcomposerobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicComposerObject

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicComposer IDirectMusicComposer8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicComposerObject : 
	public I_dxj_DirectMusicComposer,
	//public CComCoClass<C_dxj_DirectMusicComposerObject, &CLSID__dxj_DirectMusicComposer>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicComposerObject();
	virtual ~C_dxj_DirectMusicComposerObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicComposerObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicComposer)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicComposer,		"DIRECT.DirectMusicComposer.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicComposerObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

    
	    HRESULT STDMETHODCALLTYPE autoTransition( 
        /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *Performance,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *ToSeg,
        /* [in] */ long lCommand,
        /* [in] */ long lFlags,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ppTransSeg);
    
    HRESULT STDMETHODCALLTYPE composeSegmentFromTemplate( 
		/* [in] */ I_dxj_DirectMusicStyle __RPC_FAR *style,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *TemplateSeg,
        /* [in] */ short Activity,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg);
    
    HRESULT STDMETHODCALLTYPE composeSegmentFromShape( 
        /* [in] */ I_dxj_DirectMusicStyle __RPC_FAR *style,
        /* [in] */ short numberOfMeasures,
        /* [in] */ short shape,
        /* [in] */ short activity,
        /* [in] */ VARIANT_BOOL bIntro,
        /* [in] */ VARIANT_BOOL bEnd,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg);
    
    HRESULT STDMETHODCALLTYPE composeTransition( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *pFromSeg,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *ToSeg,
        /* [in] */ long mtTime,
        /* [in] */ long lCommand,
        /* [in] */ long lFlags,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg);
    
    HRESULT STDMETHODCALLTYPE composeTemplateFromShape( 
        /* [in] */ short numMeasures,
        /* [in] */ short shape,
        /* [in] */ VARIANT_BOOL bIntro,
        /* [in] */ VARIANT_BOOL bEnd,
        /* [in] */ short endLength,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *TempSeg);
    
    HRESULT STDMETHODCALLTYPE changeChordMap( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ VARIANT_BOOL trackScale,
        /* [retval][out] */ I_dxj_DirectMusicChordMap  *ChordMap);
    

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicComposer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicComposer)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmstyleobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmstyleobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmChordMapObj.h"
#include "dmSegmentObj.h"
#include "dmStyleObj.h"
#include "dmBandObj.h"

extern void *g_dxj_DirectMusicStyle;
extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicChordMap;
extern void *g_dxj_DirectMusicBand;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicStyle, {});
DESTRUCTOR(_dxj_DirectMusicStyle, {});
GETSET_OBJECT(_dxj_DirectMusicStyle);

typedef IDirectMusicSegment*		LPDIRECTMUSICSEGMENT;
typedef IDirectMusicPerformance*	LPDIRECTMUSICPERFORMANCE;
typedef IDirectMusicChordMap*		LPDIRECTMUSICCHORDMAP;
typedef IDirectMusicStyle*			LPDIRECTMUSICSTYLE;

HRESULT C_dxj_DirectMusicStyleObject:: getBandName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name)
{  
	HRESULT hr;			
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);

	hr=m__dxj_DirectMusicStyle->EnumBand((DWORD)index,wstring);
	if (hr!=S_OK) return hr;	
	*name=SysAllocString(wstring);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject:: getBandCount( long *count)        
{    			
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);
	DWORD i=0;
	
	while (S_OK==m__dxj_DirectMusicStyle->EnumBand((DWORD)i++,wstring)){
		//make sure dmusic is doing what its docs say it does
		if (i>1000000) return E_FAIL;
	}
	*count=(long)i-1;
	
	return S_OK;
}


HRESULT C_dxj_DirectMusicStyleObject:: getBand( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicBand *pBand=NULL;

	hr=m__dxj_DirectMusicStyle->GetBand(name,&pBand);
	if FAILED(hr) return hr;
	if (!pBand) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicBand,pBand,ret);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject::getDefaultBand( 
        /* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicBand *pBand=NULL;
	*ret=NULL;
	hr=m__dxj_DirectMusicStyle->GetDefaultBand(&pBand);
	if FAILED(hr) return hr;
	if (hr==S_FALSE) return S_OK;
	if (!pBand) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicBand,pBand,ret);
	return hr;
}

    
HRESULT C_dxj_DirectMusicStyleObject:: getMotifName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name)
{    
	HRESULT hr;
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);

	hr=m__dxj_DirectMusicStyle->EnumMotif((DWORD)index,wstring);
	if (hr!=S_OK) return hr;	
	*name=SysAllocString(wstring);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject:: getMotifCount( long *count)        
{    			
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);
	DWORD i=0;
	
	while (S_OK==m__dxj_DirectMusicStyle->EnumMotif((DWORD)i++,wstring)){
		//make sure dmusic is doing what its docs say it does
		if (i>1000000) return E_FAIL;
	}
	*count=(long)i-1;
	
	return S_OK;
}


HRESULT C_dxj_DirectMusicStyleObject:: getMotif( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicSegment *pSeg=NULL;

	hr=m__dxj_DirectMusicStyle->GetMotif(name,&pSeg);
	if FAILED(hr) return hr;
	if (!pSeg) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pSeg,ret);
	return hr;
}



HRESULT C_dxj_DirectMusicStyleObject:: getChordMapName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name)
{    	
	HRESULT hr;
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);

	hr=m__dxj_DirectMusicStyle->EnumChordMap((DWORD)index,wstring);
	if (hr!=S_OK) return hr;	
	*name=SysAllocString(wstring);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject:: getChordMapCount( long *count)        
{ 
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);
	DWORD i=0;
	
	while (S_OK==m__dxj_DirectMusicStyle->EnumChordMap((DWORD)i++,wstring)){
		//make sure dmusic is doing what its docs say it does
		if (i>1000000) return E_FAIL;
	}
	*count=(long)i-1;
	
	return S_OK;
}


HRESULT C_dxj_DirectMusicStyleObject:: getChordMap( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicChordMap	*pMap=NULL;

	hr=m__dxj_DirectMusicStyle->GetChordMap(name,&pMap);
	if FAILED(hr) return hr;
	if (!pMap) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pMap,ret);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject:: getDefaultChordMap( 
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicChordMap	*pMap=NULL;
	*ret=NULL;
	hr=m__dxj_DirectMusicStyle->GetDefaultChordMap(&pMap);
	if (hr==S_FALSE) return S_OK;

	if FAILED(hr) return hr;
	if (!pMap) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pMap,ret);
	return hr;
}


HRESULT C_dxj_DirectMusicStyleObject:: getEmbellishmentMinLength( 
        /* [in] */ long type,
        /* [in] */ long level,
        /* [retval][out] */ long __RPC_FAR *ret)
{
	HRESULT hr;			
	DWORD dwMin=0;
	DWORD dwMax=0;

	hr=m__dxj_DirectMusicStyle->GetEmbellishmentLength((DWORD)type,(DWORD)level,&dwMin,&dwMax);
	*ret=(long)dwMin;
	return hr;
}
		
HRESULT C_dxj_DirectMusicStyleObject:: getEmbellishmentMaxLength( 
        /* [in] */ long type,
        /* [in] */ long level,
        /* [retval][out] */ long __RPC_FAR *ret)
{
	HRESULT hr;			
	DWORD dwMin=0;
	DWORD dwMax=0;

	hr=m__dxj_DirectMusicStyle->GetEmbellishmentLength((DWORD)type,(DWORD)level,&dwMin,&dwMax);	
	*ret=(long)dwMax;
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject::getTempo( 
        /* [retval][out] */ double __RPC_FAR *ret)
{
	HRESULT hr;			
	hr=m__dxj_DirectMusicStyle->GetTempo(ret);	
	return hr;
}

		

HRESULT C_dxj_DirectMusicStyleObject::getTimeSignature( 
        /* [out][in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *pTimeSig)
{
	HRESULT hr;				
	if (!pTimeSig) return E_INVALIDARG;
	hr=m__dxj_DirectMusicStyle->GetTimeSignature((DMUS_TIMESIGNATURE*)pTimeSig);	
	return hr;
}
// GetDC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmperformanceobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmperformanceobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicPerformanceObject

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicPerformance IDirectMusicPerformance8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicPerformanceObject : 
	public I_dxj_DirectMusicPerformance,
	//public CComCoClass<C_dxj_DirectMusicPerformanceObject, &CLSID__dxj_DirectMusicPerformance>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicPerformanceObject();
	virtual ~C_dxj_DirectMusicPerformanceObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicPerformanceObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicPerformance)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicPerformance,		"DIRECT.DirectMusicPerformance.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicPerformanceObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);



#if 0
    HRESULT STDMETHODCALLTYPE init( 
        /* [in] */ I_dxj_DirectSound __RPC_FAR *DirectSound,
        /* [in] */ long hWnd,
		I_dxj_DirectMusic **ret);
#endif
    
    HRESULT STDMETHODCALLTYPE closeDown( void);
    
    HRESULT STDMETHODCALLTYPE playSegment( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ long lFlags,
        /* [in] */ long startTime,
        /* [retval][out] */ I_dxj_DirectMusicSegmentState __RPC_FAR *__RPC_FAR *segmentState);
    
    HRESULT STDMETHODCALLTYPE stop( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ I_dxj_DirectMusicSegmentState __RPC_FAR *segmentState,
        /* [in] */ long mtTime,
        /* [in] */ long lFlags);
    
    HRESULT STDMETHODCALLTYPE getSegmentState( 
        /* [in] */ long mtTime,
        /* [retval][out] */ I_dxj_DirectMusicSegmentState __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE invalidate( 
        /* [in] */ long mtTime,
        /* [in] */ long flags);
    
    HRESULT STDMETHODCALLTYPE isPlaying( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ I_dxj_DirectMusicSegmentState __RPC_FAR *segmentState,
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *b);
    
    HRESULT STDMETHODCALLTYPE addNotificationType( 
        /* [in] */ CONST_DMUS_NOTIFICATION_TYPE type);
    
    HRESULT STDMETHODCALLTYPE removeNotificationType( 
        /* [in] */ CONST_DMUS_NOTIFICATION_TYPE type);
    
#ifdef _WIN64
	HRESULT STDMETHODCALLTYPE setNotificationHandle( 
        /* [in] */ HWND hnd);
#else
	HRESULT STDMETHODCALLTYPE setNotificationHandle( 
        /* [in] */ long hnd);
#endif
    
    HRESULT STDMETHODCALLTYPE getNotificationPMSG( 
        /* [out][in] */ DMUS_NOTIFICATION_PMSG_CDESC __RPC_FAR *message, VARIANT_BOOL *b);
    
    HRESULT STDMETHODCALLTYPE musicToClockTime( 
        /* [in] */ long mtTime,
        /* [retval][out] */ long __RPC_FAR *rtTime);
    
    HRESULT STDMETHODCALLTYPE clockToMusicTime( 
        /* [in] */ long rtTime,
        /* [retval][out] */ long __RPC_FAR *mtTime);
    
    HRESULT STDMETHODCALLTYPE getMusicTime( 
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getClockTime( 
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getPrepareTime( 
        /* [retval][out] */ long __RPC_FAR *lMilliSeconds);
    
    HRESULT STDMETHODCALLTYPE getBumperLength( 
        /* [retval][out] */ long __RPC_FAR *lMilliSeconds);
    
    HRESULT STDMETHODCALLTYPE getLatencyTime( 
        /* [retval][out] */ long __RPC_FAR *rtTime0);
    
    HRESULT STDMETHODCALLTYPE getQueueTime( 
        /* [retval][out] */ long __RPC_FAR *rtTime);
    
    HRESULT STDMETHODCALLTYPE getResolvedTime( 
        /* [in] */ long rtTime,
        /* [in] */ long flags,
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE setPrepareTime( 
        /* [in] */ long lMilliSeconds);
    
    HRESULT STDMETHODCALLTYPE setBumperLength( 
        /* [in] */ long lMilliSeconds);
    
    HRESULT STDMETHODCALLTYPE adjustTime( 
        /* [in] */ long rtAmount);
    
    HRESULT STDMETHODCALLTYPE setMasterAutoDownload( 
        /* [in] */ VARIANT_BOOL b);
    
    HRESULT STDMETHODCALLTYPE getMasterAutoDownload( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *b);
    
    HRESULT STDMETHODCALLTYPE setMasterTempo( 
        /* [in] */ float tempo);
    
    HRESULT STDMETHODCALLTYPE getMasterTempo( 
        /* [retval][out] */ float __RPC_FAR *tempo);
    
    HRESULT STDMETHODCALLTYPE setMasterVolume( 
        /* [in] */ long vol);
    
    HRESULT STDMETHODCALLTYPE getMasterVolume( 
        /* [retval][out] */ long __RPC_FAR *v);
    
    HRESULT STDMETHODCALLTYPE setMasterGrooveLevel( 
        /* [in] */ short level);
    
    HRESULT STDMETHODCALLTYPE getMasterGrooveLevel( 
        /* [retval][out] */  __RPC_FAR short *level);
    
    HRESULT STDMETHODCALLTYPE Reset(long flags);
    
    HRESULT STDMETHODCALLTYPE getStyle( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getChordMap( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getCommand( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ Byte __RPC_FAR *command);
    
    HRESULT STDMETHODCALLTYPE getGrooveLevel( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ Byte __RPC_FAR *level);
    
    HRESULT STDMETHODCALLTYPE getTempo( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ double __RPC_FAR *tempo);
    
    HRESULT STDMETHODCALLTYPE getTimeSig( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [out][in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timeSig);
    
    HRESULT STDMETHODCALLTYPE sendNotePMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ DMUS_NOTE_PMSG_CDESC __RPC_FAR *msg);
    
    HRESULT STDMETHODCALLTYPE sendCurvePMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ DMUS_CURVE_PMSG_CDESC __RPC_FAR *msg);
    
    HRESULT STDMETHODCALLTYPE sendMIDIPMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ Byte status,
        /* [in] */ Byte byte1,
        /* [in] */ Byte byte2);
    
    HRESULT STDMETHODCALLTYPE sendPatchPMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ Byte instrument,
        /* [in] */ Byte byte1,
        /* [in] */ Byte byte2);
    
    HRESULT STDMETHODCALLTYPE sendTempoPMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
       // /* [in] */ long channel,
        /* [in] */ double tempo);
    
    HRESULT STDMETHODCALLTYPE sendTransposePMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ short transpose);
    
    HRESULT STDMETHODCALLTYPE sendTimeSigPMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timesig);
    
#if 0
	HRESULT STDMETHODCALLTYPE getPortName( 
        /* [in] */ long i,
        /* [retval][out] */ BSTR __RPC_FAR *name);
    
    HRESULT STDMETHODCALLTYPE getPortCount( 
        /* [retval][out] */ long __RPC_FAR *c);
    
    HRESULT STDMETHODCALLTYPE getPortCaps( long i,
        /* [out][in] */ DMUS_PORTCAPS_CDESC __RPC_FAR *caps);
    
    HRESULT STDMETHODCALLTYPE setPort( 
        /* [in] */ long portid,
        /* [in] */ long numGroups);
#endif
#ifdef _WIN64
    HRESULT STDMETHODCALLTYPE InitAudio(HWND hWnd,
										long lFlags,
										DMUS_AUDIOPARAMS_CDESC *AudioParams,
                                        I_dxj_DirectSound **DirectSound,  
                                        long lDefaultPathType,           
                                        long lPChannelCount);            
#else
    HRESULT STDMETHODCALLTYPE InitAudio(long hWnd,
										long lFlags,
										DMUS_AUDIOPARAMS_CDESC *AudioParams,
                                        I_dxj_DirectSound **DirectSound,  
                                        long lDefaultPathType,           
                                        long lPChannelCount);            
#endif
        
    HRESULT STDMETHODCALLTYPE PlaySegmentEx(IUnknown *Source,
											long lFlags,
											long StartTime,
											IUnknown *From,
											IUnknown *AudioPath,
#if 0
											BSTR SegmentName,
											IUnknown *Transition, 
#endif
											I_dxj_DirectMusicSegmentState **ppSegmentState); 

    HRESULT STDMETHODCALLTYPE StopEx(IUnknown *ObjectToStop,
										long lStopTime, 
										long lFlags);


    HRESULT STDMETHODCALLTYPE CreateAudioPath(IUnknown *SourceConfig, VARIANT_BOOL fActive, 
                                           		I_dxj_DirectMusicAudioPath **ppNewPath);

    HRESULT STDMETHODCALLTYPE CreateStandardAudioPath(long lType, long lPChannelCount, VARIANT_BOOL fActive, 
	                                           I_dxj_DirectMusicAudioPath **ppNewPath);

    HRESULT STDMETHODCALLTYPE SetDefaultAudioPath(I_dxj_DirectMusicAudioPath *AudioPath);
    HRESULT STDMETHODCALLTYPE GetDefaultAudioPath(I_dxj_DirectMusicAudioPath **ppAudioPath);

#if 0
	HRESULT STDMETHODCALLTYPE AddPort(I_dxj_DirectMusicPort *port);
    HRESULT STDMETHODCALLTYPE RemovePort(I_dxj_DirectMusicPort *port);
    HRESULT STDMETHODCALLTYPE AssignPChannel(long lPChannel, I_dxj_DirectMusicPort *Port, long lGroup, long lMChannel);
    HRESULT STDMETHODCALLTYPE AssignPChannelBlock(long lPChannel, I_dxj_DirectMusicPort *Port, long lGroup);
    HRESULT STDMETHODCALLTYPE PChannelInfo(long lPChannel, I_dxj_DirectMusicPort *Port, long *lGroup, long *lMChannel);
#endif

////////////////////////////////////////////////////////////////////////////////////
//
private:
	HRESULT InternalInit();
	HRESULT InternalCleanup();
	

	IDirectMusic8 *m_pDM;
	IDirectMusicPort8 *m_pPort;
    DECL_VARIABLE(_dxj_DirectMusicPerformance);
	long m_portid;
	long m_number_of_groups;


	

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicPerformance)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dms.h ===
//+-------------------------------------------------------------------------
    //
    //  Microsoft Windows
    //
    //  Copyright (C) Microsoft Corporation, 1998 - 1999
    //
    //  File:       dms.h
    //
    //--------------------------------------------------------------------------
     
    
    //
    // dms.h : david's funky stuff
    //
    // CLONETO, QIOVERLOAD: see d3drmVisualObj.cpp
    //
    //
    //
    #include "basetsd.h"
extern long g_debuglevel;
    
    #ifdef DEBUG
	 #define DPF(n,o)		{if (g_debuglevel >= n) { OutputDebugString(o);}}
	 #define DPF1(n,o,p)		{if (g_debuglevel >= n) {char szOutN[1024]; wsprintf(szOutN,o,p);OutputDebugString(szOutN);}}
	 #define DPF2(n,o,p,e)	{if (g_debuglevel >= n) {char szOutN[1024]; wsprintf(szOutN,o,p,e);OutputDebugString(szOutN);}}
    #else
		#ifdef DBG
		 #define DPF(n,o)		{if (g_debuglevel >= n) { OutputDebugString(o);}}
		 #define DPF1(n,o,p)		{if (g_debuglevel >= n) {char szOutN[1024]; wsprintf(szOutN,o,p);OutputDebugString(szOutN);}}
		 #define DPF2(n,o,p,e)	{if (g_debuglevel >= n) {char szOutN[1024]; wsprintf(szOutN,o,p,e);OutputDebugString(szOutN);}}
		#else
		 #define DPF(n,o)		
		 #define DPF1(n,o,p)		
		 #define DPF2(n,o,p,e)
		#endif	
    #endif
    
    #define INTERNAL_CREATE_RETOBJ(objType,objOther,retval,classobj) \
    { 	C##objType##Object *prev=NULL; \
    	*retval = NULL;	\
    	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
    	{	IUnknown *unk=0; \
    		ptr->InternalGetObject(&unk); \
    		if(unk == objOther) \
    		{ \
    			*retval = (I##objType*)ptr->pinterface; \
    			IUNK(ptr->pinterface)->AddRef(); \
    			IUNK(objOther)->Release(); \
    			classobj=ptr; \
    			break; \
    		} \
    		prev = ptr; \
    	} \
    	if(!ptr) \
    	{	C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
    		c->parent = this; \
    		((I##objType *)this)->AddRef();  \
    		c->InternalSetObject(objOther); \
    		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) \
    			return E_FAIL; \
    		c->pinterface = (void*)*retval; \
    		classobj=c; \
    } }
    
    
    
    #define INTERNAL_CREATE_STRUCT(objType,retval) { C##objType##Object *c=new CComObject<C##objType##Object>;\
    	if (c==NULL) return E_OUTOFMEMORY;\
    	if (FAILED(((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL;\
    	}
    
    
    #define INTERNAL_CREATE_NOADDREF(objType,objOther,retval) {C##objType##Object *prev=NULL; *retval = NULL; \
    	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj){IUnknown *unk=0;ptr->InternalGetObject(&unk); 	if(unk == objOther) { 	*retval = (I##objType*)ptr->pinterface;	IUNK(ptr->pinterface)->AddRef(); IUNK(objOther)->Release(); break;	} 	prev = ptr; } \
    	if(!ptr) { 	C##objType##Object *c=new CComObject<C##objType##Object>; if( c == NULL ) {	objOther->Release();return E_FAIL;}	c->InternalSetObject(objOther);  if FAILED(((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval)) 	return E_FAIL; c->pinterface = (void*)*retval; }}	
    		
    // Given a java interface (objtype), envoke InternalSetObject and set the given
    // DIRECTX pointer (objOther). Also envoke QueryInterface and set a ** interface
    // ptr to a DIRECTX object (retval). So we create a DIRECTX object.
    //#define INTERNAL_CREATE(objType,objOther,retval){C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
    //c->parent = this; AddRef(); c->InternalSetObject(objOther);if (FAILED(c->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; }
    //			if (FAILED(ptr->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; 
    #ifdef _DEBUG
    #define INTERNAL_CREATE(objType,objOther,retval) \
    { \
    	DWORD refcount; char buffer[256]; wsprintf(buffer,"INTERNAL_CREATE %s \n",__FILE__); \
    	OutputDebugString(buffer); \
    	C##objType##Object *prev=NULL; \
    	*retval = NULL;	\
    	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
    	{\
    		IUnknown *unk=0; \
    		ptr->InternalGetObject(&unk); \
    		if(unk == objOther) \
    		{ \
    			*retval = (I##objType*)ptr->pinterface;\
    			IUNK(ptr->pinterface)->AddRef();\
    			IUNK(objOther)->Release(); \
    			refcount = *(((DWORD*)ptr)+1); \
    			wsprintf(buffer,"		Retrived Object [%s] RefCount %d \n\r",__FILE__, refcount);\
    			OutputDebugString(buffer);\
    			break; \
    		} \
    		prev = ptr; \
    	} \
    	if(!ptr) \
    	{ \
    		C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
    		c->parent = this; \
    		((I##objType *)this)->AddRef(); \
    		refcount = *(((DWORD*)this)+1); \
    		wsprintf(buffer,"Object [%s] RefCount[%d]\n\r",__FILE__, refcount);\
    		OutputDebugString(buffer);\
    		c->InternalSetObject(objOther);if (FAILED((	((I##objType *)c))->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
    		c->pinterface = (void*)*retval; \
    	} \
    }
    #else
    #define INTERNAL_CREATE(objType,objOther,retval) \
    { \
    	C##objType##Object *prev=NULL; \
    	*retval = NULL;	\
    	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
    	{\
    		IUnknown *unk=0; \
    		ptr->InternalGetObject(&unk); \
    		if(unk == objOther) \
    		{ \
    			*retval = (I##objType*)ptr->pinterface; \
    			IUNK(ptr->pinterface)->AddRef(); \
    			IUNK(objOther)->Release(); \
    			break; \
    		} \
    		prev = ptr; \
    	} \
    	if(!ptr) \
    	{ \
    		C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
    		c->parent = this; \
    		((I##objType *)this)->AddRef();  \
    		c->InternalSetObject(objOther); \
    		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
    		c->pinterface = (void*)*retval; \
    	} \
    }
    #endif
    
    
    #define INTERNAL_CREATE_NO_PARENT(objType,objOther,retval) \
    { \
    	C##objType##Object *prev=NULL; \
    	*retval = NULL;	\
    	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
    	{\
    		IUnknown *unk=0; \
    		ptr->InternalGetObject(&unk); \
    		if(unk == objOther) \
    		{ \
    			*retval = (I##objType*)ptr->pinterface; \
    			IUNK(ptr->pinterface)->AddRef(); \
    			IUNK(objOther)->Release(); \
    			break; \
    		} \
    		prev = ptr; \
    	} \
    	if(!ptr) \
    	{ \
    		C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
    		c->InternalSetObject(objOther); \
    		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
    		c->pinterface = (void*)*retval; \
    	} \
    }
    
    #define INTERNAL_CREATE_ADDRESS(objType,objOther,retval) \
    { \
    	C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
    	c->InternalSetObject(objOther); \
    	if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
    	c->pinterface = (void*)*retval; \
    }
    #define INTERNAL_CREATE_2REFS(objType,objParentType,objParent, objOther,retval) \
    {	 \
    	C##objType##Object *prev=NULL; \
    	*retval = NULL;	\
    	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
    	{\
    		IUnknown *unk=0; \
    		ptr->InternalGetObject(&unk); \
    		if(unk == objOther) \
    		{ \
    			*retval = (I##objType*)ptr->pinterface; \
    			IUNK(ptr->pinterface)->AddRef(); \
    			IUNK(objOther)->Release(); \
    			break; \
    		} \
    		prev = ptr; \
    	} \
    	if(!ptr) \
    	{ \
    		C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
    		c->parent = this; \
    		c->parent2 = IUNK(objParent); \
    		((I##objType *)this)->AddRef();  \
    		((I##objParentType*)objParent)->AddRef();  \
    		c->InternalSetObject(objOther); \
    		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
    		c->pinterface = (void*)*retval; \
    	} \
    }
    
    
    #define INTERNAL_CREATE_1REFS(objType,objParentType,objParent, objOther,retval) \
    {	 \
    	C##objType##Object *prev=NULL; \
    	*retval = NULL;	\
    	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
    	{\
    		IUnknown *unk=0; \
    		ptr->InternalGetObject(&unk); \
    		if(unk == objOther) \
    		{ \
    			*retval = (I##objType*)ptr->pinterface; \
    			IUNK(ptr->pinterface)->AddRef(); \
    			IUNK(objOther)->Release(); \
    			break; \
    		} \
    		prev = ptr; \
    	} \
    	if(!ptr) \
    	{ \
    		C##objType##Object *c=new CComObject<C##objType##Object>; \
            if( c == NULL ) \
            { objOther->Release(); return E_FAIL;} \
    		c->parent = IUNK(objParent); \
    		((I##objParentType*)objParent)->AddRef();  \
    		c->InternalSetObject(objOther); \
    		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
    		c->pinterface = (void*)*retval; \
    	} \
    }
    
    
    /////////////////////////////////////////////////////////////////////////
    #define MAX_INTERNAL_STR_LEN	256
    
    struct JavaString
    {
    	DWORD nBytes;
    	WCHAR Item[MAX_INTERNAL_STR_LEN];
    };
    
    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    // mod:dp helper macros for stuffing expanded unions in DirectX Structures
    
    #define IUNK(o) ((IUnknown*)(void*)(o))
    #define IS_NULLGUID(g) (\
    	(g->data1==0) && \
    	(g->data2==0) && \
    	(g->data3==0) && \
    	(g->data4[0]==0) && \
    	(g->data4[1]==0) && \
    	(g->data4[2]==0) && \
    	(g->data4[3]==0) && \
    	(g->data4[4]==0) && \
    	(g->data4[5]==0) && \
    	(g->data4[6]==0) && \
    	(g->data4[7]==0) )
    
     	
    
    
    
    /////////////////////////////////////////////////////////////////////////
    #define JAVASTRING(item) {sizeof(item)*2-2, L##item}
    
    #define PASS_THROUGH(cl,m) STDMETHODIMP C##cl##Object::m() { return m_##cl->m();}
    #define PASS_THROUGH1(c,m,t1) STDMETHODIMP C##c##Object::m(t1 v1) { return m_##c->m(v1);}
    #define PASS_THROUGH2(c,m,t1,t2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2) { return m_##c->m(v1, v2);}
    #define PASS_THROUGH3(c,m,t1,t2,t3) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,t3 v3) { return m_##c->m(v1, v2,v3);}
    #define PASS_THROUGH4(c,m,t1,t2,t3,t4) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4){return m_##c->m(v1, v2,v3,v4);}
    #define PASS_THROUGH5(c,m,t1,t2,t3,t4,t5) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5){return m_##c->m(v1, v2,v3,v4,v5);}
    #define PASS_THROUGH6(c,m,t1,t2,t3,t4,t5,t6) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6){return m_##c->m(v1, v2,v3,v4,v5,v6);}
    #define PASS_THROUGH7(c,m,t1,t2,t3,t4,t5,t6,t7) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7){return m_##c->m(v1, v2,v3,v4,v5,v6,v7);}
    #define PASS_THROUGH8(c,m,t1,t2,t3,t4,t5,t6,t7,t8) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7,t8 v8){return m_##c->m(v1,v2,v3,v4,v5,v6,v7,v8);}
    
    #define PASS_THROUGH_CAST_1(c,m,t1,tt1) STDMETHODIMP C##c##Object::m(t1 v1) { return m_##c->m(tt1 v1);}
    #define PASS_THROUGH_CAST_2(c,m,t1,tt1,t2,tt2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2) { return m_##c->m(tt1 v1, tt2 v2);}
    #define PASS_THROUGH_CAST_3(c,m,t1,tt1,t2,tt2,t3,tt3) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,t3 v3) { return m_##c->m(tt1 v1,tt2 v2,tt3 v3);}
    #define PASS_THROUGH_CAST_4(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4){return m_##c->m(tt1 v1, tt2 v2,tt3 v3,tt4 v4);}
    #define PASS_THROUGH_CAST_5(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5){return m_##c->m(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5);}
    #define PASS_THROUGH_CAST_6(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6){return m_##c->m(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6);}
    #define PASS_THROUGH_CAST_7(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6,t7,tt7) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7){return m_##c->m(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6,tt7 v7);}
    #define PASS_THROUGH_CAST_8(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6,t7,tt7,t8,tt8) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7,t8 v8){return m_##c->m(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6,tt7 v7,tt8 v8);}
    
    //mod:dp additions due to renaming 
    #define PASS_THROUGH_R(c,m1,m2) STDMETHODIMP C##c##Object::m1() { if(m_##c==NULL)return E_FAIL; return m_##c->m2();}
    #define PASS_THROUGH1_R(c,m1,m2,t1) STDMETHODIMP C##c##Object::m1(t1 v1) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1);}
    #define PASS_THROUGH2_R(c,m1,m2,t1,t2) STDMETHODIMP C##c##Object::m1(t1 v1, t2 v2) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2);}
    #define PASS_THROUGH3_R(c,m1,m2,t1,t2,t3) STDMETHODIMP C##c##Object::m1(t1 v1, t2 v2,t3 v3) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3);}
    #define PASS_THROUGH4_R(c,m1,m2,t1,t2,t3,t4) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3,v4);}
    #define PASS_THROUGH5_R(c,m1,m2,t1,t2,t3,t4,t5) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3,v4,v5);}
    #define PASS_THROUGH6_R(c,m1,m2,t1,t2,t3,t4,t5,t6) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3,v4,v5,v6);}
    #define PASS_THROUGH7_R(c,m1,m2,t1,t2,t3,t4,t5,t6,t7) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7){if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3,v4,v5,v6,v7);}
    #define PASS_THROUGH8_R(c,m1,m2,t1,t2,t3,t4,t5,t6,t7,t8) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7,t8 v8){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1,v2,v3,v4,v5,v6,v7,v8);}
    
    #define PASS_THROUGH_CAST_1_R(c,m1,m2,t1,tt1) STDMETHODIMP C##c##Object::m1(t1 v1) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1);}
    #define PASS_THROUGH_CAST_2_R(c,m1,m2,t1,tt1,t2,tt2) STDMETHODIMP C##c##Object::m1(t1 v1, t2 v2) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1, tt2 v2);}
    #define PASS_THROUGH_CAST_3_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3) STDMETHODIMP C##c##Object::m1(t1 v1, t2 v2,t3 v3) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3);}
    #define PASS_THROUGH_CAST_4_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1, tt2 v2,tt3 v3,tt4 v4);}
    #define PASS_THROUGH_CAST_5_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5);}
    #define PASS_THROUGH_CAST_6_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6);}
    #define PASS_THROUGH_CAST_7_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6,t7,tt7) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6,tt7 v7);}
    #define PASS_THROUGH_CAST_8_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6,t7,tt7,t8,tt8) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7,t8 v8){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6,tt7 v7,tt8 v8);}
    
    #define COPY_OR_CLEAR(dest, src, si) {if(src) memcpy((void *)dest, (void *)src, si);else memset((void *)dest, si, 0);}
    #define COPY(dest, src, si) memcpy((void *)dest, (void *)src, si)
    
    // ??
    #define DECLSET_OBJECT(ifacevar, var, typ) {if(var) var->Release();	var = (typ)ifacevar;}
    #define DECLGET_OBJECT(ifacevar, var){*ifacevar = (IUnknown *)var;}
    
    
    #define ISEQUAL(c) \
    	STDMETHODIMP C##c##Object::isEqual(I##c *d, int *retval)\
    					{	IUnknown *IU1;\
    						IUnknown *IU2;\
    						if (d == NULL)\
    							return E_FAIL;	\
    						this->InternalGetObject((IUnknown **)(&IU1)); \
    						d->InternalGetObject((IUnknown **)(&IU2)); \
    						if (IU1 == IU2) \
    							*retval = TRUE; \
    						else \
    							*retval = FALSE; \
    						return S_OK;}
    
    #define DX3J_GLOBAL_LINKS( obj_type ) \
    int creationid;\
    void *parent; \
    void *pinterface; \
    void *nextobj; 
    
    /*STDMETHOD(isEqual)(IUnknown *pobj, int *ret)*/; 
    
    // Given a class (c)
    #define GETSET_OBJECT(c) \
    	STDMETHODIMP C##c##Object::InternalSetObject(IUnknown *l)\
    					{DECLSET_OBJECT(l,m_##c,typedef_##c);return S_OK;} \
    	STDMETHODIMP C##c##Object::InternalGetObject(IUnknown **l)\
    					{DECLGET_OBJECT(l,m_##c);return S_OK;} 
    	//ISEQUAL(c);
    
    // Given a java interface, go get a pointer_to_a_pointer to a DIRECTX object
    //pac DO_GETOBJECT_NOTNULL is too dangerous and is commented.  use DO_GETOBJECT_NOTNULL
    //#define DO_GETOBJECT(t,v,i) t v;i->InternalGetObject((IUnknown **)(&v));
    #define DO_GETOBJECT_NOTNULL(t,v,i) t v=NULL;if(i) i->InternalGetObject((IUnknown **)(&v));
    
    
    //
    extern int g_creationcount;
    
    
    #ifdef _DEBUG
    
    #define CONSTRUCTOR(c, o) C##c##Object::C##c##Object(){ \
    	 m_##c = NULL; parent = NULL; pinterface = NULL; \
    	 nextobj =  g##c##;\
    	 creationid = ++g_creationcount;\
    	 char buffer[256];\
    	 wsprintf(buffer,"Constructor Creation Id [%d] %s",g_creationcount,__FILE__);\
    	 OutputDebugString(buffer);\
    	 g##c## = (void *)this; o }
    
    #else
    #define CONSTRUCTOR(c, o) C##c##Object::C##c##Object(){ \
         m_##c = NULL; parent = NULL; pinterface = NULL; \
         nextobj = (void*)g##c##; \
         creationid = ++g_creationcount; \
         g##c## = (void*)this; o}
    #endif
    
    #ifdef _DEBUG
    
    #define DESTRUCTOR(c, o) C##c##Object::~C##c##Object(){o; \
    	char buffer[256]; \
    	wsprintf(buffer,"Destructor Id[%d] %s ",creationid,__FILE__); \
    	OutputDebugString(buffer); 	C##c##Object *prev=NULL; \
    	for(C##c##Object *ptr=(C##c##Object *)g##c##; ptr; ptr=(C##c##Object *)ptr->nextobj) \
    	{\
    		if(ptr == this) \
    		{ \
    			if(prev) \
    				prev->nextobj = ptr->nextobj; \
    			else \
    				g##c## = (void*)ptr->nextobj; \
    			break; \
    		} \
    		prev = ptr; \
    	} \
    	if(m_##c){ 	int count = IUNK(m_##c)->Release(); wsprintf(buffer,"DirectX %s Ref count [%d]",__FILE__,count); OutputDebugString(buffer); \
    		if(count==0){ char szOut[512];wsprintf(szOut,"\n Real %s released \n",__FILE__); OutputDebugString(szOut); m_##c = NULL; } \
    	} \
    	if(parent) IUNK(parent)->Release(); \
    }
    
    #else
    #define DESTRUCTOR(c, o) C##c##Object::~C##c##Object(){o; \
    	C##c##Object *prev=NULL; \
    	for(C##c##Object *ptr=(C##c##Object *)g##c##; ptr; ptr=(C##c##Object *)ptr->nextobj) \
    	{\
    		if(ptr == this) \
    		{ \
    			if(prev) \
    				prev->nextobj = ptr->nextobj; \
    			else \
    				g##c## = (void*)ptr->nextobj; \
    			break; \
    		} \
    		prev = ptr; \
    	} \
    	if(m_##c){ \
    		if (IUNK(m_##c)->Release()==0) m_##c = NULL; \
    	} \
    	if(parent) IUNK(parent)->Release();\
    }
    #endif 
    
    
    
    #define OBJCHECK(lable, c) { \
    	char buffer[256];\
    	if ( g##c ) \
    	{\
    		int count = 0; \
    		C##c##Object *prev=NULL; \
    		C##c##Object *ptr;\
    		for(ptr=(C##c##Object *)g##c##; ptr; ptr=(C##c##Object *)ptr->nextobj) \
    		{\
    			DWORD refcount = *(((DWORD*)ptr)+1);\
    			wsprintf( buffer,"%s: Ref Count [%d] CreateId [%d]\n\r",lable,refcount,ptr->creationid);\
    			OutputDebugString(buffer);\
    			count++;\
    		}\
    		wsprintf(buffer,"%s: %d \n\r",lable,count);\
    		OutputDebugString(buffer);\
    	}\
    }
    
    
    
    
    #ifdef _DEBUG
    #define CONSTRUCTOR_STRUCT(c, o) C##c##Object::C##c##Object(){  nextobj = g##c##;\
    	 creationid = ++g_creationcount;\
    	char buffer[256];\
    	wsprintf(buffer,"Creation Id [%d]",g_creationcount);\
    	OutputDebugString(buffer);\
    	 g##c## = (void*)this;o}
    #else
    #define CONSTRUCTOR_STRUCT(c, o) C##c##Object::C##c##Object(){ \
     nextobj =(void*) g##c##; \
     creationid = ++g_creationcount; \
     g##c## = (void*)this; \
     o}
    #endif
    
    
    
    
    #define DESTRUCTOR_STRUCT(c, o) C##c##Object::~C##c##Object(){o; \
    C##c##Object *prev=NULL; \
    for(C##c##Object *ptr=(C##c##Object *)g##c##; ptr; ptr=(C##c##Object *)ptr->nextobj) \
    {\
    	if(ptr == this) \
    	{ \
    		if(prev) \
    			prev->nextobj = ptr->nextobj; \
    		else \
    			g##c## = (void*)ptr->nextobj; \
    		break; \
    	} \
    	prev = ptr; \
    } \
    }
    
    
    // Given a java class (c), create a DIRECTX object and an interface ** ptr to it.
    #define RETURN_NEW_ITEM(c,m,oc) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_CAST(c,m,oc, ty) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(ty &lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_NOREL(c,m,oc) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(&lp) != S_OK)return E_FAIL;INTERNAL_CREATE_NOREL(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM1(c,m,oc,t1) STDMETHODIMP C##c##Object::m(t1 v1, I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(v1,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM2(c,m,oc,t1,t2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(v1,v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_CAST_1(c,m,oc,t1,tt1) STDMETHODIMP C##c##Object::m(t1 v1, I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(tt1 v1,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_CAST_2(c,m,oc,t1,tt1,t2,tt2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(tt1 v1,tt2 v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_CAST_3(c,m,oc,t1,tt1,t2,tt2,t3,tt3) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2, t3 v3, I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(tt1 v1,tt2 v2,tt3 v3,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    //mod:dp additions due to renaming 
    // Given a java class (c), create a DIRECTX object and an interface ** ptr to it.
    #define RETURN_NEW_ITEM_R(c,m,m2,oc) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m2(&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM1_R(c,m,m2,oc,t1) STDMETHODIMP C##c##Object::m(t1 v1, I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m2(v1,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM2_R(c,m,m2,oc,t1,t2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m2(v1,v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_CAST_R(c,m,m2,oc,ty) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m2(ty &lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_CAST_1_R(c,m,m2,oc,t1,tt1) STDMETHODIMP C##c##Object::m(t1 v1, I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m2(tt1 v1,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_CAST_2_R(c,m,m2,oc,t1,tt1,t2,tt2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m2(tt1 v1,tt2 v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #if 0 
    #define RETURN_NEW_ITEM_NOREL(c,m,oc) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(&lp) != S_OK)return E_FAIL;INTERNAL_CREATE_NOREL(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_CAST_3(c,m,oc,t1,tt1,t2,tt2,t3,tt3) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2, t3 v3, I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(tt1 v1,tt2 v2,tt3 v3,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    #endif
    
    // Return a primitive value by reference.
    #define GET_DIRECT(cl,met,t) STDMETHODIMP C##cl##Object::met(t *h){*h=(t)m_##cl->met();return S_OK;}
    #define GET_DIRECT1(cl,met,t,t1) STDMETHODIMP C##cl##Object::met(t1 v1,t *h){*h=(t)m_##cl->met(v1);return S_OK;}
    #define GET_DIRECT2(cl,met,t,t1,t2) STDMETHODIMP C##cl##Object::met(t1 v1, t2 v2, t *h){*h=(t)m_##cl->met(v1,v2);return S_OK;}
    
    #define GET_DIRECT_R(cl,met,met2,t) STDMETHODIMP C##cl##Object::met(t *h){*h=(t)m_##cl->met2();return S_OK;}
    #define GET_DIRECT1_R(cl,met,met2,t,t1) STDMETHODIMP C##cl##Object::met(t1 v1,t *h){*h=(t)m_##cl->met2(v1);return S_OK;}
    #define GET_DIRECT2_R(cl,met,met2,t,t1,t2) STDMETHODIMP C##cl##Object::met(t1 v1, t2 v2, t *h){*h=(t)m_##cl->met2(v1,v2);return S_OK;}
    
    
    // Return a pointer to a primitive value as a ** ptr.
    #define GET_DIRECTPTR(cl,met,t) STDMETHODIMP C##cl##Object::met(t **h){*h=(struct t*)m_##cl->met();return S_OK;}
    #define GET_DIRECTPTR1(cl,met,t,t1) STDMETHODIMP C##cl##Object::met(t1 v1,t **h){*h=(struct t*)m_##cl->met(v1);return S_OK;}
    #define GET_DIRECTPTR2(cl,met,t,t1,t2) STDMETHODIMP C##cl##Object::met(t1 v1, t2 v2, t **h){*h=(struct t*)m_##cl->met(v1,v2);return S_OK;}
    
    //Do a DO_GETOBJECT_NOTNULL and then call a method on the object
    #define DO_GETOBJECT_ANDUSEIT(cl,me,iface) STDMETHODIMP C##cl##Object::me(I##iface *vis) \
    	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->me(lp); }
    
    #define DO_GETOBJECT_ANDUSEIT_CAST(cl,me,iface, t1) STDMETHODIMP C##cl##Object::me(I##iface *vis) \
    	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->me((t1)lp); }
    
    #define DO_GETOBJECT_ANDUSEIT1(cl,me,iface,t1) STDMETHODIMP C##cl##Object::me(t1 v1,I##iface *vis) \
    	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->me(v1, lp); }
    
    #define DO_GETOBJECT_ANDUSEIT2(cl,me,iface,t1,t2) STDMETHODIMP C##cl##Object::me(t1 v1,t2 v2,I##iface *vis) \
    	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->me(v1, v2, lp); }
    
    //mod:dp additions due to renaming 
    //Do a DO_GETOBJECT_NOTNULL and then call a method on the object
    #define DO_GETOBJECT_ANDUSEIT_R(cl,me, m2, iface) STDMETHODIMP C##cl##Object::me(I##iface *vis) \
    	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->m2(lp); }
    
    #define DO_GETOBJECT_ANDUSEIT_CAST_R(cl,me, m2, iface, t1) STDMETHODIMP C##cl##Object::me(I##iface *vis) \
    	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->m2((t1)lp); }
    
    #define DO_GETOBJECT_ANDUSEIT1_R(cl,me, m2, iface,t1) STDMETHODIMP C##cl##Object::me(t1 v1,I##iface *vis) \
    	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->m2(v1, lp); }
    
    #define DO_GETOBJECT_ANDUSEIT2_R(cl,me, m2, iface,t1,t2) STDMETHODIMP C##cl##Object::me(t1 v1,t2 v2,I##iface *vis) \
    	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->m2(v1, v2, lp); }
    
    
    // Make a copy of an object!
    //#define CLONE(cl) STDMETHODIMP C##cl##Object::Clone(Id3drmObject **retval){typedef_##cl lp;\
    //	m_##cl->Clone(0,IID_I##cl,(void **)&lp);INTERNAL_CREATE(cl,lp,retval);return S_OK;}
    
    //#define CLONE(cl) STDMETHODIMP C##cl##Object::Clone(I##cl **retval){typedef_##cl lp;\
    //m_##cl->Clone(0,IID_I##cl,(void **)&lp);INTERNAL_CREATE(cl, lp, retval);	return S_OK;}
    
    //#define CLONE_R(cl,c2) STDMETHODIMP C##cl##Object::clone(I##cl **retval){typedef_##cl lp;\
    //m_##cl->Clone(0,IID_I##c2,(void **)&lp);INTERNAL_CREATE(cl, lp, retval);	return S_OK;}
    
    
    #define CLONE_R(cl,c2) STDMETHODIMP C##cl##Object::clone(IUnknown **retval){typedef_##cl lp;\
    m_##cl->Clone(0,IID_I##c2,(void **)&lp);INTERNAL_CREATE(cl, lp, (I##cl **)retval);	return S_OK;}
    
    
    
    #define GETNAME(cl) STDMETHODIMP C##cl##Object::GetName(BSTR *n){return _GetName(m_##cl, n, TRUE);}
    #define GETCLASSNAME(cl) STDMETHODIMP C##cl##Object::GetClassName(BSTR *n){return _GetName(m_##cl, n, FALSE);}
    
    #define SETNAME(cl) STDMETHODIMP C##cl##Object::SetName(BSTR Name){	\
    	USES_CONVERSION;\
    	LPSTR str = NULL; \
		__try { str = W2T(Name); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; } return m_##cl->SetName( str );}
    
    #define GETNAME_R(cl) STDMETHODIMP C##cl##Object::getName(BSTR *n){return _GetName(m_##cl, n, TRUE);}
    #define GETCLASSNAME_R(cl) STDMETHODIMP C##cl##Object::getClassName(BSTR *n){return _GetName(m_##cl, n, FALSE);}
    
    #define SETNAME_R(cl) STDMETHODIMP C##cl##Object::setName(BSTR Name){	\
    	USES_CONVERSION;\
    	LPSTR str = NULL; \
		__try { str = W2T(Name); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; } return m_##cl->SetName( str );}
    
    #define CLONETO(clMe, cl, ifaceThat) STDMETHODIMP C##clMe##Object::Get##cl(I##cl **retval) \
    { typedef_##cl lp; if (m_##clMe->QueryInterface(ifaceThat, (void **) &lp) != S_OK) return S_FALSE; \
    	INTERNAL_CREATE( cl, lp, retval); return S_OK; }
    
    
    #define ISSAFEARRAY1D(ppsa,count) ((*ppsa) &&  ( ((SAFEARRAY*)*ppsa)->cDims==1) && (((SAFEARRAY*)*ppsa)->rgsabound[0].cElements >= count))
    
    /**********************************************************************************************/
    extern "C" BOOL ParseWaveResource(void *pvRes, WAVEFORMATEX **ppWaveHeader,	BYTE **ppbWaveData, DWORD *pcbWaveSize);
    extern "C" BOOL GetWaveResource(HMODULE hModule, LPCTSTR lpName,
    			 WAVEFORMATEX **ppWaveHeader, BYTE **ppbWaveData, DWORD *pcbWaveSize);
    
    extern "C" DWORD bppToddbd(int bpp);
    
    
    extern "C" void PassBackUnicode(LPSTR str, BSTR *Name, DWORD cnt);
    extern "C" void ctojDSBufferDesc( LPDSBUFFERDESC lpdd,
    					DSBUFFERDESC_CDESC *ddsb, WAVEFORMATEX_CDESC *wave);
    extern "C" void jtocDSBufferDesc( LPDSBUFFERDESC lpdd, DSBUFFERDESC_CDESC *ddsb, WAVEFORMATEX_CDESC *wave);
    extern "C" void ctojWaveFormatEx( LPWAVEFORMATEX lpdd, WAVEFORMATEX_CDESC *wave);
    extern "C" void CopyFloats(D3DVALUE *mat1, D3DVALUE *mat2, DWORD count);
    

    
    extern "C" BOOL PASCAL myEnumSoundDriversCallback(GUID &SPGuid, LPSTR description, 
    													LPSTR module, void *lpArg);
    
    extern "C" BOOL CALLBACK myEnumDeviceObjectsCallback(  LPCDIDEVICEOBJECTINSTANCE pI,    LPVOID lpArg ) ;
    extern "C" BOOL CALLBACK myEnumCreatedEffectObjectsCallback(LPDIRECTINPUTEFFECT peff,    LPVOID lpArg );
    extern "C" BOOL CALLBACK myEnumEffectsCallback(  LPCDIEFFECTINFO pdei,    LPVOID lpArg   );
    extern "C" BOOL CALLBACK myEnumInputDevicesCallback(  LPDIDEVICEINSTANCE lpddi,    LPVOID pvRef   );
    
    //////////////////////////////////////////////////////////////////////////
    
    
    
    
    /*
     **********************************************************************
     * INTERNAL_CREATE(thisClass, var, retval)
     *		thisClass	class we are working on
     *		var			variable created in routine to get DirectX object
     *		retval		return value back to java
     *
     * wrap a DirectX object in one of ours and shove it in the return value
     ***********************************************************************
     * INTERNAL_CREATE_NOREL(thisClass, var, retval)
     *		thisClass	class we are working on
     *		var			variable created in routine to get DirectX object
     *		retval		return value back to java
     *
     * wrap a DirectX object in one of ours and shove it in the return value
     * If the layer obejct fails, DONT release the DirectX object
     ***********************************************************************
     * DO_GETOBJECT_NOTNULL(type,var,iface)
     *		type		type of variable we are creating
     *		var			variable we are creating
     *		iface		layer iface where we are getting the object from
     *
     * declare and get a DirectX object from a layer object
     ***********************************************************************
     * DO_GETOBJECT_NOTNULL(type,var,iface)
     *		type		type of variable we are creating
     *		var			variable we are creating
     *		iface		layer iface where we are getting the object from
     *
     * same as DO_GETOBJECT_NOTNULL except that we check for iface==NULL before calling
     ***********************************************************************
     * PASS_THROUGH[x](class,method,[...])
     *		class		this class
     *		method		method to call
     *
     * pass call straight through
     ***********************************************************************
     * PASS_THROUGH_CAST_[x](class,method,[...])
     *		class		this class
     *		method		method to call
     *
     * pass call straight through, casting the parameters to allow the call to pass
     ***********************************************************************
     * RETURN_NEW_ITEM(thisClass,method,OtherClass)
     *		thisClass	class being worked on
     *		method		method working on
     *		otherClass	class whose object we want
     *
     * call DirectX method to get the DirectX object, then wrap it in one of our layer
     * objects
     ***********************************************************************
     * RETURN_NEW_ITEM[1,2](thisClass,method,OtherClass,type)
     *		thisClass	class being worked on
     *		method		method working on
     *		otherClass	class whose object we want
     *		type		type of parameter
     *
     * Same as RETURN_NEWITEM except that there is an extra parameter (or two) BEFORE the
     * returned one
     ***********************************************************************
     * RETURN_NEW_ITEM_CAST_[1,2](thisClass,method,OtherClass,type)
     *		thisClass	class being worked on
     *		method		method working on
     *		otherClass	class whose object we want
     *		type		type of parameter
     *
     * Same as RETURN_NEW_ITEM[1,2] except that there the extra parameter(s) are type cast
     ******************************************************************************
     * RETURN_NEW_ITEM_NOREL(thisClass,method,OtherClass)
     *		thisClass	class being worked on
     *		method		method working on
     *		otherClass	class whose object we want
     *
     * same as RETURN_NEW_ITEM except that calls INTERNAL_CREATE_NOTREL instead of
     * INTERNAL_CREATE
     ******************************************************************************
     * GET_DIRECT(cl,met,t)
     *		class		class being worked on
     *		method		method being worked on
     *		t			type of the variable being returned
     *
     * DirectX returns value directly (no HRESULT), we get the value from Direct and
     * then return S_OK. (see CddSurfaceObject::Restore, may need to be added).
     * Note: the value is passed back via a pointer to that value.
     ******************************************************************************
     * GET_DIRECT[1,2](cl,met,t,t1)
     *		class		class being worked on
     *		method		method being worked on
     *		t			type of the variable being returned
     *      t1			type of extra variable(s) BEFORE retval
     *
     * same as GET_DIRECT but there is another parameter (or two) BEFORE the returned one
     ****************************************************************************************
     * GET_DIRECTPTR(cl,met,t)
     *		class		class being worked on
     *		method		method being worked on
     *		t			type of the variable being returned
     *
     * DirectX returns a pointer to a value directly (no HRESULT), we get the value from
     * Direct and then return S_OK. In this case it is a pointer to a pointer.
     ***************************************************************************************
     * GET_DIRECTPTR[1,2](cl,met,t,t1)
     *		class		class being worked on
     *		method		method being worked on
     *		t			type of the variable being returned
     *      t1			type of extra variable(s) BEFORE retval
     *
     * same as GET_DIRECTPTR but there is a parameter (or two) BEFORE the one returned.
     ***************************************************************************************
     * DO_GETOBJECT_ANDUSEIT(cl,me,iface)
     *		class		class being worked on
     *		method		method being worked on
     *		iface		secondary interface we are interested in
     *
     * get an internal object from iface and use it in the method. we return from the method
     ***************************************************************************************
     * DO_GETOBJECT_ANDUSEIT_CAST(cl,me,iface,type)
     *		class		class being worked on
     *		method		method being worked on
     *		iface		secondary interface we are interested in
     *		type		type to cast to in the actual call.
     * get an internal object from iface and use it in the method. we return from the method
     ***************************************************************************************
     * DO_GETOBJECT_ANDUSEIT[1,2](cl,me,iface,ty)
     *		class		class being worked on
     *		method		method being worked on
     *		iface		secondary interface we are interested in
     *		type		type of parameter BEFORE 2nd object
     *
     * same as DO_GETOBJECT_ANDUSEIT except there is another parameter (or two) BEFORE
     * the object one
     ************************************************************************************
     * CLONE(cl)
     *		class		class to clone
     *
     * >>>>>>> THIS IS A D3DRMOBJECT METHOD <<<<<<<<<<
     ************************************************************************************
     * GETNAME(cl)
     *		class		class to retive name of
     * >>>>>>> THIS IS A D3DRMOBJECT METHOD <<<<<<<<<<
     ************************************************************************************
     * GETCLASSNAME(cl)
     *		class		class to retive name of
     * >>>>>>> THIS IS A D3DRMOBJECT METHOD <<<<<<<<<<
     ************************************************************************************
     * DELETEDESTROYCALLBACK(cl)
     *		class		class to retive name of
     * >>>>>>> THIS IS A D3DRMOBJECT METHOD <<<<<<<<<<
     ************************************************************************************
     * QIOVERLOAD(cl, ifaceThat, clThat)
     *		class		class being worked on
     *		iface		iface of DIRECT object.  Should really typedef_## this!
     *		clThat		object we are going to create
     *
     * this is really bright - overloading QI to get new objects
     ************************************************************************************
     * CLONETO(cl, clThat, ifaceThat)
     *		class		class being worked on
     *		iface		iface of DIRECT object.  Should really typedef_## this!
     *		clThat		object we are going to create
     *
     * this is really bright - overloading QI to get new objects
     ************************************************************************************
     */
    
    
    extern void *g_dxj_DirectSound3dListener;
    extern void *g_dxj_DirectSoundBuffer;
    extern void *g_dxj_DirectSound3dBuffer;
    extern void *g_dxj_DirectSound;
    extern void *g_dxj_DirectSoundCapture;
    extern void *g_dxj_DirectSoundCaptureBuffer;
    extern void *g_dxj_DirectSoundNotify;

    extern void *g_dxj_DirectInput8;
    extern void *g_dxj_DirectInputDevice8;
    extern void *g_dxj_DirectInputEffect;
    
    extern void *g_dxj_DirectPlayVoiceClient;
    extern void *g_dxj_DirectPlayVoiceServer;
    extern void *g_dxj_DirectPlayVoiceSetup;
    
    #define DXHEAPALLOC malloc
    #define DXSTACKALLOC lalloc
    #define DXHEAPFREE free
    #define DXALLOCBSTR SysAllocString

    #define Byte unsigned char
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmsegmentobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmsegmentobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicSegmentObject
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicSegment IDirectMusicSegment8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicSegmentObject : 
	public I_dxj_DirectMusicSegment,
	//public CComCoClass<C_dxj_DirectMusicSegmentObject, &CLSID__dxj_DirectMusicSegment>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicSegmentObject();
	virtual ~C_dxj_DirectMusicSegmentObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicSegmentObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicSegment)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicSegment,		"DIRECT.DirectMusicSegment.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicSegmentObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

        HRESULT STDMETHODCALLTYPE clone( 
            /* [in] */ long mtStart,
            /* [in] */ long mtEnd,
            /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ppSegment);
        
        HRESULT STDMETHODCALLTYPE setStartPoint( 
            /* [in] */ long mtStart);
        
        HRESULT STDMETHODCALLTYPE getStartPoint( 
            /* [retval][out] */ long __RPC_FAR *pmtStart);
        
        HRESULT STDMETHODCALLTYPE setLoopPoints( 
            /* [in] */ long mtStart,
            /* [in] */ long mtEnd);
        
        HRESULT STDMETHODCALLTYPE getLoopPointStart( 
            /* [retval][out] */ long __RPC_FAR *pmtStart);
        
        HRESULT STDMETHODCALLTYPE getLoopPointEnd( 
            /* [retval][out] */ long __RPC_FAR *pmtEnd);
        
        HRESULT STDMETHODCALLTYPE getLength( 
            /* [retval][out] */ long __RPC_FAR *pmtLength);
        
        HRESULT STDMETHODCALLTYPE setLength( 
            /* [in] */ long mtLength);
        
        HRESULT STDMETHODCALLTYPE getRepeats( 
            /* [retval][out] */ long __RPC_FAR *lRepeats);
        
        HRESULT STDMETHODCALLTYPE setRepeats( 
            /* [in] */ long lRepeats);
        
        
        HRESULT STDMETHODCALLTYPE download( 
            /* [in] */ IUnknown __RPC_FAR *downloadpath);
        
        HRESULT STDMETHODCALLTYPE unload( 
            /* [in] */ IUnknown __RPC_FAR *downloadpath);
        
        
        HRESULT STDMETHODCALLTYPE setAutoDownloadEnable( 
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE setTempoEnable( 
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE setTimeSigEnable( 
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE setStandardMidiFile();
        
        HRESULT STDMETHODCALLTYPE connectToCollection( 
            /* [in] */ I_dxj_DirectMusicCollection __RPC_FAR *c);
	
        HRESULT STDMETHODCALLTYPE GetAudioPathConfig(IUnknown **ret);

		HRESULT STDMETHODCALLTYPE getStyle( 
        /* [in] */ long lTrack,
        /* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getChordMap( 
        /* [in] */ long lTrack,
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);

    HRESULT STDMETHODCALLTYPE GetName(BSTR *ret);		
	////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicSegment);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicSegment)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmsegmentstateobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmsegmentstateobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicSegmentStateObject
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicSegmentState IDirectMusicSegmentState8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicSegmentStateObject : 
	public I_dxj_DirectMusicSegmentState,
	//public CComCoClass<C_dxj_DirectMusicSegmentStateObject, &CLSID__dxj_DirectMusicSegmentState>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicSegmentStateObject();
	virtual ~C_dxj_DirectMusicSegmentStateObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicSegmentStateObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicSegmentState)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicSegmentState,		"DIRECT.DirectMusicSegmentState.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicSegmentStateObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	HRESULT STDMETHODCALLTYPE getRepeats( 
		/* [retval][out] */ long __RPC_FAR *repeats);

	HRESULT STDMETHODCALLTYPE getSeek( 
		/* [retval][out] */ long __RPC_FAR *seek);

	HRESULT STDMETHODCALLTYPE getStartPoint( 
		/* [retval][out] */ long __RPC_FAR *seek);

	HRESULT STDMETHODCALLTYPE getStartTime( 
		/* [retval][out] */ long __RPC_FAR *seek);

	HRESULT STDMETHODCALLTYPE getSegment( 
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *segment);

	
////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicSegmentState);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicSegmentState)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmsegmentstateobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmsegmentstateobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmSegmentStateObj.h"
#include "dmSegmentObj.h"

extern void *g_dxj_DirectMusicSegmentState;
extern void *g_dxj_DirectMusicSegment;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicSegmentState, {});
DESTRUCTOR(_dxj_DirectMusicSegmentState, {});
GETSET_OBJECT(_dxj_DirectMusicSegmentState);


HRESULT C_dxj_DirectMusicSegmentStateObject::getRepeats( long __RPC_FAR *repeats)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegmentState->GetRepeats((DWORD*)repeats);
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentStateObject::getSeek( long __RPC_FAR *seek)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegmentState->GetSeek(seek);
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentStateObject::getStartPoint( long __RPC_FAR *t)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegmentState->GetStartPoint(t);
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentStateObject::getStartTime( long __RPC_FAR *t)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegmentState->GetStartTime(t);
	return hr;
}




HRESULT CREATE_DMSEGMENT_NOADDREF(IDirectMusicSegment8 *pSeg,I_dxj_DirectMusicSegment **segment) 
{
	C_dxj_DirectMusicSegmentObject *prev=NULL;
	*segment = NULL; 
	for(	
		C_dxj_DirectMusicSegmentObject 
			*ptr=(C_dxj_DirectMusicSegmentObject *)g_dxj_DirectMusicSegment;
			ptr;
			ptr=(C_dxj_DirectMusicSegmentObject *)ptr->nextobj
		)
	{
		IUnknown *unk=0;
		ptr->InternalGetObject(&unk); 
		if(unk == pSeg) 
		{ 
			*segment = (I_dxj_DirectMusicSegment*)ptr->pinterface;
			IUNK(ptr->pinterface)->AddRef();
			break;
		}
		prev = ptr;
	} 
	if(!ptr) 
	{
		C_dxj_DirectMusicSegmentObject *c=new CComObject<C_dxj_DirectMusicSegmentObject>;
		if( c == NULL ) 
		{
			pSeg->Release();
			return E_FAIL;
		}
		c->InternalSetObject(pSeg);  
		if FAILED(((I_dxj_DirectMusicSegment *)c)->QueryInterface(IID_I_dxj_DirectMusicSegment, (void **)segment)) 
		{
			return E_FAIL; 
		}
		if (!(*segment)) return E_FAIL;

		c->pinterface = (void*)*segment;
	}	
	return S_OK;
}



HRESULT C_dxj_DirectMusicSegmentStateObject::getSegment( 		
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *segment)
{
	HRESULT hr;	
	IDirectMusicSegment8 *pSeg=NULL;
	if(!segment) return E_INVALIDARG;

	hr=m__dxj_DirectMusicSegmentState->GetSegment((IDirectMusicSegment**)&pSeg);
	if FAILED(hr) return hr;	
	
		
	//INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pSeg,segment);
	hr= CREATE_DMSEGMENT_NOADDREF(pSeg,segment);
	if FAILED(hr) return hr;

	if (*segment==NULL) return E_OUTOFMEMORY;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmstyleobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmstyleobj.h
//
//--------------------------------------------------------------------------

//: Declaration of the C_dxj_DirectMusicStyleObject
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicStyle IDirectMusicStyle8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicStyleObject : 
	public I_dxj_DirectMusicStyle,
	//public CComCoClass<C_dxj_DirectMusicStyleObject, &CLSID__dxj_DirectMusicStyle>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicStyleObject();
	virtual ~C_dxj_DirectMusicStyleObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicStyleObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicStyle)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicStyle,		"DIRECT.DirectMusicStyle.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicStyleObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

  
          
    HRESULT STDMETHODCALLTYPE getBandName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name);
    
    HRESULT STDMETHODCALLTYPE getBandCount( 
        /* [retval][out] */ long __RPC_FAR *count);
    
    HRESULT STDMETHODCALLTYPE getBand( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getDefaultBand( 
        /* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getMotifName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name);
    
    HRESULT STDMETHODCALLTYPE getMotifCount( 
        /* [retval][out] */ long __RPC_FAR *count);
    
    HRESULT STDMETHODCALLTYPE getMotif( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getChordMapName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name);
    
    HRESULT STDMETHODCALLTYPE getChordMapCount( 
        /* [retval][out] */ long __RPC_FAR *count);
    
    HRESULT STDMETHODCALLTYPE getChordMap( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getDefaultChordMap( 
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getEmbellishmentMinLength( 
        /* [in] */ long type,
        /* [in] */ long level,
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getEmbellishmentMaxLength( 
        /* [in] */ long type,
        /* [in] */ long level,
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getTimeSignature( 
        /* [out][in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *pTimeSig);
    
    HRESULT STDMETHODCALLTYPE getTempo( 
        /* [retval][out] */ double __RPC_FAR *pTempo);
  

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicStyle);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicStyle)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmusaudiopathobj.h ===
#include "resource.h"       // main symbols
#include "dmusici.h"

#define typedef__dxj_DirectMusicAudioPath IDirectMusicAudioPath8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicAudioPathObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectMusicAudioPath, &IID_I_dxj_DirectMusicAudioPath, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectMusicAudioPath,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectMusicAudioPathObject() ;
	virtual ~C_dxj_DirectMusicAudioPathObject() ;

BEGIN_COM_MAP(C_dxj_DirectMusicAudioPathObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectMusicAudioPath)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectMusicAudioPathObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectMusicAudioPath
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

	HRESULT STDMETHODCALLTYPE GetObjectInPath(long lPChannel, long lStage, long lBuffer, BSTR guidObject, long lIndex, BSTR iidInterface, IUnknown **ppObject);
	HRESULT STDMETHODCALLTYPE Activate(VARIANT_BOOL fActive);
	HRESULT STDMETHODCALLTYPE SetVolume(long lVolume, long lDuration);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectMusicAudioPath);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectMusicAudioPath);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmusaudiopathobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dMusAudioPathObj.h"					   
#include "dsound3dbuffer.h"
#include "dsoundbufferobj.h"
#include "dsoundprimarybufferobj.h"
#include "dsound3dlistener.h"
#include "dsoundFXGargleobj.h"
#include "dsoundFXEchoobj.h"
#include "dsoundFXChorusobj.h"
#include "dsoundFXCompressorobj.h"
#include "dsoundFXDistortionobj.h"
#include "dsoundFXFlangerobj.h"
#include "dsoundfxi3dl2reverbobj.h"
#if 0
#include "dsoundfxi3dl2sourceobj.h"
#include "dsoundfxsendobj.h"
#endif
#include "dsoundfxparameqobj.h"
#include "dsoundfxwavesreverbobj.h"

extern void *g_dxj_DirectSoundFXWavesReverb;
extern void *g_dxj_DirectSoundFXCompressor;
extern void *g_dxj_DirectSoundFXChorus;
extern void *g_dxj_DirectSoundFXGargle;
extern void *g_dxj_DirectSoundFXEcho;
extern void *g_dxj_DirectSoundFXSend;
extern void *g_dxj_DirectSoundFXDistortion;
extern void *g_dxj_DirectSoundFXFlanger;
extern void *g_dxj_DirectSoundFXParamEQ;
extern void *g_dxj_DirectSoundFXI3DL2Reverb;
#if 0
extern void *g_dxj_DirectSoundFXI3DL2Source;
#endif

extern HRESULT AudioBSTRtoGUID(LPGUID,BSTR);
extern void *g_dxj_DirectMusicAudioPath;
extern void *g_dxj_DirectSoundPrimaryBuffer;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicAudioPathObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectMusicAudioPath [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicAudioPathObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectMusicAudioPath [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectMusicAudioPathObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicAudioPathObject::C_dxj_DirectMusicAudioPathObject(){ 
		
	DPF1(1,"Constructor Creation  DirectMusicAudioPath Object[%d] \n ",g_creationcount);

	m__dxj_DirectMusicAudioPath = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectMusicAudioPath;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectMusicAudioPath = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectMusicAudioPathObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicAudioPathObject::~C_dxj_DirectMusicAudioPathObject()
{

	DPF(1,"Entering ~C_dxj_DirectMusicAudioPathObject destructor \n");

     C_dxj_DirectMusicAudioPathObject *prev=NULL; 
	for(C_dxj_DirectMusicAudioPathObject *ptr=(C_dxj_DirectMusicAudioPathObject *)g_dxj_DirectMusicAudioPath ; ptr; ptr=(C_dxj_DirectMusicAudioPathObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectMusicAudioPath = (void*)ptr->nextobj; 
			
			DPF(1,"DirectMusicAudioPathObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectMusicAudioPath){
		int count = IUNK(m__dxj_DirectMusicAudioPath)->Release();
		
		#ifdef DEBUG
		char AudioPath[256];
		wsprintf(AudioPath,"DirectX IDirectMusicAudioPath Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectMusicAudioPath = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectMusicAudioPathObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectMusicAudioPath;
	
	return S_OK;
}
HRESULT C_dxj_DirectMusicAudioPathObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectMusicAudioPath=(IDirectMusicAudioPath8*)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectMusicAudioPathObject::GetObjectInPath(long lPChannel, long lStage, long lBuffer, BSTR guidObject, long lIndex, BSTR iidInterface, IUnknown **ppObject)
{
	HRESULT hr;
	GUID guidObj;
	GUID guidIID;

	__try {
		if (FAILED (hr = AudioBSTRtoGUID(&guidObj, guidObject) ) )
			return hr;

		if (FAILED (hr = AudioBSTRtoGUID(&guidIID, iidInterface ) ) )
			return hr;


		if( 0==_wcsicmp(iidInterface,L"iid_idirectsound3dbuffer")){
			IDirectSound3DBuffer	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSound3dBuffer, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(iidInterface,L"iid_idirectsoundbuffer8")){
			IDirectSoundBuffer8	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundBuffer, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(iidInterface,L"iid_idirectsoundbuffer")){
			IDirectSoundBuffer	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundPrimaryBuffer, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(iidInterface,L"iid_idirectsound3dlistener")){
			IDirectSound3DListener	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSound3dListener, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_gargle")){
			IDirectSoundFXGargle	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXGargle, lpRetObj, ppObject);
		}
#if 0
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_send")){
			IDirectSoundFXSend	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXSend, lpRetObj, ppObject);
		}
#endif
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_echo")){
			IDirectSoundFXEcho	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXEcho, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_chorus")){
			IDirectSoundFXChorus	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXChorus, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_compressor")){
			IDirectSoundFXCompressor	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXCompressor, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_distortion")){
			IDirectSoundFXDistortion	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXDistortion, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_flanger")){
			IDirectSoundFXFlanger	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXFlanger, lpRetObj, ppObject);
		}
#if 0
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_i3dl2source")){
			IDirectSoundFXI3DL2Source	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXI3DL2Source, lpRetObj, ppObject);
		}
#endif
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_i3dl2reverb")){
			IDirectSoundFXI3DL2Reverb	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXI3DL2Reverb, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_parameq")){
			IDirectSoundFXParamEq	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXParamEQ, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_waves_reverb")){
			IDirectSoundFXWavesReverb	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXWavesReverb, lpRetObj, ppObject);
		}
		else
			return E_INVALIDARG;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
HRESULT C_dxj_DirectMusicAudioPathObject::Activate(VARIANT_BOOL fActive)
{
	HRESULT hr;

	__try {
		if (FAILED (hr = m__dxj_DirectMusicAudioPath->Activate((BOOL) fActive) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectMusicAudioPathObject::SetVolume(long lVolume, long lDuration)
{
	HRESULT hr;

	__try {
		if (FAILED (hr = m__dxj_DirectMusicAudioPath->SetVolume(lVolume, (DWORD) lDuration) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmsegmentobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmsegmentobj.cpp
//
//--------------------------------------------------------------------------

// dmSegmentObj.cpp

#include "stdafx.h"
#include "Direct.h"
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "dms.h"
#include "dmSegmentObj.h"
#include "dmStyleObj.h"
#include "dmChordMapObj.h"

extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicStyle;
extern void *g_dxj_DirectMusicChordMap;

//CONSTRUCTOR(_dxj_DirectMusicSegment, {});

C_dxj_DirectMusicSegmentObject::C_dxj_DirectMusicSegmentObject()
{ 
     m__dxj_DirectMusicSegment = NULL;
	 parent = NULL; 
	 pinterface = NULL; 
     nextobj = (void*)g_dxj_DirectMusicSegment; 
     creationid = ++g_creationcount; 
     g_dxj_DirectMusicSegment = (void*)this; 

}

DESTRUCTOR(_dxj_DirectMusicSegment, {});
GETSET_OBJECT(_dxj_DirectMusicSegment);


HRESULT C_dxj_DirectMusicSegmentObject::clone( 
        /* [in] */ long mtStart,
        /* [in] */ long mtEnd,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ppSegment)
{
	HRESULT hr;	
	IDirectMusicSegment *pOut=NULL;    
	IDirectMusicSegment8 *pReal=NULL;    
	__try {

		if (FAILED (hr=m__dxj_DirectMusicSegment->Clone((MUSIC_TIME)mtStart,(MUSIC_TIME)mtEnd,&pOut) ) )
			return hr;

		if (!pOut)return E_OUTOFMEMORY;

		hr = pOut->QueryInterface(IID_IDirectMusicSegment8, (void**) &pReal);
		pOut->Release();
		if FAILED(hr) return hr;

		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pReal,ppSegment);
		if (!*ppSegment)return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;

}


HRESULT C_dxj_DirectMusicSegmentObject::setStartPoint(   /* [in] */ long mtStart)
{
	HRESULT hr;		

	__try {
		hr=m__dxj_DirectMusicSegment->SetStartPoint((MUSIC_TIME)mtStart);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}


HRESULT C_dxj_DirectMusicSegmentObject::getStartPoint(   /* [in] */ long *mtStart)
{
	HRESULT hr;			

	__try {
		hr=m__dxj_DirectMusicSegment->GetStartPoint((MUSIC_TIME*)mtStart);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::setLoopPoints(   /* [in] */ long mtStart,   /* [in] */ long mtEnd)
{
	HRESULT hr;		
	
	__try {
		hr=m__dxj_DirectMusicSegment->SetLoopPoints((MUSIC_TIME)mtStart,(MUSIC_TIME)mtEnd);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getLoopPointStart(   long *mtOut)
{
	HRESULT hr;		
	MUSIC_TIME mtStart =0;
	MUSIC_TIME mtEnd =0;	

	__try {
		hr=m__dxj_DirectMusicSegment->GetLoopPoints((MUSIC_TIME*)&mtStart,(MUSIC_TIME*)&mtEnd);
		*mtOut=(long)mtStart;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getLoopPointEnd(   long *mtOut)
{
	HRESULT hr;		
	MUSIC_TIME mtStart =0;
	MUSIC_TIME mtEnd =0;	

	__try {
		hr=m__dxj_DirectMusicSegment->GetLoopPoints((MUSIC_TIME*)&mtStart,(MUSIC_TIME*)&mtEnd);
		*mtOut=(long)mtEnd;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::setLength(   /* [in] */ long mtLength)
{
	HRESULT hr;			

	__try {
		hr=m__dxj_DirectMusicSegment->SetLength((MUSIC_TIME)mtLength);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getLength(   /* [in] */ long *mtLength)
{
	HRESULT hr;			

	__try {
		hr=m__dxj_DirectMusicSegment->GetLength((MUSIC_TIME*)mtLength);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}
   


HRESULT C_dxj_DirectMusicSegmentObject::setRepeats(   /* [in] */ long lrep)
{
	HRESULT hr;			
	
	__try {
		hr=m__dxj_DirectMusicSegment->SetRepeats((DWORD)lrep);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getRepeats(   /* [in] */ long *lrep)
{
	HRESULT hr;			

	__try {
		hr=m__dxj_DirectMusicSegment->GetRepeats((DWORD*)lrep);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}
     

HRESULT C_dxj_DirectMusicSegmentObject::download( 
        /* [in] */ IUnknown __RPC_FAR *downloadpath)
{
	if (!downloadpath) return E_INVALIDARG;	
	HRESULT hr;	
	
	__try {
		I_dxj_DirectMusicSegment	*lpSeg = NULL;
		I_dxj_DirectMusicAudioPath	*lpPath = NULL;

		hr = downloadpath->QueryInterface(IID_I_dxj_DirectMusicPerformance, (void**)&lpSeg);
		if (SUCCEEDED(hr) )
		{
			DO_GETOBJECT_NOTNULL(IDirectMusicPerformance8*,pPer,lpSeg);
			hr=m__dxj_DirectMusicSegment->Download(pPer);
			return hr;
		}
		else
		{
			hr = downloadpath->QueryInterface(IID_I_dxj_DirectMusicAudioPath, (void**)&lpPath);
			if (SUCCEEDED(hr) )
			{
				DO_GETOBJECT_NOTNULL(IDirectMusicAudioPath*,pPer,lpPath);
				hr=m__dxj_DirectMusicSegment->Download(pPer);
				return hr;
			}
			else
				return E_INVALIDARG;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectMusicSegmentObject::unload(         
        /* [in] */ IUnknown __RPC_FAR *downloadpath)
{
	if (!downloadpath) return E_INVALIDARG;	
	HRESULT hr;	
	I_dxj_DirectMusicSegment	*lpSeg = NULL;
	I_dxj_DirectMusicAudioPath	*lpPath = NULL;

	__try {
		hr = downloadpath->QueryInterface(IID_I_dxj_DirectMusicPerformance, (void**)&lpSeg);
		if (SUCCEEDED(hr) )
		{
			DO_GETOBJECT_NOTNULL(IDirectMusicPerformance8*,pPer,lpSeg);
			hr=m__dxj_DirectMusicSegment->Unload(pPer);
			return hr;
		}
		else
		{
			hr = downloadpath->QueryInterface(IID_I_dxj_DirectMusicAudioPath, (void**)&lpPath);
			if (SUCCEEDED(hr) )
			{
				DO_GETOBJECT_NOTNULL(IDirectMusicAudioPath*,pPer,lpPath);
				hr=m__dxj_DirectMusicSegment->Unload(pPer);
				return hr;
			}
			else
				return E_INVALIDARG;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}



HRESULT C_dxj_DirectMusicSegmentObject::setAutoDownloadEnable(         
        /* [retval][out] */ VARIANT_BOOL b)
{
	HRESULT hr;	
	
	__try {
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicSegment->SetParam(GUID_Disable_Auto_Download,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicSegment->SetParam(GUID_Enable_Auto_Download,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,NULL);	
		}		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

     
HRESULT C_dxj_DirectMusicSegmentObject::setTempoEnable( 
        /* [retval][out] */ VARIANT_BOOL b)
{
	HRESULT hr;	
	DWORD trackIndex=0;

	__try {
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicSegment->SetParam(GUID_DisableTempo,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicSegment->SetParam(GUID_EnableTempo,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::setTimeSigEnable(         
        /* [retval][out] */ VARIANT_BOOL b)
{
	HRESULT hr;	
	DWORD trackIndex=0;

	__try {
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicSegment->SetParam(GUID_DisableTimeSig,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicSegment->SetParam(GUID_EnableTimeSig,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::setStandardMidiFile()
{
	HRESULT hr;	

	__try {
		hr=m__dxj_DirectMusicSegment->SetParam(GUID_StandardMIDIFile,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,NULL);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}
     

HRESULT C_dxj_DirectMusicSegmentObject:: connectToCollection( 
            /* [in] */ I_dxj_DirectMusicCollection __RPC_FAR *c)
{
	HRESULT hr;		

	__try {
		DO_GETOBJECT_NOTNULL(IDirectMusicCollection8*,pCol,c);
		hr=m__dxj_DirectMusicSegment->SetParam(GUID_ConnectToDLSCollection,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,(void*)pCol);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}
        

HRESULT C_dxj_DirectMusicSegmentObject:: GetAudioPathConfig(IUnknown **ret)
{
	HRESULT hr;

	__try {
		if (FAILED(hr = m__dxj_DirectMusicSegment->GetAudioPathConfig(ret) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectMusicSegmentObject::getStyle( 
		/* [in] */ long lTrack,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret)
{				
		HRESULT hr;	
		IDirectMusicStyle *pStyle=NULL;

	__try {
		if (!ret) return E_INVALIDARG;
		*ret=NULL;
		
		hr=m__dxj_DirectMusicSegment->GetParam( GUID_IDirectMusicStyle, 0xffffffff, (DWORD)lTrack, 
                                 0, NULL, (VOID*)&pStyle );
		if FAILED(hr) return hr;
				
		
		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicStyle,pStyle,ret);
		if (*ret==NULL) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getChordMap( 
		/* [in] */ long lTrack,
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
		HRESULT hr;	
		IDirectMusicChordMap *pMap=NULL;

	__try {
		if (!ret) return E_INVALIDARG;
		*ret=NULL;
		
		hr=m__dxj_DirectMusicSegment->GetParam(GUID_IDirectMusicChordMap,0xFFFFFFFF,(DWORD)lTrack,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&pMap );	
		if FAILED(hr) return hr;
				
		
		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pMap,ret);
		if (*ret==NULL) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::GetName(BSTR *ret)
{
	HRESULT					hr;	
	IDirectMusicObject8		*pObj = NULL;
	DMUS_OBJECTDESC			objDesc;

	__try {
		*ret=NULL;
		
		hr=m__dxj_DirectMusicSegment->QueryInterface(IID_IDirectMusicObject8, (void**) &pObj);	
		if FAILED(hr) return hr;

		ZeroMemory(&objDesc, sizeof(DMUS_OBJECTDESC));
		objDesc.dwSize = sizeof(DMUS_OBJECTDESC);
		pObj->GetDescriptor(&objDesc);
		if ((objDesc.dwValidData & DMUS_OBJ_NAME) == DMUS_OBJ_NAME)
		{
			//Return this name
			*ret = SysAllocString(objDesc.wszName);
		}
		else if ((objDesc.dwValidData & DMUS_OBJ_FILENAME) == DMUS_OBJ_FILENAME)
		{
			//Return this filename
			*ret = SysAllocString(objDesc.wszFileName);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmusbufferobj.h ===
#include "resource.h"       // main symbols
#include "dmusicc.h"

#define typedef__dxj_DirectMusicBuffer LPDIRECTMUSICBUFFER8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicBufferObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectMusicBuffer, &IID_I_dxj_DirectMusicBuffer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectMusicBuffer,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectMusicBufferObject() ;
	virtual ~C_dxj_DirectMusicBufferObject() ;

BEGIN_COM_MAP(C_dxj_DirectMusicBufferObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectMusicBuffer)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectMusicBufferObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectMusicBuffer
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);


////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectMusicBuffer);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectMusicBuffer);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmusbufferobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dMusBufferObj.h"					   

extern void *g_dxj_DirectMusicBuffer;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicBufferObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectMusicBuffer [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicBufferObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectMusicBuffer [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectMusicBufferObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicBufferObject::C_dxj_DirectMusicBufferObject(){ 
		
	DPF1(1,"Constructor Creation  DirectMusicBuffer Object[%d] \n ",g_creationcount);

	m__dxj_DirectMusicBuffer = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectMusicBuffer;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectMusicBuffer = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectMusicBufferObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicBufferObject::~C_dxj_DirectMusicBufferObject()
{

	DPF(1,"Entering ~C_dxj_DirectMusicBufferObject destructor \n");

     C_dxj_DirectMusicBufferObject *prev=NULL; 
	for(C_dxj_DirectMusicBufferObject *ptr=(C_dxj_DirectMusicBufferObject *)g_dxj_DirectMusicBuffer ; ptr; ptr=(C_dxj_DirectMusicBufferObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectMusicBuffer = (void*)ptr->nextobj; 
			
			DPF(1,"DirectMusicBufferObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectMusicBuffer){
		int count = IUNK(m__dxj_DirectMusicBuffer)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectMusicBuffer Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectMusicBuffer = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectMusicBufferObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectMusicBuffer;
	
	return S_OK;
}
HRESULT C_dxj_DirectMusicBufferObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectMusicBuffer=(LPDIRECTMUSICBUFFER8)pUnk;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmusobj.h ===
#include "resource.h"       // main symbols
#include "dmusicc.h"

#define typedef__dxj_DirectMusic LPDIRECTMUSIC

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectMusic, &IID_I_dxj_DirectMusic, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectMusic,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectMusicObject() ;
	virtual ~C_dxj_DirectMusicObject() ;

BEGIN_COM_MAP(C_dxj_DirectMusicObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectMusic)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectMusicObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectMusic
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE Activate(VARIANT_BOOL fEnable);
		HRESULT STDMETHODCALLTYPE SetDirectSound(I_dxj_DirectSound *DirectSound,long hWnd);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectMusic);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectMusic);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmusobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dMusObj.h"					   

extern void *g_dxj_DirectMusic;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectMusic [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectMusic [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectMusicObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicObject::C_dxj_DirectMusicObject(){ 
		
	DPF1(1,"Constructor Creation  DirectMusic Object[%d] \n ",g_creationcount);

	m__dxj_DirectMusic = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectMusic;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectMusic = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectMusicObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicObject::~C_dxj_DirectMusicObject()
{

	DPF(1,"Entering ~C_dxj_DirectMusicObject destructor \n");

     C_dxj_DirectMusicObject *prev=NULL; 
	for(C_dxj_DirectMusicObject *ptr=(C_dxj_DirectMusicObject *)g_dxj_DirectMusic ; ptr; ptr=(C_dxj_DirectMusicObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectMusic = (void*)ptr->nextobj; 
			
			DPF(1,"DirectMusicObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectMusic){
		int count = IUNK(m__dxj_DirectMusic)->Release();
		
		#ifdef DEBUG
		char Buffer[256];
		wsprintf(Buffer,"DirectX IDirectMusic Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectMusic = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectMusicObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectMusic;
	
	return S_OK;
}
HRESULT C_dxj_DirectMusicObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectMusic=(LPDIRECTMUSIC)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectMusicObject::Activate(VARIANT_BOOL fEnable)
{
	HRESULT hr;
	
	if (fEnable == VARIANT_FALSE)
	{
		if (FAILED (hr = m__dxj_DirectMusic->Activate(FALSE) ) )
			return hr;
	} else
	{
		if (FAILED (hr = m__dxj_DirectMusic->Activate(TRUE) ) )
			return hr;
	}
	return S_OK;
}

HRESULT C_dxj_DirectMusicObject::SetDirectSound(I_dxj_DirectSound *DirectSound,long hWnd)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECTSOUND, lpDSound, DirectSound);
	
	if (FAILED( hr = m__dxj_DirectMusic->SetDirectSound(lpDSound, (HWND)hWnd)) )
		return hr;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmussongobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmussongobj.cpp
//
//--------------------------------------------------------------------------


#include "dmusici.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmusSongObj.h"
#include "dmSegmentObj.h"

extern void *g_dxj_DirectMusicSong;
extern void *g_dxj_DirectMusicSegment;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BOOL IsEmptyString(BSTR szString);

CONSTRUCTOR(_dxj_DirectMusicSong, {});
DESTRUCTOR(_dxj_DirectMusicSong, {});
GETSET_OBJECT(_dxj_DirectMusicSong);

HRESULT C_dxj_DirectMusicSongObject::Compose()
{
	HRESULT hr;

	__try {
		if (FAILED (hr = m__dxj_DirectMusicSong->Compose() ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectMusicSongObject::GetSegment(BSTR Name, I_dxj_DirectMusicSegment **ret)
{
    WCHAR wszSegName[MAX_PATH];
	HRESULT hr;
	IDirectMusicSegment		*lpOldSeg = NULL;
	IDirectMusicSegment8	*lpSeg = NULL;

	__try {
		if (!IsEmptyString(Name))
		{
			wcscpy(wszSegName, Name);	

			if (FAILED( hr = m__dxj_DirectMusicSong->GetSegment(wszSegName, &lpOldSeg) ) )
				return hr;
		}
		else
		{
			if (FAILED( hr = m__dxj_DirectMusicSong->GetSegment(NULL, &lpOldSeg) ) )
				return hr;
		}

		hr = lpOldSeg->QueryInterface(IID_IDirectMusicSegment8, (void**) &lpSeg);
		lpOldSeg->Release();
		if (FAILED(hr))
			return hr;

		INTERNAL_CREATE(_dxj_DirectMusicSegment, lpSeg, ret)
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectMusicSongObject::GetAudioPathConfig(IUnknown **ret)
{
	HRESULT hr;

	__try {
		if (FAILED(hr = m__dxj_DirectMusicSong->GetAudioPathConfig(ret) ))
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectMusicSongObject::Download(IUnknown *downloadpath)
{
	if (!downloadpath) return E_INVALIDARG;	
	HRESULT hr;	
	I_dxj_DirectMusicSegment	*lpSeg = NULL;
	I_dxj_DirectMusicAudioPath	*lpPath = NULL;

	__try {
		hr = downloadpath->QueryInterface(IID_I_dxj_DirectMusicSegment, (void**)&lpSeg);
		if (SUCCEEDED(hr) )
		{
			DO_GETOBJECT_NOTNULL(IDirectMusicPerformance8*,pPer,lpSeg);
			hr=m__dxj_DirectMusicSong->Download(pPer);
			return hr;
		}
		else
		{
			hr = downloadpath->QueryInterface(IID_I_dxj_DirectMusicAudioPath, (void**)&lpPath);
			if (SUCCEEDED(hr) )
			{
				DO_GETOBJECT_NOTNULL(IDirectMusicAudioPath*,pPer,lpPath);
				hr=m__dxj_DirectMusicSong->Download(pPer);
				return hr;
			}
			else
				return E_INVALIDARG;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectMusicSongObject::Unload(IUnknown *downloadpath)
{
	if (!downloadpath) return E_INVALIDARG;	
	HRESULT hr;	
	I_dxj_DirectMusicSegment	*lpSeg = NULL;
	I_dxj_DirectMusicAudioPath	*lpPath = NULL;

	__try {
		hr = downloadpath->QueryInterface(IID_I_dxj_DirectMusicSegment, (void**)&lpSeg);
		if (SUCCEEDED(hr) )
		{
			DO_GETOBJECT_NOTNULL(IDirectMusicPerformance8*,pPer,lpSeg);
			hr=m__dxj_DirectMusicSong->Unload(pPer);
			return hr;
		}
		else
		{
			hr = downloadpath->QueryInterface(IID_I_dxj_DirectMusicAudioPath, (void**)&lpPath);
			if (SUCCEEDED(hr) )
			{
				DO_GETOBJECT_NOTNULL(IDirectMusicAudioPath*,pPer,lpPath);
				hr=m__dxj_DirectMusicSong->Unload(pPer);
				return hr;
			}
			else
				return E_INVALIDARG;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectMusicSongObject::EnumSegment(long lSegmentID, [out,retval] I_dxj_DirectMusicSegment **ret)
{
	HRESULT hr;
	IDirectMusicSegment		*lpOldSeg = NULL;
	IDirectMusicSegment8	*lpSeg = NULL;

	__try {
		if (FAILED( hr = m__dxj_DirectMusicSong->EnumSegment((DWORD) lSegmentID, &lpOldSeg) ) )
		hr = lpOldSeg->QueryInterface(IID_IDirectMusicSegment8, (void**) &lpSeg);
		lpOldSeg->Release();
		if (FAILED(hr))
			return hr;

		INTERNAL_CREATE(_dxj_DirectMusicSegment, lpSeg, ret)
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmusportobj.h ===
#include "resource.h"       // main symbols
#include "dmusicc.h"

#define typedef__dxj_DirectMusicPort LPDIRECTMUSICPORT8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicPortObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectMusicPort, &IID_I_dxj_DirectMusicPort, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectMusicPort,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectMusicPortObject() ;
	virtual ~C_dxj_DirectMusicPortObject() ;

BEGIN_COM_MAP(C_dxj_DirectMusicPortObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectMusicPort)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectMusicPortObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectMusicPort
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

// Member functions

		HRESULT STDMETHODCALLTYPE PlayBuffer(I_dxj_DirectMusicBuffer *Buffer);
		HRESULT STDMETHODCALLTYPE SetReadNotificationHandle(long hEvent);
		HRESULT STDMETHODCALLTYPE Read(I_dxj_DirectMusicBuffer **Buffer);

//		[helpcontext(1)]			HRESULT DownloadInstrument(THIS_ IDirectMusicInstrument *pInstrument, 
//			                                     IDirectMusicDownloadedInstrument **ppDownloadedInstrument,
//			                                     DMUS_NOTERANGE *pNoteRanges,
//			                                     DWORD dwNumNoteRanges);
//		[helpcontext(1)]			HRESULT UnloadInstrument(THIS_ IDirectMusicDownloadedInstrument *pDownloadedInstrument);

		HRESULT STDMETHODCALLTYPE GetLatencyClock(I_dxj_ReferenceClock **Clock);
		HRESULT STDMETHODCALLTYPE GetRunningStats(DMUS_SYNTHSTATS_CDESC *Stats);
		HRESULT STDMETHODCALLTYPE Compact();
		HRESULT STDMETHODCALLTYPE GetCaps(DMUS_PORTCAPS_CDESC *PortCaps);
		HRESULT STDMETHODCALLTYPE SetNumChannelGroups(long lChannelGroups);
		HRESULT STDMETHODCALLTYPE GetNumChannelGroups(long *ChannelGroups);
		HRESULT STDMETHODCALLTYPE Activate(VARIANT_BOOL fActive);
		HRESULT STDMETHODCALLTYPE SetChannelPriority(long lChannelGroup, long lChannel, long lPriority);
		HRESULT STDMETHODCALLTYPE GetChannelPriority(long lChannelGroup, long lChannel, long *lPriority);
		HRESULT STDMETHODCALLTYPE SetDirectSound(I_dxj_DirectSound *DirectSound, I_dxj_DirectSoundBuffer *DirectSoundBuffer);
		HRESULT STDMETHODCALLTYPE GetFormat(WAVEFORMATEX_CDESC *WaveFormatEx);
		
		// New for DMusPort8
		HRESULT STDMETHODCALLTYPE DownloadWave(I_dxj_DirectSoundWave *Wave,long lFlags,I_dxj_DirectSoundDownloadedWave **retWave);
		HRESULT STDMETHODCALLTYPE UnloadWave(I_dxj_DirectSoundDownloadedWave *Wave);
		HRESULT STDMETHODCALLTYPE AllocVoice(I_dxj_DirectSoundDownloadedWave *Wave,long lChannel,long lChannelGroup,long rtStart,long rtReadahead,I_dxj_DirectMusicVoice **Voice);
		HRESULT STDMETHODCALLTYPE AssignChannelToBuses(long lChannelGroup,long lChannel,SAFEARRAY **lBuses,long lBusCount); 
		HRESULT STDMETHODCALLTYPE SetSink(I_dxj_DirectSoundSink *Sink);
		HRESULT STDMETHODCALLTYPE GetSink(I_dxj_DirectSoundSink **Sink);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectMusicPort);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectMusicPort);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmussongobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmSongobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicSongObject

#include "resource.h"       // main symbols
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#define typedef__dxj_DirectMusicSong IDirectMusicSong8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicSongObject : 
	public I_dxj_DirectMusicSong,
	//public CComCoClass<C_dxj_DirectMusicSongObject, &CLSID__dxj_DirectMusicSong>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicSongObject();
	virtual ~C_dxj_DirectMusicSongObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicSongObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicSong)		
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicSongObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

		HRESULT STDMETHODCALLTYPE Compose();
		HRESULT STDMETHODCALLTYPE GetSegment(BSTR Name, I_dxj_DirectMusicSegment **ret);
		//HRESULT STDMETHODCALLTYPE Clone(I_dxj_DirectMusicSong **ret);
		HRESULT STDMETHODCALLTYPE GetAudioPathConfig(IUnknown **ret);
		HRESULT STDMETHODCALLTYPE Download(IUnknown *downloadpath);
		HRESULT STDMETHODCALLTYPE Unload(IUnknown *downloadpath);
		HRESULT STDMETHODCALLTYPE EnumSegment(long lSegmentID, I_dxj_DirectMusicSegment **ret);
    

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicSong);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicSong)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmusportobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dMusPortObj.h"					   
#include "dMusBufferObj.h"					   
#include "dsoundobj.h"
#include "dsoundbufferobj.h"
#include "dsounddownloadedwaveobj.h"
#include "dsoundsinkobj.h"

extern void *g_dxj_DirectMusicPort;
extern void *g_dxj_DirectSoundSink;
extern void *g_dxj_DirectMusicBuffer;
extern void *g_dxj_DirectSoundDownloadedWave;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicPortObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectMusicPort [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicPortObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectMusicPort [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectMusicPortObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicPortObject::C_dxj_DirectMusicPortObject(){ 
		
	DPF1(1,"Constructor Creation  DirectMusicPort Object[%d] \n ",g_creationcount);

	m__dxj_DirectMusicPort = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectMusicPort;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectMusicPort = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectMusicPortObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicPortObject::~C_dxj_DirectMusicPortObject()
{

	DPF(1,"Entering ~C_dxj_DirectMusicPortObject destructor \n");

     C_dxj_DirectMusicPortObject *prev=NULL; 
	for(C_dxj_DirectMusicPortObject *ptr=(C_dxj_DirectMusicPortObject *)g_dxj_DirectMusicPort ; ptr; ptr=(C_dxj_DirectMusicPortObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectMusicPort = (void*)ptr->nextobj; 
			
			DPF(1,"DirectMusicPortObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectMusicPort){
		int count = IUNK(m__dxj_DirectMusicPort)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectMusicPort Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectMusicPort = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectMusicPortObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectMusicPort;
	
	return S_OK;
}
HRESULT C_dxj_DirectMusicPortObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectMusicPort=(LPDIRECTMUSICPORT8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::PlayBuffer(I_dxj_DirectMusicBuffer *Buffer)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICBUFFER, lpMusBuf, Buffer);

	if (FAILED(hr = m__dxj_DirectMusicPort->PlayBuffer(lpMusBuf) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::SetReadNotificationHandle(long hEvent)
{
	HRESULT hr;

	if (FAILED(hr = m__dxj_DirectMusicPort->SetReadNotificationHandle((HANDLE) hEvent) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::Read(I_dxj_DirectMusicBuffer **Buffer)
{
	HRESULT					hr;
	LPDIRECTMUSICBUFFER		lpBuf = NULL;

	if (FAILED(hr = m__dxj_DirectMusicPort->Read(lpBuf) ) )
		return hr;

	INTERNAL_CREATE(_dxj_DirectMusicBuffer, lpBuf, Buffer);
	return S_OK;
}

//		[helpcontext(1)]			HRESULT DownloadInstrument(THIS_ IDirectMusicInstrument *pInstrument, 
//			                                     IDirectMusicDownloadedInstrument **ppDownloadedInstrument,
//			                                     DMUS_NOTERANGE *pNoteRanges,
//			                                     DWORD dwNumNoteRanges);
//		[helpcontext(1)]			HRESULT UnloadInstrument(THIS_ IDirectMusicDownloadedInstrument *pDownloadedInstrument);

HRESULT C_dxj_DirectMusicPortObject::GetLatencyClock(I_dxj_ReferenceClock **Clock)
{
	HRESULT hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::GetRunningStats(DMUS_SYNTHSTATS_CDESC *Stats)
{
	HRESULT hr;

	if (FAILED(hr = m__dxj_DirectMusicPort->GetRunningStats((DMUS_SYNTHSTATS*)Stats) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::Compact()
{
	HRESULT hr;

	if (FAILED (hr = m__dxj_DirectMusicPort->Compact() ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::GetCaps(DMUS_PORTCAPS_CDESC *PortCaps)
{
	HRESULT hr;

	if (FAILED (hr = m__dxj_DirectMusicPort->GetCaps((DMUS_PORTCAPS*)PortCaps) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::SetNumChannelGroups(long lChannelGroups)
{
	HRESULT hr;
	
	if (FAILED (hr = m__dxj_DirectMusicPort->SetNumChannelGroups((DWORD) lChannelGroups) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::GetNumChannelGroups(long *ChannelGroups)
{
	HRESULT hr;

	if (FAILED (hr = m__dxj_DirectMusicPort->GetNumChannelGroups((DWORD*) ChannelGroups) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::Activate(VARIANT_BOOL fActive)
{
	HRESULT hr;

	if (fActive == VARIANT_FALSE)
	{
		if (FAILED (hr = m__dxj_DirectMusicPort->Activate(FALSE) ) )
			return hr;
	} else
	{
		if (FAILED (hr = m__dxj_DirectMusicPort->Activate(TRUE) ) )
			return hr;
	}
	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::SetChannelPriority(long lChannelGroup, long lChannel, long lPriority)
{
	HRESULT hr;
	
	if (FAILED (hr = m__dxj_DirectMusicPort->SetChannelPriority((DWORD) lChannelGroup, (DWORD) lChannel, (DWORD) lPriority) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::GetChannelPriority(long lChannelGroup, long lChannel, long *lPriority)
{
	HRESULT hr;

	if (FAILED (hr = m__dxj_DirectMusicPort->GetChannelPriority((DWORD) lChannelGroup, (DWORD) lChannel, (DWORD*) lPriority) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::SetDirectSound(I_dxj_DirectSound *DirectSound, I_dxj_DirectSoundBuffer *DirectSoundBuffer)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(LPDIRECTSOUND, lpDSound, DirectSound);
	DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDBUFFER, lpDSoundBuf, DirectSoundBuffer);

	if (FAILED ( hr = m__dxj_DirectMusicPort->SetDirectSound(lpDSound, lpDSoundBuf) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::GetFormat(WAVEFORMATEX_CDESC *WaveFormatEx)
{
	HRESULT hr;

	return S_OK;
}

		
// New for DMusPort8
HRESULT C_dxj_DirectMusicPortObject::DownloadWave(I_dxj_DirectSoundWave *Wave,long lFlags,I_dxj_DirectSoundDownloadedWave **retWave)
{
	HRESULT hr;
	LPDIRECTSOUNDDOWNLOADEDWAVE	lpDWave = NULL;
	DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDWAVE, lpWave, Wave);

	if (FAILED (hr = m__dxj_DirectMusicPort->DownloadWave(lpWave, (DWORD) lFlags, &lpDWave) ) )
		return hr;

	INTERNAL_CREATE(_dxj_DirectSoundDownloadedWave, lpDWave, retWave);

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::UnloadWave(I_dxj_DirectSoundDownloadedWave *Wave)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDDOWNLOADEDWAVE, lpWave, Wave);

	if (FAILED (hr = m__dxj_DirectMusicPort->UnloadWave(lpWave) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::AllocVoice(I_dxj_DirectSoundDownloadedWave *Wave,long lChannel,long lChannelGroup,long rtStart,long rtReadahead,I_dxj_DirectMusicVoice **Voice)
{
	HRESULT hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::AssignChannelToBuses(long lChannelGroup,long lChannel,SAFEARRAY **lBuses,long lBusCount)
{
	HRESULT hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::SetSink(I_dxj_DirectSoundSink *Sink)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDSINK8, lpSink, Sink);

	if (FAILED (hr = m__dxj_DirectMusicPort->SetSink(lpSink) ) )
		return hr;


	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::GetSink(I_dxj_DirectSoundSink **Sink)
{
	HRESULT hr;
	LPDIRECTSOUNDSINK8 lpSink = NULL;

	if (FAILED (hr = m__dxj_DirectMusicPort->GetSink(&lpSink) ) )
		return hr;

	INTERNAL_CREATE(_dxj_DirectSoundSink, lpSink, Sink);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmusvoiceobj.h ===
#include "resource.h"       // main symbols
#include "dmusicc.h"

#define typedef__dxj_DirectMusicVoice LPDIRECTMUSICVOICE8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicVoiceObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectMusicVoice, &IID_I_dxj_DirectMusicVoice, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectMusicVoice,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectMusicVoiceObject() ;
	virtual ~C_dxj_DirectMusicVoiceObject() ;

BEGIN_COM_MAP(C_dxj_DirectMusicVoiceObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectMusicVoice)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectMusicVoiceObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectMusicVoice
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE Play(REFERENCE_TIME rtStart,long lPitch,long lVolume);
		HRESULT STDMETHODCALLTYPE Stop(REFERENCE_TIME rtStop);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectMusicVoice);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectMusicVoice);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dmusvoiceobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dMusVoiceObj.h"					   

extern void *g_dxj_DirectMusicVoice;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicVoiceObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectMusicVoice [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicVoiceObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectMusicVoice [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectMusicVoiceObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicVoiceObject::C_dxj_DirectMusicVoiceObject(){ 
		
	DPF1(1,"Constructor Creation  DirectMusicVoice Object[%d] \n ",g_creationcount);

	m__dxj_DirectMusicVoice = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectMusicVoice;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectMusicVoice = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectMusicVoiceObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicVoiceObject::~C_dxj_DirectMusicVoiceObject()
{

	DPF(1,"Entering ~C_dxj_DirectMusicVoiceObject destructor \n");

     C_dxj_DirectMusicVoiceObject *prev=NULL; 
	for(C_dxj_DirectMusicVoiceObject *ptr=(C_dxj_DirectMusicVoiceObject *)g_dxj_DirectMusicVoice ; ptr; ptr=(C_dxj_DirectMusicVoiceObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectMusicVoice = (void*)ptr->nextobj; 
			
			DPF(1,"DirectMusicVoiceObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectMusicVoice){
		int count = IUNK(m__dxj_DirectMusicVoice)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectMusicVoice Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectMusicVoice = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectMusicVoiceObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectMusicVoice;
	
	return S_OK;
}
HRESULT C_dxj_DirectMusicVoiceObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectMusicVoice=(LPDIRECTMUSICVOICE8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectMusicVoiceObject::Play(REFERENCE_TIME rtStart,long lPitch,long lVolume)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectMusicVoice->Play(rtStart, (DWORD)lPitch, (DWORD)lVolume )) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicVoiceObject::Stop(REFERENCE_TIME rtStop)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectMusicVoice->Stop(rtStop) ))
		return hr;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplayaddressobj.h ===
#include "resource.h"       // main symbols
#include "dpaddr.h"

#define typedef__dxj_DirectPlayAddress IDirectPlay8Address*

/////////////////////////////////////////////////////////////////////////////
// Direct Net Peer

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayAddressObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayAddress, &IID_I_dxj_DirectPlayAddress, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayAddress,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayAddressObject() ;
	virtual ~C_dxj_DirectPlayAddressObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayAddressObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayAddress)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayAddressObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayAddress
public:
	 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE BuildFromURL(BSTR SourceURL);
		HRESULT STDMETHODCALLTYPE Duplicate(I_dxj_DirectPlayAddress **NewAddress);
		HRESULT STDMETHODCALLTYPE Clear();
		HRESULT STDMETHODCALLTYPE GetURL(BSTR *URL);
		HRESULT STDMETHODCALLTYPE GetSP(BSTR *guidSP);
		HRESULT STDMETHODCALLTYPE GetUserData(void *UserData, long *lBufferSize);
		HRESULT STDMETHODCALLTYPE SetSP(BSTR guidSP);
		HRESULT STDMETHODCALLTYPE SetUserData(void *UserData, long lDataSize);
		HRESULT STDMETHODCALLTYPE GetNumComponents(long *lNumComponents);
		HRESULT STDMETHODCALLTYPE GetDevice(BSTR *guidDevice);
		HRESULT STDMETHODCALLTYPE SetDevice(BSTR guidDevice);
		HRESULT STDMETHODCALLTYPE SetEqual(I_dxj_DirectPlayAddress *Address);
		HRESULT STDMETHODCALLTYPE AddComponentLong(BSTR sComponent, long lValue);
		HRESULT STDMETHODCALLTYPE AddComponentString(BSTR sComponent, BSTR sValue);
		HRESULT STDMETHODCALLTYPE GetComponentLong(BSTR sComponent, long *lValue);
		HRESULT STDMETHODCALLTYPE GetComponentString(BSTR sComponent, BSTR *sValue);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayAddress);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayAddress);

	DWORD InternalAddRef();
	DWORD InternalRelease();
	void	*m_pUserData;
	DWORD	m_dwUserDataSize;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplayaddressobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPlayAddressObj.h"					   

extern void *g_dxj_DirectPlayAddress;
extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT DPLAYBSTRtoGUID(LPGUID,BSTR);
extern BOOL IsEmptyString(BSTR szString);

#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }
#define SAFE_RELEASE(p)      { __try { if(p) { int i = 0; i = (p)->Release(); DPF1(1,"--DirectPlayAddress SafeRelease (RefCount = %d)\n",i); if (!i) { (p)=NULL;}} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { (p) = NULL;} } 

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayAddressObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"------ DXVB: DirectPlayAddress8 [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayAddressObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"------ DXVB: DirectPlayAddress8 [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayAddressObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayAddressObject::C_dxj_DirectPlayAddressObject(){ 
		
	DPF1(1,"------ DXVB: Constructor Creation  DirectPlayAddress8 Object[%d] \n ",g_creationcount);

	m__dxj_DirectPlayAddress = NULL;

	m_pUserData = NULL;
	m_dwUserDataSize = 0;
	g_dxj_DirectPlayAddress = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayAddressObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayAddressObject::~C_dxj_DirectPlayAddressObject()
{

	DPF(1,"Entering ~C_dxj_DirectPlayAddressObject destructor \n");

	__try {
		SAFE_RELEASE(m__dxj_DirectPlayAddress);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		m__dxj_DirectPlayAddress = NULL;
	}

	SAFE_DELETE(m_pUserData);
}

HRESULT C_dxj_DirectPlayAddressObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayAddress;
	
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayAddress=(IDirectPlay8Address*)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::BuildFromURL(BSTR SourceURL)
{
	HRESULT hr;

	__try {
		if (FAILED(hr = m__dxj_DirectPlayAddress->BuildFromURLW(SourceURL) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::Duplicate(I_dxj_DirectPlayAddress **NewAddress)
{
	HRESULT hr;
	IDirectPlay8Address		*lpDup = NULL;

	__try {
		if (FAILED (hr = m__dxj_DirectPlayAddress->Duplicate(&lpDup) ) )
			return hr;

		INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayAddress, lpDup, NewAddress);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::Clear()
{
	HRESULT hr;

	__try {
		if (FAILED ( hr = m__dxj_DirectPlayAddress->Clear() ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::GetURL(BSTR *URL)
{
	HRESULT hr;
	WCHAR	wszUrl[MAX_PATH];
	DWORD	dwNumChars = 0;
	
	__try {
		hr = m__dxj_DirectPlayAddress->GetURLW(NULL, &dwNumChars);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		if (FAILED (hr = m__dxj_DirectPlayAddress->GetURLW(&wszUrl[0],&dwNumChars) ) )
			return hr;

		*URL = SysAllocString(&wszUrl[0]);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::GetSP(BSTR *guidSP)
{
	HRESULT hr;
	GUID	guidDev;
	
	__try {
		if (FAILED (hr = m__dxj_DirectPlayAddress->GetSP(&guidDev ) ) )
			return hr;

		GUID* pGuid = new GUID; 
		if (!pGuid)
			return E_OUTOFMEMORY;

		memcpy( pGuid, &guidDev, sizeof(GUID) );
		*guidSP = GUIDtoBSTR(pGuid);
		SAFE_DELETE(pGuid);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::GetUserData(void *UserData, long *lBufferSize)
{
	__try {
		DPF(1,"-----Entering (DplayAddress) GetUserData call...\n");
		//Copy the memory over to our new variable
		memcpy(UserData,m_pUserData,m_dwUserDataSize);
		lBufferSize = (long*)&m_dwUserDataSize;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::SetSP(BSTR guidSP)
{
	HRESULT hr;
	GUID	guidDev;

	__try {
		if (guidSP)
		{
			if (FAILED( hr = DPLAYBSTRtoGUID(&guidDev, guidSP) ) )
				return hr;
		}
		else
			return E_INVALIDARG;

		if (FAILED ( hr = m__dxj_DirectPlayAddress->SetSP(&guidDev) ))
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::SetUserData(void *UserData, long lDataSize)
{
	__try {
		DPF(1,"-----Entering (DplayAddress) SetUserData call...\n");
		if (m_pUserData)
			SAFE_DELETE(m_pUserData);

		m_pUserData = (void*)new BYTE[lDataSize];
		if (!m_pUserData)
			return E_OUTOFMEMORY;

		memcpy((void*) m_pUserData, (void*)UserData, lDataSize);
		m_dwUserDataSize = (DWORD)lDataSize;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::GetNumComponents(long *lNumComponents)
{
	HRESULT hr;

	__try {
		if (FAILED (hr = m__dxj_DirectPlayAddress->GetNumComponents((DWORD*) lNumComponents) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::GetDevice(BSTR *guidDevice)
{
	HRESULT hr;
	GUID	guidDev;
	
	__try {
		if (FAILED (hr = m__dxj_DirectPlayAddress->GetDevice(&guidDev ) ) )
			return hr;

		GUID* pGuid = new GUID; 
		if (!pGuid)
			return E_OUTOFMEMORY;

		memcpy( pGuid, &guidDev, sizeof(GUID) );
		*guidDevice = GUIDtoBSTR(pGuid);
		SAFE_DELETE(pGuid);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::SetDevice(BSTR guidDevice)
{
	HRESULT hr;
	GUID	guidDev;

	__try {
		if (guidDevice)
		{
			if (FAILED( hr = DPLAYBSTRtoGUID(&guidDev, guidDevice) ) )
				return hr;
		}
		else
			return E_INVALIDARG;

		if (FAILED ( hr = m__dxj_DirectPlayAddress->SetDevice(&guidDev) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::SetEqual(I_dxj_DirectPlayAddress *Address)
{
	HRESULT hr;

	__try {
		DO_GETOBJECT_NOTNULL( IDirectPlay8Address*, lpAddress, Address);

		if (FAILED (hr = m__dxj_DirectPlayAddress->SetEqual( lpAddress) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::AddComponentLong(BSTR sComponent, long lValue)
{
	HRESULT hr;
    WCHAR wszComponent[MAX_PATH];

	__try {
		if (!IsEmptyString(sComponent)) wcscpy(wszComponent, sComponent);	

		if (FAILED (hr = m__dxj_DirectPlayAddress->AddComponent(wszComponent, (DWORD*) &lValue, sizeof(DWORD), DPNA_DATATYPE_DWORD ) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}


HRESULT C_dxj_DirectPlayAddressObject::AddComponentString(BSTR sComponent, BSTR sValue)
{
	HRESULT hr;
    WCHAR wszComponent[MAX_PATH];
    WCHAR wszValue[MAX_PATH];

	__try {
		if (!IsEmptyString(sComponent)) wcscpy(wszComponent, sComponent);	
		if (!IsEmptyString(sValue)) wcscpy(wszValue, sValue);	

		if (FAILED (hr = m__dxj_DirectPlayAddress->AddComponent(wszComponent, (WCHAR*) &wszValue, (((DWORD*)sValue)[-1]) + sizeof(WCHAR), DPNA_DATATYPE_STRING ) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::GetComponentLong(BSTR sComponent, long *lValue)
{
	HRESULT hr;
    WCHAR wszComponent[MAX_PATH];
    DWORD dwSize = 0;
	DWORD dwDataType = DPNA_DATATYPE_DWORD;
	DWORD dwData = 0;
	
	__try {
		if (!IsEmptyString(sComponent))
		{
			wcscpy(wszComponent, sComponent);	
		}
		else
			return E_INVALIDARG;

		hr = m__dxj_DirectPlayAddress->GetComponentByName(wszComponent, NULL, &dwSize, &dwDataType);
		if (FAILED(hr) && (hr != DPNERR_BUFFERTOOSMALL))	
			return hr;

		if (FAILED (hr = m__dxj_DirectPlayAddress->GetComponentByName(wszComponent, &dwData, &dwSize, &dwDataType) ) )
			return hr;

		*lValue = dwData;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::GetComponentString(BSTR sComponent, BSTR *sValue)
{
	HRESULT hr;
    WCHAR wszComponent[MAX_PATH];
    DWORD dwSize = 0;
	DWORD dwDataType = DPNA_DATATYPE_STRING;
	WCHAR *wszRet = NULL;
	
	__try {
		if (!IsEmptyString(sComponent))
		{
			wcscpy(wszComponent, sComponent);	
		}
		else
			return E_INVALIDARG;

		hr = m__dxj_DirectPlayAddress->GetComponentByName(wszComponent, NULL, &dwSize, &dwDataType);
		if (FAILED(hr) && (hr != DPNERR_BUFFERTOOSMALL))	
			return hr;

		wszRet = (WCHAR*)new BYTE[dwSize];
		if (!wszRet)
			return E_OUTOFMEMORY;

		hr = m__dxj_DirectPlayAddress->GetComponentByName(wszComponent, wszRet, &dwSize, &dwDataType);
		if (FAILED(hr))	
			return hr;

		*sValue = SysAllocString(wszRet);
		SAFE_DELETE(wszRet);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplaybufhelp.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:       DplayBufHelp.cpp
//  Content:    Helper functions for DPlay Buffers (Byte arrays)
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "Direct.h"

#define SAFE_FREE(p)       { if(p) { free (p); p=NULL; } }
#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }

#define INITIAL_BUFFER_SIZE 20

HRESULT WINAPI VB_GrowBuffer(SAFEARRAY **Buffer, DWORD dwGrowSize);
HRESULT WINAPI VB_NewBuffer(SAFEARRAY **Buffer, long *lOffSet);
HRESULT WINAPI VB_AddDataToBuffer(SAFEARRAY **Buffer, void *lData, DWORD lSize, long *lOffSet);
HRESULT WINAPI VB_AddStringToBuffer(SAFEARRAY **Buffer, BSTR StringData, long *lOffSet);
HRESULT WINAPI VB_GetDataFromBuffer(SAFEARRAY **Buffer, void *lData, DWORD lSize, long *lOffSet);
HRESULT WINAPI VB_GetStringFromBuffer(SAFEARRAY **Buffer, long *lOffSet, BSTR *sData);

// Functions for writing a buffer
HRESULT WINAPI VB_AddStringToBuffer(SAFEARRAY **Buffer, BSTR StringData, long *lOffSet)
{
	HRESULT hr;
	// For strings we will first write out a DWORD 
	// containging the length of the string.  Then we
	// will write the actual data to the string.

	DWORD dwStrLen= (((DWORD*)StringData)[-1]);
	DWORD dwDataSize = sizeof(DWORD) + dwStrLen;
	
	if (!StringData)
		return E_INVALIDARG;

	if (!((SAFEARRAY*)*Buffer))
	{
		// We need to create this buffer, it doesn't exist
		SAFEARRAY					*lpData = NULL;
		SAFEARRAYBOUND				rgsabound[1];

		// Let's create our SafeArray
		rgsabound[0].lLbound = 0; // A single dimension array that is zero based
		rgsabound[0].cElements = dwDataSize; //Set the initial size
		// Create this data
		lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (!lpData)
			return E_OUTOFMEMORY;

		(SAFEARRAY*)*Buffer = lpData;
	}

	if (!((SAFEARRAY*)*Buffer)->pvData)
		return E_INVALIDARG;

	// Do we have enough memory for this string right now?
	if (*lOffSet + dwDataSize > ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements)
		if (FAILED( hr = VB_GrowBuffer(Buffer, dwDataSize) ) )
			return hr;

	// Ok, now we' ve got our memory, copy it over
	// First the length
	BYTE  *lPtr = (BYTE*)((SAFEARRAY*)*Buffer)->pvData;
	__try {

		memcpy(lPtr + *lOffSet, &dwStrLen, sizeof(DWORD));
		*lOffSet += sizeof(DWORD);
		// Now the actual string
		memcpy(lPtr + *lOffSet, StringData, dwStrLen);
		*lOffSet += dwStrLen;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_INVALIDARG;
	}

	return S_OK;

}

HRESULT WINAPI VB_AddDataToBuffer(SAFEARRAY **Buffer, void *lData, DWORD lSize, long *lOffSet)
{
	HRESULT hr;
	
	if (!lData)
		return E_INVALIDARG;

	if (!lSize)
		return E_INVALIDARG;

	if (!((SAFEARRAY*)*Buffer))
	{
		// We need to create this buffer, it doesn't exist
		SAFEARRAY					*lpData = NULL;
		SAFEARRAYBOUND				rgsabound[1];

		// Let's create our SafeArray
		rgsabound[0].lLbound = 0; // A single dimension array that is zero based
		rgsabound[0].cElements = lSize; //Set the initial size
		// Create this data
		lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (!lpData)
			return E_OUTOFMEMORY;

		(SAFEARRAY*)*Buffer = lpData;
	}

	if (!((SAFEARRAY*)*Buffer)->pvData)
		return E_INVALIDARG;

	// Do we have enough memory for this string right now?
	if (*lOffSet + lSize > ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements)
		if (FAILED( hr = VB_GrowBuffer(Buffer, lSize) ) )
			return hr;

	BYTE  *lPtr = (BYTE*)((SAFEARRAY*)*Buffer)->pvData;

	__try {
		memcpy(lPtr + *lOffSet, lData, lSize);
		*lOffSet += lSize;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_INVALIDARG;
	}
	return S_OK;
}

HRESULT WINAPI VB_NewBuffer(SAFEARRAY **Buffer, long *lOffSet)
{
	// Set up with a 20 byte msg at first
	SAFEARRAY					*lpData = NULL;
	SAFEARRAYBOUND				rgsabound[1];

	// Let's create our SafeArray
	rgsabound[0].lLbound = 0; // A single dimension array that is zero based
	rgsabound[0].cElements = INITIAL_BUFFER_SIZE; //Set the initial size
	// Create this data
	lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

	if (!lpData)
		return E_OUTOFMEMORY;

	(SAFEARRAY*)*Buffer = lpData;

	*lOffSet = 0;
	return S_OK;
}

HRESULT WINAPI VB_GrowBuffer(SAFEARRAY **Buffer, DWORD dwGrowSize)
{
	SAFEARRAY					*lpData = NULL;
	SAFEARRAYBOUND				rgsabound[1];
	DWORD						dwCurSize = 0;

	if (!dwGrowSize)
		return E_INVALIDARG;

	if (!((SAFEARRAY*)*Buffer))
		return E_INVALIDARG;

	if (!((SAFEARRAY*)*Buffer)->pvData)
		return E_INVALIDARG;

	dwCurSize = ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements;

	// Let's create a new SafeArray
	rgsabound[0].lLbound = 0; // A single dimension array that is zero based
	rgsabound[0].cElements = dwCurSize + dwGrowSize; //Set the size
	// Create this data
	lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

	if (!lpData)
		return E_OUTOFMEMORY;

	__try {
		memcpy(lpData->pvData, ((SAFEARRAY*)*Buffer)->pvData, dwCurSize);
		SafeArrayDestroy((SAFEARRAY*)*Buffer);

		(SAFEARRAY*)*Buffer = lpData;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT WINAPI VB_GetDataFromBuffer(SAFEARRAY **Buffer, void *lData, DWORD lSize, long *lOffSet)
{
	// Simply copy the memory from the offset to the new data

	if (!lData)
		return E_INVALIDARG;

	if (!lSize)
		return E_INVALIDARG;

	if (!(SAFEARRAY*)*Buffer)
		return E_INVALIDARG;

	if (!((SAFEARRAY*)*Buffer)->pvData)
		return E_INVALIDARG;

	if (*lOffSet + lSize > ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements)
		return E_INVALIDARG;

	BYTE  *lPtr = (BYTE*)((SAFEARRAY*)*Buffer)->pvData;

	__try {
		memcpy(lData, lPtr + *lOffSet, lSize);
		*lOffSet += lSize;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_INVALIDARG;
	}

	return S_OK;
}

HRESULT WINAPI VB_GetStringFromBuffer(SAFEARRAY **Buffer, long *lOffSet, BSTR *sData)
{
	DWORD		dwStrLen = 0;
	WCHAR		*sNewString = NULL;

	// Simply copy the memory from the offset to the new data
	if (!(SAFEARRAY*)*Buffer)
		return E_INVALIDARG;

	if (!((SAFEARRAY*)*Buffer)->pvData)
		return E_INVALIDARG;

	if (*lOffSet + sizeof(DWORD) > ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements)
		return E_INVALIDARG;

	BYTE  *lPtr = (BYTE*)((SAFEARRAY*)*Buffer)->pvData;

	__try {
		// First read the size of the string
		dwStrLen = *(DWORD*)(lPtr + *lOffSet);
		*lOffSet += sizeof(DWORD);

		if (*lOffSet + dwStrLen  > ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements)
			return E_INVALIDARG;

		sNewString = (WCHAR*)new BYTE[dwStrLen+2];
		if (!sNewString)
			return E_OUTOFMEMORY;

		ZeroMemory(sNewString, dwStrLen+2);
		memcpy(sNewString, lPtr + *lOffSet, dwStrLen);
		*sData = SysAllocString(sNewString);

		*lOffSet += (dwStrLen);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_INVALIDARG;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplayclientobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPlayClientObj.h"					   
#include "DPlayAddressObj.h"

extern void *g_dxj_DirectPlayAddress;
extern void *g_dxj_DirectPlayClient;
extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT DPLAYBSTRtoGUID(LPGUID,BSTR);
extern BOOL IsEmptyString(BSTR szString);

#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }
#define SAFE_RELEASE(p)      { __try { if(p) { int i = 0; i = (p)->Release(); DPF1(1,"--DirectPlayClient SafeRelease (RefCount = %d)\n",i); if (!i) { (p)=NULL;}} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { (p) = NULL;} } 
#define SAFE_DELETE_ARRAY(p)       { if(p) { delete [] (p); p=NULL; } }

DWORD WINAPI CloseClientThreadProc(void* lpParam);
DWORD WINAPI ReleaseClientThreadProc(void* lpParam);

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayClientObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF1(1,"----- DXVB: DirectPlayClient8 AddRef %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayClientObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF1(1,"------ DXVB: DirectPlayClient8 Release %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayClientObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayClientObject::C_dxj_DirectPlayClientObject(){ 
		
	DPF(1,"---- DXVB: Constructor Creation  DirectPlayClient8 Object\n ");

	m__dxj_DirectPlayClient = NULL;

	m_SPInfo = NULL;
	m_dwSPCount = 0;
	
	m_fInit = FALSE;
	m_fHandleEvents = FALSE;

	m_pEventStream=NULL;
	m_dwMsgCount = 0;

}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayClientObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayClientObject::~C_dxj_DirectPlayClientObject()
{

	DPF(1,"---- Entering ~C_dxj_DirectPlayClientObject destructor \n");

	 //We still have messages to process get rid of them
	m_fHandleEvents = FALSE;
	FlushBuffer(0);
	SAFE_DELETE_ARRAY(m_SPInfo);
	SAFE_RELEASE(m_pEventStream);

	HANDLE hThread = NULL;
	DWORD dwThread = 0;
	// We are quitting anyway, so we don't really care what is going on in this thread..
	hThread = CreateThread(NULL, 0, ReleaseClientThreadProc, this->m__dxj_DirectPlayClient, 0, &dwThread);
}

HRESULT C_dxj_DirectPlayClientObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayClient;
	
	return S_OK;
}
HRESULT C_dxj_DirectPlayClientObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayClient=(IDirectPlay8Client*)pUnk;
	return S_OK;
}

HRESULT WINAPI DirectPlayClientMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer )
{
	HRESULT					hr=S_OK;
	LPUNKNOWN			    lpUnk=NULL;
	BOOL					fCallCoUninit = FALSE;
	VARIANT_BOOL							fRejectMsg = VARIANT_FALSE;
	
	// User context for the message handler is a pointer to our class module.
	C_dxj_DirectPlayClientObject	*lpPeer = (C_dxj_DirectPlayClientObject*)pvUserContext;

	if (!lpPeer) 
		return S_OK; //Object must be gone

	DPF2(1,"-----Entering (DPlayClient) MessageHandler call... (Current msg count=%d) MSGID = %d\n", lpPeer->m_dwMsgCount, dwMessageId );
	//Increment the msg count
	InterlockedIncrement(&lpPeer->m_dwMsgCount);

	if (!lpPeer->m_fHandleEvents)
	{
		DPF(1,"-----Leaving (DPlayClient) MessageHandler call (*Not Handling Events*)...\n");
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return S_OK;
	}

	if (!lpPeer->m_pEventStream) 
	{
		DPF(1,"-----Leaving (DPlayClient) MessageHandler call (Stream Not Present)...\n");
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return S_OK;
	}

	// First we need to set our stream seek back to the beginning
	// We will do this every time we enter this function since we don't know if
	// we are on the same thread or not...
	
	I_dxj_DirectPlayEvent	*lpEvent = NULL;
	__try {
		LARGE_INTEGER l;
		l.QuadPart = 0;
		lpPeer->m_pEventStream->Seek(l, STREAM_SEEK_SET, NULL);

		hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);

		if (hr == CO_E_NOTINITIALIZED) // Call CoInit so we can unmarshal
		{
			CoInitializeEx(NULL,COINIT_MULTITHREADED);
			hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
			fCallCoUninit = TRUE;
		}

		if (!lpEvent) 
		{
			DPF1(1,"-----Leaving (DPlayClient) MessageHandler call (No event interface) - (Hresult) = %d...\n", hr);
			InterlockedDecrement(&lpPeer->m_dwMsgCount);
			return hr;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (DPlayClient) MessageHandler call (Stream Gone)...\n");
		return S_OK;
	}

    switch( dwMessageId )
	{
	//Receive
	case DPN_MSGID_RECEIVE:
		{
			DPF(1,"-----DirectPlayClient8 Callback Receive\n");
			DPNMSG_RECEIVE				*pMsgReceive = (DPNMSG_RECEIVE*)pMsgBuffer;
			DPNMSG_RECEIVE_CDESC		m_dpReceive;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpReceive, sizeof(DPNMSG_RECEIVE_CDESC));
			m_dpReceive.idSender = pMsgReceive->dpnidSender;
			
			// Let's load our SafeArray

			if (pMsgReceive->dwReceiveDataSize) 
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = pMsgReceive->dwReceiveDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = pMsgReceive->pReceiveData;
				m_dpReceive.lDataSize = pMsgReceive->dwReceiveDataSize;
				m_dpReceive.ReceivedData = lpData;
			}

			lpEvent->Receive(&m_dpReceive, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}
			
			break;
		}

	//Send complete
	case DPN_MSGID_SEND_COMPLETE:
		{
			DPF(1,"-----DirectPlayClient8 Callback SendComplete\n");
			DPNMSG_SEND_COMPLETE				*msg = (DPNMSG_SEND_COMPLETE*)pMsgBuffer;
			DPNMSG_SEND_COMPLETE_CDESC			m_dpSend;

			ZeroMemory(&m_dpSend, sizeof(DPNMSG_SEND_COMPLETE_CDESC));
			m_dpSend.AsyncOpHandle = (long)msg->hAsyncOp;
			m_dpSend.hResultCode = (long)msg->hResultCode;
			m_dpSend.lSendTime = (long)msg->dwSendTime;

			lpEvent->SendComplete(&m_dpSend, &fRejectMsg);
			break;
		}

	//Async Op complete
	case DPN_MSGID_ASYNC_OP_COMPLETE:
		{
			DPF(1,"-----DirectPlayClient8 Callback AsyncOpComplete\n");
			DPNMSG_ASYNC_OP_COMPLETE				*msg = (DPNMSG_ASYNC_OP_COMPLETE*)pMsgBuffer;
			DPNMSG_ASYNC_OP_COMPLETE_CDESC			m_dpAsynOp;
			
			ZeroMemory(&m_dpAsynOp, sizeof(DPNMSG_ASYNC_OP_COMPLETE_CDESC));
			m_dpAsynOp.AsyncOpHandle = (long) msg->hAsyncOp;
			m_dpAsynOp.hResultCode = (long) msg->hResultCode;

			lpEvent->AsyncOpComplete(&m_dpAsynOp, &fRejectMsg);
			break;
		}

	// Add/Remove players from groups
	case DPN_MSGID_ADD_PLAYER_TO_GROUP:
	case DPN_MSGID_REMOVE_PLAYER_FROM_GROUP:
		{
			DPF(1,"-----DirectPlayClient8 Callback Add/Remove Group\n");
			DPNMSG_ADD_PLAYER_TO_GROUP				*msg = (DPNMSG_ADD_PLAYER_TO_GROUP*)pMsgBuffer;
			DPNID									m_dpnidAddRemoveGroupID = 0;
			DPNID									m_dpnidAddRemovePlayerID = 0;

			m_dpnidAddRemoveGroupID = msg->dpnidGroup;
			m_dpnidAddRemovePlayerID = msg->dpnidPlayer;

			lpEvent->AddRemovePlayerGroup(dwMessageId, m_dpnidAddRemovePlayerID, m_dpnidAddRemoveGroupID, &fRejectMsg);
			break;
		}

	// App Desc
	case DPN_MSGID_APPLICATION_DESC:
		{
			DPF(1,"-----DirectPlayClient8 Callback App desc\n");
			lpEvent->AppDesc(&fRejectMsg);
		break;
		}

	// Indicate Connect
	case DPN_MSGID_INDICATE_CONNECT:
		{
			DPF(1,"-----DirectPlayClient8 Callback Indicate Connect\n");
			DPNMSG_INDICATE_CONNECT				*msg = (DPNMSG_INDICATE_CONNECT*)pMsgBuffer;
			DPNMSG_INDICATE_CONNECT_CDESC		m_dpIndConnect;
			WCHAR* wszAddress = NULL;
			WCHAR* wszDevice = NULL;
			DWORD dwNumChars = 0;


			ZeroMemory(&m_dpIndConnect, sizeof(DPNMSG_INDICATE_CONNECT_CDESC));

			__try {
				if (msg->pAddressPlayer)
				{
					hr = msg->pAddressPlayer->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
                        wszAddress = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
						if (FAILED (hr = msg->pAddressPlayer->GetURLW(wszAddress,&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpIndConnect.AddressPlayerUrl = SysAllocString(wszAddress);
						}
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (Indicate Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
						DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
                    wszDevice = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
					if (FAILED (hr = msg->pAddressDevice->GetURLW(wszDevice,&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpIndConnect.AddressDeviceUrl = SysAllocString(wszDevice);
					}
				}
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (Indicate Connect -  Part2)...\n");
			}

			lpEvent->IndicateConnect(&m_dpIndConnect, &fRejectMsg);
			// Get rid of these addresses
			if (m_dpIndConnect.AddressPlayerUrl)
				SysFreeString(m_dpIndConnect.AddressPlayerUrl);

			if (m_dpIndConnect.AddressDeviceUrl)
				SysFreeString(m_dpIndConnect.AddressDeviceUrl);
		break;
		}

	// Connect complete
	case DPN_MSGID_CONNECT_COMPLETE:
		{
			DPF(1,"-----DirectPlayClient8 Callback ConnectComplete\n");
			DPNMSG_CONNECT_COMPLETE				*msg = (DPNMSG_CONNECT_COMPLETE*)pMsgBuffer;
			DPNMSG_CONNECT_COMPLETE_CDESC		m_dpConnectComp;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpConnectComp, sizeof(DPNMSG_CONNECT_COMPLETE_CDESC));
			m_dpConnectComp.hResultCode = (long) msg->hResultCode;
			m_dpConnectComp.AsyncOpHandle =(long) msg->hAsyncOp;
			// Let's load our SafeArray

			if (msg->dwApplicationReplyDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwApplicationReplyDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pvApplicationReplyData;
				m_dpConnectComp.ReplyData = lpData;
			}

			lpEvent->ConnectComplete(&m_dpConnectComp, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}
		break;
		}

	// Host migrated
	case DPN_MSGID_HOST_MIGRATE:
		{
			DPF(1,"-----DirectPlayClient8 Callback HostMigrate\n");
			DPNMSG_HOST_MIGRATE				*msg = (DPNMSG_HOST_MIGRATE*)pMsgBuffer;
			DPNID							m_dpnidNewHostID = 0;

			m_dpnidNewHostID = msg->dpnidNewHost;

			lpEvent->HostMigrate(m_dpnidNewHostID, &fRejectMsg);
	
			break;
		}

	// Terminate Session
	case DPN_MSGID_TERMINATE_SESSION:
		{
			DPF(1,"-----DirectPlayClient8 Callback TerminateSession\n");
			DPNMSG_TERMINATE_SESSION		*msg = (DPNMSG_TERMINATE_SESSION*)pMsgBuffer;
			DPNMSG_TERMINATE_SESSION_CDESC			m_dpTerm;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpTerm, sizeof(DPNMSG_TERMINATE_SESSION_CDESC));
			m_dpTerm.hResultCode = msg->hResultCode;

			// Let's load our SafeArray

			if (msg->dwTerminateDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwTerminateDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pvTerminateData;
				m_dpTerm.TerminateData = lpData;
			}

			lpEvent->TerminateSession(&m_dpTerm,&fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}

		break;
		}

	// Enum Host query
	case DPN_MSGID_ENUM_HOSTS_QUERY:
		{
			DPF(1,"-----DirectPlayClient8 Callback EnumHostQuery\n");
			DPNMSG_ENUM_HOSTS_QUERY				*msg = (DPNMSG_ENUM_HOSTS_QUERY*)pMsgBuffer;
			DPNMSG_ENUM_HOSTS_QUERY_CDESC			m_dpEnumHostQuery;
			WCHAR* wszAddress = NULL;
			WCHAR* wszDevice = NULL;
			DWORD									dwNumChars = 0;

			
			ZeroMemory(&m_dpEnumHostQuery, sizeof(DPNMSG_ENUM_HOSTS_QUERY_CDESC));

			__try {
				hr = msg->pAddressSender->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
					DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
                    wszAddress = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
					if (FAILED (hr = msg->pAddressSender->GetURLW(wszAddress,&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpEnumHostQuery.AddressSenderUrl = SysAllocString(wszAddress);
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumQuery Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
					DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
                    wszDevice = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
					if (FAILED (hr = msg->pAddressDevice->GetURLW(wszDevice,&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpEnumHostQuery.AddressDeviceUrl = SysAllocString(wszDevice);
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumQuery Connect - Part2)...\n");
			}
			lpEvent->EnumHostsQuery(&m_dpEnumHostQuery, &fRejectMsg);

			// Get rid of these addresses
			if (m_dpEnumHostQuery.AddressSenderUrl)
				SysFreeString(m_dpEnumHostQuery.AddressSenderUrl);

			if (m_dpEnumHostQuery.AddressDeviceUrl)
				SysFreeString(m_dpEnumHostQuery.AddressDeviceUrl);

			break;
		}
	
	// Create Player
	case DPN_MSGID_CREATE_PLAYER:
		{
			DPF(1,"-----DirectPlayClient8 Callback CreatePlayer\n");
			DPNMSG_CREATE_PLAYER	*msg = (DPNMSG_CREATE_PLAYER*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			
			m_dpnidPlayerID = msg->dpnidPlayer;

			lpEvent->CreatePlayer(m_dpnidPlayerID, &fRejectMsg);
			
		break;
		}

	// Destroy Player
	case DPN_MSGID_DESTROY_PLAYER:
		{
			DPF(1,"-----DirectPlayClient8 Callback DestroyPlayer\n");
			DPNMSG_DESTROY_PLAYER	*msg = (DPNMSG_DESTROY_PLAYER*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DWORD									m_dwReason = 0;
			
			m_dpnidPlayerID = msg->dpnidPlayer;
			m_dwReason = msg->dwReason;
			
			lpEvent->DestroyPlayer(m_dpnidPlayerID, m_dwReason, &fRejectMsg);
		break;
		}

	// Create Group
	case DPN_MSGID_CREATE_GROUP:
		{
			DPF(1,"-----DirectPlayClient8 Callback CreateGroup\n");
			DPNMSG_CREATE_GROUP	*msg = (DPNMSG_CREATE_GROUP*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DPNID									m_dpnidOwnerID = 0;
			
			m_dpnidPlayerID = msg->dpnidGroup;
			m_dpnidOwnerID = msg->dpnidOwner;
			
			lpEvent->CreateGroup(m_dpnidPlayerID, m_dpnidOwnerID, &fRejectMsg);
		break;
		}

	//Destroy Group
	case DPN_MSGID_DESTROY_GROUP:
		{
			DPF(1,"-----DirectPlayClient8 Callback DestroyGroup\n");
			DPNMSG_DESTROY_GROUP	*msg = (DPNMSG_DESTROY_GROUP*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DWORD									m_dwReason = 0;
			
			m_dpnidPlayerID = msg->dpnidGroup;
			m_dwReason = msg->dwReason;
			

			lpEvent->DestroyGroup(m_dpnidPlayerID, m_dwReason, &fRejectMsg);
		break;
		}


	// Info
	case DPN_MSGID_PEER_INFO:
	case DPN_MSGID_CLIENT_INFO:
	case DPN_MSGID_SERVER_INFO:
	case DPN_MSGID_GROUP_INFO:
		{
			DPF(1,"-----DirectPlayClient8 Callback Info\n");
			DPNMSG_PEER_INFO	*msg = (DPNMSG_PEER_INFO*)pMsgBuffer;
			DPNID									m_dpnidInfoID = 0;
			
			m_dpnidInfoID = msg->dpnidPeer;

			lpEvent->InfoNotify(dwMessageId, m_dpnidInfoID, &fRejectMsg);
			break;
		}

	// EnumHostRes
	case DPN_MSGID_ENUM_HOSTS_RESPONSE:
		{
			DPF(1,"-----DirectPlayClient8 Callback EnumHostResponse\n");
			DPNMSG_ENUM_HOSTS_RESPONSE	*msg = (DPNMSG_ENUM_HOSTS_RESPONSE*)pMsgBuffer;
			DPNMSG_ENUM_HOSTS_RESPONSE_CDESC		m_dpEnumHostRes;
			DWORD									dwNumChars = 0;
			WCHAR* wszAddress = NULL;
			WCHAR* wszDevice = NULL;

			
			ZeroMemory(&m_dpEnumHostRes, sizeof(DPNMSG_ENUM_HOSTS_RESPONSE_CDESC));

			m_dpEnumHostRes.ApplicationDescription.lSize = (long)msg->pApplicationDescription->dwSize;
			m_dpEnumHostRes.ApplicationDescription.lFlags = msg->pApplicationDescription->dwFlags;
			m_dpEnumHostRes.ApplicationDescription.guidInstance = GUIDtoBSTR((GUID*)&msg->pApplicationDescription->guidInstance);
			m_dpEnumHostRes.ApplicationDescription.guidApplication = GUIDtoBSTR((GUID*)&msg->pApplicationDescription->guidApplication);
			m_dpEnumHostRes.ApplicationDescription.lMaxPlayers = (long)msg->pApplicationDescription->dwMaxPlayers;
			m_dpEnumHostRes.ApplicationDescription.lCurrentPlayers = (long)msg->pApplicationDescription->dwCurrentPlayers;
			m_dpEnumHostRes.ApplicationDescription.SessionName = SysAllocString(msg->pApplicationDescription->pwszSessionName);
			m_dpEnumHostRes.ApplicationDescription.Password = SysAllocString(msg->pApplicationDescription->pwszPassword);
			m_dpEnumHostRes.lRoundTripLatencyMS = (long) msg->dwRoundTripLatencyMS;

			__try {
				if (msg->pAddressSender)
				{
					DPF(1,"-----About to get AdressSender...\n");
					hr = msg->pAddressSender->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
                        wszAddress = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
						if (FAILED (hr = msg->pAddressSender->GetURLW(wszAddress,&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpEnumHostRes.AddressSenderUrl = SysAllocString(wszAddress);
						}
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumRes Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				if (msg->pAddressDevice)
				{
					DPF(1,"-----About to get AdressDevice...\n");
					hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else {
                        wszDevice = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
						if (FAILED (hr = msg->pAddressDevice->GetURLW(wszDevice,&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpEnumHostRes.AddressDeviceUrl = SysAllocString(wszDevice);
						}
					}
				}
			
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumRes Connect - Part1)...\n");
			}
			lpEvent->EnumHostsResponse(&m_dpEnumHostRes, &fRejectMsg);
			if (m_dpEnumHostRes.AddressSenderUrl)
				SysFreeString(m_dpEnumHostRes.AddressSenderUrl);

			if (m_dpEnumHostRes.AddressDeviceUrl)
				SysFreeString(m_dpEnumHostRes.AddressDeviceUrl);
		break;
		}

	// Indicate Connect
	case DPN_MSGID_INDICATED_CONNECT_ABORTED:
		{
			DPF(1,"-----DirectPlayServer8 Callback Indicated Connect Abort\n");

			lpEvent->IndicatedConnectAborted(&fRejectMsg);

		break;
		}
	}

	if (fCallCoUninit)
		CoUninitialize();

	InterlockedDecrement(&lpPeer->m_dwMsgCount);
	DPF(1,"-----Leaving (DPlayClient) MessageHandler call...\n");

	if (fRejectMsg != VARIANT_FALSE)
		return E_FAIL;

	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::EnumHosts(DPN_APPLICATION_DESC_CDESC *ApplicationDesc,I_dxj_DirectPlayAddress *AddrHost,I_dxj_DirectPlayAddress *DeviceInfo,long lRetryCount, long lRetryInterval, long lTimeOut,long lFlags, void *UserData, long UserDataSize, long *lAsync)
{
	HRESULT					hr;
	DPN_APPLICATION_DESC	desc;
	GUID					guidApp;
	GUID					guidInst;
    WCHAR					wszSessionName[MAX_PATH];
    WCHAR					wszPassword[MAX_PATH];
	DPNHANDLE				*dpAsync = NULL;

	__try {
		DPF(1,"-----Entering (DPlayClient) EnumHosts call...\n");

		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		if (!IsEmptyString(ApplicationDesc->SessionName)) wcscpy(wszSessionName,ApplicationDesc->SessionName);
		if (!IsEmptyString(ApplicationDesc->Password)) wcscpy(wszPassword,ApplicationDesc->Password);
		ZeroMemory(&desc, sizeof(desc));

		// Set up our Desc
		desc.dwSize = sizeof(DPN_APPLICATION_DESC);
		desc.dwFlags = ApplicationDesc->lFlags;

		desc.dwMaxPlayers = ApplicationDesc->lMaxPlayers;
		desc.dwCurrentPlayers = ApplicationDesc->lCurrentPlayers;
		if (!IsEmptyString(ApplicationDesc->SessionName))
			desc.pwszSessionName = wszSessionName;
		if (!IsEmptyString(ApplicationDesc->Password))
			desc.pwszPassword = wszPassword;

		if (ApplicationDesc->guidApplication)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&guidApp, ApplicationDesc->guidApplication) ) )
				return hr;
			desc.guidApplication = guidApp;
		}

		if (ApplicationDesc->guidInstance)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&guidInst, ApplicationDesc->guidInstance) ) )
				return hr;
			desc.guidInstance = guidInst;
		}

		// Get our host and device address
		IDirectPlay8Address	*lpHost = NULL;
		IDirectPlay8Address	*lpDevice = NULL;

		if(AddrHost) AddrHost->InternalGetObject((IUnknown **)(&lpHost));
		if(DeviceInfo) DeviceInfo->InternalGetObject((IUnknown **)(&lpDevice));

		hr = m__dxj_DirectPlayClient->EnumHosts(&desc, lpHost, lpDevice, UserData, UserDataSize, (DWORD) lRetryCount, (DWORD) lRetryInterval, (DWORD) lTimeOut, NULL,  dpAsync, (DWORD) lFlags);
		// This should return E_PENDING

		if (dpAsync)
		{
			*lAsync = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}

		if( hr != E_PENDING && FAILED(hr) )
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::CancelAsyncOperation(long lAsyncHandle, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) CancelAsyncOperation call...\n");
		if (FAILED( hr= m__dxj_DirectPlayClient->CancelAsyncOperation((DPNHANDLE) lAsyncHandle, (DWORD) lFlags) ) ) 
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::Connect(DPN_APPLICATION_DESC_CDESC *AppDesc,I_dxj_DirectPlayAddress *Address,I_dxj_DirectPlayAddress *DeviceInfo, long lFlags, void *UserData, long UserDataSize, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_APPLICATION_DESC	desc;
    WCHAR					wszSessionName[MAX_PATH];
    WCHAR					wszPassword[MAX_PATH];
	DPNHANDLE				*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DPlayClient) Connect call...\n");
		if (!IsEmptyString(AppDesc->SessionName)) wcscpy(wszSessionName,AppDesc->SessionName);
		if (!IsEmptyString(AppDesc->Password)) wcscpy(wszPassword,AppDesc->Password);

		ZeroMemory(&desc, sizeof(desc));

		// Set up our Desc
		desc.dwSize = sizeof(DPN_APPLICATION_DESC);
		desc.dwFlags = AppDesc->lFlags;

		desc.dwMaxPlayers = AppDesc->lMaxPlayers;
		desc.dwCurrentPlayers = AppDesc->lCurrentPlayers;
		if (!IsEmptyString(AppDesc->SessionName))
			desc.pwszSessionName = wszSessionName;
		if (!IsEmptyString(AppDesc->Password))
			desc.pwszPassword = wszPassword;

		if (AppDesc->guidApplication)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&desc.guidApplication, AppDesc->guidApplication) ) )
				return hr;
		}

		if (AppDesc->guidInstance)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&desc.guidInstance , AppDesc->guidInstance) ) )
				return hr;
		}

		// Get our host and device address
		IDirectPlay8Address	*lpAddress = NULL;
		IDirectPlay8Address	*lpDevice = NULL;

		if(Address) 
		{ 
			IUnknown *lpTemp = NULL;

			Address->InternalGetObject((IUnknown **)(&lpTemp));
			lpTemp->QueryInterface(IID_IDirectPlay8Address, (void**)&lpAddress);
			lpTemp->Release();
		}

		if(DeviceInfo) 
		{
			IUnknown *lpTemp = NULL;

			DeviceInfo->InternalGetObject((IUnknown **)(&lpTemp));
			lpTemp->QueryInterface(IID_IDirectPlay8Address, (void**)&lpDevice);
			lpTemp->Release();
		}

		// Time to connect
		hr = m__dxj_DirectPlayClient->Connect(&desc, lpAddress, lpDevice, NULL, NULL, UserData, (DWORD)UserDataSize, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::Send(SAFEARRAY **Buffer, long lTimeOut,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_BUFFER_DESC		lpBuf;
	DWORD				dwBufSize = ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		DPF(1,"-----Entering (DPlayClient) SendTo call...\n");

		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}
			
		lpBuf.dwBufferSize = dwBufSize;
		lpBuf.pBufferData  = (BYTE*)((SAFEARRAY*)*Buffer)->pvData;

		hr = m__dxj_DirectPlayClient->Send(&lpBuf, 1, (DWORD) lTimeOut, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetSendQueueInfo(long *lNumMsgs, long *lNumBytes, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetSendQueueInfo call...\n");
		if (FAILED (hr = m__dxj_DirectPlayClient->GetSendQueueInfo((DWORD*)lNumMsgs, (DWORD*)lNumBytes, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetApplicationDesc(long lFlags, DPN_APPLICATION_DESC_CDESC *ret)
{
	HRESULT					hr;
	DWORD					dwSize = 0;
	DPN_APPLICATION_DESC	*desc = NULL;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetApplicationDesc call...\n");
		hr= m__dxj_DirectPlayClient->GetApplicationDesc(NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		desc = (DPN_APPLICATION_DESC*)new BYTE[dwSize];
		if (!desc)
			return E_OUTOFMEMORY;

		if (!dwSize)
			return E_FAIL;

		desc->dwSize = sizeof(DPN_APPLICATION_DESC);

		hr= m__dxj_DirectPlayClient->GetApplicationDesc(desc, &dwSize, (DWORD) lFlags);
		if( FAILED(hr))
			return hr;

		// Now return the vals 
		ret->lSize = dwSize;
		ret->lFlags = desc->dwFlags;
		ret->guidInstance = GUIDtoBSTR(&desc->guidInstance);
		ret->guidApplication = GUIDtoBSTR(&desc->guidApplication);
		ret->lMaxPlayers = desc->dwMaxPlayers;
		ret->lCurrentPlayers = desc->dwCurrentPlayers;
		ret->SessionName = SysAllocString(desc->pwszSessionName);
		ret->Password = SysAllocString(desc->pwszPassword);

		SAFE_DELETE_ARRAY(desc);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::SetClientInfo(DPN_PLAYER_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_PLAYER_INFO dpInfo;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DPlayClient) SetClientInfo call...\n");
		ZeroMemory(&dpInfo, sizeof(DPN_PLAYER_INFO) );

		dpInfo.dwSize = sizeof(DPN_PLAYER_INFO);
		dpInfo.dwInfoFlags = PlayerInfo->lInfoFlags;
		dpInfo.pwszName = PlayerInfo->Name;
		dpInfo.dwPlayerFlags = PlayerInfo->lPlayerFlags;

		hr = m__dxj_DirectPlayClient->SetClientInfo(&dpInfo, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetServerInfo(long lFlags, DPN_PLAYER_INFO_CDESC *layerInfo)
{
	HRESULT				hr;
    DWORD				dwSize = 0;
    DPN_PLAYER_INFO		*PlayerInfo = NULL;
    
	__try {
		DPF(1,"-----Entering (DPlayClient) GetServerInfo call...\n");
		hr = m__dxj_DirectPlayClient->GetServerInfo( NULL, &dwSize, (DWORD) lFlags );
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		PlayerInfo = (DPN_PLAYER_INFO*) new BYTE[ dwSize ];
		if (!PlayerInfo)
			return E_OUTOFMEMORY;

		if (!dwSize)
			return E_FAIL;

		ZeroMemory( PlayerInfo, dwSize );
		PlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);
		hr = m__dxj_DirectPlayClient->GetServerInfo(PlayerInfo, &dwSize, (DWORD) lFlags );
		if( FAILED(hr) )
			return hr;

		layerInfo->lSize = sizeof(DPN_PLAYER_INFO_CDESC);
		layerInfo->lInfoFlags = PlayerInfo->dwInfoFlags;
		layerInfo->Name = SysAllocString(PlayerInfo->pwszName);
		layerInfo->lPlayerFlags = PlayerInfo->dwPlayerFlags;
		// We no longer need the playerinfo we got.. get rid of it..
		SAFE_DELETE_ARRAY(PlayerInfo);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::Close(long lFlags)
{
	HRESULT hr;
	BOOL bGotMsg = FALSE;
	BOOL bWait = FALSE;
	DWORD dwObj = 0;
	int i=0;
	MSG msg;
	HANDLE hThread = NULL;

	__try {
		DPF(1,"-----Entering (DPlayClient) Close call...\n");
		FlushBuffer(0);

		DWORD dwThread = 0;

		hThread = CreateThread(NULL, 0, CloseClientThreadProc, this->m__dxj_DirectPlayClient, 0, &dwThread);
		msg.message = WM_NULL;

		while ((WM_QUIT != msg.message) && (!bWait))
		{
			bGotMsg = PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE);
			i++;
			if ((!bGotMsg) || (i>10))
			{
				dwObj = WaitForSingleObject(hThread, 10);
				bWait = (dwObj == WAIT_OBJECT_0);
				i = 0;
			}
			if (bGotMsg)
			{
				TranslateMessage( &msg );
				DispatchMessage( &msg );
			}
			bGotMsg = FALSE;
		}


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	CloseHandle(hThread);
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::ReturnBuffer(long lBufferHandle)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) ReturnBuffer call...\n");
		if (FAILED(hr = m__dxj_DirectPlayClient->ReturnBuffer( (DPNHANDLE) lBufferHandle, 0 ) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetCaps(long lFlags, DPNCAPS_CDESC *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetCaps call...\n");
		ret->lSize = sizeof(DPN_CAPS);
		if (FAILED (hr=m__dxj_DirectPlayClient->GetCaps( (DPN_CAPS*) ret, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::SetCaps(DPNCAPS_CDESC *Caps, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) SetCaps call...\n");
		if (FAILED( hr = m__dxj_DirectPlayClient->SetCaps((DPN_CAPS*)Caps, (DWORD)lFlags)))
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetCountServiceProviders(long lFlags, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetCountServiceProviders call...\n");
		if (!m_SPInfo)
			if (FAILED (hr=GetSP(lFlags) ) )
				return hr;
		
		*ret = (long)m_dwSPCount;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetServiceProvider(long lIndex, DPN_SERVICE_PROVIDER_INFO_CDESC *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetServiceProvider call...\n");
		if (!m_SPInfo)
			if (FAILED (hr=GetSP(0) ) )
				return hr;

		if ((lIndex < 1 ) || ((DWORD)lIndex > m_dwSPCount))
			return E_INVALIDARG;

		// Fill out our structure
		ret->lFlags = (long) m_SPInfo[lIndex-1].dwFlags;
		ret->Name = SysAllocString(m_SPInfo[lIndex-1].pwszName);
		ret->Guid = GUIDtoBSTR(&m_SPInfo[lIndex-1].guid);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetSP(long lFlags)
{
    // Enumerate all DirectPlay sevice providers
    
	HRESULT		hr;
	DWORD		dwSize=0;
	DWORD		dwItems=0;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetSP call...\n");
		SAFE_DELETE_ARRAY(m_SPInfo);
		hr = m__dxj_DirectPlayClient->EnumServiceProviders( NULL, NULL, m_SPInfo, &dwSize, 
										  &dwItems, (DWORD) lFlags );
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		m_SPInfo = (DPN_SERVICE_PROVIDER_INFO*) new BYTE[dwSize];
		if (!m_SPInfo)
			return E_OUTOFMEMORY;

		if( FAILED( hr = m__dxj_DirectPlayClient->EnumServiceProviders( NULL, NULL, m_SPInfo, &dwSize, 
										  &dwItems, (DWORD) lFlags) ) )
			return hr;

		m_dwSPCount = dwItems;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::RegisterLobby(long dpnHandle, I_dxj_DirectPlayLobbiedApplication *LobbyApp, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) RegisterLobby call...\n");
		DO_GETOBJECT_NOTNULL( IDirectPlay8LobbiedApplication*, lpLobby, LobbyApp);

		if (FAILED( hr = m__dxj_DirectPlayClient->RegisterLobby((DPNHANDLE) dpnHandle, lpLobby,(DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetConnectionInfo(long lFlags, DPN_CONNECTION_INFO_CDESC *pdpConnectionInfo)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetConnectionInfo call...\n");
		pdpConnectionInfo->lSize = sizeof(DPN_CONNECTION_INFO);
		if (FAILED( hr = m__dxj_DirectPlayClient->GetConnectionInfo((DPN_CONNECTION_INFO*)pdpConnectionInfo, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetServerAddress(long lFlags, I_dxj_DirectPlayAddress **pAddress)
{
	IDirectPlay8Address	*lpAdd = NULL;
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetServerAddress call...\n");
		if (FAILED (hr = m__dxj_DirectPlayClient->GetServerAddress( &lpAdd, (DWORD) lFlags) ) )
			return hr;

		INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayAddress,lpAdd, pAddress);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::SetSPCaps(BSTR guidSP, DPN_SP_CAPS_CDESC *spCaps, long lFlags)
{
	HRESULT hr;
	GUID guidServiceProvider;

	__try {
		DPF(1,"-----Entering (DPlayClient) SetSPCaps call...\n");
		if (FAILED(hr = DPLAYBSTRtoGUID(&guidServiceProvider, guidSP) ) )
			return hr;

		spCaps->lSize = sizeof(DPN_SP_CAPS);
		//
		//	MiNara: Added 0 for dwFlags parameter
		//
		if (FAILED(hr = m__dxj_DirectPlayClient->SetSPCaps(&guidServiceProvider,(DPN_SP_CAPS*)spCaps,(DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetSPCaps(BSTR guidSP, long lFlags, DPN_SP_CAPS_CDESC *spCaps)
{
	HRESULT hr;
	GUID guidServiceProvider;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetSPCaps call...\n");
		spCaps->lSize = sizeof(DPN_SP_CAPS);

		if (FAILED(hr = DPLAYBSTRtoGUID(&guidServiceProvider, guidSP) ) )
			return hr;

		if (FAILED(hr = m__dxj_DirectPlayClient->GetSPCaps(&guidServiceProvider,(DPN_SP_CAPS*)spCaps, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::RegisterMessageHandler(I_dxj_DirectPlayEvent *event)
{
    HRESULT	  hr=S_OK;
    LPSTREAM  pStm=NULL;

	DPF(1,"-----Entering (DPlayClient) RegisterMessageHandler call...\n");
	if (!event) return E_INVALIDARG;
    
    if (!m_fHandleEvents)
	{
		DPF(1,"-----(DPlayClient) RegisterMessageHandler call (We are not handling events currently)...\n");
		if (m_pEventStream) 
			m_pEventStream->Release();

		DPF(1,"-----(DPlayClient) RegisterMessageHandler call (CreateStream)...\n");
		hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);
		if FAILED(hr) return hr;

		DPF(1,"-----(DPlayClient) RegisterMessageHandler call (Marshall VB Event interface)...\n");
		hr = CoMarshalInterface(pStm, IID_I_dxj_DirectPlayEvent, event, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLEWEAK);
		if FAILED(hr) return hr;

		// Now we need to set the seek location of the stream to the beginning
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStm->Seek(l, STREAM_SEEK_SET, NULL);
    
		m_pEventStream=pStm;

		DPF(1,"-----(DPlayClient) RegisterMessageHandler call (Call DPlayInit)...\n");
		if (!m_fInit)
		{
			if (FAILED ( hr = m__dxj_DirectPlayClient->Initialize( this, DirectPlayClientMessageHandler, 0 ) ) )
				return hr;
			m_fInit = TRUE;
		}
		m_fHandleEvents = TRUE;
	}
	else
		return DPNERR_ALREADYINITIALIZED;

	return hr;
}

HRESULT C_dxj_DirectPlayClientObject::UnRegisterMessageHandler()
{
	DPF(1,"-----Entering (DPlayClient) UnregisterMessageHandler call...\n");
	m_fHandleEvents = FALSE;
	//Clear out the messages currently waiting
	FlushBuffer(0);
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::FlushBuffer(LONG dwNumMessagesLeft)
{
	
	DWORD dwTime = GetTickCount();

	DPF(1,"-----Entering (DPlayClient) FlushBuffer call...\n");
	//Clear out the messages currently waiting
	BOOL bGotMsg = FALSE; 
	BOOL bWait = FALSE; 
	int i=0; 
	MSG msg; 
	HRESULT hr = S_OK; 
	msg.message = WM_NULL; 
	while ((WM_QUIT != msg.message) && (m_dwMsgCount > dwNumMessagesLeft)) 
	{ 
		bGotMsg = PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE); 
		i++; 
		if (GetTickCount() - dwTime > 5000)
		{
			// Don't let FlushBuffer wait more than 5 seconds
			DPF1(1,"-----Leaving (DplayPeer) FlushBuffer call (All messages *not* flushed - %d remained)...\n", m_dwMsgCount);
			return S_OK;
		}
		if (bGotMsg) 
		{ 
			TranslateMessage( &msg ); 
			DispatchMessage( &msg ); 
		} 
		bGotMsg = FALSE; 
		Sleep(0);
	} 
	DPF(1,"-----Leaving (DPlayClient) FlushBuffer call (All messages flushed)...\n");
	return S_OK;
}

DWORD WINAPI CloseClientThreadProc(void* lpParam)
{
	// User context for the message handler is a pointer to our class module.
	IDirectPlay8Client	*lpPeer = (IDirectPlay8Client*)lpParam;

	DPF(1,"-----Entering (DplayPeer) CloseClientThreadProc call...\n");
	lpPeer->Close(0);
	DPF(1,"-----Leaving (DplayPeer) CloseClientThreadProc call ...\n");
	return 0;
}
DWORD WINAPI ReleaseClientThreadProc(void* lpParam)
{
	// User context for the message handler is a pointer to our class module.
	IDirectPlay8Client	*lpPeer = (IDirectPlay8Client*)lpParam;

	DPF(1,"-----Entering (DplayPeer) ReleaseClientThreadProc call...\n");
	SAFE_RELEASE(lpPeer);
	DPF(1,"-----Leaving (DplayPeer) ReleaseClientThreadProc call ...\n");
	CloseHandle(GetCurrentThread());
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplaylobbiedappobj.h ===
#include "resource.h"       // main symbols
#include "dplobby8.h"

#define typedef__dxj_DirectPlayLobbiedApplication IDirectPlay8LobbiedApplication*

/////////////////////////////////////////////////////////////////////////////
// Direct Net Peer

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayLobbiedApplicationObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayLobbiedApplication, &IID_I_dxj_DirectPlayLobbiedApplication, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayLobbiedApplication,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayLobbiedApplicationObject() ;
	virtual ~C_dxj_DirectPlayLobbiedApplicationObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayLobbiedApplicationObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayLobbiedApplication)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayLobbiedApplicationObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayLobbiedApplication
public:
	 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE RegisterMessageHandler(I_dxj_DirectPlayLobbyEvent *lobbyEvent, long *lDPNHandle);
		HRESULT STDMETHODCALLTYPE RegisterProgram(DPL_PROGRAM_DESC_CDESC *ProgramDesc,long lFlags);
		HRESULT STDMETHODCALLTYPE UnRegisterProgram(BSTR guidApplication,long lFlags);
		HRESULT STDMETHODCALLTYPE Send(long Target,SAFEARRAY **Buffer,long lBufferSize,long lFlags);
		HRESULT STDMETHODCALLTYPE SetAppAvailable(VARIANT_BOOL fAvailable, long lFlags);
		HRESULT STDMETHODCALLTYPE UpdateStatus(long LobbyClient, long lStatus);
		HRESULT STDMETHODCALLTYPE Close();
		HRESULT STDMETHODCALLTYPE UnRegisterMessageHandler();
		HRESULT STDMETHODCALLTYPE GetConnectionSettings(long hLobbyClient, long lFlags, DPL_CONNECTION_SETTINGS_CDESC *ConnectionSettings);	
		HRESULT STDMETHODCALLTYPE SetConnectionSettings(long hTarget, long lFlags, DPL_CONNECTION_SETTINGS_CDESC *ConnectionSettings, I_dxj_DirectPlayAddress *HostAddress, I_dxj_DirectPlayAddress *Device);
		HRESULT STDMETHODCALLTYPE GetVBConnSettings(DPL_CONNECTION_SETTINGS *OldCon, DPL_CONNECTION_SETTINGS_CDESC *NewCon);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayLobbiedApplication);

private:
	BOOL						m_fInit;

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayLobbiedApplication);

	DWORD InternalAddRef();
	DWORD InternalRelease();

	BOOL									m_fHandleEvents;
	IStream									*m_pEventStream;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplaylobbyclientobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPlayLobbyClientObj.h"					   
#include "DplayAddressObj.h"

extern HRESULT DPLAYBSTRtoGUID(LPGUID,BSTR);
extern void *g_dxj_DirectPlayLobbyClient;
extern void *g_dxj_DirectPlayAddress;

extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BOOL IsEmptyString(BSTR szString);

#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }
#define SAFE_RELEASE(p)      { __try { if(p) { (p)->Release(); (p)=NULL;} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { (p) = NULL;} } 

DWORD WINAPI CloseLobbyClientThreadProc(void* lpParam);

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayLobbyClientObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF1(1,"------ DXVB: DirectPlayLobbyClient8 AddRef %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayLobbyClientObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF1(1,"------ DXVB: DirectPlayLobbyClient8 Release %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayLobbyClientObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayLobbyClientObject::C_dxj_DirectPlayLobbyClientObject(){ 
		
	DPF(1,"------ DXVB: Constructor Creation  DirectPlayLobbyClient8 Object \n ");

	m__dxj_DirectPlayLobbyClient = NULL;
    m_ProgInfo = NULL;
	m_dwAppCount = 0;
	 	
	m_fInit = FALSE;

	m_pUserData = NULL;
	m_dwUserDataSize = 0;
	m_fHandleEvents = FALSE;

	m_pEventStream=NULL;
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayLobbyClientObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayLobbyClientObject::~C_dxj_DirectPlayLobbyClientObject()
{

	DPF(1,"------ DXVB: Entering ~C_dxj_DirectPlayLobbyClientObject destructor \n");
	SAFE_RELEASE(m__dxj_DirectPlayLobbyClient);
    SAFE_DELETE(m_ProgInfo)
	m_fHandleEvents = FALSE;

	if (m_pEventStream) 
		m_pEventStream->Release();

}

HRESULT C_dxj_DirectPlayLobbyClientObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayLobbyClient;
	
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayLobbyClient=(IDirectPlay8LobbyClient*)pUnk;
	return S_OK;
}

HRESULT WINAPI DirectPlayLobbyClientMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer )
{
	HRESULT					hr=S_OK;
	BOOL					fCallCoUninit = FALSE;
	VARIANT_BOOL			fRejectMsg = VARIANT_FALSE;

	// User context for the message handler is a pointer to our class module.
	C_dxj_DirectPlayLobbyClientObject	*lpPeer = (C_dxj_DirectPlayLobbyClientObject*)pvUserContext;
	DPF(1,"-----Entering (DPlayLobbyClient) MessageHandler call...\n");
	
	if (!lpPeer) return E_FAIL;
	if (!lpPeer->m_pEventStream) return E_FAIL;

	if (!lpPeer->m_fHandleEvents)
		return S_OK;

	// First we need to set our stream seek back to the beginning
	// We will do this every time we enter this function since we don't know if
	// we are on the same thread or not...
		I_dxj_DirectPlayLobbyEvent	*lpEvent = NULL;
	__try {
		LARGE_INTEGER l;
		l.QuadPart = 0;
		lpPeer->m_pEventStream->Seek(l, STREAM_SEEK_SET, NULL);

		hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
		if (hr == CO_E_NOTINITIALIZED) // Call CoInit so we can unmarshal
		{
			CoInitialize(NULL);
			hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
			fCallCoUninit = TRUE;
		}

		if (!lpEvent) 
		{
			DPF(1,"-----Leaving (DplayLobbyClient) MessageHandler call (No event interface)...\n");
			return hr;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		DPF(1,"-----Leaving (DplayLobbyClient) MessageHandler call (Stream Gone)...\n");
		return S_OK;
	}

    switch( dwMessageId )
	{
	//Receive
	case DPL_MSGID_RECEIVE:
		{
			DPL_MESSAGE_RECEIVE			*msg = (DPL_MESSAGE_RECEIVE*)pMsgBuffer;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			DPL_MESSAGE_RECEIVE_CDESC	m_dpReceive;
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpReceive, sizeof(DPL_MESSAGE_RECEIVE_CDESC));
			m_dpReceive.Sender = (long)msg->hSender;
			
			// Let's load our SafeArray

			if (msg->dwBufferSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwBufferSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pBuffer;
				m_dpReceive.lBufferSize = msg->dwBufferSize;
				m_dpReceive.Buffer = lpData;
			}

			lpEvent->Receive(&m_dpReceive, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}
			
			break;
		}

	//Connect
	case DPL_MSGID_CONNECT:
		{
			DPL_MESSAGE_CONNECT				*msg = (DPL_MESSAGE_CONNECT*)pMsgBuffer;
			DPNHANDLE						m_hConnectID;
			DPL_MESSAGE_CONNECT_CDESC		m_dpConnection;
			SAFEARRAY						*lpData = NULL;
			SAFEARRAYBOUND					rgsabound[1];
			WCHAR* wszAddress = NULL;
			WCHAR* wszDevice = NULL;
			DWORD									dwNumChars = 0;
			BYTE						*lpTemp = NULL;

			m_dpConnection.ConnectId = (long)msg->hConnectId;
			// Let's load our SafeArray

			if (msg->dwLobbyConnectDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwLobbyConnectDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pvLobbyConnectData;
				m_dpConnection.LobbyConnectData = lpData;
			}

			lpPeer->GetVBConnSettings(msg->pdplConnectionSettings, &m_dpConnection.dplMsgCon);

			__try {
				hr = msg->pdplConnectionSettings->pdp8HostAddress->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					return hr;

                wszAddress = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
				if (FAILED (hr = msg->pdplConnectionSettings->pdp8HostAddress->GetURLW(wszAddress,&dwNumChars) ) )
					return hr;

				m_dpConnection.dplMsgCon.AddressSenderUrl = SysAllocString(wszAddress);
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// Just skip this part
			}

			__try {
				dwNumChars = 0;
				hr = ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					return hr;

                wszDevice = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
				if (FAILED (hr = ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)->GetURLW(wszDevice,&dwNumChars) ) )
					return hr;

				m_dpConnection.dplMsgCon.AddressDeviceUrl = SysAllocString(wszDevice);
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// Just skip this part
			}

			lpEvent->Connect(&m_dpConnection, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}

			// Get rid of these addresses
			if (m_dpConnection.dplMsgCon.AddressSenderUrl)
				SysFreeString(m_dpConnection.dplMsgCon.AddressSenderUrl);

			if (m_dpConnection.dplMsgCon.AddressDeviceUrl)
				SysFreeString(m_dpConnection.dplMsgCon.AddressDeviceUrl);
			
		break;
		}

	//Disconnect
	case DPL_MSGID_DISCONNECT:
		{
			DPL_MESSAGE_DISCONNECT				*msg = (DPL_MESSAGE_DISCONNECT*)pMsgBuffer;
			DPNHANDLE								m_hDisconnectID;
			HRESULT									m_hDisconnectReason;

			m_hDisconnectID = (long)msg->hDisconnectId;
			m_hDisconnectReason = (long) msg->hrReason;

			lpEvent->Disconnect(m_hDisconnectID, m_hDisconnectReason);
			
			break;
		}

	//Status
	case DPL_MSGID_SESSION_STATUS:
		{
			DPL_MESSAGE_SESSION_STATUS			*msg = (DPL_MESSAGE_SESSION_STATUS*)pMsgBuffer;
			DPNHANDLE								m_hSender;
			DWORD									m_dwSessionStatus;

			m_dwSessionStatus = (long)msg->dwStatus;
			m_hSender = (long)msg->hSender;
	
			lpEvent->SessionStatus(m_dwSessionStatus,m_hSender);

		break;
		}

	//ConnectionSettings
	case DPL_MSGID_CONNECTION_SETTINGS:
		{
			DPL_MESSAGE_CONNECTION_SETTINGS			*msg = (DPL_MESSAGE_CONNECTION_SETTINGS*)pMsgBuffer;
			DPL_MESSAGE_CONNECTION_SETTINGS_CDESC	dpCon;
			WCHAR* wszAddress = NULL;
			WCHAR* wszDevice = NULL;
			DWORD									dwNumChars = 0;

			ZeroMemory(&dpCon, sizeof(DPL_MESSAGE_CONNECTION_SETTINGS_CDESC));

			lpPeer->GetVBConnSettings(msg->pdplConnectionSettings, &dpCon.dplConnectionSettings);
			dpCon.hSender = (long)msg->hSender;
			__try {
				hr = msg->pdplConnectionSettings->pdp8HostAddress->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					return hr;

                wszAddress = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
				if (FAILED (hr = msg->pdplConnectionSettings->pdp8HostAddress->GetURLW(wszAddress,&dwNumChars) ) )
					return hr;

				dpCon.dplConnectionSettings.AddressSenderUrl = SysAllocString(wszAddress);
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// Just skip this part
			}

			__try {
				dwNumChars = 0;
				hr = ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					return hr;

                wszDevice = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
				if (FAILED (hr = ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)->GetURLW(wszDevice,&dwNumChars) ) )
					return hr;

				dpCon.dplConnectionSettings.AddressDeviceUrl = SysAllocString(wszDevice);
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// Just skip this part
			}
			lpEvent->ConnectionSettings(&dpCon);
			// Get rid of these addresses
			if (dpCon.dplConnectionSettings.AddressSenderUrl)
				SysFreeString(dpCon.dplConnectionSettings.AddressSenderUrl);

			if (dpCon.dplConnectionSettings.AddressDeviceUrl)
				SysFreeString(dpCon.dplConnectionSettings.AddressDeviceUrl);

		break;
		}
	}

	__try {
		if (lpPeer->m_pEventStream)
				// clean up marshaled packet
			CoReleaseMarshalData(lpPeer->m_pEventStream);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		return S_OK;
	}

	if (fCallCoUninit)
		CoUninitialize();

	DPF(1,"-----Leaving (DPlayLobbyClient) MessageHandler call...\n");

	if (fRejectMsg != VARIANT_FALSE)
		return E_FAIL;

	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::RegisterMessageHandler(I_dxj_DirectPlayLobbyEvent *lobbyEvent)
{
    HRESULT	  hr=S_OK;
    LPSTREAM  pStm=NULL;

	DPF(1,"-----Entering (DPlayLobbyClient) RegisterMessageHandler call...\n");
	if (!lobbyEvent) return E_INVALIDARG;
    
    if (!m_fHandleEvents)
	{
		if (m_pEventStream) 
			m_pEventStream->Release();


		// Create a global stream.  The stream needs to be global so we can 
		// marshal once, and unmarshal as many times as necessary
		hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);
		if FAILED(hr) return hr;

		// Now we can marshal our IUnknown interface.  We use MSHLFLAGS_TABLEWEAK 
		// so we can unmarshal any number of times
		hr = CoMarshalInterface(pStm, IID_I_dxj_DirectPlayLobbyEvent, lobbyEvent, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLEWEAK);
		if FAILED(hr) return hr;

		// Now we need to set the seek location of the stream to the beginning
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStm->Seek(l, STREAM_SEEK_SET, NULL);
    
		m_pEventStream=pStm;

		if (!m_fInit)
		{
			if (FAILED ( hr = m__dxj_DirectPlayLobbyClient->Initialize( this, DirectPlayLobbyClientMessageHandler, 0 ) ) )
				return hr;
			m_fInit = TRUE;
		}
		m_fHandleEvents = TRUE;
	}
	else
		return DPNERR_ALREADYINITIALIZED;

	return hr;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::GetCountLocalPrograms(BSTR GuidApplication,long *lCount)
{
	GUID *guidApp = NULL;
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayLobbyClient) GetCountLocalPrograms call...\n");
		if (!IsEmptyString(GuidApplication))
		{
			guidApp = new GUID;
			if (FAILED (hr = BSTRtoGUID(guidApp,GuidApplication) ) )
				return hr;
		}

		if (FAILED (hr = GetProgs(guidApp) ) )
			return hr;

		if (guidApp)
			SAFE_DELETE(guidApp);

		*lCount = (long)m_dwAppCount;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::GetLocalProgram(long lProgID, DPL_APPLICATION_INFO_CDESC *app)
{
	__try {
		DPF(1,"-----Entering (DPlayLobbyClient) GetLocalProgram call...\n");
		if (!m_ProgInfo)
			return E_INVALIDARG;

		if ((lProgID < 1 ) || ((DWORD)lProgID > m_dwAppCount))
			return E_INVALIDARG;

		// Now we've got to fill our DPL_PROGRAM_DESC_CDESC structure
		//app->lSize = m_ProgInfo[lProgID - 1].dwSize;
		app->lFlags = m_ProgInfo[lProgID - 1].dwFlags;
		app->ApplicationName = SysAllocString(m_ProgInfo[lProgID - 1].pwszApplicationName);
		app->guidApplication = GUIDtoBSTR(&m_ProgInfo[lProgID - 1].guidApplication);
		app->lNumRunning = m_ProgInfo[lProgID - 1].dwNumRunning;
		app->lNumWaiting = m_ProgInfo[lProgID - 1].dwNumWaiting;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::ConnectApplication(DPL_CONNECT_INFO_CDESC *ConnectionInfo,long lTimeOut,long lFlags, long *hApplication)
{
	HRESULT				hr;
	DPL_CONNECT_INFO	dplConnect;
	DPNHANDLE			hApp = NULL;

	__try {
		DPF(1,"-----Entering (DPlayLobbyClient) ConnectApplication call...\n");
		ZeroMemory(&dplConnect,sizeof(DPL_CONNECT_INFO));
		// Fill out our connection structure

		dplConnect.dwSize = sizeof(DPL_CONNECT_INFO);
		dplConnect.dwFlags = ConnectionInfo->lFlags;
		if (FAILED (hr = BSTRtoGUID(&dplConnect.guidApplication,ConnectionInfo->guidApplication) ) )
			return hr;

		if (FAILED (hr = m__dxj_DirectPlayLobbyClient->ConnectApplication(&dplConnect,NULL, &hApp, (DWORD) lTimeOut, (DWORD) lFlags) ) )
			return hr;

		*hApplication = (long)hApp;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::Send(long Target,SAFEARRAY **Buffer,long lBufferSize,long lFlags)
{
	HRESULT hr;
	BYTE				*lpBuf = NULL;
	DWORD				dwBufferSize = 0;

	__try {
		DPF(1,"-----Entering (DPlayLobbyClient) Send call...\n");
		dwBufferSize = (DWORD)lBufferSize;

		hr = m__dxj_DirectPlayLobbyClient->Send((DPNHANDLE) Target, (BYTE*) ((SAFEARRAY*)*Buffer)->pvData, dwBufferSize, (DWORD) lFlags);
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::ReleaseApplication(long Application)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayLobbyClient) ReleaseApplication call...\n");
		if (FAILED (hr = m__dxj_DirectPlayLobbyClient->ReleaseApplication( (DPNHANDLE) Application, 0 ) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::Close()
{
	HRESULT hr;
	BOOL bGotMsg = FALSE;
	BOOL bWait = FALSE;
	DWORD dwObj = 0;
	int i=0;
	MSG msg;

	__try {
		DPF(1,"-----Entering (DPlayLobbyClient) Close call...\n");
		HANDLE hThread = NULL;
		DWORD dwThread = 0;

		hThread = CreateThread(NULL, 0, &CloseLobbyClientThreadProc, this->m__dxj_DirectPlayLobbyClient, 0, &dwThread);
		msg.message = WM_NULL;

		while ((WM_QUIT != msg.message) && (!bWait))
		{
			bGotMsg = PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE);
			i++;
			if ((!bGotMsg) || (i>10))
			{
				dwObj = WaitForSingleObject(hThread, 10);
				bWait = (dwObj == WAIT_OBJECT_0);
				i = 0;
			}
			if (bGotMsg)
			{
				TranslateMessage( &msg );
				DispatchMessage( &msg );
			}
			bGotMsg = FALSE;
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::GetProgs(GUID *guidApp)
{
    // Enumerate all DirectPlay Local Progs
    
	HRESULT		hr;
	DWORD		dwSize=0;
	DWORD		dwItems=0;
	
	__try {
		DPF(1,"-----Entering (DPlayLobbyClient) GetProgs call...\n");
		hr = m__dxj_DirectPlayLobbyClient->EnumLocalPrograms( guidApp, (BYTE*)m_ProgInfo, &dwSize, &dwItems, 0);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		m_ProgInfo = (DPL_APPLICATION_INFO*) new BYTE[dwSize];
		if( FAILED( hr = m__dxj_DirectPlayLobbyClient->EnumLocalPrograms( guidApp, (BYTE*)m_ProgInfo, &dwSize, &dwItems, 0) ) )
			return hr;

		m_dwAppCount = dwItems;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}


HRESULT C_dxj_DirectPlayLobbyClientObject::UnRegisterMessageHandler()
{
	DPF(1,"-----Entering (DPlayLobbyClient) UnregisterMessageHandler call...\n");
	m_fHandleEvents = FALSE;
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::GetConnectionSettings(long hLobbyClient, long lFlags, DPL_CONNECTION_SETTINGS_CDESC *ConnectionSettings)
{
	DPL_CONNECTION_SETTINGS	*desc = NULL;
	DWORD					dwSize = 0;
	HRESULT					hr = S_OK;
	WCHAR* wszAddress = NULL;
	WCHAR* wszDevice = NULL;
	DWORD									dwNumChars = 0;

	__try {
		hr= m__dxj_DirectPlayLobbyClient->GetConnectionSettings((DPNHANDLE) hLobbyClient, NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		desc = (DPL_CONNECTION_SETTINGS*)new BYTE[dwSize];
		desc->dwSize = sizeof(DPL_CONNECTION_SETTINGS);

		hr= m__dxj_DirectPlayLobbyClient->GetConnectionSettings((DPNHANDLE) hLobbyClient, desc, &dwSize, (DWORD) lFlags);
		if( FAILED(hr))
			return hr;

		__try {
			hr = desc->pdp8HostAddress->GetURLW(NULL, &dwNumChars);
			if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				return hr;

            wszAddress = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
			if (FAILED (hr = desc->pdp8HostAddress->GetURLW(wszAddress,&dwNumChars) ) )
				return hr;

			ConnectionSettings->AddressSenderUrl = SysAllocString(wszAddress);
		}	
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			// Just skip this part
		}

		__try {
			dwNumChars = 0;
			hr = ((IDirectPlay8Address*)*desc->ppdp8DeviceAddresses)->GetURLW(NULL, &dwNumChars);
			if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				return hr;

            wszDevice = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
			if (FAILED (hr = ((IDirectPlay8Address*)*desc->ppdp8DeviceAddresses)->GetURLW(wszDevice,&dwNumChars) ) )
				return hr;

			ConnectionSettings->AddressDeviceUrl = SysAllocString(wszDevice);
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			// Just skip this part
		}

		GetVBConnSettings(desc, ConnectionSettings);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::SetConnectionSettings(long hTarget, long lFlags, DPL_CONNECTION_SETTINGS_CDESC *ConnectionSettings, I_dxj_DirectPlayAddress *HostAddress, I_dxj_DirectPlayAddress *Device)
{
	DPL_CONNECTION_SETTINGS	desc;
	HRESULT					hr = S_OK;
	GUID					guidApp;
	GUID					guidInst;
    WCHAR					wszSessionName[MAX_PATH];
    WCHAR					wszPassword[MAX_PATH];

	__try {
		ZeroMemory(&desc, sizeof(DPL_CONNECTION_SETTINGS));
		desc.dwSize = sizeof(DPL_CONNECTION_SETTINGS);
		desc.dwFlags = ConnectionSettings->lFlags;
		HostAddress->InternalGetObject((IUnknown**)&desc.pdp8HostAddress);
		Device->InternalGetObject((IUnknown**)desc.ppdp8DeviceAddresses);

		ZeroMemory(&desc.dpnAppDesc, sizeof(DPN_APPLICATION_DESC));

		// Set up our Desc
		desc.dpnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);

		if (!IsEmptyString(ConnectionSettings->ApplicationDescription.SessionName)) 
		{
			wcscpy(wszSessionName,ConnectionSettings->ApplicationDescription.SessionName);
			desc.dpnAppDesc.pwszSessionName = wszSessionName;
		}
		if (!IsEmptyString(ConnectionSettings->ApplicationDescription.Password)) 
		{
			wcscpy(wszPassword,ConnectionSettings->ApplicationDescription.Password);
			desc.dpnAppDesc.pwszPassword = wszPassword;
		}

		desc.dpnAppDesc.dwFlags = ConnectionSettings->ApplicationDescription.lFlags;

		desc.dpnAppDesc.dwMaxPlayers = ConnectionSettings->ApplicationDescription.lMaxPlayers;
		desc.dpnAppDesc.dwCurrentPlayers = ConnectionSettings->ApplicationDescription.lCurrentPlayers;

		if (FAILED(hr = DPLAYBSTRtoGUID(&guidApp, ConnectionSettings->ApplicationDescription.guidApplication) ) )
			return hr;
		desc.dpnAppDesc.guidApplication = guidApp;

		if (FAILED(hr = DPLAYBSTRtoGUID(&guidInst, ConnectionSettings->ApplicationDescription.guidInstance) ) )
			return hr;
		desc.dpnAppDesc.guidInstance = guidInst;
		
		hr= m__dxj_DirectPlayLobbyClient->SetConnectionSettings((DPNHANDLE) hTarget, &desc, (DWORD) lFlags);
		if( FAILED(hr))
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::GetVBConnSettings(DPL_CONNECTION_SETTINGS *OldCon, DPL_CONNECTION_SETTINGS_CDESC *NewCon)
{
	IDirectPlay8Address *dpAdd = NULL;
	HRESULT hr;

	__try {
		NewCon->lSize = OldCon->dwSize;
		NewCon->lFlags = OldCon->dwFlags;
		NewCon->PlayerName = SysAllocString(OldCon->pwszPlayerName);

		ZeroMemory(&NewCon->ApplicationDescription, sizeof(DPN_APPLICATION_DESC_CDESC));

		// Set up our Desc
		NewCon->ApplicationDescription.lSize = OldCon->dpnAppDesc.dwSize;
		NewCon->ApplicationDescription.SessionName = SysAllocString(OldCon->dpnAppDesc.pwszSessionName);
		NewCon->ApplicationDescription.Password = SysAllocString(OldCon->dpnAppDesc.pwszPassword);
		NewCon->ApplicationDescription.lFlags = OldCon->dpnAppDesc.dwFlags;
		NewCon->ApplicationDescription.lMaxPlayers = OldCon->dpnAppDesc.dwMaxPlayers;
		NewCon->ApplicationDescription.lCurrentPlayers = OldCon->dpnAppDesc.dwCurrentPlayers;
		NewCon->ApplicationDescription.guidApplication = GUIDtoBSTR(&OldCon->dpnAppDesc.guidApplication);
		NewCon->ApplicationDescription.guidInstance = GUIDtoBSTR(&OldCon->dpnAppDesc.guidInstance);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

DWORD WINAPI CloseLobbyClientThreadProc(void* lpParam)
{
	// User context for the message handler is a pointer to our class module.
	IDirectPlay8LobbyClient	*lpPeer = (IDirectPlay8LobbyClient*)lpParam;

	DPF(1,"-----Entering (DPlayLobbiedApp) ClosePeerThreadProc call...\n");
	lpPeer->Close(0);
	DPF(1,"-----Leaving (DPlayLobbiedApp) ClosePeerThreadProc call ...\n");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplaylobbiedappobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPlayLobbiedAppObj.h"					   
#include "DplayAddressObj.h"

extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern HRESULT DPLAYBSTRtoGUID(LPGUID,BSTR);
extern BOOL IsEmptyString(BSTR szString);

extern void *g_dxj_DirectPlayLobbiedApplication;
extern void *g_dxj_DirectPlayAddress;

#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }
#define SAFE_RELEASE(p)      { __try { if(p) { (p)->Release(); (p)=NULL;} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { (p) = NULL;} } 

DWORD WINAPI CloseLobbiedAppThreadProc(void* lpParam);

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayLobbiedApplicationObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF1(1,"------ DXVB: DirectPlayLobbiedApplication8 AddRef %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayLobbiedApplicationObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF1(1,"------ DXVB: DirectPlayLobbiedApplication8 Release %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayLobbiedApplicationObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayLobbiedApplicationObject::C_dxj_DirectPlayLobbiedApplicationObject(){ 
		
	DPF(1,"------ DXVB: Constructor Creation DirectPlayLobbiedApplication8 \n ");

	m__dxj_DirectPlayLobbiedApplication = NULL;
	m_fInit = FALSE;

	m_fHandleEvents = FALSE;
	m_pEventStream=NULL;
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayLobbiedApplicationObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayLobbiedApplicationObject::~C_dxj_DirectPlayLobbiedApplicationObject()
{

	DPF(1,"------ DXVB: Entering ~C_dxj_DirectPlayLobbiedApplicationObject destructor \n");

	SAFE_RELEASE(m__dxj_DirectPlayLobbiedApplication);

	m_fHandleEvents = FALSE;

	if (m_pEventStream) 
		m_pEventStream->Release();
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayLobbiedApplication;
	
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayLobbiedApplication=(IDirectPlay8LobbiedApplication*)pUnk;
	return S_OK;
}

HRESULT WINAPI DirectPlayLobbiedAppMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer )
{
	HRESULT					hr=S_OK;
	BOOL					fCallCoUninit = FALSE;
	VARIANT_BOOL			fRejectMsg = VARIANT_FALSE;

	// User context for the message handler is a pointer to our class module.
	C_dxj_DirectPlayLobbiedApplicationObject	*lpPeer = (C_dxj_DirectPlayLobbiedApplicationObject*)pvUserContext;
	DPF(1,"-----Entering (DPlayLobbiedApp) MessageHandler call...\n");
	
	if (!lpPeer) return E_FAIL;
	if (!lpPeer->m_pEventStream) return E_FAIL;

	if (!lpPeer->m_fHandleEvents)
		return S_OK;

	// First we need to set our stream seek back to the beginning
	// We will do this every time we enter this function since we don't know if
	// we are on the same thread or not...
		I_dxj_DirectPlayLobbyEvent	*lpEvent = NULL;
	__try {
		LARGE_INTEGER l;
		l.QuadPart = 0;
		lpPeer->m_pEventStream->Seek(l, STREAM_SEEK_SET, NULL);

		hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
		if (hr == CO_E_NOTINITIALIZED) // Call CoInit so we can unmarshal
		{
			CoInitialize(NULL);
			hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
			fCallCoUninit = TRUE;
		}

		if (!lpEvent) 
		{
			DPF(1,"-----Leaving (DplayLobbyClient) MessageHandler call (No event interface)...\n");
			return hr;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		DPF(1,"-----Leaving (DplayLobbyClient) MessageHandler call (Stream Gone)...\n");
		return S_OK;
	}

    switch( dwMessageId )
	{
	//Receive
	case DPL_MSGID_RECEIVE:
		{
			DPL_MESSAGE_RECEIVE			*msg = (DPL_MESSAGE_RECEIVE*)pMsgBuffer;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			DPL_MESSAGE_RECEIVE_CDESC	m_dpReceive;
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpReceive, sizeof(DPL_MESSAGE_RECEIVE_CDESC));
			m_dpReceive.Sender = (long)msg->hSender;
			
			// Let's load our SafeArray

			if (msg->dwBufferSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwBufferSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pBuffer;
				m_dpReceive.lBufferSize = msg->dwBufferSize;
				m_dpReceive.Buffer = lpData;
			}

			lpEvent->Receive(&m_dpReceive, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}
			
			break;
		}

	//Connect
	case DPL_MSGID_CONNECT:
		{
			DPL_MESSAGE_CONNECT				*msg = (DPL_MESSAGE_CONNECT*)pMsgBuffer;
			DPNHANDLE						m_hConnectID;
			DPL_MESSAGE_CONNECT_CDESC		m_dpConnection;
			SAFEARRAY						*lpData = NULL;
			SAFEARRAYBOUND					rgsabound[1];
			WCHAR* wszAddress = NULL;
			WCHAR* wszDevice = NULL;
			DWORD									dwNumChars = 0;
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpConnection, sizeof(DPL_MESSAGE_CONNECT_CDESC));
			m_dpConnection.ConnectId = (long)msg->hConnectId;
			// Let's load our SafeArray

			if (msg->dwLobbyConnectDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwLobbyConnectDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pvLobbyConnectData;
				
				m_dpConnection.LobbyConnectData = lpData;
			}

			lpPeer->GetVBConnSettings(msg->pdplConnectionSettings, &m_dpConnection.dplMsgCon);

			__try {
				if (msg->pdplConnectionSettings->pdp8HostAddress)
				{
					hr = msg->pdplConnectionSettings->pdp8HostAddress->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
						return hr;

                    wszAddress = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
					if (FAILED (hr = msg->pdplConnectionSettings->pdp8HostAddress->GetURLW(wszAddress,&dwNumChars) ) )
						return hr;

					m_dpConnection.dplMsgCon.AddressSenderUrl = SysAllocString(wszAddress);
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// Just skip this part
			}

			__try {
				dwNumChars = 0;
				if ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)
				{
					hr = ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
						return hr;

                    wszDevice = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
					if (FAILED (hr = ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)->GetURLW(wszDevice,&dwNumChars) ) )
						return hr;

					m_dpConnection.dplMsgCon.AddressDeviceUrl = SysAllocString(wszDevice);
				}
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// Just skip this part
			}

			lpEvent->Connect(&m_dpConnection, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}

			// Get rid of these addresses
			if (m_dpConnection.dplMsgCon.AddressSenderUrl)
				SysFreeString(m_dpConnection.dplMsgCon.AddressSenderUrl);

			if (m_dpConnection.dplMsgCon.AddressDeviceUrl)
				SysFreeString(m_dpConnection.dplMsgCon.AddressDeviceUrl);
			
		break;
		}

	//Disconnect
	case DPL_MSGID_DISCONNECT:
		{
			DPL_MESSAGE_DISCONNECT				*msg = (DPL_MESSAGE_DISCONNECT*)pMsgBuffer;
			DPNHANDLE								m_hDisconnectID;
			HRESULT									m_hDisconnectReason;

			m_hDisconnectID = (long)msg->hDisconnectId;
			m_hDisconnectReason = (long) msg->hrReason;

			lpEvent->Disconnect(m_hDisconnectID, m_hDisconnectReason);
			
			break;
		}

	//Status
	case DPL_MSGID_SESSION_STATUS:
		{
			DPL_MESSAGE_SESSION_STATUS			*msg = (DPL_MESSAGE_SESSION_STATUS*)pMsgBuffer;
			DPNHANDLE								m_hSender;
			DWORD									m_dwSessionStatus;

			m_dwSessionStatus = (long)msg->dwStatus;
			m_hSender = (long)msg->hSender;
	
			lpEvent->SessionStatus(m_dwSessionStatus,m_hSender);

		break;
		}

	//ConnectionSettings
	case DPL_MSGID_CONNECTION_SETTINGS:
		{
			DPL_MESSAGE_CONNECTION_SETTINGS			*msg = (DPL_MESSAGE_CONNECTION_SETTINGS*)pMsgBuffer;
			DPL_MESSAGE_CONNECTION_SETTINGS_CDESC	dpCon;
			WCHAR* wszAddress = NULL;
			WCHAR* wszDevice = NULL;
			DWORD									dwNumChars = 0;

			ZeroMemory(&dpCon, sizeof(DPL_MESSAGE_CONNECTION_SETTINGS_CDESC));

			lpPeer->GetVBConnSettings(msg->pdplConnectionSettings, &dpCon.dplConnectionSettings);
			dpCon.hSender = (long)msg->hSender;
			__try {
				if (msg->pdplConnectionSettings->pdp8HostAddress)
				{
					hr = msg->pdplConnectionSettings->pdp8HostAddress->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
						return hr;

                    wszAddress = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
					if (FAILED (hr = msg->pdplConnectionSettings->pdp8HostAddress->GetURLW(wszAddress,&dwNumChars) ) )
						return hr;

					dpCon.dplConnectionSettings.AddressSenderUrl = SysAllocString(wszAddress);
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// Just skip this part
			}

			__try {
				dwNumChars = 0;
				if ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)
				{
					hr = ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
						return hr;

                    wszDevice = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
					if (FAILED (hr = ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)->GetURLW(wszDevice,&dwNumChars) ) )
						return hr;

					dpCon.dplConnectionSettings.AddressDeviceUrl = SysAllocString(wszDevice);
				}
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// Just skip this part
			}
			lpEvent->ConnectionSettings(&dpCon);
			// Get rid of these addresses
			if (dpCon.dplConnectionSettings.AddressSenderUrl)
				SysFreeString(dpCon.dplConnectionSettings.AddressSenderUrl);

			if (dpCon.dplConnectionSettings.AddressDeviceUrl)
				SysFreeString(dpCon.dplConnectionSettings.AddressDeviceUrl);

		break;
		}
	}

	__try {
		if (lpPeer->m_pEventStream)
				// clean up marshaled packet
			CoReleaseMarshalData(lpPeer->m_pEventStream);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		return S_OK;
	}

	if (fCallCoUninit)
		CoUninitialize();

	DPF(1,"-----Leaving (DPlayLobbiedApp) MessageHandler call...\n");

	if (fRejectMsg != VARIANT_FALSE)
		return E_FAIL;

	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::RegisterMessageHandler(I_dxj_DirectPlayLobbyEvent *lobbyEvent, long *lDPNHandle)
{
    HRESULT	  hr=S_OK;
    LPSTREAM  pStm=NULL;
    IUnknown *pUnk=NULL;

	DPF(1,"-----Entering (DPlayLobbiedApp) RegisterMessageHandler call...\n");
	if (!lobbyEvent) return E_INVALIDARG;
    
    if (!m_fHandleEvents)
	{
		if (m_pEventStream) 
			m_pEventStream->Release();

    
		// Create a global stream.  The stream needs to be global so we can 
		// marshal once, and unmarshal as many times as necessary
		hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);
		if FAILED(hr) return hr;

		// Now we can marshal our IUnknown interface.  We use MSHLFLAGS_TABLEWEAK 
		// so we can unmarshal any number of times
		hr = CoMarshalInterface(pStm, IID_I_dxj_DirectPlayLobbyEvent, lobbyEvent, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLEWEAK);
		if FAILED(hr) return hr;

		// Now we need to set the seek location of the stream to the beginning
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStm->Seek(l, STREAM_SEEK_SET, NULL);
    
		m_pEventStream=pStm;

		if (!m_fInit)
		{
			if (FAILED ( hr = m__dxj_DirectPlayLobbiedApplication->Initialize( this, DirectPlayLobbiedAppMessageHandler, (DPNHANDLE*) lDPNHandle, 0 ) ) )
				return hr;
			m_fInit = TRUE;
		}
		m_fHandleEvents = TRUE;
	}
	else
		return DPNERR_ALREADYINITIALIZED;

	return hr;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::RegisterProgram(DPL_PROGRAM_DESC_CDESC *ProgramDesc,long lFlags)
{
	HRESULT hr;
	DPL_PROGRAM_DESC dpProg;
	GUID guidApp;

	__try {
		DPF(1,"-----Entering (DPlayLobbiedApp) RegisterProgram call...\n");
		ZeroMemory(&guidApp, sizeof(GUID));
		if (FAILED (hr = BSTRtoGUID(&guidApp, ProgramDesc->guidApplication) ) )
			return hr;

		ZeroMemory(&dpProg, sizeof(DPL_PROGRAM_DESC) );
		// Fill out our struct
		dpProg.dwSize = sizeof(DPL_PROGRAM_DESC);
		dpProg.dwFlags = ProgramDesc->lFlags;
		dpProg.guidApplication = guidApp;
		dpProg.pwszApplicationName = ProgramDesc->ApplicationName;
		dpProg.pwszCommandLine = ProgramDesc->CommandLine;
		dpProg.pwszCurrentDirectory = ProgramDesc->CurrentDirectory;
		dpProg.pwszDescription = ProgramDesc->Description;
		dpProg.pwszExecutableFilename = ProgramDesc->ExecutableFilename;
		dpProg.pwszExecutablePath = ProgramDesc->ExecutablePath;
		dpProg.pwszLauncherFilename = ProgramDesc->LauncherFilename;
		dpProg.pwszLauncherPath = ProgramDesc->LauncherPath;

		if (FAILED( hr = m__dxj_DirectPlayLobbiedApplication->RegisterProgram(&dpProg, (DWORD) lFlags) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::UnRegisterProgram(BSTR guidApplication,long lFlags)
{
	HRESULT hr;
	GUID guidApp;

	__try {
		DPF(1,"-----Entering (DPlayLobbiedApp) UnregisterProgram call...\n");
		ZeroMemory(&guidApp, sizeof(GUID));
		if (FAILED (hr = BSTRtoGUID(&guidApp, guidApplication) ) )
			return hr;

		if (FAILED (hr = m__dxj_DirectPlayLobbiedApplication->UnRegisterProgram(&guidApp,(DWORD) lFlags) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::Send(long Target,SAFEARRAY **Buffer,long lBufferSize,long lFlags)
{
	HRESULT hr;
	DWORD				dwBufferSize = 0;

	__try {
		DPF(1,"-----Entering (DPlayLobbiedApp) Send call...\n");
		dwBufferSize = (DWORD)lBufferSize;

		hr = m__dxj_DirectPlayLobbiedApplication->Send((DPNHANDLE) Target, (BYTE*)((SAFEARRAY*)*Buffer)->pvData, dwBufferSize, (DWORD) lFlags);
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::SetAppAvailable(VARIANT_BOOL fAvailable, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayLobbiedApp) SetAppAvailable call...\n");
		if (fAvailable == VARIANT_TRUE)
		{
			if (FAILED (hr = m__dxj_DirectPlayLobbiedApplication->SetAppAvailable(TRUE, (DWORD) lFlags) ) )
				return hr;
		}
		else
		{
			if (FAILED (hr = m__dxj_DirectPlayLobbiedApplication->SetAppAvailable(FALSE, (DWORD) lFlags) ) )
				return hr;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

#if 0
HRESULT C_dxj_DirectPlayLobbiedApplicationObject::WaitForConnection(long lMilliseconds)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayLobbiedApp) WaitForConnection call...\n");
		if (FAILED (hr = m__dxj_DirectPlayLobbiedApplication->WaitForConnection((DWORD) lMilliseconds, 0 ) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}
#endif
HRESULT C_dxj_DirectPlayLobbiedApplicationObject::UpdateStatus(long LobbyClient, long lStatus)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayLobbiedApp) UpdateStatus call...\n");
		if (FAILED (hr = m__dxj_DirectPlayLobbiedApplication->UpdateStatus((DPNHANDLE) LobbyClient, (DWORD) lStatus, 0 ) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::Close()
{
	HRESULT hr; 
	BOOL bGotMsg = FALSE;
	BOOL bWait = FALSE;
	DWORD dwObj = 0;
	int i=0;
	MSG msg;

	__try {
		DPF(1,"-----Entering (DPlayLobbiedApp) Close call...\n");
		HANDLE hThread = NULL;
		DWORD dwThread = 0;

		hThread = CreateThread(NULL, 0, &CloseLobbiedAppThreadProc, this->m__dxj_DirectPlayLobbiedApplication, 0, &dwThread);
		msg.message = WM_NULL;

		while ((WM_QUIT != msg.message) && (!bWait))
		{
			bGotMsg = PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE);
			i++;
			if ((!bGotMsg) || (i>10))
			{
				dwObj = WaitForSingleObject(hThread, 10);
				bWait = (dwObj == WAIT_OBJECT_0);
				i = 0;
			}
			if (bGotMsg)
			{
				TranslateMessage( &msg );
				DispatchMessage( &msg );
			}
			bGotMsg = FALSE;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}


HRESULT C_dxj_DirectPlayLobbiedApplicationObject::UnRegisterMessageHandler()
{
	DPF(1,"-----Entering (DPlayLobbiedApp) UnregisterMessageHandler call...\n");
	m_fHandleEvents = FALSE;
	return S_OK;
}


HRESULT C_dxj_DirectPlayLobbiedApplicationObject::GetConnectionSettings(long hLobbyClient, long lFlags, DPL_CONNECTION_SETTINGS_CDESC *ConnectionSettings)
{
	DPL_CONNECTION_SETTINGS	*desc = NULL;
	DWORD					dwSize = 0;
	HRESULT					hr = S_OK;
	WCHAR* wszAddress = NULL;
	WCHAR* wszDevice = NULL;
	DWORD									dwNumChars = 0;

	__try {
		hr= m__dxj_DirectPlayLobbiedApplication->GetConnectionSettings((DPNHANDLE) hLobbyClient, NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		desc = (DPL_CONNECTION_SETTINGS*)new BYTE[dwSize];
		desc->dwSize = sizeof(DPL_CONNECTION_SETTINGS);

		hr= m__dxj_DirectPlayLobbiedApplication->GetConnectionSettings((DPNHANDLE) hLobbyClient, desc, &dwSize, (DWORD) lFlags);
		if( FAILED(hr))
			return hr;
		__try {
			hr = desc->pdp8HostAddress->GetURLW(NULL, &dwNumChars);
			if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				return hr;

            wszAddress = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
			if (FAILED (hr = desc->pdp8HostAddress->GetURLW(wszAddress,&dwNumChars) ) )
				return hr;

			ConnectionSettings->AddressSenderUrl = SysAllocString(wszAddress);
		}	
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			// Just skip this part
		}

		__try {
			dwNumChars = 0;
			hr = ((IDirectPlay8Address*)*desc->ppdp8DeviceAddresses)->GetURLW(NULL, &dwNumChars);
			if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				return hr;

            wszDevice = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
			if (FAILED (hr = ((IDirectPlay8Address*)*desc->ppdp8DeviceAddresses)->GetURLW(wszDevice,&dwNumChars) ) )
				return hr;

			ConnectionSettings->AddressDeviceUrl = SysAllocString(wszDevice);
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			// Just skip this part
		}
		GetVBConnSettings(desc, ConnectionSettings);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::SetConnectionSettings(long hTarget, long lFlags, DPL_CONNECTION_SETTINGS_CDESC *ConnectionSettings, I_dxj_DirectPlayAddress *HostAddress, I_dxj_DirectPlayAddress *Device)
{
	DPL_CONNECTION_SETTINGS	desc;
	HRESULT					hr = S_OK;
	GUID					guidApp;
	GUID					guidInst;
    WCHAR					wszSessionName[MAX_PATH];
    WCHAR					wszPassword[MAX_PATH];

	__try {
		ZeroMemory(&desc, sizeof(DPL_CONNECTION_SETTINGS));
		desc.dwSize = sizeof(DPL_CONNECTION_SETTINGS);
		desc.dwFlags = ConnectionSettings->lFlags;
		HostAddress->InternalGetObject((IUnknown**)&desc.pdp8HostAddress);
		Device->InternalGetObject((IUnknown**)desc.ppdp8DeviceAddresses);

		ZeroMemory(&desc.dpnAppDesc, sizeof(DPN_APPLICATION_DESC));

		// Set up our Desc
		desc.dpnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);

		if (!IsEmptyString(ConnectionSettings->ApplicationDescription.SessionName)) 
		{
			wcscpy(wszSessionName,ConnectionSettings->ApplicationDescription.SessionName);
			desc.dpnAppDesc.pwszSessionName = wszSessionName;
		}
		if (!IsEmptyString(ConnectionSettings->ApplicationDescription.Password)) 
		{
			wcscpy(wszPassword,ConnectionSettings->ApplicationDescription.Password);
			desc.dpnAppDesc.pwszPassword = wszPassword;
		}

		desc.dpnAppDesc.dwFlags = ConnectionSettings->ApplicationDescription.lFlags;

		desc.dpnAppDesc.dwMaxPlayers = ConnectionSettings->ApplicationDescription.lMaxPlayers;
		desc.dpnAppDesc.dwCurrentPlayers = ConnectionSettings->ApplicationDescription.lCurrentPlayers;

		if (FAILED(hr = DPLAYBSTRtoGUID(&guidApp, ConnectionSettings->ApplicationDescription.guidApplication) ) )
			return hr;
		desc.dpnAppDesc.guidApplication = guidApp;

		if (FAILED(hr = DPLAYBSTRtoGUID(&guidInst, ConnectionSettings->ApplicationDescription.guidInstance) ) )
			return hr;
		desc.dpnAppDesc.guidInstance = guidInst;
		
		hr= m__dxj_DirectPlayLobbiedApplication->SetConnectionSettings((DPNHANDLE) hTarget, &desc, (DWORD) lFlags);
		if( FAILED(hr))
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::GetVBConnSettings(DPL_CONNECTION_SETTINGS *OldCon, DPL_CONNECTION_SETTINGS_CDESC *NewCon)
{
	IDirectPlay8Address *dpAdd = NULL;
	HRESULT hr;

	__try {
		NewCon->lSize = OldCon->dwSize;
		NewCon->lFlags = OldCon->dwFlags;
		NewCon->PlayerName = SysAllocString(OldCon->pwszPlayerName);

		ZeroMemory(&NewCon->ApplicationDescription, sizeof(DPN_APPLICATION_DESC_CDESC));

		// Set up our Desc
		NewCon->ApplicationDescription.lSize = OldCon->dpnAppDesc.dwSize;
		NewCon->ApplicationDescription.SessionName = SysAllocString(OldCon->dpnAppDesc.pwszSessionName);
		NewCon->ApplicationDescription.Password = SysAllocString(OldCon->dpnAppDesc.pwszPassword);
		NewCon->ApplicationDescription.lFlags = OldCon->dpnAppDesc.dwFlags;
		NewCon->ApplicationDescription.lMaxPlayers = OldCon->dpnAppDesc.dwMaxPlayers;
		NewCon->ApplicationDescription.lCurrentPlayers = OldCon->dpnAppDesc.dwCurrentPlayers;
		NewCon->ApplicationDescription.guidApplication = GUIDtoBSTR(&OldCon->dpnAppDesc.guidApplication);
		NewCon->ApplicationDescription.guidInstance = GUIDtoBSTR(&OldCon->dpnAppDesc.guidInstance);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

DWORD WINAPI CloseLobbiedAppThreadProc(void* lpParam)
{
	// User context for the message handler is a pointer to our class module.
	IDirectPlay8LobbiedApplication	*lpPeer = (IDirectPlay8LobbiedApplication*)lpParam;

	DPF(1,"-----Entering (DPlayLobbiedApp) ClosePeerThreadProc call...\n");
	lpPeer->Close(0);
	DPF(1,"-----Leaving (DPlayLobbiedApp) ClosePeerThreadProc call ...\n");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplayclientobj.h ===
#include "resource.h"       // main symbols
#include "dplay8.h"

#define typedef__dxj_DirectPlayClient IDirectPlay8Client*
//Forward declare the class
class C_dxj_DirectPlayClientObject;

/////////////////////////////////////////////////////////////////////////////
// Direct Net Peer

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayClientObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayClient, &IID_I_dxj_DirectPlayClient, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayClient,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayClientObject() ;
	virtual ~C_dxj_DirectPlayClientObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayClientObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayClient)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayClientObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayClient
public:
	 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);


		HRESULT STDMETHODCALLTYPE RegisterMessageHandler(I_dxj_DirectPlayEvent *event);
		HRESULT STDMETHODCALLTYPE EnumHosts(DPN_APPLICATION_DESC_CDESC *ApplicationDesc,I_dxj_DirectPlayAddress *AddrHost,I_dxj_DirectPlayAddress *DeviceInfo,long lRetryCount, long lRetryInterval, long lTimeOut,long lFlags, void *UserData, long UserDataSize, long *lAsync);
		HRESULT STDMETHODCALLTYPE GetCountServiceProviders(long lFlags, long *ret);
		HRESULT STDMETHODCALLTYPE GetServiceProvider(long lIndex, DPN_SERVICE_PROVIDER_INFO_CDESC *ret);
		HRESULT STDMETHODCALLTYPE CancelAsyncOperation(long lAsyncHandle, long lFlags);
		HRESULT STDMETHODCALLTYPE Connect(DPN_APPLICATION_DESC_CDESC *AppDesc,I_dxj_DirectPlayAddress *Address,I_dxj_DirectPlayAddress *DeviceInfo, long lFlags, void *UserData, long UserDataSize, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE Send(SAFEARRAY **Buffer, long lTimeOut,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE GetSendQueueInfo(long *lNumMsgs, long *lNumBytes, long lFlags);
		HRESULT STDMETHODCALLTYPE GetApplicationDesc(long lFlags, DPN_APPLICATION_DESC_CDESC *ret);
		HRESULT STDMETHODCALLTYPE SetClientInfo(DPN_PLAYER_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE GetServerInfo(long lFlags, DPN_PLAYER_INFO_CDESC *layerInfo);
		HRESULT STDMETHODCALLTYPE Close(long lFlags);
		HRESULT STDMETHODCALLTYPE ReturnBuffer(long lBufferHandle);
		HRESULT STDMETHODCALLTYPE GetCaps(long lFlags, DPNCAPS_CDESC *ret);
		HRESULT STDMETHODCALLTYPE SetCaps(DPNCAPS_CDESC *Caps, long lFlags);
		HRESULT STDMETHODCALLTYPE RegisterLobby(long dpnHandle, I_dxj_DirectPlayLobbiedApplication *LobbyApp, long lFlags);
		HRESULT STDMETHODCALLTYPE GetConnectionInfo(long lFlags, DPN_CONNECTION_INFO_CDESC *pdpConnectionInfo);

		HRESULT STDMETHODCALLTYPE GetServerAddress(long lFlags, I_dxj_DirectPlayAddress **pAddress);
		HRESULT STDMETHODCALLTYPE SetSPCaps(BSTR guidSP, DPN_SP_CAPS_CDESC *spCaps, long lFlags);
		HRESULT STDMETHODCALLTYPE GetSPCaps(BSTR guidSP, long lFlags, DPN_SP_CAPS_CDESC *spCaps);
		HRESULT STDMETHODCALLTYPE GetUserData(void *UserData, long *UserDataSize);
		HRESULT STDMETHODCALLTYPE UnRegisterMessageHandler();
////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayClient);

private:
    DPN_SERVICE_PROVIDER_INFO	*m_SPInfo;
	DWORD						m_dwSPCount;
	BOOL						m_fInit;

	HRESULT STDMETHODCALLTYPE GetSP(long lFlags);
	HRESULT STDMETHODCALLTYPE	FlushBuffer(LONG dwNumMessagesLeft);

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayClient);

	DWORD InternalAddRef();
	DWORD InternalRelease();

	BOOL									m_fHandleEvents;
	IStream									*m_pEventStream;

	//We need to keep a count of the messages
	LONG									m_dwMsgCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplaylobbyclientobj.h ===
#include "resource.h"       // main symbols
#include "dplobby8.h"

#define typedef__dxj_DirectPlayLobbyClient IDirectPlay8LobbyClient*

/////////////////////////////////////////////////////////////////////////////
// Direct Net Peer

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayLobbyClientObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayLobbyClient, &IID_I_dxj_DirectPlayLobbyClient, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayLobbyClient,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayLobbyClientObject() ;
	virtual ~C_dxj_DirectPlayLobbyClientObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayLobbyClientObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayLobbyClient)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayLobbyClientObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayLobbyClient
public:
	 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE RegisterMessageHandler(I_dxj_DirectPlayLobbyEvent *lobbyEvent);
		HRESULT STDMETHODCALLTYPE GetCountLocalPrograms(BSTR GuidApplication,long *lCount);
		HRESULT STDMETHODCALLTYPE GetLocalProgram(long lProgID, DPL_APPLICATION_INFO_CDESC *app);
		HRESULT STDMETHODCALLTYPE ConnectApplication(DPL_CONNECT_INFO_CDESC *ConnectionInfo,long lTimeOut,long lFlags, long *hApplication);
		HRESULT STDMETHODCALLTYPE Send(long Target,SAFEARRAY **Buffer,long lBufferSize,long lFlags);
		HRESULT STDMETHODCALLTYPE ReleaseApplication(long Application);
		HRESULT STDMETHODCALLTYPE Close();
		HRESULT STDMETHODCALLTYPE UnRegisterMessageHandler();
		HRESULT STDMETHODCALLTYPE GetConnectionSettings(long hLobbyClient, long lFlags, DPL_CONNECTION_SETTINGS_CDESC *ConnectionSettings);	
		HRESULT STDMETHODCALLTYPE SetConnectionSettings(long hTarget, long lFlags, DPL_CONNECTION_SETTINGS_CDESC *ConnectionSettings, I_dxj_DirectPlayAddress *HostAddress, I_dxj_DirectPlayAddress *Device);
		HRESULT STDMETHODCALLTYPE GetVBConnSettings(DPL_CONNECTION_SETTINGS *OldCon, DPL_CONNECTION_SETTINGS_CDESC *NewCon);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayLobbyClient);

private:
    DPL_APPLICATION_INFO		*m_ProgInfo;
	DWORD						m_dwAppCount;
	BOOL						m_fInit;

	HRESULT STDMETHODCALLTYPE	GetProgs(GUID *guidApp);

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayLobbyClient);

	DWORD InternalAddRef();
	DWORD InternalRelease();

	// We need these for our user data vars
	void			*m_pUserData;
	DWORD			m_dwUserDataSize;

	BOOL									m_fHandleEvents;
	IStream									*m_pEventStream;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplaypeerobj.h ===
#include "resource.h"       // main symbols
#include "dplay8.h"

//Forward declare the class
class C_dxj_DirectPlayPeerObject;

#define typedef__dxj_DirectPlayPeer IDirectPlay8Peer*

/////////////////////////////////////////////////////////////////////////////
// Direct Net Peer

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayPeerObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayPeer, &IID_I_dxj_DirectPlayPeer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayPeer,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayPeerObject() ;
	virtual ~C_dxj_DirectPlayPeerObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayPeerObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayPeer)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayPeerObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayPeer
public:
	 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE DestroyGroup(long idGroup,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE RemovePlayerFromGroup(long idGroup, long idClient,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE DestroyPeer(long idClient, long lFlags, void *UserData, long UserDataSize);
		HRESULT STDMETHODCALLTYPE Connect(DPN_APPLICATION_DESC_CDESC *AppDesc,I_dxj_DirectPlayAddress *Address,I_dxj_DirectPlayAddress *DeviceInfo, long lFlags, void *UserData, long UserDataSize, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE RegisterMessageHandler(I_dxj_DirectPlayEvent *event);
		HRESULT STDMETHODCALLTYPE EnumHosts(DPN_APPLICATION_DESC_CDESC *ApplicationDesc,I_dxj_DirectPlayAddress *AddrHost,I_dxj_DirectPlayAddress *DeviceInfo,long lRetryCount, long lRetryInterval, long lTimeOut,long lFlags, void *UserData, long UserDataSize, long *lAsync);
		HRESULT STDMETHODCALLTYPE GetCountServiceProviders(long lFlags, long *ret);
		HRESULT STDMETHODCALLTYPE GetServiceProvider(long lIndex, DPN_SERVICE_PROVIDER_INFO_CDESC *ret);

		// Enum for Clients/Groups
		HRESULT STDMETHODCALLTYPE GetCountPlayersAndGroups(long lFlags, long *ret);
		HRESULT STDMETHODCALLTYPE GetPlayerOrGroup(long lIndex, long *ret);
		// Enum Players in groups
		HRESULT STDMETHODCALLTYPE GetCountGroupMembers(long dpid,long lFlags, long *ret);
		HRESULT STDMETHODCALLTYPE GetGroupMember(long lIndex,long dpid, long *ret);

		HRESULT STDMETHODCALLTYPE ReturnBuffer(long lBufferHandle);
		HRESULT STDMETHODCALLTYPE Host(DPN_APPLICATION_DESC_CDESC *AppDesc,I_dxj_DirectPlayAddress *Address, long lFlags );

		HRESULT STDMETHODCALLTYPE CancelAsyncOperation(long lAsyncHandle, long lFlags);
		HRESULT STDMETHODCALLTYPE GetApplicationDesc(long lFlags, DPN_APPLICATION_DESC_CDESC __RPC_FAR *ret);
		HRESULT STDMETHODCALLTYPE SetApplicationDesc(DPN_APPLICATION_DESC_CDESC *AppDesc, long lFlags);
		HRESULT STDMETHODCALLTYPE Close(long lFlags);
		HRESULT STDMETHODCALLTYPE GetCaps(long lFlags, DPNCAPS_CDESC __RPC_FAR *ret);
		HRESULT STDMETHODCALLTYPE SetCaps(DPNCAPS_CDESC __RPC_FAR *Caps, long lFlags);

		HRESULT STDMETHODCALLTYPE SendTo(long idSend ,SAFEARRAY **Buffer,long lTimeOut,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE CreateGroup(DPN_GROUP_INFO_CDESC *GroupInfo,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE AddPlayerToGroup(long idGroup, long idClient,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE GetSendQueueInfo(long idPlayer, long *lNumMsgs, long *lNumBytes, long lFlags);
		HRESULT STDMETHODCALLTYPE SetGroupInfo(long idGroup, DPN_GROUP_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE GetGroupInfo(long idGroup,long lFlags, DPN_GROUP_INFO_CDESC *layerInfo);
		HRESULT STDMETHODCALLTYPE SetPeerInfo(DPN_PLAYER_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE GetPeerInfo(long idPeer,long lFlags, DPN_PLAYER_INFO_CDESC *layerInfo);
		HRESULT STDMETHODCALLTYPE RegisterLobby(long dpnHandle, I_dxj_DirectPlayLobbiedApplication *LobbyApp, long lFlags);
		HRESULT STDMETHODCALLTYPE GetConnectionInfo(long idPlayer, long lFlags, DPN_CONNECTION_INFO_CDESC *pdpConnectionInfo);
		
		HRESULT STDMETHODCALLTYPE GetPeerAddress(long idPlayer, long lFlags, I_dxj_DirectPlayAddress **pAddress);
		HRESULT STDMETHODCALLTYPE GetLocalHostAddress(long lFlags, I_dxj_DirectPlayAddress **pAddress);
		HRESULT STDMETHODCALLTYPE SetSPCaps(BSTR guidSP, DPN_SP_CAPS_CDESC *spCaps, long lFlags);
		HRESULT STDMETHODCALLTYPE GetSPCaps(BSTR guidSP, long lFlags, DPN_SP_CAPS_CDESC *spCaps);
		HRESULT STDMETHODCALLTYPE TerminateSession(long lFlags, void *UserData, long UserDataSize);
		HRESULT STDMETHODCALLTYPE GetUserData(void *UserData, long *UserDataSize);
		HRESULT STDMETHODCALLTYPE SetUserData(void *UserData, long UserDataSize);
		HRESULT STDMETHODCALLTYPE UnRegisterMessageHandler();

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayPeer);

private:
    DPN_SERVICE_PROVIDER_INFO	*m_SPInfo;
	DWORD						m_dwSPCount;
	DPNID						*m_ClientsGroups;
	DPNID						*m_GroupMembers;
	DPNID						m_dwGroupID;
	DWORD						m_dwClientCount;
	DWORD						m_dwGroupMemberCount;
	BOOL						m_fInit;

	HRESULT STDMETHODCALLTYPE	GetSP(long lFlags);
	HRESULT STDMETHODCALLTYPE	GetClientsAndGroups(long lFlags);
	HRESULT STDMETHODCALLTYPE	GetGroupMembers(long lFlags, DPNID dpGroupID);
	HRESULT STDMETHODCALLTYPE	FlushBuffer(LONG dwNumMessagesLeft);

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayPeer);

	DWORD InternalAddRef();
	DWORD InternalRelease();
	
	BOOL									m_fHandleEvents;
	IStream									*m_pEventStream;

	//We need to keep a count of the messages
	LONG			m_dwMsgCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplaypeerobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dplayaddressobj.h"
#include "DPlayPeerObj.h"					   

extern void *g_dxj_DirectPlayPeer;
extern void *g_dxj_DirectPlayAddress;
extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT DPLAYBSTRtoGUID(LPGUID,BSTR);
extern BOOL IsEmptyString(BSTR szString);

#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }
#define SAFE_DELETE_ARRAY(p)       { if(p) { delete [] (p); p=NULL; } }
#define SAFE_RELEASE(p)      { __try { if(p) { int i = 0; i = (p)->Release(); DPF1(1,"--DirectPlayPeer SafeRelease (RefCount = %d)\n",i); if (!i) { (p)=NULL;}} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { (p) = NULL;} } 

HRESULT WINAPI DirectPlayMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer );

DWORD WINAPI ClosePeerThreadProc(void* lpParam);
DWORD WINAPI ReleasePeerThreadProc(void* lpParam);

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayPeerObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF1(1,"------ DXVB: DirectPlayPeer8 AddRef %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayPeerObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF1(1,"------ DXVB: DirectPlayPeer8 Release %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayPeerObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayPeerObject::C_dxj_DirectPlayPeerObject(){ 
		
	DPF(1,"------ DXVB: Constructor Creation  DirectPlayPeer8 Object\n ");

	m__dxj_DirectPlayPeer = NULL;
	m_SPInfo = NULL;
	m_dwSPCount = 0;
	m_ClientsGroups = NULL;
	m_GroupMembers = NULL;
	m_dwGroupID = 0;
	m_dwClientCount = 0;
	m_dwGroupMemberCount = 0;
	m_fInit = FALSE;

	m_fHandleEvents = FALSE;

	m_pEventStream=NULL;
	m_dwMsgCount = 0;

}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayPeerObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayPeerObject::~C_dxj_DirectPlayPeerObject()
{

	DPF(1,"------ DXVB: Entering ~C_dxj_DirectPlayPeerObject destructor \n");

	//We still have messages to process get rid of them
	m_fHandleEvents = FALSE;
	FlushBuffer(0);

	SAFE_RELEASE(m_pEventStream);
	SAFE_DELETE_ARRAY(m_SPInfo);
	SAFE_DELETE_ARRAY(m_ClientsGroups);
	SAFE_DELETE_ARRAY(m_GroupMembers);

	HANDLE hThread = NULL;
	DWORD dwThread = 0;
	// We are quitting anyway, so we don't really care what is going on in this thread..
	hThread = CreateThread(NULL, 0, ReleasePeerThreadProc, this->m__dxj_DirectPlayPeer, 0, &dwThread);
}

HRESULT C_dxj_DirectPlayPeerObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayPeer;
	
	return S_OK;
}
HRESULT C_dxj_DirectPlayPeerObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayPeer=(IDirectPlay8Peer*)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::CancelAsyncOperation(long lAsyncHandle, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) CancelAsyncOp call...\n");
		if (FAILED( hr= m__dxj_DirectPlayPeer->CancelAsyncOperation((DPNHANDLE) lAsyncHandle, (DWORD) lFlags) ) ) 
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetApplicationDesc(long lFlags, DPN_APPLICATION_DESC_CDESC *ret)
{
	HRESULT					hr;
	DWORD					dwSize = 0;
	DPN_APPLICATION_DESC	*desc = NULL;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetAppDesc call...\n");
		//First get the size
		hr = m__dxj_DirectPlayPeer->GetApplicationDesc(NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		desc = (DPN_APPLICATION_DESC*) new BYTE[dwSize];
		if (!desc)
			return E_OUTOFMEMORY;

		ZeroMemory(desc, dwSize);

		desc->dwSize = sizeof(DPN_APPLICATION_DESC);
		if (FAILED( hr= m__dxj_DirectPlayPeer->GetApplicationDesc(desc, &dwSize, (DWORD) lFlags) ) )
			return hr;

		// Now return the vals 
		ret->lSize = dwSize;
		ret->lFlags = desc->dwFlags;
		ret->guidInstance = GUIDtoBSTR(&desc->guidInstance);
		ret->guidApplication = GUIDtoBSTR(&desc->guidApplication);
		ret->lMaxPlayers = desc->dwMaxPlayers;
		ret->lCurrentPlayers = desc->dwCurrentPlayers;
		ret->SessionName = SysAllocString(desc->pwszSessionName);
		ret->Password = SysAllocString(desc->pwszPassword);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}


HRESULT C_dxj_DirectPlayPeerObject::SetApplicationDesc(DPN_APPLICATION_DESC_CDESC *AppDesc, long lFlags)
{
	HRESULT					hr;
	DPN_APPLICATION_DESC	*desc = NULL;
	GUID					guidApp;
	GUID					guidInst;
    WCHAR					wszSessionName[MAX_PATH];
    WCHAR					wszPassword[MAX_PATH];

	__try {
		DPF(1,"-----Entering (DplayPeer) SetAppDesc call...\n");
	
		desc = (DPN_APPLICATION_DESC*) new BYTE[AppDesc->lSize];
		if (!desc)
			return E_OUTOFMEMORY;

		ZeroMemory(desc, AppDesc->lSize);

		// Set up our Desc
		desc->dwSize = sizeof(DPN_APPLICATION_DESC);

		if (!IsEmptyString(AppDesc->SessionName))
		{
			wcscpy(wszSessionName,AppDesc->SessionName);
			desc->pwszSessionName = wszSessionName;
		}
		if (!IsEmptyString(AppDesc->Password))
		{
			wcscpy(wszPassword,AppDesc->Password);
			desc->pwszPassword = wszPassword;
		}

		desc->dwFlags = AppDesc->lFlags;

		desc->dwMaxPlayers = AppDesc->lMaxPlayers;
		desc->dwCurrentPlayers = AppDesc->lCurrentPlayers;

		if (FAILED(hr = DPLAYBSTRtoGUID(&guidApp, AppDesc->guidApplication) ) )
			return hr;
		desc->guidApplication = guidApp;

		if (FAILED(hr = DPLAYBSTRtoGUID(&guidInst, AppDesc->guidInstance) ) )
			return hr;
		desc->guidInstance = guidInst;
		
		if (FAILED( hr= m__dxj_DirectPlayPeer->SetApplicationDesc(desc, (DWORD) lFlags) ) )
			return hr;

		SAFE_DELETE_ARRAY(desc);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::Close(long lFlags)
{
	HRESULT hr;
	BOOL bGotMsg = FALSE;
	BOOL bWait = FALSE;
	DWORD dwObj = 0;
	int i=0;
	MSG msg;


	HANDLE hThread = NULL;
	__try {
		DPF(1,"-----Entering (DplayPeer) Close call...\n");
		FlushBuffer(0);

		DWORD dwThread = 0;

		hThread = CreateThread(NULL, 0, ClosePeerThreadProc, this->m__dxj_DirectPlayPeer, 0, &dwThread);
		msg.message = WM_NULL;

		while ((WM_QUIT != msg.message) && (!bWait))
		{
			bGotMsg = PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE);
			i++;
			if ((!bGotMsg) || (i>10))
			{
				dwObj = WaitForSingleObject(hThread, 10);
				bWait = (dwObj == WAIT_OBJECT_0);
				i = 0;
			}
			if (bGotMsg)
			{
				TranslateMessage( &msg );
				DispatchMessage( &msg );
			}
			bGotMsg = FALSE;
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	CloseHandle(hThread);
	DPF(1,"-----Leaving (DplayPeer) Close call...\n");
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetCaps(long lFlags, DPNCAPS_CDESC *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetCaps call...\n");
		ret->lSize = sizeof(DPN_CAPS);
		if (FAILED (hr=m__dxj_DirectPlayPeer->GetCaps( (DPN_CAPS*) ret, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::SetCaps(DPNCAPS_CDESC *Caps, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) SetCaps call...\n");
		if (FAILED( hr = m__dxj_DirectPlayPeer->SetCaps((DPN_CAPS*)Caps, (DWORD)lFlags)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::DestroyGroup(long idGroup,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DplayPeer) DestroyGroup call...\n");
		hr= m__dxj_DirectPlayPeer->DestroyGroup((DPNID) idGroup, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}

		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::RemovePlayerFromGroup(long idGroup, long idClient,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DplayPeer) RemovePlayerFromGroup call...\n");
		hr = m__dxj_DirectPlayPeer->RemovePlayerFromGroup( (DPNID) idGroup,
						(DPNID) idClient, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}

		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::DestroyPeer(long idClient, long lFlags, void *UserData, long UserDataSize)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) DestroyPeer call...\n");
		if (FAILED( hr= m__dxj_DirectPlayPeer->DestroyPeer((DPNID) idClient, UserData, UserDataSize, (DWORD) lFlags) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::Connect(DPN_APPLICATION_DESC_CDESC *AppDesc,I_dxj_DirectPlayAddress *Address,I_dxj_DirectPlayAddress *DeviceInfo, long lFlags, void *UserData, long UserDataSize, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_APPLICATION_DESC	desc;
    WCHAR					wszSessionName[MAX_PATH];
    WCHAR					wszPassword[MAX_PATH];
	DPNHANDLE				*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DplayPeer) Connect call...\n");
		if (!IsEmptyString(AppDesc->SessionName)) wcscpy(wszSessionName,AppDesc->SessionName);
		if (!IsEmptyString(AppDesc->Password)) wcscpy(wszPassword,AppDesc->Password);

		ZeroMemory(&desc, sizeof(desc));

		// Set up our Desc
		desc.dwSize = sizeof(DPN_APPLICATION_DESC);
		desc.dwFlags = AppDesc->lFlags;

		desc.dwMaxPlayers = AppDesc->lMaxPlayers;
		desc.dwCurrentPlayers = AppDesc->lCurrentPlayers;
		if (!IsEmptyString(AppDesc->SessionName))
			desc.pwszSessionName = wszSessionName;
		if (!IsEmptyString(AppDesc->Password))
			desc.pwszPassword = wszPassword;

		if (AppDesc->guidApplication)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&desc.guidApplication, AppDesc->guidApplication) ) )
				return hr;
		}

		if (AppDesc->guidInstance)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&desc.guidInstance , AppDesc->guidInstance) ) )
				return hr;
		}

		// Get our host and device address
		IDirectPlay8Address	*lpAddress = NULL;
		IDirectPlay8Address	*lpDevice = NULL;

		if(Address) 
		{ 
			Address->InternalGetObject((IUnknown **)(&lpAddress));
		}

		if(DeviceInfo) 
		{
			DeviceInfo->InternalGetObject((IUnknown **)(&lpDevice));
		}

		// Time to connect
		hr = m__dxj_DirectPlayPeer->Connect(&desc, lpAddress, lpDevice, NULL, NULL, UserData, (DWORD)UserDataSize, NULL, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}

		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetCountPlayersAndGroups(long lFlags, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetCountPlayersAndGroups call...\n");
		// On the GetCount call we will always get the latest info
		if (FAILED ( hr = GetClientsAndGroups(lFlags) ) )
			return hr;
		
		*ret = m_dwClientCount;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetPlayerOrGroup(long lIndex, long *ret)
{
	__try {
		DPF(1,"-----Entering (DplayPeer) GetPlayerOrGroup call...\n");
		if (!m_ClientsGroups)
			return E_INVALIDARG;

		if ((lIndex < 1 ) || ((DWORD)lIndex > m_dwClientCount))
			return E_INVALIDARG;

		// Fill out our structure
		*ret = m_ClientsGroups[lIndex - 1];
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetCountGroupMembers(long dpid,long lFlags, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetCountGroupMembers call...\n");
		// On the GetCount call we will always get the latest info
		if (FAILED ( hr = GetGroupMembers(lFlags, (DPNID) dpid) ) )
			return hr;
		
		*ret = m_dwGroupMemberCount;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetGroupMember(long lIndex,long dpid, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetGroupMember call...\n");
		if ((!m_GroupMembers) || ((DPNID)dpid != m_dwGroupID) )
			if (FAILED (hr = GetGroupMembers(0, (DPNID) dpid) ) )
				return hr;

		if ((lIndex < 1 ) || ((DWORD)lIndex > m_dwGroupMemberCount))
			return E_INVALIDARG;

		if (!m_GroupMembers)
			return E_INVALIDARG;

		// Fill out our structure
		*ret = m_GroupMembers[lIndex - 1];
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::EnumHosts(DPN_APPLICATION_DESC_CDESC *ApplicationDesc,I_dxj_DirectPlayAddress *AddrHost,I_dxj_DirectPlayAddress *DeviceInfo,long lRetryCount, long lRetryInterval, long lTimeOut,long lFlags, void *UserData, long UserDataSize, long *lAsync)
{
	HRESULT					hr;
	DPN_APPLICATION_DESC	desc;
    WCHAR					wszSessionName[MAX_PATH];
    WCHAR					wszPassword[MAX_PATH];
	DPNHANDLE				*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DplayPeer) EnumHosts call...\n");
		if (!IsEmptyString(ApplicationDesc->SessionName)) wcscpy(wszSessionName,ApplicationDesc->SessionName);
		if (!IsEmptyString(ApplicationDesc->Password)) wcscpy(wszPassword,ApplicationDesc->Password);

		ZeroMemory(&desc, sizeof(desc));

		// Set up our Desc
		desc.dwSize = sizeof(DPN_APPLICATION_DESC);
		desc.dwFlags = ApplicationDesc->lFlags;

		desc.dwMaxPlayers = ApplicationDesc->lMaxPlayers;
		desc.dwCurrentPlayers = ApplicationDesc->lCurrentPlayers;
		if (!IsEmptyString(ApplicationDesc->SessionName))
			desc.pwszSessionName = wszSessionName;
		if (!IsEmptyString(ApplicationDesc->Password))
			desc.pwszPassword = wszPassword;

		if (ApplicationDesc->guidApplication)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&desc.guidApplication, ApplicationDesc->guidApplication) ) )
				return hr;
		}

		if (ApplicationDesc->guidInstance)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&desc.guidInstance, ApplicationDesc->guidInstance) ) )
				return hr;
		}

		// Get our host and device address
		DO_GETOBJECT_NOTNULL( IDirectPlay8Address*, lpHost, AddrHost);
		DO_GETOBJECT_NOTNULL( IDirectPlay8Address*, lpDevice, DeviceInfo);

		hr = m__dxj_DirectPlayPeer->EnumHosts(&desc, lpHost, lpDevice, UserData, UserDataSize, (DWORD) lRetryCount, (DWORD) lRetryInterval, (DWORD) lTimeOut, NULL,  dpAsync, (DWORD) lFlags);
		// This should return E_PENDING

		if (dpAsync)
		{
			*lAsync = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if( hr != E_PENDING && FAILED(hr) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::ReturnBuffer(long lBufferHandle)
{
	HRESULT hr;

	__try {
		//We should actually never get here since this is hidden, but just in case
		DPF(1,"-----Entering (DplayPeer) ReturnBuffer call...\n");
		if (FAILED(hr = m__dxj_DirectPlayPeer->ReturnBuffer( (DPNHANDLE) lBufferHandle, 0 ) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::Host(DPN_APPLICATION_DESC_CDESC *AppDesc,I_dxj_DirectPlayAddress *Address, long lFlags)
{
	HRESULT hr;
	DPN_APPLICATION_DESC	desc;
	GUID					guidApp;
	GUID					guidInst;
    WCHAR wszSessionName[MAX_PATH];
    WCHAR wszPassword[MAX_PATH];

	__try {
		DPF(1,"-----Entering (DplayPeer) Host call...\n");
		if (!IsEmptyString(AppDesc->SessionName)) wcscpy(wszSessionName,AppDesc->SessionName);
		if (!IsEmptyString(AppDesc->Password)) wcscpy(wszPassword,AppDesc->Password);
		
		DO_GETOBJECT_NOTNULL( IDirectPlay8Address*, lpAddress, Address);

		ZeroMemory(&desc, sizeof(DPN_APPLICATION_DESC) );

		desc.dwSize = sizeof(DPN_APPLICATION_DESC);
		desc.dwFlags = AppDesc->lFlags;
		desc.dwMaxPlayers = AppDesc->lMaxPlayers;
		desc.dwCurrentPlayers = AppDesc->lCurrentPlayers;
		if (!IsEmptyString(AppDesc->SessionName))
			desc.pwszSessionName = wszSessionName;
		if (!IsEmptyString(AppDesc->Password))
			desc.pwszPassword = wszPassword;

		if (AppDesc->guidApplication)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&guidApp, AppDesc->guidApplication) ) )
				return hr;
			desc.guidApplication = guidApp;
		}

		if (AppDesc->guidInstance)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&guidInst, AppDesc->guidInstance) ) )
				return hr;
			desc.guidInstance = guidInst;
		}

		if (FAILED (hr = m__dxj_DirectPlayPeer->Host(&desc, &lpAddress, 1, NULL, NULL, NULL, (DWORD) lFlags ) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::SendTo(long idSend, SAFEARRAY **Buffer, long lTimeOut,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_BUFFER_DESC		lpBuf;
	DWORD				dwBufSize = ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		DPF(1,"-----Entering (DplayPeer) SendTo call...\n");
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}
			
		lpBuf.dwBufferSize = dwBufSize;
		lpBuf.pBufferData  = (BYTE*)((SAFEARRAY*)*Buffer)->pvData;

		hr = m__dxj_DirectPlayPeer->SendTo((DPNID) idSend, &lpBuf, 1, (DWORD) lTimeOut, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::CreateGroup(DPN_GROUP_INFO_CDESC *GroupInfo, long lFlags, long *hAsyncHandle)
{
	HRESULT			hr;
	DPN_GROUP_INFO	dpnGroup;
    WCHAR			wszName[MAX_PATH];
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DplayPeer) CreateGroup call...\n");
		if (!IsEmptyString(GroupInfo->Name)) wcscpy(wszName,GroupInfo->Name);
		
		ZeroMemory(&dpnGroup, sizeof(DPN_GROUP_INFO) );
		dpnGroup.dwSize = sizeof(DPN_GROUP_INFO);
		dpnGroup.dwInfoFlags = GroupInfo->lInfoFlags;
		dpnGroup.dwGroupFlags = GroupInfo->lGroupFlags;
		dpnGroup.pwszName = wszName;

		hr = m__dxj_DirectPlayPeer->CreateGroup(&dpnGroup, NULL, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::AddPlayerToGroup(long idGroup, long idClient,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DplayPeer) AddPlayerToGroup call...\n");
		hr = m__dxj_DirectPlayPeer->AddPlayerToGroup((DPNID) idGroup, (DPNID) idClient, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetSendQueueInfo(long idPlayer, long *lNumMsgs, long *lNumBytes, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetSendQueueInfo call...\n");
		if (FAILED (hr = m__dxj_DirectPlayPeer->GetSendQueueInfo((DPNID) idPlayer, (DWORD*)lNumMsgs, (DWORD*)lNumBytes, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::SetGroupInfo(long idGroup, DPN_GROUP_INFO_CDESC *PlayerInfo, long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_GROUP_INFO dpInfo;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DplayPeer) SetGroupInfo call...\n");

		ZeroMemory(&dpInfo, sizeof(DPN_GROUP_INFO) );

		dpInfo.dwSize = sizeof(DPN_GROUP_INFO);
		dpInfo.dwInfoFlags = PlayerInfo->lInfoFlags;
		dpInfo.pwszName = PlayerInfo->Name;
		dpInfo.dwGroupFlags = PlayerInfo->lGroupFlags;

		hr = m__dxj_DirectPlayPeer->SetGroupInfo((DPNID) idGroup, &dpInfo, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetGroupInfo(long idGroup,long lFlags, DPN_GROUP_INFO_CDESC *layerInfo)
{
	HRESULT			hr;
	DPN_GROUP_INFO	*PlayerInfo = NULL;
	DWORD			dwInfoSize = 0;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetGroupInfo call...\n");
		hr = m__dxj_DirectPlayPeer->GetGroupInfo( (DPNID) idGroup, NULL, &dwInfoSize, (DWORD) lFlags );
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		PlayerInfo = (DPN_GROUP_INFO*) new BYTE[ dwInfoSize ];
		if (!PlayerInfo)
			return E_OUTOFMEMORY;

		ZeroMemory( PlayerInfo, dwInfoSize );
		PlayerInfo->dwSize = sizeof(DPN_GROUP_INFO);
		hr = m__dxj_DirectPlayPeer->GetGroupInfo( (DPNID) idGroup, PlayerInfo, &dwInfoSize, (DWORD)lFlags );
		if( FAILED(hr) )
			return hr;

		layerInfo->lSize = sizeof(DPN_GROUP_INFO_CDESC);
		layerInfo->lInfoFlags = PlayerInfo->dwInfoFlags;
		layerInfo->Name = SysAllocString(PlayerInfo->pwszName);
		layerInfo->lGroupFlags = PlayerInfo->dwGroupFlags;
		// We no longer need the playerinfo we got.. get rid of it..
		SAFE_DELETE_ARRAY(PlayerInfo);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::SetPeerInfo(DPN_PLAYER_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_PLAYER_INFO dpInfo;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DplayPeer) SetPeerInfo call...\n");
		ZeroMemory(&dpInfo, sizeof(DPN_PLAYER_INFO) );

		dpInfo.dwSize = sizeof(DPN_PLAYER_INFO);
		dpInfo.dwInfoFlags = PlayerInfo->lInfoFlags;
		dpInfo.pwszName = PlayerInfo->Name;
		dpInfo.dwPlayerFlags = PlayerInfo->lPlayerFlags;

		hr = m__dxj_DirectPlayPeer->SetPeerInfo(&dpInfo, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetPeerInfo(long idPeer,long lFlags, DPN_PLAYER_INFO_CDESC *layerInfo)
{
	HRESULT				hr;
    DWORD				dwSize = 0;
    DPN_PLAYER_INFO		*PlayerInfo = NULL;
    
	DPF(1,"-----Entering (DplayPeer) GetPeerInfo call...\n");

	__try
	{
		hr = m__dxj_DirectPlayPeer->GetPeerInfo( (DPNID) idPeer, NULL, &dwSize, (DWORD) lFlags );
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		PlayerInfo = (DPN_PLAYER_INFO*) new BYTE[ dwSize ];
		if (!PlayerInfo)
			return E_OUTOFMEMORY;

		ZeroMemory( PlayerInfo, dwSize );
		PlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);
		hr = m__dxj_DirectPlayPeer->GetPeerInfo( (DPNID) idPeer, PlayerInfo, &dwSize, (DWORD) lFlags );
		if( FAILED(hr) )
			return hr;

		layerInfo->lSize = sizeof(DPN_PLAYER_INFO_CDESC);
		layerInfo->lInfoFlags = PlayerInfo->dwInfoFlags;
		layerInfo->Name = SysAllocString(PlayerInfo->pwszName);
		layerInfo->lPlayerFlags = PlayerInfo->dwPlayerFlags;
		// We no longer need the playerinfo we got.. get rid of it..
		SAFE_DELETE_ARRAY(PlayerInfo);
		return S_OK;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		DPF(1,"***** GetPeerInfo ERROR...\n");
		return E_FAIL;
	}
}

HRESULT C_dxj_DirectPlayPeerObject::GetCountServiceProviders(long lFlags, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetCountSP call...\n");
		if (!m_SPInfo)
			if (FAILED (hr=GetSP(lFlags) ) )
				return hr;
		
		*ret = (long)m_dwSPCount;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetServiceProvider(long lIndex, DPN_SERVICE_PROVIDER_INFO_CDESC *ret)
{
	HRESULT hr;
	GUID	*guidSP = NULL;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetSP call...\n");
		if (!m_SPInfo)
			if (FAILED (hr=GetSP(0) ) )
				return hr;

		if ((lIndex < 1 ) || ((DWORD)lIndex > m_dwSPCount))
			return E_INVALIDARG;

		// Fill out our structure
		ret->lFlags = (long) m_SPInfo[lIndex-1].dwFlags;
		ret->Name = SysAllocString(m_SPInfo[lIndex-1].pwszName);

		guidSP = new GUID;
		if (!guidSP)
			return E_OUTOFMEMORY;

		memcpy(guidSP,&m_SPInfo[lIndex-1].guid,sizeof(GUID));
		ret->Guid = GUIDtoBSTR(guidSP);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetSP(long lFlags)
{
    // Enumerate all DirectPlay sevice providers
    
	HRESULT		hr;
	DWORD		dwSize=0;
	DWORD		dwItems=0;

	__try {
		SAFE_DELETE_ARRAY(m_SPInfo);
		hr = m__dxj_DirectPlayPeer->EnumServiceProviders( NULL, NULL, m_SPInfo, &dwSize, 
										  &dwItems, (DWORD) lFlags );
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		m_SPInfo = (DPN_SERVICE_PROVIDER_INFO*) new BYTE[dwSize];
		if (!m_SPInfo)
			return E_OUTOFMEMORY;

		ZeroMemory(m_SPInfo, dwSize);
		if( FAILED( hr = m__dxj_DirectPlayPeer->EnumServiceProviders( NULL, NULL, m_SPInfo, &dwSize, 
										  &dwItems, (DWORD) lFlags ) ) )
			return hr;

		m_dwSPCount = dwItems;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetClientsAndGroups(long lFlags)
{
    // Enumerate all DirectPlay clients and groups
    
	HRESULT		hr;
	DWORD		dwSize=0;

	__try {
		SAFE_DELETE_ARRAY(m_ClientsGroups);
		hr = m__dxj_DirectPlayPeer->EnumPlayersAndGroups(NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		m_ClientsGroups = (DPNID*) new BYTE[dwSize * sizeof(DPNID)];
		if (!m_ClientsGroups)
			return E_OUTOFMEMORY;

		if( FAILED( hr = m__dxj_DirectPlayPeer->EnumPlayersAndGroups(m_ClientsGroups, &dwSize, (DWORD) lFlags) ) )
			return hr;

		m_dwClientCount = dwSize;// sizeof(DPNID);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetGroupMembers(long lFlags, DPNID dpGroupID)
{
    // Enumerate all DirectPlay group members for this group
    
	HRESULT		hr;
	DWORD		dwSize=0;

	__try {
		SAFE_DELETE_ARRAY(m_GroupMembers);
		hr = m__dxj_DirectPlayPeer->EnumGroupMembers (dpGroupID, NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		m_GroupMembers = (DPNID*) new BYTE[dwSize * sizeof(DPNID)];
		if (!m_GroupMembers)
			return E_OUTOFMEMORY;

		if( FAILED( hr = m__dxj_DirectPlayPeer->EnumGroupMembers (dpGroupID, m_GroupMembers, &dwSize, (DWORD) lFlags) ) )
			return hr;

		m_dwGroupMemberCount = dwSize;
		m_dwGroupID = dpGroupID;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}


HRESULT C_dxj_DirectPlayPeerObject::RegisterLobby(long dpnHandle, I_dxj_DirectPlayLobbiedApplication *LobbyApp, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) RegisterLobby call...\n");
		DO_GETOBJECT_NOTNULL( IDirectPlay8LobbiedApplication*, lpLobby, LobbyApp);

		if (FAILED( hr = m__dxj_DirectPlayPeer->RegisterLobby((DPNHANDLE) dpnHandle, lpLobby,(DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetConnectionInfo(long idPlayer, long lFlags, DPN_CONNECTION_INFO_CDESC *pdpConnectionInfo)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetConnectionInfo call...\n");
		pdpConnectionInfo->lSize = sizeof(DPN_CONNECTION_INFO);
		if (FAILED( hr = m__dxj_DirectPlayPeer->GetConnectionInfo((DPNID) idPlayer, (DPN_CONNECTION_INFO*)pdpConnectionInfo, lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetPeerAddress(long idPlayer,long lFlags, I_dxj_DirectPlayAddress **pAddress)
{
	IDirectPlay8Address	*lpAdd = NULL;
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetPeerAddress call...\n");
		if (FAILED (hr = m__dxj_DirectPlayPeer->GetPeerAddress( (DPNID) idPlayer, &lpAdd, (DWORD) lFlags) ) )
			return hr;

		INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayAddress,lpAdd, pAddress);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetLocalHostAddress(long lFlags, I_dxj_DirectPlayAddress **pAddress)
{
	IDirectPlay8Address	*lpAdd = NULL;
	HRESULT hr;
	DWORD	dwItems = 0;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetLocalHostAddress call...\n");
		hr = m__dxj_DirectPlayPeer->GetLocalHostAddresses( &lpAdd,&dwItems, (DWORD) lFlags);
		if (FAILED (hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		if (dwItems>1) 
			return E_INVALIDARG;

		if ( FAILED (hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL,CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8Address, (LPVOID*) &lpAdd ) ) )
				return hr;
		
		hr = m__dxj_DirectPlayPeer->GetLocalHostAddresses( &lpAdd,&dwItems, (DWORD) lFlags);
		if (FAILED (hr))
			return hr;

		INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayAddress,lpAdd, pAddress);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::SetSPCaps(BSTR guidSP, DPN_SP_CAPS_CDESC *spCaps, long lFlags)
{
	HRESULT hr;
	GUID guidServiceProvider;

	__try {
		DPF(1,"-----Entering (DplayPeer) SetSPCaps call...\n");
		if (FAILED(hr = DPLAYBSTRtoGUID(&guidServiceProvider, guidSP) ) )
			return hr;

		spCaps->lSize = sizeof(DPN_SP_CAPS);
		//
		//	MiNara: Added 0 for dwFlags parameter
		//
		if (FAILED(hr = m__dxj_DirectPlayPeer->SetSPCaps(&guidServiceProvider,(DPN_SP_CAPS*)spCaps,(DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetSPCaps(BSTR guidSP, long lFlags, DPN_SP_CAPS_CDESC *spCaps)
{
	HRESULT hr;
	GUID guidServiceProvider;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetSPCaps call...\n");
		spCaps->lSize = sizeof(DPN_SP_CAPS);

		if (FAILED(hr = DPLAYBSTRtoGUID(&guidServiceProvider, guidSP) ) )
			return hr;

		if (FAILED(hr = m__dxj_DirectPlayPeer->GetSPCaps(&guidServiceProvider,(DPN_SP_CAPS*)spCaps, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::TerminateSession(long lFlags, void *UserData, long UserDataSize)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) TerminateSession call...\n");
		if (FAILED (hr = m__dxj_DirectPlayPeer->TerminateSession(UserData,UserDataSize,(DWORD) lFlags)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT WINAPI DirectPlayMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer )
{
	HRESULT									hr = S_OK;
	LPUNKNOWN								lpUnk = NULL;
	BOOL									fCallCoUninit = FALSE;
	VARIANT_BOOL							fRejectMsg = VARIANT_FALSE;

	
	// User context for the message handler is a pointer to our class module.
	C_dxj_DirectPlayPeerObject	*lpPeer = (C_dxj_DirectPlayPeerObject*)pvUserContext;

	if (!lpPeer) 
		return S_OK; //Object must be gone

	DPF2(1,"-----Entering (DplayPeer) MessageHandler call... (Current msg count=%d) MSGID = %d\n", lpPeer->m_dwMsgCount, dwMessageId );
	//Increment the msg count
	InterlockedIncrement(&lpPeer->m_dwMsgCount);

	if (!lpPeer->m_fHandleEvents)
	{
		DPF(1,"-----Leaving (DplayPeer) MessageHandler call (*Not Handling Events*)...\n");
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return S_OK;
	}

	if (!lpPeer->m_pEventStream) 
	{
		DPF(1,"-----Leaving (DplayPeer) MessageHandler call (Stream Not Present)...\n");
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return S_OK;
	}

	// First we need to set our stream seek back to the beginning
	// We will do this every time we enter this function since we don't know if
	// we are on the same thread or not...
	
	I_dxj_DirectPlayEvent	*lpEvent = NULL;
	__try {
		LARGE_INTEGER l;
		l.QuadPart = 0;
		lpPeer->m_pEventStream->Seek(l, STREAM_SEEK_SET, NULL);

		hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
		if (hr == CO_E_NOTINITIALIZED) // Call CoInit so we can unmarshal
		{
			DPF1(1,"-----Calling CoInitEx... HR = %d\n", hr);
			CoInitializeEx(NULL,COINIT_MULTITHREADED);
			hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
			fCallCoUninit = TRUE;
		}

		if (!lpEvent) 
		{
			DPF1(1,"-----Leaving (DplayPeer) MessageHandler call (No event interface)... HR = %d\n", hr);
			InterlockedDecrement(&lpPeer->m_dwMsgCount);
			return hr;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (DplayPeer) MessageHandler call (Stream Gone)...\n");
		return S_OK;
	}

    switch( dwMessageId )
	{
	//Receive
	case DPN_MSGID_RECEIVE:
		{
			DPF(1,"-----DirectPlayPeer8 Callback Receive\n");
			DPNMSG_RECEIVE				*pMsgReceive = (DPNMSG_RECEIVE*)pMsgBuffer;
			DPNMSG_RECEIVE_CDESC		m_dpReceive;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpReceive, sizeof(DPNMSG_RECEIVE_CDESC));
			m_dpReceive.idSender = pMsgReceive->dpnidSender;
			
			// Let's load our SafeArray

			if (pMsgReceive->dwReceiveDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = pMsgReceive->dwReceiveDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = pMsgReceive->pReceiveData;
				m_dpReceive.lDataSize = pMsgReceive->dwReceiveDataSize;
				m_dpReceive.ReceivedData = lpData;
			}

			lpEvent->Receive(&m_dpReceive, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}
			
			break;
		}

	//Send complete
	case DPN_MSGID_SEND_COMPLETE:
		{
			DPF(1,"-----DirectPlayPeer8 Callback SendComplete\n");
			DPNMSG_SEND_COMPLETE				*msg = (DPNMSG_SEND_COMPLETE*)pMsgBuffer;
			DPNMSG_SEND_COMPLETE_CDESC			m_dpSend;

			ZeroMemory(&m_dpSend, sizeof(DPNMSG_SEND_COMPLETE_CDESC));
			m_dpSend.AsyncOpHandle = (long)msg->hAsyncOp;
			m_dpSend.hResultCode = (long)msg->hResultCode;
			m_dpSend.lSendTime = (long)msg->dwSendTime;

			lpEvent->SendComplete(&m_dpSend, &fRejectMsg);
			break;
		}

	//Async Op complete
	case DPN_MSGID_ASYNC_OP_COMPLETE:
		{
			DPF(1,"-----DirectPlayPeer8 Callback AsyncOpComplete\n");
			DPNMSG_ASYNC_OP_COMPLETE				*msg = (DPNMSG_ASYNC_OP_COMPLETE*)pMsgBuffer;
			DPNMSG_ASYNC_OP_COMPLETE_CDESC			m_dpAsynOp;
			
			ZeroMemory(&m_dpAsynOp, sizeof(DPNMSG_ASYNC_OP_COMPLETE_CDESC));
			m_dpAsynOp.AsyncOpHandle = (long) msg->hAsyncOp;
			m_dpAsynOp.hResultCode = (long) msg->hResultCode;

			lpEvent->AsyncOpComplete(&m_dpAsynOp, &fRejectMsg);
			break;
		}

	// Add/Remove players from groups
	case DPN_MSGID_ADD_PLAYER_TO_GROUP:
	case DPN_MSGID_REMOVE_PLAYER_FROM_GROUP:
		{
			DPF(1,"-----DirectPlayPeer8 Callback Add/Remove Group\n");
			DPNMSG_ADD_PLAYER_TO_GROUP				*msg = (DPNMSG_ADD_PLAYER_TO_GROUP*)pMsgBuffer;
			DPNID									m_dpnidAddRemoveGroupID = 0;
			DPNID									m_dpnidAddRemovePlayerID = 0;

			m_dpnidAddRemoveGroupID = msg->dpnidGroup;
			m_dpnidAddRemovePlayerID = msg->dpnidPlayer;

			lpEvent->AddRemovePlayerGroup(dwMessageId, m_dpnidAddRemovePlayerID, m_dpnidAddRemoveGroupID, &fRejectMsg);
			break;
		}

	// App Desc
	case DPN_MSGID_APPLICATION_DESC:
		{
			DPF(1,"-----DirectPlayPeer8 Callback App desc\n");
			lpEvent->AppDesc(&fRejectMsg);
		break;
		}

	// Indicate Connect
	case DPN_MSGID_INDICATE_CONNECT:
		{
			DPF(1,"-----DirectPlayPeer8 Callback Indicate Connect\n");
			DPNMSG_INDICATE_CONNECT				*msg = (DPNMSG_INDICATE_CONNECT*)pMsgBuffer;
			DPNMSG_INDICATE_CONNECT_CDESC		m_dpIndConnect;
			WCHAR* wszAddress = NULL;
			WCHAR* wszDevice = NULL;
			DWORD									dwNumChars = 0;


			ZeroMemory(&m_dpIndConnect, sizeof(DPNMSG_INDICATE_CONNECT_CDESC));

			__try {
				if (msg->pAddressPlayer)
				{
					hr = msg->pAddressPlayer->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
                        wszAddress = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
						if (FAILED (hr = msg->pAddressPlayer->GetURLW(wszAddress,&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpIndConnect.AddressPlayerUrl = SysAllocString(wszAddress);
						}
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (Indicate Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
						DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
                    wszDevice = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
					if (FAILED (hr = msg->pAddressDevice->GetURLW(wszDevice,&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpIndConnect.AddressDeviceUrl = SysAllocString(wszDevice);
					}
				}
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (Indicate Connect -  Part2)...\n");
			}

			lpEvent->IndicateConnect(&m_dpIndConnect, &fRejectMsg);
			// Get rid of these addresses
			if (m_dpIndConnect.AddressPlayerUrl)
				SysFreeString(m_dpIndConnect.AddressPlayerUrl);

			if (m_dpIndConnect.AddressDeviceUrl)
				SysFreeString(m_dpIndConnect.AddressDeviceUrl);
		break;
		}

	// Connect complete
	case DPN_MSGID_CONNECT_COMPLETE:
		{
			DPF(1,"-----DirectPlayPeer8 Callback ConnectComplete\n");
			DPNMSG_CONNECT_COMPLETE				*msg = (DPNMSG_CONNECT_COMPLETE*)pMsgBuffer;
			DPNMSG_CONNECT_COMPLETE_CDESC		m_dpConnectComp;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpConnectComp, sizeof(DPNMSG_CONNECT_COMPLETE_CDESC));
			m_dpConnectComp.hResultCode = (long) msg->hResultCode;
			m_dpConnectComp.AsyncOpHandle =(long) msg->hAsyncOp;
			// Let's load our SafeArray

			if (msg->dwApplicationReplyDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwApplicationReplyDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pvApplicationReplyData;
				m_dpConnectComp.ReplyData = lpData;
			}

			lpEvent->ConnectComplete(&m_dpConnectComp, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}
		break;
		}

	// Host migrated
	case DPN_MSGID_HOST_MIGRATE:
		{
			DPF(1,"-----DirectPlayPeer8 Callback HostMigrate\n");
			DPNMSG_HOST_MIGRATE				*msg = (DPNMSG_HOST_MIGRATE*)pMsgBuffer;
			DPNID							m_dpnidNewHostID = 0;

			m_dpnidNewHostID = msg->dpnidNewHost;

			lpEvent->HostMigrate(m_dpnidNewHostID, &fRejectMsg);
	
			break;
		}

	// Terminate Session
	case DPN_MSGID_TERMINATE_SESSION:
		{
			DPF(1,"-----DirectPlayPeer8 Callback TerminateSession\n");
			DPNMSG_TERMINATE_SESSION		*msg = (DPNMSG_TERMINATE_SESSION*)pMsgBuffer;
			DPNMSG_TERMINATE_SESSION_CDESC			m_dpTerm;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpTerm, sizeof(DPNMSG_TERMINATE_SESSION_CDESC));
			m_dpTerm.hResultCode = msg->hResultCode;

			// Let's load our SafeArray

			if (msg->dwTerminateDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwTerminateDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pvTerminateData;
				m_dpTerm.TerminateData = lpData;
			}

			lpEvent->TerminateSession(&m_dpTerm,&fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}

		break;
		}

	// Enum Host query
	case DPN_MSGID_ENUM_HOSTS_QUERY:
		{
			DPF(1,"-----DirectPlayPeer8 Callback EnumHostQuery\n");
			DPNMSG_ENUM_HOSTS_QUERY				*msg = (DPNMSG_ENUM_HOSTS_QUERY*)pMsgBuffer;
			DPNMSG_ENUM_HOSTS_QUERY_CDESC			m_dpEnumHostQuery;
			WCHAR* wszAddress = NULL;
			WCHAR* wszDevice = NULL;
			DWORD									dwNumChars = 0;

			
			ZeroMemory(&m_dpEnumHostQuery, sizeof(DPNMSG_ENUM_HOSTS_QUERY_CDESC));

			__try {
				hr = msg->pAddressSender->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
					DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
                    wszAddress = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
					if (FAILED (hr = msg->pAddressSender->GetURLW(wszAddress,&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpEnumHostQuery.AddressSenderUrl = SysAllocString(wszAddress);
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumQuery Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
					DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
                    wszDevice = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
					if (FAILED (hr = msg->pAddressDevice->GetURLW(wszDevice,&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpEnumHostQuery.AddressDeviceUrl = SysAllocString(wszDevice);
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumQuery Connect - Part2)...\n");
			}
			lpEvent->EnumHostsQuery(&m_dpEnumHostQuery, &fRejectMsg);

			// Get rid of these addresses
			if (m_dpEnumHostQuery.AddressSenderUrl)
				SysFreeString(m_dpEnumHostQuery.AddressSenderUrl);

			if (m_dpEnumHostQuery.AddressDeviceUrl)
				SysFreeString(m_dpEnumHostQuery.AddressDeviceUrl);

			break;
		}
	
	// Create Player
	case DPN_MSGID_CREATE_PLAYER:
		{
			DPF(1,"-----DirectPlayPeer8 Callback CreatePlayer\n");
			DPNMSG_CREATE_PLAYER	*msg = (DPNMSG_CREATE_PLAYER*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			
			m_dpnidPlayerID = msg->dpnidPlayer;

			lpEvent->CreatePlayer(m_dpnidPlayerID, &fRejectMsg);
			
		break;
		}

	// Destroy Player
	case DPN_MSGID_DESTROY_PLAYER:
		{
			DPF(1,"-----DirectPlayPeer8 Callback DestroyPlayer\n");
			DPNMSG_DESTROY_PLAYER	*msg = (DPNMSG_DESTROY_PLAYER*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DWORD									m_dwReason = 0;
			
			m_dpnidPlayerID = msg->dpnidPlayer;
			m_dwReason = msg->dwReason;
			
			lpEvent->DestroyPlayer(m_dpnidPlayerID, m_dwReason, &fRejectMsg);
		break;
		}

	// Create Group
	case DPN_MSGID_CREATE_GROUP:
		{
			DPF(1,"-----DirectPlayPeer8 Callback CreateGroup\n");
			DPNMSG_CREATE_GROUP	*msg = (DPNMSG_CREATE_GROUP*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DPNID									m_dpnidOwnerID = 0;
			
			m_dpnidPlayerID = msg->dpnidGroup;
			m_dpnidOwnerID = msg->dpnidOwner;
			
			lpEvent->CreateGroup(m_dpnidPlayerID, m_dpnidOwnerID, &fRejectMsg);
		break;
		}

	//Destroy Group
	case DPN_MSGID_DESTROY_GROUP:
		{
			DPF(1,"-----DirectPlayPeer8 Callback DestroyGroup\n");
			DPNMSG_DESTROY_GROUP	*msg = (DPNMSG_DESTROY_GROUP*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DWORD									m_dwReason = 0;
			
			m_dpnidPlayerID = msg->dpnidGroup;
			m_dwReason = msg->dwReason;
			

			lpEvent->DestroyGroup(m_dpnidPlayerID, m_dwReason, &fRejectMsg);
		break;
		}


	// Info
	case DPN_MSGID_PEER_INFO:
	case DPN_MSGID_CLIENT_INFO:
	case DPN_MSGID_SERVER_INFO:
	case DPN_MSGID_GROUP_INFO:
		{
			DPF(1,"-----DirectPlayPeer8 Callback Info\n");
			DPNMSG_PEER_INFO	*msg = (DPNMSG_PEER_INFO*)pMsgBuffer;
			DPNID									m_dpnidInfoID = 0;
			
			m_dpnidInfoID = msg->dpnidPeer;

			lpEvent->InfoNotify(dwMessageId, m_dpnidInfoID, &fRejectMsg);
			break;
		}

	// EnumHostRes
	case DPN_MSGID_ENUM_HOSTS_RESPONSE:
		{
			DPF(1,"-----DirectPlayPeer8 Callback EnumHostResponse\n");
			DPNMSG_ENUM_HOSTS_RESPONSE	*msg = (DPNMSG_ENUM_HOSTS_RESPONSE*)pMsgBuffer;
			DPNMSG_ENUM_HOSTS_RESPONSE_CDESC		m_dpEnumHostRes;
			DWORD									dwNumChars = 0;
			WCHAR* wszAddress = NULL;
			WCHAR* wszDevice = NULL;

			
			ZeroMemory(&m_dpEnumHostRes, sizeof(DPNMSG_ENUM_HOSTS_RESPONSE_CDESC));

			m_dpEnumHostRes.ApplicationDescription.lSize = (long)msg->pApplicationDescription->dwSize;
			m_dpEnumHostRes.ApplicationDescription.lFlags = msg->pApplicationDescription->dwFlags;
			m_dpEnumHostRes.ApplicationDescription.guidInstance = GUIDtoBSTR((GUID*)&msg->pApplicationDescription->guidInstance);
			m_dpEnumHostRes.ApplicationDescription.guidApplication = GUIDtoBSTR((GUID*)&msg->pApplicationDescription->guidApplication);
			m_dpEnumHostRes.ApplicationDescription.lMaxPlayers = (long)msg->pApplicationDescription->dwMaxPlayers;
			m_dpEnumHostRes.ApplicationDescription.lCurrentPlayers = (long)msg->pApplicationDescription->dwCurrentPlayers;
			m_dpEnumHostRes.ApplicationDescription.SessionName = SysAllocString(msg->pApplicationDescription->pwszSessionName);
			m_dpEnumHostRes.ApplicationDescription.Password = SysAllocString(msg->pApplicationDescription->pwszPassword);
			m_dpEnumHostRes.lRoundTripLatencyMS = (long) msg->dwRoundTripLatencyMS;

			__try {
				if (msg->pAddressSender)
				{
					DPF(1,"-----About to get AdressSender...\n");
					hr = msg->pAddressSender->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
                        wszAddress = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
						DPF1(1,"--- About to call GetURLW, NumChars= %d\n",dwNumChars);
						if (FAILED (hr = msg->pAddressSender->GetURLW(wszAddress,&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpEnumHostRes.AddressSenderUrl = SysAllocString(wszAddress);
						}
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumRes Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				if (msg->pAddressDevice)
				{
					DPF(1,"-----About to get AdressDevice...\n");
					hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else {
						DPF1(1,"--- About to call GetURLW, NumChars= %d\n",dwNumChars);
                        wszDevice = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
						if (FAILED (hr = msg->pAddressDevice->GetURLW(wszDevice,&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpEnumHostRes.AddressDeviceUrl = SysAllocString(wszDevice);
						}
					}
				}
			
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumRes Connect - Part1)...\n");
			}

			lpEvent->EnumHostsResponse(&m_dpEnumHostRes, &fRejectMsg);

			if (m_dpEnumHostRes.AddressSenderUrl)
				SysFreeString(m_dpEnumHostRes.AddressSenderUrl);

			if (m_dpEnumHostRes.AddressDeviceUrl)
				SysFreeString(m_dpEnumHostRes.AddressDeviceUrl);
		break;
		}

	// Indicate Connect
	case DPN_MSGID_INDICATED_CONNECT_ABORTED:
		{
			DPF(1,"-----DirectPlayServer8 Callback Indicated Connect Abort\n");

			lpEvent->IndicatedConnectAborted(&fRejectMsg);

		break;
		}
	}

	if (fCallCoUninit)
		CoUninitialize();

	InterlockedDecrement(&lpPeer->m_dwMsgCount);
	DPF(1,"-----Leaving (DplayPeer) MessageHandler call...\n");
	if (fRejectMsg != VARIANT_FALSE)
		return E_FAIL;

	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::RegisterMessageHandler(I_dxj_DirectPlayEvent *event)
{
    HRESULT	  hr=S_OK;
    LPSTREAM  pStm=NULL;

	if (!event) return E_INVALIDARG;
    
    if (!m_fHandleEvents)
	{
		DPF(1,"-----Entering (DplayPeer) RegisterMessageHandler call...\n");
		SAFE_RELEASE(m_pEventStream);

		// Create a global stream.  The stream needs to be global so we can 
		// marshal once, and unmarshal as many times as necessary
		hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);
		if FAILED(hr) return hr;

		// Now we can marshal our IUnknown interface.  We use MSHLFLAGS_TABLEWEAK 
		// so we can unmarshal any number of times
		hr = CoMarshalInterface(pStm, IID_I_dxj_DirectPlayEvent, event, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLEWEAK);
		if FAILED(hr) return hr;

		// Now we need to set the seek location of the stream to the beginning
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStm->Seek(l, STREAM_SEEK_SET, NULL);
    
		m_pEventStream=pStm;
		if (!m_fInit)
		{
			if (FAILED ( hr = m__dxj_DirectPlayPeer->Initialize( this, DirectPlayMessageHandler, 0 ) ) )
				return hr;
			m_fInit = TRUE;
		}
		m_fHandleEvents = TRUE;
	}
	else
		return DPNERR_ALREADYINITIALIZED;

	return hr;
}

HRESULT C_dxj_DirectPlayPeerObject::UnRegisterMessageHandler()
{
	DPF(1,"-----Entering (DplayPeer) UnregisterMessageHandler call...\n");
	m_fHandleEvents = FALSE;
	//Clear out the messages currently waiting
	FlushBuffer(0);
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::FlushBuffer(LONG dwNumMessagesLeft)
{
	
	DWORD dwTime = GetTickCount();

	DPF(1,"-----Entering (DplayPeer) FlushBuffer call...\n");
	//Clear out the messages currently waiting
	BOOL bGotMsg = FALSE; 
	BOOL bWait = FALSE; 
	int i=0; 
	MSG msg; 
	HRESULT hr = S_OK; 
	msg.message = WM_NULL; 
	while ((WM_QUIT != msg.message) && (m_dwMsgCount > dwNumMessagesLeft)) 
	{ 
		bGotMsg = PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE); 
		i++; 
		if (GetTickCount() - dwTime > 5000)
		{
			// Don't let FlushBuffer wait more than 5 seconds
			DPF1(1,"-----Leaving (DplayPeer) FlushBuffer call (All messages *not* flushed - %d remained)...\n", m_dwMsgCount);
			return S_OK;
		}
		if (bGotMsg) 
		{ 
			TranslateMessage( &msg ); 
			DispatchMessage( &msg ); 
		} 
		bGotMsg = FALSE; 
		Sleep(0);
	} 
	DPF(1,"-----Leaving (DplayPeer) FlushBuffer call (All messages flushed)...\n");
	return S_OK;
}

DWORD WINAPI ClosePeerThreadProc(void* lpParam)
{
	// User context for the message handler is a pointer to our class module.
	IDirectPlay8Peer	*lpPeer = (IDirectPlay8Peer*)lpParam;

	DPF(1,"-----Entering (DplayPeer) ClosePeerThreadProc call...\n");
	lpPeer->Close(0);
	DPF(1,"-----Leaving (DplayPeer) ClosePeerThreadProc call ...\n");
	return 0;
}

DWORD WINAPI ReleasePeerThreadProc(void* lpParam)
{
	// User context for the message handler is a pointer to our class module.
	IDirectPlay8Peer	*lpPeer = (IDirectPlay8Peer*)lpParam;

	DPF(1,"-----Entering (DplayPeer) ReleasePeerThreadProc call...\n");
	SAFE_RELEASE(lpPeer);
	DPF(1,"-----Leaving (DplayPeer) ReleasePeerThreadProc call ...\n");
	CloseHandle(GetCurrentThread());
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplayserverobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPlayServerObj.h"					   
#include "dplayaddressobj.h"

extern void *g_dxj_DirectPlayAddress;
extern void *g_dxj_DirectPlayServer;
extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT DPLAYBSTRtoGUID(LPGUID,BSTR);
extern BOOL IsEmptyString(BSTR szString);

#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }
#define SAFE_DELETE_ARRAY(p)       { if(p) { delete [] (p); p=NULL; } }
#define SAFE_RELEASE(p)      { __try { if(p) { int i = 0; i = (p)->Release(); DPF1(1,"--DirectPlayServer SafeRelease (RefCount = %d)\n",i); if (!i) { (p)=NULL;}} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { (p) = NULL;} } 

HRESULT WINAPI DirectPlayServerMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer );

DWORD WINAPI CloseServerThreadProc(void* lpParam);
DWORD WINAPI ReleaseServerThreadProc(void* lpParam);

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayServerObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF1(1,"----- DXVB: DirectPlayServer8 AddRef %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayServerObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF1(1,"----- DXVB: DirectPlayServer8 Release %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayServerObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayServerObject::C_dxj_DirectPlayServerObject(){ 
		
	DPF(1,"Constructor Creation  DirectPlayServer8 Object\n ");

	m__dxj_DirectPlayServer = NULL;

	m_fHandleEvents = FALSE;
	m_SPInfo = NULL;
	m_dwSPCount = 0;
	m_ClientsGroups = NULL;
	m_GroupMembers = NULL;
	m_dwGroupID = 0;
	m_dwClientCount = 0;
	m_dwGroupMemberCount = 0;
	m_ClientsGroups = NULL;
	m_GroupMembers = NULL;
	m_dwGroupID = 0;
	m_dwClientCount = 0;
	m_dwGroupMemberCount = 0;
	m_fInit = FALSE;

	m_fHandleEvents = FALSE;
	m_pEventStream=NULL;
	m_dwMsgCount = 0;
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayServerObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayServerObject::~C_dxj_DirectPlayServerObject()
{

	DPF(1,"----- Entering ~C_dxj_DirectPlayServerObject destructor \n");

	// Stop handling events and flush the buffer
	m_fHandleEvents = FALSE;
	FlushBuffer(0);

	SAFE_DELETE_ARRAY(m_SPInfo);
	SAFE_DELETE_ARRAY(m_ClientsGroups);
	SAFE_DELETE_ARRAY(m_GroupMembers);
	SAFE_RELEASE(m_pEventStream);

	HANDLE hThread = NULL;
	DWORD dwThread = 0;
	// We are quitting anyway, so we don't really care what is going on in this thread..
	hThread = CreateThread(NULL, 0, ReleaseServerThreadProc, this->m__dxj_DirectPlayServer, 0, &dwThread);
}

HRESULT C_dxj_DirectPlayServerObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayServer;
	
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayServer=(IDirectPlay8Server*)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetCountPlayersAndGroups(long lFlags, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetCountPlayersAndGroups call...\n");
		// On the GetCount call we will always get the latest info
		if (FAILED ( hr = GetClientsAndGroups(lFlags) ) )
			return hr;
		
		*ret = m_dwClientCount;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetPlayerOrGroup(long lIndex, long *ret)
{
	__try {
		DPF(1,"-----Entering (DPlayServer) GetPlayerOrGroup call...\n");
		if (!m_ClientsGroups)
			return E_INVALIDARG;

		if ((lIndex < 1 ) || ((DWORD)lIndex > m_dwClientCount))
			return E_INVALIDARG;

		// Fill out our structure
		*ret = m_ClientsGroups[lIndex - 1];
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetCountGroupMembers(long dpid,long lFlags, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetCountGroupMemberss call...\n");
		// On the GetCount call we will always get the latest info
		if (FAILED ( hr = GetGroupMembers(lFlags, (DPNID) dpid) ) )
			return hr;
		
		*ret = m_dwGroupMemberCount;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetGroupMember(long lIndex,long dpid, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetGroupMember call...\n");
		if ((!m_GroupMembers) || ((DPNID)dpid != m_dwGroupID) )
			if (FAILED (hr = GetGroupMembers(0, (DPNID) dpid) ) )
				return hr;

		if ((lIndex < 1 ) || ((DWORD)lIndex > m_dwGroupMemberCount))
			return E_INVALIDARG;

		// Fill out our structure
		if (!m_GroupMembers)
			return E_INVALIDARG;

		*ret = m_GroupMembers[lIndex - 1];
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::CancelAsyncOperation(long lAsyncHandle, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) CancelAsyncOperation call...\n");
		if (FAILED( hr= m__dxj_DirectPlayServer->CancelAsyncOperation((DPNHANDLE) lAsyncHandle, (DWORD) lFlags) ) ) 
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::SendTo(long idSend ,SAFEARRAY **Buffer, long lTimeOut,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_BUFFER_DESC		lpBuf;
	DWORD				dwBufSize = ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		DPF(1,"-----Entering (DPlayServer) SendTo call...\n");
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}
			
		lpBuf.dwBufferSize = dwBufSize;
		lpBuf.pBufferData  = (BYTE*)((SAFEARRAY*)*Buffer)->pvData;

		hr = m__dxj_DirectPlayServer->SendTo((DPNID) idSend, &lpBuf, 1, (DWORD) lTimeOut, NULL, dpAsync, (DWORD) lFlags);
		
		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}

		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::CreateGroup(DPN_GROUP_INFO_CDESC *GroupInfo,long lFlags, long *hAsyncHandle)
{
	HRESULT			hr;
	DPN_GROUP_INFO	dpnGroup;
    WCHAR			wszName[MAX_PATH];
	DPNHANDLE		*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DPlayServer) CreateGroup call...\n");
		if (!IsEmptyString(GroupInfo->Name)) wcscpy(wszName,GroupInfo->Name);

		ZeroMemory(&dpnGroup, sizeof(DPN_GROUP_INFO) );
		dpnGroup.dwSize = sizeof(DPN_GROUP_INFO);
		dpnGroup.dwInfoFlags = GroupInfo->lInfoFlags;
		dpnGroup.dwGroupFlags = GroupInfo->lGroupFlags;
		dpnGroup.pwszName = wszName;

		hr = m__dxj_DirectPlayServer->CreateGroup(&dpnGroup, NULL, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::AddPlayerToGroup(long idGroup, long idClient,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DPlayServer) AddPlayerToGroup call...\n");
		hr = m__dxj_DirectPlayServer->AddPlayerToGroup((DPNID) idGroup, (DPNID) idClient, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}

		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetSendQueueInfo(long idPlayer, long *lNumMsgs, long *lNumBytes, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetSendQueueInfo call...\n");
		if (FAILED (hr = m__dxj_DirectPlayServer->GetSendQueueInfo((DPNID) idPlayer, (DWORD*)lNumMsgs, (DWORD*)lNumBytes, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::SetGroupInfo(long idGroup, DPN_GROUP_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_GROUP_INFO dpInfo;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DPlayServer) SetGroupInfo call...\n");
		ZeroMemory(&dpInfo, sizeof(DPN_GROUP_INFO) );

		dpInfo.dwSize = sizeof(DPN_GROUP_INFO);
		dpInfo.dwInfoFlags = PlayerInfo->lInfoFlags;
		dpInfo.pwszName = PlayerInfo->Name;
		dpInfo.dwGroupFlags = PlayerInfo->lGroupFlags;

		hr = m__dxj_DirectPlayServer->SetGroupInfo((DPNID) idGroup, &dpInfo, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetGroupInfo(long idGroup,long lFlags, DPN_GROUP_INFO_CDESC *layerInfo)
{
	HRESULT			hr;
	DPN_GROUP_INFO	*PlayerInfo = NULL;
	DWORD			dwInfoSize = 0;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetGroupInfo call...\n");
		hr = m__dxj_DirectPlayServer->GetGroupInfo( (DPNID) idGroup, NULL, &dwInfoSize, (DWORD) lFlags );
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		PlayerInfo = (DPN_GROUP_INFO*) new BYTE[ dwInfoSize ];
		if (!PlayerInfo)
			return E_OUTOFMEMORY;

		ZeroMemory( PlayerInfo, dwInfoSize );
		PlayerInfo->dwSize = sizeof(DPN_GROUP_INFO);
		hr = m__dxj_DirectPlayServer->GetGroupInfo( (DPNID) idGroup, PlayerInfo, &dwInfoSize, (DWORD) lFlags );
		if( FAILED(hr) )
			return hr;

		layerInfo->lSize = sizeof(DPN_GROUP_INFO_CDESC);
		layerInfo->lInfoFlags = PlayerInfo->dwInfoFlags;
		layerInfo->Name = SysAllocString(PlayerInfo->pwszName);
		layerInfo->lGroupFlags = PlayerInfo->dwGroupFlags;
		// We no longer need the playerinfo we got.. get rid of it..
		SAFE_DELETE_ARRAY(PlayerInfo);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::SetServerInfo(DPN_PLAYER_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_PLAYER_INFO dpInfo;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DPlayServer) SetServerInfo call...\n");
		ZeroMemory(&dpInfo, sizeof(DPN_PLAYER_INFO) );

		dpInfo.dwSize = sizeof(DPN_PLAYER_INFO);
		dpInfo.dwInfoFlags = PlayerInfo->lInfoFlags;
		dpInfo.pwszName = PlayerInfo->Name;
		dpInfo.dwPlayerFlags = PlayerInfo->lPlayerFlags;

		hr = m__dxj_DirectPlayServer->SetServerInfo(&dpInfo, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetClientInfo(long idPeer,long lFlags, DPN_PLAYER_INFO_CDESC *layerInfo)
{
	HRESULT				hr;
    DWORD				dwSize = 0;
    DPN_PLAYER_INFO		*PlayerInfo = NULL;
    
	__try {
		DPF(1,"-----Entering (DPlayServer) GetClientInfo call...\n");
		hr = m__dxj_DirectPlayServer->GetClientInfo( (DPNID) idPeer, NULL, &dwSize, (DWORD) lFlags );
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		PlayerInfo = (DPN_PLAYER_INFO*) new BYTE[ dwSize ];
		if (!PlayerInfo)
			return E_OUTOFMEMORY;

		ZeroMemory( PlayerInfo, dwSize );
		PlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);
		hr = m__dxj_DirectPlayServer->GetClientInfo( (DPNID) idPeer, PlayerInfo, &dwSize, (DWORD) lFlags );
		if( FAILED(hr) )
			return hr;

		layerInfo->lSize = sizeof(DPN_PLAYER_INFO_CDESC);
		layerInfo->lInfoFlags = PlayerInfo->dwInfoFlags;
		layerInfo->Name = SysAllocString(PlayerInfo->pwszName);
		layerInfo->lPlayerFlags = PlayerInfo->dwPlayerFlags;
		// We no longer need the playerinfo we got.. get rid of it..
		SAFE_DELETE_ARRAY(PlayerInfo);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;

}

HRESULT C_dxj_DirectPlayServerObject::GetApplicationDesc(long lFlags, DPN_APPLICATION_DESC_CDESC *ret)
{
	HRESULT					hr;
	DWORD					dwSize = 0;
	DPN_APPLICATION_DESC	*desc = NULL;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetApplicationDesc call...\n");
		//First get the size
		hr = m__dxj_DirectPlayServer->GetApplicationDesc(NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		desc = (DPN_APPLICATION_DESC*) new BYTE[dwSize];
		if (!desc)
			return E_OUTOFMEMORY;

		ZeroMemory(desc, dwSize);

		desc->dwSize = sizeof(DPN_APPLICATION_DESC);
		if (FAILED( hr= m__dxj_DirectPlayServer->GetApplicationDesc(desc, &dwSize, (DWORD) lFlags) ) )
			return hr;

		// Now return the vals 
		ret->lSize = dwSize;
		ret->lFlags = desc->dwFlags;
		ret->guidInstance = GUIDtoBSTR(&desc->guidInstance);
		ret->guidApplication = GUIDtoBSTR(&desc->guidApplication);
		ret->lMaxPlayers = desc->dwMaxPlayers;
		ret->lCurrentPlayers = desc->dwCurrentPlayers;
		ret->SessionName = SysAllocString(desc->pwszSessionName);
		ret->Password = SysAllocString(desc->pwszPassword);
		SAFE_DELETE_ARRAY(desc);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::SetApplicationDesc(DPN_APPLICATION_DESC_CDESC *AppDesc, long lFlags)
{
	HRESULT					hr;
	DPN_APPLICATION_DESC	*desc = NULL;
    WCHAR					wszSessionName[MAX_PATH];
    WCHAR					wszPassword[MAX_PATH];
	GUID					guidApp;
	DWORD					dwSize = 0;

	__try {
		DPF(1,"-----Entering (DPlayServer) SetApplicationDesc call...\n");
	
		desc = new DPN_APPLICATION_DESC;
		if (!desc)
			return E_OUTOFMEMORY;

		ZeroMemory(desc, sizeof(DPN_APPLICATION_DESC));

		desc->dwSize = sizeof(DPN_APPLICATION_DESC);

		if (!IsEmptyString(AppDesc->SessionName))
		{
			wcscpy(wszSessionName,AppDesc->SessionName);
			desc->pwszSessionName = wszSessionName;
		}
		if (!IsEmptyString(AppDesc->Password)) 
		{
			wcscpy(wszPassword,AppDesc->Password);
			desc->pwszPassword = wszPassword;
		}
		
		if (FAILED(hr = DPLAYBSTRtoGUID(&guidApp, AppDesc->guidApplication) ) )
			return hr;
		desc->guidApplication = guidApp;

		desc->dwMaxPlayers = AppDesc->lMaxPlayers;

		if (FAILED( hr= m__dxj_DirectPlayServer->SetApplicationDesc(desc, (DWORD) lFlags) ) )
			return hr;

		SAFE_DELETE(desc);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}


HRESULT C_dxj_DirectPlayServerObject::Host(DPN_APPLICATION_DESC_CDESC *AppDesc,I_dxj_DirectPlayAddress *Address, long lFlags)
{
	HRESULT hr;
	DPN_APPLICATION_DESC	desc;
    WCHAR wszSessionName[MAX_PATH];
    WCHAR wszPassword[MAX_PATH];

	__try {
		DPF(1,"-----Entering (DPlayServer) Host call...\n");
		if (!IsEmptyString(AppDesc->SessionName)) wcscpy(wszSessionName,AppDesc->SessionName);
		if (!IsEmptyString(AppDesc->Password)) wcscpy(wszPassword,AppDesc->Password);
		
		DO_GETOBJECT_NOTNULL( IDirectPlay8Address*, lpAddress, Address);

		ZeroMemory(&desc, sizeof(DPN_APPLICATION_DESC) );

		desc.dwSize = sizeof(DPN_APPLICATION_DESC);
		desc.dwFlags = AppDesc->lFlags;
		desc.dwMaxPlayers = AppDesc->lMaxPlayers;
		desc.dwCurrentPlayers = AppDesc->lCurrentPlayers;
		if (!IsEmptyString(AppDesc->SessionName))
			desc.pwszSessionName = wszSessionName;
		if (!IsEmptyString(AppDesc->Password))
			desc.pwszPassword = wszPassword;

		if (AppDesc->guidApplication)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&desc.guidApplication, AppDesc->guidApplication) ) )
				return hr;
		}

		if (AppDesc->guidInstance)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&desc.guidInstance , AppDesc->guidInstance) ) )
				return hr;
		}

		if (FAILED (hr = m__dxj_DirectPlayServer->Host(&desc, &lpAddress, 1, NULL, NULL, NULL, (DWORD) lFlags ) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::Close(long lFlags)
{
	HRESULT hr;
	BOOL bGotMsg = FALSE;
	BOOL bWait = FALSE;
	DWORD dwObj = 0;
	int i=0;
	MSG msg;

	HANDLE hThread = NULL;
	__try {
		DPF(1,"-----Entering (DPlayServer) Close call...\n");
		FlushBuffer(0);

		DWORD dwThread = 0;

		hThread = CreateThread(NULL, 0, CloseServerThreadProc, this->m__dxj_DirectPlayServer, 0, &dwThread);
		msg.message = WM_NULL;

		while ((WM_QUIT != msg.message) && (!bWait))
		{
			bGotMsg = PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE);
			i++;
			if ((!bGotMsg) || (i>10))
			{
				dwObj = WaitForSingleObject(hThread, 10);
				bWait = (dwObj == WAIT_OBJECT_0);
				i = 0;
			}
			if (bGotMsg)
			{
				TranslateMessage( &msg );
				DispatchMessage( &msg );
			}
			bGotMsg = FALSE;
		}


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	CloseHandle(hThread);
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetCaps(long lFlags, DPNCAPS_CDESC *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetCaps call...\n");
		ret->lSize = sizeof(DPN_CAPS);
		if (FAILED (hr=m__dxj_DirectPlayServer->GetCaps( (DPN_CAPS*) ret, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::SetCaps(DPNCAPS_CDESC *Caps, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) SetCaps call...\n");
		if (FAILED( hr = m__dxj_DirectPlayServer->SetCaps((DPN_CAPS*)Caps, (DWORD)lFlags)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::RemovePlayerFromGroup(long idGroup, long idClient,long lFlags,long *hAsyncHandle)
{
	HRESULT hr;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DPlayServer) RemovePlayerFromGroup call...\n");
		hr = m__dxj_DirectPlayServer->RemovePlayerFromGroup( (DPNID) idGroup,
						(DPNID) idClient, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::ReturnBuffer(long lBufferHandle)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) ReturnBuffer call...\n");
		if (FAILED(hr = m__dxj_DirectPlayServer->ReturnBuffer( (DPNHANDLE) lBufferHandle, 0 ) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::DestroyClient(long idClient, long lFlags, void *UserData, long UserDataSize)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) DestroyClient call...\n");
		if (FAILED( hr= m__dxj_DirectPlayServer->DestroyClient((DPNID) idClient, UserData, UserDataSize, (DWORD) lFlags) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::DestroyGroup(long idGroup,long lFlags,long *hAsyncHandle)
{
	HRESULT hr;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DPlayServer) DestroyGroup call...\n");
		hr= m__dxj_DirectPlayServer->DestroyGroup((DPNID) idGroup, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}


HRESULT C_dxj_DirectPlayServerObject::RegisterLobby(long dpnHandle, I_dxj_DirectPlayLobbiedApplication *LobbyApp, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) RegisterLobby call...\n");
		DO_GETOBJECT_NOTNULL( IDirectPlay8LobbiedApplication*, lpLobby, LobbyApp);

		if (FAILED( hr = m__dxj_DirectPlayServer->RegisterLobby((DPNHANDLE) dpnHandle, lpLobby,(DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetCountServiceProviders(long lFlags, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetCountServiceProviders call...\n");
		if (!m_SPInfo)
			if (FAILED (hr=GetSP(lFlags) ) )
				return hr;
		
		*ret = (long)m_dwSPCount;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetServiceProvider(long lIndex, DPN_SERVICE_PROVIDER_INFO_CDESC *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetServiceProvider call...\n");
		if (!m_SPInfo)
			if (FAILED (hr=GetSP(0) ) )
				return hr;

		if ((lIndex < 1 ) || ((DWORD)lIndex > m_dwSPCount))
			return E_INVALIDARG;

		// Fill out our structure
		ret->lFlags = (long) m_SPInfo[lIndex-1].dwFlags;
		ret->Name = SysAllocString(m_SPInfo[lIndex-1].pwszName);

		ret->Guid = GUIDtoBSTR(&m_SPInfo[lIndex-1].guid);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetSP(long lFlags)
{
    // Enumerate all DirectPlay sevice providers
    
	HRESULT		hr;
	DWORD		dwSize=0;
	DWORD		dwItems=0;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetSP call...\n");
		SAFE_DELETE_ARRAY(m_SPInfo);
		hr = m__dxj_DirectPlayServer->EnumServiceProviders( NULL, NULL, m_SPInfo, &dwSize, 
										  &dwItems, (DWORD) lFlags );
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		m_SPInfo = (DPN_SERVICE_PROVIDER_INFO*) new BYTE[dwSize];
		if (!m_SPInfo)
			return E_OUTOFMEMORY;

		if( FAILED( hr = m__dxj_DirectPlayServer->EnumServiceProviders( NULL, NULL, m_SPInfo, &dwSize, 
										  &dwItems, (DWORD) lFlags ) ) )
			return hr;

		m_dwSPCount = dwItems;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
HRESULT C_dxj_DirectPlayServerObject::GetClientsAndGroups(long lFlags)
{
    // Enumerate all DirectPlay clients and groups
    
	HRESULT		hr;
	DWORD		dwSize=0;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetClientsAndGroups call...\n");
		SAFE_DELETE_ARRAY(m_ClientsGroups);
		hr = m__dxj_DirectPlayServer->EnumPlayersAndGroups(NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		m_ClientsGroups = (DPNID*) new BYTE[dwSize * sizeof(DPNID)];
		if (!m_ClientsGroups)
			return E_OUTOFMEMORY;

		if( FAILED( hr = m__dxj_DirectPlayServer->EnumPlayersAndGroups(m_ClientsGroups, &dwSize, (DWORD) lFlags) ) )
			return hr;

		m_dwClientCount = dwSize;// sizeof(DPNID);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetGroupMembers(long lFlags, DPNID dpGroupID)
{
    // Enumerate all DirectPlay group members for this group
    
	HRESULT		hr;
	DWORD		dwSize=0;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetGroupMembers call...\n");
		SAFE_DELETE_ARRAY(m_GroupMembers);
		hr = m__dxj_DirectPlayServer->EnumGroupMembers(dpGroupID, NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		m_GroupMembers = new DPNID[dwSize];
		if (!m_GroupMembers)
			return E_OUTOFMEMORY;

		if( FAILED( hr = m__dxj_DirectPlayServer->EnumGroupMembers(dpGroupID, m_GroupMembers, &dwSize, (DWORD) lFlags) ) )
			return hr;

		m_dwGroupMemberCount = dwSize;
		m_dwGroupID = dpGroupID;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetConnectionInfo(long idPlayer, long lFlags, DPN_CONNECTION_INFO_CDESC *pdpConnectionInfo)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetConnectionInfo call...\n");
		pdpConnectionInfo->lSize = sizeof(DPN_CONNECTION_INFO);
		if (FAILED( hr = m__dxj_DirectPlayServer->GetConnectionInfo((DPNID) idPlayer, (DPN_CONNECTION_INFO*)pdpConnectionInfo, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetClientAddress(long idPlayer,long lFlags, I_dxj_DirectPlayAddress **pAddress)
{
	IDirectPlay8Address	*lpAdd = NULL;
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetClientAddress call...\n");
		if (FAILED (hr = m__dxj_DirectPlayServer->GetClientAddress( (DPNID) idPlayer, &lpAdd, (DWORD) lFlags) ) )
			return hr;

		INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayAddress,lpAdd, pAddress);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetLocalHostAddress(long lFlags, I_dxj_DirectPlayAddress **pAddress)
{
	IDirectPlay8Address	*lpAdd = NULL;
	HRESULT hr;
	DWORD	dwItems = 0;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetLocalHostAddress call...\n");
		hr = m__dxj_DirectPlayServer->GetLocalHostAddresses( &lpAdd,&dwItems, (DWORD) lFlags);
		if (FAILED (hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		if (dwItems>1) 
			return E_INVALIDARG;

		if ( FAILED (hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL,CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8Address, (LPVOID*) &lpAdd ) ) )
				return hr;
		
		hr = m__dxj_DirectPlayServer->GetLocalHostAddresses( &lpAdd,&dwItems, (DWORD) lFlags);
		if (FAILED (hr))
			return hr;

		INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayAddress,lpAdd, pAddress);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::SetSPCaps(BSTR guidSP, DPN_SP_CAPS_CDESC *spCaps, long lFlags)
{
	HRESULT hr;
	GUID guidServiceProvider;

	__try {
		DPF(1,"-----Entering (DPlayServer) SetSPCaps call...\n");
		if (FAILED(hr = DPLAYBSTRtoGUID(&guidServiceProvider, guidSP) ) )
			return hr;

		spCaps->lSize = sizeof(DPN_SP_CAPS);
		//
		//	MiNara: Added 0 for dwFlags parameter
		//
		if (FAILED(hr = m__dxj_DirectPlayServer->SetSPCaps(&guidServiceProvider,(DPN_SP_CAPS*)spCaps,(DWORD) lFlags) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetSPCaps(BSTR guidSP, long lFlags, DPN_SP_CAPS_CDESC *spCaps)
{
	HRESULT hr;
	GUID guidServiceProvider;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetSPCaps call...\n");
		spCaps->lSize = sizeof(DPN_SP_CAPS);
		if (FAILED(hr = DPLAYBSTRtoGUID(&guidServiceProvider, guidSP) ) )
			return hr;

		if (FAILED(hr = m__dxj_DirectPlayServer->GetSPCaps(&guidServiceProvider,(DPN_SP_CAPS*)spCaps, (DWORD) lFlags) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}


HRESULT WINAPI DirectPlayServerMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer )
{
	HRESULT					hr=S_OK;
	LPUNKNOWN			    lpUnk=NULL;
	BOOL					fCallCoUninit = FALSE;
	VARIANT_BOOL			fRejectMsg = VARIANT_FALSE;
	
	// User context for the message handler is a pointer to our class module.
	C_dxj_DirectPlayServerObject	*lpPeer = (C_dxj_DirectPlayServerObject*)pvUserContext;

	if (!lpPeer) 
		return S_OK; //Object must be gone

	DPF2(1,"-----Entering (DPlayServer) MessageHandler call... (Current msg count=%d) MSGID = %d\n", lpPeer->m_dwMsgCount, dwMessageId );
	//Increment the msg count
	InterlockedIncrement(&lpPeer->m_dwMsgCount);

	if (!lpPeer->m_fHandleEvents)
	{
		DPF(1,"-----Leaving (DPlayServer) MessageHandler call (*Not Handling Events*)...\n");
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return S_OK;
	}

	if (!lpPeer->m_pEventStream) 
	{
		DPF(1,"-----Leaving (DPlayServer) MessageHandler call (Stream Not Present)...\n");
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return S_OK;
	}

	// First we need to set our stream seek back to the beginning
	// We will do this every time we enter this function since we don't know if
	// we are on the same thread or not...
	
	I_dxj_DirectPlayEvent	*lpEvent = NULL;
	__try {
		LARGE_INTEGER l;
		l.QuadPart = 0;
		lpPeer->m_pEventStream->Seek(l, STREAM_SEEK_SET, NULL);

		hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
		if (hr == CO_E_NOTINITIALIZED) // Call CoInit so we can unmarshal
		{
			CoInitializeEx(NULL,COINIT_MULTITHREADED);
			hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
			fCallCoUninit = TRUE;
		}

		if (!lpEvent) 
		{
			DPF(1,"-----Leaving (DPlayServer) MessageHandler call (No event interface)...\n");
			InterlockedDecrement(&lpPeer->m_dwMsgCount);
			return hr;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (DPlayServer) MessageHandler call (Stream Gone)...\n");
		return S_OK;
	}

    switch( dwMessageId )
	{
	//Receive
	case DPN_MSGID_RECEIVE:
		{
			DPF(1,"-----DirectPlayServer8 Callback Receive\n");
			DPNMSG_RECEIVE				*pMsgReceive = (DPNMSG_RECEIVE*)pMsgBuffer;
			DPNMSG_RECEIVE_CDESC		m_dpReceive;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpReceive, sizeof(DPNMSG_RECEIVE_CDESC));
			m_dpReceive.idSender = pMsgReceive->dpnidSender;
			
			// Let's load our SafeArray

			if (pMsgReceive->dwReceiveDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = pMsgReceive->dwReceiveDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = pMsgReceive->pReceiveData;
				m_dpReceive.lDataSize = pMsgReceive->dwReceiveDataSize;
				m_dpReceive.ReceivedData = lpData;
			}

			lpEvent->Receive(&m_dpReceive, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}
			
			break;
		}

	//Send complete
	case DPN_MSGID_SEND_COMPLETE:
		{
			DPF(1,"-----DirectPlayServer8 Callback SendComplete\n");
			DPNMSG_SEND_COMPLETE				*msg = (DPNMSG_SEND_COMPLETE*)pMsgBuffer;
			DPNMSG_SEND_COMPLETE_CDESC			m_dpSend;

			ZeroMemory(&m_dpSend, sizeof(DPNMSG_SEND_COMPLETE_CDESC));
			m_dpSend.AsyncOpHandle = (long)msg->hAsyncOp;
			m_dpSend.hResultCode = (long)msg->hResultCode;
			m_dpSend.lSendTime = (long)msg->dwSendTime;

			lpEvent->SendComplete(&m_dpSend, &fRejectMsg);
			break;
		}

	//Async Op complete
	case DPN_MSGID_ASYNC_OP_COMPLETE:
		{
			DPF(1,"-----DirectPlayServer8 Callback AsyncOpComplete\n");
			DPNMSG_ASYNC_OP_COMPLETE				*msg = (DPNMSG_ASYNC_OP_COMPLETE*)pMsgBuffer;
			DPNMSG_ASYNC_OP_COMPLETE_CDESC			m_dpAsynOp;
			
			ZeroMemory(&m_dpAsynOp, sizeof(DPNMSG_ASYNC_OP_COMPLETE_CDESC));
			m_dpAsynOp.AsyncOpHandle = (long) msg->hAsyncOp;
			m_dpAsynOp.hResultCode = (long) msg->hResultCode;

			lpEvent->AsyncOpComplete(&m_dpAsynOp, &fRejectMsg);
			break;
		}

	// Add/Remove players from groups
	case DPN_MSGID_ADD_PLAYER_TO_GROUP:
	case DPN_MSGID_REMOVE_PLAYER_FROM_GROUP:
		{
			DPF(1,"-----DirectPlayServer8 Callback Add/Remove Group\n");
			DPNMSG_ADD_PLAYER_TO_GROUP				*msg = (DPNMSG_ADD_PLAYER_TO_GROUP*)pMsgBuffer;
			DPNID									m_dpnidAddRemoveGroupID = 0;
			DPNID									m_dpnidAddRemovePlayerID = 0;

			m_dpnidAddRemoveGroupID = msg->dpnidGroup;
			m_dpnidAddRemovePlayerID = msg->dpnidPlayer;

			lpEvent->AddRemovePlayerGroup(dwMessageId, m_dpnidAddRemovePlayerID, m_dpnidAddRemoveGroupID, &fRejectMsg);
			break;
		}

	// App Desc
	case DPN_MSGID_APPLICATION_DESC:
		{
			DPF(1,"-----DirectPlayServer8 Callback App desc\n");
			lpEvent->AppDesc(&fRejectMsg);
		break;
		}

	// Indicate Connect
	case DPN_MSGID_INDICATE_CONNECT:
		{
			DPF(1,"-----DirectPlayServer8 Callback Indicate Connect\n");
			DPNMSG_INDICATE_CONNECT				*msg = (DPNMSG_INDICATE_CONNECT*)pMsgBuffer;
			DPNMSG_INDICATE_CONNECT_CDESC		m_dpIndConnect;
			WCHAR* wszAddress = NULL;
			WCHAR* wszDevice = NULL;
			DWORD									dwNumChars = 0;


			ZeroMemory(&m_dpIndConnect, sizeof(DPNMSG_INDICATE_CONNECT_CDESC));

			__try {
				if (msg->pAddressPlayer)
				{
					hr = msg->pAddressPlayer->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
                        wszAddress = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
						if (FAILED (hr = msg->pAddressPlayer->GetURLW(wszAddress,&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpIndConnect.AddressPlayerUrl = SysAllocString(wszAddress);
						}
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (Indicate Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
						DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
                    wszDevice = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
					if (FAILED (hr = msg->pAddressDevice->GetURLW(wszDevice,&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpIndConnect.AddressDeviceUrl = SysAllocString(wszDevice);
					}
				}
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (Indicate Connect -  Part2)...\n");
			}

			lpEvent->IndicateConnect(&m_dpIndConnect, &fRejectMsg);
			// Get rid of these addresses
			if (m_dpIndConnect.AddressPlayerUrl)
				SysFreeString(m_dpIndConnect.AddressPlayerUrl);

			if (m_dpIndConnect.AddressDeviceUrl)
				SysFreeString(m_dpIndConnect.AddressDeviceUrl);
		break;
		}

	// Connect complete
	case DPN_MSGID_CONNECT_COMPLETE:
		{
			DPF(1,"-----DirectPlayServer8 Callback ConnectComplete\n");
			DPNMSG_CONNECT_COMPLETE				*msg = (DPNMSG_CONNECT_COMPLETE*)pMsgBuffer;
			DPNMSG_CONNECT_COMPLETE_CDESC		m_dpConnectComp;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpConnectComp, sizeof(DPNMSG_CONNECT_COMPLETE_CDESC));
			m_dpConnectComp.hResultCode = (long) msg->hResultCode;
			m_dpConnectComp.AsyncOpHandle =(long) msg->hAsyncOp;
			// Let's load our SafeArray

			if (msg->dwApplicationReplyDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwApplicationReplyDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pvApplicationReplyData;
				m_dpConnectComp.ReplyData = lpData;
			}

			lpEvent->ConnectComplete(&m_dpConnectComp, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}
		break;
		}

	// Host migrated
	case DPN_MSGID_HOST_MIGRATE:
		{
			DPF(1,"-----DirectPlayServer8 Callback HostMigrate\n");
			DPNMSG_HOST_MIGRATE				*msg = (DPNMSG_HOST_MIGRATE*)pMsgBuffer;
			DPNID							m_dpnidNewHostID = 0;

			m_dpnidNewHostID = msg->dpnidNewHost;

			lpEvent->HostMigrate(m_dpnidNewHostID, &fRejectMsg);
	
			break;
		}

	// Terminate Session
	case DPN_MSGID_TERMINATE_SESSION:
		{
			DPF(1,"-----DirectPlayServer8 Callback TerminateSession\n");
			DPNMSG_TERMINATE_SESSION		*msg = (DPNMSG_TERMINATE_SESSION*)pMsgBuffer;
			DPNMSG_TERMINATE_SESSION_CDESC			m_dpTerm;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpTerm, sizeof(DPNMSG_TERMINATE_SESSION_CDESC));
			m_dpTerm.hResultCode = msg->hResultCode;

			// Let's load our SafeArray

			if (msg->dwTerminateDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwTerminateDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pvTerminateData;
				m_dpTerm.TerminateData = lpData;
			}

			lpEvent->TerminateSession(&m_dpTerm,&fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}

		break;
		}

	// Enum Host query
	case DPN_MSGID_ENUM_HOSTS_QUERY:
		{
			DPF(1,"-----DirectPlayServer8 Callback EnumHostQuery\n");
			DPNMSG_ENUM_HOSTS_QUERY				*msg = (DPNMSG_ENUM_HOSTS_QUERY*)pMsgBuffer;
			DPNMSG_ENUM_HOSTS_QUERY_CDESC			m_dpEnumHostQuery;
			WCHAR* wszAddress = NULL;
			WCHAR* wszDevice = NULL;
			DWORD									dwNumChars = 0;

			
			ZeroMemory(&m_dpEnumHostQuery, sizeof(DPNMSG_ENUM_HOSTS_QUERY_CDESC));

			__try {
				hr = msg->pAddressSender->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
					DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
                    wszAddress = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
					if (FAILED (hr = msg->pAddressSender->GetURLW(wszAddress,&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpEnumHostQuery.AddressSenderUrl = SysAllocString(wszAddress);
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumQuery Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
					DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
                    wszDevice = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
					if (FAILED (hr = msg->pAddressDevice->GetURLW(wszDevice,&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpEnumHostQuery.AddressDeviceUrl = SysAllocString(wszDevice);
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumQuery Connect - Part2)...\n");
			}
			lpEvent->EnumHostsQuery(&m_dpEnumHostQuery, &fRejectMsg);

			// Get rid of these addresses
			if (m_dpEnumHostQuery.AddressSenderUrl)
				SysFreeString(m_dpEnumHostQuery.AddressSenderUrl);

			if (m_dpEnumHostQuery.AddressDeviceUrl)
				SysFreeString(m_dpEnumHostQuery.AddressDeviceUrl);

			break;
		}
	
	// Create Player
	case DPN_MSGID_CREATE_PLAYER:
		{
			DPF(1,"-----DirectPlayServer8 Callback CreatePlayer\n");
			DPNMSG_CREATE_PLAYER	*msg = (DPNMSG_CREATE_PLAYER*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			
			m_dpnidPlayerID = msg->dpnidPlayer;

			lpEvent->CreatePlayer(m_dpnidPlayerID, &fRejectMsg);
			
		break;
		}

	// Destroy Player
	case DPN_MSGID_DESTROY_PLAYER:
		{
			DPF(1,"-----DirectPlayServer8 Callback DestroyPlayer\n");
			DPNMSG_DESTROY_PLAYER	*msg = (DPNMSG_DESTROY_PLAYER*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DWORD									m_dwReason = 0;
			
			m_dpnidPlayerID = msg->dpnidPlayer;
			m_dwReason = msg->dwReason;
			
			lpEvent->DestroyPlayer(m_dpnidPlayerID, m_dwReason, &fRejectMsg);
		break;
		}

	// Create Group
	case DPN_MSGID_CREATE_GROUP:
		{
			DPF(1,"-----DirectPlayServer8 Callback CreateGroup\n");
			DPNMSG_CREATE_GROUP	*msg = (DPNMSG_CREATE_GROUP*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DPNID									m_dpnidOwnerID = 0;
			
			m_dpnidPlayerID = msg->dpnidGroup;
			m_dpnidOwnerID = msg->dpnidOwner;
			
			lpEvent->CreateGroup(m_dpnidPlayerID, m_dpnidOwnerID, &fRejectMsg);
		break;
		}

	//Destroy Group
	case DPN_MSGID_DESTROY_GROUP:
		{
			DPF(1,"-----DirectPlayServer8 Callback DestroyGroup\n");
			DPNMSG_DESTROY_GROUP	*msg = (DPNMSG_DESTROY_GROUP*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DWORD									m_dwReason = 0;
			
			m_dpnidPlayerID = msg->dpnidGroup;
			m_dwReason = msg->dwReason;
			

			lpEvent->DestroyGroup(m_dpnidPlayerID, m_dwReason, &fRejectMsg);
		break;
		}


	// Info
	case DPN_MSGID_PEER_INFO:
	case DPN_MSGID_CLIENT_INFO:
	case DPN_MSGID_SERVER_INFO:
	case DPN_MSGID_GROUP_INFO:
		{
			DPF(1,"-----DirectPlayServer8 Callback Info\n");
			DPNMSG_PEER_INFO	*msg = (DPNMSG_PEER_INFO*)pMsgBuffer;
			DPNID									m_dpnidInfoID = 0;
			
			m_dpnidInfoID = msg->dpnidPeer;

			lpEvent->InfoNotify(dwMessageId, m_dpnidInfoID, &fRejectMsg);
			break;
		}

	// EnumHostRes
	case DPN_MSGID_ENUM_HOSTS_RESPONSE:
		{
			DPF(1,"-----DirectPlayServer8 Callback EnumHostResponse\n");
			DPNMSG_ENUM_HOSTS_RESPONSE	*msg = (DPNMSG_ENUM_HOSTS_RESPONSE*)pMsgBuffer;
			DPNMSG_ENUM_HOSTS_RESPONSE_CDESC		m_dpEnumHostRes;
			DWORD									dwNumChars = 0;
			WCHAR* wszAddress = NULL;
			WCHAR* wszDevice = NULL;

			
			ZeroMemory(&m_dpEnumHostRes, sizeof(DPNMSG_ENUM_HOSTS_RESPONSE_CDESC));

			m_dpEnumHostRes.ApplicationDescription.lSize = (long)msg->pApplicationDescription->dwSize;
			m_dpEnumHostRes.ApplicationDescription.lFlags = msg->pApplicationDescription->dwFlags;
			m_dpEnumHostRes.ApplicationDescription.guidInstance = GUIDtoBSTR((GUID*)&msg->pApplicationDescription->guidInstance);
			m_dpEnumHostRes.ApplicationDescription.guidApplication = GUIDtoBSTR((GUID*)&msg->pApplicationDescription->guidApplication);
			m_dpEnumHostRes.ApplicationDescription.lMaxPlayers = (long)msg->pApplicationDescription->dwMaxPlayers;
			m_dpEnumHostRes.ApplicationDescription.lCurrentPlayers = (long)msg->pApplicationDescription->dwCurrentPlayers;
			m_dpEnumHostRes.ApplicationDescription.SessionName = SysAllocString(msg->pApplicationDescription->pwszSessionName);
			m_dpEnumHostRes.ApplicationDescription.Password = SysAllocString(msg->pApplicationDescription->pwszPassword);
			m_dpEnumHostRes.lRoundTripLatencyMS = (long) msg->dwRoundTripLatencyMS;

			__try {
				if (msg->pAddressSender)
				{
					DPF(1,"-----About to get AdressSender...\n");
					hr = msg->pAddressSender->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
                        wszAddress = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
						if (FAILED (hr = msg->pAddressSender->GetURLW(wszAddress,&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpEnumHostRes.AddressSenderUrl = SysAllocString(wszAddress);
						}
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumRes Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				if (msg->pAddressDevice)
				{
					DPF(1,"-----About to get AdressDevice...\n");
					hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else {
                        wszDevice = (WCHAR*)_alloca(sizeof(WCHAR) * dwNumChars);
						if (FAILED (hr = msg->pAddressDevice->GetURLW(wszDevice,&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpEnumHostRes.AddressDeviceUrl = SysAllocString(wszDevice);
						}
					}
				}
			
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumRes Connect - Part1)...\n");
			}
			lpEvent->EnumHostsResponse(&m_dpEnumHostRes, &fRejectMsg);
			if (m_dpEnumHostRes.AddressSenderUrl)
				SysFreeString(m_dpEnumHostRes.AddressSenderUrl);

			if (m_dpEnumHostRes.AddressDeviceUrl)
				SysFreeString(m_dpEnumHostRes.AddressDeviceUrl);
		break;
		}

	// Indicate Connect
	case DPN_MSGID_INDICATED_CONNECT_ABORTED:
		{
			DPF(1,"-----DirectPlayServer8 Callback Indicated Connect Abort\n");

			lpEvent->IndicatedConnectAborted(&fRejectMsg);

		break;
		}
	}

	if (fCallCoUninit)
		CoUninitialize();

	InterlockedDecrement(&lpPeer->m_dwMsgCount);
	DPF(1,"-----Leaving (DPlayServer) MessageHandler call...\n");

	if (fRejectMsg != VARIANT_FALSE)
		return E_FAIL;

	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::RegisterMessageHandler(I_dxj_DirectPlayEvent *event)
{
    HRESULT	  hr=S_OK;
    LPSTREAM  pStm=NULL;

	if (!event) return E_INVALIDARG;
    
    if (!m_fHandleEvents)
	{
		DPF(1,"-----Entering (DplayServer) RegisterMessageHandler call...\n");
		SAFE_RELEASE(m_pEventStream);

		// Create a global stream.  The stream needs to be global so we can 
		// marshal once, and unmarshal as many times as necessary
		hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);
		if FAILED(hr) return hr;

		// Now we can marshal our IUnknown interface.  We use MSHLFLAGS_TABLEWEAK 
		// so we can unmarshal any number of times
		hr = CoMarshalInterface(pStm, IID_I_dxj_DirectPlayEvent, event, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLEWEAK);
		if FAILED(hr) return hr;

		// Now we need to set the seek location of the stream to the beginning
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStm->Seek(l, STREAM_SEEK_SET, NULL);
    
		m_pEventStream=pStm;
		if (!m_fInit)
		{
			if (FAILED ( hr = m__dxj_DirectPlayServer->Initialize( this, DirectPlayServerMessageHandler, 0 ) ) )
				return hr;
			m_fInit = TRUE;
		}
		m_fHandleEvents = TRUE;
	}
	else
		return DPNERR_ALREADYINITIALIZED;

	return hr;
}

HRESULT C_dxj_DirectPlayServerObject::UnRegisterMessageHandler()
{
	DPF(1,"-----Entering (DPlayServer) UnregisterMessageHandler call...\n");
	m_fHandleEvents = FALSE;
	//Clear out the messages currently waiting
	FlushBuffer(0);
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::FlushBuffer(LONG dwNumMessagesLeft)
{
	DWORD dwTime = GetTickCount();

	DPF(1,"-----Entering (DPlayServer) FlushBuffer call...\n");
	//Clear out the messages currently waiting
	BOOL bGotMsg = FALSE; 
	BOOL bWait = FALSE; 
	int i=0; 
	MSG msg; 
	HRESULT hr = S_OK; 
	msg.message = WM_NULL; 
	while ((WM_QUIT != msg.message) && (m_dwMsgCount > dwNumMessagesLeft)) 
	{ 
		bGotMsg = PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE); 
		i++; 
		if (GetTickCount() - dwTime > 5000)
		{
			// Don't let FlushBuffer wait more than 5 seconds
			DPF1(1,"-----Leaving (DPlayServer) FlushBuffer call (All messages *not* flushed - %d remained)...\n", m_dwMsgCount);
			return S_OK;
		}
		if (bGotMsg) 
		{ 
			TranslateMessage( &msg ); 
			DispatchMessage( &msg ); 
		} 
		bGotMsg = FALSE; 
		Sleep(0);
	} 
	DPF(1,"-----Leaving (DPlayServer) FlushBuffer call (All messages flushed)...\n");
	return S_OK;
}


DWORD WINAPI CloseServerThreadProc(void* lpParam)
{
	// User context for the message handler is a pointer to our class module.
	IDirectPlay8Server	*lpPeer = (IDirectPlay8Server*)lpParam;

	DPF(1,"-----Entering (DPlayServer) CloseServerThreadProc call...\n");
	lpPeer->Close(0);
	DPF(1,"-----Leaving (DPlayServer) CloseServerThreadProc call ...\n");
	return 0;
}
DWORD WINAPI ReleaseServerThreadProc(void* lpParam)
{
	// User context for the message handler is a pointer to our class module.
	IDirectPlay8Server	*lpPeer = (IDirectPlay8Server*)lpParam;

	DPF(1,"-----Entering (DPlayServer) ReleaseServerThreadProc call...\n");
	SAFE_RELEASE(lpPeer);
	DPF(1,"-----Leaving (DPlayServer) ReleaseServerThreadProc call ...\n");
	CloseHandle(GetCurrentThread());
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplayserverobj.h ===
#include "resource.h"       // main symbols
#include "dplay8.h"

//Forward declare the class
class C_dxj_DirectPlayServerObject;

#define typedef__dxj_DirectPlayServer IDirectPlay8Server*

/////////////////////////////////////////////////////////////////////////////
// Direct Net Peer

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayServerObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayServer, &IID_I_dxj_DirectPlayServer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayServer,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayServerObject() ;
	virtual ~C_dxj_DirectPlayServerObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayServerObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayServer)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayServerObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayServer
public:
	 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE RegisterMessageHandler(I_dxj_DirectPlayEvent *event);

		// Enum for Clients/Groups
		HRESULT STDMETHODCALLTYPE GetCountPlayersAndGroups(long lFlags, long *ret);
		HRESULT STDMETHODCALLTYPE GetPlayerOrGroup(long lIndex, long *ret);
		// Enum Players in groups
		HRESULT STDMETHODCALLTYPE GetCountGroupMembers(long dpid,long lFlags, long *ret);
		HRESULT STDMETHODCALLTYPE GetGroupMember(long lIndex,long dpid, long *ret);

		HRESULT STDMETHODCALLTYPE GetCountServiceProviders(long lFlags, long *ret);
		HRESULT STDMETHODCALLTYPE GetServiceProvider(long lIndex, DPN_SERVICE_PROVIDER_INFO_CDESC *ret);
		HRESULT STDMETHODCALLTYPE CancelAsyncOperation(long lAsyncHandle, long lFlags);
		HRESULT STDMETHODCALLTYPE SendTo(long idSend ,SAFEARRAY **Buffer, long lTimeOut,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE CreateGroup(DPN_GROUP_INFO_CDESC *GroupInfo,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE AddPlayerToGroup(long idGroup, long idClient,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE GetSendQueueInfo(long idPlayer, long *lNumMsgs, long *lNumBytes, long lFlags);
		HRESULT STDMETHODCALLTYPE SetGroupInfo(long idGroup, DPN_GROUP_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE GetGroupInfo(long idGroup,long lFlags, DPN_GROUP_INFO_CDESC *layerInfo);
		HRESULT STDMETHODCALLTYPE SetServerInfo(DPN_PLAYER_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE GetClientInfo(long idPeer,long lFlags, DPN_PLAYER_INFO_CDESC *layerInfo);
		HRESULT STDMETHODCALLTYPE GetApplicationDesc(long lFlags, DPN_APPLICATION_DESC_CDESC *ret);
		HRESULT STDMETHODCALLTYPE SetApplicationDesc(DPN_APPLICATION_DESC_CDESC *AppDesc, long lFlags);
		HRESULT STDMETHODCALLTYPE Host(DPN_APPLICATION_DESC_CDESC *AppDesc,I_dxj_DirectPlayAddress *Address, long lFlags);
		HRESULT STDMETHODCALLTYPE Close(long lFlags);
		HRESULT STDMETHODCALLTYPE GetCaps(long lFlags, DPNCAPS_CDESC *ret);
		HRESULT STDMETHODCALLTYPE SetCaps(DPNCAPS_CDESC *Caps, long lFlags);
		HRESULT STDMETHODCALLTYPE RemovePlayerFromGroup(long idGroup, long idClient,long lFlags,long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE ReturnBuffer(long lBufferHandle);
		HRESULT STDMETHODCALLTYPE DestroyClient(long idClient, long lFlags, void *UserData, long UserDataSize);
		HRESULT STDMETHODCALLTYPE DestroyGroup(long idGroup,long lFlags,long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE RegisterLobby(long dpnHandle, I_dxj_DirectPlayLobbiedApplication *LobbyApp, long lFlags);
		HRESULT STDMETHODCALLTYPE GetConnectionInfo(long idPlayer, long lFlags, DPN_CONNECTION_INFO_CDESC *pdpConnectionInfo);

		HRESULT STDMETHODCALLTYPE GetClientAddress(long idPlayer,long lFlags, I_dxj_DirectPlayAddress **pAddress);
		HRESULT STDMETHODCALLTYPE GetLocalHostAddress(long lFlags, I_dxj_DirectPlayAddress **pAddress);
		HRESULT STDMETHODCALLTYPE SetSPCaps(BSTR guidSP, DPN_SP_CAPS_CDESC *spCaps, long lFlags);
		HRESULT STDMETHODCALLTYPE GetSPCaps(BSTR guidSP, long lFlags, DPN_SP_CAPS_CDESC *spCaps);
		HRESULT STDMETHODCALLTYPE GetUserData(void *UserData, long *UserDataSize);
		HRESULT STDMETHODCALLTYPE SetUserData(void *UserData, long UserDataSize);
		HRESULT STDMETHODCALLTYPE UnRegisterMessageHandler();

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayServer);

private:
	BOOL									m_fInit;
    DPN_SERVICE_PROVIDER_INFO	*m_SPInfo;
	DWORD						m_dwSPCount;
	DPNID						*m_ClientsGroups;
	DPNID						*m_GroupMembers;
	DPNID						m_dwGroupID;
	DWORD						m_dwClientCount;
	DWORD						m_dwGroupMemberCount;

	HRESULT STDMETHODCALLTYPE	GetSP(long lFlags);
	HRESULT STDMETHODCALLTYPE	GetClientsAndGroups(long lFlags);
	HRESULT STDMETHODCALLTYPE	GetGroupMembers(long lFlags, DPNID dpGroupID);
	HRESULT STDMETHODCALLTYPE	FlushBuffer(LONG dwNumMessagesLeft);

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayServer);

	DWORD InternalAddRef();
	DWORD InternalRelease();

	BOOL									m_fHandleEvents;
	IStream									*m_pEventStream;

	//We need to keep a count of the messages
	LONG									m_dwMsgCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplayvoiceclientobj.h ===
#include "resource.h"       // main symbols
#include "dSoundObj.h"
#include "dSoundCaptureObj.h"

#define typedef__dxj_DirectPlayVoiceClient LPDIRECTPLAYVOICECLIENT

	/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayVoiceClientObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayVoiceClient, &IID_I_dxj_DirectPlayVoiceClient, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayVoiceClient,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayVoiceClientObject() ;
	virtual ~C_dxj_DirectPlayVoiceClientObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayVoiceClientObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayVoiceClient)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayVoiceClientObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayVoiceClient
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

        HRESULT STDMETHODCALLTYPE Initialize ( 
            /* [in] */ IUnknown __RPC_FAR *DplayObj,
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE Connect ( 
            /* [in] */ DVSOUNDDEVICECONFIG_CDESC __RPC_FAR *SoundDeviceConfig,
            /* [in] */ DVCLIENTCONFIG_CDESC __RPC_FAR *ClientConfig,
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE Disconnect ( 
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE GetSessionDesc ( 
            /* [out][in] */ DVSESSIONDESC_CDESC __RPC_FAR *SessionDesc);
        
        HRESULT STDMETHODCALLTYPE GetClientConfig ( 
            /* [out][in] */ DVCLIENTCONFIG_CDESC __RPC_FAR *ClientConfig);
        
        HRESULT STDMETHODCALLTYPE SetClientConfig ( 
            /* [in] */ DVCLIENTCONFIG_CDESC __RPC_FAR *ClientConfig);
        
        HRESULT STDMETHODCALLTYPE GetCaps ( 
            /* [out][in] */ DVCAPS_CDESC __RPC_FAR *Caps);
        
        HRESULT STDMETHODCALLTYPE GetCompressionTypeCount ( 
            /* [retval][out] */ long __RPC_FAR *v1);
        
        HRESULT STDMETHODCALLTYPE GetCompressionType ( 
            /* [in] */ long lIndex,
            /* [out][in] */ DVCOMPRESSIONINFO_CDESC __RPC_FAR *Data,
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE SetTransmitTargets ( 
            /* [in] */ SAFEARRAY **playerIDs,
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE GetTransmitTargets ( 
            /* [in] */ long lFlags,
            /* [retval][out] */ SAFEARRAY **ret);
 
		HRESULT STDMETHODCALLTYPE SetCurrentSoundDevices (
			/* [in] */ I_dxj_DirectSound *DirectSoundObj, 
			/* [in] */ I_dxj_DirectSoundCapture *DirectCaptureObj);

		HRESULT STDMETHODCALLTYPE GetSoundDevices (
			/* [in,out] */ I_dxj_DirectSound __RPC_FAR *DirectSoundObj, 
			/* [in,out] */ I_dxj_DirectSoundCapture __RPC_FAR *DirectCaptureObj);
		
		HRESULT STDMETHODCALLTYPE Create3DSoundBuffer (
			/* [in] */ long playerID, 
						I_dxj_DirectSoundBuffer __RPC_FAR *Buffer,
						long lPriority,
						long lFlags, 
			/* [out,retval] */ I_dxj_DirectSound3dBuffer __RPC_FAR **UserBuffer);

		HRESULT STDMETHODCALLTYPE Delete3DSoundBuffer (
			/* [in] */ long playerID, 
			/* [in] */ I_dxj_DirectSound3dBuffer __RPC_FAR *UserBuffer);
		HRESULT STDMETHODCALLTYPE GetSoundDeviceConfig(
			/* [out,retval] */ DVSOUNDDEVICECONFIG_CDESC __RPC_FAR *SoundDeviceConfig);

		HRESULT STDMETHODCALLTYPE StartClientNotification(
			/* [in] */ I_dxj_DPVoiceEvent __RPC_FAR *event);
		
		HRESULT STDMETHODCALLTYPE UnRegisterMessageHandler();

		////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayVoiceClient);

private:
    DECL_VARIABLE(_dxj_DirectSound);
    DECL_VARIABLE(_dxj_DirectSoundCapture);
	HRESULT STDMETHODCALLTYPE	FlushBuffer(LONG dwNumMessagesLeft);


public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayVoiceClient);

	DWORD InternalAddRef();
	DWORD InternalRelease();
	
	BOOL						m_fHandleVoiceClientEvents;
	IStream						*m_pEventStream;
	BOOL						m_fInit;
	//We need to keep a count of the messages
	LONG									m_dwMsgCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplayvoiceclientobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dPlayVoiceClientObj.h"	
#include "dPlayVoiceServerObj.h"				   
#include "dvoice.h"
#include "dSound3DBuffer.h"

extern void *g_dxj_DirectPlayVoiceClient;
extern BSTR GUIDtoBSTR(LPGUID pGuid);
extern HRESULT DPLAYBSTRtoGUID(LPGUID,BSTR);
#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }
#define SAFE_RELEASE(p)      { __try { if(p) { DPF(1,"------ DXVB: SafeRelease About to call release:"); int i = 0; i = (p)->Release(); DPF1(1,"--DirectPlayVoiceClient SafeRelease (RefCount = %d)\n",i); if (!i) { (p)=NULL;}} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { DPF(1,"------ DXVB: SafeRelease Exception Handler hit(??):") (p) = NULL;} } 

DWORD WINAPI ReleaseVoiceClientThreadProc(void* lpParam);

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayVoiceClientObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF1(1,"------ DXVB: DirectPlayVoiceClient AddRef %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayVoiceClientObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF1(1,"DirectPlayVoiceClient Release %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayVoiceClientObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayVoiceClientObject::C_dxj_DirectPlayVoiceClientObject(){ 
		
	DPF(1,"------ DXVB: Constructor Creation  DirectPlayVoiceClient Object\n ");

	m__dxj_DirectPlayVoiceClient = NULL;
	m__dxj_DirectSound = NULL;
	m__dxj_DirectSoundCapture = NULL;
	m_pEventStream=NULL;
	m_fInit = FALSE;
	m_fHandleVoiceClientEvents = FALSE;
	m_dwMsgCount = 0;

}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayVoiceClientObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayVoiceClientObject::~C_dxj_DirectPlayVoiceClientObject()
{

	DPF(1,"------ DXVB: Entering ~C_dxj_DirectPlayVoiceClientObject destructor \n");
	m_fHandleVoiceClientEvents = FALSE;
	FlushBuffer(0);
	SAFE_RELEASE(m_pEventStream);

	HANDLE hThread = NULL;
	DWORD dwThread = 0;
	// We are quitting anyway, so we don't really care what is going on in this thread..
	hThread = CreateThread(NULL, 0, ReleaseVoiceClientThreadProc, this->m__dxj_DirectPlayVoiceClient, 0, &dwThread);
	DPF(1,"------ DXVB: Leaving ~C_dxj_DirectPlayVoiceClientObject destructor \n");

}

HRESULT C_dxj_DirectPlayVoiceClientObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayVoiceClient;
	
	return S_OK;
}
HRESULT C_dxj_DirectPlayVoiceClientObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayVoiceClient=(LPDIRECTPLAYVOICECLIENT)pUnk;
	return S_OK;
}

HRESULT CALLBACK VoiceMessageHandlerClient(LPVOID lpvUserContext, DWORD dwMessageType, LPVOID lpMessage)
{
	HRESULT					hr=S_OK;

	// User context for the message handler is a pointer to our class module.
	C_dxj_DirectPlayVoiceClientObject	*lpPeer = (C_dxj_DirectPlayVoiceClientObject*)lpvUserContext;
	
	DPF2(1,"-----Entering (VoiceClient) MessageHandler call... (Current msg count=%d) MSGID = %d\n", lpPeer->m_dwMsgCount, dwMessageType );
	//Increment the msg count
	InterlockedIncrement(&lpPeer->m_dwMsgCount);

	if (!lpPeer) 
	{
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (VoiceClient) MessageHandler call (No lpPeer member)...\n");
		return E_FAIL;
	}

	if (!lpPeer->m_pEventStream) 
	{
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (VoiceClient) MessageHandler call (No stream)...\n");
		return E_FAIL;
	}

	if (!lpPeer->m_fHandleVoiceClientEvents)
	{
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (VoiceClient) MessageHandler call (Not handling events)...\n");
		return S_OK;
	}

	if (!SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_HIGHEST))
	{
		DPF(1,"-----(VoiceClient) SetThreadPri Failed... \n");	
	}
	// First we need to set our stream seek back to the beginning
	// We will do this every time we enter this function since we don't know if
	// we are on the same thread or not...
	LARGE_INTEGER l;
	I_dxj_DPVoiceEvent	*lpEvent = NULL;

	l.QuadPart = 0;
	lpPeer->m_pEventStream->Seek(l, STREAM_SEEK_SET, NULL);

	DPF(1,"-----(VoiceClient) About to CoUnmarshal the interface... \n");	
	hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DPVoiceEvent, (void**)&lpEvent);
	if (!lpEvent) 
	{
		DPF(1,"-----(VoiceClient) CoUnmarshal Failed... \n");	
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return hr;
	}
	
	switch (dwMessageType)
	{
		case DVMSGID_LOCALHOSTSETUP:
		{
			DVMSG_LOCALHOSTSETUP		*msg = (DVMSG_LOCALHOSTSETUP*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive LocalHostSetup Msg... \n");	
			msg->pvContext = lpvUserContext;
			msg->pMessageHandler = VoiceMessageHandlerClient;
			break;
		}

		case DVMSGID_SESSIONLOST:
		{
			DVMSG_SESSIONLOST			*msg = (DVMSG_SESSIONLOST*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive SessionLost Msg... \n");	
			lpEvent->SessionLost(msg->hrResult);
			DPF(1,"-----(VoiceClient) Returning from VB -  SessionLost Msg... \n");	
			break;
		}
        
		case DVMSGID_HOSTMIGRATED:
		{
			DVMSG_HOSTMIGRATED			*msg = (DVMSG_HOSTMIGRATED*)lpMessage;
			I_dxj_DirectPlayVoiceServer	*lpServer = NULL;

			INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayVoiceServer, msg->pdvServerInterface, &lpServer);
			DPF(1,"-----(VoiceClient) Receive HostMigrated Msg... \n");	
			lpEvent->HostMigrated(msg->dvidNewHostID, lpServer);
			DPF(1,"-----(VoiceClient) Returning from VB -  HostMigrated Msg... \n");	
            break;
		}

        case DVMSGID_RECORDSTART:             
		{
			DVMSG_RECORDSTART *pMsg = (DVMSG_RECORDSTART*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive RecordStart Msg... \n");	
			lpEvent->RecordStart(pMsg->dwPeakLevel);
			DPF(1,"-----(VoiceClient) Returning from VB -  RecordStart Msg... \n");	
            break;
		}

        case DVMSGID_RECORDSTOP:             
		{
			DVMSG_RECORDSTOP *pMsg = (DVMSG_RECORDSTOP*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive RecordStop Msg... \n");	
			lpEvent->RecordStop(pMsg->dwPeakLevel);
			DPF(1,"-----(VoiceClient) Returning from VB -  RecordStop Msg... \n");	
            break;
		}
            
        case DVMSGID_PLAYERVOICESTART:
		{
			DVMSG_PLAYERVOICESTART *pMsg = (DVMSG_PLAYERVOICESTART*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive PlayerVoiceStart Msg... \n");	
			lpEvent->PlayerVoiceStart(pMsg->dvidSourcePlayerID);
			DPF(1,"-----(VoiceClient) Returning from VB -  PlayerVoiceStart Msg... \n");	
            break;
		}

        case DVMSGID_PLAYERVOICESTOP:
		{
			DVMSG_PLAYERVOICESTOP *pMsg = (DVMSG_PLAYERVOICESTOP*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive PlayerVoiceStop Msg... \n");	
			lpEvent->PlayerVoiceStop(pMsg->dvidSourcePlayerID);
			DPF(1,"-----(VoiceClient) Returning from VB -  PlayerVoiceStop Msg... \n");	
            break;
		}
		
		case DVMSGID_CONNECTRESULT:
		{
			DVMSG_CONNECTRESULT			*msg = (DVMSG_CONNECTRESULT*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive ConnectResult Msg... \n");	
			lpEvent->ConnectResult(msg->hrResult);
			DPF(1,"-----(VoiceClient) Returning from VB -  ConnectResult Msg... \n");	
			break;
		}

		case DVMSGID_DISCONNECTRESULT:
		{
			DVMSG_DISCONNECTRESULT *pMsg = (DVMSG_DISCONNECTRESULT*)lpMessage;
			DPF(1,"-----(VoiceClient) Receive DisconnectResult Msg... \n");	
			lpEvent->DisconnectResult(pMsg->hrResult);
			DPF(1,"-----(VoiceClient) Returning from VB -  DisconnectResult Msg... \n");	
			break;
		}
		
		case DVMSGID_INPUTLEVEL:
		{
			DVMSG_INPUTLEVEL *pMsg = (DVMSG_INPUTLEVEL*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive InputLevel Msg... \n");	
			lpEvent->InputLevel(pMsg->dwPeakLevel,pMsg->lRecordVolume);
			DPF(1,"-----(VoiceClient) Returning from VB -  InputLevel Msg... \n");	
			break;
		}

		case DVMSGID_OUTPUTLEVEL:
		{
			DVMSG_OUTPUTLEVEL *pMsg = (DVMSG_OUTPUTLEVEL*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive Output Level Msg... \n");	
			lpEvent->OutputLevel(pMsg->dwPeakLevel,pMsg->lOutputVolume);
			DPF(1,"-----(VoiceClient) Returning from VB -  Output Level Msg... \n");	
			break;
		}

		case DVMSGID_PLAYEROUTPUTLEVEL:
		{
			DVMSG_PLAYEROUTPUTLEVEL *pMsg = (DVMSG_PLAYEROUTPUTLEVEL*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive PlayerOutputLevel Msg... \n");	
			lpEvent->PlayerOutputLevel(pMsg->dvidSourcePlayerID,pMsg->dwPeakLevel);
			DPF(1,"-----(VoiceClient) Returning from VB -  PlayerOutputLevel Msg... \n");	
			break;
		}

		case DVMSGID_CREATEVOICEPLAYER:
		{
			DVMSG_CREATEVOICEPLAYER *pMsg = (DVMSG_CREATEVOICEPLAYER*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive CreateVoicePlayer Msg... \n");	
			lpEvent->CreateVoicePlayer(pMsg->dvidPlayer, pMsg->dwFlags);
			DPF(1,"-----(VoiceClient) Returning from VB -  CreateVoicePlayer Msg... \n");	
			break;
		}

		case DVMSGID_DELETEVOICEPLAYER:
		{
			DVMSG_DELETEVOICEPLAYER *pMsg = (DVMSG_DELETEVOICEPLAYER*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive DeleteVoicePlayer Msg... \n");	
			lpEvent->DeleteVoicePlayer(pMsg->dvidPlayer);
			DPF(1,"-----(VoiceClient) Returning from VB -  DeleteVoicePlayer Msg... \n");	
			break;
		}

		case DVMSGID_SETTARGETS:
			DPF(1,"-----(VoiceClient) Receive SetTargets Msg... \n");	
			break;
	}

	DPF(1,"-----Leaving (VoiceClient) MessageHandler call...\n");
	InterlockedDecrement(&lpPeer->m_dwMsgCount);
	return S_OK;
}


STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::Initialize ( 
	IUnknown *DplayObj,
	long lFlags)
{
	HRESULT					hr;
	IUnknown				*lpDplay = NULL;
	I_dxj_DirectPlayPeer	*lpPeer = NULL;
	I_dxj_DirectPlayClient	*lpClient = NULL;
	I_dxj_DirectPlayServer	*lpServer = NULL;

	__try {
		DPF(1,"-----Entering (VoiceClient) Initialize call...\n");
		// First we need to get our IUnknown pointer from whatever we pass in
		hr = DplayObj->QueryInterface(IID_I_dxj_DirectPlayPeer, (void**)&lpPeer);
		if (SUCCEEDED(hr))
		{
			lpPeer->InternalGetObject(&lpDplay);
			SAFE_RELEASE(lpPeer);
		}
		else
		{
			hr = DplayObj->QueryInterface(IID_I_dxj_DirectPlayClient, (void**)&lpClient);
			if (SUCCEEDED(hr))
			{
				lpClient->InternalGetObject(&lpDplay);
				SAFE_RELEASE(lpClient);
			}
			else
			{
				hr = DplayObj->QueryInterface(IID_I_dxj_DirectPlayServer, (void**)&lpServer);
				if (SUCCEEDED(hr))
				{
					lpServer->InternalGetObject(&lpDplay);
					SAFE_RELEASE(lpServer);
				}
			}
		}

		if (!lpDplay)
			return E_INVALIDARG;

		if (!m_fInit)
		{
			if (FAILED( hr=m__dxj_DirectPlayVoiceClient->Initialize(lpDplay, &VoiceMessageHandlerClient,
								this,0,(DWORD)lFlags)))
				return hr;
			m_fInit = TRUE;
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
										
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::Connect ( 
	DVSOUNDDEVICECONFIG_CDESC *SoundDeviceConfig,
	DVCLIENTCONFIG_CDESC *ClientConfig,
	long lFlags)
{
	HRESULT						hr;
	DVCLIENTCONFIG				dvClient;
	DVSOUNDDEVICECONFIG			dvSound;
	GUID						guidPlayback;
	GUID						guidCapture;
	LPDIRECTSOUND8				lpDSoundOut = NULL;
	LPDIRECTSOUNDCAPTURE8		lpDSoundCaptureOut = NULL;

	__try {
		DPF(1,"-----Entering (VoiceClient) Connect call...\n");
		//FlushBuffer(0);
		//Set up the sound config
		ZeroMemory ( &dvSound, sizeof(DVSOUNDDEVICECONFIG));
		dvSound.dwSize						= sizeof(DVSOUNDDEVICECONFIG);
		dvSound.dwFlags						= (DWORD)SoundDeviceConfig->lFlags;

		//Set up the default playback device (or whatever they picked)
		if (SoundDeviceConfig->guidPlaybackDevice == NULL)
			dvSound.guidPlaybackDevice			= DSDEVID_DefaultVoicePlayback;
		else
		{
			hr = DPLAYBSTRtoGUID(&guidPlayback, SoundDeviceConfig->guidPlaybackDevice);
			dvSound.guidPlaybackDevice = guidPlayback;
		}

		// Set up the default capture device (or whatever they picked)
		if (SoundDeviceConfig->guidCaptureDevice == NULL)
			dvSound.guidCaptureDevice			= DSDEVID_DefaultVoiceCapture;
		else
		{
			hr = DPLAYBSTRtoGUID(&guidCapture, SoundDeviceConfig->guidCaptureDevice);
			dvSound.guidCaptureDevice = guidCapture;
		}

		// Is there a current Playback device?
		if (m__dxj_DirectSound)
			dvSound.lpdsPlaybackDevice = m__dxj_DirectSound;
		else
			dvSound.lpdsPlaybackDevice			= NULL;
		
		// Is there a current Capture device?
		if (m__dxj_DirectSoundCapture)
			dvSound.lpdsCaptureDevice			= m__dxj_DirectSoundCapture;
		else
			dvSound.lpdsCaptureDevice			= NULL;

		dvSound.lpdsPlaybackDevice		= lpDSoundOut;
		dvSound.lpdsCaptureDevice		= lpDSoundCaptureOut;
		dvSound.hwndAppWindow				= (HWND)SoundDeviceConfig->hwndAppWindow;

		if (SoundDeviceConfig->MainSoundBuffer)
		{
			DO_GETOBJECT_NOTNULL( LPDIRECTSOUNDBUFFER8, lpDSoundBuffer, SoundDeviceConfig->MainSoundBuffer);
			dvSound.lpdsMainBuffer = lpDSoundBuffer;
			dvSound.dwMainBufferFlags = SoundDeviceConfig->lMainBufferFlags;	
			dvSound.dwMainBufferPriority = SoundDeviceConfig->lMainBufferPriority;	
		}

		//Set up the client config
		ZeroMemory ( &dvClient, sizeof(DVCLIENTCONFIG) );
		dvClient.dwSize						= sizeof(DVCLIENTCONFIG);
		dvClient.dwFlags					= ClientConfig->lFlags;
		dvClient.lRecordVolume				= ClientConfig->lRecordVolume;     
		dvClient.lPlaybackVolume			= ClientConfig->lPlaybackVolume;   
		dvClient.dwThreshold				= ClientConfig->lThreshold;
		dvClient.dwBufferQuality			= ClientConfig->lBufferQuality;
		dvClient.dwBufferAggressiveness		= ClientConfig->lBufferAggressiveness;
		dvClient.dwNotifyPeriod				= ClientConfig->lNotifyPeriod;

		if (FAILED ( hr = m__dxj_DirectPlayVoiceClient->Connect(&dvSound, &dvClient, (DWORD)lFlags)))
			return hr;
		
		//Now set the devices that were used.
		m__dxj_DirectSound = lpDSoundOut;
		m__dxj_DirectSoundCapture = lpDSoundCaptureOut;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::Disconnect ( 
	long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (VoiceClient) Disconnect call...\n");

		FlushBuffer(0);
		if (FAILED (hr = m__dxj_DirectPlayVoiceClient->Disconnect((DWORD)lFlags)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::GetSessionDesc ( 
	DVSESSIONDESC_CDESC *SessionDesc)
{
	HRESULT				hr;
	DVSESSIONDESC		dvSession;
	
	__try {
		DPF(1,"-----Entering (VoiceClient) GetSessionDesc call...\n");
		//FlushBuffer(0);
		dvSession.dwSize = sizeof(DVSESSIONDESC);
		//Now get the buffer
		if ( FAILED(hr = m__dxj_DirectPlayVoiceClient->GetSessionDesc(&dvSession)))
			return hr;
	
		//Cast into return buffer
		SessionDesc->lFlags = (long)dvSession.dwFlags;
		SessionDesc->lSessionType = (long)dvSession.dwSessionType;
		SessionDesc->guidCT = GUIDtoBSTR(&dvSession.guidCT);
		SessionDesc->lBufferQuality = (long)dvSession.dwBufferQuality;
		SessionDesc->lBufferAggressiveness = (long)dvSession.dwBufferAggressiveness;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::GetClientConfig ( 
	DVCLIENTCONFIG_CDESC *ClientConfig)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (VoiceClient) GetClientConfig call...\n");
		//FlushBuffer(0);
		ClientConfig->lSize = sizeof(DVCLIENTCONFIG);
		if (FAILED ( hr = m__dxj_DirectPlayVoiceClient->GetClientConfig((DVCLIENTCONFIG*)ClientConfig)))
			return hr;
	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::SetClientConfig ( 
	DVCLIENTCONFIG_CDESC *ClientConfig)
{
	HRESULT hr;
	DVCLIENTCONFIG dvClient;

	__try {
		DPF(1,"-----Entering (VoiceClient) SetClientConfig call...\n");
		//FlushBuffer(0);
		ZeroMemory ( &dvClient, sizeof(DVCLIENTCONFIG) );
		
		// Fill our copy of DVCLIENTCONFIG
		dvClient.dwSize							= sizeof(DVCLIENTCONFIG);
		dvClient.dwFlags						= ClientConfig->lFlags;
		dvClient.lRecordVolume					= ClientConfig->lRecordVolume;     
		dvClient.lPlaybackVolume				= ClientConfig->lPlaybackVolume;   
		dvClient.dwThreshold					= ClientConfig->lThreshold;
		dvClient.dwBufferQuality				= ClientConfig->lBufferQuality;
		dvClient.dwBufferAggressiveness			= ClientConfig->lBufferAggressiveness;
		dvClient.dwNotifyPeriod					= ClientConfig->lNotifyPeriod;
		
		if (FAILED ( hr = m__dxj_DirectPlayVoiceClient->SetClientConfig(&dvClient)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::GetCaps ( 
	DVCAPS_CDESC *Caps)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (VoiceClient) GetCaps call...\n");
		//FlushBuffer(0);
		Caps->lSize = sizeof(DVCAPS);
		if (FAILED ( hr = m__dxj_DirectPlayVoiceClient->GetCaps((DVCAPS*)Caps)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::GetCompressionTypeCount ( 
	long *retval)
{
	HRESULT			hr;
	DWORD			dwSize = 0;
	DWORD			dwNumElements = 0;

	__try {
		DPF(1,"-----Entering (VoiceClient) GetCompressionTypeCount call...\n");
		//FlushBuffer(0);
		hr = m__dxj_DirectPlayVoiceClient->GetCompressionTypes(NULL, &dwSize, &dwNumElements ,0);
		
		if ( hr != DVERR_BUFFERTOOSMALL && FAILED(hr) ) //We didn't expect this error
			return hr;

		*retval = (long)dwNumElements;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::GetCompressionType ( 
	long lIndex,
	DVCOMPRESSIONINFO_CDESC *Data,
	long lFlags)
{
	HRESULT					hr;
	LPBYTE					pBuffer = NULL;	
	DWORD					dwSize = 0;
	DWORD					dwNumElements = 0;
	LPDVCOMPRESSIONINFO		pdvCompressionInfo;
	LPGUID					pGuid;

	__try {
		DPF(1,"-----Entering (VoiceClient) GetCompressionTypes call...\n");
		//FlushBuffer(0);
		hr = m__dxj_DirectPlayVoiceClient->GetCompressionTypes(pBuffer, &dwSize, &dwNumElements ,0);
		
		if ( hr != DVERR_BUFFERTOOSMALL && FAILED(hr) ) //We didn't expect this error
			return hr;

		pBuffer = new BYTE[dwSize];
		if (!pBuffer)
			return E_OUTOFMEMORY;
		
		if ( FAILED ( hr = m__dxj_DirectPlayVoiceClient->GetCompressionTypes(pBuffer, &dwSize, &dwNumElements, (DWORD)lFlags)))
			return hr;

		if (lIndex > (long)dwNumElements)
			return DVERR_INVALIDPARAM;

		pdvCompressionInfo = (LPDVCOMPRESSIONINFO) pBuffer;

		pGuid = new GUID;
		if (!pGuid)
			return E_OUTOFMEMORY;

		// Ok, fill up our struct
		ZeroMemory(Data, sizeof(DVCOMPRESSIONINFO_CDESC));
		Data->lSize				= sizeof(DVCOMPRESSIONINFO_CDESC);
		Data->lFlags				= pdvCompressionInfo[lIndex-1].dwFlags;
		Data->lMaxBitsPerSecond	= pdvCompressionInfo[lIndex-1].dwMaxBitsPerSecond;
		Data->strDescription		= SysAllocString(pdvCompressionInfo[lIndex-1].lpszDescription);
		Data->strName				= SysAllocString(pdvCompressionInfo[lIndex-1].lpszName);

		(*pGuid) = pdvCompressionInfo[lIndex-1].guidType;

		Data->guidType				= GUIDtoBSTR(pGuid);
		SAFE_DELETE(pGuid);
		SAFE_DELETE(pBuffer);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::SetTransmitTargets ( 
	SAFEARRAY **playerIDs,
	long lFlags)
{
	HRESULT hr;
	DWORD	dwNumTarget = ((SAFEARRAY*)*playerIDs)->rgsabound[0].cElements;
	
	__try {
		DPF(1,"-----Entering (VoiceClient) SetTransmitTargets call...\n");
		//FlushBuffer(0);
		if (FAILED( hr = m__dxj_DirectPlayVoiceClient->SetTransmitTargets((DVID*)(((SAFEARRAY*)*playerIDs)->pvData),
						dwNumTarget, (DWORD) lFlags )))
			return hr;
	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::GetTransmitTargets ( 
	long lFlags,
	SAFEARRAY **ret)
{
	HRESULT hr;
	DVID	*dwPlayers = NULL;
	DWORD	dwNumPlayers=0;
	SAFEARRAY					*lpData = NULL;
	SAFEARRAYBOUND				rgsabound[1];
	BYTE						*lpByte = NULL;

	__try {
		DPF(1,"-----Entering (VoiceClient) GetTransmitTargets call...\n");
		//FlushBuffer(0);
		
		hr =m__dxj_DirectPlayVoiceClient->GetTransmitTargets(NULL, &dwNumPlayers, (DWORD) lFlags );

		if (FAILED(hr) && ( hr != DVERR_BUFFERTOOSMALL))
			return hr;

		dwPlayers = (DVID*)new BYTE[sizeof(DVID) * dwNumPlayers];
		if (!dwPlayers)
			return E_OUTOFMEMORY;

		if (FAILED( hr = m__dxj_DirectPlayVoiceClient->GetTransmitTargets(dwPlayers, &dwNumPlayers, (DWORD) lFlags )))
			return hr;

		if (dwNumPlayers)
		{
			// Now let's create a safearray to pass back
			rgsabound[0].lLbound = 0;
			rgsabound[0].cElements = dwNumPlayers;
			
			lpData = SafeArrayCreate(VT_UI4, 1, rgsabound);
			memcpy(lpData->pvData,dwPlayers,sizeof(DVID) * dwNumPlayers);
		}
		*ret = lpData;
		SAFE_DELETE(dwPlayers);
	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::SetCurrentSoundDevices (
	I_dxj_DirectSound *DirectSoundObj, 
	I_dxj_DirectSoundCapture *DirectCaptureObj)
{
	__try {
		DPF(1,"-----Entering (VoiceClient) SetCurrentSoundDevices call...\n");
		//FlushBuffer(0);
		DO_GETOBJECT_NOTNULL( LPDIRECTSOUND8, lpSound, DirectSoundObj);
		DO_GETOBJECT_NOTNULL( LPDIRECTSOUNDCAPTURE8, lpSoundCapture, DirectCaptureObj);

		m__dxj_DirectSound = lpSound;
		m__dxj_DirectSoundCapture = lpSoundCapture;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::GetSoundDevices (
	I_dxj_DirectSound *DirectSoundObj, 
	I_dxj_DirectSoundCapture *DirectCaptureObj)
{
	__try {
		DPF(1,"-----Entering (VoiceClient) GetSoundDevices call...\n");
		//FlushBuffer(0);
		if (m__dxj_DirectSound)
			INTERNAL_CREATE_NOADDREF(_dxj_DirectSound,m__dxj_DirectSound,&DirectSoundObj);

		if (m__dxj_DirectSoundCapture)
			INTERNAL_CREATE_NOADDREF(_dxj_DirectSoundCapture ,m__dxj_DirectSoundCapture,&DirectCaptureObj);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::Create3DSoundBuffer (
	long playerID,
	I_dxj_DirectSoundBuffer *Buffer,
	long lPriority,
	long lFlags, 
	I_dxj_DirectSound3dBuffer **UserBuffer)
{
	HRESULT						hr;
	IDirectSound3DBuffer		*lpDSound3DBuffer = NULL;

	__try {
		DPF(1,"-----Entering (VoiceClient) Create3DSoundBuffer call...\n");
		//FlushBuffer(0);

		if (Buffer)
		{
			DO_GETOBJECT_NOTNULL( LPDIRECTSOUNDBUFFER8, lpDSoundBuffer, Buffer);
			//First let's go ahead and get the real DirectSoundBuffer
			if ( FAILED ( hr = m__dxj_DirectPlayVoiceClient->Create3DSoundBuffer(
						(DVID)playerID, lpDSoundBuffer, (DWORD)lPriority, (DWORD) lFlags, &lpDSound3DBuffer)))
				return hr;
		}
		else
		{
			//First let's go ahead and get the real DirectSoundBuffer
			if ( FAILED ( hr = m__dxj_DirectPlayVoiceClient->Create3DSoundBuffer(
						(DVID)playerID, NULL, 0, 0, &lpDSound3DBuffer)))
				return hr;
		}

		//We need to do an AddRef() on this buffer so when we release it, it will go away
		lpDSound3DBuffer->AddRef();
		// Now let's get a I_dxj_DirectSound3dBuffer to pass back..
		INTERNAL_CREATE_ADDRESS(_dxj_DirectSound3dBuffer,lpDSound3DBuffer,UserBuffer);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
				
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::Delete3DSoundBuffer (
	long playerID, 
	I_dxj_DirectSound3dBuffer *UserBuffer)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (VoiceClient) Delete3DSoundBuffer call...\n");
		//FlushBuffer(0);
		DO_GETOBJECT_NOTNULL( LPDIRECTSOUND3DBUFFER, lpBuffer, UserBuffer);
		DPF(1,"-----Calling Delete3DSoundBuffer on core obj...\n");
		if (FAILED( hr=m__dxj_DirectPlayVoiceClient->Delete3DSoundBuffer((DVID)playerID, &lpBuffer)))
			return hr;

		/*int i = UserBuffer->AddRef();
		DPF1(1,"-----New Ref: %d...\n",i);*/
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		DPF(1,"-----Leaving (VoiceClient) Delete3DSoundBuffer call (Exception Handler)...\n");
		return E_FAIL;
	}
	
	DPF(1,"-----Leaving (VoiceClient) Delete3DSoundBuffer call (No error)...\n");
	return S_OK;
}
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::GetSoundDeviceConfig(DVSOUNDDEVICECONFIG_CDESC *SoundDeviceConfig)
{
	HRESULT hr;
	DWORD dwSize = 0;
	DVSOUNDDEVICECONFIG *pdvConfig = NULL;

	DPF(1,"-----Entering (VoiceClient) GetSoundDeviceConfig call...\n");
	__try {
		//FlushBuffer(0);

		hr = m__dxj_DirectPlayVoiceClient->GetSoundDeviceConfig(NULL, &dwSize);
		if ( hr != DVERR_BUFFERTOOSMALL && FAILED(hr) ) //We didn't expect this error
			return hr;
		pdvConfig = (DVSOUNDDEVICECONFIG*) new BYTE[dwSize];
		if (!pdvConfig)
			return E_OUTOFMEMORY;

		pdvConfig->dwSize = sizeof(DVSOUNDDEVICECONFIG);
		hr = m__dxj_DirectPlayVoiceClient->GetSoundDeviceConfig(pdvConfig, &dwSize);
		if ( FAILED(hr) ) //We didn't expect this error
			return hr;
		
		SoundDeviceConfig->lSize = (long)pdvConfig->dwSize;
		SoundDeviceConfig->lFlags = (long)pdvConfig->dwFlags;
#ifdef _WIN64
		SoundDeviceConfig->hwndAppWindow = pdvConfig->hwndAppWindow;
#else
		SoundDeviceConfig->hwndAppWindow = (long)pdvConfig->hwndAppWindow;
#endif
		SoundDeviceConfig->guidPlaybackDevice = GUIDtoBSTR(&pdvConfig->guidPlaybackDevice);
		SoundDeviceConfig->guidCaptureDevice = GUIDtoBSTR(&pdvConfig->guidCaptureDevice);

		SAFE_DELETE(pdvConfig);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::StartClientNotification(I_dxj_DPVoiceEvent *event)
{
    HRESULT	  hr=S_OK;
    LPSTREAM  pStm=NULL;
    IUnknown *pUnk=NULL;

	DPF(1,"-----Entering (VoiceClient) StartClientNotification call...\n");
	if (!event) return E_INVALIDARG;
    
	SAFE_RELEASE(m_pEventStream);

	// Create a global stream.  The stream needs to be global so we can 
	// marshal once, and unmarshal as many times as necessary
	hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);
    if FAILED(hr) return hr;

	// Now we can marshal our IUnknown interface.  We use MSHLFLAGS_TABLEWEAK 
	// so we can unmarshal any number of times
	hr = CoMarshalInterface(pStm, IID_I_dxj_DPVoiceEvent, event, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLEWEAK);
    if FAILED(hr) return hr;

	// Now we need to set the seek location of the stream to the beginning
	LARGE_INTEGER l;
	l.QuadPart = 0;
	pStm->Seek(l, STREAM_SEEK_SET, NULL);
    
	m_pEventStream=pStm;

	m_fHandleVoiceClientEvents = TRUE;

	return hr;
}

HRESULT C_dxj_DirectPlayVoiceClientObject::UnRegisterMessageHandler()
{
	DPF(1,"-----Entering (VoiceClient) UnregisterMessageHandler call...\n");
	m_fHandleVoiceClientEvents = FALSE;
	FlushBuffer(0);
	return S_OK;
}

HRESULT C_dxj_DirectPlayVoiceClientObject::FlushBuffer(LONG dwNumMessagesLeft)
{
	
	DWORD dwTime = GetTickCount();

	DPF(1,"-----Entering (VoiceClient) FlushBuffer call...\n");
	//Clear out the messages currently waiting
	//Clear out the messages currently waiting
	BOOL bGotMsg = FALSE; 
	BOOL bWait = FALSE; 
	int i=0; 
	MSG msg; 
	HRESULT hr = S_OK; 
	msg.message = WM_NULL; 
	while ((WM_QUIT != msg.message) && (m_dwMsgCount > dwNumMessagesLeft)) 
	{ 
		bGotMsg = PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE); 
		i++; 
		if (GetTickCount() - dwTime > 5000)
		{
			// Don't let FlushBuffer wait more than 5 seconds
			DPF1(1,"-----Leaving (VoiceClient) FlushBuffer call (All messages *not* flushed - %d remained)...\n", m_dwMsgCount);
			return S_OK;
		}
		if (bGotMsg) 
		{ 
			TranslateMessage( &msg ); 
			DispatchMessage( &msg ); 
		} 
		bGotMsg = FALSE; 
		Sleep(0);
	} 
	DPF(1,"-----Leaving (VoiceClient) FlushBuffer call (All messages flushed)...\n");
	return S_OK;
}
DWORD WINAPI ReleaseVoiceClientThreadProc(void* lpParam)
{
	// User context for the message handler is a pointer to our class module.
	LPDIRECTPLAYVOICECLIENT lpPeer = (LPDIRECTPLAYVOICECLIENT)lpParam;

	SAFE_RELEASE(lpPeer);
	CloseHandle(GetCurrentThread());
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplayvoiceserverobj.h ===
#include "resource.h"       // main symbols
#define typedef__dxj_DirectPlayVoiceServer LPDIRECTPLAYVOICESERVER

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayVoiceServerObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayVoiceServer, &IID_I_dxj_DirectPlayVoiceServer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayVoiceServer,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayVoiceServerObject() ;
	virtual ~C_dxj_DirectPlayVoiceServerObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayVoiceServerObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayVoiceServer)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayVoiceServerObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayVoiceServer
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

        HRESULT STDMETHODCALLTYPE Initialize ( 
            /* [in] */ IUnknown __RPC_FAR *DplayObj,
           /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE StartSession ( 
            /* [in] */ DVSESSIONDESC_CDESC __RPC_FAR *SessionDesc,
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE StopSession ( 
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE GetSessionDesc ( 
            /* [out][in] */ DVSESSIONDESC_CDESC __RPC_FAR *SessionDesc);
        
        HRESULT STDMETHODCALLTYPE SetSessionDesc ( 
            /* [in] */ DVSESSIONDESC_CDESC __RPC_FAR *ClientConfig);
        
        HRESULT STDMETHODCALLTYPE GetCaps ( 
            /* [out][in] */ DVCAPS_CDESC __RPC_FAR *Caps);
        
        HRESULT STDMETHODCALLTYPE GetCompressionTypeCount ( 
            /* [retval][out] */ long __RPC_FAR *v1);
        
        HRESULT STDMETHODCALLTYPE GetCompressionType ( 
            /* [in] */ long lIndex,
            /* [out][in] */ DVCOMPRESSIONINFO_CDESC __RPC_FAR *Data,
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE SetTransmitTargets ( 
            /* [in] */ long playerSourceID,
            /* [in] */ SAFEARRAY **playerTargetIDs,
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE GetTransmitTargets ( 
            /* [in] */ long playerSourceID,
            /* [in] */ long lFlags,
            /* [retval][out] */ SAFEARRAY **ret);

		HRESULT STDMETHODCALLTYPE StartServerNotification(
			/* [in] */ I_dxj_DPVoiceEvent __RPC_FAR *event);

		HRESULT STDMETHODCALLTYPE UnRegisterMessageHandler();

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayVoiceServer);

private:
	HRESULT STDMETHODCALLTYPE	FlushBuffer(LONG dwNumMessagesLeft);

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayVoiceServer);

	DWORD InternalAddRef();
	DWORD InternalRelease();

	BOOL						m_fHandleVoiceClientEvents;
	IStream						*m_pEventStream;
	BOOL						m_fInit;
	//We need to keep a count of the messages
	LONG									m_dwMsgCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplayvoicesetupobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectPlayVoiceSetup LPDIRECTPLAYVOICETEST

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayVoiceSetupObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayVoiceSetup, &IID_I_dxj_DirectPlayVoiceSetup, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayVoiceSetup,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayVoiceSetupObject() ;
	virtual ~C_dxj_DirectPlayVoiceSetupObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayVoiceSetupObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayVoiceSetup)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayVoiceSetupObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayVoiceSetup
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

        HRESULT STDMETHODCALLTYPE CheckAudioSetup ( 
            /* [in] */ BSTR guidPlaybackDevice,
            /* [in] */ BSTR guidCaptureDevice,
#ifdef _WIN64
			/* [in] */ HWND hwndOwner,
#else
			/* [in] */ long hwndOwner,
#endif
            /* [in] */ long lFlags,
            /* [retval][out] */ long __RPC_FAR *v1);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayVoiceSetup);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayVoiceSetup);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsenumobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsenumobj.cpp
//
//--------------------------------------------------------------------------

#define OLDDSENUM 1

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dxglob7obj.h"
#include "DSEnumObj.h"
 

extern BSTR GUIDtoBSTR(LPGUID pGuid);

extern "C" BOOL PASCAL  objDirectSoundEnumCallback( 

#ifdef OLDDSENUM
	LPGUID lpGuid,
#else
	LPCGUID lpGuid,
#endif

  LPCSTR lpDriverDescription,  
  LPCSTR lpDriverName,         
  LPVOID lpArg            
)
{
        GUID guid;
        ZeroMemory(&guid,sizeof(GUID));
        if (lpGuid){
           memcpy(&guid,lpGuid,sizeof(GUID));
        }

	
	DPF(1,"Entered objDirectDrawEnumCallback \r\n");

	
	C_dxj_DSEnumObject *pObj=(C_dxj_DSEnumObject*)lpArg;
	if (pObj==NULL) return TRUE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList)
		{
			void* tmp = realloc(pObj->m_pList,sizeof(DXDRIVERINFO_CDESC)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DXDRIVERINFO_CDESC*)tmp;
			else
				return FALSE;
		}
		else
			pObj->m_pList=(DXDRIVERINFO_CDESC*)malloc(sizeof(DXDRIVERINFO_CDESC)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DXDRIVERINFO_CDESC));
        pObj->m_pList[pObj->m_nCount].strGuid=GUIDtoBSTR((GUID*)&guid);
//      pObj->m_pList[pObj->m_nCount].strGuid=GUIDtoBSTR((GUID*)lpGuid); 
	if (lpDriverDescription!=NULL) {
		pObj->m_pList[pObj->m_nCount].strDescription=T2BSTR(lpDriverDescription);
	}
	if (lpDriverName!=NULL){
		pObj->m_pList[pObj->m_nCount].strName=T2BSTR(lpDriverName);
	}

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DSEnumObject::C_dxj_DSEnumObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DSEnumObject::~C_dxj_DSEnumObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].strGuid) SysFreeString(m_pList[i].strGuid);
			if (m_pList[i].strDescription) SysFreeString(m_pList[i].strDescription);
			if (m_pList[i].strName) SysFreeString(m_pList[i].strName);
		}
		free(m_pList);
	}

}


HRESULT C_dxj_DSEnumObject::create(DSOUNDENUMERATE pcbFunc,DSOUNDCAPTUREENUMERATE pcbFunc2,I_dxj_DSEnum **ppRet)
{
	HRESULT hr=S_OK;	
	C_dxj_DSEnumObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DSEnumObject::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DSEnumObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	if (pcbFunc) 
	{
		hr=pcbFunc(objDirectSoundEnumCallback,pNew);	
	}
	else if (pcbFunc2)
	{
		hr=pcbFunc2(objDirectSoundEnumCallback,pNew);
	}
	else {
		hr = E_INVALIDARG;
	}

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		//let destructor do the clean up
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DSEnum,(void**)ppRet);
	return hr;
}




HRESULT C_dxj_DSEnumObject::getName( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;	
	*ret=SysAllocString(m_pList[index-1].strName);		

	return S_OK;
}

HRESULT C_dxj_DSEnumObject::getDescription( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;	

	*ret=SysAllocString(m_pList[index-1].strDescription);

	return S_OK;
}

HRESULT C_dxj_DSEnumObject::getGuid( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;	

	*ret=SysAllocString(m_pList[index-1].strGuid);
	return S_OK;
}

HRESULT C_dxj_DSEnumObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplayvoicesetupobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dPlayVoiceSetupObj.h"					   

extern void *g_dxj_DirectPlayVoiceSetup;
extern BSTR GUIDtoBSTR(LPGUID pGuid);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayVoiceSetupObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectPlayVoiceTest [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayVoiceSetupObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectPlayVoiceTest [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayVoiceSetupObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayVoiceSetupObject::C_dxj_DirectPlayVoiceSetupObject(){ 
		
	DPF1(1,"Constructor Creation  DirectPlayVoiceTest Object[%d] \n ",g_creationcount);

	m__dxj_DirectPlayVoiceSetup = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectPlayVoiceSetup;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectPlayVoiceSetup = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayVoiceSetupObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayVoiceSetupObject::~C_dxj_DirectPlayVoiceSetupObject()
{

	DPF(1,"Entering ~C_dxj_DirectPlayVoiceSetupObject destructor \n");

     C_dxj_DirectPlayVoiceSetupObject *prev=NULL; 
	for(C_dxj_DirectPlayVoiceSetupObject *ptr=(C_dxj_DirectPlayVoiceSetupObject *)g_dxj_DirectPlayVoiceSetup ; ptr; ptr=(C_dxj_DirectPlayVoiceSetupObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectPlayVoiceSetup = (void*)ptr->nextobj; 
			
			DPF(1,"DirectPlayVoiceTestObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectPlayVoiceSetup){
		int count = IUNK(m__dxj_DirectPlayVoiceSetup)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectPlayVoiceTest Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectPlayVoiceSetup = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectPlayVoiceSetupObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayVoiceSetup;
	
	return S_OK;
}
HRESULT C_dxj_DirectPlayVoiceSetupObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayVoiceSetup=(LPDIRECTPLAYVOICETEST)pUnk;
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayVoiceSetupObject::CheckAudioSetup ( 
	BSTR guidPlaybackDevice,
	BSTR guidCaptureDevice,
#ifdef _WIN64
	HWND hwndOwner,
#else
	long hwndOwner,
#endif
	long lFlags,
	long *retval)
{
	HRESULT hr;
	LPGUID pPlayback = NULL;
	LPGUID pCapture = NULL;

	__try {
		hr = BSTRtoGUID(pPlayback, guidPlaybackDevice);
		hr = BSTRtoGUID(pCapture, guidCaptureDevice);

		if ( FAILED (hr = m__dxj_DirectPlayVoiceSetup->CheckAudioSetup(pPlayback, pCapture, (HWND) hwndOwner, (DWORD) lFlags)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsenumobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsenumobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DSEnumObject : 
	public I_dxj_DSEnum,
	public CComObjectRoot
{
public:
	C_dxj_DSEnumObject() ;
	virtual ~C_dxj_DSEnumObject() ;

BEGIN_COM_MAP(C_dxj_DSEnumObject)
	COM_INTERFACE_ENTRY(I_dxj_DSEnum)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DSEnumObject)

public:
        HRESULT STDMETHODCALLTYPE getGuid( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid) ;
        
        HRESULT STDMETHODCALLTYPE getDescription( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid) ;
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid) ;
        
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count) ;
				
		static HRESULT create(DSOUNDENUMERATE pcbFunc,DSOUNDCAPTUREENUMERATE pcbFunc2,I_dxj_DSEnum **ppRet);		

public:
		DXDRIVERINFO_CDESC 	*m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsound3dbuffer.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsound3dbuffer.cpp
//
//--------------------------------------------------------------------------

// dSound3DBuffer.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file


#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"
#include "dms.h"
#include "dSoundObj.h"
#include "dSoundBufferObj.h"
#include "dSound3DBuffer.h"
#include "dSound3DListener.h"
#define SAFE_RELEASE(p)      { __try { if(p) { DPF(1,"------ DXVB: SafeRelease About to call release:"); int i = 0; i = (p)->Release(); DPF1(1,"--DirectPlaySound3DBuffer SafeRelease (RefCount = %d)\n",i); if (!i) { (p)=NULL;}} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { DPF(1,"------ DXVB: SafeRelease Exception Handler hit(??):") (p) = NULL;} } 

C_dxj_DirectSound3dBufferObject::C_dxj_DirectSound3dBufferObject(){ 
		
	DPF(1,"------ DXVB: Constructor Creation  DirectSound3DBuffer Object\n ");
	m__dxj_DirectSound3dBuffer = NULL;
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayVoiceClientObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSound3dBufferObject::~C_dxj_DirectSound3dBufferObject()
{

	DPF(1,"------ DXVB: Entering ~C_dxj_DirectSound3dBufferObject destructor \n");
	SAFE_RELEASE(m__dxj_DirectSound3dBuffer);
	DPF(1,"------ DXVB: Leaving ~C_dxj_DirectPlayVoiceClientObject destructor \n");

}

GETSET_OBJECT(_dxj_DirectSound3dBuffer);

	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, getConeAngles, GetConeAngles, long*,(DWORD*), long*,(DWORD*));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dBuffer, getConeOrientation, GetConeOrientation, D3DVECTOR_CDESC*, (_D3DVECTOR*));
	PASS_THROUGH1_R(_dxj_DirectSound3dBuffer, getConeOutsideVolume, GetConeOutsideVolume, long*);
	PASS_THROUGH1_R(_dxj_DirectSound3dBuffer, getMaxDistance, GetMaxDistance, float*);
	PASS_THROUGH1_R(_dxj_DirectSound3dBuffer, getMinDistance, GetMinDistance, float*);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dBuffer, getMode, GetMode,  long *,(DWORD*));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dBuffer, getPosition, GetPosition, D3DVECTOR_CDESC*, (_D3DVECTOR*));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dBuffer, getVelocity, GetVelocity, D3DVECTOR_CDESC*, (_D3DVECTOR*));
	PASS_THROUGH_CAST_3_R(_dxj_DirectSound3dBuffer, setConeAngles, SetConeAngles, long,(DWORD) ,long,(DWORD) ,long,(DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dBuffer, setConeOrientation,  SetConeOrientation, float,(float), float,(float), float,(float), long,(DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, setConeOutsideVolume, SetConeOutsideVolume, long, (long),long,(DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, setMaxDistance, SetMaxDistance, float, (float),long,(DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, setMinDistance, SetMinDistance, float,(float),long,(DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, setMode, SetMode, long,(unsigned long) , long,(DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dBuffer, setPosition, SetPosition, float,(float), float,(float), float,(float), long,(DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dBuffer, setVelocity, SetVelocity, float,(float), float,(float), float,(float), long,(DWORD));

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dBufferObject::getAllParameters( DS3DBUFFER_CDESC* lobj )
{
	if(!lobj)
		return E_POINTER;

	lobj->lSize = sizeof(DS3DBUFFER);
	return m__dxj_DirectSound3dBuffer->GetAllParameters( (LPDS3DBUFFER)lobj );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dBufferObject::setAllParameters( DS3DBUFFER_CDESC *lobj, long apply)
{
	if(!lobj)
		return E_POINTER;

	lobj->lSize = sizeof(DS3DBUFFER);
	return m__dxj_DirectSound3dBuffer->SetAllParameters( (LPDS3DBUFFER)lobj, (DWORD)apply );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dBufferObject::getDirectSoundBuffer( I_dxj_DirectSoundBuffer **retv)
{
	HRESULT hr;
	IDirectSoundBuffer *pdsb;
	hr=m__dxj_DirectSound3dBuffer->QueryInterface(IID_IDirectSoundBuffer,(void**)&pdsb);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_DirectSoundBuffer,pdsb,retv);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dplayvoiceserverobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dPlayVoiceServerObj.h"					   
#include "dvoice.h"

extern BSTR GUIDtoBSTR(LPGUID pGuid);
extern HRESULT DPLAYBSTRtoGUID(LPGUID,BSTR);
extern void *g_dxj_DirectPlayVoiceServer;

#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }
#define SAFE_RELEASE(p)      { __try { if(p) { int i = 0; i = (p)->Release(); DPF1(1,"--DirectPlayVoiceServer SafeRelease (RefCount = %d)\n",i); if (!i) { (p)=NULL;}} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { (p) = NULL;} } 


DWORD WINAPI ReleaseVoiceThreadProc(void* lpParam);
///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayVoiceServerObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF1(1,"------ DXVB: DirectPlayVoiceServer AddRef %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayVoiceServerObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF1(1,"DirectPlayVoiceServer Release %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayVoiceServerObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayVoiceServerObject::C_dxj_DirectPlayVoiceServerObject(){ 
		
	DPF(1,"------ DXVB: Constructor Creation  DirectPlayVoiceServer Object \n ");

	m__dxj_DirectPlayVoiceServer = NULL;
	m_pEventStream=NULL;
	m_fInit = FALSE;
	m_fHandleVoiceClientEvents = FALSE;
	m_dwMsgCount = 0;
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayVoiceServerObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayVoiceServerObject::~C_dxj_DirectPlayVoiceServerObject()
{

	DPF(1,"------ DXVB: Entering ~C_dxj_DirectPlayVoiceServerObject destructor \n");

	m_fHandleVoiceClientEvents = FALSE;
	FlushBuffer(0);
	SAFE_RELEASE(m_pEventStream);

	HANDLE hThread = NULL;
	DWORD dwThread = 0;
	// We are quitting anyway, so we don't really care what is going on in this thread..
	hThread = CreateThread(NULL, 0, ReleaseVoiceThreadProc, this->m__dxj_DirectPlayVoiceServer, 0, &dwThread);

}

HRESULT C_dxj_DirectPlayVoiceServerObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayVoiceServer;
	
	return S_OK;
}
HRESULT C_dxj_DirectPlayVoiceServerObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayVoiceServer=(LPDIRECTPLAYVOICESERVER)pUnk;
	return S_OK;
}

HRESULT CALLBACK VoiceMessageHandlerServer(LPVOID lpvUserContext, DWORD dwMessageType,
		LPVOID lpMessage)
{
	HRESULT					hr=S_OK;

	// User context for the message handler is a pointer to our class module.
	C_dxj_DirectPlayVoiceServerObject	*lpPeer = (C_dxj_DirectPlayVoiceServerObject*)lpvUserContext;
	
	DPF2(1,"-----Entering (VoiceServer) MessageHandler call... (Current msg count=%d) MSGID = %d\n", lpPeer->m_dwMsgCount, dwMessageType );
	//Increment the msg count
	InterlockedIncrement(&lpPeer->m_dwMsgCount);

	if (!lpPeer) 
	{
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (VoiceServer) MessageHandler call (No lpPeer member)...\n");
		return E_FAIL;
	}

	if (!lpPeer->m_pEventStream) 
	{
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (VoiceServer) MessageHandler call (No stream)...\n");
		return E_FAIL;
	}

	if (!lpPeer->m_fHandleVoiceClientEvents)
	{
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (VoiceServer) MessageHandler call (Not handling events)...\n");
		return S_OK;
	}

	// First we need to set our stream seek back to the beginning
	// We will do this every time we enter this function since we don't know if
	// we are on the same thread or not...
	LARGE_INTEGER l;
	I_dxj_DPVoiceEvent	*lpEvent = NULL;

	l.QuadPart = 0;
	lpPeer->m_pEventStream->Seek(l, STREAM_SEEK_SET, NULL);

	hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DPVoiceEvent, (void**)&lpEvent);
	if (!lpEvent) 
	{
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return hr;
	}
	
	switch (dwMessageType)
	{
		case DVMSGID_LOCALHOSTSETUP:
		{
			DVMSG_LOCALHOSTSETUP		*msg = (DVMSG_LOCALHOSTSETUP*)lpMessage;

			msg->pvContext = lpvUserContext;
			msg->pMessageHandler = VoiceMessageHandlerServer;
			break;
		}

		case DVMSGID_SESSIONLOST:
		{
			DVMSG_SESSIONLOST			*msg = (DVMSG_SESSIONLOST*)lpMessage;

			lpEvent->SessionLost(msg->hrResult);
			break;
		}
        
		case DVMSGID_HOSTMIGRATED:
		{
			DVMSG_HOSTMIGRATED			*msg = (DVMSG_HOSTMIGRATED*)lpMessage;
			I_dxj_DirectPlayVoiceServer	*lpServer = NULL;

			INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayVoiceServer, msg->pdvServerInterface, &lpServer);
			lpEvent->HostMigrated(msg->dvidNewHostID, lpServer);
            break;
		}

        case DVMSGID_RECORDSTART:             
		{
			DVMSG_RECORDSTART *pMsg = (DVMSG_RECORDSTART*)lpMessage;

			lpEvent->RecordStart(pMsg->dwPeakLevel);
            break;
		}

        case DVMSGID_RECORDSTOP:             
		{
			DVMSG_RECORDSTOP *pMsg = (DVMSG_RECORDSTOP*)lpMessage;

			lpEvent->RecordStop(pMsg->dwPeakLevel);
            break;
		}
            
        case DVMSGID_PLAYERVOICESTART:
		{
			DVMSG_PLAYERVOICESTART *pMsg = (DVMSG_PLAYERVOICESTART*)lpMessage;

			lpEvent->PlayerVoiceStart(pMsg->dvidSourcePlayerID);
            break;
		}

        case DVMSGID_PLAYERVOICESTOP:
		{
			DVMSG_PLAYERVOICESTOP *pMsg = (DVMSG_PLAYERVOICESTOP*)lpMessage;

			lpEvent->PlayerVoiceStop(pMsg->dvidSourcePlayerID);
            break;
		}
		
		case DVMSGID_CONNECTRESULT:
		{
			DVMSG_CONNECTRESULT			*msg = (DVMSG_CONNECTRESULT*)lpMessage;

			lpEvent->ConnectResult(msg->hrResult);
			break;
		}

		case DVMSGID_DISCONNECTRESULT:
		{
			DVMSG_DISCONNECTRESULT *pMsg = (DVMSG_DISCONNECTRESULT*)lpMessage;
			lpEvent->DisconnectResult(pMsg->hrResult);
			break;
		}
		
		case DVMSGID_INPUTLEVEL:
		{
			DVMSG_INPUTLEVEL *pMsg = (DVMSG_INPUTLEVEL*)lpMessage;

			lpEvent->InputLevel(pMsg->dwPeakLevel,pMsg->lRecordVolume);
			break;
		}

		case DVMSGID_OUTPUTLEVEL:
		{
			DVMSG_OUTPUTLEVEL *pMsg = (DVMSG_OUTPUTLEVEL*)lpMessage;

			lpEvent->OutputLevel(pMsg->dwPeakLevel,pMsg->lOutputVolume);
			break;
		}

		case DVMSGID_PLAYEROUTPUTLEVEL:
		{
			DVMSG_PLAYEROUTPUTLEVEL *pMsg = (DVMSG_PLAYEROUTPUTLEVEL*)lpMessage;

			lpEvent->PlayerOutputLevel(pMsg->dvidSourcePlayerID,pMsg->dwPeakLevel);
			break;
		}

		case DVMSGID_CREATEVOICEPLAYER:
		{
			DVMSG_CREATEVOICEPLAYER *pMsg = (DVMSG_CREATEVOICEPLAYER*)lpMessage;

			lpEvent->CreateVoicePlayer(pMsg->dvidPlayer, pMsg->dwFlags);
			break;
		}

		case DVMSGID_DELETEVOICEPLAYER:
		{
			DVMSG_DELETEVOICEPLAYER *pMsg = (DVMSG_DELETEVOICEPLAYER*)lpMessage;

			lpEvent->DeleteVoicePlayer(pMsg->dvidPlayer);
			break;
		}

		case DVMSGID_SETTARGETS:
			break;
	}

	DPF(1,"-----Leaving (VoiceServer) MessageHandler call...\n");
	InterlockedDecrement(&lpPeer->m_dwMsgCount);
    
	return S_OK;
}


STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::Initialize ( 
	IUnknown *DplayObj,
	long lFlags)
{
	HRESULT hr;
	IUnknown				*lpDplay = NULL;
	I_dxj_DirectPlayPeer	*lpPeer = NULL;
	I_dxj_DirectPlayClient	*lpClient = NULL;
	I_dxj_DirectPlayServer	*lpServer = NULL;

	__try {
		DPF(1,"-----Entering (VoiceServer) Initialize call...\n");
		// First we need to get our IUnknown pointer from whatever we pass in
		hr = DplayObj->QueryInterface(IID_I_dxj_DirectPlayPeer, (void**)&lpPeer);
		if (SUCCEEDED(hr))
		{
			lpPeer->InternalGetObject(&lpDplay);
			SAFE_RELEASE(lpPeer);
		}
		else
		{
			hr = DplayObj->QueryInterface(IID_I_dxj_DirectPlayClient, (void**)&lpClient);
			if (SUCCEEDED(hr))
			{
				lpClient->InternalGetObject(&lpDplay);
				SAFE_RELEASE(lpClient);
			}
			else
			{
				hr = DplayObj->QueryInterface(IID_I_dxj_DirectPlayServer, (void**)&lpServer);
				if (SUCCEEDED(hr))
				{
					lpServer->InternalGetObject(&lpDplay);
					SAFE_RELEASE(lpServer);
				}
			}
		}

		if (!lpDplay)
			return E_INVALIDARG;

		if (!m_fInit)
		{
			if (FAILED( hr=m__dxj_DirectPlayVoiceServer->Initialize(lpDplay, &VoiceMessageHandlerServer,
								this,0,(DWORD)lFlags)))
				return hr;
			m_fInit = TRUE;
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

        
STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::StartSession ( 
	DVSESSIONDESC_CDESC *SessionDesc,
	long lFlags)
{
	DVSESSIONDESC dvSession;
	HRESULT hr;
	GUID pguidCT;
	
	__try {
		DPF(1,"-----Entering (VoiceServer) StartSession call...\n");
		FlushBuffer(0);
		ZeroMemory(&dvSession, sizeof(DVSESSIONDESC));

		dvSession.dwSize						= sizeof(DVSESSIONDESC);
		dvSession.dwBufferAggressiveness		= SessionDesc->lBufferAggressiveness;
		dvSession.dwBufferQuality				= SessionDesc->lBufferQuality;
		dvSession.dwFlags						= SessionDesc->lFlags;
		dvSession.dwSessionType					= SessionDesc->lSessionType;

		if ( SessionDesc->guidCT == NULL )
			dvSession.guidCT						= DPVCTGUID_DEFAULT;
		else
		{
			hr = DPLAYBSTRtoGUID(&pguidCT, SessionDesc->guidCT);
			dvSession.guidCT = pguidCT;
		}
		
		if (FAILED ( hr = m__dxj_DirectPlayVoiceServer->StartSession( &dvSession, (DWORD)lFlags)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::StopSession ( 
	long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (VoiceServer) StopSession call...\n");
		FlushBuffer(0);
		if (FAILED ( hr = m__dxj_DirectPlayVoiceServer->StopSession((DWORD)lFlags)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::GetSessionDesc ( 
	DVSESSIONDESC_CDESC *SessionDesc)
{
	HRESULT				hr;
	DVSESSIONDESC		dvSession;
	
	__try {
		DPF(1,"-----Entering (VoiceServer) GetSessionDesc call...\n");
		FlushBuffer(0);
		dvSession.dwSize = sizeof(DVSESSIONDESC);
		//Now get the buffer
		if ( FAILED(hr = m__dxj_DirectPlayVoiceServer->GetSessionDesc(&dvSession)))
			return hr;
		
		//Cast into return buffer
		SessionDesc->lFlags = (long)dvSession.dwFlags;
		SessionDesc->lSessionType = (long)dvSession.dwSessionType;
		SessionDesc->guidCT = GUIDtoBSTR(&dvSession.guidCT);
		SessionDesc->lBufferQuality = (long)dvSession.dwBufferQuality;
		SessionDesc->lBufferAggressiveness = (long)dvSession.dwBufferAggressiveness;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::SetSessionDesc ( 
	DVSESSIONDESC_CDESC *SessionDesc)
{
	DVSESSIONDESC dvSession;
	HRESULT hr;
	GUID pguidCT;
	
	__try {
		DPF(1,"-----Entering (VoiceServer) SetSessionDesc call...\n");
		FlushBuffer(0);
		ZeroMemory(&dvSession, sizeof(DVSESSIONDESC));

		dvSession.dwSize						= sizeof(DVSESSIONDESC);
		dvSession.dwBufferAggressiveness		= SessionDesc->lBufferAggressiveness;
		dvSession.dwBufferQuality				= SessionDesc->lBufferQuality;
		dvSession.dwFlags						= SessionDesc->lFlags;
		dvSession.dwSessionType					= SessionDesc->lSessionType;

		if ( SessionDesc->guidCT == NULL )
			dvSession.guidCT						= DPVCTGUID_DEFAULT;
		else
		{
			hr = DPLAYBSTRtoGUID(&pguidCT, SessionDesc->guidCT);
			dvSession.guidCT = pguidCT;
		}

		if (FAILED ( hr = m__dxj_DirectPlayVoiceServer->SetSessionDesc(&dvSession)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::GetCaps ( 
	DVCAPS_CDESC *Caps)
{
	HRESULT				hr;

	__try {
		DPF(1,"-----Entering (VoiceServer) GetCaps call...\n");
		FlushBuffer(0);
		Caps->lSize=sizeof(DVCAPS);
		if (FAILED ( hr = m__dxj_DirectPlayVoiceServer->GetCaps((DVCAPS*)Caps))) 
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::GetCompressionTypeCount ( 
	long *retval)
{
	HRESULT			hr;
	DWORD			dwSize = 0;
	DWORD			dwNumElements = 0;

	__try {
		DPF(1,"-----Entering (VoiceServer) GetCompressionTypeCount call...\n");
		FlushBuffer(0);
		hr = m__dxj_DirectPlayVoiceServer->GetCompressionTypes(NULL, &dwSize, &dwNumElements ,0);
		
		if ( hr != DVERR_BUFFERTOOSMALL && FAILED(hr) ) //We didn't expect this error
			return hr;

		*retval = (long)dwNumElements;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::GetCompressionType ( 
	long lIndex,
	DVCOMPRESSIONINFO_CDESC *Data,
	long lFlags)
{
	HRESULT					hr;
	LPBYTE					pBuffer = NULL;	
	DWORD					dwSize = 0;
	DWORD					dwNumElements = 0;
	LPDVCOMPRESSIONINFO		pdvCompressionInfo;
	LPGUID					pGuid;

	__try {
		DPF(1,"-----Entering (VoiceServer) GetCompressionType call...\n");
		FlushBuffer(0);
		hr = m__dxj_DirectPlayVoiceServer->GetCompressionTypes(pBuffer, &dwSize, &dwNumElements ,0);
		
		if ( hr != DVERR_BUFFERTOOSMALL && FAILED(hr) ) //We didn't expect this error
			return hr;

		pBuffer = new BYTE[dwSize];
		if (!pBuffer)
			return E_OUTOFMEMORY;
		
		if ( FAILED ( hr = m__dxj_DirectPlayVoiceServer->GetCompressionTypes(pBuffer, &dwSize, &dwNumElements, (DWORD)lFlags)))
			return hr;

		if (lIndex > (long)dwNumElements)
			return DVERR_INVALIDPARAM;

		pdvCompressionInfo = (LPDVCOMPRESSIONINFO) pBuffer;
		pGuid = new GUID;
		if (!pGuid)
			return E_OUTOFMEMORY;

		// Ok, fill up our struct
		ZeroMemory(Data, sizeof(DVCOMPRESSIONINFO_CDESC));
		Data->lSize				= sizeof(DVCOMPRESSIONINFO_CDESC);
		Data->lFlags				= pdvCompressionInfo[lIndex-1].dwFlags;
		Data->lMaxBitsPerSecond		= pdvCompressionInfo[lIndex-1].dwMaxBitsPerSecond;
		Data->strDescription		= SysAllocString(pdvCompressionInfo[lIndex-1].lpszDescription);
		Data->strName				= SysAllocString(pdvCompressionInfo[lIndex-1].lpszName);
		(*pGuid) = pdvCompressionInfo[lIndex-1].guidType;

		Data->guidType				= GUIDtoBSTR(pGuid);
		SAFE_DELETE(pGuid);
		SAFE_DELETE(pBuffer);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::SetTransmitTargets ( 
	long playerSourceID,
	SAFEARRAY **playerTargetIDs,
	long lFlags)
{
	HRESULT hr;
	DWORD	dwNumTarget = ((SAFEARRAY*)*playerTargetIDs)->rgsabound[0].cElements;

	__try {
		DPF(1,"-----Entering (VoiceServer) SetTransmitTargets call...\n");
		FlushBuffer(0);
		if (FAILED( hr = m__dxj_DirectPlayVoiceServer->SetTransmitTargets((DVID)playerSourceID , 
				(DVID*)((SAFEARRAY*)*playerTargetIDs)->pvData, dwNumTarget, (DWORD) lFlags )))
			return hr;
	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::GetTransmitTargets ( 
	long playerSourceID,
	long lFlags,
	SAFEARRAY **ret)
{
	HRESULT hr;
	DVID	*dwPlayers = NULL;
	DWORD	dwNumPlayers=0;
	SAFEARRAY					*lpData = NULL;
	SAFEARRAYBOUND				rgsabound[1];

	__try {
		DPF(1,"-----Entering (VoiceServer) GetTransmitTargets call...\n");
		FlushBuffer(0);
		hr =m__dxj_DirectPlayVoiceServer->GetTransmitTargets((DVID)playerSourceID, NULL, &dwNumPlayers, (DWORD) lFlags );

		if (FAILED(hr) && ( hr != DVERR_BUFFERTOOSMALL))
			return hr;

		dwPlayers = (DVID*)new BYTE[sizeof(DVID) * dwNumPlayers];
		if (!dwPlayers)
			return E_OUTOFMEMORY;

		if (FAILED( hr = m__dxj_DirectPlayVoiceServer->GetTransmitTargets((DVID)playerSourceID, dwPlayers, &dwNumPlayers, (DWORD) lFlags )))
			return hr;

		
		if (dwNumPlayers)
		{
			// Now let's create a safearray to pass back
			rgsabound[0].lLbound = 0;
			rgsabound[0].cElements = dwNumPlayers;
			
			lpData = SafeArrayCreate(VT_UI4, 1, rgsabound);
			memcpy(lpData->pvData,dwPlayers,sizeof(DVID) * dwNumPlayers);
		}
		*ret = lpData;
		SAFE_DELETE(dwPlayers);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}


STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::StartServerNotification(I_dxj_DPVoiceEvent *event)
{
    HRESULT	  hr=S_OK;
    LPSTREAM  pStm=NULL;

	if (!event) return E_INVALIDARG;
    
	DPF(1,"-----Entering (VoiceServer) StartServerNotification call...\n");
	SAFE_RELEASE(m_pEventStream);

	// Create a global stream.  The stream needs to be global so we can 
	// marshal once, and unmarshal as many times as necessary
	hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);
    if FAILED(hr) return hr;
	// Now we can marshal our IUnknown interface.  We use MSHLFLAGS_TABLEWEAK 
	// so we can unmarshal any number of times
	hr = CoMarshalInterface(pStm, IID_I_dxj_DPVoiceEvent, event, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLEWEAK);
    if FAILED(hr) return hr;

	// Now we need to set the seek location of the stream to the beginning
	LARGE_INTEGER l;
	l.QuadPart = 0;
	pStm->Seek(l, STREAM_SEEK_SET, NULL);
    
	m_pEventStream=pStm;

	m_fHandleVoiceClientEvents = TRUE;
	return hr;
}

HRESULT C_dxj_DirectPlayVoiceServerObject::UnRegisterMessageHandler()
{
	DPF(1,"-----Entering (VoiceServer) UnregisterMessageHandler call...\n");
	m_fHandleVoiceClientEvents = FALSE;
	FlushBuffer(0);
	return S_OK;
}

HRESULT C_dxj_DirectPlayVoiceServerObject::FlushBuffer(LONG dwNumMessagesLeft)
{
	
	DWORD dwTime = GetTickCount();

	DPF(1,"-----Entering (VoiceServer) FlushBuffer call...\n");
	//Clear out the messages currently waiting
	while (m_dwMsgCount > dwNumMessagesLeft)
	{
		if (GetTickCount() - dwTime > 5000)
		{
			// Don't let FlushBuffer wait more than 5 seconds
			DPF1(1,"-----Leaving (VoiceServer) FlushBuffer call (All messages *not* flushed - %d remained)...\n", m_dwMsgCount);
			return S_OK;
		}
		//Give another thread a chance
		Sleep(0);
	}
	DPF(1,"-----Leaving (VoiceServer) FlushBuffer call (All messages flushed)...\n");
	return S_OK;
}
DWORD WINAPI ReleaseVoiceThreadProc(void* lpParam)
{
	// User context for the message handler is a pointer to our class module.
	LPDIRECTPLAYVOICESERVER lpPeer = (LPDIRECTPLAYVOICESERVER)lpParam;

	SAFE_RELEASE(lpPeer);
	CloseHandle(GetCurrentThread());
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsound3dbuffer.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsound3dbuffer.h
//
//--------------------------------------------------------------------------

// dSound3DBuffer.h : Declaration of the C_dxj_DirectSound3dBufferObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSound3dBuffer LPDIRECTSOUND3DBUFFER8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSound3dBufferObject : 
	public I_dxj_DirectSound3dBuffer,
	//public CComCoClass<C_dxj_DirectSound3dBufferObject, &CLSID__dxj_DirectSound3dBuffer>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectSound3dBufferObject() ;
	virtual ~C_dxj_DirectSound3dBufferObject() ;

BEGIN_COM_MAP(C_dxj_DirectSound3dBufferObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSound3dBuffer)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectSound3dBuffer,	"DIRECT.DirectSound3dBuffer.3",		"DIRECT.DirectSound3dBuffer.3",			IDS_DSOUND3DBUFFER_DESC, THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_DirectSound3dBufferObject)

// I_dxj_DirectSound3dBuffer
public:
	/*** IDirectSoundBuffer3D methods ***/
	//updated

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE getDirectSoundBuffer( 
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *retVal);
        
         HRESULT STDMETHODCALLTYPE getAllParameters( 
            /* [out][in] */ DS3DBUFFER_CDESC __RPC_FAR *buffer);
        
         HRESULT STDMETHODCALLTYPE getConeAngles( 
            /* [out][in] */ long __RPC_FAR *inCone,
            /* [out][in] */ long __RPC_FAR *outCone);
        
         HRESULT STDMETHODCALLTYPE getConeOrientation( 
            /* [out][in] */ D3DVECTOR_CDESC __RPC_FAR *orientation);
        
         HRESULT STDMETHODCALLTYPE getConeOutsideVolume( 
            /* [retval][out] */ long __RPC_FAR *coneOutsideVolume);
        
         HRESULT STDMETHODCALLTYPE getMaxDistance( 
            /* [retval][out] */ float __RPC_FAR *maxDistance);
        
         HRESULT STDMETHODCALLTYPE getMinDistance( 
            /* [retval][out] */ float __RPC_FAR *minDistance);
        
         HRESULT STDMETHODCALLTYPE getMode( 
            /* [retval][out] */ long __RPC_FAR *mode);
        
         HRESULT STDMETHODCALLTYPE getPosition( 
            /* [out][in] */ D3DVECTOR_CDESC __RPC_FAR *position);
        
         HRESULT STDMETHODCALLTYPE getVelocity( 
            /* [out][in] */ D3DVECTOR_CDESC __RPC_FAR *velocity);
        
         HRESULT STDMETHODCALLTYPE setAllParameters( 
            /* [in] */ DS3DBUFFER_CDESC __RPC_FAR *buffer,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setConeAngles( 
            /* [in] */ long inCone,
            /* [in] */ long outCone,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setConeOrientation( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setConeOutsideVolume( 
            /* [in] */ long coneOutsideVolume,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setMaxDistance( 
            /* [in] */ float maxDistance,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setMinDistance( 
            /* [in] */ float minDistance,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setMode( 
            /* [in] */ long mode,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setPosition( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setVelocity( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag);
private:
    DECL_VARIABLE(_dxj_DirectSound3dBuffer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSound3dBuffer )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsound3dlistener.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsound3dlistener.cpp
//
//--------------------------------------------------------------------------

// dSound3DListener.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"
#include "dms.h"
#include "dSoundObj.h"
#include "dSoundBufferObj.h"
#include "dSound3DListener.h"
#include "dSoundPrimaryBufferObj.h"

extern void *g_dxj_DirectSoundPrimaryBuffer;

CONSTRUCTOR(_dxj_DirectSound3dListener, {});
DESTRUCTOR(_dxj_DirectSound3dListener,  {});
GETSET_OBJECT(_dxj_DirectSound3dListener);

	PASS_THROUGH1_R(_dxj_DirectSound3dListener, getDistanceFactor, GetDistanceFactor, float*);
	PASS_THROUGH1_R(_dxj_DirectSound3dListener, getDopplerFactor, GetDopplerFactor, float*);
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dListener, getOrientation, GetOrientation, D3DVECTOR_CDESC*, (_D3DVECTOR*) , D3DVECTOR_CDESC*, (_D3DVECTOR*) );
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dListener, getPosition, GetPosition, D3DVECTOR_CDESC*, (_D3DVECTOR*));
	PASS_THROUGH1_R(_dxj_DirectSound3dListener, getRolloffFactor, GetRolloffFactor, float*);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dListener, getVelocity, GetVelocity, D3DVECTOR_CDESC*, (_D3DVECTOR*));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dListener, setDistanceFactor, SetDistanceFactor, float ,(float),long,( DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dListener, setDopplerFactor, SetDopplerFactor, float , (float),long,(DWORD));
	PASS_THROUGH_CAST_7_R(_dxj_DirectSound3dListener, setOrientation, SetOrientation, 
		float,(float), float, (float), float,(float),float,(float),float, (float),
		float,(float),long,(DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dListener, setPosition, SetPosition, float,(float), float, (float),float,(float),long,( DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dListener, setRolloffFactor, SetRolloffFactor,float,(float),  long, (DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dListener, setVelocity, SetVelocity, float,(float), float,(float), float,(float),long,(DWORD));
	PASS_THROUGH_R(_dxj_DirectSound3dListener, commitDeferredSettings, CommitDeferredSettings);

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dListenerObject::getAllParameters( DS3DLISTENER_CDESC* lobj )
{
	if(!lobj)
		return E_POINTER;

	lobj->lSize = sizeof(DS3DLISTENER);
	return m__dxj_DirectSound3dListener->GetAllParameters( (LPDS3DLISTENER)lobj );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dListenerObject::setAllParameters( DS3DLISTENER_CDESC *lobj, long apply)
{
	if(!lobj)
		return E_POINTER;

	lobj->lSize = sizeof(DS3DLISTENER);
	return m__dxj_DirectSound3dListener->SetAllParameters( (LPDS3DLISTENER)lobj, (DWORD)apply );
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dListenerObject::getDirectSoundBuffer( I_dxj_DirectSoundPrimaryBuffer **retv)
{
	HRESULT hr;
	IDirectSoundBuffer *pdsb;
	hr=m__dxj_DirectSound3dListener->QueryInterface(IID_IDirectSoundBuffer,(void**)&pdsb);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_DirectSoundPrimaryBuffer,pdsb,retv);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsound3dlistener.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsound3dlistener.h
//
//--------------------------------------------------------------------------

// dSound3DListener.h : Declaration of the C_dxj_DirectSound3dListenerObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSound3dListener LPDIRECTSOUND3DLISTENER8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSound3dListenerObject : 
	public I_dxj_DirectSound3dListener,
	//public CComCoClass<C_dxj_DirectSound3dListenerObject, &CLSID__dxj_DirectSound3dListener>,
	public CComObjectRoot
{
public:
	C_dxj_DirectSound3dListenerObject() ;
	virtual ~C_dxj_DirectSound3dListenerObject() ;

BEGIN_COM_MAP(C_dxj_DirectSound3dListenerObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSound3dListener)
END_COM_MAP()

//y	DECLARE_REGISTRY(CLSID__dxj_DirectSound3dListener,	"DIRECT.DirectSound3dListener.3",	"DIRECT.DirectSound3dListener.3",		IDS_DSOUND3DLISTENER_DESC, THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_DirectSound3dListenerObject)

// I_dxj_DirectSound3dListener
public:
	/*** IDirectSound3D methods ***/
	//
	//updated

	     /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd) ;
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd) ;
        
         HRESULT STDMETHODCALLTYPE getAllParameters( 
            /* [out][in] */ DS3DLISTENER_CDESC __RPC_FAR *listener) ;
        
         HRESULT STDMETHODCALLTYPE getDistanceFactor( 
            /* [retval][out] */ float __RPC_FAR *distanceFactor) ;
        
         HRESULT STDMETHODCALLTYPE getDopplerFactor( 
            /* [retval][out] */ float __RPC_FAR *dopplerFactor) ;
        
         HRESULT STDMETHODCALLTYPE getOrientation( 
            /* [out][in] */ D3DVECTOR_CDESC __RPC_FAR *orientFront,
            /* [out][in] */ D3DVECTOR_CDESC __RPC_FAR *orientTop) ;
        
         HRESULT STDMETHODCALLTYPE getPosition( 
            /* [out] */ D3DVECTOR_CDESC __RPC_FAR *position) ;
        
         HRESULT STDMETHODCALLTYPE getRolloffFactor( 
            /* [retval][out] */ float __RPC_FAR *rolloffFactor) ;
        
         HRESULT STDMETHODCALLTYPE getVelocity( 
            /* [retval][out] */ D3DVECTOR_CDESC __RPC_FAR *velocity) ;
        
         HRESULT STDMETHODCALLTYPE setAllParameters( 
            /* [in] */ DS3DLISTENER_CDESC __RPC_FAR *listener,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setDistanceFactor( 
            /* [in] */ float distanceFactor,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setDopplerFactor( 
            /* [in] */ float dopplerFactor,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setOrientation( 
            /* [in] */ float xFront,
            /* [in] */ float yFront,
            /* [in] */ float zFront,
            /* [in] */ float xTop,
            /* [in] */ float yTop,
            /* [in] */ float zTop,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setPosition( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setRolloffFactor( 
            /* [in] */ float rolloffFactor,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setVelocity( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE commitDeferredSettings( void) ;
        
         HRESULT STDMETHODCALLTYPE getDirectSoundBuffer( 
            /* [retval][out] */ I_dxj_DirectSoundPrimaryBuffer __RPC_FAR *__RPC_FAR *retVal) ;
private:
    DECL_VARIABLE(_dxj_DirectSound3dListener);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSound3dListener )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundbufferobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundbufferobj.h
//
//--------------------------------------------------------------------------

// dSoundBufferObj.h : Declaration of the C_dxj_DirectSoundBufferObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundBuffer LPDIRECTSOUNDBUFFER8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundBufferObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundBuffer, &IID_I_dxj_DirectSoundBuffer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundBuffer,
#endif

	//public CComCoClass<C_dxj_DirectSoundBufferObject, &CLSID__dxj_DirectSoundBuffer>,
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundBufferObject() ;
	virtual ~C_dxj_DirectSoundBufferObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundBufferObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundBuffer)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//y	DECLARE_REGISTRY(CLSID__dxj_DirectSoundBuffer,	"DIRECT.DirectSoundBuffer.3",		"DIRECT.DirectSoundBuffer.3",			IDS_DSOUNDBUFFER_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundBufferObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundBufferObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundBuffer
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE getDirectSound3dBuffer( 
            /* [retval][out] */ I_dxj_DirectSound3dBuffer __RPC_FAR *__RPC_FAR *lpdsb);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSBCAPS_CDESC __RPC_FAR *caps);
        
         HRESULT STDMETHODCALLTYPE getCurrentPosition( 
            /* [out] */ DSCURSORS_CDESC __RPC_FAR *cursors);
        
         HRESULT STDMETHODCALLTYPE getFormat( 
            /* [out][in] */ WAVEFORMATEX_CDESC __RPC_FAR *format);
        
         HRESULT STDMETHODCALLTYPE getVolume( 
            /* [retval][out] */ long __RPC_FAR *volume);
        
         HRESULT STDMETHODCALLTYPE getPan( 
            /* [retval][out] */ long __RPC_FAR *pan);
        
         HRESULT STDMETHODCALLTYPE getFrequency( 
            /* [retval][out] */ long __RPC_FAR *frequency);
        
         HRESULT STDMETHODCALLTYPE getStatus( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE initialize( 
            /* [in] */ I_dxj_DirectSound __RPC_FAR *directSound,
            /* [out][in] */ DSBUFFERDESC_CDESC __RPC_FAR *bufferDesc,
            /* [out][in] */ byte __RPC_FAR *wbuf);
        
         HRESULT STDMETHODCALLTYPE writeBuffer( 
            /* [in] */ long start,
            /* [in] */ long size,
            ///* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *buffer,
			void * buf,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE readBuffer( 
            /* [in] */ long start,
            /* [in] */ long size,
            ///* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *buffer,
				void * buf,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE play( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE setCurrentPosition( 
            /* [in] */ long newPosition);
        
         HRESULT STDMETHODCALLTYPE setVolume( 
            /* [in] */ long volume);
        
         HRESULT STDMETHODCALLTYPE setPan( 
            /* [in] */ long pan);
        
         HRESULT STDMETHODCALLTYPE setFrequency( 
            /* [in] */ long frequency);
        
         HRESULT STDMETHODCALLTYPE stop( void);
        
         HRESULT STDMETHODCALLTYPE restore( void);
		 
		 HRESULT STDMETHODCALLTYPE setNotificationPositions(long nElements,SAFEARRAY  **ppsa);

		 HRESULT STDMETHODCALLTYPE saveToFile(BSTR b);
		 
		 HRESULT STDMETHODCALLTYPE SetFX(long lEffectsCount, SAFEARRAY **Buffers, SAFEARRAY **lResultIDs);
		 
		 HRESULT STDMETHODCALLTYPE AcquireResources(long lFlags, SAFEARRAY **lEffects);

		 HRESULT STDMETHODCALLTYPE GetObjectinPath(BSTR guidFX, long lIndex, BSTR iidInterface, IUnknown **ret);

#if 0
		 HRESULT STDMETHODCALLTYPE SetChannelVolume(long lChannelCount, SAFEARRAY **lChannels, SAFEARRAY **lVolumes);
#endif

private:
    DECL_VARIABLE(_dxj_DirectSoundBuffer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSoundBuffer )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundcapturebufferobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundcapturebufferobj.cpp
//
//--------------------------------------------------------------------------

// dSoundCaptureBufferObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file


#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"

#include "dms.h"
#include "dSoundObj.h"
#include "dSoundCaptureBufferObj.h"
#include "dSoundCaptureObj.h"

CONSTRUCTOR(_dxj_DirectSoundCaptureBuffer, {});
DESTRUCTOR(_dxj_DirectSoundCaptureBuffer, {});
GETSET_OBJECT(_dxj_DirectSoundCaptureBuffer);

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::getCaps(DSCBCAPS_CDESC *caps)
{    
	((DSCBCAPS*)caps)->dwSize=sizeof(DSCBCAPS);
    return m__dxj_DirectSoundCaptureBuffer->GetCaps((DSCBCAPS*)caps);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::getCurrentPosition(DSCURSORS_CDESC *desc) 
{    	
	/////////////////////////////////////////////////////////////////////////////
	if(!desc)
		return E_POINTER;

	return (m__dxj_DirectSoundCaptureBuffer->GetCurrentPosition((DWORD*)&desc->lPlay, (DWORD*)&desc->lWrite) ); 
}


STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::getStatus(long *stat)
{    	
    return m__dxj_DirectSoundCaptureBuffer->GetStatus((DWORD*)stat);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::start(long flags)
{    	
    return m__dxj_DirectSoundCaptureBuffer->Start((DWORD)flags);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::stop()
{    	
    return m__dxj_DirectSoundCaptureBuffer->Stop();
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::getFormat(WAVEFORMATEX_CDESC *format)
{    	
	DWORD cb=0;
    return m__dxj_DirectSoundCaptureBuffer->GetFormat((WAVEFORMATEX*)format,sizeof(WAVEFORMATEX_CDESC),&cb);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::initialize(I_dxj_DirectSoundCaptureBuffer *buffer,DSCBUFFERDESC_CDESC *desc)
{    	
	((DSCBUFFERDESC*)desc)->dwSize=sizeof(DSCBUFFERDESC);
	DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDCAPTURE, lpref, buffer);
    return m__dxj_DirectSoundCaptureBuffer->Initialize(lpref,(DSCBUFFERDESC*)desc);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::setNotificationPositions (long nElements,SAFEARRAY  **ppsa)
{
	if (!ISSAFEARRAY1D(ppsa,(DWORD)nElements))
		return E_INVALIDARG;
	
	HRESULT hr;
	LPDIRECTSOUNDNOTIFY pDSN=NULL;

	if (nElements == 0)
	{
		// There is absolutely nothing to do if we want to set 0 notification positions
		return S_OK;
	}

	hr=m__dxj_DirectSoundCaptureBuffer->QueryInterface(IID_IDirectSoundNotify,(void**)&pDSN);
	if FAILED(hr) return hr;

    hr=pDSN->SetNotificationPositions((DWORD)nElements,(LPCDSBPOSITIONNOTIFY)((SAFEARRAY*)*ppsa)->pvData);	
		
	pDSN->Release();

	return hr;
}

        

/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own buffer
//which is passed into WriteBuffer(). Because the environment is now double
//buffered there is no need to Lock Java memory. WriteBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::writeBuffer(long start, long totsz, 
													void  *buf,  long flags) 
{ 
	#pragma message ("SoundBuffer writeBuffer ")

	byte *buffer=(byte*)buf; //(byte*)((SAFEARRAY*)*ppsa)->pvData;

	if(!buffer)
		return E_POINTER;

	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;
	__try {
	DPF1(1,"----- DXVB: DSoundCaptureBuffer (WriteBuffer) Lock buffer (Total size = %d )\n",totsz);
	if ((val = m__dxj_DirectSoundCaptureBuffer->Lock((DWORD)start, (DWORD)totsz, &p1, &size1, &p2, &size2, 
															(DWORD)flags)) != DS_OK)
		return val;

	// Copy to buffer end, then do a wrapped portion if it exists, then unlock
	DPF1(1,"----- DXVB: DSoundCaptureBuffer (WriteBuffer) about to copy to buffer (size1 = %d )\n",size1);
	if (p1)	
	{
		DPF1(1,"----- DXVB: DSoundCaptureBuffer (WriteBuffer) about to copy to buffer (size1 = %d )\n",size1);
		memcpy (p1, buffer, size1);
	}

	if (p2)	 //There was wrapping
	{
		DPF1(1,"----- DXVB: DSoundCaptureBuffer (WriteBuffer) about to copy to buffer (size2 = %d )\n",size2);
		memcpy(p2, &buffer[size1], size2);
	}

	//docdoc: because Lock and Unlock are tied together within WriteBuffer,
	//        DSBufferDesc no longer needs to save Lock's system pointers.
	DPF(1,"----- DXVB: DSoundCaptureBuffer (WriteBuffer) Unlocking buffer.\n");
	val= m__dxj_DirectSoundCaptureBuffer->Unlock(p1, size1, p2, size2);
   }
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		DPF(1,"----- DXVB: (WriteBuffer) Exception.\n");
		return E_FAIL;
	}
	return val;
}


/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own buffer
//which is passed into WriteBuffer(). Because the environment is now double
//buffered there is no need to Lock Java memory. WriteBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::readBuffer(long start, long totsz, 
													void  *buf,  long flags) 
{ 

	//byte *buffer=(byte*)((SAFEARRAY*)*ppsa)->pvData;
	byte *buffer=(byte*)buf;

	if(!buffer)
		return E_POINTER;
	
	LPVOID	p1 = NULL, p2 = NULL;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;
	
   __try {
	DPF1(1,"----- DXVB: DSoundCaptureBuffer (ReadBuffer) Lock buffer (Total size = %d )\n",totsz);
	if ((val = m__dxj_DirectSoundCaptureBuffer->Lock((DWORD)start, (DWORD)totsz, &p1, &size1, &p2, &size2, 
															(DWORD)flags)) != DS_OK)
		return val;

	// Copy to buffer end, then do a wrapped portion if it exists, then unlock
	if (p1)	
	{
		DPF1(1,"----- DXVB: DSoundCaptureBuffer (ReadBuffer) about to copy to buffer (size1 = %d )\n",size1);
		memcpy (buffer,p1,  size1);
	}

	if (p2)	 //There was wrapping
	{
		DPF1(1,"----- DXVB: DSoundCaptureBuffer (ReadBuffer) about to copy to buffer (size2 = %d )\n",size2);
		memcpy(&buffer[size1],p2,  size2);
	}

	//docdoc: because Lock and Unlock are tied together within WriteBuffer,
	//        DSBufferDesc no longer needs to save Lock's system pointers.
	DPF(1,"----- DXVB: DSoundCaptureBuffer (ReadBuffer) Unlocking buffer.\n");
	val= m__dxj_DirectSoundCaptureBuffer->Unlock(p1, size1, p2, size2);
   }
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		DPF(1,"----- DXVB: (ReadBuffer) Exception.\n");
		return E_FAIL;
	}
   return val;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundcaptureobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundcaptureobj.cpp
//
//--------------------------------------------------------------------------

// dSoundCaptureObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"

#include "dms.h"
#include "dSoundObj.h"
#include "dSoundCaptureObj.h"
#include "dSoundCaptureBufferObj.h"

CONSTRUCTOR(_dxj_DirectSoundCapture, {});
DESTRUCTOR(_dxj_DirectSoundCapture, {});
GETSET_OBJECT(_dxj_DirectSoundCapture);

   

STDMETHODIMP C_dxj_DirectSoundCaptureObject::createCaptureBuffer(
	DSCBUFFERDESC_CDESC *desc,I_dxj_DirectSoundCaptureBuffer **retval)
{
    
	HRESULT						hr = S_OK;
	IDirectSoundCaptureBuffer	*lpBuffer=NULL;
	DSCBUFFERDESC				realDesc;
	
	ZeroMemory(&realDesc, sizeof(DSCBUFFERDESC));

	realDesc.dwSize = sizeof(DSCBUFFERDESC);
	
	realDesc.dwBufferBytes = desc->lBufferBytes;
	realDesc.dwReserved = desc->lReserved;
	realDesc.lpwfxFormat = (WAVEFORMATEX*)&desc->fxFormat;

    hr=m__dxj_DirectSoundCapture->CreateCaptureBuffer(&realDesc,&lpBuffer,NULL);	
	if FAILED(hr) return hr;
	
	INTERNAL_CREATE(_dxj_DirectSoundCaptureBuffer, lpBuffer, retval);
	return hr;
}

STDMETHODIMP C_dxj_DirectSoundCaptureObject::getCaps(DSCCAPS_CDESC *caps){
	((DSCCAPS*)caps)->dwSize=sizeof(DSCCAPS);
	return m__dxj_DirectSoundCapture->GetCaps((DSCCAPS*)caps);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundcaptureobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsoundcaptureobj.h
//
//--------------------------------------------------------------------------

// dSoundBufferObj.h : Declaration of the C_dxj_DirectSoundCaptureObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundCapture LPDIRECTSOUNDCAPTURE8
#ifndef _DSOUNDCAPTUREOBJ_H_
#define _DSOUNDCAPTUREOBJ_H_
/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundCaptureObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundCapture, &IID_I_dxj_DirectSoundCapture, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundCapture,
#endif

	//public CComCoClass<C_dxj_DirectSoundCaptureObject, &CLSID__dxj_DirectSoundCapture>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundCaptureObject() ;
	virtual ~C_dxj_DirectSoundCaptureObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundCaptureObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundCapture)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectSoundCapture,	"DIRECT.DirectSoundCapture.5",		"DIRECT.DirectSoundCapture.5",			IDS_DSOUNDBUFFER_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundCaptureObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundCaptureObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundCapture
public:
	//updated

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd) ;
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd) ;
        
         HRESULT STDMETHODCALLTYPE createCaptureBuffer( 
            /* [in] */ DSCBUFFERDESC_CDESC __RPC_FAR *bufferDesc,
            /* [retval][out] */ I_dxj_DirectSoundCaptureBuffer __RPC_FAR *__RPC_FAR *ret) ;
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSCCAPS_CDESC __RPC_FAR *caps) ;

private:
    DECL_VARIABLE(_dxj_DirectSoundCapture);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSoundCapture )
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundcapturebufferobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsoundcapturebufferobj.h
//
//--------------------------------------------------------------------------

// dSoundBufferObj.h : Declaration of the C_dxj_DirectSoundCaptureBufferObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundCaptureBuffer LPDIRECTSOUNDCAPTUREBUFFER

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundCaptureBufferObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundCaptureBuffer, &IID_I_dxj_DirectSoundCaptureBuffer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundCaptureBuffer,
#endif

//	public CComCoClass<C_dxj_DirectSoundCaptureBufferObject, &CLSID__dxj_DirectSoundCaptureBuffer>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundCaptureBufferObject() ;
	virtual ~C_dxj_DirectSoundCaptureBufferObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundCaptureBufferObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundCaptureBuffer)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectSoundCaptureBuffer,	"DIRECT.DirectSoundCaptureBuffer.5",		"DIRECT.DirectSoundCaptureBuffer.5",			IDS_DSOUNDBUFFER_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundCaptureBufferObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundCaptureBufferObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundCaptureBuffer
public:
	//updated

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSCBCAPS_CDESC __RPC_FAR *caps);
        
         HRESULT STDMETHODCALLTYPE getCurrentPosition( DSCURSORS_CDESC *desc);                  			

         HRESULT STDMETHODCALLTYPE getFormat( 
            /* [out][in] */ WAVEFORMATEX_CDESC __RPC_FAR *waveformat);
        
         HRESULT STDMETHODCALLTYPE getStatus( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE initialize( 
            /* [in] */ I_dxj_DirectSoundCaptureBuffer __RPC_FAR *captureBuffer,
            /* [in] */ DSCBUFFERDESC_CDESC __RPC_FAR *bufferDesc);
        
         HRESULT STDMETHODCALLTYPE start( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE stop( void);

		 HRESULT  STDMETHODCALLTYPE setNotificationPositions(long nElements,SAFEARRAY  **ppsa);

		 HRESULT STDMETHODCALLTYPE readBuffer(long start, long totsz, 
													void  *buf,  long flags) ;
		 HRESULT STDMETHODCALLTYPE writeBuffer(long start, long totsz, 
													void  *buf,  long flags) ;


private:
    DECL_VARIABLE(_dxj_DirectSoundCaptureBuffer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSoundCaptureBuffer )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsounddownloadedwaveobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundDownloadedWaveObj.h"

extern void *g_dxj_DirectSoundDownloadedWave;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundDownloadedWaveObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundDownloadedWave [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundDownloadedWaveObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundDownloadedWave [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundDownloadedWaveObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundDownloadedWaveObject::C_dxj_DirectSoundDownloadedWaveObject(){ 
		
	DPF1(1,"Constructor Creation DirectSoundDownloadedWave Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundDownloadedWave = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundDownloadedWave;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundDownloadedWave = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundDownloadedWaveObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundDownloadedWaveObject::~C_dxj_DirectSoundDownloadedWaveObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundDownloadedWaveObject destructor \n");

     C_dxj_DirectSoundDownloadedWaveObject *prev=NULL; 
	for(C_dxj_DirectSoundDownloadedWaveObject *ptr=(C_dxj_DirectSoundDownloadedWaveObject*)g_dxj_DirectSoundDownloadedWave ; ptr; ptr=(C_dxj_DirectSoundDownloadedWaveObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundDownloadedWave = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundDownloadedWave found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundDownloadedWave){
		int count = IUNK(m__dxj_DirectSoundDownloadedWave)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundDownloadedWave Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundDownloadedWave = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();
	
}

HRESULT C_dxj_DirectSoundDownloadedWaveObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundDownloadedWave;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundDownloadedWaveObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundDownloadedWave=(LPDIRECTSOUNDDOWNLOADEDWAVE)pUnk;
	return S_OK;
}

//////////////
/// No Methods
//////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundbufferobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundbufferobj.cpp
//
//--------------------------------------------------------------------------

// dSoundBufferObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"

#include "dms.h"
#include "dSoundBufferObj.h"
#include "dSoundObj.h"
#include "dSound3DListener.h"
#include "dSound3DBuffer.h"
#include "dsoundFXGargleobj.h"
#include "dsoundFXEchoobj.h"
#include "dsoundFXChorusobj.h"
#include "dsoundFXCompressorobj.h"
#include "dsoundFXDistortionobj.h"
#include "dsoundFXFlangerobj.h"
#include "dsoundfxi3dl2reverbobj.h"
#if 0
#include "dsoundfxi3dl2sourceobj.h"
#include "dsoundfxsendobj.h"
#endif
#include "dsoundfxparameqobj.h"
#include "dsoundfxwavesreverbobj.h"

extern void *g_dxj_DirectSoundFXWavesReverb;
extern void *g_dxj_DirectSoundFXCompressor;
extern void *g_dxj_DirectSoundFXChorus;
extern void *g_dxj_DirectSoundFXGargle;
extern void *g_dxj_DirectSoundFXEcho;
extern void *g_dxj_DirectSoundFXSend;
extern void *g_dxj_DirectSoundFXDistortion;
extern void *g_dxj_DirectSoundFXFlanger;
extern void *g_dxj_DirectSoundFXParamEQ;
extern void *g_dxj_DirectSoundFXI3DL2Reverb;
#if 0
extern void *g_dxj_DirectSoundFXI3DL2Source;
#endif
#define SAFE_DELETE(p) { if (p) {free(p); p = NULL;} }

extern HRESULT AudioBSTRtoGUID(LPGUID,BSTR);
extern HRESULT InternalSaveToFile(IDirectSoundBuffer *pBuff,BSTR file);

CONSTRUCTOR(_dxj_DirectSoundBuffer, {});
DESTRUCTOR(_dxj_DirectSoundBuffer, {});
GETSET_OBJECT(_dxj_DirectSoundBuffer);

	PASS_THROUGH1_R(_dxj_DirectSoundBuffer, getVolume, GetVolume, long*);
	PASS_THROUGH1_R(_dxj_DirectSoundBuffer, getPan, GetPan, long*);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, getFrequency, GetFrequency, long*,(DWORD*));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, getStatus, GetStatus, long*,(DWORD*));

	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, setCurrentPosition, SetCurrentPosition, long,(DWORD));
	PASS_THROUGH1_R(_dxj_DirectSoundBuffer, setPan, SetPan, LONG);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, setFrequency, SetFrequency, long,(DWORD));
	PASS_THROUGH_R(_dxj_DirectSoundBuffer, stop, Stop);
	PASS_THROUGH_R(_dxj_DirectSoundBuffer, restore, Restore);


STDMETHODIMP C_dxj_DirectSoundBufferObject::setVolume(LONG vol)
{
	__try {
		return m__dxj_DirectSoundBuffer->SetVolume(vol); 
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
}

STDMETHODIMP C_dxj_DirectSoundBufferObject::getDirectSound3dBuffer(I_dxj_DirectSound3dBuffer **retval)
{
    IDirectSound3DBuffer *lp3db;
	HRESULT hr = S_OK;

	__try {
		if( (hr=m__dxj_DirectSoundBuffer->QueryInterface(IID_IDirectSound3DBuffer, (void**) &lp3db)) != S_OK)
			return hr;

		INTERNAL_CREATE(_dxj_DirectSound3dBuffer, lp3db, retval);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

STDMETHODIMP C_dxj_DirectSoundBufferObject::getCaps(DSBCAPS_CDESC* caps)
{
	__try {
		if(!caps)
			return E_POINTER;

		caps->lSize = sizeof(DSBCAPS);
		return m__dxj_DirectSoundBuffer->GetCaps((LPDSBCAPS)caps); 
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::getCurrentPosition(DSCURSORS_CDESC *desc) 
{ 
	__try {
		if(!desc) return E_POINTER;
		return (m__dxj_DirectSoundBuffer->GetCurrentPosition((DWORD*)&desc->lPlay, (DWORD*)&desc->lWrite) ); 
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

}

/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own buffer
//which is passed into WriteBuffer(). Because the environment is now double
//buffered there is no need to Lock Java memory. WriteBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::writeBuffer(long start, long totsz, 
					void  *buf,  long flags) 
{ 
	#pragma message ("SoundBuffer writeBuffer ")

	byte *buffer=(byte*)buf; //(byte*)((SAFEARRAY*)*ppsa)->pvData;

	if(!buffer)
		return E_POINTER;

	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;

	__try {
		if ((val = m__dxj_DirectSoundBuffer->Lock((DWORD)start, (DWORD)totsz,
			 &p1, &size1, &p2, &size2,
			(DWORD)flags)) != DS_OK)
			return val;

		// Copy to buffer end, then do a wrapped portion if it exists, then unlock
		DPF1(1,"----- DXVB: DSoundBuffer (WriteBuffer) about to copy to buffer (size1 = %d )\n",size1);
		if (p1)	
		{
			DPF1(1,"----- DXVB: DSoundBuffer (WriteBuffer) about to copy to buffer (size1 = %d )\n",size1);
			memcpy (p1, buffer, size1);
		}

		if (p2)	 //There was wrapping
		{
			DPF1(1,"----- DXVB: DSoundBuffer (WriteBuffer) about to copy to buffer (size2 = %d )\n",size2);
			memcpy(p2, &buffer[size1], size2);
		}

		//docdoc: because Lock and Unlock are tied together within WriteBuffer,
		//        DSBufferDesc no longer needs to save Lock's system pointers.
		DPF(1,"----- DXVB: DSoundBuffer (WriteBuffer) Unlocking buffer.\n");
		val=m__dxj_DirectSoundBuffer->Unlock(p1, size1, p2, size2);
	}
	__except(0,0){
		return E_FAIL;
	}
	return val;
}


/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own buffer
//which is passed into WriteBuffer(). Because the environment is now double
//buffered there is no need to Lock Java memory. WriteBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::readBuffer(long start, long totsz,
	void  *buf,  long flags) 
{ 

	byte *buffer=(byte*)buf;

	if(!buffer)
		return E_POINTER;
	
	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;
	
   __try {
	if ((val = m__dxj_DirectSoundBuffer->Lock((DWORD)start, (DWORD)totsz, &p1, &size1, &p2, &size2, 
															(DWORD)flags)) != DS_OK)
		return val;

	// Copy to buffer end, then do a wrapped portion if it exists, then unlock
	if (p1)	
	{
		DPF1(1,"----- DXVB: DSoundBuffer (ReadBuffer) about to copy to buffer (size1 = %d )\n",size1);
		memcpy (buffer,p1,  size1);
	}

	if (p2)	 //There was wrapping
	{
		DPF1(1,"----- DXVB: DSoundBuffer (ReadBuffer) about to copy to buffer (size2 = %d )\n",size2);
		memcpy(&buffer[size1],p2,  size2);
	}

	//docdoc: because Lock and Unlock are tied together within WriteBuffer,
	//        DSBufferDesc no longer needs to save Lock's system pointers.
	DPF(1,"----- DXVB: DSoundBuffer (ReadBuffer) Unlocking buffer.\n");
	val= m__dxj_DirectSoundBuffer->Unlock(p1, size1, p2, size2);
   }
   __except(1,1){
	return E_FAIL;
   }
   return val;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::getFormat(WAVEFORMATEX_CDESC *format) 
{ 
	DWORD *wsize=0;	// docdoc: throw away returned written size

	HRESULT hr=DS_OK;
	__try {
		hr=m__dxj_DirectSoundBuffer->GetFormat((LPWAVEFORMATEX)format, (DWORD)sizeof(WAVEFORMATEX_CDESC), wsize);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
			
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::initialize(I_dxj_DirectSound *ds,
		 DSBUFFERDESC_CDESC *buf, unsigned char *wave) 
{
	if(! (ds && buf && wave) )
		return E_POINTER;


	LPDSBUFFERDESC lpds = NULL;

	__try {
		lpds = (LPDSBUFFERDESC)malloc(sizeof(DSBUFFERDESC));
		if (!lpds)
			return E_OUTOFMEMORY;

		ZeroMemory(lpds, sizeof(DSBUFFERDESC));

		lpds->dwSize = sizeof(DSBUFFERDESC);
		lpds->dwFlags = buf->lFlags;
		lpds->dwBufferBytes = buf->lBufferBytes;
		lpds->dwReserved = buf->lReserved;
#ifdef _WIN64
		lpds->lpwfxFormat = (WAVEFORMATEX*)wave;
#else
		lpds->lpwfxFormat = (WAVEFORMATEX*)PtrToLong(wave);
#endif
		AudioBSTRtoGUID(&lpds->guid3DAlgorithm, buf->guid3DAlgorithm);

		DO_GETOBJECT_NOTNULL(LPDIRECTSOUND, lpdsound, ds)

		m__dxj_DirectSoundBuffer->Initialize(lpdsound, (LPDSBUFFERDESC)lpds);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::play(long flags) 
{
	HRESULT hr=DS_OK;
	__try {
		if((hr=m__dxj_DirectSoundBuffer->Play(0, 0, (DWORD)flags)) != DS_OK)
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return hr;
}



STDMETHODIMP C_dxj_DirectSoundBufferObject::setNotificationPositions (long nElements,SAFEARRAY  **ppsa)
{
	if (!ISSAFEARRAY1D(ppsa,(DWORD)nElements))
		return E_INVALIDARG;
	
	HRESULT hr;
	LPDIRECTSOUNDNOTIFY pDSN=NULL;

	__try {
		if (nElements == 0)
		{
			// There is absolutely nothing to do if we want to set 0 notification positions
			return S_OK;
		}

		hr=m__dxj_DirectSoundBuffer->QueryInterface(IID_IDirectSoundNotify,(void**)&pDSN);
		if FAILED(hr) return hr;

		hr=pDSN->SetNotificationPositions((DWORD)nElements,(LPCDSBPOSITIONNOTIFY)((SAFEARRAY*)*ppsa)->pvData);	
			
		pDSN->Release();

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}


STDMETHODIMP C_dxj_DirectSoundBufferObject::saveToFile(BSTR file)
{

	HRESULT hr= InternalSaveToFile(m__dxj_DirectSoundBuffer,file);
	return hr;
}

STDMETHODIMP C_dxj_DirectSoundBufferObject::SetFX(long lEffectsCount, SAFEARRAY **Buffers, SAFEARRAY **lResultIDs)
{
	HRESULT hr;

	DSEFFECTDESC		*dsec = NULL;
	DSEFFECTDESC_CDESC	*bufTemp = NULL;
	
	DWORD				*dwRetStatus = NULL;

	__try {
		if (lEffectsCount != 0)
		{
			// Get memory for our effects buffers
			dsec = (DSEFFECTDESC*)malloc(sizeof(DSEFFECTDESC) * lEffectsCount);
			if (!dsec) return E_OUTOFMEMORY;

			//Get memory for our Status
			dwRetStatus = (DWORD*)malloc(sizeof(DWORD) * lEffectsCount);
			if (!dwRetStatus)
			{
				SAFE_DELETE(dsec);
				return E_OUTOFMEMORY;
			}
			ZeroMemory(dwRetStatus,sizeof(DWORD) * lEffectsCount);

			bufTemp = (DSEFFECTDESC_CDESC*)malloc(sizeof(DSEFFECTDESC_CDESC) * lEffectsCount);
			if (!bufTemp) return E_OUTOFMEMORY;

			memcpy(bufTemp, (DSEFFECTDESC_CDESC*)((SAFEARRAY*)*Buffers)->pvData, sizeof(DSEFFECTDESC_CDESC) * lEffectsCount);

			// Set up our effect
			for (int i=0 ; i<=lEffectsCount-1 ; i++)
			{
				ZeroMemory(&dsec[i], sizeof(DSEFFECTDESC));
				dsec[i].dwSize = sizeof(DSEFFECTDESC);
				dsec[i].dwFlags	= (DWORD) bufTemp[i].lFlags;
				#if 0
				DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDBUFFER, lpBuf, bufTemp[i].SendBuffer);
				dsec[i].lpSendBuffer = lpBuf;
				#endif
				if (FAILED (hr = AudioBSTRtoGUID(&dsec[i].guidDSFXClass, bufTemp[i].guidDSFXClass ) ) )
				{
					SAFE_DELETE(dsec);
					SAFE_DELETE(bufTemp);
					return hr;
				}
			}
			// We no longer need this 
			SAFE_DELETE(bufTemp);
		}

		if (FAILED (hr = m__dxj_DirectSoundBuffer->SetFX((DWORD)lEffectsCount, dsec, dwRetStatus) ))
		{
			SAFE_DELETE(dsec);
			return hr;
		}

		SAFE_DELETE(dsec);
		// Now we can return our status's
		if (dwRetStatus)
			memcpy(((SAFEARRAY*)*lResultIDs)->pvData, dwRetStatus, sizeof(DWORD) * lEffectsCount);

		SAFE_DELETE(dwRetStatus);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}
		 
STDMETHODIMP C_dxj_DirectSoundBufferObject::AcquireResources(long lFlags, SAFEARRAY **lEffects)
{
	HRESULT hr;
	DWORD				*dwRetStatus = NULL;
	DWORD				dwEffectsCount = 0;

	__try {
		dwEffectsCount = (DWORD)((SAFEARRAY*)*lEffects)->rgsabound[0].cElements;
		//Get memory for our Status
		dwRetStatus = (DWORD*)malloc(sizeof(DWORD) * dwEffectsCount);
		if (!dwRetStatus)
			return E_OUTOFMEMORY;

		ZeroMemory(dwRetStatus,sizeof(DWORD) * dwEffectsCount);

		if (FAILED ( hr = m__dxj_DirectSoundBuffer->AcquireResources((DWORD) lFlags, dwEffectsCount, dwRetStatus) ) )
			return hr;
		
		// Now we can return our status's
		memcpy(((SAFEARRAY*)*lEffects)->pvData, dwRetStatus, sizeof(DWORD) * dwEffectsCount);
		SAFE_DELETE(dwRetStatus);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

STDMETHODIMP C_dxj_DirectSoundBufferObject::GetObjectinPath(BSTR guidFX, long lIndex, BSTR iidInterface, IUnknown **ret)
{
	HRESULT hr;
	GUID guidEffect;
	GUID guidIID;

	__try {
		if (FAILED (hr = AudioBSTRtoGUID(&guidEffect, guidFX ) ) )
			return hr;

		if (FAILED (hr = AudioBSTRtoGUID(&guidIID, iidInterface ) ) )
			return hr;


		if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_gargle")){
			IDirectSoundFXGargle	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXGargle, lpRetObj, ret);
		}
#if 0
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_send")){
			IDirectSoundFXSend	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXSend, lpRetObj, ret);
		}
#endif
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_echo")){
			IDirectSoundFXEcho	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXEcho, lpRetObj, ret);
		}
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_chorus")){
			IDirectSoundFXChorus	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXChorus, lpRetObj, ret);
		}
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_compressor")){
			IDirectSoundFXCompressor	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXCompressor, lpRetObj, ret);
		}
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_distortion")){
			IDirectSoundFXDistortion	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXDistortion, lpRetObj, ret);
		}
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_flanger")){
			IDirectSoundFXFlanger	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXFlanger, lpRetObj, ret);
		}
#if 0
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_i3dl2source")){
			IDirectSoundFXI3DL2Source	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXI3DL2Source, lpRetObj, ret);
		}
#endif
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_i3dl2reverb")){
			IDirectSoundFXI3DL2Reverb	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXI3DL2Reverb, lpRetObj, ret);
		}
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_parameq")){
			IDirectSoundFXParamEq	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXParamEQ, lpRetObj, ret);
		}
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_waves_reverb")){
			IDirectSoundFXWavesReverb	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXWavesReverb, lpRetObj, ret);
		}
		else
			return E_INVALIDARG;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

#if 0
STDMETHODIMP C_dxj_DirectSoundBufferObject::SetChannelVolume(long lChannelCount, SAFEARRAY **lChannels, SAFEARRAY **lVolumes)
{
	HRESULT hr;

	__try {
		if (FAILED(hr = m__dxj_DirectSoundBuffer->SetChannelVolume((DWORD) lChannelCount, (DWORD*) ((SAFEARRAY*)*lChannels)->pvData, (long*) ((SAFEARRAY*)*lVolumes)->pvData) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsounddownloadedwaveobj.h ===
#include "resource.h"       // main symbols
#include "dmusicc.h"

#define typedef__dxj_DirectSoundDownloadedWave LPDIRECTSOUNDDOWNLOADEDWAVE8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundDownloadedWaveObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundDownloadedWave, &IID_I_dxj_DirectSoundDownloadedWave, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundDownloadedWave,
#endif

	public CComObjectRoot
{

public:
	C_dxj_DirectSoundDownloadedWaveObject() ;
	virtual ~C_dxj_DirectSoundDownloadedWaveObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundDownloadedWaveObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundDownloadedWave)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundDownloadedWaveObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundDownloadedWave
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundDownloadedWave);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundDownloadedWave);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxchorusobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXChorus LPDIRECTSOUNDFXCHORUS8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXChorusObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXChorus, &IID_I_dxj_DirectSoundFXChorus, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXChorus,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXChorusObject() ;
	virtual ~C_dxj_DirectSoundFXChorusObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXChorusObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXChorus)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXChorusObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXChorus
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXCHORUS_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXCHORUS_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXChorus);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXChorus);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxcompressorobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXCompressor LPDIRECTSOUNDFXCOMPRESSOR8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXCompressorObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXCompressor, &IID_I_dxj_DirectSoundFXCompressor, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXCompressor,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXCompressorObject() ;
	virtual ~C_dxj_DirectSoundFXCompressorObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXCompressorObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXCompressor)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXCompressorObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXCompressor
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXCOMPRESSOR_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXCOMPRESSOR_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXCompressor);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXCompressor);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxcompressorobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXCompressorObj.h"					   

extern void *g_dxj_DirectSoundFXCompressor;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXCompressorObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXCompressor [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXCompressorObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXCompressor [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXCompressorObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXCompressorObject::C_dxj_DirectSoundFXCompressorObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXCompressor Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXCompressor = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXCompressor;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXCompressor = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXCompressorObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXCompressorObject::~C_dxj_DirectSoundFXCompressorObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXCompressorObject destructor \n");

     C_dxj_DirectSoundFXCompressorObject *prev=NULL; 
	for(C_dxj_DirectSoundFXCompressorObject *ptr=(C_dxj_DirectSoundFXCompressorObject *)g_dxj_DirectSoundFXCompressor ; ptr; ptr=(C_dxj_DirectSoundFXCompressorObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXCompressor = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXCompressorObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXCompressor){
		int count = IUNK(m__dxj_DirectSoundFXCompressor)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXCompressor Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXCompressor = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXCompressorObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXCompressor;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXCompressorObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXCompressor=(LPDIRECTSOUNDFXCOMPRESSOR8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXCompressorObject::SetAllParameters(DSFXCOMPRESSOR_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXCompressor->SetAllParameters((DSFXCompressor*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXCompressorObject::GetAllParameters(DSFXCOMPRESSOR_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXCompressor->GetAllParameters((DSFXCompressor*) params) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxdistortionobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXDistortion LPDIRECTSOUNDFXDISTORTION8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXDistortionObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXDistortion, &IID_I_dxj_DirectSoundFXDistortion, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXDistortion,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXDistortionObject() ;
	virtual ~C_dxj_DirectSoundFXDistortionObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXDistortionObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXDistortion)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXDistortionObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXDistortion
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXDISTORTION_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXDISTORTION_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXDistortion);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXDistortion);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxchorusobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXChorusObj.h"					   

extern void *g_dxj_DirectSoundFXChorus;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXChorusObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXChorus [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXChorusObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXChorus [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXChorusObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXChorusObject::C_dxj_DirectSoundFXChorusObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXChorus Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXChorus = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXChorus;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXChorus = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXChorusObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXChorusObject::~C_dxj_DirectSoundFXChorusObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXChorusObject destructor \n");

     C_dxj_DirectSoundFXChorusObject *prev=NULL; 
	for(C_dxj_DirectSoundFXChorusObject *ptr=(C_dxj_DirectSoundFXChorusObject *)g_dxj_DirectSoundFXChorus ; ptr; ptr=(C_dxj_DirectSoundFXChorusObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXChorus = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXChorusObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXChorus){
		int count = IUNK(m__dxj_DirectSoundFXChorus)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXChorus Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXChorus = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXChorusObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXChorus;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXChorusObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXChorus=(LPDIRECTSOUNDFXCHORUS8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXChorusObject::SetAllParameters(DSFXCHORUS_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXChorus->SetAllParameters((DSFXChorus*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXChorusObject::GetAllParameters(DSFXCHORUS_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXChorus->GetAllParameters((DSFXChorus*) params) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxdistortionobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXDistortionObj.h"					   

extern void *g_dxj_DirectSoundFXDistortion;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXDistortionObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXDistortion [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXDistortionObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXDistortion [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXDistortionObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXDistortionObject::C_dxj_DirectSoundFXDistortionObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXDistortion Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXDistortion = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXDistortion;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXDistortion = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXDistortionObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXDistortionObject::~C_dxj_DirectSoundFXDistortionObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXDistortionObject destructor \n");

     C_dxj_DirectSoundFXDistortionObject *prev=NULL; 
	for(C_dxj_DirectSoundFXDistortionObject *ptr=(C_dxj_DirectSoundFXDistortionObject *)g_dxj_DirectSoundFXDistortion ; ptr; ptr=(C_dxj_DirectSoundFXDistortionObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXDistortion = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXDistortionObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXDistortion){
		int count = IUNK(m__dxj_DirectSoundFXDistortion)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXDistortion Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXDistortion = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXDistortionObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXDistortion;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXDistortionObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXDistortion=(LPDIRECTSOUNDFXDISTORTION8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXDistortionObject::SetAllParameters(DSFXDISTORTION_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXDistortion->SetAllParameters((DSFXDistortion*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXDistortionObject::GetAllParameters(DSFXDISTORTION_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXDistortion->GetAllParameters((DSFXDistortion*) params) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxechoobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXEchoObj.h"					   

extern void *g_dxj_DirectSoundFXEcho;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXEchoObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXEcho [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXEchoObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXEcho [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXEchoObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXEchoObject::C_dxj_DirectSoundFXEchoObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXEcho Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXEcho = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXEcho;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXEcho = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXEchoObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXEchoObject::~C_dxj_DirectSoundFXEchoObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXEchoObject destructor \n");

     C_dxj_DirectSoundFXEchoObject *prev=NULL; 
	for(C_dxj_DirectSoundFXEchoObject *ptr=(C_dxj_DirectSoundFXEchoObject *)g_dxj_DirectSoundFXEcho ; ptr; ptr=(C_dxj_DirectSoundFXEchoObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXEcho = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXEchoObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXEcho){
		int count = IUNK(m__dxj_DirectSoundFXEcho)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXEcho Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXEcho = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXEchoObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXEcho;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXEchoObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXEcho=(LPDIRECTSOUNDFXECHO8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXEchoObject::SetAllParameters(DSFXECHO_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXEcho->SetAllParameters((DSFXEcho*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXEchoObject::GetAllParameters(DSFXECHO_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXEcho->GetAllParameters((DSFXEcho*) params) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxechoobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXEcho LPDIRECTSOUNDFXECHO8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXEchoObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXEcho, &IID_I_dxj_DirectSoundFXEcho, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXEcho,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXEchoObject() ;
	virtual ~C_dxj_DirectSoundFXEchoObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXEchoObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXEcho)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXEchoObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXEcho
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXECHO_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXECHO_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXEcho);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXEcho);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxflangerobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXFlanger LPDIRECTSOUNDFXFLANGER8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXFlangerObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXFlanger, &IID_I_dxj_DirectSoundFXFlanger, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXFlanger,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXFlangerObject() ;
	virtual ~C_dxj_DirectSoundFXFlangerObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXFlangerObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXFlanger)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXFlangerObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXFlanger
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXFLANGER_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXFLANGER_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXFlanger);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXFlanger);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxi3dl2reverbobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXI3DL2Reverb LPDIRECTSOUNDFXI3DL2REVERB8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXI3DL2ReverbObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXI3DL2Reverb, &IID_I_dxj_DirectSoundFXI3DL2Reverb, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXI3DL2Reverb,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXI3DL2ReverbObject() ;
	virtual ~C_dxj_DirectSoundFXI3DL2ReverbObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXI3DL2ReverbObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXI3DL2Reverb)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXI3DL2ReverbObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXI3DL2Reverb
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXI3DL2REVERB_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXI3DL2REVERB_CDESC *params);
		HRESULT STDMETHODCALLTYPE SetPreset(long lPreset);
		HRESULT STDMETHODCALLTYPE GetPreset(long *ret);
		HRESULT STDMETHODCALLTYPE SetQuality(long lQuality);
		HRESULT STDMETHODCALLTYPE GetQuality(long *ret);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXI3DL2Reverb);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXI3DL2Reverb);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxgargleobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXGargle LPDIRECTSOUNDFXGARGLE8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXGargleObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXGargle, &IID_I_dxj_DirectSoundFXGargle, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXGargle,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXGargleObject() ;
	virtual ~C_dxj_DirectSoundFXGargleObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXGargleObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXGargle)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXGargleObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXGargle
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXGARGLE_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXGARGLE_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXGargle);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXGargle);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxi3dl2reverbobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXI3DL2ReverbObj.h"					   

extern void *g_dxj_DirectSoundFXI3DL2Reverb;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXI3DL2ReverbObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXI3DL2Reverb [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXI3DL2ReverbObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXI3DL2Reverb [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXI3DL2ReverbObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXI3DL2ReverbObject::C_dxj_DirectSoundFXI3DL2ReverbObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXI3DL2Reverb Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXI3DL2Reverb = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXI3DL2Reverb;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXI3DL2Reverb = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXI3DL2ReverbObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXI3DL2ReverbObject::~C_dxj_DirectSoundFXI3DL2ReverbObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXI3DL2ReverbObject destructor \n");

     C_dxj_DirectSoundFXI3DL2ReverbObject *prev=NULL; 
	for(C_dxj_DirectSoundFXI3DL2ReverbObject *ptr=(C_dxj_DirectSoundFXI3DL2ReverbObject *)g_dxj_DirectSoundFXI3DL2Reverb ; ptr; ptr=(C_dxj_DirectSoundFXI3DL2ReverbObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXI3DL2Reverb = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXI3DL2ReverbObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXI3DL2Reverb){
		int count = IUNK(m__dxj_DirectSoundFXI3DL2Reverb)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXI3DL2Reverb Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXI3DL2Reverb = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXI3DL2ReverbObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXI3DL2Reverb;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXI3DL2ReverbObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXI3DL2Reverb=(LPDIRECTSOUNDFXI3DL2REVERB8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2ReverbObject::SetAllParameters(DSFXI3DL2REVERB_CDESC *params)
{
	HRESULT hr;

	__try {
		if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Reverb->SetAllParameters((DSFXI3DL2Reverb*) params) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2ReverbObject::GetAllParameters(DSFXI3DL2REVERB_CDESC *params)
{
	HRESULT hr;

	__try {
		if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Reverb->GetAllParameters((DSFXI3DL2Reverb*) params) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXI3DL2ReverbObject::SetPreset(long lPreset)
{
	HRESULT hr;

	__try {
		if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Reverb->SetPreset((DWORD) lPreset) ))
			return hr;
	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2ReverbObject::GetPreset(long *ret)
{
	HRESULT hr;

	__try {
		if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Reverb->GetPreset((DWORD*) ret) ))
			return hr;
	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2ReverbObject::SetQuality(long lQuality)
{
	HRESULT hr;

	__try {
		if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Reverb->SetQuality(lQuality) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2ReverbObject::GetQuality(long *ret)
{
	HRESULT hr;

	__try {
		if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Reverb->GetQuality(ret) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxflangerobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXFlangerObj.h"					   

extern void *g_dxj_DirectSoundFXFlanger;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXFlangerObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXFlanger [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXFlangerObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXFlanger [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXFlangerObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXFlangerObject::C_dxj_DirectSoundFXFlangerObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXFlanger Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXFlanger = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXFlanger;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXFlanger = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXFlangerObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXFlangerObject::~C_dxj_DirectSoundFXFlangerObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXFlangerObject destructor \n");

     C_dxj_DirectSoundFXFlangerObject *prev=NULL; 
	for(C_dxj_DirectSoundFXFlangerObject *ptr=(C_dxj_DirectSoundFXFlangerObject *)g_dxj_DirectSoundFXFlanger ; ptr; ptr=(C_dxj_DirectSoundFXFlangerObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXFlanger = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXFlangerObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXFlanger){
		int count = IUNK(m__dxj_DirectSoundFXFlanger)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXFlanger Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXFlanger = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXFlangerObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXFlanger;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXFlangerObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXFlanger=(LPDIRECTSOUNDFXFLANGER8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXFlangerObject::SetAllParameters(DSFXFLANGER_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXFlanger->SetAllParameters((DSFXFlanger*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXFlangerObject::GetAllParameters(DSFXFLANGER_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXFlanger->GetAllParameters((DSFXFlanger*) params) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxgargleobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXGargleObj.h"					   

extern void *g_dxj_DirectSoundFXGargle;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXGargleObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXGargle [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXGargleObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXGargle [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXGargleObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXGargleObject::C_dxj_DirectSoundFXGargleObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXGargle Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXGargle = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXGargle;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXGargle = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXGargleObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXGargleObject::~C_dxj_DirectSoundFXGargleObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXGargleObject destructor \n");

     C_dxj_DirectSoundFXGargleObject *prev=NULL; 
	for(C_dxj_DirectSoundFXGargleObject *ptr=(C_dxj_DirectSoundFXGargleObject *)g_dxj_DirectSoundFXGargle ; ptr; ptr=(C_dxj_DirectSoundFXGargleObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXGargle = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXGargleObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXGargle){
		int count = IUNK(m__dxj_DirectSoundFXGargle)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXGargle Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXGargle = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXGargleObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXGargle;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXGargleObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXGargle=(LPDIRECTSOUNDFXGARGLE8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXGargleObject::SetAllParameters(DSFXGARGLE_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXGargle->SetAllParameters((DSFXGargle*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXGargleObject::GetAllParameters(DSFXGARGLE_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXGargle->GetAllParameters((DSFXGargle*) params) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxi3dl2sourceobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXI3DL2SourceObj.h"					   

extern void *g_dxj_DirectSoundFXI3DL2Source;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXI3DL2SourceObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXI3DL2Source [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXI3DL2SourceObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXI3DL2Source [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXI3DL2SourceObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXI3DL2SourceObject::C_dxj_DirectSoundFXI3DL2SourceObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXI3DL2Source Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXI3DL2Source = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXI3DL2Source;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXI3DL2Source = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXI3DL2SourceObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXI3DL2SourceObject::~C_dxj_DirectSoundFXI3DL2SourceObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXI3DL2SourceObject destructor \n");

     C_dxj_DirectSoundFXI3DL2SourceObject *prev=NULL; 
	for(C_dxj_DirectSoundFXI3DL2SourceObject *ptr=(C_dxj_DirectSoundFXI3DL2SourceObject *)g_dxj_DirectSoundFXI3DL2Source ; ptr; ptr=(C_dxj_DirectSoundFXI3DL2SourceObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXI3DL2Source = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXI3DL2SourceObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXI3DL2Source){
		int count = IUNK(m__dxj_DirectSoundFXI3DL2Source)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXI3DL2Source Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXI3DL2Source = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXI3DL2SourceObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXI3DL2Source;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXI3DL2SourceObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXI3DL2Source=(LPDIRECTSOUNDFXI3DL2SOURCE8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2SourceObject::SetAllParameters(DSFXI3DL2SOURCE_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Source->SetAllParameters((DSFXI3DL2Source*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2SourceObject::GetAllParameters(DSFXI3DL2SOURCE_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Source->GetAllParameters((DSFXI3DL2Source*) params) ))
		return hr;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXI3DL2SourceObject::SetObstructionPreset(long lObstruction)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Source->SetObstructionPreset((DWORD) lObstruction) ))
		return hr;
	
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2SourceObject::GetObstructionPreset(long *ret)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Source->GetObstructionPreset((DWORD*) ret) ))
		return hr;
	
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2SourceObject::SetOcclusionPreset(long lOcclusion)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Source->SetOcclusionPreset((DWORD) lOcclusion) ))
		return hr;
	
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2SourceObject::GetOcclusionPreset(long *ret)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Source->GetOcclusionPreset((DWORD*) ret) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxi3dl2sourceobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXI3DL2Source LPDIRECTSOUNDFXI3DL2SOURCE8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXI3DL2SourceObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXI3DL2Source, &IID_I_dxj_DirectSoundFXI3DL2Source, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXI3DL2Source,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXI3DL2SourceObject() ;
	virtual ~C_dxj_DirectSoundFXI3DL2SourceObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXI3DL2SourceObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXI3DL2Source)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXI3DL2SourceObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXI3DL2Source
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXI3DL2SOURCE_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXI3DL2SOURCE_CDESC *params);
		HRESULT STDMETHODCALLTYPE SetObstructionPreset(long lObstruction);
		HRESULT STDMETHODCALLTYPE GetObstructionPreset(long *ret);
		HRESULT STDMETHODCALLTYPE SetOcclusionPreset(long lOcclusion);
		HRESULT STDMETHODCALLTYPE GetOcclusionPreset(long *ret);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXI3DL2Source);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXI3DL2Source);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxsendobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXSend LPDIRECTSOUNDFXSEND8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXSendObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXSend, &IID_I_dxj_DirectSoundFXSend, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXSend,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXSendObject() ;
	virtual ~C_dxj_DirectSoundFXSendObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXSendObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXSend)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXSendObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXSend
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXSEND_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXSEND_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXSend);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXSend);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxparameqobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXParamEQObj.h"					   

extern void *g_dxj_DirectSoundFXParamEQ;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXParamEQObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXParamEQ [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXParamEQObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXParamEQ [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXParamEQObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXParamEQObject::C_dxj_DirectSoundFXParamEQObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXParamEQ Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXParamEQ = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXParamEQ;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXParamEQ = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXParamEQObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXParamEQObject::~C_dxj_DirectSoundFXParamEQObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXParamEQObject destructor \n");

     C_dxj_DirectSoundFXParamEQObject *prev=NULL; 
	for(C_dxj_DirectSoundFXParamEQObject *ptr=(C_dxj_DirectSoundFXParamEQObject *)g_dxj_DirectSoundFXParamEQ ; ptr; ptr=(C_dxj_DirectSoundFXParamEQObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXParamEQ = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXParamEQObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXParamEQ){
		int count = IUNK(m__dxj_DirectSoundFXParamEQ)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXParamEQ Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXParamEQ = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXParamEQObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXParamEQ;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXParamEQObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXParamEQ=(LPDIRECTSOUNDFXPARAMEQ8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXParamEQObject::SetAllParameters(DSFXPARAMEQ_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXParamEQ->SetAllParameters((DSFXParamEq*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXParamEQObject::GetAllParameters(DSFXPARAMEQ_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXParamEQ->GetAllParameters((DSFXParamEq*) params) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxsendobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXSendObj.h"					   

extern void *g_dxj_DirectSoundFXSend;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXSendObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXSend [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXSendObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXSend [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXSendObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXSendObject::C_dxj_DirectSoundFXSendObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXSend Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXSend = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXSend;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXSend = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXSendObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXSendObject::~C_dxj_DirectSoundFXSendObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXSendObject destructor \n");

     C_dxj_DirectSoundFXSendObject *prev=NULL; 
	for(C_dxj_DirectSoundFXSendObject *ptr=(C_dxj_DirectSoundFXSendObject *)g_dxj_DirectSoundFXSend ; ptr; ptr=(C_dxj_DirectSoundFXSendObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXSend = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXSendObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXSend){
		int count = IUNK(m__dxj_DirectSoundFXSend)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXSend Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXSend = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXSendObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXSend;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXSendObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXSend=(LPDIRECTSOUNDFXSEND8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXSendObject::SetAllParameters(DSFXSEND_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXSend->SetAllParameters((DSFXSend*)params) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXSendObject::GetAllParameters(DSFXSEND_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXSend->GetAllParameters((DSFXSend*)params) ) )
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxwavesreverbobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXWavesReverb IDirectSoundFXWavesReverb*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXWavesReverbObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXWavesReverb, &IID_I_dxj_DirectSoundFXWavesReverb, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXWavesReverb,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXWavesReverbObject() ;
	virtual ~C_dxj_DirectSoundFXWavesReverbObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXWavesReverbObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXWavesReverb)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXWavesReverbObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXWavesReverb
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXWAVESREVERB_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXWAVESREVERB_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXWavesReverb);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXWavesReverb);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundobj.cpp
//
//--------------------------------------------------------------------------

// dSoundObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file


#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"
#include "dms.h"
#include "dSoundObj.h"
#include "dSoundBufferObj.h"
#include "dsoundprimarybufferobj.h"
extern	BOOL IsAllZeros(void *pStruct,DWORD size); 
extern HRESULT AudioBSTRtoGUID(LPGUID,BSTR);

extern HRESULT InternalCreateSoundBufferFromFile(LPDIRECTSOUND8 lpDirectSound,LPDSBUFFERDESC pDesc,WCHAR *file,LPDIRECTSOUNDBUFFER8 *lplpDirectSoundBuffer) ;
extern HRESULT InternalCreateSoundBufferFromResource(LPDIRECTSOUND8 lpDirectSound,LPDSBUFFERDESC pDesc,HANDLE resHandle,WCHAR *resName,LPDIRECTSOUNDBUFFER8 *lplpDirectSoundBuffer);
extern void *g_dxj_DirectSoundPrimaryBuffer;

CONSTRUCTOR(_dxj_DirectSound, {m__dxj_DirectSound=NULL;m_pDriverGuid=NULL;});
DESTRUCTOR(_dxj_DirectSound,  {if (m_pDriverGuid) delete m_pDriverGuid;});
GETSET_OBJECT(_dxj_DirectSound);
	//
    /*** IDirectSound methods ***/
	//

PASS_THROUGH_CAST_1_R(_dxj_DirectSound, getSpeakerConfig, GetSpeakerConfig, long*,(DWORD*)); 
PASS_THROUGH_CAST_1_R(_dxj_DirectSound, setSpeakerConfig, SetSpeakerConfig, long,(DWORD)); 

STDMETHODIMP C_dxj_DirectSoundObject::getCaps(DSCAPS_CDESC* caps)
{
	caps->lSize = sizeof(DSCAPS);
	return m__dxj_DirectSound->GetCaps((LPDSCAPS)caps); 
}

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////

#ifdef _WIN64
STDMETHODIMP C_dxj_DirectSoundObject::setCooperativeLevel(HWND h, long d)
#else
STDMETHODIMP C_dxj_DirectSoundObject::setCooperativeLevel(LONG h, long d)
#endif
{
	if( m__dxj_DirectSound == NULL )
		return E_FAIL;

	return m__dxj_DirectSound->SetCooperativeLevel((HWND)h, (DWORD)d); 
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectSoundObject::duplicateSoundBuffer(I_dxj_DirectSoundBuffer *src, 
		I_dxj_DirectSoundBuffer **val) 
{
	if(! (src && val) )
		return E_POINTER;

	DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDBUFFER, lpdsb, src);

	//Need to create a second one
	LPDIRECTSOUNDBUFFER		dsb=0;
	HRESULT hr=S_OK;
	hr=m__dxj_DirectSound->DuplicateSoundBuffer((LPDIRECTSOUNDBUFFER)lpdsb, &dsb); 
	if SUCCEEDED(hr)
	{
		INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, val);
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectSoundObject::CreatePrimarySoundBuffer(DSBUFFERDESC_CDESC *desc, 
			I_dxj_DirectSoundPrimaryBuffer **val) 
{
	LPDIRECTSOUNDBUFFER 		dsb = NULL;	// Need to get the buffer first
	DSBUFFERDESC				lpds;
	HRESULT						hr;

	if ((desc->lFlags & DSBCAPS_PRIMARYBUFFER) == 0)
		return E_INVALIDARG;

	lpds.dwSize = sizeof(DSBUFFERDESC);
	lpds.dwFlags = desc->lFlags;
	lpds.dwBufferBytes = desc->lBufferBytes;
	lpds.dwReserved = desc->lReserved;
	lpds.lpwfxFormat = NULL;
	AudioBSTRtoGUID(&lpds.guid3DAlgorithm, desc->guid3DAlgorithm);

	if (FAILED(hr = m__dxj_DirectSound->CreateSoundBuffer(&lpds, &dsb, NULL) ) )
		return hr;

	INTERNAL_CREATE(_dxj_DirectSoundPrimaryBuffer, dsb, val);

	return S_OK;
}


STDMETHODIMP C_dxj_DirectSoundObject::createSoundBuffer(DSBUFFERDESC_CDESC *desc, 
			I_dxj_DirectSoundBuffer **val) 
{
	LPDIRECTSOUNDBUFFER 		dsb = NULL;	// Need to get the buffer first
	DSBUFFERDESC				lpds;
	LPDIRECTSOUNDBUFFER8		dsbReal = NULL;
	HRESULT						hr;
	WAVEFORMATEX				fxWave;

	if (desc->lFlags & DSBCAPS_PRIMARYBUFFER)
		return E_INVALIDARG;

	ZeroMemory(&lpds, sizeof(DSBUFFERDESC));
	ZeroMemory(&fxWave, sizeof(WAVEFORMATEX));

	lpds.dwSize = sizeof(DSBUFFERDESC);

	lpds.dwFlags = desc->lFlags;
	lpds.dwBufferBytes = desc->lBufferBytes;
	lpds.dwReserved = desc->lReserved;
	if (!IsAllZeros(&desc->fxFormat, sizeof(WAVEFORMATEX)))
	{
		memcpy(&fxWave, &desc->fxFormat, sizeof(WAVEFORMATEX));
	}
	else
	{
		// Do a default one
		fxWave.cbSize = sizeof(WAVEFORMATEX);
		fxWave.wFormatTag = WAVE_FORMAT_PCM;
		fxWave.nChannels = 2;
		fxWave.nSamplesPerSec = 22050;
		fxWave.wBitsPerSample = 16;
		fxWave.nBlockAlign = fxWave.wBitsPerSample / 8 * fxWave.nChannels;
		fxWave.nAvgBytesPerSec = fxWave.nSamplesPerSec * fxWave.nBlockAlign;
#if 0
		if ((desc->lFlags & DSBCAPS_MIXIN) == 0)
		    lpds.dwBufferBytes = fxWave.nSamplesPerSec;
#endif
	}
		lpds.lpwfxFormat = &fxWave;

	AudioBSTRtoGUID(&lpds.guid3DAlgorithm, desc->guid3DAlgorithm);

	if (FAILED(hr = m__dxj_DirectSound->CreateSoundBuffer(&lpds, &dsb, NULL) ) )
		return hr;

	hr = dsb->QueryInterface(IID_IDirectSoundBuffer8, (void**) &dsbReal);
	dsb->Release();
	if (FAILED(hr)) return hr;

	INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsbReal, val);

	return S_OK;
}

STDMETHODIMP C_dxj_DirectSoundObject::createSoundBufferFromFile(BSTR fileName, DSBUFFERDESC_CDESC *desc, 
			I_dxj_DirectSoundBuffer **val) 
{
	LPDIRECTSOUNDBUFFER8	dsb;	// Need to get the buffer first
	LPDSBUFFERDESC			lpds = NULL;
	HRESULT					hr=S_OK;

		
	*val=NULL;	

	lpds = (LPDSBUFFERDESC)malloc(sizeof(DSBUFFERDESC));
	if (!lpds)
		return E_OUTOFMEMORY;

	ZeroMemory(lpds, sizeof(DSBUFFERDESC));

	lpds->dwSize = sizeof(DSBUFFERDESC);
	lpds->dwFlags = desc->lFlags;
	lpds->dwBufferBytes = desc->lBufferBytes;
	lpds->dwReserved = desc->lReserved;
	lpds->lpwfxFormat = (WAVEFORMATEX*)&desc->fxFormat;
	AudioBSTRtoGUID(&lpds->guid3DAlgorithm, desc->guid3DAlgorithm);
	
	if (FAILED( hr=InternalCreateSoundBufferFromFile(m__dxj_DirectSound,(LPDSBUFFERDESC)lpds,
			(WCHAR*)fileName,&dsb) ) )
			return hr;

	// Return our information now
	desc->lFlags = lpds->dwFlags;
	desc->lBufferBytes = lpds->dwBufferBytes;

	INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, val);

	DWORD *wsize=0;	

	hr = dsb->GetFormat((LPWAVEFORMATEX)&desc->fxFormat, (DWORD)sizeof(WAVEFORMATEX_CDESC), wsize);

	return S_OK;

}



STDMETHODIMP C_dxj_DirectSoundObject::createSoundBufferFromResource(BSTR resFile, BSTR resName, 
			DSBUFFERDESC_CDESC *desc, 
			 I_dxj_DirectSoundBuffer **val) 
{

		
	
	LPDIRECTSOUNDBUFFER8	dsb;	// Need to get the buffer first
	LPDSBUFFERDESC			lpds = NULL ;
	HRESULT					hr=S_OK;	
	HMODULE					hMod=NULL;

	
	USES_CONVERSION;
		
	if  ((resFile) &&(resFile[0]!=0)){
		// BUG BUG: - 
		// seems that GetModuleHandleW is
		// always returning 0 on w98??			
		// hMod= GetModuleHandleW(moduleName);
		LPCTSTR pszName = NULL;
		__try { pszName = W2T(resFile); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		 hMod= GetModuleHandle(pszName);
	}

		
	*val=NULL;	

	lpds = (LPDSBUFFERDESC)malloc(sizeof(DSBUFFERDESC));
	if (!lpds)
		return E_OUTOFMEMORY;

	ZeroMemory(lpds, sizeof(DSBUFFERDESC));

	lpds->dwSize = sizeof(DSBUFFERDESC);
	lpds->dwFlags = desc->lFlags;
	lpds->dwBufferBytes = desc->lBufferBytes;
	lpds->dwReserved = desc->lReserved;
	lpds->lpwfxFormat = (WAVEFORMATEX*)&desc->fxFormat;
	AudioBSTRtoGUID(&lpds->guid3DAlgorithm, desc->guid3DAlgorithm);
	
	hr=InternalCreateSoundBufferFromResource(m__dxj_DirectSound,(LPDSBUFFERDESC)lpds,
			(HANDLE)hMod,(WCHAR*)resName,&dsb);

	
	if SUCCEEDED(hr)
	{
		INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, val);
	}


	return hr;
}

#if 0
//DEAD CODE
STDMETHODIMP C_dxj_DirectSoundObject::AllocSink(
		long lBusCount, WAVEFORMATEX_CDESC *format, 
		I_dxj_DirectSoundSink **ret)
{
	HRESULT hr;
	LPDIRECTSOUNDSINK8	lpdsink = NULL;
	
	hr = m__dxj_DirectSound->AllocSink((DWORD) lBusCount, sizeof(lBusCount), (WAVEFORMATEX*)format, &lpdsink);
 
	if (FAILED(hr))
		return hr;

	INTERNAL_CREATE(_dxj_DirectSoundSink, lpdsink , ret);

	return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxparameqobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXParamEQ LPDIRECTSOUNDFXPARAMEQ8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXParamEQObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXParamEQ, &IID_I_dxj_DirectSoundFXParamEQ, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXParamEQ,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXParamEQObject() ;
	virtual ~C_dxj_DirectSoundFXParamEQObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXParamEQObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXParamEQ)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXParamEQObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXParamEQ
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXPARAMEQ_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXPARAMEQ_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXParamEQ);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXParamEQ);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundfxwavesreverbobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXWavesReverbObj.h"					   

extern void *g_dxj_DirectSoundFXWavesReverb;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXWavesReverbObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXWavesReverb [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXWavesReverbObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXWavesReverb [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXWavesReverbObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXWavesReverbObject::C_dxj_DirectSoundFXWavesReverbObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXWavesReverb Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXWavesReverb = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXWavesReverb;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXWavesReverb = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXWavesReverbObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXWavesReverbObject::~C_dxj_DirectSoundFXWavesReverbObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXWavesReverbObject destructor \n");

     C_dxj_DirectSoundFXWavesReverbObject *prev=NULL; 
	for(C_dxj_DirectSoundFXWavesReverbObject *ptr=(C_dxj_DirectSoundFXWavesReverbObject *)g_dxj_DirectSoundFXWavesReverb ; ptr; ptr=(C_dxj_DirectSoundFXWavesReverbObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXWavesReverb = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXWavesReverbObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXWavesReverb){
		int count = IUNK(m__dxj_DirectSoundFXWavesReverb)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXWavesReverb Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXWavesReverb = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXWavesReverbObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXWavesReverb;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXWavesReverbObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXWavesReverb=(IDirectSoundFXWavesReverb*)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXWavesReverbObject::SetAllParameters(DSFXWAVESREVERB_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXWavesReverb->SetAllParameters((DSFXWavesReverb*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXWavesReverbObject::GetAllParameters(DSFXWAVESREVERB_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXWavesReverb->GetAllParameters((DSFXWavesReverb*) params) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundobj.h
//
//--------------------------------------------------------------------------

// dSoundObj.h : Declaration of the C_dxj_DirectSoundObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSound  LPDIRECTSOUND8
#ifndef _DSOUNDOBJ_H_
#define _DSOUNDOBJ_H_

#ifndef Hwnd
	#define HWnd long
#endif
 
/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSound, &IID_I_dxj_DirectSound, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSound,
#endif

	//public CComCoClass<C_dxj_DirectSoundObject, &CLSID__dxj_DirectSound>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundObject() ;
	virtual ~C_dxj_DirectSoundObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSound)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectSound, "DIRECT.DirectSound.3",				"DIRECT.DirectSound.3",					IDS_DSOUND_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundBuffer
public:


         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE createSoundBuffer( 
            /* [in] */ DSBUFFERDESC_CDESC __RPC_FAR *bufferDesc,
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *soundBuffer);
        
         HRESULT STDMETHODCALLTYPE createSoundBufferFromFile( 
            /* [in] */ BSTR fileName,
            /* [out][in] */ DSBUFFERDESC_CDESC __RPC_FAR *bufferDesc,
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *soundBuffer);
        
         HRESULT STDMETHODCALLTYPE createSoundBufferFromResource( 
            /* [in] */ BSTR resourceFile,
            /* [in] */ BSTR resourceName,
            /* [out][in] */ DSBUFFERDESC_CDESC __RPC_FAR *bufferDesc,
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *soundBuffer);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSCAPS_CDESC __RPC_FAR *caps);
        
         HRESULT STDMETHODCALLTYPE duplicateSoundBuffer( 
            /* [in] */ I_dxj_DirectSoundBuffer __RPC_FAR *original,
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *duplicate);
        
         HRESULT STDMETHODCALLTYPE setCooperativeLevel( 
#ifdef _WIN64
		    /* [in] */ HWND hwnd,
#else
		    /* [in] */ LONG hwnd,
#endif
            /* [in] */ long level);
        
        
         HRESULT STDMETHODCALLTYPE getSpeakerConfig( 
            /* [retval][out] */ long __RPC_FAR *speakerConfig);
        
         HRESULT STDMETHODCALLTYPE setSpeakerConfig( 
            /* [in] */ long speakerConfig);


         HRESULT STDMETHODCALLTYPE CreatePrimarySoundBuffer( 
            /* [in] */ DSBUFFERDESC_CDESC __RPC_FAR *bufferDesc,
            /* [retval][out] */ I_dxj_DirectSoundPrimaryBuffer __RPC_FAR *__RPC_FAR *soundBuffer);

			
#if 0
		HRESULT STDMETHODCALLTYPE AllocSink(
			long lBusCount, WAVEFORMATEX_CDESC __RPC_FAR *format, 
			I_dxj_DirectSoundSink __RPC_FAR *__RPC_FAR *ret);
#endif

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectSound);
	GUID *m_pDriverGuid;

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSound )
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundprimarybufferobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundPrimaryBufferobj.h
//
//--------------------------------------------------------------------------

// dSoundPrimaryBufferObj.h : Declaration of the C_dxj_DirectSoundPrimaryBufferObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundPrimaryBuffer LPDIRECTSOUNDBUFFER

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundPrimaryBufferObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundPrimaryBuffer, &IID_I_dxj_DirectSoundPrimaryBuffer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundPrimaryBuffer,
#endif

	//public CComCoClass<C_dxj_DirectSoundPrimaryBufferObject, &CLSID__dxj_DirectSoundPrimaryBuffer>,
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundPrimaryBufferObject() ;
	virtual ~C_dxj_DirectSoundPrimaryBufferObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundPrimaryBufferObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundPrimaryBuffer)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundPrimaryBufferObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundPrimaryBufferObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundPrimaryBuffer
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE getDirectSound3dListener( 
            /* [retval][out] */ I_dxj_DirectSound3dListener __RPC_FAR *__RPC_FAR *lpdsl);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSBCAPS_CDESC __RPC_FAR *caps);
        
         HRESULT STDMETHODCALLTYPE getCurrentPosition( 
            /* [out] */ DSCURSORS_CDESC __RPC_FAR *cursors);
        
         HRESULT STDMETHODCALLTYPE getFormat( 
            /* [out][in] */ WAVEFORMATEX_CDESC __RPC_FAR *format);
        
         HRESULT STDMETHODCALLTYPE getVolume( 
            /* [retval][out] */ long __RPC_FAR *volume);
        
         HRESULT STDMETHODCALLTYPE getPan( 
            /* [retval][out] */ long __RPC_FAR *pan);
        
         HRESULT STDMETHODCALLTYPE getStatus( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE initialize( 
            /* [in] */ I_dxj_DirectSound __RPC_FAR *directSound,
            /* [out][in] */ DSBUFFERDESC_CDESC __RPC_FAR *BufferDesc,
            /* [out][in] */ byte __RPC_FAR *wbuf);
        
         HRESULT STDMETHODCALLTYPE writeBuffer( 
            /* [in] */ long start,
            /* [in] */ long size,
            ///* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *PrimaryBuffer,
			void * buf,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE readBuffer( 
            /* [in] */ long start,
            /* [in] */ long size,
            ///* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *PrimaryBuffer,
				void * buf,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE play( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE setFormat( 
            /* [in] */ WAVEFORMATEX_CDESC __RPC_FAR *format);
        
         HRESULT STDMETHODCALLTYPE setVolume( 
            /* [in] */ long volume);
        
         HRESULT STDMETHODCALLTYPE setPan( 
            /* [in] */ long pan);
        
         HRESULT STDMETHODCALLTYPE stop( void);
        
         HRESULT STDMETHODCALLTYPE restore( void);
		 


private:
    DECL_VARIABLE(_dxj_DirectSoundPrimaryBuffer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSoundPrimaryBuffer )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundsinkobj.h ===
#include "resource.h"       // main symbols
#include "dsound.h"

#define typedef__dxj_DirectSoundSink LPDIRECTSOUNDSINK8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundSinkObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundSink, &IID_I_dxj_DirectSoundSink, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundSink,
#endif

	public CComObjectRoot
{

public:
	C_dxj_DirectSoundSinkObject() ;
	virtual ~C_dxj_DirectSoundSinkObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundSinkObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundSink)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundSinkObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundSink
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE AddSource(I_dxj_DirectSoundSource __RPC_FAR *Source); 

		HRESULT STDMETHODCALLTYPE RemoveSource(I_dxj_DirectSoundSource __RPC_FAR *Source); 

		HRESULT STDMETHODCALLTYPE SetMasterClock(I_dxj_ReferenceClock __RPC_FAR *MasterClock);

		HRESULT STDMETHODCALLTYPE GetSoundBuffer(long lBuffer, I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *SoundBuffer);

		HRESULT STDMETHODCALLTYPE GetBusIDs(SAFEARRAY **lBusIDs);

		HRESULT STDMETHODCALLTYPE GetSoundBufferBusIDs(I_dxj_DirectSoundBuffer __RPC_FAR *buffer, SAFEARRAY **lBusIDs);

		HRESULT STDMETHODCALLTYPE GetLatencyClock(
			/* [in,out] */ I_dxj_ReferenceClock __RPC_FAR *__RPC_FAR *Clock);

		HRESULT STDMETHODCALLTYPE Activate(
			/* [in] */ long fEnable);

		HRESULT STDMETHODCALLTYPE CreateSoundBuffer(
			/* [in] */ DSBUFFERDESC_CDESC __RPC_FAR *BufferDesc, 
			/* [in] */ long lBusID,
			/* [out,retval] */ I_dxj_DirectSoundBuffer __RPC_FAR **Buffer);

		HRESULT STDMETHODCALLTYPE CreateSoundBufferFromFile(
			/* [in] */ BSTR fileName,
			/* [in] */ DSBUFFERDESC_CDESC __RPC_FAR *BufferDesc, 
			/* [in] */ long lBusID,
			/* [out,retval] */ I_dxj_DirectSoundBuffer __RPC_FAR **Buffer);

		HRESULT STDMETHODCALLTYPE GetBusCount(
			/* [out,retval] */ long *lCount); 

		HRESULT STDMETHODCALLTYPE PlayWave(
			/* [in] */ long rt, 
			/* [in] */ I_dxj_DirectSoundWave __RPC_FAR *Wave, 
			/* [in] */ long lFlags);

	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundSink);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundSink);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundprimarybufferobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundPrimaryBufferobj.cpp
//
//--------------------------------------------------------------------------

// dSoundPrimaryBufferObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"

#include "dms.h"
#include "dSoundPrimaryBufferObj.h"
#include "dSoundObj.h"
#include "dSound3DListener.h"

#define SAFE_DELETE(p) { free(p); p = NULL; }

extern HRESULT AudioBSTRtoGUID(LPGUID,BSTR);
extern void *g_dxj_DirectSoundPrimaryBuffer;

CONSTRUCTOR(_dxj_DirectSoundPrimaryBuffer, {});
DESTRUCTOR(_dxj_DirectSoundPrimaryBuffer, {});
GETSET_OBJECT(_dxj_DirectSoundPrimaryBuffer);

	PASS_THROUGH1_R(_dxj_DirectSoundPrimaryBuffer, getVolume, GetVolume, long*);
	PASS_THROUGH1_R(_dxj_DirectSoundPrimaryBuffer, getPan, GetPan, long*);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundPrimaryBuffer, getStatus, GetStatus, long*,(DWORD*));

	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundPrimaryBuffer, setFormat, SetFormat, WAVEFORMATEX_CDESC*, (LPWAVEFORMATEX));
	PASS_THROUGH1_R(_dxj_DirectSoundPrimaryBuffer, setPan, SetPan, LONG);
	PASS_THROUGH_R(_dxj_DirectSoundPrimaryBuffer, stop, Stop);
	PASS_THROUGH_R(_dxj_DirectSoundPrimaryBuffer, restore, Restore);


STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::setVolume(LONG vol)
{

	return m__dxj_DirectSoundPrimaryBuffer->SetVolume(vol); 
}

STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::getDirectSound3dListener(I_dxj_DirectSound3dListener **retval)
{
    IDirectSound3DListener *lp3dl;
    HRESULT hr = S_OK;

    if((hr=m__dxj_DirectSoundPrimaryBuffer->QueryInterface(IID_IDirectSound3DListener, (void**) &lp3dl)) != S_OK)
		return hr;

	INTERNAL_CREATE(_dxj_DirectSound3dListener, lp3dl, retval);

	return hr;
}

STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::getCaps(DSBCAPS_CDESC* caps)
{
	if(!caps)
		return E_POINTER;

	caps->lSize = sizeof(DSBCAPS);
	return m__dxj_DirectSoundPrimaryBuffer->GetCaps((LPDSBCAPS)caps); 
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::getCurrentPosition(DSCURSORS_CDESC *desc) 
{ 
   if(!desc) return E_POINTER;

  return (m__dxj_DirectSoundPrimaryBuffer->GetCurrentPosition((DWORD*)&desc->lPlay, (DWORD*)&desc->lWrite) ); 
}

/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own PrimaryBuffer
//which is passed into WritePrimaryBuffer(). Because the environment is now double
//PrimaryBuffered there is no need to Lock Java memory. WritePrimaryBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::writeBuffer(long start, long totsz, 
					void  *buf,  long flags) 
{ 
	#pragma message ("SoundPrimaryBuffer writePrimaryBuffer ")

	byte *PrimaryBuffer=(byte*)buf; //(byte*)((SAFEARRAY*)*ppsa)->pvData;

	if(!PrimaryBuffer)
		return E_POINTER;

	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;

	__try {
		if ((val = m__dxj_DirectSoundPrimaryBuffer->Lock((DWORD)start, (DWORD)totsz,
			 &p1, &size1, &p2, &size2,
			(DWORD)flags)) != DS_OK)
			return val;

		// Copy to buffer end, then do a wrapped portion if it exists, then unlock
		DPF1(1,"----- DXVB: DSoundPrimaryBuffer (WriteBuffer) about to copy to buffer (size1 = %d )\n",size1);
		if (p1)	
		{
			DPF1(1,"----- DXVB: DSoundPrimaryBuffer (WriteBuffer) about to copy to buffer (size1 = %d )\n",size1);
			memcpy (p1, PrimaryBuffer, size1);
		}

		if (p2)	 //There was wrapping
		{
			DPF1(1,"----- DXVB: DSoundPrimaryBuffer (WriteBuffer) about to copy to buffer (size2 = %d )\n",size2);
			memcpy(p2, &PrimaryBuffer[size1], size2);
		}

		//docdoc: because Lock and Unlock are tied together within WriteBuffer,
		//        DSBufferDesc no longer needs to save Lock's system pointers.
		DPF(1,"----- DXVB: DSoundPrimaryBuffer (WriteBuffer) Unlocking buffer.\n");
		val=m__dxj_DirectSoundPrimaryBuffer->Unlock(p1, size1, p2, size2);
	}
	__except(0,0){
		return E_FAIL;
	}
	return val;
}


/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own PrimaryBuffer
//which is passed into WritePrimaryBuffer(). Because the environment is now double
//PrimaryBuffered there is no need to Lock Java memory. WritePrimaryBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::readBuffer(long start, long totsz,
	void  *buf,  long flags) 
{ 

	byte *PrimaryBuffer=(byte*)buf;

	if(!PrimaryBuffer)
		return E_POINTER;
	
	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;
	
   __try {
	if ((val = m__dxj_DirectSoundPrimaryBuffer->Lock((DWORD)start, (DWORD)totsz, &p1, &size1, &p2, &size2, 
															(DWORD)flags)) != DS_OK)
		return val;

	// Copy to buffer end, then do a wrapped portion if it exists, then unlock
	if (p1)	
	{
		DPF1(1,"----- DXVB: DSoundPrimaryBuffer (ReadBuffer) about to copy to buffer (size1 = %d )\n",size1);
		memcpy (PrimaryBuffer,p1,  size1);
	}

	if (p2)	 //There was wrapping
	{
		DPF1(1,"----- DXVB: DSoundPrimaryBuffer (ReadBuffer) about to copy to buffer (size2 = %d )\n",size2);
		memcpy(&PrimaryBuffer[size1],p2,  size2);
	}

	//docdoc: because Lock and Unlock are tied together within WriteBuffer,
	//        DSBufferDesc no longer needs to save Lock's system pointers.
	DPF(1,"----- DXVB: DSoundPrimaryBuffer (ReadBuffer) Unlocking buffer.\n");
	val= m__dxj_DirectSoundPrimaryBuffer->Unlock(p1, size1, p2, size2);
   }
   __except(1,1){
	return E_FAIL;
   }
   return val;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::getFormat(WAVEFORMATEX_CDESC *format) 
{ 
	DWORD *wsize=0;	// docdoc: throw away returned written size

	HRESULT hr=DS_OK;
	hr=m__dxj_DirectSoundPrimaryBuffer->GetFormat((LPWAVEFORMATEX)format, (DWORD)sizeof(WAVEFORMATEX_CDESC), wsize);
			
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::initialize(I_dxj_DirectSound *ds,
		 DSBUFFERDESC_CDESC *buf, unsigned char *wave) 
{
	if(! (ds && buf && wave) )
		return E_POINTER;


	LPDSBUFFERDESC lpds = NULL;
	lpds = (LPDSBUFFERDESC)malloc(sizeof(DSBUFFERDESC));
	if (!lpds)
		return E_OUTOFMEMORY;

	ZeroMemory(lpds, sizeof(DSBUFFERDESC));

	lpds->dwSize = sizeof(DSBUFFERDESC);
	lpds->dwFlags = buf->lFlags;
	lpds->dwBufferBytes = buf->lBufferBytes;
	lpds->dwReserved = buf->lReserved;
#ifdef _WIN64
	lpds->lpwfxFormat = (WAVEFORMATEX*)wave;
#else
	lpds->lpwfxFormat = (WAVEFORMATEX*)PtrToLong(wave);
#endif
	AudioBSTRtoGUID(&lpds->guid3DAlgorithm, buf->guid3DAlgorithm);

	DO_GETOBJECT_NOTNULL(LPDIRECTSOUND, lpdsound, ds)

	m__dxj_DirectSoundPrimaryBuffer->Initialize(lpdsound, (LPDSBUFFERDESC)lpds);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::play(long flags) 
{
	HRESULT hr=DS_OK;
	if((hr=m__dxj_DirectSoundPrimaryBuffer->Play(0, 0, (DWORD)flags)) != DS_OK)
		return hr;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundsourceobj.h ===
#include "resource.h"       // main symbols
#include "dsound.h"

#define typedef__dxj_DirectSoundSource LPDIRECTSOUNDSOURCE

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundSource : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundSource, &IID_I_dxj_DirectSoundSource, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundSource,
#endif

	public CComObjectRoot
{

public:
	C_dxj_DirectSoundSource() ;
	virtual ~C_dxj_DirectSoundSource() ;

BEGIN_COM_MAP(C_dxj_DirectSoundSource)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundSource)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundSource)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundSource
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

			HRESULT STDMETHODCALLTYPE GetFormat(
			/* [in] */ WAVEFORMATEX_CDESC __RPC_FAR *WaveFormatEx);

			HRESULT STDMETHODCALLTYPE SetSink(
			/* [in] */ I_dxj_DirectSoundSink __RPC_FAR *SoundSink);

			HRESULT STDMETHODCALLTYPE Seek(long lPosition);

			HRESULT STDMETHODCALLTYPE Read(I_dxj_DirectSoundBuffer *Buffers[], long *busIDs, long lBusCount);

			HRESULT STDMETHODCALLTYPE GetSize(long *ret);

	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundSource);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundSource);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundsourceobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dsoundsourceobj.h"

extern void *g_dxj_DirectSoundSource;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundSource::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundSource [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundSource::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundSource [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundSource
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundSource::C_dxj_DirectSoundSource(){ 
		
	DPF1(1,"Constructor Creation DirectSoundSource Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundSource = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundSource;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundSource = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundSource
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundSource::~C_dxj_DirectSoundSource()
{

	DPF(1,"Entering ~C_dxj_DirectSoundSource destructor \n");

     C_dxj_DirectSoundSource *prev=NULL; 
	for(C_dxj_DirectSoundSource *ptr=(C_dxj_DirectSoundSource*)g_dxj_DirectSoundSource ; ptr; ptr=(C_dxj_DirectSoundSource *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundSource = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundSource found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundSource){
		int count = IUNK(m__dxj_DirectSoundSource)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundSource Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundSource = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();
	
}

HRESULT C_dxj_DirectSoundSource::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundSource;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundSource::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundSource=(LPDIRECTSOUNDSOURCE)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundSource::GetFormat(WAVEFORMATEX_CDESC *WaveFormatEx)
{

	HRESULT hr;
	DWORD dwSize;

	WAVEFORMATEX *fxFormat = (WAVEFORMATEX*)WaveFormatEx;

	fxFormat->cbSize = sizeof(WAVEFORMATEX);

	dwSize = sizeof(WAVEFORMATEX);

	if ( FAILED ( hr = m__dxj_DirectSoundSource->GetFormat(fxFormat, &dwSize) ) )
		return hr;

	//WaveFormatEx = (WAVEFORMATEX_CDESC)*fxFormat;
	return S_OK;
}


HRESULT C_dxj_DirectSoundSource::SetSink(I_dxj_DirectSoundSink *SoundSink)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL( LPDIRECTSOUNDSINK8, lpDSoundSink, SoundSink);

	if ( FAILED ( hr = m__dxj_DirectSoundSource->SetSink(lpDSoundSink) ) )
		return hr;
	return S_OK;
}

HRESULT C_dxj_DirectSoundSource::Seek(long lPosition)
{
	HRESULT hr;

	if ( FAILED ( hr = m__dxj_DirectSoundSource->Seek(lPosition) ) )
		return hr;
	return S_OK;
}

HRESULT C_dxj_DirectSoundSource::Read(I_dxj_DirectSoundBuffer *Buffers[], long *busIDs, long lBusCount)
{
	HRESULT hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundSource::GetSize(long *ret)
{
	HRESULT hr;

	if ( FAILED ( hr = m__dxj_DirectSoundSource->GetSize((ULONGLONG*)ret) ) )
		return hr;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundsinkobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundSinkObj.h"
#include "dSoundBufferObj.h"

extern void *g_dxj_DirectSoundSink;
extern HRESULT InternalCreateSoundBufferFromFileSink(LPDIRECTSOUNDSINK8 lpDirectSound,LPDSBUFFERDESC pDesc,WCHAR *file,LPDIRECTSOUNDBUFFER *lplpDirectSoundBuffer, DWORD dwBusID) ;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundSinkObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundSink [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundSinkObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundSink [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundSinkObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundSinkObject::C_dxj_DirectSoundSinkObject(){ 
		
	DPF1(1,"Constructor Creation DirectSoundSink Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundSink = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundSink;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundSink = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundSinkObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundSinkObject::~C_dxj_DirectSoundSinkObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundSinkObject destructor \n");

     C_dxj_DirectSoundSinkObject *prev=NULL; 
	for(C_dxj_DirectSoundSinkObject *ptr=(C_dxj_DirectSoundSinkObject*)g_dxj_DirectSoundSink ; ptr; ptr=(C_dxj_DirectSoundSinkObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundSink = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundSink found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundSink){
		int count = IUNK(m__dxj_DirectSoundSink)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundSink Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundSink = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();
	
}

HRESULT C_dxj_DirectSoundSinkObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundSink;
	
	return S_OK;
}

HRESULT C_dxj_DirectSoundSinkObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundSink=(LPDIRECTSOUNDSINK)pUnk;
	return S_OK;
}


HRESULT C_dxj_DirectSoundSinkObject::Activate(long fEnable){
	HRESULT hr;

	if ( FAILED ( hr = m__dxj_DirectSoundSink->Activate(fEnable) ) )
		return hr;

	return S_OK;
}


HRESULT C_dxj_DirectSoundSinkObject::CreateSoundBuffer(DSBUFFERDESC_CDESC *BufferDesc, 
	long lBusID, I_dxj_DirectSoundBuffer **Buffer){

	LPDIRECTSOUNDBUFFER			dsb;	// Need to get the buffer first

	BufferDesc->lSize = sizeof(DSBUFFERDESC);
	
	LPDSBUFFERDESC lpds ;
	lpds = (LPDSBUFFERDESC)&BufferDesc;
	HRESULT hr=S_OK;
	hr = m__dxj_DirectSoundSink->CreateSoundBuffer(lpds, (DWORD*)&lBusID, (DWORD)lBusID, &dsb );
 
	if SUCCEEDED(hr)
		INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, Buffer );

	return S_OK;
}


HRESULT C_dxj_DirectSoundSinkObject::CreateSoundBufferFromFile(BSTR fileName,
	DSBUFFERDESC_CDESC *BufferDesc, 
	long lBusID, I_dxj_DirectSoundBuffer **Buffer){

	LPDIRECTSOUNDBUFFER		dsb;	
	LPDSBUFFERDESC			lpds ;
	HRESULT					hr=S_OK;

		
	*Buffer=NULL;	
	BufferDesc->lSize = sizeof(DSBUFFERDESC);
	lpds = (LPDSBUFFERDESC)&BufferDesc;
	
	hr=InternalCreateSoundBufferFromFileSink(m__dxj_DirectSoundSink,(LPDSBUFFERDESC)&BufferDesc,
			(WCHAR*)fileName,&dsb, (DWORD) lBusID); 

	if SUCCEEDED(hr)
		INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, Buffer);
	return S_OK;
}


HRESULT C_dxj_DirectSoundSinkObject::GetBusCount(long *lCount){
	
	HRESULT hr;

	if ( FAILED ( hr = m__dxj_DirectSoundSink->GetBusCount((DWORD*)lCount) ) )
		return hr;
	
	return S_OK;
}


HRESULT C_dxj_DirectSoundSinkObject::PlayWave(long rt, 
									I_dxj_DirectSoundWave *Wave, 
									long lFlags)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL( LPDIRECTSOUNDWAVE8, lpDSoundWave, Wave);

	if ( FAILED ( hr = m__dxj_DirectSoundSink->PlayWave((REFERENCE_TIME) rt, lpDSoundWave, (DWORD)lFlags) ) )
		return hr;

	return S_OK;
}
HRESULT C_dxj_DirectSoundSinkObject::GetLatencyClock(I_dxj_ReferenceClock **Clock)
{
	return S_OK;
}
HRESULT C_dxj_DirectSoundSinkObject::AddSource(I_dxj_DirectSoundSource *Source)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL( LPDIRECTSOUNDSOURCE8, lpDSoundSource, Source);

	if (FAILED ( hr = m__dxj_DirectSoundSink->AddSource(lpDSoundSource) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundSinkObject::RemoveSource(I_dxj_DirectSoundSource *Source)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL( LPDIRECTSOUNDSOURCE8, lpDSoundSource, Source);

	if (FAILED ( hr = m__dxj_DirectSoundSink->RemoveSource(lpDSoundSource) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundSinkObject::SetMasterClock(I_dxj_ReferenceClock *MasterClock)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL( IReferenceClock*, lpRefClock, MasterClock);

	if (FAILED ( hr = m__dxj_DirectSoundSink->SetMasterClock(lpRefClock) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundSinkObject::GetSoundBuffer(long lBuffer, I_dxj_DirectSoundBuffer **SoundBuffer)
{
	return S_OK;
}

	
HRESULT C_dxj_DirectSoundSinkObject::GetBusIDs(SAFEARRAY **lBusIDs)
{
	return S_OK;
}

HRESULT C_dxj_DirectSoundSinkObject::GetSoundBufferBusIDs(I_dxj_DirectSoundBuffer *buffer, SAFEARRAY **lBusIDs)
{
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundwaveobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundWaveObj.h"
#include "dmdls.h"

extern void *g_dxj_DirectSoundWave;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundWaveObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundWave [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundWaveObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundWave [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundWaveObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundWaveObject::C_dxj_DirectSoundWaveObject(){ 
		
	DPF1(1,"Constructor Creation DirectSoundWave Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundWave = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundWave;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundWave = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundWaveObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundWaveObject::~C_dxj_DirectSoundWaveObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundWaveObject destructor \n");

     C_dxj_DirectSoundWaveObject *prev=NULL; 
	for(C_dxj_DirectSoundWaveObject *ptr=(C_dxj_DirectSoundWaveObject*)g_dxj_DirectSoundWave ; ptr; ptr=(C_dxj_DirectSoundWaveObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundWave = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundWave found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundWave){
		int count = IUNK(m__dxj_DirectSoundWave)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundWave Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundWave = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();
	
}

HRESULT C_dxj_DirectSoundWaveObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundWave;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundWaveObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundWave=(LPDIRECTSOUNDWAVE)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundWaveObject::GetWaveArticulation(DMUS_WAVEART_CDESC *Articulation)
{
	HRESULT hr;

	DMUS_WAVEART *wavart = NULL;

	wavart = (DMUS_WAVEART*)malloc(sizeof(DMUS_WAVEART));
	ZeroMemory(wavart, sizeof(DMUS_WAVEART));

	if (FAILED (hr = m__dxj_DirectSoundWave->GetWaveArticulation(wavart) ) )
		return hr;
	
	Articulation = (DMUS_WAVEART_CDESC*)wavart;
	return S_OK;
}
HRESULT C_dxj_DirectSoundWaveObject::CreateSource(WAVEFORMATEX_CDESC format, long lFlags, I_dxj_DirectSoundSource **Source)
{
	HRESULT hr;

	return S_OK;
}
			
HRESULT C_dxj_DirectSoundWaveObject::GetFormat(WAVEFORMATEX_CDESC *format, long lFlags)        
{
	HRESULT hr;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dsoundwaveobj.h ===
#include "resource.h"       // main symbols
#include "dsound.h"

#define typedef__dxj_DirectSoundWave LPDIRECTSOUNDWAVE

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundWaveObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundWave, &IID_I_dxj_DirectSoundWave, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundWave,
#endif

	public CComObjectRoot
{

public:
	C_dxj_DirectSoundWaveObject() ;
	virtual ~C_dxj_DirectSoundWaveObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundWaveObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundWave)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundWaveObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundWave
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

			HRESULT STDMETHODCALLTYPE GetWaveArticulation(DMUS_WAVEART_CDESC *Articulation);             
			
			HRESULT STDMETHODCALLTYPE CreateSource(WAVEFORMATEX_CDESC format, long lFlags, I_dxj_DirectSoundSource **Source); 
			
			HRESULT STDMETHODCALLTYPE GetFormat(WAVEFORMATEX_CDESC *format, long lFlags);                                           

	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundWave);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundWave);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\frmsave.h ===
//**************************************************************************
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999 All Rights Reserved.
//
//  File:   frmsave.h
//
//  Description:    Save LPDIRECT3DRMFRAME to an x file.
//
//  History:
//      011/06/98    CongpaY     Created
//
//**************************************************************************

typedef struct _Header {
    WORD major;
    WORD minor;
    DWORD flags;
} Header;

typedef struct _ColorRGBA {
    float r;
    float g;
    float b;
    float a;
} ColorRGBA;

typedef struct _ColorRGB {
    float r;
    float g;
    float b;
} ColorRGB;

typedef struct _IndexedColor {
    DWORD index;
    ColorRGBA color;
} IndexedColor;

typedef struct _VertexColors {
    DWORD cVertices;
    IndexedColor vertexColors[1];
} VertexColors;

typedef struct _Boolean2d {
    BOOL u;
    BOOL v;
} Boolean2d;

typedef struct _FaceWraps {
    DWORD cFaces;
    Boolean2d faceWraps[1];
} FaceWraps;

typedef struct _Coords2d {
    float u;
    float v;
} Coords2d;

typedef struct _TextureCoords {
    DWORD cVertices;
    Coords2d textureCoords[1];
} TextureCoords;

typedef struct _FaceMaterials {
    DWORD cMaterials;
    DWORD cFaceIndexes;
    DWORD faceIndexes[1];
} FaceMaterials;

typedef struct _BaseMaterial {
    ColorRGBA faceColor;
    float power;
    ColorRGB specularColor;
    ColorRGB emissiveColor;
} BaseMaterial;

typedef struct _FaceMaterial {
    D3DCOLOR faceColor;
    LPDIRECT3DRMMATERIAL pMaterial;
    LPDIRECT3DRMTEXTURE pTexture;
    _FaceMaterial *pNext;
} FaceMaterial;

typedef void (__stdcall *CREATEXFILE)( IDirectXFile **);

class FaceMaterialList
{
    DWORD cElements;
    FaceMaterial *pFirst;	

public:
    FaceMaterialList();
    ~FaceMaterialList();

    DWORD Find(D3DCOLOR faceColor,
               LPDIRECT3DRMMATERIAL pMaterial,
               LPDIRECT3DRMTEXTURE pTexture);

    DWORD Count() { return cElements; }
    FaceMaterial *First() { return pFirst; }
};

class NameEntry {
public:
    LPSTR pName;
    NameEntry *pNext;
};

class NameList
{
    NameEntry *pFirst;
    NameEntry **ppLast;
public:
    NameList();
    ~NameList();
    void Add(LPSTR pName);
};

class Saver {
public:
    Saver();
    ~Saver();

    HRESULT Init(LPCSTR filename,
                 D3DRMXOFFORMAT d3dFormat,
                 D3DRMSAVEOPTIONS d3dSaveFlags);

    HRESULT SaveHeaderObject();
    
    HRESULT SaveFrame(LPDIRECT3DRMFRAME3 pFrame,
                      LPDIRECT3DRMFRAME3 pRefFrame = NULL,
                      LPDIRECTXFILEDATA  pRefFrameObj = NULL);
private:	
    LPDIRECTXFILE pXFile;
    LPDIRECTXFILESAVEOBJECT pSave;
    D3DRMXOFFORMAT d3dFormat;
    D3DRMSAVEOPTIONS d3dSaveFlags;
    NameList lNames;

    HRESULT SaveFrameTransform(LPDIRECTXFILEDATA pFrameObj,
                               LPDIRECT3DRMFRAME3 pFrame,
                               LPDIRECT3DRMFRAME3 pRefFrame);
    
    HRESULT SaveMeshBuilder(LPDIRECTXFILEDATA pFrameObj,
                            LPDIRECT3DRMMESHBUILDER3 pMeshBuilder);
    
    HRESULT CreateMeshObject(DWORD cVertices,
                             DWORD cFaces,
                             DWORD dwFaceData,
                             LPDWORD pdwFaceData,
                             LPDIRECT3DRMMESHBUILDER3 pMeshBuilder,
                             LPDIRECTXFILEDATA *ppMeshObj);
    
    HRESULT CreateNormalsObject(LPDIRECTXFILEDATA pMeshObj,
                                DWORD cNormals,
                                DWORD cFaces,
                                DWORD dwFaceData,
                                LPDWORD pdwFaceData,
                                LPDIRECT3DRMMESHBUILDER3 pMeshBuilder);
    
    HRESULT CreateVertexColorsObject(LPDIRECTXFILEDATA pMeshObj,
                                     DWORD cVertices,
                                     LPDIRECT3DRMMESHBUILDER3 pMeshBuilder);
    
    HRESULT CreateMaterialListObject(LPDIRECTXFILEDATA pMeshObj,
                                     LPDIRECT3DRMFACEARRAY pFaceArray);
    
    HRESULT CreateMaterialObject(LPDIRECTXFILEDATA pMatListObj,
                                 FaceMaterial *pMat);
    
    HRESULT CreateTextureWrapsObject(LPDIRECTXFILEDATA pMeshObj,
                                     LPDIRECT3DRMFACEARRAY pFaceArray);
    
    HRESULT CreateTextureCoordsObject(LPDIRECTXFILEDATA pMeshObj,
                                      DWORD cVertices,
                                      LPDIRECT3DRMMESHBUILDER3 pMeshBuilder);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dxerr8.h ===
/*==========================================================================;
 *
 *
 *  File:   dxerr8.h
 *  Content:    DirectX Error Library Include File
 *
 ****************************************************************************/

#ifndef _DXERR8_H_
#define _DXERR8_H_


//
//  DXGetErrorString8
//  
//  Desc:  Converts an DirectX HRESULT to a string 
//
//  Args:  HRESULT hr   Can be any error code from
//                      DPLAY D3D8 D3DX8 DMUSIC DSOUND
//
//  Return: Converted string 
//
const char*  __stdcall DXGetErrorString8A(HRESULT hr);
const WCHAR* __stdcall DXGetErrorString8W(HRESULT hr);

#ifdef UNICODE
    #define DXGetErrorString8 DXGetErrorString8W
#else
    #define DXGetErrorString8 DXGetErrorString8A
#endif 


//
//  DXTrace
//
//  Desc:  Outputs a formatted error message to the debug stream
//
//  Args:  CHAR* strFile   The current file, typically passed in using the 
//                         __FILE__ macro.
//         DWORD dwLine    The current line number, typically passed in using the 
//                         __LINE__ macro.
//         HRESULT hr      An HRESULT that will be traced to the debug stream.
//         CHAR* strMsg    A string that will be traced to the debug stream (may be NULL)
//         BOOL bPopMsgBox If TRUE, then a message box will popup also containing the passed info.
//
//  Return: The hr that was passed in.  
//
HRESULT __stdcall DXTraceA( char* strFile, DWORD dwLine, HRESULT hr, char* strMsg, BOOL bPopMsgBox = FALSE );
HRESULT __stdcall DXTraceW( char* strFile, DWORD dwLine, HRESULT hr, WCHAR* strMsg, BOOL bPopMsgBox = FALSE );

#ifdef UNICODE
    #define DXTrace DXTraceW
#else
    #define DXTrace DXTraceA
#endif 


//
// Helper macros
//
#if defined(DEBUG) | defined(_DEBUG)
    #define DXTRACE_MSG(str)              DXTrace( __FILE__, (DWORD)__LINE__, 0, str, FALSE )
    #define DXTRACE_ERR(str,hr)           DXTrace( __FILE__, (DWORD)__LINE__, hr, str, TRUE )
    #define DXTRACE_ERR_NOMSGBOX(str,hr)  DXTrace( __FILE__, (DWORD)__LINE__, hr, str, FALSE )
#else
    #define DXTRACE_MSG(str)              (0L)
    #define DXTRACE_ERR(str,hr)           (hr)
    #define DXTRACE_ERR_NOMSGBOX(str,hr)  (hr)
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dxglob7obj.h ===
//+-------------------------------------------------------------------------
    //
    //  Microsoft Windows
    //
    //  Copyright (C) Microsoft Corporation, 1998 - 1999
    //
    //  File:       dxglob7obj.h
    //
    //--------------------------------------------------------------------------
    
    
    #include "resource.h"       // main symbols
    
    
    typedef HRESULT (__stdcall *DSOUNDCREATE)(GUID FAR * lpGUID, LPDIRECTSOUND8 * ppDS, IUnknown FAR *pUnkOuter );
    typedef HRESULT (__stdcall *DSOUNDCAPTURECREATE)(GUID FAR * lpGUID, LPDIRECTSOUNDCAPTURE * ppDS, IUnknown FAR *pUnkOuter );
    typedef HRESULT (CALLBACK *DSOUNDENUMERATE)(LPDSENUMCALLBACK lpCallback, LPVOID lpContext );
    typedef HRESULT (CALLBACK *DSOUNDCAPTUREENUMERATE)(LPDSENUMCALLBACK lpCallback, LPVOID lpContext );
    typedef LPDIRECT3DDEVICE8 (__stdcall *D3DCREATE8)(DWORD ver);

    
    typedef struct tag_EVENTTHREADINFO {
    	HANDLE hEvent;
    	struct tag_EVENTTHREADINFO *pNext;
    	IStream *pStream;
    	I_dxj_DirectXEvent8 *pCallback;
    	DWORD threadID;
    	HANDLE hThread;
    	BOOL	fEnd;
    	HANDLE  hEndEvent;
    } EVENTTHREADINFO;
    
    
    class C_dxj_DirectX7Object :
    	public I_dxj_DirectX8,
    	public CComCoClass<C_dxj_DirectX7Object, &CLSID__dxj_DirectX8>, public CComObjectRoot
    {
    public:
    	C_dxj_DirectX7Object() ;
    	virtual ~C_dxj_DirectX7Object() ;
    
    BEGIN_COM_MAP(C_dxj_DirectX7Object)
    	COM_INTERFACE_ENTRY(I_dxj_DirectX8)
    END_COM_MAP()
    
    	DECLARE_REGISTRY(CLSID__dxj_DirectX8,	"DIRECT.DirectX8.0",		"DIRECT.DirectX8.0",	IDS_DIRECTX8_DESC, THREADFLAGS_BOTH)
    
    // Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundResourceObject) if you don't want your object
    // to support aggregation
    DECLARE_AGGREGATABLE(C_dxj_DirectX7Object)
    
    
    public:
    
            
            HRESULT STDMETHODCALLTYPE directSoundCreate( 
                /* [in] */ BSTR guid,
                /* [retval][out] */ I_dxj_DirectSound __RPC_FAR *__RPC_FAR *ret);
            
            HRESULT STDMETHODCALLTYPE directSoundCaptureCreate( 
                /* [in] */ BSTR guid,
                /* [retval][out] */ I_dxj_DirectSoundCapture __RPC_FAR *__RPC_FAR *ret);
            
            HRESULT STDMETHODCALLTYPE getDSEnum( 
                /* [retval][out] */ I_dxj_DSEnum __RPC_FAR *__RPC_FAR *retVal);
            
            HRESULT STDMETHODCALLTYPE getDSCaptureEnum( 
                /* [retval][out] */ I_dxj_DSEnum __RPC_FAR *__RPC_FAR *retVal);
            
            HRESULT STDMETHODCALLTYPE directInputCreate( 
                /* [retval][out] */ I_dxj_DirectInput8 __RPC_FAR *__RPC_FAR *ret);
            
           HRESULT STDMETHODCALLTYPE DirectPlayVoiceClientCreate( 
               /* [retval][out] */ I_dxj_DirectPlayVoiceClient __RPC_FAR *__RPC_FAR *ret);
   
           HRESULT STDMETHODCALLTYPE DirectPlayVoiceServerCreate( 
               /* [retval][out] */ I_dxj_DirectPlayVoiceServer __RPC_FAR *__RPC_FAR *ret);
   
   		HRESULT STDMETHODCALLTYPE DirectPlayVoiceTestCreate( 
               /* [retval][out] */ I_dxj_DirectPlayVoiceSetup __RPC_FAR *__RPC_FAR *ret);
   
          
            HRESULT STDMETHODCALLTYPE directMusicLoaderCreate( 
                /* [retval][out] */ I_dxj_DirectMusicLoader __RPC_FAR *__RPC_FAR *ret);
            
            HRESULT STDMETHODCALLTYPE directMusicComposerCreate( 
                /* [retval][out] */ I_dxj_DirectMusicComposer __RPC_FAR *__RPC_FAR *ret);
            
            HRESULT STDMETHODCALLTYPE directMusicPerformanceCreate( 
                /* [retval][out] */ I_dxj_DirectMusicPerformance __RPC_FAR *__RPC_FAR *ret);
    			
        
            
#ifdef _WIN64
			HRESULT STDMETHODCALLTYPE createEvent( 
                /* [in] */ I_dxj_DirectXEvent8 __RPC_FAR *event,
                /* [retval][out] */ HANDLE __RPC_FAR *h) ;
            
            HRESULT STDMETHODCALLTYPE setEvent( 
                /* [in] */ HANDLE eventId) ;
            
            HRESULT STDMETHODCALLTYPE destroyEvent( 
                /* [in] */ HANDLE eventId) ;
#else
			HRESULT STDMETHODCALLTYPE createEvent( 
                /* [in] */ I_dxj_DirectXEvent8 __RPC_FAR *event,
                /* [retval][out] */ LONG __RPC_FAR *h) ;
            
            HRESULT STDMETHODCALLTYPE setEvent( 
                /* [in] */ LONG eventId) ;
            
            HRESULT STDMETHODCALLTYPE destroyEvent( 
                /* [in] */ LONG eventId) ;
#endif
    
          
 	    HRESULT STDMETHODCALLTYPE createNewGuid(BSTR *ret);

	    HRESULT STDMETHODCALLTYPE DirectXFileCreate(I_dxj_DirectXFile **ret);
   
		HRESULT STDMETHODCALLTYPE DirectPlayPeerCreate(I_dxj_DirectPlayPeer **ret);

		HRESULT STDMETHODCALLTYPE DirectPlayServerCreate(I_dxj_DirectPlayServer **ret);

		HRESULT STDMETHODCALLTYPE DirectPlayClientCreate(I_dxj_DirectPlayClient **ret);
		
		HRESULT STDMETHODCALLTYPE DirectPlayAddressCreate(I_dxj_DirectPlayAddress **ret);
        
		HRESULT STDMETHODCALLTYPE Direct3DCreate(IUnknown **ppRet);

		HRESULT STDMETHODCALLTYPE DirectPlayLobbyClientCreate(I_dxj_DirectPlayLobbyClient **ret);
		
		HRESULT STDMETHODCALLTYPE DirectPlayLobbiedApplicationCreate(I_dxj_DirectPlayLobbiedApplication **ret);

	
            void LoadDSOUND();
            void LoadDINPUT();
            void LoadD3D8();
    
    private:
    
    	DSOUNDCREATE			m_pDirectSoundCreate;
    	DSOUNDCAPTURECREATE		m_pDirectSoundCaptureCreate;
    	DSOUNDENUMERATE			m_pDirectSoundEnumerate;
    	DSOUNDCAPTUREENUMERATE		m_pDirectSoundCaptureEnumerate;
    	D3DCREATE8   			m_pDirect3DCreate8;
    	EVENTTHREADINFO			*m_pEventList;
    
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dxglob7obj.cpp ===
//+-------------------------------------------------------------------------
    //
    //  Microsoft Windows
    //
    //  Copyright (C) Microsoft Corporation, 1998 - 1999
    //
    //  File:       dxglob7obj.cpp
    //
    //--------------------------------------------------------------------------
          
    
    #include "windows.h"
    #include "mmsystem.h"

	
    #include "stdafx.h"
    #include "d3d8.h"
    #include "d3dx8.h"
    #include "Direct.h"
    #include "dms.h"
    #include "math.h"
    
    #include "dxGlob7Obj.h"
    
    #include "dmusici.h"
    #include "dmusicf.h"
    #include "dvoice.h"
    #include "dxfile.h"
    
    #include "dsoundObj.h"
    #include "dsoundCaptureObj.h"
    #include "DSEnumObj.h"    
    
    #include "DPlayPeerObj.h"
    #include "DPlayServerObj.h"
    #include "DPlayClientObj.h"
    #include "DPlayLobbyClientObj.h"
    #include "DPlayLobbiedAppObj.h"
    #include "DPlayVoiceClientObj.h"
    #include "DPlayVoiceServerObj.h"
    #include "DPlayVoiceSetupObj.h"
    #include "DPlayAddressObj.h"
    
    #include "dinput1Obj.h"
    
    #include "dmSegmentObj.h"
    #include "dmSegmentStateObj.h"
    #include "dmChordMapObj.h"
    #include "dmBandObj.h"
    #include "dmCollectionObj.h"
    #include "dmStyleObj.h"
    #include "dmPerformanceObj.h"
    #include "dmLoaderObj.h"
    #include "dmComposerObj.h"

    #include "xfileobj.h"    
    #include "verinfo.h"

    extern HINSTANCE g_hDSoundHandle;
    extern HINSTANCE g_hDPlay;
    extern HINSTANCE g_hInstDINPUTDLL;
    extern HINSTANCE g_hInst;
    extern HINSTANCE g_hD3D8;
    
    extern HRESULT BSTRtoPPGUID(LPGUID*,BSTR);
    extern HRESULT BSTRtoGUID(LPGUID,BSTR);
    
    extern void *g_dxj_DirectMusic;
    extern void *g_dxj_DirectMusicLoader;
    extern void *g_dxj_DirectMusicComposer;
    extern void *g_dxj_DirectMusicPerformance;
    extern void *g_dxj_DirectPlay;
    extern void *g_dxj_DirectPlayPeer;
    extern void *g_dxj_DirectPlayLobbyClient;
    extern void *g_dxj_DirectPlayLobbiedApplication;
    extern void *g_dxj_DirectPlayServer;
    extern void *g_dxj_DirectPlayClient;
    extern void *g_dxj_DirectPlayAddress;
    
    extern BSTR GUIDtoBSTR(LPGUID);
    extern HRESULT DPLBSTRtoGUID(LPGUID pGuid,BSTR str);
    
    extern HINSTANCE LoadD3D8DLL();
    extern HINSTANCE LoadD3DXOFDLL();
    extern HINSTANCE LoadDPlayDLL();
    extern HINSTANCE LoadDSoundDLL();
    extern HINSTANCE LoadDINPUTDLL();
    
    DWORD WINAPI ThreadFunc(LPVOID param);
        
#ifndef DX_FINAL_RELEASE

// shut 'em down if they try to use the beta bits too long
HRESULT TimeBomb() 
{
    #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
    SYSTEMTIME st;
    GetSystemTime(&st);

    if ( st.wYear > DX_EXPIRE_YEAR ||
         ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH)))
    ) {
        MessageBox(0, DX_EXPIRE_TEXT,
                      TEXT("Microsoft DirectX For Visual Basic"), MB_OK);
        return S_OK;// let it work anyway.
    }
     return S_OK;   
} // TimeBomb

#endif
    
    C_dxj_DirectX7Object::C_dxj_DirectX7Object(){
            	
    
        m_pDirectSoundCreate=NULL;
        m_pDirectSoundEnumerate=NULL;
        m_pDirectSoundCaptureEnumerate=NULL;
    	m_pDirectSoundCaptureCreate=NULL;
	m_pDirect3DCreate8=NULL;
        m_pEventList=NULL;
    }
    
    void C_dxj_DirectX7Object::LoadDSOUND()
    {   
    	if (!g_hDSoundHandle )	LoadDSoundDLL();  
        if (!m_pDirectSoundCreate)              m_pDirectSoundCreate = (DSOUNDCREATE)GetProcAddress( g_hDSoundHandle, "DirectSoundCreate8" );
        if (!m_pDirectSoundCaptureCreate)       m_pDirectSoundCaptureCreate = (DSOUNDCAPTURECREATE)GetProcAddress( g_hDSoundHandle, "DirectSoundCaptureCreate" );
        if (!m_pDirectSoundEnumerate)           m_pDirectSoundEnumerate = (DSOUNDENUMERATE)GetProcAddress( g_hDSoundHandle, "DirectSoundEnumerateA" );
        if (!m_pDirectSoundCaptureEnumerate)    m_pDirectSoundCaptureEnumerate = (DSOUNDCAPTUREENUMERATE)GetProcAddress( g_hDSoundHandle, "DirectSoundCaptureEnumerateA" );
        
    }
    
    void C_dxj_DirectX7Object::LoadD3D8()
    {   
    	if (!g_hD3D8 )	LoadD3D8DLL();  
        if (!m_pDirect3DCreate8)             m_pDirect3DCreate8 = (D3DCREATE8)GetProcAddress( g_hD3D8, "Direct3DCreate8" );        
    }
    
    
    C_dxj_DirectX7Object::~C_dxj_DirectX7Object()
    {
        DWORD i=1;
    
        while (m_pEventList) {
    
#ifdef _WIN64
        destroyEvent((HANDLE)m_pEventList->hEvent);
#else
        destroyEvent((LONG)PtrToLong(m_pEventList->hEvent));
#endif
        }
    }
    
    
    
  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayVoiceClientCreate(I_dxj_DirectPlayVoiceClient **ret){
  
      HRESULT						hr;
      LPDIRECTPLAYVOICECLIENT		realvoice=NULL;
      DWORD						i=0;
  

  
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
      if( FAILED(hr = CoCreateInstance(CLSID_DirectPlayVoiceClient,NULL,
  						CLSCTX_INPROC_SERVER,
  						IID_IDirectPlayVoiceClient,
  						(LPVOID*) &realvoice)))
  		return hr;
  
      INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayVoiceClient,realvoice,ret);
      
      if (*ret==NULL) {
          i=realvoice->Release();
          return E_FAIL;
      }
  	return hr;
  }
  
  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayLobbyClientCreate(I_dxj_DirectPlayLobbyClient **ret) {
      HRESULT						hr;
      IDirectPlay8LobbyClient		*realLC=NULL;
  
  
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
	if( FAILED(hr = CoCreateInstance(CLSID_DirectPlay8LobbyClient,NULL,
  										CLSCTX_INPROC_SERVER,
  										IID_IDirectPlay8LobbyClient,
  										(void**) &realLC)))
  		return hr;
  
      INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayLobbyClient,realLC,ret);
      
      if (*ret==NULL) {
          realLC->Release();
          return E_FAIL;
      }
  	return hr;
  }

		
  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayLobbiedApplicationCreate(I_dxj_DirectPlayLobbiedApplication **ret) {
      HRESULT						hr;
      IDirectPlay8LobbiedApplication	*realLA=NULL;
  
  
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
	if( FAILED(hr = CoCreateInstance(CLSID_DirectPlay8LobbiedApplication,NULL,
  										CLSCTX_INPROC_SERVER,
  										IID_IDirectPlay8LobbiedApplication,
  										(void**) &realLA)))
  		return hr;
  
      INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayLobbiedApplication,realLA,ret);
      
      if (*ret==NULL) {
          realLA->Release();
          return E_FAIL;
      }
  	return hr;
  }

  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayVoiceServerCreate(I_dxj_DirectPlayVoiceServer **ret){
  
      HRESULT						hr;
      LPDIRECTPLAYVOICESERVER		realvoice=NULL;
      DWORD						i=0;
  
  
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
  	if( FAILED(hr = CoCreateInstance(CLSID_DirectPlayVoiceServer,NULL,
  										CLSCTX_INPROC_SERVER,
  										IID_IDirectPlayVoiceServer,
  										(LPVOID*) &realvoice)))
  		return hr;
  
      INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayVoiceServer,realvoice,ret);
      
      if (*ret==NULL) {
          i=realvoice->Release();
          return E_FAIL;
      }
  	return hr;
  }
  
  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayVoiceTestCreate(I_dxj_DirectPlayVoiceSetup **ret){
  
      HRESULT						hr;
      LPDIRECTPLAYVOICETEST		realsetup=NULL;
      DWORD						i=0;
  
  
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
  	if( FAILED(hr = CoCreateInstance(CLSID_DirectPlayVoiceTest,NULL,
  										CLSCTX_INPROC_SERVER,
  										IID_IDirectPlayVoiceTest,
  										(LPVOID*) &realsetup)))
  		return hr;
  
      INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayVoiceSetup,realsetup,ret);
      
      if (*ret==NULL) {
          i=realsetup->Release();
          return E_FAIL;
      }
  	return hr;
  }  	  	
    
  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayPeerCreate(I_dxj_DirectPlayPeer **ret)
  {
	HRESULT				hr;
	IDirectPlay8Peer	*lpDplayPeer = NULL;


#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
	if ( FAILED (hr = CoCreateInstance( CLSID_DirectPlay8Peer, NULL,CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8Peer, (LPVOID*) &lpDplayPeer ) ) )
				return hr;

	INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayPeer, lpDplayPeer, ret);

	if (*ret == NULL) 
	{
		lpDplayPeer->Release();
		return E_FAIL;
	}
	return hr;
  
  }
    
  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayServerCreate(I_dxj_DirectPlayServer **ret)
  {
	HRESULT					hr;
	IDirectPlay8Server		*lpDplayServer = NULL;

#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
	if ( FAILED (hr = CoCreateInstance( CLSID_DirectPlay8Server, NULL,CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8Server, (LPVOID*) &lpDplayServer ) ) )
				return hr;

	INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayServer, lpDplayServer, ret);

	if (*ret == NULL) 
	{
		lpDplayServer->Release();
		return E_FAIL;
	}
	return hr;
  
  }
    
  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayAddressCreate(I_dxj_DirectPlayAddress **ret)
  {
	HRESULT					hr;
	IDirectPlay8Address		*lpDplayAddress = NULL;


#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
	if ( FAILED (hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL,CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8Address, (LPVOID*) &lpDplayAddress ) ) )
				return hr;

	INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayAddress, lpDplayAddress, ret);

	if (*ret == NULL) 
	{
		lpDplayAddress->Release();
		return E_FAIL;
	}
	return hr;
  
  }

  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayClientCreate(I_dxj_DirectPlayClient **ret)
  {
	HRESULT					hr;
	IDirectPlay8Client		*lpDplayClient = NULL;


#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
	if ( FAILED (hr = CoCreateInstance( CLSID_DirectPlay8Client, NULL,CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8Client, (LPVOID*) &lpDplayClient ) ) )
				return hr;

	INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayClient, lpDplayClient, ret);

	if (*ret == NULL) 
	{
		lpDplayClient->Release();
		return E_FAIL;
	}
	return hr;
  
  }

  STDMETHODIMP C_dxj_DirectX7Object::directSoundCreate(BSTR  strGuid, I_dxj_DirectSound **ret){
        HRESULT			hr;
        LPDIRECTSOUND8		realsound8=NULL;
        GUID			guid;
        LPGUID			pguid=&guid;
    
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
        LoadDSOUND();
    
        hr=BSTRtoPPGUID(&pguid,strGuid);
        if FAILED(hr) return hr;
    
        if (!m_pDirectSoundCreate) return E_FAIL;
    
        hr=(m_pDirectSoundCreate)((GUID*)pguid,&realsound8,NULL);
        if FAILED(hr) return  hr;
      
        INTERNAL_CREATE(_dxj_DirectSound,realsound8,ret);
        
        if (*ret==NULL) {
            realsound8->Release();
            return E_FAIL;
        }
    
        return hr;		
    }
    
    
    STDMETHODIMP C_dxj_DirectX7Object::directSoundCaptureCreate(BSTR strGuid, I_dxj_DirectSoundCapture **ret){
        HRESULT		  hr;
        LPDIRECTSOUNDCAPTURE realsound1=NULL;
        LPDIRECTSOUNDCAPTURE8 realsound8=NULL;
        GUID			guid;
        LPGUID			pguid=&guid;
        hr=BSTRtoPPGUID(&pguid,strGuid);
        if FAILED(hr) return hr;
    
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
    	LoadDSOUND();
    
    
        if (!m_pDirectSoundCaptureCreate) return E_FAIL;
    
        hr=(m_pDirectSoundCaptureCreate)(pguid,&realsound1,NULL); 
        if FAILED(hr) return  hr;
        
		// I'm getting No Such interface on this call. - BUG
		hr=realsound1->QueryInterface(IID_IDirectSoundCapture8,(void**)&realsound8);
		realsound1->Release();
		if FAILED(hr) return hr;
	  
    
        INTERNAL_CREATE(_dxj_DirectSoundCapture,realsound8,ret);
        
        if (*ret==NULL) {
            realsound8->Release();
            return E_FAIL;
        }
    
        if (*ret==NULL) {
            realsound1->Release();
            return E_FAIL;
        }
        return hr;		
    }
    
    
    STDMETHODIMP C_dxj_DirectX7Object::getDSCaptureEnum( I_dxj_DSEnum **retVal)
    {	
        HRESULT hr;
    
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
        LoadDSOUND();
    
        if (!m_pDirectSoundCaptureEnumerate) return E_FAIL;	
        hr=C_dxj_DSEnumObject::create(NULL,m_pDirectSoundCaptureEnumerate,retVal);
    
        return hr;
    
    }
            
    
    
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    
    
    STDMETHODIMP C_dxj_DirectX7Object::getDSEnum( I_dxj_DSEnum **retVal)
    {	
        HRESULT hr;

#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
        LoadDSOUND();
    
        if (!m_pDirectSoundEnumerate) return E_FAIL;	
        hr=C_dxj_DSEnumObject::create(m_pDirectSoundEnumerate,NULL,retVal);
    
        return hr;
    
    }
    
    
    ////////////////////////////////////////////////////////////////
    
  STDMETHODIMP C_dxj_DirectX7Object::directInputCreate(I_dxj_DirectInput8 **ret){
      
      HRESULT hr;

#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
      LoadDINPUTDLL();
    

      //DirectInput8Create(HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);
      static HRESULT (WINAPI *ProcAdd)(HINSTANCE , DWORD , REFIID , LPVOID *, LPUNKNOWN)=NULL;  
  
      if (ProcAdd==NULL){
        if (g_hInstDINPUTDLL==NULL) return E_NOINTERFACE;
        ProcAdd = (HRESULT (WINAPI *)(HINSTANCE , DWORD , REFIID , LPVOID *, LPUNKNOWN)) GetProcAddress(g_hInstDINPUTDLL, "DirectInput8Create"); 
        if (ProcAdd==NULL) return E_FAIL;
      }	
     
      LPDIRECTINPUT8W lpInput8=NULL;
  
      hr= (ProcAdd)(g_hInst,(DWORD)DIRECTINPUT_VERSION,IID_IDirectInput8W,(void**)&lpInput8,NULL);
      if FAILED(hr) return hr;
        
   
      INTERNAL_CREATE(_dxj_DirectInput8,lpInput8,ret);	
    
      return hr;
    }
    
    

//    STDMETHODIMP C_dxj_DirectX7Object::systemBpp(long *retval)
//    {
//        HDC hdc;
//    
//        hdc = ::GetDC(NULL);
//        *retval = GetDeviceCaps(hdc, BITSPIXEL);
//        ::ReleaseDC(NULL, hdc);
//    
//        return S_OK;
//    }

    
    
    
    STDMETHODIMP C_dxj_DirectX7Object::directMusicLoaderCreate ( 
                /* [retval][out] */ I_dxj_DirectMusicLoader __RPC_FAR *__RPC_FAR *ret)
    {
        HRESULT hr;
    
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
        IDirectMusicLoader8 *pLoader=NULL;    

        hr =CoCreateInstance(
                CLSID_DirectMusicLoader, 
            	NULL,
                CLSCTX_INPROC,   
            	IID_IDirectMusicLoader8,
                (void**)&pLoader);
    
        if (FAILED(hr)) return E_NOINTERFACE;
        
        if (!pLoader) return E_FAIL;

		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicLoader,pLoader,ret);
    
        return S_OK;
    }
            
    STDMETHODIMP C_dxj_DirectX7Object::directMusicComposerCreate ( 
                /* [retval][out] */ I_dxj_DirectMusicComposer __RPC_FAR *__RPC_FAR *ret)
    {
        
        IDirectMusicComposer8	*pComp=NULL;    
        HRESULT hr;

#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
    
        if (FAILED(CoCreateInstance(
                CLSID_DirectMusicComposer, 
            	NULL,
                CLSCTX_INPROC,   
            	IID_IDirectMusicComposer8,
                (void**)&pComp        )))   {
             return E_NOINTERFACE;
        }
        if (!pComp) return E_FAIL;

        INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicComposer,pComp,ret);
        return S_OK;
    }
    
    
    STDMETHODIMP C_dxj_DirectX7Object::directMusicPerformanceCreate ( 
                /* [retval][out] */ I_dxj_DirectMusicPerformance __RPC_FAR *__RPC_FAR *ret)
    {
    
        IDirectMusicPerformance8 *pPerf=NULL;    
        HRESULT hr;

#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
            
    
        if (FAILED(CoCreateInstance(
                CLSID_DirectMusicPerformance, 
            	NULL,
                CLSCTX_INPROC,   
            	IID_IDirectMusicPerformance8,
                (void**)&pPerf        )))   {
             return E_NOINTERFACE;
        }
        if (!pPerf) return E_FAIL;
		
        INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicPerformance,pPerf,ret);
        return S_OK;
    }
    
    
    
    
    
#ifdef _WIN64
    STDMETHODIMP C_dxj_DirectX7Object::createEvent( 
                /* [in] */ I_dxj_DirectXEvent8 __RPC_FAR *event,
                /* [retval][out] */ HANDLE __RPC_FAR *h) 
#else
    STDMETHODIMP C_dxj_DirectX7Object::createEvent( 
                /* [in] */ I_dxj_DirectXEvent8 __RPC_FAR *event,
                /* [retval][out] */ LONG __RPC_FAR *h) 
#endif
    {
    
        HRESULT	  hr;
        LPSTREAM  pStm=NULL;
        IUnknown *pUnk=NULL;
    
        HANDLE hEvent=NULL;	
        EVENTTHREADINFO *pNewEvent=NULL;
        EVENTTHREADINFO *pTemp=NULL;
        if (!event) return E_INVALIDARG;
        if (!h) return E_INVALIDARG;
    
        pNewEvent=(EVENTTHREADINFO*)malloc(sizeof(EVENTTHREADINFO));
        if (!pNewEvent) return E_OUTOFMEMORY;
		ZeroMemory(pNewEvent, sizeof(EVENTTHREADINFO));
        pNewEvent->pNext=NULL;
        pNewEvent->fEnd=FALSE;	
        pNewEvent->pCallback=event;
        pNewEvent->pStream=NULL;
        event->AddRef();
    
    
    
        pNewEvent->hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
        if (!pNewEvent->hEvent){
            free(pNewEvent);
            event->Release();
            return E_FAIL;
        }
    
        //pNewEvent->hEndEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
        
        hr=event->QueryInterface(IID_IUnknown,(void**)&pUnk);
        if FAILED(hr) {
          	free(pNewEvent);
          	event->Release();
          	return E_FAIL;
        }
    
        hr=CoMarshalInterThreadInterfaceInStream(IID_IUnknown,pUnk,&pStm);
        if (pUnk) pUnk->Release();
        if FAILED(hr) {  			
          	free(pNewEvent);
          	event->Release();			
          	return E_FAIL;
        }
    
        pNewEvent->pStream=pStm;
    
        pNewEvent->hThread=CreateThread(NULL,0,ThreadFunc,(unsigned long*)pNewEvent,CREATE_SUSPENDED ,&pNewEvent->threadID);
        if (!pNewEvent->threadID) {
            	CloseHandle(pNewEvent->hEvent);
            	free(pNewEvent);
            	event->Release();
            	return E_FAIL;
        }
    
    
        if (!m_pEventList){
            m_pEventList=pNewEvent;
        }
        else{
            pTemp=m_pEventList;
            m_pEventList=pNewEvent;	
            pNewEvent->pNext=pTemp;
        }
    
    
        ResumeThread(pNewEvent->hThread);
            
    
#ifdef _WIN64
		*h=(pNewEvent->hEvent); 
#else
		*h=(LONG)PtrToLong(pNewEvent->hEvent); 
#endif
        return S_OK;
    }
            
#ifdef _WIN64
    STDMETHODIMP C_dxj_DirectX7Object::setEvent( 
                /* [in] */ HANDLE eventId)  
	{
        SetEvent(eventId);
        return S_OK;
    }
#else
    STDMETHODIMP C_dxj_DirectX7Object::setEvent( 
                /* [in] */ LONG eventId)  
	{
        SetEvent((HANDLE)eventId);
        return S_OK;
    }
#endif
    
#ifdef _WIN64
    STDMETHODIMP C_dxj_DirectX7Object::destroyEvent( 
                /* [in] */ HANDLE eventId)  
#else
    STDMETHODIMP C_dxj_DirectX7Object::destroyEvent( 
                /* [in] */ LONG eventId)  
#endif
    {
        //find the info on the stack
        if (!m_pEventList) return E_INVALIDARG;
    
        EVENTTHREADINFO *pTemp=NULL;
        EVENTTHREADINFO *pLast=NULL;
    
        //rely on lazy evaluation
        for (pTemp=m_pEventList; ((pTemp)&&(pTemp->hEvent!=(HANDLE)eventId));pLast=pTemp,pTemp=pTemp->pNext);
        if (!pTemp) return E_INVALIDARG;
    
        //remove it from our Link List
        if (!pLast) {
            m_pEventList=pTemp->pNext;		
        }
        else {
            pLast->pNext=pTemp->pNext;
        }
    
        //indicate that we want to kill the thread
        pTemp->fEnd=TRUE;
    
        //Fire the event in case we are waiting	
        if (pTemp->hEvent) SetEvent(pTemp->hEvent);
    
        //Wait for it to finish out
        if (pTemp->hThread) WaitForSingleObject(pTemp->hThread,1000);
    
        //wait for the end event to signal
        //if (pTemp->hEndEvent) WaitForSingleObject(pTemp->hEndEvent,1000);
    
        //desctroy the event
        if (pTemp->hEvent) CloseHandle(pTemp->hEvent);
        //if (pTemp->hEndEvent) CloseHandle (pTemp->hEndEvent);
        
        if (pTemp->pCallback) pTemp->pCallback->Release();
        
        //thread is gone..
        
        //free the memory
        free(pTemp);
    
        return S_OK;
    }
    
    DWORD WINAPI ThreadFunc(LPVOID param){
        HRESULT hr;
        IUnknown *pUnk=NULL;
        EVENTTHREADINFO *pCntrl=(EVENTTHREADINFO *)param;
        I_dxj_DirectXEvent8	*pVBCallback=NULL;
            
    
        OleInitialize(NULL);
    
    
        LCID LOCAL_SYSTEM_DEFAULT=GetSystemDefaultLCID();
    
    
        //note pstrm is released even on failure
        hr=CoGetInterfaceAndReleaseStream(pCntrl->pStream,IID_IUnknown,(void**)&pUnk);
        pCntrl->pCallback=NULL;	//since released to 0
    
        if FAILED(hr) return -1;
        if (!pUnk) return -1;
        
    
        
        hr=pUnk->QueryInterface(IID_I_dxj_DirectXEvent8,(void**)&pVBCallback);
        pUnk->Release();
    
        if FAILED(hr) return -1;  
    
        while (pCntrl->fEnd==FALSE) 
        {
            WaitForSingleObject(pCntrl->hEvent,INFINITE);
          	if ((pVBCallback )&&(pCntrl->fEnd==FALSE))
        	{
         		pVBCallback->AddRef();
#ifdef _WIN64
        		pVBCallback->DXCallback(pCntrl->hEvent); 
#else
        		pVBCallback->DXCallback((LONG)PtrToLong(pCntrl->hEvent)); 
#endif
          		pVBCallback->Release();
         	}
        }
    
    
        if (pVBCallback) pVBCallback->Release();
    
        OleUninitialize();
    
        //we need to syncronize the ending of the thread..
        //if (pCntrl->hEndEvent) SetEvent(pCntrl->hEndEvent);		
        
        return 0;
    }
    
    
    STDMETHODIMP C_dxj_DirectX7Object::createNewGuid(BSTR *ret)
    {
      	GUID g=GUID_NULL;
      	if (!ret) return E_INVALIDARG;
    
      	::CoCreateGuid(&g);
      	*ret=GUIDtoBSTR(&g);
      	return S_OK;
    }
    
    STDMETHODIMP C_dxj_DirectX7Object::DirectXFileCreate(I_dxj_DirectXFile **ret)
    {
		HRESULT hr;
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
		hr=C_dxj_DirectXFileObject::create(ret);
		return hr;

    }


    STDMETHODIMP C_dxj_DirectX7Object::Direct3DCreate(IUnknown **ppRet)
    {
        HRESULT hr;
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
	LoadD3D8();
	if (!m_pDirect3DCreate8) return E_FAIL;
	
	*ppRet=(IUnknown*) m_pDirect3DCreate8(D3D_SDK_VERSION);

       	return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\filestrm.h ===
#pragma once

#ifndef __FILESTRM_H_
#define __FILESTRM_H_

/*//////////////////////////////////////////////////////////////////////////////
//
// File: filestrm.h
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created
// -@- 09/23/99 (mikemarr)  - copyright, started history
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/

#include <objidl.h>


class CFileStream : public IStream
{
public: 
    
    CFileStream(LPCTSTR filename, BOOL bReadOnly, BOOL bTruncate, HRESULT *error);
    ~CFileStream();
    
    // IUnknown methods
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID, LPVOID FAR*);
    
    // Implemented IStream methods
    STDMETHODIMP Read(void __RPC_FAR *pv, ULONG cb, ULONG __RPC_FAR *pcbRead);
    STDMETHODIMP Write(const void __RPC_FAR *pv, ULONG cb, ULONG __RPC_FAR *pcbWritten);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER __RPC_FAR *plibNewPosition);
    STDMETHODIMP Stat(STATSTG __RPC_FAR *pstatstg, DWORD grfStatFlag);
    
    // Unimplemented IStream methods
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize) {return E_NOTIMPL;}
    STDMETHODIMP CopyTo(IStream __RPC_FAR *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER __RPC_FAR *pcbRead, ULARGE_INTEGER __RPC_FAR *pcbWritten) {return E_NOTIMPL;}
    STDMETHODIMP Commit(DWORD grfCommitFlags) {return E_NOTIMPL;}
    STDMETHODIMP Revert(void) {return E_NOTIMPL;}
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) {return E_NOTIMPL;}
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) {return E_NOTIMPL;}
    STDMETHODIMP Clone(IStream __RPC_FAR *__RPC_FAR *ppstm) {return E_NOTIMPL;}
    
private:
    
    DWORD m_cRef;
    HANDLE m_hfile;	
    
};

#endif // #ifndef __FILESTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\frmsave.cpp ===
//**************************************************************************
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999 All Rights Reserved.
//
//  File:   frmsave.cpp
//
//  Description:    Save LPDIRECT3DRMFRAME to an x file.
//
//  History:
//      011/06/98    CongpaY     Created
//
//**************************************************************************


#include <d3drm.h>
#include <dxfile.h>
#include <rmxftmpl.h>
#include <rmxfguid.h>
#include "frmsave.h"

extern HINSTANCE g_hInstD3DXOFDLL;

#define MyD3DRMColorGetAlpha(color)  ((float)((color & 0xFF000000)>>24)/(float)255)
#define MyD3DRMColorGetRed(color)  ((float)((color & 0x00FF0000)>>16)/(float)255)
#define MyD3DRMColorGetGreen(color)  ((float)((color & 0x0000FF00)>>8)/(float)255)
#define MyD3DRMColorGetBlue(color)  ((float)((color & 0x000000FF))/(float)255)


HRESULT FrameToXFile(LPDIRECT3DRMFRAME3 pFrame,
                     LPCSTR filename,
                     D3DRMXOFFORMAT d3dFormat,
                     D3DRMSAVEOPTIONS d3dSaveFlags)
{
    Saver saver;
    saver.Init(filename, d3dFormat, d3dSaveFlags);
    saver.SaveHeaderObject();
    saver.SaveFrame(pFrame);
    return S_OK;
}

Saver::Saver()
  : pXFile(NULL),
    pSave(NULL)
{
}

Saver::~Saver()
{
    if (pSave) pSave->Release();
    if (pXFile) pXFile->Release();
}

HRESULT Saver::Init(LPCSTR filename,
                    D3DRMXOFFORMAT d3dFormatArg,
                    D3DRMSAVEOPTIONS d3dSaveFlagsArg)
{
    d3dFormat = d3dFormatArg;
    d3dSaveFlags = d3dSaveFlagsArg;


	CREATEXFILE pCreateXFile=(CREATEXFILE)GetProcAddress( g_hInstD3DXOFDLL, "DirectXFileCreate" );	
	if (!pCreateXFile) return E_NOTIMPL;
		
	
    DXFILEFORMAT xFormat;

    if (d3dFormat == D3DRMXOF_BINARY)
        xFormat = DXFILEFORMAT_BINARY;
    else if (d3dFormat == D3DRMXOF_TEXT)
        xFormat = DXFILEFORMAT_TEXT;
    else
        xFormat = DXFILEFORMAT_COMPRESSED;

    //DirectXFileCreate(&pXFile);
	pCreateXFile(&pXFile);
    pXFile->RegisterTemplates((LPVOID)D3DRM_XTEMPLATES, D3DRM_XTEMPLATE_BYTES);

    pXFile->CreateSaveObject(filename, xFormat, &pSave);

    return S_OK;
}

HRESULT Saver::SaveHeaderObject()
{
    LPDIRECTXFILEDATA pHeader;
    Header data;

    data.major = 1;
    data.minor = 0;
    data.flags = (d3dFormat == D3DRMXOF_TEXT)? 1 : 0;

    pSave->CreateDataObject(TID_DXFILEHeader,
                            NULL,
                            NULL,
                            sizeof(Header),
                            &data,
                            &pHeader);

    pSave->SaveData(pHeader);
    pHeader->Release();
    return S_OK;
}

HRESULT Saver::SaveFrame(LPDIRECT3DRMFRAME3 pFrame,
                         LPDIRECT3DRMFRAME3 pRefFrame,
                         LPDIRECTXFILEDATA pRefFrameObj)
{
    DWORD i;
    HRESULT hr;
    LPDIRECTXFILEDATA pFrameObj;
    
    pSave->CreateDataObject(TID_D3DRMFrame,
                            NULL, 
                            NULL,
                            0,
                            NULL,
                            &pFrameObj);

    SaveFrameTransform(pFrameObj, pFrame, pRefFrame);

    // Enumerate visuals.

    DWORD cVisuals;

    pFrame->GetVisuals(&cVisuals, NULL);

    if (cVisuals)
    {
        LPUNKNOWN *ppUnk = new LPUNKNOWN[cVisuals];

        pFrame->GetVisuals(&cVisuals, ppUnk);

        for (i = 0; i < cVisuals; i++)
        {
            LPDIRECT3DRMFRAME3 pChildFrame;
            hr = ppUnk[i]->QueryInterface(IID_IDirect3DRMFrame3, (LPVOID *)&pChildFrame);

            if (SUCCEEDED(hr))
            {
                SaveFrame(pChildFrame, pFrame, pFrameObj);
                pChildFrame->Release();
            }
            else
            {
                LPDIRECT3DRMMESHBUILDER3 pMeshBuilder;
                hr = ppUnk[i]->QueryInterface(IID_IDirect3DRMMeshBuilder3, (LPVOID *)&pMeshBuilder);
    
                if (SUCCEEDED(hr))
                {
                    SaveMeshBuilder(pFrameObj, pMeshBuilder);
                    pMeshBuilder->Release();
                }
            }

            ppUnk[i]->Release();
        }

        delete[] ppUnk;
    }

    // Enumerate child frames.

    LPDIRECT3DRMFRAMEARRAY pFrameArray;

    pFrame->GetChildren(&pFrameArray);

    for (i = 0; i < pFrameArray->GetSize(); i++)
    {
        LPDIRECT3DRMFRAME pTmpFrame;
        LPDIRECT3DRMFRAME3 pChildFrame;
        pFrameArray->GetElement(i, &pTmpFrame);
        pTmpFrame->QueryInterface(IID_IDirect3DRMFrame3, (LPVOID *)&pChildFrame);
        pTmpFrame->Release();
        SaveFrame(pChildFrame, pFrame, pFrameObj);
        pChildFrame->Release();
    }

    pFrameArray->Release();

    // Add frame object to the saved list.

    if (pRefFrameObj)
        pRefFrameObj->AddDataObject(pFrameObj);
    else
        pSave->SaveData(pFrameObj);

    pFrameObj->Release();

    return S_OK;
}

HRESULT Saver::SaveFrameTransform(LPDIRECTXFILEDATA pFrameObj,
                                  LPDIRECT3DRMFRAME3 pFrame,
                                  LPDIRECT3DRMFRAME3 pRefFrame)
{
    LPDIRECTXFILEDATA pFrameTransformObj;
    D3DRMMATRIX4D rmMatrix;

    pFrame->GetTransform(pRefFrame, rmMatrix);

    pSave->CreateDataObject(TID_D3DRMFrameTransformMatrix,
                            NULL,
                            NULL,
                            sizeof(D3DRMMATRIX4D),
                            &rmMatrix,
                            &pFrameTransformObj);

    pFrameObj->AddDataObject(pFrameTransformObj);
    pFrameTransformObj->Release();
    return S_OK;
}

HRESULT Saver::SaveMeshBuilder(LPDIRECTXFILEDATA pFrameObj,
                               LPDIRECT3DRMMESHBUILDER3 pMeshBuilder)
{
    LPDIRECTXFILEDATA pMeshObj;
    DWORD cVertices, cNormals, cFaces, dwFaceData, *pdwFaceData;
    LPDIRECT3DRMFACEARRAY pFaceArray = NULL;

    pMeshBuilder->GetGeometry(&cVertices, NULL,
                              &cNormals, NULL,
                              &dwFaceData, NULL);

    cFaces = pMeshBuilder->GetFaceCount();

    if (!cVertices || !cNormals || !dwFaceData || !cFaces)
        return S_OK;

    pdwFaceData = new DWORD[dwFaceData];

    pMeshBuilder->GetGeometry(NULL, NULL,
                              NULL, NULL,
                              &dwFaceData, pdwFaceData);

    CreateMeshObject(cVertices, cFaces, dwFaceData, pdwFaceData,
                     pMeshBuilder, &pMeshObj);

    D3DRMCOLORSOURCE clrSrc = pMeshBuilder->GetColorSource();

    if (clrSrc == D3DRMCOLOR_FROMVERTEX)
    {
        CreateVertexColorsObject(pMeshObj, cVertices, pMeshBuilder);
    }

    if (d3dSaveFlags & D3DRMXOFSAVE_MATERIALS)
    {
        if (!pFaceArray)
            pMeshBuilder->GetFaces(&pFaceArray);
        CreateMaterialListObject(pMeshObj, pFaceArray);
    }

    if (d3dSaveFlags & D3DRMXOFSAVE_NORMALS)
    {
        CreateNormalsObject(pMeshObj,
                            cNormals, cFaces, dwFaceData, pdwFaceData,
                            pMeshBuilder);
    }
    

    if (d3dSaveFlags & D3DRMXOFSAVE_TEXTURETOPOLOGY)
    {
        if (!pFaceArray)
            pMeshBuilder->GetFaces(&pFaceArray);
        CreateTextureWrapsObject(pMeshObj, pFaceArray);
    }

    if (d3dSaveFlags & D3DRMXOFSAVE_TEXTURECOORDINATES)
    {
        CreateTextureCoordsObject(pMeshObj, cVertices, pMeshBuilder);
    }

    if (pFrameObj)
        pFrameObj->AddDataObject(pMeshObj);
    else
        pSave->SaveData(pMeshObj);

    pMeshObj->Release();
    delete[] pdwFaceData;
    if (pFaceArray)
        pFaceArray->Release();

    return S_OK;
}

HRESULT Saver::CreateMeshObject(DWORD cVertices,
                                DWORD cFaces,
                                DWORD dwFaceData,
                                LPDWORD pdwFaceData,
                                LPDIRECT3DRMMESHBUILDER3 pMeshBuilder,
                                LPDIRECTXFILEDATA *ppMeshObj)
{
    // mesh data is vertex_count + vertices + face_count + face_vertex_data;

    DWORD cbSize, *data;
    cbSize = cVertices * sizeof(D3DVECTOR) +
        (1 + (dwFaceData + cFaces + 1)/2) * sizeof(DWORD);

    data = (LPDWORD) new BYTE[cbSize];
    data[0] = cVertices;
    LPD3DVECTOR pVertices = (LPD3DVECTOR)&data[1];
    pMeshBuilder->GetGeometry(&cVertices, pVertices,
                              NULL, NULL,
                              NULL, NULL);

    LPDWORD pdwTmp = (LPDWORD)&pVertices[cVertices];
    *pdwTmp++ = cFaces;

    while (*pdwFaceData)
    {
        DWORD cFaceVertices = *pdwFaceData++;
        *pdwTmp++ = cFaceVertices;

        for (DWORD i = 0; i < cFaceVertices; i++)
        {
            *pdwTmp++ = *pdwFaceData++;
            pdwFaceData++; // skip normal index.
        }
    }

    DWORD dwSize;
    pMeshBuilder->GetName(&dwSize, NULL);
    
    LPSTR szName = NULL;
    if (dwSize)
    {
        szName = new char[dwSize];
        pMeshBuilder->GetName(&dwSize, szName);
    }

    pSave->CreateDataObject(TID_D3DRMMesh,
                            szName,
                            NULL,
                            cbSize,
                            data,
                            ppMeshObj);

    if (szName) lNames.Add(szName);
    delete[] data;
    return S_OK;
}

HRESULT Saver::CreateNormalsObject(LPDIRECTXFILEDATA pMeshObj,
                                   DWORD cNormals,
                                   DWORD cFaces,
                                   DWORD dwFaceData,
                                   LPDWORD pdwFaceData,
                                   LPDIRECT3DRMMESHBUILDER3 pMeshBuilder)
{                                
    // normals data is normal_count + normals + face_count + face_normal_data;

    DWORD cbSize, *data;
    cbSize = cNormals * sizeof(D3DVECTOR) +
        (1 + (dwFaceData + cFaces + 1)/2) * sizeof(DWORD);

    data = (LPDWORD) new BYTE[cbSize];
    data[0] = cNormals;

    LPD3DVECTOR pNormals = (LPD3DVECTOR)&data[1];

    pMeshBuilder->GetGeometry(NULL, NULL,
                              &cNormals, pNormals,
                              NULL, NULL);

    LPDWORD pdwTmp = (LPDWORD)&pNormals[cNormals];
    *pdwTmp++ = cFaces;

    while (*pdwFaceData)
    {
        DWORD cFaceVertices = *pdwFaceData++;
        *pdwTmp++ = cFaceVertices;

        for (DWORD i = 0; i < cFaceVertices; i++)
        {
            pdwFaceData++; // skip vertex index.
            *pdwTmp++ = *pdwFaceData++;
        }
    }

    LPDIRECTXFILEDATA pNormalsObj;

    pSave->CreateDataObject(TID_D3DRMMeshNormals,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pNormalsObj);

    pMeshObj->AddDataObject(pNormalsObj);
    pNormalsObj->Release();
    delete[] data;

    return S_OK;
}

HRESULT Saver::CreateVertexColorsObject(LPDIRECTXFILEDATA pMeshObj,
                                        DWORD cVertices,
                                        LPDIRECT3DRMMESHBUILDER3 pMeshBuilder)
{
    DWORD cbSize;
    VertexColors *data;

    cbSize = sizeof(DWORD) + cVertices * sizeof(IndexedColor);

    data = (VertexColors *) new BYTE[cbSize];
    data->cVertices = cVertices;

    for (DWORD i = 0; i < cVertices; i++)
    {
        D3DCOLOR color = pMeshBuilder->GetVertexColor(i);
        data->vertexColors[i].index = i;
        data->vertexColors[i].color.r = MyD3DRMColorGetRed(color);
        data->vertexColors[i].color.g = MyD3DRMColorGetGreen(color);
        data->vertexColors[i].color.b = MyD3DRMColorGetBlue(color);
        data->vertexColors[i].color.a = MyD3DRMColorGetAlpha(color);
    }

    LPDIRECTXFILEDATA pVertexColorsObj;

    pSave->CreateDataObject(TID_D3DRMMeshVertexColors,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pVertexColorsObj);

    pMeshObj->AddDataObject(pVertexColorsObj);
    pVertexColorsObj->Release();
    delete[] data;                        

    return S_OK;
}

HRESULT Saver::CreateMaterialListObject(LPDIRECTXFILEDATA pMeshObj,
                                        LPDIRECT3DRMFACEARRAY pFaceArray)
{
    DWORD cbSize, cFaces;
    FaceMaterials *data;
    FaceMaterialList lMat;

    cFaces = pFaceArray->GetSize();
    cbSize = (2 + cFaces) * sizeof(DWORD);

    data = (FaceMaterials *) new BYTE[cbSize];
    data->cFaceIndexes = cFaces;
    LPDWORD pdwIndex = data->faceIndexes;

    for (DWORD i = 0; i < cFaces; i++, pdwIndex++)
    {
        LPDIRECT3DRMFACE pFace;
        pFaceArray->GetElement(i, &pFace);

        D3DCOLOR faceColor;
        LPDIRECT3DRMMATERIAL pMaterial;
        LPDIRECT3DRMTEXTURE pTexture;

        faceColor = pFace->GetColor();
        pFace->GetMaterial(&pMaterial);
        pFace->GetTexture(&pTexture);
        
        *pdwIndex = lMat.Find(faceColor, pMaterial, pTexture);

        pMaterial->Release();
        if (pTexture) pTexture->Release();
        pFace->Release();
    }

    data->cMaterials = lMat.Count();

    if (data->cMaterials == 1)
    {
        data->cFaceIndexes = 1;
        data->faceIndexes[0] = 0;
        cbSize = 3 * sizeof(DWORD);
    }

    LPDIRECTXFILEDATA pMatListObj;

    pSave->CreateDataObject(TID_D3DRMMeshMaterialList,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pMatListObj);

    FaceMaterial *pMat;
    for (pMat = lMat.First(); pMat; pMat = pMat->pNext)
    {
        CreateMaterialObject(pMatListObj,
                             pMat);
    }

    pMeshObj->AddDataObject(pMatListObj);
    pMatListObj->Release();
    delete[] data;
    
    return S_OK;
}

HRESULT Saver::CreateMaterialObject(LPDIRECTXFILEDATA pMatListObj,
                                    FaceMaterial *pMat)
{
    BaseMaterial data;

    data.faceColor.r = MyD3DRMColorGetRed(pMat->faceColor);
    data.faceColor.g = MyD3DRMColorGetGreen(pMat->faceColor);
    data.faceColor.b = MyD3DRMColorGetBlue(pMat->faceColor);
    data.faceColor.a = MyD3DRMColorGetAlpha(pMat->faceColor);

    data.power = pMat->pMaterial->GetPower();

    pMat->pMaterial->GetSpecular(&data.specularColor.r,
                                 &data.specularColor.g,
                                 &data.specularColor.b);

    pMat->pMaterial->GetEmissive(&data.emissiveColor.r,
                                 &data.emissiveColor.g,
                                 &data.emissiveColor.b);

    LPDIRECTXFILEDATA pMaterialObj;

    pSave->CreateDataObject(TID_D3DRMMaterial,
                            NULL,
                            NULL,
                            sizeof(BaseMaterial),
                            &data,
                            &pMaterialObj);

    if (pMat->pTexture)
    {
        IDirectXFileData *pTextureObj;

        DWORD dwSize;
        pMat->pTexture->GetName(&dwSize, NULL);

        if (dwSize)
        {
            LPSTR szName = new char[dwSize];
            pMat->pTexture->GetName(&dwSize, szName);
    
            pSave->CreateDataObject(TID_D3DRMTextureFilename,
                                    NULL,
                                    NULL,
                                    sizeof(LPSTR),
                                    &szName,
                                    &pTextureObj);
    
            pMaterialObj->AddDataObject(pTextureObj);
            pTextureObj->Release();
            lNames.Add(szName);
        }
    }

    pMatListObj->AddDataObject(pMaterialObj);
    pMaterialObj->Release();

    return S_OK;
}

HRESULT Saver::CreateTextureWrapsObject(LPDIRECTXFILEDATA pMeshObj,
                                        LPDIRECT3DRMFACEARRAY pFaceArray)
{
    DWORD cbSize, cFaces;
    FaceWraps *data;

    cFaces = pFaceArray->GetSize();
    cbSize = sizeof(DWORD) + cFaces * sizeof(Boolean2d);

    data = (FaceWraps *) new BYTE[cbSize];
    data->cFaces = cFaces;
    Boolean2d *pWrap = data->faceWraps;

    for (DWORD i = 0; i < cFaces; i++, pWrap++)
    {
        LPDIRECT3DRMFACE pFace;
        pFaceArray->GetElement(i, &pFace);
        pFace->GetTextureTopology(&pWrap->u, &pWrap->v);
        pFace->Release();
    }

    LPDIRECTXFILEDATA pTextureWrapsObj;

    pSave->CreateDataObject(TID_D3DRMMeshFaceWraps,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pTextureWrapsObj);

    pMeshObj->AddDataObject(pTextureWrapsObj);
    pTextureWrapsObj->Release();
    delete[] data;                        

    return S_OK;
}

HRESULT Saver::CreateTextureCoordsObject(LPDIRECTXFILEDATA pMeshObj,
                                         DWORD cVertices,
                                         LPDIRECT3DRMMESHBUILDER3 pMeshBuilder)
{
    DWORD cbSize;
    TextureCoords *data;

    cbSize = sizeof(DWORD) + cVertices * sizeof(Coords2d);

    data = (TextureCoords *) new BYTE[cbSize];
    data->cVertices = cVertices;
    Coords2d *pCoords = data->textureCoords;

    for (DWORD i = 0; i < cVertices; i++, pCoords++)
    {
        pMeshBuilder->GetTextureCoordinates(i, &pCoords->u, &pCoords->v);
    }

    LPDIRECTXFILEDATA pTexCoordsObj;

    pSave->CreateDataObject(TID_D3DRMMeshTextureCoords,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pTexCoordsObj);

    pMeshObj->AddDataObject(pTexCoordsObj);
    pTexCoordsObj->Release();
    delete[] data;                        

    return S_OK;
}

FaceMaterialList::FaceMaterialList()
  : cElements(0), pFirst(NULL)
{
}

FaceMaterialList::~FaceMaterialList()
{
    FaceMaterial *pMat = pFirst;
    while (pMat)
    {
        FaceMaterial *pNext = pMat->pNext;
        pMat->pMaterial->Release();
        if (pMat->pTexture) pMat->pTexture->Release();
        delete pMat;
        pMat = pNext;
    }
}

DWORD FaceMaterialList::Find(D3DCOLOR faceColor,
                             LPDIRECT3DRMMATERIAL pMaterial,
                             LPDIRECT3DRMTEXTURE pTexture)
{
    FaceMaterial *pTmp = pFirst;
    FaceMaterial **ppNew = &pFirst;

    for (DWORD i = 0; pTmp; i++, pTmp = pTmp->pNext)
    {
        if (pTmp->faceColor == faceColor &&
            pTmp->pMaterial == pMaterial &&
            pTmp->pTexture == pTexture)
            return i;

        if (!pTmp->pNext)
            ppNew = &pTmp->pNext;
    }

    FaceMaterial *pNew = new FaceMaterial;
    pNew->faceColor = faceColor;
    pNew->pMaterial = pMaterial;
    pNew->pTexture = pTexture;
    pNew->pNext = NULL;
    pMaterial->AddRef();
    if (pTexture) pTexture->AddRef();

    *ppNew = pNew;
    cElements++;
    return i;
}

NameList::NameList()
 : pFirst(NULL),
   ppLast(NULL)
{
}

NameList::~NameList()
{
    NameEntry *pEntry = pFirst;

    while (pEntry)
    {
        NameEntry *pNext = pEntry->pNext;
        delete[] pEntry->pName;
        delete pEntry;
        pEntry = pNext;
    }
}

void NameList::Add(LPSTR pName)
{
    NameEntry *pNew = new NameEntry;

    pNew->pName = pName;
    pNew->pNext = NULL;

    if (ppLast)
        *ppLast = pNew;
    else
        pFirst = pNew;

    ppLast = &pNew->pNext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\filestrm.cpp ===
/*//////////////////////////////////////////////////////////////////////////////
//
// File: filestrm.cpp
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created
// -@- 09/23/99 (mikemarr)  - copyright, started history
// -@- 07/15/00 (andrewke)  - replicated in DXVB dir
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/

#include "Filestrm.h"

CFileStream::CFileStream(LPCTSTR filename, BOOL bRead, BOOL bTruncate, HRESULT *error)
{
    m_hfile = CreateFile(filename, bRead ? GENERIC_READ : GENERIC_WRITE, 0, NULL, 
						  (bTruncate ? CREATE_ALWAYS : OPEN_EXISTING), FILE_ATTRIBUTE_NORMAL,
						  NULL);
	if (error)
	{
        ULONG foo = GetLastError();
		if (m_hfile == INVALID_HANDLE_VALUE)
			*error = E_FAIL;
		else
			*error = NOERROR;
	}
	m_cRef = 1;
}

CFileStream::~CFileStream()
{
	CloseHandle(m_hfile);
}

STDMETHODIMP_(ULONG) CFileStream::AddRef(void)
{
	return m_cRef++;	
}

STDMETHODIMP_(ULONG) CFileStream::Release(void)
{
	if (--m_cRef != 0)	
		return m_cRef;	
	
	delete this;
	return 0;
}


STDMETHODIMP CFileStream::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{	
	*ppv=NULL;
	if (riid == IID_IUnknown)
		*ppv=(IUnknown*)this;
	else if (riid == IID_IStream)
		*ppv=(IStream*)this;
	else
		return E_NOINTERFACE;
	((LPUNKNOWN)*ppv)->AddRef();
	return NOERROR;
}


STDMETHODIMP CFileStream::Read(void __RPC_FAR *pv, ULONG cb, ULONG __RPC_FAR *pcbRead)
{
	DWORD read;
	BOOL result = ReadFile(m_hfile, pv, cb, &read, NULL);
	if (pcbRead)
		*pcbRead = read;
	if (result)
		return S_OK;
	else
		return E_FAIL;
}


STDMETHODIMP CFileStream::Write(const void __RPC_FAR *pv, ULONG cb, ULONG __RPC_FAR *pcbWritten)
{
	DWORD written;
	BOOL result = WriteFile(m_hfile, pv, cb, &written, NULL);
	if (pcbWritten)
		*pcbWritten = written;
	if (result)
		return S_OK;
	else
		return E_FAIL;
}

STDMETHODIMP CFileStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER __RPC_FAR *plibNewPosition)
{
	LONG movelow;
	LONG movehigh;

	movelow = dlibMove.LowPart;
	movehigh = dlibMove.HighPart;

	DWORD moveMethod;
	switch (dwOrigin)
	{
	case STREAM_SEEK_SET: moveMethod = FILE_BEGIN; break;
	case STREAM_SEEK_CUR: moveMethod = FILE_CURRENT; break;
	case STREAM_SEEK_END: moveMethod = FILE_END; break;
	default: return E_INVALIDARG;
	}



	DWORD result = SetFilePointer(m_hfile, movelow, &movehigh, moveMethod);

	if (plibNewPosition)
	{
		plibNewPosition->LowPart = result;
		plibNewPosition->HighPart = movehigh;
	}

	if (result != -1)
		return NOERROR;
	else
		return E_FAIL;
}


STDMETHODIMP CFileStream::Stat(STATSTG __RPC_FAR *pstatstg, DWORD grfStatFlag)
{
    memset(pstatstg, 0, sizeof(STATSTG));

    pstatstg->pwcsName = NULL; 
    pstatstg->type = STGTY_STREAM; 

    pstatstg->cbSize.LowPart = GetFileSize(m_hfile, &pstatstg->cbSize.HighPart); 

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\dxerr8.cpp ===
/*==========================================================================;
 *
 *
 *  File:   dxerr8.cpp
 *  Content:    DirectX Error Library 
 *
 ****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <MMsystem.h>


#include"d3d8.h"
#include"d3dx8.h"
#include"d3dxerr.h"
#include"dsound.h"
#include"dmusici.h"
#include"dplay8.h"
#include"dvoice.h"
#include"dinput.h"
#include"dinputd.h"

//#include"appman.h"

#define BUFFER_SIZE 3000
#define  CHK_ERR(hrchk, strOut) \
        case hrchk: \
             return strOut;     


/****************************************************/
/* DXGetErrorString8A                                */
/*                                                  */
/****************************************************/

const char * __stdcall  DXGetErrorString8A(HRESULT hr)
{
   switch(hr)
   {     
        // Common Win32 error codes
        CHK_ERR(S_OK, "S_OK")
        CHK_ERR(S_FALSE, "S_FALSE")
        
        CHK_ERR(E_UNEXPECTED, "E_UNEXPECTED")
        CHK_ERR(E_NOTIMPL, "E_NOTIMPL")
        CHK_ERR(E_OUTOFMEMORY, "E_OUTOFMEMORY")
        CHK_ERR(E_INVALIDARG, "E_INVALIDARG")
        CHK_ERR(E_NOINTERFACE, "E_NOINTERFACE")
        CHK_ERR(E_POINTER, "E_POINTER")
        CHK_ERR(E_HANDLE, "E_HANDLE")
        CHK_ERR(E_ABORT, "E_ABORT")
        CHK_ERR(E_FAIL, "E_FAIL")
        CHK_ERR(E_ACCESSDENIED, "E_ACCESSDENIED")
        CHK_ERR(E_PENDING, "E_PENDING")
        CHK_ERR(REGDB_E_CLASSNOTREG, "REGDB_E_CLASSNOTREG")
        CHK_ERR(CO_E_NOTINITIALIZED, "CO_E_NOTINITIALIZED")
        CHK_ERR(CO_E_ALREADYINITIALIZED, "CO_E_ALREADYINITIALIZED")

//      CHK_ERR(DIERR_GENERIC, "E_FAIL")
        CHK_ERR(DIERR_NOAGGREGATION, "E_NOAGGREGATION")
        CHK_ERR(DIERR_INSUFFICIENTPRIVS, "DIERR_INSUFFICIENTPRIVS")
        CHK_ERR(DIERR_DEVICEFULL, "DIERR_DEVICEFULL")
        CHK_ERR(DIERR_MOREDATA, "DIERR_MOREDATA")
        CHK_ERR(DIERR_NOTDOWNLOADED, "DIERR_NOTDOWNLOADED")
        CHK_ERR(DIERR_HASEFFECTS, "DIERR_HASEFFECTS")
        CHK_ERR(DIERR_NOTEXCLUSIVEACQUIRED, "DIERR_NOTEXCLUSIVEACQUIRED")
        CHK_ERR(DIERR_INCOMPLETEEFFECT, "DIERR_INCOMPLETEEFFECT")
        CHK_ERR(DIERR_NOTBUFFERED, "DIERR_NOTBUFFERED")
        CHK_ERR(DIERR_EFFECTPLAYING, "DIERR_EFFECTPLAYING")
        CHK_ERR(DIERR_UNPLUGGED, "DIERR_UNPLUGGED")
        CHK_ERR(DIERR_REPORTFULL, "DIERR_REPORTFULL")
        CHK_ERR(DIERR_DRIVERFIRST, "DIERR_DRIVERFIRST")
        CHK_ERR(DIERR_DRIVERLAST, "DIERR_DRIVERLAST")
        CHK_ERR(DIERR_INVALIDCLASSINSTALLER, "DIERR_INVALIDCLASSINSTALLER")
        CHK_ERR(DIERR_CANCELLED, "DIERR_CANCELLED")
        CHK_ERR(DIERR_BADINF, "DIERR_BADINF")
        CHK_ERR(DIERR_NOTFOUND, "DIERR_NOTFOUND or DIERR_NOTFOUND")
//      CHK_ERR(DIERR_READONLY, "DIERR_READONLY or DIERR_OTHERAPPHASPRIO or DIERR_HANDLEEXISTS or DSERR_ACCESSDENIED")
        CHK_ERR(DIERR_NOTACQUIRED, "DIERR_NOTACQUIRED")
//      CHK_ERR(DIERR_OUTOFMEMORY, "E_OUTOFMEMORY")
        CHK_ERR(DIERR_NOTINITIALIZED, "DIERR_NOTINITIALIZED")
        CHK_ERR(DIERR_INPUTLOST, "DIERR_INPUTLOST")
        CHK_ERR(DIERR_BADDRIVERVER, "DIERR_BADDRIVERVER")
        CHK_ERR(DIERR_ACQUIRED, "DIERR_ACQUIRED")
        CHK_ERR(DIERR_NOMOREITEMS, "DIERR_NOMOREITEMS")
        CHK_ERR(DIERR_OLDDIRECTINPUTVERSION, "DIERR_OLDDIRECTINPUTVERSION")
        CHK_ERR(DIERR_BETADIRECTINPUTVERSION, "DIERR_BETADIRECTINPUTVERSION")
        CHK_ERR(DIERR_ALREADYINITIALIZED, "DIERR_ALREADYINITIALIZED")
        
        CHK_ERR(DVERR_BUFFERTOOSMALL, "DVERR_BUFFERTOOSMALL")
        CHK_ERR(DVERR_EXCEPTION, "DVERR_EXCEPTION")
        CHK_ERR(DVERR_INVALIDFLAGS, "DVERR_INVALIDFLAGS")
        CHK_ERR(DVERR_INVALIDOBJECT, "DVERR_INVALIDOBJECT")
        CHK_ERR(DVERR_INVALIDPLAYER, "DVERR_INVALIDPLAYER")
        CHK_ERR(DVERR_INVALIDGROUP, "DVERR_INVALIDGROUP")
        CHK_ERR(DVERR_INVALIDHANDLE, "DVERR_INVALIDHANDLE")
        CHK_ERR(DVERR_SESSIONLOST, "DVERR_SESSIONLOST")
        CHK_ERR(DVERR_NOVOICESESSION, "DVERR_NOVOICESESSION")
        CHK_ERR(DVERR_CONNECTIONLOST, "DVERR_CONNECTIONLOST")
        CHK_ERR(DVERR_NOTINITIALIZED, "DVERR_NOTINITIALIZED")
        CHK_ERR(DVERR_CONNECTED, "DVERR_CONNECTED")
        CHK_ERR(DVERR_NOTCONNECTED, "DVERR_NOTCONNECTED")
        CHK_ERR(DVERR_CONNECTABORTING, "DVERR_CONNECTABORTING")
        CHK_ERR(DVERR_NOTALLOWED, "DVERR_NOTALLOWED")
        CHK_ERR(DVERR_INVALIDTARGET, "DVERR_INVALIDTARGET")
        CHK_ERR(DVERR_TRANSPORTNOTHOST, "DVERR_TRANSPORTNOTHOST")
        CHK_ERR(DVERR_COMPRESSIONNOTSUPPORTED, "DVERR_COMPRESSIONNOTSUPPORTED")
        CHK_ERR(DVERR_ALREADYPENDING, "DVERR_ALREADYPENDING")
        CHK_ERR(DVERR_SOUNDINITFAILURE, "DVERR_SOUNDINITFAILURE")
        CHK_ERR(DVERR_TIMEOUT, "DVERR_TIMEOUT")
        CHK_ERR(DVERR_CONNECTABORTED, "DVERR_CONNECTABORTED")
        CHK_ERR(DVERR_NO3DSOUND, "DVERR_NO3DSOUND")
        CHK_ERR(DVERR_ALREADYBUFFERED, "DVERR_ALREADYBUFFERED")
        CHK_ERR(DVERR_NOTBUFFERED, "DVERR_NOTBUFFERED")
        CHK_ERR(DVERR_HOSTING, "DVERR_HOSTING")
        CHK_ERR(DVERR_NOTHOSTING, "DVERR_NOTHOSTING")
        CHK_ERR(DVERR_INVALIDDEVICE, "DVERR_INVALIDDEVICE")
        CHK_ERR(DVERR_RECORDSYSTEMERROR, "DVERR_RECORDSYSTEMERROR")
        CHK_ERR(DVERR_PLAYBACKSYSTEMERROR, "DVERR_PLAYBACKSYSTEMERROR")
        CHK_ERR(DVERR_SENDERROR, "DVERR_SENDERROR")
        CHK_ERR(DVERR_USERCANCEL, "DVERR_USERCANCEL")
        CHK_ERR(DVERR_RUNSETUP, "DVERR_RUNSETUP")
        CHK_ERR(DVERR_INCOMPATIBLEVERSION, "DVERR_INCOMPATIBLEVERSION")
        CHK_ERR(DVERR_INITIALIZED, "DVERR_INITIALIZED")
        CHK_ERR(DVERR_NOTRANSPORT, "DVERR_NOTRANSPORT")
        CHK_ERR(DVERR_NOCALLBACK, "DVERR_NOCALLBACK")
        CHK_ERR(DVERR_TRANSPORTNOTINIT, "DVERR_TRANSPORTNOTINIT")
        CHK_ERR(DVERR_TRANSPORTNOSESSION, "DVERR_TRANSPORTNOSESSION")
        CHK_ERR(DVERR_TRANSPORTNOPLAYER, "DVERR_TRANSPORTNOPLAYER")
        CHK_ERR(DVERR_USERBACK, "DVERR_USERBACK")
        CHK_ERR(DVERR_NORECVOLAVAILABLE, "DVERR_NORECVOLAVAILABLE")
        
        CHK_ERR(DPNERR_ABORTED, "DPNERR_ABORTED")
        CHK_ERR(DPNERR_ADDRESSING, "DPNERR_ADDRESSING")
        CHK_ERR(DPNERR_ALREADYCONNECTED, "DPNERR_ALREADYCONNECTED")
        CHK_ERR(DPNERR_ALREADYDISCONNECTING, "DPNERR_ALREADYDISCONNECTING")
        CHK_ERR(DPNERR_ALREADYINITIALIZED, "DPNERR_ALREADYINITIALIZED")
        CHK_ERR(DPNERR_ALREADYREGISTERED, "DPNERR_ALREADYREGISTERED")
        CHK_ERR(DPNERR_BUFFERTOOSMALL, "DPNERR_BUFFERTOOSMALL")
        CHK_ERR(DPNERR_CANNOTCANCEL, "DPNERR_CANNOTCANCEL")
        CHK_ERR(DPNERR_CANTCREATEGROUP, "DPNERR_CANTCREATEGROUP")
        CHK_ERR(DPNERR_CANTCREATEPLAYER, "DPNERR_CANTCREATEPLAYER")
        CHK_ERR(DPNERR_CANTLAUNCHAPPLICATION, "DPNERR_CANTLAUNCHAPPLICATION")
        CHK_ERR(DPNERR_CONNECTING, "DPNERR_CONNECTING")
        CHK_ERR(DPNERR_CONNECTIONLOST, "DPNERR_CONNECTIONLOST")
        CHK_ERR(DPNERR_CONVERSION, "DPNERR_CONVERSION")
        CHK_ERR(DPNERR_DOESNOTEXIST, "DPNERR_DOESNOTEXIST")
        CHK_ERR(DPNERR_DUPLICATECOMMAND, "DPNERR_DUPLICATECOMMAND")
        CHK_ERR(DPNERR_ENDPOINTNOTRECEIVING, "DPNERR_ENDPOINTNOTRECEIVING")
        CHK_ERR(DPNERR_EXCEPTION, "DPNERR_EXCEPTION")
        CHK_ERR(DPNERR_GROUPNOTEMPTY, "DPNERR_GROUPNOTEMPTY")
        CHK_ERR(DPNERR_HOSTING, "DPNERR_HOSTING")
        CHK_ERR(DPNERR_HOSTREJECTEDCONNECTION, "DPNERR_HOSTREJECTEDCONNECTION")
        CHK_ERR(DPNERR_INCOMPLETEADDRESS, "DPNERR_INCOMPLETEADDRESS")
        CHK_ERR(DPNERR_INVALIDADDRESSFORMAT, "DPNERR_INVALIDADDRESSFORMAT")
        CHK_ERR(DPNERR_INVALIDAPPLICATION, "DPNERR_INVALIDAPPLICATION")
        CHK_ERR(DPNERR_INVALIDCOMMAND, "DPNERR_INVALIDCOMMAND")
        CHK_ERR(DPNERR_INVALIDENDPOINT, "DPNERR_INVALIDENDPOINT")
        CHK_ERR(DPNERR_INVALIDFLAGS, "DPNERR_INVALIDFLAGS")
        CHK_ERR(DPNERR_INVALIDGROUP, "DPNERR_INVALIDGROUP")
        CHK_ERR(DPNERR_INVALIDHANDLE, "DPNERR_INVALIDHANDLE")
        CHK_ERR(DPNERR_INVALIDINSTANCE, "DPNERR_INVALIDINSTANCE")
        CHK_ERR(DPNERR_INVALIDINTERFACE, "DPNERR_INVALIDINTERFACE")
        CHK_ERR(DPNERR_INVALIDDEVICEADDRESS, "DPNERR_INVALIDDEVICEADDRESS")
        CHK_ERR(DPNERR_INVALIDOBJECT, "DPNERR_INVALIDOBJECT")
        CHK_ERR(DPNERR_INVALIDPASSWORD, "DPNERR_INVALIDPASSWORD")
        CHK_ERR(DPNERR_INVALIDPLAYER, "DPNERR_INVALIDPLAYER")
        CHK_ERR(DPNERR_INVALIDPRIORITY, "DPNERR_INVALIDPRIORITY")
        CHK_ERR(DPNERR_INVALIDHOSTADDRESS, "DPNERR_INVALIDHOSTADDRESS")
        CHK_ERR(DPNERR_INVALIDSTRING, "DPNERR_INVALIDSTRING")
        CHK_ERR(DPNERR_INVALIDURL, "DPNERR_INVALIDURL")
        CHK_ERR(DPNERR_NOCAPS, "DPNERR_NOCAPS")
        CHK_ERR(DPNERR_NOCONNECTION, "DPNERR_NOCONNECTION")
        CHK_ERR(DPNERR_NOHOSTPLAYER, "DPNERR_NOHOSTPLAYER")
        CHK_ERR(DPNERR_NOMOREADDRESSCOMPONENTS, "DPNERR_NOMOREADDRESSCOMPONENTS")
        CHK_ERR(DPNERR_NORESPONSE, "DPNERR_NORESPONSE")
        CHK_ERR(DPNERR_NOTALLOWED, "DPNERR_NOTALLOWED")
        CHK_ERR(DPNERR_NOTHOST, "DPNERR_NOTHOST")
        CHK_ERR(DPNERR_NOTREADY, "DPNERR_NOTREADY")
        CHK_ERR(DPNERR_NOTREGISTERED, "DPNERR_NOTREGISTERED")
        CHK_ERR(DPNERR_PLAYERLOST, "DPNERR_PLAYERLOST")
        CHK_ERR(DPNERR_SENDTOOLARGE, "DPNERR_SENDTOOLARGE")
        CHK_ERR(DPNERR_SESSIONFULL, "DPNERR_SESSIONFULL")
        CHK_ERR(DPNERR_TABLEFULL, "DPNERR_TABLEFULL")
        CHK_ERR(DPNERR_TIMEDOUT, "DPNERR_TIMEDOUT")
        CHK_ERR(DPNERR_UNINITIALIZED, "DPNERR_UNINITIALIZED")
        CHK_ERR(DPNERR_USERCANCEL, "DPNERR_USERCANCEL")
        
        CHK_ERR(DXFILEERR_BADOBJECT, "DXFILEERR_BADOBJECT")
        CHK_ERR(DXFILEERR_BADVALUE, "DXFILEERR_BADVALUE")
        CHK_ERR(DXFILEERR_BADTYPE, "DXFILEERR_BADTYPE")
        CHK_ERR(DXFILEERR_BADSTREAMHANDLE, "DXFILEERR_BADSTREAMHANDLE")
        CHK_ERR(DXFILEERR_BADALLOC, "DXFILEERR_BADALLOC")
        CHK_ERR(DXFILEERR_NOTFOUND, "DXFILEERR_NOTFOUND")
        CHK_ERR(DXFILEERR_NOTDONEYET, "DXFILEERR_NOTDONEYET")
        CHK_ERR(DXFILEERR_FILENOTFOUND, "DXFILEERR_FILENOTFOUND")
        CHK_ERR(DXFILEERR_RESOURCENOTFOUND, "DXFILEERR_RESOURCENOTFOUND")
        CHK_ERR(DXFILEERR_URLNOTFOUND, "DXFILEERR_URLNOTFOUND")
        CHK_ERR(DXFILEERR_BADRESOURCE, "DXFILEERR_BADRESOURCE")
        CHK_ERR(DXFILEERR_BADFILETYPE, "DXFILEERR_BADFILETYPE")
        CHK_ERR(DXFILEERR_BADFILEVERSION, "DXFILEERR_BADFILEVERSION")
        CHK_ERR(DXFILEERR_BADFILEFLOATSIZE, "DXFILEERR_BADFILEFLOATSIZE")
        CHK_ERR(DXFILEERR_BADFILECOMPRESSIONTYPE, "DXFILEERR_BADFILECOMPRESSIONTYPE")
        CHK_ERR(DXFILEERR_BADFILE, "DXFILEERR_BADFILE")
        CHK_ERR(DXFILEERR_PARSEERROR, "DXFILEERR_PARSEERROR")
        CHK_ERR(DXFILEERR_NOTEMPLATE, "DXFILEERR_NOTEMPLATE")
        CHK_ERR(DXFILEERR_BADARRAYSIZE, "DXFILEERR_BADARRAYSIZE")
        CHK_ERR(DXFILEERR_BADDATAREFERENCE, "DXFILEERR_BADDATAREFERENCE")
        CHK_ERR(DXFILEERR_INTERNALERROR, "DXFILEERR_INTERNALERROR")
        CHK_ERR(DXFILEERR_NOMOREOBJECTS, "DXFILEERR_NOMOREOBJECTS")
        CHK_ERR(DXFILEERR_BADINTRINSICS, "DXFILEERR_BADINTRINSICS")
        CHK_ERR(DXFILEERR_NOMORESTREAMHANDLES, "DXFILEERR_NOMORESTREAMHANDLES")
        CHK_ERR(DXFILEERR_NOMOREDATA, "DXFILEERR_NOMOREDATA")
        CHK_ERR(DXFILEERR_BADCACHEFILE, "DXFILEERR_BADCACHEFILE")
        CHK_ERR(DXFILEERR_NOINTERNET, "DXFILEERR_NOINTERNET")
        
        CHK_ERR(D3DERR_OUTOFVIDEOMEMORY, "D3DERR_OUTOFVIDEOMEMORY")
        CHK_ERR(D3DERR_WRONGTEXTUREFORMAT, "D3DERR_WRONGTEXTUREFORMAT")
        CHK_ERR(D3DERR_UNSUPPORTEDCOLOROPERATION, "D3DERR_UNSUPPORTEDCOLOROPERATION")
        CHK_ERR(D3DERR_UNSUPPORTEDCOLORARG, "D3DERR_UNSUPPORTEDCOLORARG")
        CHK_ERR(D3DERR_UNSUPPORTEDALPHAOPERATION, "D3DERR_UNSUPPORTEDALPHAOPERATION")
        CHK_ERR(D3DERR_UNSUPPORTEDALPHAARG, "D3DERR_UNSUPPORTEDALPHAARG")
        CHK_ERR(D3DERR_TOOMANYOPERATIONS, "D3DERR_TOOMANYOPERATIONS")
        CHK_ERR(D3DERR_CONFLICTINGTEXTUREFILTER, "D3DERR_CONFLICTINGTEXTUREFILTER")
        CHK_ERR(D3DERR_UNSUPPORTEDFACTORVALUE, "D3DERR_UNSUPPORTEDFACTORVALUE")
        CHK_ERR(D3DERR_CONFLICTINGRENDERSTATE, "D3DERR_CONFLICTINGRENDERSTATE")
        CHK_ERR(D3DERR_UNSUPPORTEDTEXTUREFILTER, "D3DERR_UNSUPPORTEDTEXTUREFILTER")
        CHK_ERR(D3DERR_CONFLICTINGTEXTUREPALETTE, "D3DERR_CONFLICTINGTEXTUREPALETTE")
        CHK_ERR(D3DERR_DRIVERINTERNALERROR, "D3DERR_DRIVERINTERNALERROR")
        CHK_ERR(D3DERR_NOTFOUND, "D3DERR_NOTFOUND")
        CHK_ERR(D3DERR_MOREDATA, "D3DERR_MOREDATA")
        CHK_ERR(D3DERR_DEVICELOST, "D3DERR_DEVICELOST")
        CHK_ERR(D3DERR_DEVICENOTRESET, "D3DERR_DEVICENOTRESET")
        CHK_ERR(D3DERR_NOTAVAILABLE, "D3DERR_NOTAVAILABLE")
        CHK_ERR(D3DERR_INVALIDDEVICE, "D3DERR_INVALIDDEVICE")
        CHK_ERR(D3DERR_INVALIDCALL, "D3DERR_INVALIDCALL")
        
        CHK_ERR(DSERR_ALLOCATED, "DSERR_ALLOCATED")
        CHK_ERR(DSERR_CONTROLUNAVAIL, "DSERR_CONTROLUNAVAIL")
        CHK_ERR(DSERR_INVALIDCALL, "DSERR_INVALIDCALL")
        CHK_ERR(DSERR_PRIOLEVELNEEDED, "DSERR_PRIOLEVELNEEDED")
        CHK_ERR(DSERR_BADFORMAT, "DSERR_BADFORMAT")
        CHK_ERR(DSERR_NODRIVER, "DSERR_NODRIVER")
        CHK_ERR(DSERR_ALREADYINITIALIZED, "DSERR_ALREADYINITIALIZED")
        CHK_ERR(DSERR_BUFFERLOST, "DSERR_BUFFERLOST")
        CHK_ERR(DSERR_OTHERAPPHASPRIO, "DSERR_OTHERAPPHASPRIO")
        CHK_ERR(DSERR_UNINITIALIZED, "DSERR_UNINITIALIZED")
      
        CHK_ERR(DMUS_E_DRIVER_FAILED, "DMUS_E_DRIVER_FAILED")
        CHK_ERR(DMUS_E_PORTS_OPEN, "DMUS_E_PORTS_OPEN")
        CHK_ERR(DMUS_E_DEVICE_IN_USE, "DMUS_E_DEVICE_IN_USE")
        CHK_ERR(DMUS_E_INSUFFICIENTBUFFER, "DMUS_E_INSUFFICIENTBUFFER")
        CHK_ERR(DMUS_E_BUFFERNOTSET, "DMUS_E_BUFFERNOTSET")
        CHK_ERR(DMUS_E_BUFFERNOTAVAILABLE, "DMUS_E_BUFFERNOTAVAILABLE")
        CHK_ERR(DMUS_E_NOTADLSCOL, "DMUS_E_NOTADLSCOL")
        CHK_ERR(DMUS_E_INVALIDOFFSET, "DMUS_E_INVALIDOFFSET")
        CHK_ERR(DMUS_E_ALREADY_LOADED, "DMUS_E_ALREADY_LOADED")
        CHK_ERR(DMUS_E_INVALIDPOS, "DMUS_E_INVALIDPOS")
        CHK_ERR(DMUS_E_INVALIDPATCH, "DMUS_E_INVALIDPATCH")
        CHK_ERR(DMUS_E_CANNOTSEEK, "DMUS_E_CANNOTSEEK")
        CHK_ERR(DMUS_E_CANNOTWRITE, "DMUS_E_CANNOTWRITE")
        CHK_ERR(DMUS_E_CHUNKNOTFOUND, "DMUS_E_CHUNKNOTFOUND")
        CHK_ERR(DMUS_E_INVALID_DOWNLOADID, "DMUS_E_INVALID_DOWNLOADID")
        CHK_ERR(DMUS_E_NOT_DOWNLOADED_TO_PORT, "DMUS_E_NOT_DOWNLOADED_TO_PORT")
        CHK_ERR(DMUS_E_ALREADY_DOWNLOADED, "DMUS_E_ALREADY_DOWNLOADED")
        CHK_ERR(DMUS_E_UNKNOWN_PROPERTY, "DMUS_E_UNKNOWN_PROPERTY")
        CHK_ERR(DMUS_E_SET_UNSUPPORTED, "DMUS_E_SET_UNSUPPORTED")
        CHK_ERR(DMUS_E_GET_UNSUPPORTED, "DMUS_E_GET_UNSUPPORTED")
        CHK_ERR(DMUS_E_NOTMONO, "DMUS_E_NOTMONO")
        CHK_ERR(DMUS_E_BADARTICULATION, "DMUS_E_BADARTICULATION")
        CHK_ERR(DMUS_E_BADINSTRUMENT, "DMUS_E_BADINSTRUMENT")
        CHK_ERR(DMUS_E_BADWAVELINK, "DMUS_E_BADWAVELINK")
        CHK_ERR(DMUS_E_NOARTICULATION, "DMUS_E_NOARTICULATION")
        CHK_ERR(DMUS_E_NOTPCM, "DMUS_E_NOTPCM")
        CHK_ERR(DMUS_E_BADWAVE, "DMUS_E_BADWAVE")
        CHK_ERR(DMUS_E_BADOFFSETTABLE, "DMUS_E_BADOFFSETTABLE")
        CHK_ERR(DMUS_E_UNKNOWNDOWNLOAD, "DMUS_E_UNKNOWNDOWNLOAD")
        CHK_ERR(DMUS_E_NOSYNTHSINK, "DMUS_E_NOSYNTHSINK")
        CHK_ERR(DMUS_E_ALREADYOPEN, "DMUS_E_ALREADYOPEN")
        CHK_ERR(DMUS_E_ALREADYCLOSED, "DMUS_E_ALREADYCLOSED")
        CHK_ERR(DMUS_E_SYNTHNOTCONFIGURED, "DMUS_E_SYNTHNOTCONFIGURED")
        CHK_ERR(DMUS_E_SYNTHACTIVE, "DMUS_E_SYNTHACTIVE")
        CHK_ERR(DMUS_E_CANNOTREAD, "DMUS_E_CANNOTREAD")
        CHK_ERR(DMUS_E_DMUSIC_RELEASED, "DMUS_E_DMUSIC_RELEASED")
        CHK_ERR(DMUS_E_BUFFER_EMPTY, "DMUS_E_BUFFER_EMPTY")
        CHK_ERR(DMUS_E_BUFFER_FULL, "DMUS_E_BUFFER_FULL")
        CHK_ERR(DMUS_E_PORT_NOT_CAPTURE, "DMUS_E_PORT_NOT_CAPTURE")
        CHK_ERR(DMUS_E_PORT_NOT_RENDER, "DMUS_E_PORT_NOT_RENDER")
        CHK_ERR(DMUS_E_DSOUND_NOT_SET, "DMUS_E_DSOUND_NOT_SET")
        CHK_ERR(DMUS_E_ALREADY_ACTIVATED, "DMUS_E_ALREADY_ACTIVATED")
        CHK_ERR(DMUS_E_INVALIDBUFFER, "DMUS_E_INVALIDBUFFER")
        CHK_ERR(DMUS_E_WAVEFORMATNOTSUPPORTED, "DMUS_E_WAVEFORMATNOTSUPPORTED")
        CHK_ERR(DMUS_E_SYNTHINACTIVE, "DMUS_E_SYNTHINACTIVE")
        CHK_ERR(DMUS_E_DSOUND_ALREADY_SET, "DMUS_E_DSOUND_ALREADY_SET")
        CHK_ERR(DMUS_E_INVALID_EVENT, "DMUS_E_INVALID_EVENT")
        CHK_ERR(DMUS_E_UNSUPPORTED_STREAM, "DMUS_E_UNSUPPORTED_STREAM")
        CHK_ERR(DMUS_E_ALREADY_INITED, "DMUS_E_ALREADY_INITED")
        CHK_ERR(DMUS_E_INVALID_BAND, "DMUS_E_INVALID_BAND")
        CHK_ERR(DMUS_E_TRACK_HDR_NOT_FIRST_CK, "DMUS_E_TRACK_HDR_NOT_FIRST_CK")
        CHK_ERR(DMUS_E_TOOL_HDR_NOT_FIRST_CK, "DMUS_E_TOOL_HDR_NOT_FIRST_CK")
        CHK_ERR(DMUS_E_INVALID_TRACK_HDR, "DMUS_E_INVALID_TRACK_HDR")
        CHK_ERR(DMUS_E_INVALID_TOOL_HDR, "DMUS_E_INVALID_TOOL_HDR")
        CHK_ERR(DMUS_E_ALL_TOOLS_FAILED, "DMUS_E_ALL_TOOLS_FAILED")
        CHK_ERR(DMUS_E_ALL_TRACKS_FAILED, "DMUS_E_ALL_TRACKS_FAILED")
        CHK_ERR(DMUS_E_NOT_FOUND, "DMUS_E_NOT_FOUND")
        CHK_ERR(DMUS_E_NOT_INIT, "DMUS_E_NOT_INIT")
        CHK_ERR(DMUS_E_TYPE_DISABLED, "DMUS_E_TYPE_DISABLED")
        CHK_ERR(DMUS_E_TYPE_UNSUPPORTED, "DMUS_E_TYPE_UNSUPPORTED")
        CHK_ERR(DMUS_E_TIME_PAST, "DMUS_E_TIME_PAST")
        CHK_ERR(DMUS_E_TRACK_NOT_FOUND, "DMUS_E_TRACK_NOT_FOUND")
        CHK_ERR(DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT, "DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT")
        CHK_ERR(DMUS_E_NO_MASTER_CLOCK, "DMUS_E_NO_MASTER_CLOCK")
        CHK_ERR(DMUS_E_LOADER_NOCLASSID, "DMUS_E_LOADER_NOCLASSID")
        CHK_ERR(DMUS_E_LOADER_BADPATH, "DMUS_E_LOADER_BADPATH")
        CHK_ERR(DMUS_E_LOADER_FAILEDOPEN, "DMUS_E_LOADER_FAILEDOPEN")
        CHK_ERR(DMUS_E_LOADER_FORMATNOTSUPPORTED, "DMUS_E_LOADER_FORMATNOTSUPPORTED")
        CHK_ERR(DMUS_E_LOADER_FAILEDCREATE, "DMUS_E_LOADER_FAILEDCREATE")
        CHK_ERR(DMUS_E_LOADER_OBJECTNOTFOUND, "DMUS_E_LOADER_OBJECTNOTFOUND")
        CHK_ERR(DMUS_E_LOADER_NOFILENAME, "DMUS_E_LOADER_NOFILENAME")
        CHK_ERR(DMUS_E_INVALIDFILE, "DMUS_E_INVALIDFILE")
        CHK_ERR(DMUS_E_ALREADY_EXISTS, "DMUS_E_ALREADY_EXISTS")
        CHK_ERR(DMUS_E_OUT_OF_RANGE, "DMUS_E_OUT_OF_RANGE")
        CHK_ERR(DMUS_E_SEGMENT_INIT_FAILED, "DMUS_E_SEGMENT_INIT_FAILED")
        CHK_ERR(DMUS_E_ALREADY_SENT, "DMUS_E_ALREADY_SENT")
        CHK_ERR(DMUS_E_CANNOT_FREE, "DMUS_E_CANNOT_FREE")
        CHK_ERR(DMUS_E_CANNOT_OPEN_PORT, "DMUS_E_CANNOT_OPEN_PORT")
        CHK_ERR(DMUS_E_CANNOT_CONVERT, "DMUS_E_CANNOT_CONVERT")
        CHK_ERR(DMUS_E_DESCEND_CHUNK_FAIL, "DMUS_E_DESCEND_CHUNK_FAIL")
        CHK_ERR(DMUS_E_NOT_LOADED, "DMUS_E_NOT_LOADED")
        CHK_ERR(DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE, "DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE")
        CHK_ERR(DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE, "DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE")
        CHK_ERR(DMUS_E_SCRIPT_ERROR_IN_SCRIPT, "DMUS_E_SCRIPT_ERROR_IN_SCRIPT")
        CHK_ERR(DMUS_E_SCRIPT_CANTLOAD_OLEAUT32, "DMUS_E_SCRIPT_CANTLOAD_OLEAUT32")
        CHK_ERR(DMUS_E_SCRIPT_LOADSCRIPT_ERROR, "DMUS_E_SCRIPT_LOADSCRIPT_ERROR")
        CHK_ERR(DMUS_E_SCRIPT_INVALID_FILE, "DMUS_E_SCRIPT_INVALID_FILE")
        CHK_ERR(DMUS_E_INVALID_SCRIPTTRACK, "DMUS_E_INVALID_SCRIPTTRACK")
        CHK_ERR(DMUS_E_SCRIPT_VARIABLE_NOT_FOUND, "DMUS_E_SCRIPT_VARIABLE_NOT_FOUND")
        CHK_ERR(DMUS_E_SCRIPT_ROUTINE_NOT_FOUND, "DMUS_E_SCRIPT_ROUTINE_NOT_FOUND")
        CHK_ERR(DMUS_E_INVALID_SEGMENTTRIGGERTRACK, "DMUS_E_INVALID_SEGMENTTRIGGERTRACK")
        CHK_ERR(DMUS_E_INVALID_LYRICSTRACK, "DMUS_E_INVALID_LYRICSTRACK")
        CHK_ERR(DMUS_E_INVALID_PARAMCONTROLTRACK, "DMUS_E_INVALID_PARAMCONTROLTRACK")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR, "DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR, "DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE, "DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE")
        CHK_ERR(DMUS_E_AUDIOPATHS_NOT_VALID, "DMUS_E_AUDIOPATHS_NOT_VALID")
        CHK_ERR(DMUS_E_AUDIOPATHS_IN_USE, "DMUS_E_AUDIOPATHS_IN_USE")
        CHK_ERR(DMUS_E_NO_AUDIOPATH_CONFIG, "DMUS_E_NO_AUDIOPATH_CONFIG")
        CHK_ERR(DMUS_E_AUDIOPATH_INACTIVE, "DMUS_E_AUDIOPATH_INACTIVE")
        CHK_ERR(DMUS_E_AUDIOPATH_NOBUFFER, "DMUS_E_AUDIOPATH_NOBUFFER")
        CHK_ERR(DMUS_E_AUDIOPATH_NOPORT, "DMUS_E_AUDIOPATH_NOPORT")
        CHK_ERR(DMUS_E_NO_AUDIOPATH, "DMUS_E_NO_AUDIOPATH")
        CHK_ERR(DMUS_E_INVALIDCHUNK, "DMUS_E_INVALIDCHUNK")      
        CHK_ERR(DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER, "DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER")
        CHK_ERR(DMUS_E_INVALID_CONTAINER_OBJECT, "DMUS_E_INVALID_CONTAINER_OBJECT")    

        /* NO APPMAN SUPPORT FOR NOW
        CHK_ERR(APPMAN_E_NOTINITIALIZED, "APPMAN_E_NOTINITIALIZED")
        CHK_ERR(APPMAN_E_INVALIDPROPERTYSIZE, "APPMAN_E_INVALIDPROPERTYSIZE")
        CHK_ERR(APPMAN_E_INVALIDDATA, "APPMAN_E_INVALIDDATA")
        CHK_ERR(APPMAN_E_INVALIDPROPERTY, "APPMAN_E_INVALIDPROPERTY")
        CHK_ERR(APPMAN_E_READONLYPROPERTY, "APPMAN_E_READONLYPROPERTY")
        CHK_ERR(APPMAN_E_PROPERTYNOTSET, "APPMAN_E_PROPERTYNOTSET")
        CHK_ERR(APPMAN_E_OVERFLOW, "APPMAN_E_OVERFLOW")
        CHK_ERR(APPMAN_E_INVALIDPROPERTYVALUE, "APPMAN_E_INVALIDPROPERTYVALUE")
        CHK_ERR(APPMAN_E_ACTIONINPROGRESS, "APPMAN_E_ACTIONINPROGRESS")
        CHK_ERR(APPMAN_E_ACTIONNOTINITIALIZED, "APPMAN_E_ACTIONNOTINITIALIZED")
        CHK_ERR(APPMAN_E_REQUIREDPROPERTIESMISSING, "APPMAN_E_REQUIREDPROPERTIESMISSING")
        CHK_ERR(APPMAN_E_APPLICATIONALREADYEXISTS, "APPMAN_E_APPLICATIONALREADYEXISTS")
        CHK_ERR(APPMAN_E_APPLICATIONALREADYLOCKED, "APPMAN_E_APPLICATIONALREADYLOCKED")
        CHK_ERR(APPMAN_E_NODISKSPACEAVAILABLE, "APPMAN_E_NODISKSPACEAVAILABLE")
        CHK_ERR(APPMAN_E_UNKNOWNAPPLICATION, "APPMAN_E_UNKNOWNAPPLICATION")
        CHK_ERR(APPMAN_E_INVALIDPARAMETERS, "APPMAN_E_INVALIDPARAMETERS")
        CHK_ERR(APPMAN_E_OBJECTLOCKED, "APPMAN_E_OBJECTLOCKED")
        CHK_ERR(APPMAN_E_INVALIDINDEX, "APPMAN_E_INVALIDINDEX")
        CHK_ERR(APPMAN_E_REGISTRYCORRUPT, "APPMAN_E_REGISTRYCORRUPT")
        CHK_ERR(APPMAN_E_CANNOTASSOCIATE, "APPMAN_E_CANNOTASSOCIATE")
        CHK_ERR(APPMAN_E_INVALIDASSOCIATION, "APPMAN_E_INVALIDASSOCIATION")
        CHK_ERR(APPMAN_E_ALREADYASSOCIATED, "APPMAN_E_ALREADYASSOCIATED")
        CHK_ERR(APPMAN_E_APPLICATIONREQUIRED, "APPMAN_E_APPLICATIONREQUIRED")
        CHK_ERR(APPMAN_E_INVALIDEXECUTECMDLINE, "APPMAN_E_INVALIDEXECUTECMDLINE")
        CHK_ERR(APPMAN_E_INVALIDDOWNSIZECMDLINE, "APPMAN_E_INVALIDDOWNSIZECMDLINE")
        CHK_ERR(APPMAN_E_INVALIDREINSTALLCMDLINE, "APPMAN_E_INVALIDREINSTALLCMDLINE")
        CHK_ERR(APPMAN_E_INVALIDUNINSTALLCMDLINE, "APPMAN_E_INVALIDUNINSTALLCMDLINE")
        CHK_ERR(APPMAN_E_INVALIDSELFTESTCMDLINE, "APPMAN_E_INVALIDSELFTESTCMDLINE")
        CHK_ERR(APPMAN_E_PARENTAPPNOTREADY, "APPMAN_E_PARENTAPPNOTREADY")
        CHK_ERR(APPMAN_E_INVALIDSTATE, "APPMAN_E_INVALIDSTATE")
        CHK_ERR(APPMAN_E_INVALIDROOTPATH, "APPMAN_E_INVALIDROOTPATH")
        CHK_ERR(APPMAN_E_CACHEOVERRUN, "APPMAN_E_CACHEOVERRUN")
        CHK_ERR(APPMAN_E_REINSTALLDX, "APPMAN_E_REINSTALLDX")
        */
   }
   
   return "Unknown";
}

















/****************************************************/
/* DXGetErrorString8W                               */
/*                                                  */
/****************************************************/
const WCHAR * __stdcall DXGetErrorString8W(HRESULT hr)
{
   switch(hr)
   {             
        // Common Win32 error codes
        CHK_ERR(S_OK, L"S_OK")
        CHK_ERR(S_FALSE, L"S_FALSE")

        CHK_ERR(E_UNEXPECTED, L"E_UNEXPECTED")
        CHK_ERR(E_NOTIMPL, L"E_NOTIMPL")
        CHK_ERR(E_OUTOFMEMORY, L"E_OUTOFMEMORY")
        CHK_ERR(E_INVALIDARG, L"E_INVALIDARG")
        CHK_ERR(E_NOINTERFACE, L"E_NOINTERFACE")
        CHK_ERR(E_POINTER, L"E_POINTER")
        CHK_ERR(E_HANDLE, L"E_HANDLE")
        CHK_ERR(E_ABORT, L"E_ABORT")
        CHK_ERR(E_FAIL, L"E_FAIL")
        CHK_ERR(E_ACCESSDENIED, L"E_ACCESSDENIED")
        CHK_ERR(E_PENDING, L"E_PENDING")
        CHK_ERR(REGDB_E_CLASSNOTREG, L"REGDB_E_CLASSNOTREG")
        CHK_ERR(CO_E_NOTINITIALIZED, L"CO_E_NOTINITIALIZED")
        CHK_ERR(CO_E_ALREADYINITIALIZED, L"CO_E_ALREADYINITIALIZED")

//      CHK_ERR(DIERR_GENERIC, L"E_FAIL")
        CHK_ERR(DIERR_NOAGGREGATION, L"E_NOAGGREGATION")
        CHK_ERR(DIERR_INSUFFICIENTPRIVS, L"DIERR_INSUFFICIENTPRIVS")
        CHK_ERR(DIERR_DEVICEFULL, L"DIERR_DEVICEFULL")
        CHK_ERR(DIERR_MOREDATA, L"DIERR_MOREDATA")
        CHK_ERR(DIERR_NOTDOWNLOADED, L"DIERR_NOTDOWNLOADED")
        CHK_ERR(DIERR_HASEFFECTS, L"DIERR_HASEFFECTS")
        CHK_ERR(DIERR_NOTEXCLUSIVEACQUIRED, L"DIERR_NOTEXCLUSIVEACQUIRED")
        CHK_ERR(DIERR_INCOMPLETEEFFECT, L"DIERR_INCOMPLETEEFFECT")
        CHK_ERR(DIERR_NOTBUFFERED, L"DIERR_NOTBUFFERED")
        CHK_ERR(DIERR_EFFECTPLAYING, L"DIERR_EFFECTPLAYING")
        CHK_ERR(DIERR_UNPLUGGED, L"DIERR_UNPLUGGED")
        CHK_ERR(DIERR_REPORTFULL, L"DIERR_REPORTFULL")
        CHK_ERR(DIERR_DRIVERFIRST, L"DIERR_DRIVERFIRST")
        CHK_ERR(DIERR_DRIVERLAST, L"DIERR_DRIVERLAST")
        CHK_ERR(DIERR_INVALIDCLASSINSTALLER, L"DIERR_INVALIDCLASSINSTALLER")
        CHK_ERR(DIERR_CANCELLED, L"DIERR_CANCELLED")
        CHK_ERR(DIERR_BADINF, L"DIERR_BADINF")
        CHK_ERR(DIERR_NOTFOUND, L"DIERR_NOTFOUND or DIERR_NOTFOUND")
//      CHK_ERR(DIERR_READONLY, L"DIERR_READONLY or DIERR_OTHERAPPHASPRIO or DIERR_HANDLEEXISTS or DSERR_ACCESSDENIED")
        CHK_ERR(DIERR_NOTACQUIRED, L"DIERR_NOTACQUIRED")
//      CHK_ERR(DIERR_OUTOFMEMORY, L"E_OUTOFMEMORY")
        CHK_ERR(DIERR_NOTINITIALIZED, L"DIERR_NOTINITIALIZED")
        CHK_ERR(DIERR_INPUTLOST, L"DIERR_INPUTLOST")
        CHK_ERR(DIERR_BADDRIVERVER, L"DIERR_BADDRIVERVER")
        CHK_ERR(DIERR_ACQUIRED, L"DIERR_ACQUIRED")
        CHK_ERR(DIERR_NOMOREITEMS, L"DIERR_NOMOREITEMS")
        CHK_ERR(DIERR_OLDDIRECTINPUTVERSION, L"DIERR_OLDDIRECTINPUTVERSION")
        CHK_ERR(DIERR_BETADIRECTINPUTVERSION, L"DIERR_BETADIRECTINPUTVERSION")
        CHK_ERR(DIERR_ALREADYINITIALIZED, L"DIERR_ALREADYINITIALIZED")
                
        CHK_ERR(DVERR_BUFFERTOOSMALL, L"DVERR_BUFFERTOOSMALL")
        CHK_ERR(DVERR_EXCEPTION, L"DVERR_EXCEPTION")
        CHK_ERR(DVERR_INVALIDFLAGS, L"DVERR_INVALIDFLAGS")
        CHK_ERR(DVERR_INVALIDOBJECT, L"DVERR_INVALIDOBJECT")
        CHK_ERR(DVERR_INVALIDPLAYER, L"DVERR_INVALIDPLAYER")
        CHK_ERR(DVERR_INVALIDGROUP, L"DVERR_INVALIDGROUP")
        CHK_ERR(DVERR_INVALIDHANDLE, L"DVERR_INVALIDHANDLE")
        CHK_ERR(DVERR_SESSIONLOST, L"DVERR_SESSIONLOST")
        CHK_ERR(DVERR_NOVOICESESSION, L"DVERR_NOVOICESESSION")
        CHK_ERR(DVERR_CONNECTIONLOST, L"DVERR_CONNECTIONLOST")
        CHK_ERR(DVERR_NOTINITIALIZED, L"DVERR_NOTINITIALIZED")
        CHK_ERR(DVERR_CONNECTED, L"DVERR_CONNECTED")
        CHK_ERR(DVERR_NOTCONNECTED, L"DVERR_NOTCONNECTED")
        CHK_ERR(DVERR_CONNECTABORTING, L"DVERR_CONNECTABORTING")
        CHK_ERR(DVERR_NOTALLOWED, L"DVERR_NOTALLOWED")
        CHK_ERR(DVERR_INVALIDTARGET, L"DVERR_INVALIDTARGET")
        CHK_ERR(DVERR_TRANSPORTNOTHOST, L"DVERR_TRANSPORTNOTHOST")
        CHK_ERR(DVERR_COMPRESSIONNOTSUPPORTED, L"DVERR_COMPRESSIONNOTSUPPORTED")
        CHK_ERR(DVERR_ALREADYPENDING, L"DVERR_ALREADYPENDING")
        CHK_ERR(DVERR_SOUNDINITFAILURE, L"DVERR_SOUNDINITFAILURE")
        CHK_ERR(DVERR_TIMEOUT, L"DVERR_TIMEOUT")
        CHK_ERR(DVERR_CONNECTABORTED, L"DVERR_CONNECTABORTED")
        CHK_ERR(DVERR_NO3DSOUND, L"DVERR_NO3DSOUND")
        CHK_ERR(DVERR_ALREADYBUFFERED, L"DVERR_ALREADYBUFFERED")
        CHK_ERR(DVERR_NOTBUFFERED, L"DVERR_NOTBUFFERED")
        CHK_ERR(DVERR_HOSTING, L"DVERR_HOSTING")
        CHK_ERR(DVERR_NOTHOSTING, L"DVERR_NOTHOSTING")
        CHK_ERR(DVERR_INVALIDDEVICE, L"DVERR_INVALIDDEVICE")
        CHK_ERR(DVERR_RECORDSYSTEMERROR, L"DVERR_RECORDSYSTEMERROR")
        CHK_ERR(DVERR_PLAYBACKSYSTEMERROR, L"DVERR_PLAYBACKSYSTEMERROR")
        CHK_ERR(DVERR_SENDERROR, L"DVERR_SENDERROR")
        CHK_ERR(DVERR_USERCANCEL, L"DVERR_USERCANCEL")
        CHK_ERR(DVERR_RUNSETUP, L"DVERR_RUNSETUP")
        CHK_ERR(DVERR_INCOMPATIBLEVERSION, L"DVERR_INCOMPATIBLEVERSION")
        CHK_ERR(DVERR_INITIALIZED, L"DVERR_INITIALIZED")
        CHK_ERR(DVERR_NOTRANSPORT, L"DVERR_NOTRANSPORT")
        CHK_ERR(DVERR_NOCALLBACK, L"DVERR_NOCALLBACK")
        CHK_ERR(DVERR_TRANSPORTNOTINIT, L"DVERR_TRANSPORTNOTINIT")
        CHK_ERR(DVERR_TRANSPORTNOSESSION, L"DVERR_TRANSPORTNOSESSION")
        CHK_ERR(DVERR_TRANSPORTNOPLAYER, L"DVERR_TRANSPORTNOPLAYER")
        CHK_ERR(DVERR_USERBACK, L"DVERR_USERBACK")
        CHK_ERR(DVERR_NORECVOLAVAILABLE, L"DVERR_NORECVOLAVAILABLE")
        
        CHK_ERR(DPNERR_ABORTED, L"DPNERR_ABORTED")
        CHK_ERR(DPNERR_ADDRESSING, L"DPNERR_ADDRESSING")
        CHK_ERR(DPNERR_ALREADYCONNECTED, L"DPNERR_ALREADYCONNECTED")
        CHK_ERR(DPNERR_ALREADYDISCONNECTING, L"DPNERR_ALREADYDISCONNECTING")
        CHK_ERR(DPNERR_ALREADYINITIALIZED, L"DPNERR_ALREADYINITIALIZED")
        CHK_ERR(DPNERR_ALREADYREGISTERED, L"DPNERR_ALREADYREGISTERED")
        CHK_ERR(DPNERR_BUFFERTOOSMALL, L"DPNERR_BUFFERTOOSMALL")
        CHK_ERR(DPNERR_CANNOTCANCEL, L"DPNERR_CANNOTCANCEL")
        CHK_ERR(DPNERR_CANTCREATEGROUP, L"DPNERR_CANTCREATEGROUP")
        CHK_ERR(DPNERR_CANTCREATEPLAYER, L"DPNERR_CANTCREATEPLAYER")
        CHK_ERR(DPNERR_CANTLAUNCHAPPLICATION, L"DPNERR_CANTLAUNCHAPPLICATION")
        CHK_ERR(DPNERR_CONNECTING, L"DPNERR_CONNECTING")
        CHK_ERR(DPNERR_CONNECTIONLOST, L"DPNERR_CONNECTIONLOST")
        CHK_ERR(DPNERR_CONVERSION, L"DPNERR_CONVERSION")
        CHK_ERR(DPNERR_DOESNOTEXIST, L"DPNERR_DOESNOTEXIST")
        CHK_ERR(DPNERR_DUPLICATECOMMAND, L"DPNERR_DUPLICATECOMMAND")
        CHK_ERR(DPNERR_ENDPOINTNOTRECEIVING, L"DPNERR_ENDPOINTNOTRECEIVING")
        CHK_ERR(DPNERR_EXCEPTION, L"DPNERR_EXCEPTION")
        CHK_ERR(DPNERR_GROUPNOTEMPTY, L"DPNERR_GROUPNOTEMPTY")
        CHK_ERR(DPNERR_HOSTING, L"DPNERR_HOSTING")
        CHK_ERR(DPNERR_HOSTREJECTEDCONNECTION, L"DPNERR_HOSTREJECTEDCONNECTION")
        CHK_ERR(DPNERR_INCOMPLETEADDRESS, L"DPNERR_INCOMPLETEADDRESS")
        CHK_ERR(DPNERR_INVALIDADDRESSFORMAT, L"DPNERR_INVALIDADDRESSFORMAT")
        CHK_ERR(DPNERR_INVALIDAPPLICATION, L"DPNERR_INVALIDAPPLICATION")
        CHK_ERR(DPNERR_INVALIDCOMMAND, L"DPNERR_INVALIDCOMMAND")
        CHK_ERR(DPNERR_INVALIDENDPOINT, L"DPNERR_INVALIDENDPOINT")
        CHK_ERR(DPNERR_INVALIDFLAGS, L"DPNERR_INVALIDFLAGS")
        CHK_ERR(DPNERR_INVALIDGROUP, L"DPNERR_INVALIDGROUP")
        CHK_ERR(DPNERR_INVALIDHANDLE, L"DPNERR_INVALIDHANDLE")
        CHK_ERR(DPNERR_INVALIDINSTANCE, L"DPNERR_INVALIDINSTANCE")
        CHK_ERR(DPNERR_INVALIDINTERFACE, L"DPNERR_INVALIDINTERFACE")
        CHK_ERR(DPNERR_INVALIDDEVICEADDRESS, L"DPNERR_INVALIDDEVICEADDRESS")
        CHK_ERR(DPNERR_INVALIDOBJECT, L"DPNERR_INVALIDOBJECT")
        CHK_ERR(DPNERR_INVALIDPASSWORD, L"DPNERR_INVALIDPASSWORD")
        CHK_ERR(DPNERR_INVALIDPLAYER, L"DPNERR_INVALIDPLAYER")
        CHK_ERR(DPNERR_INVALIDPRIORITY, L"DPNERR_INVALIDPRIORITY")
        CHK_ERR(DPNERR_INVALIDHOSTADDRESS, L"DPNERR_INVALIDHOSTADDRESS")
        CHK_ERR(DPNERR_INVALIDSTRING, L"DPNERR_INVALIDSTRING")
        CHK_ERR(DPNERR_INVALIDURL, L"DPNERR_INVALIDURL")
        CHK_ERR(DPNERR_NOCAPS, L"DPNERR_NOCAPS")
        CHK_ERR(DPNERR_NOCONNECTION, L"DPNERR_NOCONNECTION")
        CHK_ERR(DPNERR_NOHOSTPLAYER, L"DPNERR_NOHOSTPLAYER")
        CHK_ERR(DPNERR_NOMOREADDRESSCOMPONENTS, L"DPNERR_NOMOREADDRESSCOMPONENTS")
        CHK_ERR(DPNERR_NORESPONSE, L"DPNERR_NORESPONSE")
        CHK_ERR(DPNERR_NOTALLOWED, L"DPNERR_NOTALLOWED")
        CHK_ERR(DPNERR_NOTHOST, L"DPNERR_NOTHOST")
        CHK_ERR(DPNERR_NOTREADY, L"DPNERR_NOTREADY")
        CHK_ERR(DPNERR_NOTREGISTERED, L"DPNERR_NOTREGISTERED")
        CHK_ERR(DPNERR_PLAYERLOST, L"DPNERR_PLAYERLOST")
        CHK_ERR(DPNERR_SENDTOOLARGE, L"DPNERR_SENDTOOLARGE")
        CHK_ERR(DPNERR_SESSIONFULL, L"DPNERR_SESSIONFULL")
        CHK_ERR(DPNERR_TABLEFULL, L"DPNERR_TABLEFULL")
        CHK_ERR(DPNERR_TIMEDOUT, L"DPNERR_TIMEDOUT")
        CHK_ERR(DPNERR_UNINITIALIZED, L"DPNERR_UNINITIALIZED")
        CHK_ERR(DPNERR_USERCANCEL, L"DPNERR_USERCANCEL")
        
        CHK_ERR(DXFILEERR_BADOBJECT, L"DXFILEERR_BADOBJECT")
        CHK_ERR(DXFILEERR_BADVALUE, L"DXFILEERR_BADVALUE")
        CHK_ERR(DXFILEERR_BADTYPE, L"DXFILEERR_BADTYPE")
        CHK_ERR(DXFILEERR_BADSTREAMHANDLE, L"DXFILEERR_BADSTREAMHANDLE")
        CHK_ERR(DXFILEERR_BADALLOC, L"DXFILEERR_BADALLOC")
        CHK_ERR(DXFILEERR_NOTFOUND, L"DXFILEERR_NOTFOUND")
        CHK_ERR(DXFILEERR_NOTDONEYET, L"DXFILEERR_NOTDONEYET")
        CHK_ERR(DXFILEERR_FILENOTFOUND, L"DXFILEERR_FILENOTFOUND")
        CHK_ERR(DXFILEERR_RESOURCENOTFOUND, L"DXFILEERR_RESOURCENOTFOUND")
        CHK_ERR(DXFILEERR_URLNOTFOUND, L"DXFILEERR_URLNOTFOUND")
        CHK_ERR(DXFILEERR_BADRESOURCE, L"DXFILEERR_BADRESOURCE")
        CHK_ERR(DXFILEERR_BADFILETYPE, L"DXFILEERR_BADFILETYPE")
        CHK_ERR(DXFILEERR_BADFILEVERSION, L"DXFILEERR_BADFILEVERSION")
        CHK_ERR(DXFILEERR_BADFILEFLOATSIZE, L"DXFILEERR_BADFILEFLOATSIZE")
        CHK_ERR(DXFILEERR_BADFILECOMPRESSIONTYPE, L"DXFILEERR_BADFILECOMPRESSIONTYPE")
        CHK_ERR(DXFILEERR_BADFILE, L"DXFILEERR_BADFILE")
        CHK_ERR(DXFILEERR_PARSEERROR, L"DXFILEERR_PARSEERROR")
        CHK_ERR(DXFILEERR_NOTEMPLATE, L"DXFILEERR_NOTEMPLATE")
        CHK_ERR(DXFILEERR_BADARRAYSIZE, L"DXFILEERR_BADARRAYSIZE")
        CHK_ERR(DXFILEERR_BADDATAREFERENCE, L"DXFILEERR_BADDATAREFERENCE")
        CHK_ERR(DXFILEERR_INTERNALERROR, L"DXFILEERR_INTERNALERROR")
        CHK_ERR(DXFILEERR_NOMOREOBJECTS, L"DXFILEERR_NOMOREOBJECTS")
        CHK_ERR(DXFILEERR_BADINTRINSICS, L"DXFILEERR_BADINTRINSICS")
        CHK_ERR(DXFILEERR_NOMORESTREAMHANDLES, L"DXFILEERR_NOMORESTREAMHANDLES")
        CHK_ERR(DXFILEERR_NOMOREDATA, L"DXFILEERR_NOMOREDATA")
        CHK_ERR(DXFILEERR_BADCACHEFILE, L"DXFILEERR_BADCACHEFILE")
        CHK_ERR(DXFILEERR_NOINTERNET, L"DXFILEERR_NOINTERNET")

        CHK_ERR(D3DERR_OUTOFVIDEOMEMORY, L"D3DERR_OUTOFVIDEOMEMORY")
        CHK_ERR(D3DERR_WRONGTEXTUREFORMAT, L"D3DERR_WRONGTEXTUREFORMAT")
        CHK_ERR(D3DERR_UNSUPPORTEDCOLOROPERATION, L"D3DERR_UNSUPPORTEDCOLOROPERATION")
        CHK_ERR(D3DERR_UNSUPPORTEDCOLORARG, L"D3DERR_UNSUPPORTEDCOLORARG")
        CHK_ERR(D3DERR_UNSUPPORTEDALPHAOPERATION, L"D3DERR_UNSUPPORTEDALPHAOPERATION")
        CHK_ERR(D3DERR_UNSUPPORTEDALPHAARG, L"D3DERR_UNSUPPORTEDALPHAARG")
        CHK_ERR(D3DERR_TOOMANYOPERATIONS, L"D3DERR_TOOMANYOPERATIONS")
        CHK_ERR(D3DERR_CONFLICTINGTEXTUREFILTER, L"D3DERR_CONFLICTINGTEXTUREFILTER")
        CHK_ERR(D3DERR_UNSUPPORTEDFACTORVALUE, L"D3DERR_UNSUPPORTEDFACTORVALUE")
        CHK_ERR(D3DERR_CONFLICTINGRENDERSTATE, L"D3DERR_CONFLICTINGRENDERSTATE")
        CHK_ERR(D3DERR_UNSUPPORTEDTEXTUREFILTER, L"D3DERR_UNSUPPORTEDTEXTUREFILTER")
        CHK_ERR(D3DERR_CONFLICTINGTEXTUREPALETTE, L"D3DERR_CONFLICTINGTEXTUREPALETTE")
        CHK_ERR(D3DERR_DRIVERINTERNALERROR, L"D3DERR_DRIVERINTERNALERROR")
        CHK_ERR(D3DERR_NOTFOUND, L"D3DERR_NOTFOUND")
        CHK_ERR(D3DERR_MOREDATA, L"D3DERR_MOREDATA")
        CHK_ERR(D3DERR_DEVICELOST, L"D3DERR_DEVICELOST")
        CHK_ERR(D3DERR_DEVICENOTRESET, L"D3DERR_DEVICENOTRESET")
        CHK_ERR(D3DERR_NOTAVAILABLE, L"D3DERR_NOTAVAILABLE")
        CHK_ERR(D3DERR_INVALIDDEVICE, L"D3DERR_INVALIDDEVICE")
        CHK_ERR(D3DERR_INVALIDCALL, L"D3DERR_INVALIDCALL")
        
        CHK_ERR(DSERR_ALLOCATED, L"DSERR_ALLOCATED")
        CHK_ERR(DSERR_CONTROLUNAVAIL, L"DSERR_CONTROLUNAVAIL")
        CHK_ERR(DSERR_INVALIDCALL, L"DSERR_INVALIDCALL")
        CHK_ERR(DSERR_PRIOLEVELNEEDED, L"DSERR_PRIOLEVELNEEDED")
        CHK_ERR(DSERR_BADFORMAT, L"DSERR_BADFORMAT")
        CHK_ERR(DSERR_NODRIVER, L"DSERR_NODRIVER")
        CHK_ERR(DSERR_ALREADYINITIALIZED, L"DSERR_ALREADYINITIALIZED")
        CHK_ERR(DSERR_BUFFERLOST, L"DSERR_BUFFERLOST")
        CHK_ERR(DSERR_OTHERAPPHASPRIO, L"DSERR_OTHERAPPHASPRIO")
        CHK_ERR(DSERR_UNINITIALIZED, L"DSERR_UNINITIALIZED")
        
        CHK_ERR(DMUS_E_DRIVER_FAILED, L"DMUS_E_DRIVER_FAILED")
        CHK_ERR(DMUS_E_PORTS_OPEN, L"DMUS_E_PORTS_OPEN")
        CHK_ERR(DMUS_E_DEVICE_IN_USE, L"DMUS_E_DEVICE_IN_USE")
        CHK_ERR(DMUS_E_INSUFFICIENTBUFFER, L"DMUS_E_INSUFFICIENTBUFFER")
        CHK_ERR(DMUS_E_BUFFERNOTSET, L"DMUS_E_BUFFERNOTSET")
        CHK_ERR(DMUS_E_BUFFERNOTAVAILABLE, L"DMUS_E_BUFFERNOTAVAILABLE")
        CHK_ERR(DMUS_E_NOTADLSCOL, L"DMUS_E_NOTADLSCOL")
        CHK_ERR(DMUS_E_INVALIDOFFSET, L"DMUS_E_INVALIDOFFSET")
        CHK_ERR(DMUS_E_ALREADY_LOADED, L"DMUS_E_ALREADY_LOADED")
        CHK_ERR(DMUS_E_INVALIDPOS, L"DMUS_E_INVALIDPOS")
        CHK_ERR(DMUS_E_INVALIDPATCH, L"DMUS_E_INVALIDPATCH")
        CHK_ERR(DMUS_E_CANNOTSEEK, L"DMUS_E_CANNOTSEEK")
        CHK_ERR(DMUS_E_CANNOTWRITE, L"DMUS_E_CANNOTWRITE")
        CHK_ERR(DMUS_E_CHUNKNOTFOUND, L"DMUS_E_CHUNKNOTFOUND")
        CHK_ERR(DMUS_E_INVALID_DOWNLOADID, L"DMUS_E_INVALID_DOWNLOADID")
        CHK_ERR(DMUS_E_NOT_DOWNLOADED_TO_PORT, L"DMUS_E_NOT_DOWNLOADED_TO_PORT")
        CHK_ERR(DMUS_E_ALREADY_DOWNLOADED, L"DMUS_E_ALREADY_DOWNLOADED")
        CHK_ERR(DMUS_E_UNKNOWN_PROPERTY, L"DMUS_E_UNKNOWN_PROPERTY")
        CHK_ERR(DMUS_E_SET_UNSUPPORTED, L"DMUS_E_SET_UNSUPPORTED")
        CHK_ERR(DMUS_E_GET_UNSUPPORTED, L"DMUS_E_GET_UNSUPPORTED")
        CHK_ERR(DMUS_E_NOTMONO, L"DMUS_E_NOTMONO")
        CHK_ERR(DMUS_E_BADARTICULATION, L"DMUS_E_BADARTICULATION")
        CHK_ERR(DMUS_E_BADINSTRUMENT, L"DMUS_E_BADINSTRUMENT")
        CHK_ERR(DMUS_E_BADWAVELINK, L"DMUS_E_BADWAVELINK")
        CHK_ERR(DMUS_E_NOARTICULATION, L"DMUS_E_NOARTICULATION")
        CHK_ERR(DMUS_E_NOTPCM, L"DMUS_E_NOTPCM")
        CHK_ERR(DMUS_E_BADWAVE, L"DMUS_E_BADWAVE")
        CHK_ERR(DMUS_E_BADOFFSETTABLE, L"DMUS_E_BADOFFSETTABLE")
        CHK_ERR(DMUS_E_UNKNOWNDOWNLOAD, L"DMUS_E_UNKNOWNDOWNLOAD")
        CHK_ERR(DMUS_E_NOSYNTHSINK, L"DMUS_E_NOSYNTHSINK")
        CHK_ERR(DMUS_E_ALREADYOPEN, L"DMUS_E_ALREADYOPEN")
        CHK_ERR(DMUS_E_ALREADYCLOSED, L"DMUS_E_ALREADYCLOSED")
        CHK_ERR(DMUS_E_SYNTHNOTCONFIGURED, L"DMUS_E_SYNTHNOTCONFIGURED")
        CHK_ERR(DMUS_E_SYNTHACTIVE, L"DMUS_E_SYNTHACTIVE")
        CHK_ERR(DMUS_E_CANNOTREAD, L"DMUS_E_CANNOTREAD")
        CHK_ERR(DMUS_E_DMUSIC_RELEASED, L"DMUS_E_DMUSIC_RELEASED")
        CHK_ERR(DMUS_E_BUFFER_EMPTY, L"DMUS_E_BUFFER_EMPTY")
        CHK_ERR(DMUS_E_BUFFER_FULL, L"DMUS_E_BUFFER_FULL")
        CHK_ERR(DMUS_E_PORT_NOT_CAPTURE, L"DMUS_E_PORT_NOT_CAPTURE")
        CHK_ERR(DMUS_E_PORT_NOT_RENDER, L"DMUS_E_PORT_NOT_RENDER")
        CHK_ERR(DMUS_E_DSOUND_NOT_SET, L"DMUS_E_DSOUND_NOT_SET")
        CHK_ERR(DMUS_E_ALREADY_ACTIVATED, L"DMUS_E_ALREADY_ACTIVATED")
        CHK_ERR(DMUS_E_INVALIDBUFFER, L"DMUS_E_INVALIDBUFFER")
        CHK_ERR(DMUS_E_WAVEFORMATNOTSUPPORTED, L"DMUS_E_WAVEFORMATNOTSUPPORTED")
        CHK_ERR(DMUS_E_SYNTHINACTIVE, L"DMUS_E_SYNTHINACTIVE")
        CHK_ERR(DMUS_E_DSOUND_ALREADY_SET, L"DMUS_E_DSOUND_ALREADY_SET")
        CHK_ERR(DMUS_E_INVALID_EVENT, L"DMUS_E_INVALID_EVENT")
        CHK_ERR(DMUS_E_UNSUPPORTED_STREAM, L"DMUS_E_UNSUPPORTED_STREAM")
        CHK_ERR(DMUS_E_ALREADY_INITED, L"DMUS_E_ALREADY_INITED")
        CHK_ERR(DMUS_E_INVALID_BAND, L"DMUS_E_INVALID_BAND")
        CHK_ERR(DMUS_E_TRACK_HDR_NOT_FIRST_CK, L"DMUS_E_TRACK_HDR_NOT_FIRST_CK")
        CHK_ERR(DMUS_E_TOOL_HDR_NOT_FIRST_CK, L"DMUS_E_TOOL_HDR_NOT_FIRST_CK")
        CHK_ERR(DMUS_E_INVALID_TRACK_HDR, L"DMUS_E_INVALID_TRACK_HDR")
        CHK_ERR(DMUS_E_INVALID_TOOL_HDR, L"DMUS_E_INVALID_TOOL_HDR")
        CHK_ERR(DMUS_E_ALL_TOOLS_FAILED, L"DMUS_E_ALL_TOOLS_FAILED")
        CHK_ERR(DMUS_E_ALL_TRACKS_FAILED, L"DMUS_E_ALL_TRACKS_FAILED")
        CHK_ERR(DMUS_E_NOT_FOUND, L"DMUS_E_NOT_FOUND")
        CHK_ERR(DMUS_E_NOT_INIT, L"DMUS_E_NOT_INIT")
        CHK_ERR(DMUS_E_TYPE_DISABLED, L"DMUS_E_TYPE_DISABLED")
        CHK_ERR(DMUS_E_TYPE_UNSUPPORTED, L"DMUS_E_TYPE_UNSUPPORTED")
        CHK_ERR(DMUS_E_TIME_PAST, L"DMUS_E_TIME_PAST")
        CHK_ERR(DMUS_E_TRACK_NOT_FOUND, L"DMUS_E_TRACK_NOT_FOUND")
        CHK_ERR(DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT, L"DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT")
        CHK_ERR(DMUS_E_NO_MASTER_CLOCK, L"DMUS_E_NO_MASTER_CLOCK")
        CHK_ERR(DMUS_E_LOADER_NOCLASSID, L"DMUS_E_LOADER_NOCLASSID")
        CHK_ERR(DMUS_E_LOADER_BADPATH, L"DMUS_E_LOADER_BADPATH")
        CHK_ERR(DMUS_E_LOADER_FAILEDOPEN, L"DMUS_E_LOADER_FAILEDOPEN")
        CHK_ERR(DMUS_E_LOADER_FORMATNOTSUPPORTED, L"DMUS_E_LOADER_FORMATNOTSUPPORTED")
        CHK_ERR(DMUS_E_LOADER_FAILEDCREATE, L"DMUS_E_LOADER_FAILEDCREATE")
        CHK_ERR(DMUS_E_LOADER_OBJECTNOTFOUND, L"DMUS_E_LOADER_OBJECTNOTFOUND")
        CHK_ERR(DMUS_E_LOADER_NOFILENAME, L"DMUS_E_LOADER_NOFILENAME")
        CHK_ERR(DMUS_E_INVALIDFILE, L"DMUS_E_INVALIDFILE")
        CHK_ERR(DMUS_E_ALREADY_EXISTS, L"DMUS_E_ALREADY_EXISTS")
        CHK_ERR(DMUS_E_OUT_OF_RANGE, L"DMUS_E_OUT_OF_RANGE")
        CHK_ERR(DMUS_E_SEGMENT_INIT_FAILED, L"DMUS_E_SEGMENT_INIT_FAILED")
        CHK_ERR(DMUS_E_ALREADY_SENT, L"DMUS_E_ALREADY_SENT")
        CHK_ERR(DMUS_E_CANNOT_FREE, L"DMUS_E_CANNOT_FREE")
        CHK_ERR(DMUS_E_CANNOT_OPEN_PORT, L"DMUS_E_CANNOT_OPEN_PORT")
        CHK_ERR(DMUS_E_CANNOT_CONVERT, L"DMUS_E_CANNOT_CONVERT")
        CHK_ERR(DMUS_E_DESCEND_CHUNK_FAIL, L"DMUS_E_DESCEND_CHUNK_FAIL")
        CHK_ERR(DMUS_E_NOT_LOADED, L"DMUS_E_NOT_LOADED")
        CHK_ERR(DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE, L"DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE")
        CHK_ERR(DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE, L"DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE")
        CHK_ERR(DMUS_E_SCRIPT_ERROR_IN_SCRIPT, L"DMUS_E_SCRIPT_ERROR_IN_SCRIPT")
        CHK_ERR(DMUS_E_SCRIPT_CANTLOAD_OLEAUT32, L"DMUS_E_SCRIPT_CANTLOAD_OLEAUT32")
        CHK_ERR(DMUS_E_SCRIPT_LOADSCRIPT_ERROR, L"DMUS_E_SCRIPT_LOADSCRIPT_ERROR")
        CHK_ERR(DMUS_E_SCRIPT_INVALID_FILE, L"DMUS_E_SCRIPT_INVALID_FILE")
        CHK_ERR(DMUS_E_INVALID_SCRIPTTRACK, L"DMUS_E_INVALID_SCRIPTTRACK")
        CHK_ERR(DMUS_E_SCRIPT_VARIABLE_NOT_FOUND, L"DMUS_E_SCRIPT_VARIABLE_NOT_FOUND")
        CHK_ERR(DMUS_E_SCRIPT_ROUTINE_NOT_FOUND, L"DMUS_E_SCRIPT_ROUTINE_NOT_FOUND")
        CHK_ERR(DMUS_E_INVALID_SEGMENTTRIGGERTRACK, L"DMUS_E_INVALID_SEGMENTTRIGGERTRACK")
        CHK_ERR(DMUS_E_INVALID_LYRICSTRACK, L"DMUS_E_INVALID_LYRICSTRACK")
        CHK_ERR(DMUS_E_INVALID_PARAMCONTROLTRACK, L"DMUS_E_INVALID_PARAMCONTROLTRACK")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR, L"DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR, L"DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE, L"DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE")
        CHK_ERR(DMUS_E_AUDIOPATHS_NOT_VALID, L"DMUS_E_AUDIOPATHS_NOT_VALID")
        CHK_ERR(DMUS_E_AUDIOPATHS_IN_USE, L"DMUS_E_AUDIOPATHS_IN_USE")
        CHK_ERR(DMUS_E_NO_AUDIOPATH_CONFIG, L"DMUS_E_NO_AUDIOPATH_CONFIG")
        CHK_ERR(DMUS_E_AUDIOPATH_INACTIVE, L"DMUS_E_AUDIOPATH_INACTIVE")
        CHK_ERR(DMUS_E_AUDIOPATH_NOBUFFER, L"DMUS_E_AUDIOPATH_NOBUFFER")
        CHK_ERR(DMUS_E_AUDIOPATH_NOPORT, L"DMUS_E_AUDIOPATH_NOPORT")
        CHK_ERR(DMUS_E_NO_AUDIOPATH, L"DMUS_E_NO_AUDIOPATH")
        CHK_ERR(DMUS_E_INVALIDCHUNK, L"DMUS_E_INVALIDCHUNK")      
        CHK_ERR(DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER, L"DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER")
        CHK_ERR(DMUS_E_INVALID_CONTAINER_OBJECT, L"DMUS_E_INVALID_CONTAINER_OBJECT")    

        
        /* APP MAN NOT SUPPORTED
        CHK_ERR(APPMAN_E_NOTINITIALIZED, L"APPMAN_E_NOTINITIALIZED")
        CHK_ERR(APPMAN_E_INVALIDPROPERTYSIZE, L"APPMAN_E_INVALIDPROPERTYSIZE")
        CHK_ERR(APPMAN_E_INVALIDDATA, L"APPMAN_E_INVALIDDATA")
        CHK_ERR(APPMAN_E_INVALIDPROPERTY, L"APPMAN_E_INVALIDPROPERTY")
        CHK_ERR(APPMAN_E_READONLYPROPERTY, L"APPMAN_E_READONLYPROPERTY")
        CHK_ERR(APPMAN_E_PROPERTYNOTSET, L"APPMAN_E_PROPERTYNOTSET")
        CHK_ERR(APPMAN_E_OVERFLOW, L"APPMAN_E_OVERFLOW")
        CHK_ERR(APPMAN_E_INVALIDPROPERTYVALUE, L"APPMAN_E_INVALIDPROPERTYVALUE")
        CHK_ERR(APPMAN_E_ACTIONINPROGRESS, L"APPMAN_E_ACTIONINPROGRESS")
        CHK_ERR(APPMAN_E_ACTIONNOTINITIALIZED, L"APPMAN_E_ACTIONNOTINITIALIZED")
        CHK_ERR(APPMAN_E_REQUIREDPROPERTIESMISSING, L"APPMAN_E_REQUIREDPROPERTIESMISSING")
        CHK_ERR(APPMAN_E_APPLICATIONALREADYEXISTS, L"APPMAN_E_APPLICATIONALREADYEXISTS")
        CHK_ERR(APPMAN_E_APPLICATIONALREADYLOCKED, L"APPMAN_E_APPLICATIONALREADYLOCKED")
        CHK_ERR(APPMAN_E_NODISKSPACEAVAILABLE, L"APPMAN_E_NODISKSPACEAVAILABLE")
        CHK_ERR(APPMAN_E_UNKNOWNAPPLICATION, L"APPMAN_E_UNKNOWNAPPLICATION")
        CHK_ERR(APPMAN_E_INVALIDPARAMETERS, L"APPMAN_E_INVALIDPARAMETERS")
        CHK_ERR(APPMAN_E_OBJECTLOCKED, L"APPMAN_E_OBJECTLOCKED")
        CHK_ERR(APPMAN_E_INVALIDINDEX, L"APPMAN_E_INVALIDINDEX")
        CHK_ERR(APPMAN_E_REGISTRYCORRUPT, L"APPMAN_E_REGISTRYCORRUPT")
        CHK_ERR(APPMAN_E_CANNOTASSOCIATE, L"APPMAN_E_CANNOTASSOCIATE")
        CHK_ERR(APPMAN_E_INVALIDASSOCIATION, L"APPMAN_E_INVALIDASSOCIATION")
        CHK_ERR(APPMAN_E_ALREADYASSOCIATED, L"APPMAN_E_ALREADYASSOCIATED")
        CHK_ERR(APPMAN_E_APPLICATIONREQUIRED, L"APPMAN_E_APPLICATIONREQUIRED")
        CHK_ERR(APPMAN_E_INVALIDEXECUTECMDLINE, L"APPMAN_E_INVALIDEXECUTECMDLINE")
        CHK_ERR(APPMAN_E_INVALIDDOWNSIZECMDLINE, L"APPMAN_E_INVALIDDOWNSIZECMDLINE")
        CHK_ERR(APPMAN_E_INVALIDREINSTALLCMDLINE, L"APPMAN_E_INVALIDREINSTALLCMDLINE")
        CHK_ERR(APPMAN_E_INVALIDUNINSTALLCMDLINE, L"APPMAN_E_INVALIDUNINSTALLCMDLINE")
        CHK_ERR(APPMAN_E_INVALIDSELFTESTCMDLINE, L"APPMAN_E_INVALIDSELFTESTCMDLINE")
        CHK_ERR(APPMAN_E_PARENTAPPNOTREADY, L"APPMAN_E_PARENTAPPNOTREADY")
        CHK_ERR(APPMAN_E_INVALIDSTATE, L"APPMAN_E_INVALIDSTATE")
        CHK_ERR(APPMAN_E_INVALIDROOTPATH, L"APPMAN_E_INVALIDROOTPATH")
        CHK_ERR(APPMAN_E_CACHEOVERRUN, L"APPMAN_E_CACHEOVERRUN")
        CHK_ERR(APPMAN_E_REINSTALLDX, L"APPMAN_E_REINSTALLDX")
        */
    }

    return L"Unknown";
}




//-----------------------------------------------------------------------------
// Name: DXTraceW()
// Desc: Outputs a formatted error message to the debug stream
//-----------------------------------------------------------------------------
HRESULT __stdcall DXTraceW( CHAR* strFile, DWORD dwLine, HRESULT hr, 
                            WCHAR* strMsg, BOOL bPopMsgBox )
{
    WCHAR strLine[50];
    WCHAR strError[200];
    WCHAR strBuffer[BUFFER_SIZE];
        
    swprintf( strLine, L"%ld", dwLine );
            
    if( strFile != NULL )
    {
        if( strlen(strFile) + 200 < BUFFER_SIZE )
        {        
           swprintf( strBuffer, L"%S(%s): ", strFile, strLine );
           OutputDebugStringW( strBuffer );
        }
    }

    if( strMsg != NULL )
        OutputDebugStringW( strMsg );

    swprintf( strError, L"%s (0x%0.8x)", DXGetErrorString8W(hr), hr );
    swprintf( strBuffer, L" (hr=%s)", strError );
    OutputDebugStringW( strBuffer );

    OutputDebugStringW( L"\n" );
    
    if( bPopMsgBox )
    {
        if( wcslen(strMsg) + strlen(strFile) + 
            wcslen(strLine) + wcslen(strError) + 200 < BUFFER_SIZE )
        {
            swprintf( strBuffer, L"File: %S\nLine: %s\nError Code: %s\nCalling: %s", 
                      strFile, strLine, strError, strMsg );
            MessageBoxW( NULL, strBuffer, L"Unexpected error encountered", MB_OK|MB_ICONERROR );
        }                              
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: DXTraceA()
// Desc: Outputs a formatted error message to the debug stream
//-----------------------------------------------------------------------------
HRESULT __stdcall DXTraceA( char* strFile, DWORD dwLine, HRESULT hr, 
                            char* strMsg, BOOL bPopMsgBox )                 
{
    CHAR strLine[50];
    CHAR strError[200];
    CHAR strBuffer[BUFFER_SIZE];
        
    sprintf( strLine, "%ld", dwLine );
            
    if( strFile != NULL )
    {
        if( strlen(strFile) + 200 < BUFFER_SIZE )
        {
           sprintf( strBuffer, "%s(%s): ", strFile, strLine );
           OutputDebugStringA( strBuffer );
        }
    }

    if( strMsg != NULL )
        OutputDebugStringA( strMsg );

    sprintf( strError, "%s (0x%0.8x)", DXGetErrorString8A(hr), hr );
    sprintf( strBuffer, " (hr=%s)", strError );
    OutputDebugStringA( strBuffer );
    
    OutputDebugStringA( "\n" );
    
    if( bPopMsgBox )
    {
        if( strlen(strMsg) + strlen(strFile) + 
            strlen(strLine) + strlen(strError) + 200 < BUFFER_SIZE )
        {
            sprintf( strBuffer, "File: %s\nLine: %s\nError Code: %s\nCalling: %s", 
                     strFile, strLine, strError, strMsg );
            MessageBoxA( NULL, strBuffer, "Unexpected error encountered", MB_OK|MB_ICONERROR );
        }                              
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

RegisterBin: $(TARGET)
!ifndef NTDEBUG
!MESSAGE Registering $(TARGETNAME)
	regsvr32 -s -u $(?F)
	regsvr32 -s $?
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\pchmath.h ===
#include "d3dx8math.h"

#undef D3DXINLINE
#define D3DXINLINE
#define D3DVBINLINE 
#define D3DVBCALL WINAPI 
#include "d3dxmathVB.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\guids.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       guids.cpp
//
//--------------------------------------------------------------------------


#define INITGUID 1
#include "objbase.h"
#include "dmusici.h"
#include "dsound.h"
#include "d3d8.h"
#include "dinput.h"
#include "dvoice.h"
#include "rmxfguid.h"
#include "dplay8.h"
#include "dpaddr.h"
#include "dplobby8.h"
#include "dvoice.h"
#include "d3dx8.h"
//#include "rmxftmpl.h"
#include <dxfile.h>

//BUGBUG TODO this is not a unique guid
DEFINE_GUID(g_GUIDDXVBLOCK, 0x5dd2e8da, 0x1c77, 0x4d40, 0xb0, 0xcf, 0x98, 0xfe, 0xfd, 0xff, 0x95, 0x12);

int pad;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
#include <statreg.h>
#include <statreg.cpp>
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\referenceclockobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "ReferenceClockObj.h"					   

extern void *g_dxj_ReferenceClock;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_ReferenceClockObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"ReferenceClock [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_ReferenceClockObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"ReferenceClock [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_ReferenceClockObject
///////////////////////////////////////////////////////////////////
C_dxj_ReferenceClockObject::C_dxj_ReferenceClockObject(){ 
		
	DPF1(1,"Constructor Creation  ReferenceClock Object[%d] \n ",g_creationcount);

	m__dxj_ReferenceClock = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_ReferenceClock;
	creationid = ++g_creationcount;
	 	
	g_dxj_ReferenceClock = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_ReferenceClockObject
///////////////////////////////////////////////////////////////////
C_dxj_ReferenceClockObject::~C_dxj_ReferenceClockObject()
{

	DPF(1,"Entering ~C_dxj_ReferenceClockObject destructor \n");

     C_dxj_ReferenceClockObject *prev=NULL; 
	for(C_dxj_ReferenceClockObject *ptr=(C_dxj_ReferenceClockObject *)g_dxj_ReferenceClock ; ptr; ptr=(C_dxj_ReferenceClockObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_ReferenceClock = (void*)ptr->nextobj; 
			
			DPF(1,"ReferenceClockObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_ReferenceClock){
		int count = IUNK(m__dxj_ReferenceClock)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IReferenceClock Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_ReferenceClock = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_ReferenceClockObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_ReferenceClock;
	
	return S_OK;
}
HRESULT C_dxj_ReferenceClockObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_ReferenceClock=(IReferenceClock*)pUnk;
	return S_OK;
}
HRESULT C_dxj_ReferenceClockObject::GetTime(REFERENCE_TIME *ret)
{
	HRESULT hr;
	
	if (FAILED(hr=m__dxj_ReferenceClock->GetTime(ret) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_ReferenceClockObject::AdviseTime(REFERENCE_TIME time1, REFERENCE_TIME time2, long lHandle, long *lRet)
{
	HRESULT hr;
	
	if (FAILED(hr=m__dxj_ReferenceClock->AdviseTime(time1, time2, (HANDLE) lHandle, (DWORD*) lRet) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_ReferenceClockObject::AdvisePeriodic(REFERENCE_TIME time1, REFERENCE_TIME time2, long lHandle, long *lRet)
{
	HRESULT hr;

	if (FAILED(hr=m__dxj_ReferenceClock->AdvisePeriodic(time1, time2, (HANDLE) lHandle, (DWORD*) lRet) ) )
		return hr;
	
	return S_OK;
}

HRESULT C_dxj_ReferenceClockObject::Unadvise(long lUnadvise)
{
	HRESULT hr;
	
	if (FAILED(hr=m__dxj_ReferenceClock->Unadvise((DWORD) lUnadvise) ) )
		return hr;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\referenceclockobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_ReferenceClock IReferenceClock*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_ReferenceClockObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_ReferenceClock, &IID_I_dxj_ReferenceClock, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_ReferenceClock,
#endif

	public CComObjectRoot
{
public:
	C_dxj_ReferenceClockObject() ;
	virtual ~C_dxj_ReferenceClockObject() ;

BEGIN_COM_MAP(C_dxj_ReferenceClockObject)
	COM_INTERFACE_ENTRY(I_dxj_ReferenceClock)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_ReferenceClockObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_ReferenceClock
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE GetTime(REFERENCE_TIME __RPC_FAR *ret);
		HRESULT STDMETHODCALLTYPE AdviseTime(REFERENCE_TIME time1, REFERENCE_TIME time2, long lHandle, long __RPC_FAR *lRet);
		HRESULT STDMETHODCALLTYPE AdvisePeriodic(REFERENCE_TIME time1, REFERENCE_TIME time2, long lHandle, long __RPC_FAR *lRet);
		HRESULT STDMETHODCALLTYPE Unadvise(long lUnadvise);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_ReferenceClock);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_ReferenceClock);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Direct.rc
//
#define IDS_DSOUND_DESC                 1
#define IDS_GENERIC_DESC                2
#define IDS_DIRECTX8_DESC               3
#define IDS_D3DX8_DESC               	4

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        209
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\guids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       guids.h
//
//--------------------------------------------------------------------------

#if 0
DEFINE_GUID( IID_IDirectDraw,			0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDraw2,                  0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDraw4,                  0x9c59509a,0x39bd,0x11d1,0x8c,0x4a,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( IID_IDirectDrawSurface,		0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawSurface2,		0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27 );
DEFINE_GUID( IID_IDirectDrawSurface3,           0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB );
DEFINE_GUID( IID_IDirectDrawSurface4,           0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B );

DEFINE_GUID( IID_IDirectDrawPalette,		0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawClipper,		0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawColorControl, 	0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );
DEFINE_GUID( IID_IDirectDrawGammaControl,       0x69C11C3E,0xB46B,0x11D1,0xAD,0x7A,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );

DEFINE_GUID(IID_IDirectSound3DListener,0x279AFA84,0x4981,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60);
DEFINE_GUID(IID_IDirectSound3DBuffer,0x279AFA86,0x4981,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60);
DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);
DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);
DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);
DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);



DEFINE_GUID( IID_IDirect3D,             0x3BBA0080,0x2421,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3D2,            0x6aae1ec1,0x662a,0x11d0,0x88,0x9d,0x00,0xaa,0x00,0xbb,0xb7,0x6a);
DEFINE_GUID( IID_IDirect3D3,            0xbb223240,0xe72b,0x11d0,0xa9,0xb4,0x00,0xaa,0x00,0xc0,0x99,0x3e);
DEFINE_GUID( IID_IDirect3DRampDevice,   0xF2086B20,0x259F,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DRGBDevice,    0xA4665C60,0x2673,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DHALDevice,    0x84E63dE0,0x46AA,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMMXDevice,    0x881949a1,0xd6f3,0x11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
DEFINE_GUID( IID_IDirect3DRefDevice,    0x50936643, 0x13e9, 0x11d1, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DNullDevice, 0x8767df22, 0xbacc, 0x11d1, 0x89, 0x69, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( IID_IDirect3DDevice,       0x64108800,0x957d,0X11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
DEFINE_GUID( IID_IDirect3DDevice2,  0x93281501, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DDevice3,  0xb0ab3b60, 0x33d7, 0x11d1, 0xa9, 0x81, 0x0, 0xc0, 0x4f, 0xd7, 0xb1, 0x74);
DEFINE_GUID( IID_IDirect3DTexture,      0x2CDCD9E0,0x25A0,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DTexture2, 0x93281502, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DLight,        0x4417C142,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMaterial,     0x4417C144,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMaterial2,    0x93281503, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DMaterial3,    0xca9c46f4, 0xd3c5, 0x11d1, 0xb7, 0x5a, 0x0, 0x60, 0x8, 0x52, 0xb3, 0x12);
DEFINE_GUID( IID_IDirect3DExecuteBuffer,0x4417C145,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DViewport,     0x4417C146,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DViewport2,    0x93281500, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DViewport3,    0xb0ab3b61, 0x33d7, 0x11d1, 0xa9, 0x81, 0x0, 0xc0, 0x4f, 0xd7, 0xb1, 0x74);
DEFINE_GUID( IID_IDirect3DVertexBuffer, 0x7a503555, 0x4a83, 0x11d1, 0xa5, 0xdb, 0x0, 0xa0, 0xc9, 0x3, 0x67, 0xf8);




DEFINE_GUID(IID_IDirectPlay2, 0x2b74f7c0, 0x9154, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);
DEFINE_GUID(IID_IDirectPlay2A,0x9d460580, 0xa822, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);
DEFINE_GUID(IID_IDirectPlay3, 0x133efe40, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
DEFINE_GUID(IID_IDirectPlay3A,0x133efe41, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
DEFINE_GUID(IID_IDirectPlay4, 0xab1c530, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlay4A,0xab1c531, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlayLobby, 0xaf465c71, 0x9588, 0x11cf, 0xa0, 0x20, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
DEFINE_GUID(IID_IDirectPlayLobbyA, 0x26c66a70, 0xb367, 0x11cf, 0xa0, 0x24, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
DEFINE_GUID(IID_IDirectPlayLobby2, 0x194c220, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
DEFINE_GUID(IID_IDirectPlayLobby2A, 0x1bb4af80, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
DEFINE_GUID(IID_IDirectPlayLobby3, 0x2db72490, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlayLobby3A, 0x2db72491, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(CLSID_DirectPlayLobby, 0x2fe8f810, 0xb2a5, 0x11d0, 0xa7, 0x87, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);

// {762CCDA1-D916-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_MessagesSupported, 
0x762ccda1, 0xd916, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);
// {F56920A0-D218-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_LobbyGuid, 
0xf56920a0, 0xd218, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);
// {B4319322-D20D-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerGuid, 
0xb4319322, 0xd20d, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);
// {48784000-D219-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerScore, 
0x48784000, 0xd219, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);
// {1318F560-912C-11d0-9DAA-00A0C90A43CB}
DEFINE_GUID(DPAID_TotalSize, 
0x1318f560, 0x912c, 0x11d0, 0x9d, 0xaa, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
// {07D916C0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ServiceProvider, 
0x7d916c0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
// {59B95640-9667-11d0-A77D-0000F803ABFC}
DEFINE_GUID(DPAID_LobbyProvider, 
0x59b95640, 0x9667, 0x11d0, 0xa7, 0x7d, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
// {78EC89A0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_Phone, 
0x78ec89a0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
// {BA5A7A70-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_PhoneW, 
0xba5a7a70, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
// {F6DCC200-A2FE-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_Modem, 
0xf6dcc200, 0xa2fe, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * Direct3DRM Object interfaces
 */
DEFINE_GUID(IID_IDirect3DRMObject,          0xeb16cb00, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMObject2,         0x4516ec7c, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice,          0xe9e19280, 0x6e05, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMDevice2,         0x4516ec78, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice3,     0x549f498b, 0xbfeb, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMViewport,        0xeb16cb02, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewport2,   0x4a1b1be6, 0xbfed, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMFrame,           0xeb16cb03, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrame2,          0xc3dfbd60, 0x3988, 0x11d0, 0x9e, 0xc2, 0x0, 0x0, 0xc0, 0x29, 0x1a, 0xc3);
DEFINE_GUID(IID_IDirect3DRMFrame3,              0xff6b7f70, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMVisual,          0xeb16cb04, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMesh,            0xa3a80d01, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder,     0xa3a80d02, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder2,    0x4516ec77, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder3,    0xff6b7f71, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMFace,            0xeb16cb07, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMLight,           0xeb16cb08, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture,         0xeb16cb09, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture2,        0x120f30c0, 0x1629, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);
DEFINE_GUID(IID_IDirect3DRMTexture3,        0xff6b7f73, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMWrap,            0xeb16cb0a, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial,        0xeb16cb0b, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial2,       0xff6b7f75, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimation,       0xeb16cb0d, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimation2,      0xff6b7f77, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimationSet,    0xeb16cb0e, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationSet2,   0xff6b7f79, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMObjectArray,     0x242f6bc2, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDeviceArray,     0xeb16cb10, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewportArray,   0xeb16cb11, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrameArray,      0xeb16cb12, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMVisualArray,     0xeb16cb13, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMLightArray,      0xeb16cb14, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMPickedArray,     0xeb16cb16, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFaceArray,       0xeb16cb17, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationArray,  0xd5f1cae0, 0x4bd7, 0x11d1, 0xb9, 0x74, 0x0, 0x60, 0x8, 0x3e, 0x45, 0xf3);
DEFINE_GUID(IID_IDirect3DRMUserVisual,      0x59163de0, 0x6d43, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow,          0xaf359780, 0x6ba3, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow2,         0x86b44e25, 0x9c82, 0x11d1, 0xbb, 0xb, 0x0, 0xa0, 0xc9, 0x81, 0xa0, 0xa6);
DEFINE_GUID(IID_IDirect3DRMInterpolator,    0x242f6bc1, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMProgressiveMesh, 0x4516ec79, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMPicked2Array,    0x4516ec7b, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMClippedVisual,   0x5434e733, 0x6d66, 0x11d1, 0xbb, 0xb, 0x0, 0x0, 0xf8, 0x75, 0x86, 0x5a);
DEFINE_GUID(IID_IDirect3DRMWinDevice,   0xc5016cc0, 0xd273, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);



DEFINE_GUID(IID_IDirect3DRM2,   0x4516ecc8, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRM3,   0x2e34065, 0xc243, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);

DEFINE_GUID(GUID_XAxis,   0xA36D02E0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_YAxis,   0xA36D02E1,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_ZAxis,   0xA36D02E2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RxAxis,  0xA36D02F4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RyAxis,  0xA36D02F5,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RzAxis,  0xA36D02E3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Slider,  0xA36D02E4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Button,  0xA36D02F0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Key,     0x55728220,0xD33C,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_POV,     0xA36D02F2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Unknown, 0xA36D02F3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysMouse,   0x6F1D2B60,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboard,0x6F1D2B61,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Joystick   ,0x6F1D2B70,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_ConstantForce,0x13541C20,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_RampForce,    0x13541C21,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Square,       0x13541C22,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Sine,         0x13541C23,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Triangle,     0x13541C24,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothUp,   0x13541C25,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothDown, 0x13541C26,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Spring,       0x13541C27,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Damper,       0x13541C28,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Inertia,      0x13541C29,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Friction,     0x13541C2A,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_CustomForce,  0x13541C2B,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\xfilebinaryobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"

#include "dxfile.h"
#include "XFileBinaryObj.h"



extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);
extern BSTR XFILEGUIDtoBSTR(LPGUID);

C_dxj_DirectXFileBinaryObject::C_dxj_DirectXFileBinaryObject()
{
	m_pXFileBinary=NULL;
}
C_dxj_DirectXFileBinaryObject::~C_dxj_DirectXFileBinaryObject()
{
	if (m_pXFileBinary) m_pXFileBinary->Release();

}

HRESULT C_dxj_DirectXFileBinaryObject::create(IDirectXFileBinary *pBin,I_dxj_DirectXFileBinary **ret)
{	
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
	

	C_dxj_DirectXFileBinaryObject *c=NULL;
	c=new CComObject<C_dxj_DirectXFileBinaryObject>;
	if( c == NULL ) return E_OUTOFMEMORY;

	c->Init(pBin);

	hr=c->QueryInterface(IID_I_dxj_DirectXFileBinary, (void**)ret);
	return hr;

}


HRESULT C_dxj_DirectXFileBinaryObject::Init(IDirectXFileBinary *pBin)
{
	m_pXFileBinary=pBin;
	return S_OK;
}

STDMETHODIMP C_dxj_DirectXFileBinaryObject::GetName( 
    /* [retval][out] */ BSTR __RPC_FAR *name)
{
	HRESULT hr;
	USES_CONVERSION;

	char szName[1024];
	DWORD dwSize=1024;
	hr=m_pXFileBinary->GetName(szName,&dwSize);
	if FAILED(hr) return hr;
	*name=T2BSTR(szName);

	return S_OK;
}


STDMETHODIMP C_dxj_DirectXFileBinaryObject::GetId( 
    /* [retval][out] */ BSTR __RPC_FAR *name)
{
	HRESULT hr;
	GUID g;
	ZeroMemory(&g,sizeof(GUID));

	hr=m_pXFileBinary->GetId(&g);
	if FAILED(hr) return hr;

	*name=XFILEGUIDtoBSTR(&g);
	return hr;
}

STDMETHODIMP C_dxj_DirectXFileBinaryObject::GetSize( 
    /* [retval][out] */ long __RPC_FAR *size)
{
	HRESULT hr;

	hr=m_pXFileBinary->GetSize((DWORD*)size);
	
	return hr;
}

    

        
HRESULT C_dxj_DirectXFileBinaryObject::GetMimeType( 
            /* [retval][out] */ BSTR __RPC_FAR *mime)
{
	{
	HRESULT hr;
	USES_CONVERSION;
	const char **ppMime=NULL;

	hr=m_pXFileBinary->GetMimeType(ppMime);
	if FAILED(hr) return hr;
	if (!ppMime) return E_FAIL;

	*mime=T2BSTR(*ppMime);

	return S_OK;
}

}

        
HRESULT C_dxj_DirectXFileBinaryObject::Read( 
            /* [out][in] */ void __RPC_FAR *data,
            /* [in] */ long size,
            /* [retval][out] */ long __RPC_FAR *read)
{	
	HRESULT hr;
	__try
	{
		hr=m_pXFileBinary->Read(data,(DWORD)size,(DWORD*)read);

	}
	__except(1,1)
	{
		return E_INVALIDARG;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#define DX6 1
#define DX7 1

#include "windows.h"
#include "mmsystem.h"

#include "atlbase.h"
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include "atlcom.h"



//#define _D3DTYPES_H_ 1

#define DIRECTINPUT_VERSION 0x0800 // Added to set DInput version to 8 for dx8vb.dll
#include <d3d8.h>
#include <dSound.h>
#include <dPlay8.h>
#include <dpLobby8.h>
#include <dinput.h>
#include <dvoice.h>

#define DECL_VARIABLE(c) typedef_##c m_##c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\xfiledataobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DirectXFileDataObject :
		public I_dxj_DirectXFileData,
		public I_dxj_DirectXFileObject,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DirectXFileDataObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectXFileData)
		COM_INTERFACE_ENTRY(I_dxj_DirectXFileObject)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectXFileDataObject)

public:
		C_dxj_DirectXFileDataObject();	
		~C_dxj_DirectXFileDataObject();

		HRESULT STDMETHODCALLTYPE InternalGetObject(IUnknown **pUnk);
		HRESULT STDMETHODCALLTYPE InternalSetObject(IUnknown *pUnk);

		HRESULT STDMETHODCALLTYPE InternalGetData( IUnknown **pprealInterface); 
            
		HRESULT STDMETHODCALLTYPE InternalSetData( IUnknown *prealInterface);            

        HRESULT STDMETHODCALLTYPE GetName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
       
        
        HRESULT STDMETHODCALLTYPE GetId( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE GetDataSize( 
            /* [in] */ BSTR name,
            /* [retval][out] */ long __RPC_FAR *size);
        
        HRESULT STDMETHODCALLTYPE GetData( 
            /* [in] */ BSTR name,
            /* [in] */ void __RPC_FAR *data);
        
        HRESULT STDMETHODCALLTYPE GetType( 
            /* [retval][out] */ BSTR __RPC_FAR *type);
        
        HRESULT STDMETHODCALLTYPE GetNextObject( 
            /* [retval][out] */ I_dxj_DirectXFileObject __RPC_FAR *__RPC_FAR *type);
        
        HRESULT STDMETHODCALLTYPE AddDataObject( 
            /* [in] */ I_dxj_DirectXFileData __RPC_FAR *data);
        
        HRESULT STDMETHODCALLTYPE AddDataReference( 
            /* [in] */ BSTR name,
            /* [in] */ BSTR guid);
        
        HRESULT STDMETHODCALLTYPE AddBinaryObject( 
            /* [in] */ BSTR name,
            /* [in] */ BSTR guidObject,
            /* [in] */ BSTR MimeType,
            void __RPC_FAR *data,
            /* [in] */ long size);

		HRESULT STDMETHODCALLTYPE	GetDataFromOffset(
			/* [in] */ BSTR name,
			/* [in] */ long offset, 
			/* [in] */ long bytecount, 
			/* [in] */ void *data);		

		static HRESULT C_dxj_DirectXFileDataObject::create( IDirectXFileData *pData,I_dxj_DirectXFileData **ret);		

private:
		IDirectXFileData *m_pXFileData;
	
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\xfiledataobj.cpp ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       xfiledataobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"

#include "dxfile.h"
#include "XFileBinaryObj.h"
#include "XFileReferenceObj.h"
#include "XFileDataObj.h"



extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);
extern BSTR XFILEGUIDtoBSTR(LPGUID);
extern HRESULT XFILEBSTRtoGUID(LPGUID,BSTR);


C_dxj_DirectXFileDataObject::C_dxj_DirectXFileDataObject()
{
	m_pXFileData=NULL;
}
C_dxj_DirectXFileDataObject::~C_dxj_DirectXFileDataObject()
{
	if (m_pXFileData) m_pXFileData->Release();
}


HRESULT C_dxj_DirectXFileDataObject::create( IDirectXFileData *pData,I_dxj_DirectXFileData **ret)
{	
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
	

	C_dxj_DirectXFileDataObject *c=NULL;
	c=new CComObject<C_dxj_DirectXFileDataObject>;
	if( c == NULL ) return E_OUTOFMEMORY;
	
	hr=c->InternalSetObject((IUnknown*)pData);
	if FAILED(hr){
		delete c;
		return hr;
	}

        hr=IUNK(c)->QueryInterface(IID_I_dxj_DirectXFileData, (void**)ret);
	return hr;

}

HRESULT C_dxj_DirectXFileDataObject::InternalSetObject(IUnknown *pUnk)
{
	m_pXFileData=(IDirectXFileData*)pUnk;
	return S_OK;
}


HRESULT C_dxj_DirectXFileDataObject::InternalGetObject(IUnknown **pUnk)
{
	*pUnk=(IUnknown*)m_pXFileData;
	return S_OK;
}


STDMETHODIMP C_dxj_DirectXFileDataObject::GetName( 
    /* [retval][out] */ BSTR __RPC_FAR *name)
{
	HRESULT hr;
	USES_CONVERSION;

	char szName[1024];
	DWORD dwSize=1024;
	hr=m_pXFileData->GetName(szName,&dwSize);
	if FAILED(hr) return hr;
	*name=T2BSTR(szName);

	return S_OK;
}


STDMETHODIMP C_dxj_DirectXFileDataObject::GetId( 
    /* [retval][out] */ BSTR __RPC_FAR *name)
{
	HRESULT hr;
	GUID g;
	ZeroMemory(&g,sizeof(GUID));

	hr=m_pXFileData->GetId(&g);
	if FAILED(hr) return hr;

	*name=XFILEGUIDtoBSTR(&g);
	return hr;
}

STDMETHODIMP C_dxj_DirectXFileDataObject::GetDataSize( 
    /* [in] */ BSTR name,
    /* [retval][out] */ long __RPC_FAR *size)
{
	USES_CONVERSION;
	HRESULT hr;

	
	LPVOID  pvData=NULL;
	DWORD	dwSize=0;

	if (name[0]==0)
	{
		hr=m_pXFileData->GetData(NULL,&dwSize,&pvData);
	}
	else
	{
		LPSTR szName = NULL;
		__try { szName = W2T(name); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		hr=m_pXFileData->GetData(szName,&dwSize,&pvData);
	}

	*size=dwSize;

	return hr;
}


STDMETHODIMP C_dxj_DirectXFileDataObject::GetData( 
    /* [in] */ BSTR name,
    /* [in] */ void __RPC_FAR *data)
{
	USES_CONVERSION;
	HRESULT hr;

	
	LPVOID  pvData=NULL;
	DWORD	dwSize=0;

	if (name[0]==0)
	{
		hr=m_pXFileData->GetData(NULL,&dwSize,&pvData);
	}
	else
	{
		LPSTR szName = NULL;
		__try { szName = W2T(name); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		hr=m_pXFileData->GetData(szName,&dwSize,&pvData);
	}

	__try{
		memcpy(data,pvData,dwSize);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}

STDMETHODIMP C_dxj_DirectXFileDataObject::GetType( 
    /* [retval][out] */ BSTR __RPC_FAR *type)
{
		
	
	HRESULT hr;
	const GUID* pGUID;

	hr=m_pXFileData->GetType(&pGUID);
	if FAILED(hr) return hr;

	*type=XFILEGUIDtoBSTR((GUID*)pGUID);
	return hr;
}


STDMETHODIMP C_dxj_DirectXFileDataObject::GetNextObject( 
    /* [retval][out] */ I_dxj_DirectXFileObject __RPC_FAR *__RPC_FAR *type)
{
	HRESULT hr;
	IDirectXFileObject *pObj=NULL;
	hr=m_pXFileData->GetNextObject(&pObj);

	if (hr==DXFILEERR_NOMOREOBJECTS){
			*type=NULL;
			return S_OK;
	}

	if FAILED(hr) return hr;

	LPUNKNOWN  pUnk=NULL;
	LPUNKNOWN  pCover=NULL;
	if (!pObj){
		*type=NULL;
		return S_OK;
	}

	hr=pObj->QueryInterface(IID_IDirectXFileData,(void**)&pUnk);
	if SUCCEEDED(hr)
	{
		pObj->Release();
		
		hr=C_dxj_DirectXFileDataObject::create((IDirectXFileData*)pUnk,(I_dxj_DirectXFileData**)&pCover);
		if FAILED(hr) 
		{
			pUnk->Release();
			return hr;
		}
		
		hr=pCover->QueryInterface(IID_I_dxj_DirectXFileObject,(void**)type);
		pCover->Release();
		if FAILED(hr) pUnk->Release();

		return hr;
	}

	
	hr=pObj->QueryInterface(IID_IDirectXFileBinary,(void**)&pUnk);
	if SUCCEEDED(hr)
	{
		pObj->Release();
		
		hr=C_dxj_DirectXFileBinaryObject::create((IDirectXFileBinary*)pUnk,(I_dxj_DirectXFileBinary**)&pCover);
		if FAILED(hr) 
		{
			pUnk->Release();
			return hr;
		}
		
		hr=pCover->QueryInterface(IID_I_dxj_DirectXFileObject,(void**)type);
		pCover->Release();
		if FAILED(hr) pUnk->Release();
		
		return hr;
	}

	
	
	hr=pObj->QueryInterface(IID_IDirectXFileDataReference,(void**)&pUnk);
	if SUCCEEDED(hr)
	{
		pObj->Release();
		
		hr=C_dxj_DirectXFileReferenceObject::create((IDirectXFileDataReference*)pUnk,(I_dxj_DirectXFileReference**)&pCover);
		if FAILED(hr) 
		{
			pUnk->Release();
			return hr;
		}
		
		hr=pCover->QueryInterface(IID_I_dxj_DirectXFileObject,(void**)type);
		pCover->Release();
		if FAILED(hr) pUnk->Release();
		
		return hr;
	}

	return E_NOTIMPL;
}


STDMETHODIMP C_dxj_DirectXFileDataObject::AddDataObject( 
    /* [in] */ I_dxj_DirectXFileData __RPC_FAR *data)
{
	HRESULT hr;

	if (!data) return E_INVALIDARG;
	IDirectXFileData *pData=NULL;

	//note does not addref
	data->InternalGetObject((IUnknown**)&pData);
	if (!pData) return E_FAIL;

	hr=m_pXFileData->AddDataObject(pData);

	return hr;
	

}


STDMETHODIMP C_dxj_DirectXFileDataObject::AddDataReference( 
    /* [in] */ BSTR name,
    /* [in] */ BSTR guid)
{
	USES_CONVERSION;
	HRESULT hr;

	LPSTR  szName=NULL;
	GUID  *lpGuid=NULL;
	GUID   g;
	ZeroMemory(&g,sizeof(GUID));

	if (name[0]!=0)
	{
		__try { szName = W2T(name); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	}

	if (guid[0]!=0)
	{
		hr=XFILEBSTRtoGUID(&g,guid);
		if FAILED(hr) return hr;
		lpGuid=&g;
	}

	hr=m_pXFileData->AddDataReference(szName,lpGuid);

	return hr;
}


STDMETHODIMP C_dxj_DirectXFileDataObject::AddBinaryObject( 
    /* [in] */ BSTR name,
    /* [in] */ BSTR guidObject,
    /* [in] */ BSTR MimeType,
    void __RPC_FAR *data,
    /* [in] */ long size)
{

	USES_CONVERSION;

	HRESULT hr;
	GUID gObj;
	GUID *lpGuid=NULL;
	LPSTR szMime=NULL;
	LPSTR szName=NULL;

	ZeroMemory(&gObj,sizeof(GUID));

	if (!data) return E_INVALIDARG;


	if ((guidObject) && (guidObject[0]!=0))
	{
		hr=XFILEBSTRtoGUID(&gObj,guidObject);
		if FAILED(hr) return hr;
		lpGuid=&gObj;	
	}



	if ((name) && (name[0]!=0))
	{
		__try { szName = W2T(name); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	}


	if ((MimeType) && (MimeType[0]!=0))
	{
		__try { szMime = W2T(MimeType); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	}

	IDirectXFileData *pData=NULL;


	__try
	{
		hr=m_pXFileData->AddBinaryObject(szName,lpGuid,szMime,data,size);
	}
	__except(1,1)
	{
		return E_INVALIDARG;
	}
		

	return hr;
	
}

STDMETHODIMP C_dxj_DirectXFileDataObject::GetDataFromOffset(
			/* [in] */ BSTR name,
			/* [in] */ long offset, 
			/* [in] */ long bytecount, 
			/* [in] */ void *data)	
{
	USES_CONVERSION;
	HRESULT hr;

	
	LPVOID  pvData=NULL;
	DWORD	dwSize=0;

	if (name[0]==0)
	{
		hr=m_pXFileData->GetData(NULL,&dwSize,&pvData);
	}
	else
	{
		LPSTR szName = NULL;
		__try { szName = W2T(name); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		hr=m_pXFileData->GetData(szName,&dwSize,&pvData);
	}

	__try{
		memcpy(data,&((char*)pvData)[offset],bytecount);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\sources.inc ===
!IF 0


Copyright (C) Microsoft Corporation, 1989 - 1999

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Andrew Kertesz (Andrewke) 20-DEC-98

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF


MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dx8vb
TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=direct.def
!IF 0
        DLLENTRY=_DllMainCRTStartup
!ENDIF

DLLENTRY=DllMain

USE_LIBCMT=1
USE_CRTDLL=1
USE_MAPSYM=1
USE_STATIC_ATL=1
DX7=1
DX6=1


PLAT_DIR           = daytona
# ALT_PROJECT_TARGET = .
!if defined(NTDEBUG) && "$(NTDEBUG)" != "ntsdnodebug"
DEBUG=1
!endif

C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT

# 11/21/2000
# new compiler causing error linking in d3dx8dt
# talk with d3dx team to see if we need to link in C runtime
LINK_LIB_IGNORE = 4210

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(BASEDIR)\public\sdk\lib\*\libcmt.lib		\
           $(BASEDIR)\public\sdk\lib\*\kernel32.lib		\
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib		\
           $(BASEDIR)\public\sdk\lib\*\uuid.lib                 \
           $(BASEDIR)\public\sdk\lib\*\ole32.lib                \
           $(BASEDIR)\public\sdk\lib\*\gdi32.lib                \
           $(BASEDIR)\public\sdk\lib\*\winmm.lib                \
           $(SDK_LIB_PATH)\dinput.lib             		\
           $(BASEDIR)\public\sdk\lib\*\msacm32.lib              \
           $(BASEDIR)\public\sdk\lib\*\USER32.lib              \
           $(BASEDIR)\public\sdk\lib\*\OLEAUT32.lib            \
           $(SDK_LIB_PATH)\d3dxof.lib              
#          $(SDK_LIB_PATH)\d3d8.lib    
!if $(FREEBUILD)
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\d3dx8.lib  
             

!else
TARGETLIBS=$(TARGETLIBS) \
 $(SDK_LIB_PATH)\d3dx8dt.lib
                       
!endif      


           

PASS0_HEADERDIR=$O

INCLUDES=$(DXROOT)\inc; \
	 $(SDK_INC_PATH); \
        $(PASS0_HEADERDIR);




SOURCES=   \
        ..\direct.idl              \
	..\directvb.idl            \
        ..\direct.cpp              \
        ..\dxGlob7Obj.cpp          \
        ..\StdAfx.cpp              \
        ..\wave.cpp                \
        ..\dmLoaderObj.cpp         \
        ..\dmSegmentObj.cpp        \
        ..\dmBandObj.cpp           \
        ..\dmChordMapObj.cpp       \
        ..\dmCollectionObj.cpp     \
        ..\dmPerformanceObj.cpp    \
        ..\dmSegmentStateObj.cpp   \
        ..\dmStyleObj.cpp          \
        ..\dmComposerObj.cpp       \
        ..\dmusAudioPathObj.cpp       \
        ..\DIEnumDeviceObjectsObj.cpp \
        ..\DIEnumDevicesObj.cpp \
        ..\dInput1Obj.cpp \
        ..\dInputDeviceObj.cpp \
        ..\dInputEffectObj.cpp \
        ..\dIDevObjInstObj.cpp \
        ..\dIDevInstObj.cpp \
	..\dIEnumEffectsObj.cpp \
	..\DPlayPeerObj.cpp \
	..\DPlayServerObj.cpp \
	..\DPlayClientObj.cpp \
	..\DPlayAddressObj.cpp \
	..\DPlayLobbyClientObj.cpp \
	..\DPlayLobbiedAppObj.cpp \
	..\DplayvoiceClientObj.cpp \
	..\DplayvoiceserverObj.cpp \
	..\DplayvoiceSetupObj.cpp \
	..\DplayBufHelp.cpp \
        ..\DSEnumObj.cpp \
        ..\dSound3DBuffer.cpp \
        ..\dSound3DListener.cpp \
        ..\dSoundBufferObj.cpp \
        ..\dSoundPrimaryBufferObj.cpp \
        ..\dSoundCaptureBufferObj.cpp \
        ..\dSoundCaptureObj.cpp \
        ..\dSoundObj.cpp      \
	..\dSoundFXGargleObj.cpp \
	..\dSoundFXParamEQObj.cpp \
	..\dSoundFXWavesReverbObj.cpp \
	..\dSoundFXchorusObj.cpp \
	..\dSoundFXCompressorObj.cpp \
	..\dSoundFXDistortionObj.cpp \
	..\dSoundFXEchoObj.cpp \
	..\dSoundFXFlangerObj.cpp \
	..\dSoundFXi3dl2reverbObj.cpp \
	..\XFileObj.cpp \
	..\XFileEnumObj.cpp \
	..\XFileReferenceObj.cpp \
	..\XFileDataObj.cpp \
	..\XFileSaveObj.cpp \
	..\XFileBinaryObj.cpp \
	..\XFileSaveObj.cpp \
	..\d3dxmathvb.cpp \
	..\d3dxtexvb.cpp \
	..\d3dx8obj.cpp \
        ..\dxvb.rc \
        ..\guids.cpp \
        ..\filestrm.cpp \
        ..\dxerr8.cpp

!if "$(__PRODUCT)" == "DX7"
!if  "$(ALPHA)"=="1" || "$(WIN95)"=="1"
NTTARGETFILE1=RegisterBin
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\xfileenumobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"

#include "dxfile.h"
#include "XfileDataObj.h"
#include "XfileEnumObj.h"

	
extern HRESULT XFILEBSTRtoGUID(LPGUID,BSTR);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);

C_dxj_DirectXFileEnumObject::C_dxj_DirectXFileEnumObject()
{
	m_pXFileEnum=NULL;
}
C_dxj_DirectXFileEnumObject::~C_dxj_DirectXFileEnumObject()
{
	if (m_pXFileEnum) m_pXFileEnum->Release();
}

HRESULT C_dxj_DirectXFileEnumObject::create( IDirectXFileEnumObject *pEnum,I_dxj_DirectXFileEnum **ret)
{	
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
	
	//caller must addref
	

	C_dxj_DirectXFileEnumObject *c=NULL;
	c=new CComObject<C_dxj_DirectXFileEnumObject>;
	if( c == NULL ) return E_OUTOFMEMORY;
	c->Init(pEnum);
	hr=c->QueryInterface(IID_I_dxj_DirectXFileEnum, (void**)ret);
	return hr;

}


HRESULT C_dxj_DirectXFileEnumObject::Init( IDirectXFileEnumObject *pEnum)
{
	m_pXFileEnum=pEnum;
	return S_OK;
}
    


STDMETHODIMP C_dxj_DirectXFileEnumObject::GetNextDataObject( 
            /* [retval][out] */ I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *ret) 
{
	HRESULT hr;
	IDirectXFileData *pXFData=NULL;
	hr=m_pXFileEnum->GetNextDataObject(&pXFData);
	if (hr==DXFILEERR_NOMOREOBJECTS){
		*ret=NULL;
		return S_OK;
	}

	if FAILED(hr) return hr;

	if (pXFData==NULL) {
		*ret=NULL;
		return S_OK;
	}

	hr=C_dxj_DirectXFileDataObject::create(pXFData,ret);
	if FAILED(hr)	pXFData->Release();
	return hr;

}
        
STDMETHODIMP C_dxj_DirectXFileEnumObject::GetDataObjectById( 
            /* [in] */ BSTR id,
            I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *ret) 
{
	
	HRESULT hr;

	GUID g;
	ZeroMemory(&g,sizeof(GUID));
	hr=XFILEBSTRtoGUID(&g,id);
	if FAILED(hr) return hr;


	IDirectXFileData *pXFData=NULL;
	hr=m_pXFileEnum->GetDataObjectById(g,&pXFData);
	if FAILED(hr) return hr;

	if (pXFData==NULL) {
		*ret=NULL;
		return S_OK;
	}

	hr=C_dxj_DirectXFileDataObject::create(pXFData,ret);
	if FAILED(hr)	pXFData->Release();
	return hr;
}

        
STDMETHODIMP C_dxj_DirectXFileEnumObject::GetDataObjectByName( 
            /* [in] */ BSTR id,
            I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *ret)
{
	USES_CONVERSION;

	HRESULT hr;
	LPSTR szName = NULL;
	__try { szName = W2T(id); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }


	IDirectXFileData *pXFData=NULL;
	hr=m_pXFileEnum->GetDataObjectByName(szName,&pXFData);
	if FAILED(hr) return hr;

	if (pXFData==NULL) {
		*ret=NULL;
		return S_OK;
	}

	hr=C_dxj_DirectXFileDataObject::create(pXFData,ret);
	if FAILED(hr)	pXFData->Release();
	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\xfilebinaryobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DirectXFileBinaryObject :
		public I_dxj_DirectXFileBinary,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DirectXFileBinaryObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectXFileBinary)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectXFileBinaryObject)

public:
		C_dxj_DirectXFileBinaryObject();	
		~C_dxj_DirectXFileBinaryObject();

        
        HRESULT STDMETHODCALLTYPE GetName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE GetId( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE GetSize( 
            /* [retval][out] */ long __RPC_FAR *size);
        
        HRESULT STDMETHODCALLTYPE GetMimeType( 
            /* [retval][out] */ BSTR __RPC_FAR *mime);
        
        HRESULT STDMETHODCALLTYPE Read( 
            /* [out][in] */ void __RPC_FAR *data,
            /* [in] */ long size,
            /* [retval][out] */ long __RPC_FAR *read);
        

		HRESULT Init(IDirectXFileBinary *pBin);

		 static HRESULT C_dxj_DirectXFileBinaryObject::create(IDirectXFileBinary *pBin, I_dxj_DirectXFileBinary **ret);		

		
private:

		IDirectXFileBinary *m_pXFileBinary;
	
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\wave.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       wave.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"
#include "dms.h"
#include <mmreg.h>
#include <msacm.h>


// FOURCC codes
#undef FOURCC_RIFF
#define FOURCC_RIFF         'FFIR'

#undef FOURCC_MEM
#define FOURCC_MEM          ' MEM'

#undef FOURCC_WAVE
#define FOURCC_WAVE         'EVAW'

#undef FOURCC_FORMAT
#define FOURCC_FORMAT       ' tmf'

#undef FOURCC_DATA
#define FOURCC_DATA         'atad'

#define RPF(level,str,err) \
	{ char outBuf[MAX_PATH]; \
	  wsprintf(outBuf,str,err); \
	  OutputDebugString(outBuf); \
	}


#define DPFLVL_ERROR 1



/***************************************************************************
 *
 *  FillWfx
 *
 *  Description:
 *      Fills a WAVEFORMATEX structure, given only the necessary values.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: structure to fill.
 *      WORD [in]: number of channels.
 *      DWORD [in]: samples per second.
 *      WORD [in]: bits per sample.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME

void FillWfx(LPWAVEFORMATEX pwfx, WORD wChannels, DWORD dwSamplesPerSec, WORD wBitsPerSample)
{
    pwfx->wFormatTag = WAVE_FORMAT_PCM;
    pwfx->nChannels = min(2, max(1, wChannels));
    pwfx->nSamplesPerSec = min(DSBFREQUENCY_MAX, max(DSBFREQUENCY_MIN, dwSamplesPerSec));
    
    if(wBitsPerSample < 12)
    {
        pwfx->wBitsPerSample = 8;
    }
    else
    {
        pwfx->wBitsPerSample = 16;
    }

    pwfx->nBlockAlign = pwfx->nChannels * pwfx->wBitsPerSample / 8;
    pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;
    pwfx->cbSize = 0;
}


#if 0

HRESULT InternalCreateSoundBuffer(LPDSBUFFERDESC pDsbDesc, byte *pbWaveData,DWORD cbWaveData,LPDIRECTSOUND lpDirectSound, LPDIRECTSOUNDBUFFER *lplpDirectSoundBuffer)
{

    HRESULT                 hr                  = DS_OK;
    HACMSTREAM              has                 = NULL;
    BOOL                    fPrep               = FALSE;
    ACMSTREAMHEADER         ash;
    DWORD                   dwBufferBytes;
    LPVOID                  pvWrite;
    DWORD                   cbWrite;
    HMMIO                   hmm                 = NULL;
	MMRESULT                mmr;
	MMIOINFO                mmioinfo;
    MMCKINFO                ckiRiff;
    MMCKINFO                cki;
	LPWAVEFORMATEX          pwfxSrcFormat       = NULL;
    LPWAVEFORMATEX          pwfxDestFormat      = NULL;
	BOOL					bNULLFORMAT			= FALSE;    
	


    ZeroMemory(&mmioinfo, sizeof(mmioinfo));

	if(SUCCEEDED(hr)){
		mmioinfo.fccIOProc = FOURCC_MEM;
		mmioinfo.pchBuffer = (HPSTR)pbWaveData;
		mmioinfo.cchBuffer = cbWaveData;
    
		hmm = mmioOpen(NULL, &mmioinfo, MMIO_READ);
		
		if(!hmm)
		{
			DPF1(1, "Unable to open file via MMIO.  Error %lu", mmioinfo.wErrorRet);
			hr = E_FAIL; 
		}
	 }

    // Decend into the RIFF chunk
    if(SUCCEEDED(hr))
    {
        ckiRiff.ckid = FOURCC_RIFF;
        mmr = mmioDescend(hmm, &ckiRiff, NULL, MMIO_FINDCHUNK);

        if(MMSYSERR_NOERROR != mmr)
        {
            DPF1(1, "Unable to descend into RIFF chunk.  Error %lu", mmr);
            hr = E_FAIL; 
        }
    }

    // Verify that this is a wave file
    if(SUCCEEDED(hr) && FOURCC_WAVE != ckiRiff.fccType)
    {
        DPF1(1, "File is not type WAVE %d",GetLastError());
        hr = DSERR_BADFORMAT;
    }

    // Decend into the format chunk
    if(SUCCEEDED(hr))
    {
        cki.ckid = FOURCC_FORMAT;
        mmr = mmioDescend(hmm, &cki, &ckiRiff, MMIO_FINDCHUNK);

        if(MMSYSERR_NOERROR != mmr)
        {
            DPF1(1, "Unable to descend into format chunk.  Error %lu", mmr);
            hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
        }

        if(SUCCEEDED(hr))
        {
            pwfxSrcFormat = (LPWAVEFORMATEX)(pbWaveData + cki.dwDataOffset);
        }
    }



    // Ascend out of the format chunk
    if(SUCCEEDED(hr))
    {
        mmr = mmioAscend(hmm, &cki, 0);

        if(MMSYSERR_NOERROR != mmr)
        {
            DPF(1, "Unable to ascend out of format chunk.  Error %lu", mmr);
            hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
        }
    }

    // Descend into the data chunk
    if(SUCCEEDED(hr))
    {
        cki.ckid = FOURCC_DATA;
        mmr = mmioDescend(hmm, &cki, &ckiRiff, MMIO_FINDCHUNK);

        if(MMSYSERR_NOERROR != mmr)
        {
            RPF(DPFLVL_ERROR, "Unable to descend into data chunk.  Error %lu", mmr);
            hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
        }
    }

    // Prepare PCM conversion
    if(SUCCEEDED(hr))
    {
        if(WAVE_FORMAT_PCM == pwfxSrcFormat->wFormatTag)
        {
            // Populate the buffer description
            dwBufferBytes = cki.cksize;
            pwfxDestFormat = pwfxSrcFormat;
        }
        else
        {
            // Open an ACM conversion stream
            mmr = acmStreamOpen(&has, NULL, (LPWAVEFORMATEX)pwfxSrcFormat, pwfxDestFormat, NULL, 0, 0, 0);

            if(MMSYSERR_NOERROR != mmr)
            {
                RPF(DPFLVL_ERROR, "Unable to open an ACM stream.  Error %lu", mmr);
                hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
            }

            // Get the size of the PCM data
            if(SUCCEEDED(hr))
            {
                mmr = acmStreamSize(has, cki.cksize, &dwBufferBytes, ACM_STREAMSIZEF_SOURCE);

                if(MMSYSERR_NOERROR != mmr)
                {
                    RPF(DPFLVL_ERROR, "Unable to determine converted data size.  Error %lu", mmr);
                    hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
                }
            }

            // Create the destination format
            if(SUCCEEDED(hr))
            {
                pwfxDestFormat = (WAVEFORMATEX*)malloc(sizeof(WAVEFORMATEX));
                if (pwfxDestFormat==NULL) hr=E_OUTOFMEMORY;				
            }
        
            if(SUCCEEDED(hr))
            {
                FillWfx(pwfxDestFormat, pwfxSrcFormat->nChannels, pwfxSrcFormat->nSamplesPerSec, pwfxSrcFormat->wBitsPerSample);
            }
        }
    }

	
	LPDIRECTSOUNDBUFFER lpDirectSoundBuffer=NULL;
	
    if(SUCCEEDED(hr))
    {
		//hr = InitializeEmpty(pDsbDesc->dwFlags, dwBufferBytes, pwfxDestFormat, NULL);
		pDsbDesc->dwBufferBytes=dwBufferBytes;
		
		if (pDsbDesc->lpwfxFormat){
			memcpy(pDsbDesc->lpwfxFormat,pwfxDestFormat,sizeof(WAVEFORMATEX));
		}
		else {
			pDsbDesc->lpwfxFormat=pwfxDestFormat;
		}

		hr=lpDirectSound->CreateSoundBuffer(pDsbDesc,lplpDirectSoundBuffer,NULL);
		if (*lplpDirectSoundBuffer==NULL) hr= E_FAIL;
		lpDirectSoundBuffer=*lplpDirectSoundBuffer;
	}


    

    // Lock the buffer in order to write the PCM data to it
    if(SUCCEEDED(hr))
    {
        hr = lpDirectSoundBuffer->Lock(0, dwBufferBytes, &pvWrite, &cbWrite, NULL, NULL,0);
    }

    // Convert to PCM
    if(SUCCEEDED(hr))
    {
        if(WAVE_FORMAT_PCM == pwfxSrcFormat->wFormatTag)
        {
            CopyMemory(pvWrite, pbWaveData + cki.dwDataOffset, cbWrite);
        }
        else
        {
            // Prepare the conversion header
            ZeroMemory(&ash, sizeof(ash));

            ash.cbStruct = sizeof(ash);
            ash.pbSrc = pbWaveData + cki.dwDataOffset;
            ash.cbSrcLength = cki.cksize;
            ash.pbDst = (LPBYTE)pvWrite;
            ash.cbDstLength = cbWrite;

            mmr = acmStreamPrepareHeader(has, &ash, 0);

            if(MMSYSERR_NOERROR != mmr)
            {
                RPF(DPFLVL_ERROR, "Unable to prepare ACM stream header.  Error %lu", mmr);
                hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
            }

            fPrep = SUCCEEDED(hr);

            // Convert the buffer
            if(SUCCEEDED(hr))
            {
                mmr = acmStreamConvert(has, &ash, 0);

                if(MMSYSERR_NOERROR != mmr)
                {
                    RPF(DPFLVL_ERROR, "Unable to convert wave data.  Error %lu", mmr);
                    hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
                }
            }
        }
    }

    // Unlock the buffer
    if(SUCCEEDED(hr))
    {
        hr = lpDirectSoundBuffer->Unlock(pvWrite, cbWrite, NULL, 0);
    }

    // Clean up
    if(fPrep)
    {
        acmStreamUnprepareHeader(has, &ash, 0);
    }

    if(has)
    {
        acmStreamClose(has, 0);
    }
    
    if(hmm)
    {
        mmioClose(hmm, 0);
    }

    if(pwfxDestFormat != pwfxSrcFormat)
    {
        free(pwfxDestFormat);
    }

    return hr;

}

#endif


















///////////////////////////////////////////////////////////////////////////////////////////
		

HRESULT InternalCreateSoundBuffer(LPDSBUFFERDESC pDsbDesc, byte *pbWaveData, DWORD cbWaveData,LPDIRECTSOUND lpDirectSound, LPDIRECTSOUNDBUFFER8 *lplpDirectSoundBuffer)
{

    HRESULT                 hr                  = DS_OK;
    HACMSTREAM              has                 = NULL;
    BOOL                    fPrep               = FALSE;    
    DWORD                   dwBufferBytes		= 0;
    LPVOID                  pvWrite				= NULL;
    DWORD                   cbWrite				= 0;
	LPWAVEFORMATEX			pwfxFormat			= NULL;
	LPWAVEFORMATEX          pwfxSrcFormat       = NULL;
    LPWAVEFORMATEX          pwfxDestFormat      = NULL;    
	MMRESULT                mmr					= 0;
	DWORD					dwDataLength		= 0;
	DWORD					dwOffset			= 0;
	char					*pChunk				= NULL;
	LPDIRECTSOUNDBUFFER		lpDirectSoundBuffer	= NULL;
	ACMSTREAMHEADER         ash;
	BOOL					bNULLFORMAT			=FALSE;
	BOOL					bDirty				=FALSE;

	
	struct tag_FileHeader
	{
		DWORD       dwRiff;
		DWORD       dwFileSize;
		DWORD       dwWave;
		DWORD       dwFormat;
		DWORD       dwFormatLength;		
	} FileHeader;
	
	ZeroMemory(&FileHeader,sizeof(struct tag_FileHeader));
	
	//	If our file is big enough to have a header copy it over
	//	other wise error out
	if (cbWaveData>sizeof(struct tag_FileHeader)) 
	{
		memcpy(&FileHeader,pbWaveData,sizeof(struct tag_FileHeader));
	}
	else 
	{
		hr= E_INVALIDARG;
	}

	// File must be a riff file ( 52 R, 49 I, 46 F, 46 F)
	if (FileHeader.dwRiff != 0x46464952) 
	{
		DPF(1, "DXVB: not a RIFF file\n");
		return E_INVALIDARG;	
	}

	//  must be a WAVE format ( 57 W, 41 A, 56 V, 45 E )
	if (FileHeader.dwWave != 0x45564157)
	{
		DPF(1, "DXVB: not a WAVE file\n");
		return E_INVALIDARG;	
	}

	//  check for odd stuff
	//  note 18bytes is a typical WAVEFORMATEX
	if (FileHeader.dwFormatLength <= 14) return E_INVALIDARG;
	if (FileHeader.dwFormatLength > 1000) return E_INVALIDARG;

	//allocate the waveformat
	__try { pwfxFormat=(WAVEFORMATEX*)alloca(FileHeader.dwFormatLength);}	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	if (!pwfxFormat) return E_OUTOFMEMORY;

	//copy it to our own data structure
	pChunk=(char*)(pbWaveData+sizeof (struct tag_FileHeader));
	memcpy(pwfxFormat,pChunk,FileHeader.dwFormatLength);

	
	// Now look for the next chunk after the WaveFormat
	pChunk=(char*)(pChunk+FileHeader.dwFormatLength);
		
	// Look for option FACT chunk and skip it
	//	(66 F, 61 A, 63 C, 74 T)
	// this chunk is required for compressed wave files
	// but is optional for PCM
	//
	if ( ((DWORD*)pChunk)[0]==0x74636166) 
	{
		dwOffset=((DWORD*)pChunk)[1];
		dwBufferBytes=((DWORD*)pChunk)[2];	//number of bytes of PCM data
		pChunk =(char*)(pChunk+ dwOffset+8);	
		
	}

	//Look for required data chunk
	// (64 D, 61 A, 74 T, 61 A)
	if (((DWORD*)pChunk)[0]!=0x61746164) 
	{
				DPF(1, "DXVB: no DATA chunk in wave file\n");
				return E_INVALIDARG;	
	}

	dwDataLength=((DWORD*)pChunk)[1];
	pChunk=(char*)(pChunk+8);
								
	
	//IF we assume PCM 
	//pcm files are not required to have their fact chunk 
	//so be ware they may missreport the data length			
	dwBufferBytes=dwDataLength;	
	pwfxDestFormat=pwfxSrcFormat=pwfxFormat;

	// if we are not PCM then we need to do some things first
	if (pwfxFormat->wFormatTag!=WAVE_FORMAT_PCM)
	{
	

		// source format is from the file 
	
		pwfxSrcFormat=pwfxFormat;				//from file
		pwfxDestFormat=pDsbDesc->lpwfxFormat ;	//from user	
		

		
		//pick the format of the file passed in
		FillWfx(pwfxDestFormat, pwfxSrcFormat->nChannels, pwfxSrcFormat->nSamplesPerSec, pwfxSrcFormat->wBitsPerSample);
		

		// Open an ACM conversion stream
		mmr = acmStreamOpen(&has, NULL, (LPWAVEFORMATEX)pwfxSrcFormat, pwfxDestFormat, NULL, 0, 0, ACM_STREAMOPENF_NONREALTIME );
		if(MMSYSERR_NOERROR != mmr)
		{
			DPF1(1, "Unable to open an ACM stream.  Error %lu\n", mmr);
			return E_FAIL;
		}

	
        // Get the size of the PCM data
        mmr = acmStreamSize(has, dwDataLength, &dwBufferBytes, ACM_STREAMSIZEF_SOURCE);
        if(MMSYSERR_NOERROR != mmr)
        {
            DPF1(1, "Unable to determine converted data size.  Error %lu\n", mmr);
            return E_FAIL; //MMRESULTtoHRESULT(mmr);
        }
   

		// Allocate a DestFormat struct
        //pwfxDestFormat = (WAVEFORMATEX*)alloca(sizeof(WAVEFORMATEX));
        //if (!pwfxDestFormat) return E_OUTOFMEMORY;				
        

		// Fill the format with information from the source but
		// FillWfx sets the format to PCM
        //FillWfx(pwfxDestFormat, pwfxSrcFormat->nChannels, pwfxSrcFormat->nSamplesPerSec, pwfxSrcFormat->wBitsPerSample);
        

    }

	
	// fill the buffer desc the user passed in with the buffer bytes
	// this is the number of PCM bytes
	pDsbDesc->dwBufferBytes=dwBufferBytes;
	
	// if they provide us a pointer to a waveformatex
	// copy over the format to the input desc and use it
	// otherwise have it point to our data format temprarily
	if (pDsbDesc->lpwfxFormat){
			memcpy(pDsbDesc->lpwfxFormat,pwfxDestFormat,sizeof(WAVEFORMATEX));
		}
	else {
		pDsbDesc->lpwfxFormat=pwfxDestFormat;
		//make sure we null out the format before passing it back to the user
		//NOTE: consider the problems in a multithreaded enviroment
		//where the users data structures are being accesed by multiple
		//threads... on the other hand if thats going on..
		//then the user would need to syncronize things on his or her own 
		//for everything else including calling into apis that fill structures..
		bNULLFORMAT=TRUE;		
	}

	LPDIRECTSOUNDBUFFER		dsbTemp = NULL;
	// Create the buffer
	if (FAILED(hr=lpDirectSound->CreateSoundBuffer(pDsbDesc,&dsbTemp,NULL) ) )
		return hr;

	hr = dsbTemp->QueryInterface(IID_IDirectSoundBuffer8, (void**) lplpDirectSoundBuffer);
	dsbTemp->Release();
	if (FAILED(hr)) return hr;

	if (*lplpDirectSoundBuffer==NULL) return E_FAIL;	//todo ASSERT this instead..
	
	// for more convenient referencing...
	lpDirectSoundBuffer=*lplpDirectSoundBuffer;
	
    
    // Lock the buffer in order to write the PCM data to it
	// cbWrite will contain the number of locked bytes
    hr = lpDirectSoundBuffer->Lock(0, dwBufferBytes, &pvWrite, &cbWrite, NULL, NULL,0);
	if FAILED(hr) return hr;


	// If the sorce format was pcm then copy from the file to the buffer
    if(WAVE_FORMAT_PCM == pwfxSrcFormat->wFormatTag)
    {
    	CopyMemory(pvWrite, pChunk, cbWrite);


		// Unlock the buffer
		hr = lpDirectSoundBuffer->Unlock(pvWrite, cbWrite, NULL, 0);
    
		if (FAILED(hr)) 
		{
			 DPF(1, "DXVB: lpDirectSoundBuffer->Unlock failed.. \n");
			 return hr;
		}

    }

	// if the source format is compressed then convert first then copy
    else
    {
            // Prepare the conversion header
            ZeroMemory(&ash, sizeof(ash));

            ash.cbStruct = sizeof(ash);
            ash.pbSrc = (unsigned char*)pChunk;	//start of compressed data
            ash.cbSrcLength = dwDataLength;		//number of bytes of compressed data
            ash.pbDst = (LPBYTE)pvWrite;		//where to put the decompressed data
            ash.cbDstLength = cbWrite;			//how big is that buffer

            mmr = acmStreamPrepareHeader(has, &ash, 0);

            if(MMSYSERR_NOERROR != mmr)
            {
                DPF1(1, "DXVB: Unable to prepare ACM stream header.  Error %lu \n", mmr);
                return E_FAIL;
            }

            
            mmr = acmStreamConvert(has, &ash, 0);

            if(MMSYSERR_NOERROR != mmr)
            {
				DPF1(1, "DXVB:  Unable to convert wave data.  Error %lu \n", mmr);
                return hr;  
            }

			// Unlock the buffer
			hr = lpDirectSoundBuffer->Unlock(pvWrite, cbWrite, NULL, 0);
			if (FAILED(hr)) 
			{
				DPF(1, "DXVB: lpDirectSoundBuffer->Unlock failed.. \n");
				return hr;
			}

		    acmStreamUnprepareHeader(has, &ash, 0);
	        acmStreamClose(has, 0);
    }
    
	
	if (bNULLFORMAT){
		pDsbDesc->lpwfxFormat=NULL;
	}

    return hr;

}





HRESULT InternalCreateSoundBufferFromFile(LPDIRECTSOUND8 lpDirectSound,LPDSBUFFERDESC pDesc,WCHAR *file,LPDIRECTSOUNDBUFFER8 *lplpDirectSoundBuffer) 
{
		HRESULT					hr=S_OK;
	    HANDLE                  hFile               = NULL;
	    HANDLE                  hFileMapping        = NULL;
	    DWORD                   cbWaveData;
		LPBYTE                  pbWaveData          = NULL;

		#pragma message("CreateFileW should be used for localization why wont it work")
		//hFile = CreateFileW(file, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);        
		
		USES_CONVERSION;
		LPSTR pStrA = NULL;
		__try { pStrA = W2T(file); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

		hFile = CreateFileA(pStrA, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);        
		
        if(INVALID_HANDLE_VALUE == hFile)
        {
            hFile = NULL;
        }

        if(!hFile)
        {
            RPF(DPFLVL_ERROR, "Unable to open file.  Error %lu", GetLastError());
            hr=STG_E_FILENOTFOUND;
			return hr;
        }

        if(hFile)
        {
            cbWaveData = GetFileSize(hFile, NULL);

            if(-1 == cbWaveData)
            {
                RPF(DPFLVL_ERROR, "Unable to get file size.  Error %lu", GetLastError());
                hr = E_FAIL; //DSERR_FILEREADFAULT;
            }
        }

        if(SUCCEEDED(hr))
        {
            hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, cbWaveData, NULL);

            if(INVALID_HANDLE_VALUE == hFileMapping)
            {
                hFileMapping = NULL;
            }
            
            if(!hFileMapping)
            {
                RPF(DPFLVL_ERROR, "Unable to create file mapping.  Error %lu", GetLastError());
                hr = E_FAIL; //DSERR_FILEREADFAULT;
            }
        }

        if(SUCCEEDED(hr))
        {
            pbWaveData = (LPBYTE)MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, cbWaveData);

            if(!pbWaveData)
            {
                RPF(DPFLVL_ERROR, "Unable to map view of file.  Error %lu", GetLastError());
                hr = E_FAIL; //DSERR_FILEREADFAULT;
            }
        }

		if(SUCCEEDED(hr)) {
			hr=InternalCreateSoundBuffer(pDesc, pbWaveData, cbWaveData,lpDirectSound, lplpDirectSoundBuffer);
		}

	    if(pbWaveData)
        {
            UnmapViewOfFile(pbWaveData);
        }

        if(hFileMapping)
        {
            CloseHandle(hFileMapping);
        }
        
        if(hFile)
        {
            CloseHandle(hFile);
        }
		

		return hr;
    

}

HRESULT InternalCreateSoundBufferFromResource(LPDIRECTSOUND8 lpDirectSound,LPDSBUFFERDESC pDesc,HANDLE resHandle,WCHAR *resName,LPDIRECTSOUNDBUFFER8 *lplpDirectSoundBuffer)
{
    const LPCSTR            apszResourceTypeA[] = { "WAVE", "WAV" };
    const LPCWSTR           apszResourceTypeW[] = { L"WAVE", L"WAV" };
    UINT                    cResourceType       = 2;
    HRSRC                   hRsrc               = NULL;
    DWORD                   cbWaveData;
    LPBYTE                  pbWaveData          = NULL;
	HRESULT					hr=S_OK;
	
	LPCDSBUFFERDESC	pDsbDesc=pDesc;

    
	while(!hRsrc && cResourceType--)
    {
        hRsrc = FindResourceW((HINSTANCE)resHandle, resName, apszResourceTypeW[cResourceType]);            
    }

    if(!hRsrc)
    {
		RPF(DPFLVL_ERROR,"Unable to find resource.  Error %lu", GetLastError());
        hr = STG_E_FILENOTFOUND;
    }

    if(SUCCEEDED(hr))
    {
        cbWaveData = SizeofResource((HINSTANCE)resHandle, hRsrc);
        if(!cbWaveData)
        {

            RPF(DPFLVL_ERROR, "Unable to get resource size.  Error %lu", GetLastError());
            hr = E_FAIL;
        }
    }
        
    if(SUCCEEDED(hr))
    {                
        pbWaveData = (LPBYTE)LoadResource((HINSTANCE)resHandle, hRsrc);            
        if(!pbWaveData)
        {
            RPF(DPFLVL_ERROR, "Unable to load resource.  Error %lu", GetLastError());
            hr = E_FAIL;
        }
    }

	if(SUCCEEDED(hr)) {
		hr=InternalCreateSoundBuffer(pDesc, pbWaveData, cbWaveData,lpDirectSound, lplpDirectSoundBuffer);
	}

	//loadResource
   return hr;
}




HRESULT InternalSaveToFile(IDirectSoundBuffer *pBuff,BSTR file)
{
	WAVEFORMATEX waveFormat;
	DWORD dwWritten=0;
	DWORD dwBytes=0;
	LPBYTE lpByte=NULL;
	HRESULT hr;
	HANDLE hFile=NULL;

	if (!pBuff) return E_FAIL;
	if (!file) return E_INVALIDARG;

	
	pBuff->GetFormat(&waveFormat,sizeof(WAVEFORMATEX),NULL);


    

	USES_CONVERSION;
	LPSTR pStrA = NULL;
	__try { pStrA = W2T(file); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

    hFile = CreateFile 
                (
                    pStrA,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                );
	if (INVALID_HANDLE_VALUE != hFile)
    {
			
		struct tag_FileHeader
		{
			DWORD       dwRiff;
			DWORD       dwFileSize;
			DWORD       dwWave;
			DWORD       dwFormat;
			DWORD       dwFormatLength;
			WORD        wFormatTag;
			WORD        nChannels;
			DWORD       nSamplesPerSec;
			DWORD       nAvgBytesPerSec;
			WORD        nBlockAlign;
			WORD        wBitsPerSample;
			DWORD       dwData;
			DWORD       dwDataLength;
		} FileHeader;    

		hr=pBuff->Lock(0,0,(void**)&lpByte,&dwBytes,NULL,NULL,DSBLOCK_ENTIREBUFFER);
		if FAILED(hr) {
			CloseHandle(hFile);
			return hr;
		}

        FileHeader.dwRiff             = 0x46464952;                // RIFF
        FileHeader.dwWave             = 0x45564157;                // WAVE
        FileHeader.dwFormat           = 0x20746D66;                // fmt_chnk
        FileHeader.dwFormatLength     = 16; 
	    FileHeader.wFormatTag         = WAVE_FORMAT_PCM;
	    FileHeader.nChannels          = waveFormat.nChannels ;
	    FileHeader.nSamplesPerSec     = waveFormat.nSamplesPerSec ;
	    FileHeader.wBitsPerSample     = waveFormat.wBitsPerSample ;
	    FileHeader.nBlockAlign        = FileHeader.wBitsPerSample / 8 * FileHeader.nChannels;
	    FileHeader.nAvgBytesPerSec    = FileHeader.nSamplesPerSec * FileHeader.nBlockAlign;
        FileHeader.dwData             = 0x61746164;					// data_chnk
        FileHeader.dwDataLength       = dwBytes;
        FileHeader.dwFileSize         = dwBytes + sizeof(FileHeader);


        WriteFile(hFile, &FileHeader, sizeof(FileHeader), &dwWritten, NULL);
        

        WriteFile(hFile, lpByte, dwBytes, &dwWritten, NULL);

		hr=pBuff->Unlock(lpByte,0,NULL,0); 

        CloseHandle(hFile);
    }
    else{
		return E_FAIL;
	}
    

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\daytona\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\win9x\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\xfileenumobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DirectXFileEnumObject :
		public I_dxj_DirectXFileEnum,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DirectXFileEnumObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectXFileEnum)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectXFileEnumObject)

public:
		C_dxj_DirectXFileEnumObject();	
		~C_dxj_DirectXFileEnumObject();

         HRESULT STDMETHODCALLTYPE GetNextDataObject( 
            /* [retval][out] */ I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *ret) ;
        
         HRESULT STDMETHODCALLTYPE GetDataObjectById( 
            /* [in] */ BSTR id,
            I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *ret) ;
        
         HRESULT STDMETHODCALLTYPE GetDataObjectByName( 
            /* [in] */ BSTR id,
            I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *ret);

		HRESULT Init( IDirectXFileEnumObject *pEnum);
		 static HRESULT C_dxj_DirectXFileEnumObject::create(IDirectXFileEnumObject  *pEnum, I_dxj_DirectXFileEnum **ret);		

private:
		IDirectXFileEnumObject *m_pXFileEnum;
	
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\xfileobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"

#include "dxfile.h"
//#include "rmxftmpl.h"
#include "rmxfguid.h"

unsigned char D3DRM_XTEMPLATES2[] = {
        0x78, 0x6f, 0x66, 0x20, 0x30, 0x33, 0x30, 0x32, 0x62, 
        0x69, 0x6e, 0x20, 0x30, 0x30, 0x36, 0x34, 0x1f, 0, 0x1, 
        0, 0x6, 0, 0, 0, 0x48, 0x65, 0x61, 0x64, 0x65, 
        0x72, 0xa, 0, 0x5, 0, 0x43, 0xab, 0x82, 0x3d, 0xda, 
        0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 
        0x33, 0x28, 0, 0x1, 0, 0x5, 0, 0, 0, 0x6d, 
        0x61, 0x6a, 0x6f, 0x72, 0x14, 0, 0x28, 0, 0x1, 0, 
        0x5, 0, 0, 0, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x14, 
        0, 0x29, 0, 0x1, 0, 0x5, 0, 0, 0, 0x66, 
        0x6c, 0x61, 0x67, 0x73, 0x14, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 0x74, 
        0x6f, 0x72, 0xa, 0, 0x5, 0, 0x5e, 0xab, 0x82, 0x3d, 
        0xda, 0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 
        0xe4, 0x33, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 0, 
        0x78, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 
        0, 0x79, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 
        0, 0, 0x7a, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
        0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6f, 0x72, 0x64, 
        0x73, 0x32, 0x64, 0xa, 0, 0x5, 0, 0x44, 0x3f, 0xf2, 
        0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
        0x35, 0x94, 0xa3, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 
        0, 0x75, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 
        0, 0, 0x76, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
        0, 0x9, 0, 0, 0, 0x4d, 0x61, 0x74, 0x72, 0x69, 
        0x78, 0x34, 0x78, 0x34, 0xa, 0, 0x5, 0, 0x45, 0x3f, 
        0xf2, 0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 
        0x33, 0x35, 0x94, 0xa3, 0x34, 0, 0x2a, 0, 0x1, 0, 
        0x6, 0, 0, 0, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 
        0xe, 0, 0x3, 0, 0x10, 0, 0, 0, 0xf, 0, 
        0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x9, 0, 
        0, 0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 
        0x41, 0xa, 0, 0x5, 0, 0xe0, 0x44, 0xff, 0x35, 0x7c, 
        0x6c, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 
        0xa3, 0x2a, 0, 0x1, 0, 0x3, 0, 0, 0, 0x72, 
        0x65, 0x64, 0x14, 0, 0x2a, 0, 0x1, 0, 0x5, 0, 
        0, 0, 0x67, 0x72, 0x65, 0x65, 0x6e, 0x14, 0, 0x2a, 
        0, 0x1, 0, 0x4, 0, 0, 0, 0x62, 0x6c, 0x75, 
        0x65, 0x14, 0, 0x2a, 0, 0x1, 0, 0x5, 0, 0, 
        0, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x14, 0, 0xb, 0, 
        0x1f, 0, 0x1, 0, 0x8, 0, 0, 0, 0x43, 0x6f, 
        0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0xa, 0, 0x5, 0, 
        0x81, 0x6e, 0xe1, 0xd3, 0x35, 0x78, 0xcf, 0x11, 0x8f, 0x52, 
        0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x2a, 0, 0x1, 0, 
        0x3, 0, 0, 0, 0x72, 0x65, 0x64, 0x14, 0, 0x2a, 
        0, 0x1, 0, 0x5, 0, 0, 0, 0x67, 0x72, 0x65, 
        0x65, 0x6e, 0x14, 0, 0x2a, 0, 0x1, 0, 0x4, 0, 
        0, 0, 0x62, 0x6c, 0x75, 0x65, 0x14, 0, 0xb, 0, 
        0x1f, 0, 0x1, 0, 0xc, 0, 0, 0, 0x49, 0x6e, 
        0x64, 0x65, 0x78, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
        0xa, 0, 0x5, 0, 0x20, 0xb8, 0x30, 0x16, 0x42, 0x78, 
        0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
        0x29, 0, 0x1, 0, 0x5, 0, 0, 0, 0x69, 0x6e, 
        0x64, 0x65, 0x78, 0x14, 0, 0x1, 0, 0x9, 0, 0, 
        0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0x41, 
        0x1, 0, 0xa, 0, 0, 0, 0x69, 0x6e, 0x64, 0x65, 
        0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0xb, 0, 
        0x1f, 0, 0x1, 0, 0x7, 0, 0, 0, 0x42, 0x6f, 
        0x6f, 0x6c, 0x65, 0x61, 0x6e, 0xa, 0, 0x5, 0, 0xa0, 
        0xa6, 0x7d, 0x53, 0x37, 0xca, 0xd0, 0x11, 0x94, 0x1c, 0, 
        0x80, 0xc8, 0xc, 0xfa, 0x7b, 0x29, 0, 0x1, 0, 0x9, 
        0, 0, 0, 0x74, 0x72, 0x75, 0x65, 0x66, 0x61, 0x6c, 
        0x73, 0x65, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
        0x9, 0, 0, 0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 
        0x6e, 0x32, 0x64, 0xa, 0, 0x5, 0, 0x63, 0xae, 0x85, 
        0x48, 0xe8, 0x78, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
        0x35, 0x94, 0xa3, 0x1, 0, 0x7, 0, 0, 0, 0x42, 
        0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 0x1, 0, 
        0, 0, 0x75, 0x14, 0, 0x1, 0, 0x7, 0, 0, 
        0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 
        0x1, 0, 0, 0, 0x76, 0x14, 0, 0xb, 0, 0x1f, 
        0, 0x1, 0, 0xc, 0, 0, 0, 0x4d, 0x61, 0x74, 
        0x65, 0x72, 0x69, 0x61, 0x6c, 0x57, 0x72, 0x61, 0x70, 0xa, 
        0, 0x5, 0, 0x60, 0xae, 0x85, 0x48, 0xe8, 0x78, 0xcf, 
        0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x1, 
        0, 0x7, 0, 0, 0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 
        0x61, 0x6e, 0x1, 0, 0x1, 0, 0, 0, 0x75, 0x14, 
        0, 0x1, 0, 0x7, 0, 0, 0, 0x42, 0x6f, 0x6f, 
        0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 0x1, 0, 0, 0, 
        0x76, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0xf, 
        0, 0, 0, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 
        0x46, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0xa, 0, 
        0x5, 0, 0xe1, 0x90, 0x27, 0xa4, 0x10, 0x78, 0xcf, 0x11, 
        0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x31, 0, 
        0x1, 0, 0x8, 0, 0, 0, 0x66, 0x69, 0x6c, 0x65, 
        0x6e, 0x61, 0x6d, 0x65, 0x14, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0x8, 0, 0, 0, 0x4d, 0x61, 0x74, 0x65, 
        0x72, 0x69, 0x61, 0x6c, 0xa, 0, 0x5, 0, 0x4d, 0xab, 
        0x82, 0x3d, 0xda, 0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 
        0xaf, 0x71, 0xe4, 0x33, 0x1, 0, 0x9, 0, 0, 0, 
        0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0x41, 0x1, 
        0, 0x9, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 0x43, 
        0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0x2a, 0, 0x1, 0, 
        0x5, 0, 0, 0, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x14, 
        0, 0x1, 0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6c, 
        0x6f, 0x72, 0x52, 0x47, 0x42, 0x1, 0, 0xd, 0, 0, 
        0, 0x73, 0x70, 0x65, 0x63, 0x75, 0x6c, 0x61, 0x72, 0x43, 
        0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0x1, 0, 0x8, 0, 
        0, 0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 
        0x1, 0, 0xd, 0, 0, 0, 0x65, 0x6d, 0x69, 0x73, 
        0x73, 0x69, 0x76, 0x65, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x14, 
        0, 0xe, 0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 
        0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x8, 0, 0, 
        0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 0x63, 0x65, 0xa, 
        0, 0x5, 0, 0x5f, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 
        0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0x29, 
        0, 0x1, 0, 0x12, 0, 0, 0, 0x6e, 0x46, 0x61, 
        0x63, 0x65, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x6e, 
        0x64, 0x69, 0x63, 0x65, 0x73, 0x14, 0, 0x34, 0, 0x29, 
        0, 0x1, 0, 0x11, 0, 0, 0, 0x66, 0x61, 0x63, 
        0x65, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x6e, 0x64, 
        0x69, 0x63, 0x65, 0x73, 0xe, 0, 0x1, 0, 0x12, 0, 
        0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x56, 0x65, 0x72, 
        0x74, 0x65, 0x78, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 
        0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
        0xd, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 
        0x63, 0x65, 0x57, 0x72, 0x61, 0x70, 0x73, 0xa, 0, 0x5, 
        0, 0xc0, 0xc5, 0x1e, 0xed, 0xa8, 0xc0, 0xd0, 0x11, 0x94, 
        0x1c, 0, 0x80, 0xc8, 0xc, 0xfa, 0x7b, 0x29, 0, 0x1, 
        0, 0xf, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 
        0x57, 0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 
        0x14, 0, 0x34, 0, 0x1, 0, 0x9, 0, 0, 0, 
        0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x32, 0x64, 0x1, 
        0, 0xe, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 0x57, 
        0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0xe, 
        0, 0x1, 0, 0xf, 0, 0, 0, 0x6e, 0x46, 0x61, 
        0x63, 0x65, 0x57, 0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 
        0x65, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0x11, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 
        0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 0x6f, 
        0x72, 0x64, 0x73, 0xa, 0, 0x5, 0, 0x40, 0x3f, 0xf2, 
        0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
        0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xe, 0, 0, 
        0, 0x6e, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 
        0x6f, 0x6f, 0x72, 0x64, 0x73, 0x14, 0, 0x34, 0, 0x1, 
        0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6f, 0x72, 0x64, 
        0x73, 0x32, 0x64, 0x1, 0, 0xd, 0, 0, 0, 0x74, 
        0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 0x6f, 0x72, 
        0x64, 0x73, 0xe, 0, 0x1, 0, 0xe, 0, 0, 0, 
        0x6e, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 
        0x6f, 0x72, 0x64, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 
        0x1f, 0, 0x1, 0, 0x10, 0, 0, 0, 0x4d, 0x65, 
        0x73, 0x68, 0x4d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 
        0x4c, 0x69, 0x73, 0x74, 0xa, 0, 0x5, 0, 0x42, 0x3f, 
        0xf2, 0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 
        0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xa, 0, 
        0, 0, 0x6e, 0x4d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 
        0x6c, 0x73, 0x14, 0, 0x29, 0, 0x1, 0, 0xc, 0, 
        0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x49, 0x6e, 0x64, 
        0x65, 0x78, 0x65, 0x73, 0x14, 0, 0x34, 0, 0x29, 0, 
        0x1, 0, 0xb, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 
        0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0xe, 0, 0x1, 
        0, 0xc, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 
        0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0xf, 0, 0x14, 
        0, 0xe, 0, 0x1, 0, 0x8, 0, 0, 0, 0x4d, 
        0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 0xf, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0xb, 0, 0, 0, 0x4d, 
        0x65, 0x73, 0x68, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
        0xa, 0, 0x5, 0, 0x43, 0x3f, 0xf2, 0xf6, 0x86, 0x76, 
        0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
        0x29, 0, 0x1, 0, 0x8, 0, 0, 0, 0x6e, 0x4e, 
        0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 0x14, 0, 0x34, 0, 
        0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 0x74, 
        0x6f, 0x72, 0x1, 0, 0x7, 0, 0, 0, 0x6e, 0x6f, 
        0x72, 0x6d, 0x61, 0x6c, 0x73, 0xe, 0, 0x1, 0, 0x8, 
        0, 0, 0, 0x6e, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 
        0x73, 0xf, 0, 0x14, 0, 0x29, 0, 0x1, 0, 0xc, 
        0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x4e, 0x6f, 
        0x72, 0x6d, 0x61, 0x6c, 0x73, 0x14, 0, 0x34, 0, 0x1, 
        0, 0x8, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 
        0x61, 0x63, 0x65, 0x1, 0, 0xb, 0, 0, 0, 0x66, 
        0x61, 0x63, 0x65, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
        0xe, 0, 0x1, 0, 0xc, 0, 0, 0, 0x6e, 0x46, 
        0x61, 0x63, 0x65, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
        0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
        0x10, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x56, 0x65, 
        0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x73, 
        0xa, 0, 0x5, 0, 0x21, 0xb8, 0x30, 0x16, 0x42, 0x78, 
        0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
        0x29, 0, 0x1, 0, 0xd, 0, 0, 0, 0x6e, 0x56, 
        0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
        0x73, 0x14, 0, 0x34, 0, 0x1, 0, 0xc, 0, 0, 
        0, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x64, 0x43, 0x6f, 
        0x6c, 0x6f, 0x72, 0x1, 0, 0xc, 0, 0, 0, 0x76, 
        0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
        0x73, 0xe, 0, 0x1, 0, 0xd, 0, 0, 0, 0x6e, 
        0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 
        0x72, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0x4, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 
        0xa, 0, 0x5, 0, 0x44, 0xab, 0x82, 0x3d, 0xda, 0x62, 
        0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 
        0x29, 0, 0x1, 0, 0x9, 0, 0, 0, 0x6e, 0x56, 
        0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0x14, 0, 0x34, 
        0, 0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 
        0x74, 0x6f, 0x72, 0x1, 0, 0x8, 0, 0, 0, 0x76, 
        0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0xe, 0, 0x1, 
        0, 0x9, 0, 0, 0, 0x6e, 0x56, 0x65, 0x72, 0x74, 
        0x69, 0x63, 0x65, 0x73, 0xf, 0, 0x14, 0, 0x29, 0, 
        0x1, 0, 0x6, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 
        0x65, 0x73, 0x14, 0, 0x34, 0, 0x1, 0, 0x8, 0, 
        0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 0x63, 0x65, 
        0x1, 0, 0x5, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 
        0x73, 0xe, 0, 0x1, 0, 0x6, 0, 0, 0, 0x6e, 
        0x46, 0x61, 0x63, 0x65, 0x73, 0xf, 0, 0x14, 0, 0xe, 
        0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0x14, 0, 0, 0, 0x46, 
        0x72, 0x61, 0x6d, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 
        0x6f, 0x72, 0x6d, 0x4d, 0x61, 0x74, 0x72, 0x69, 0x78, 0xa, 
        0, 0x5, 0, 0x41, 0x3f, 0xf2, 0xf6, 0x86, 0x76, 0xcf, 
        0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x1, 
        0, 0x9, 0, 0, 0, 0x4d, 0x61, 0x74, 0x72, 0x69, 
        0x78, 0x34, 0x78, 0x34, 0x1, 0, 0xb, 0, 0, 0, 
        0x66, 0x72, 0x61, 0x6d, 0x65, 0x4d, 0x61, 0x74, 0x72, 0x69, 
        0x78, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x5, 
        0, 0, 0, 0x46, 0x72, 0x61, 0x6d, 0x65, 0xa, 0, 
        0x5, 0, 0x46, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 0x11, 
        0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0xe, 0, 
        0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 0, 
        0x1f, 0, 0x1, 0, 0x9, 0, 0, 0, 0x46, 0x6c, 
        0x6f, 0x61, 0x74, 0x4b, 0x65, 0x79, 0x73, 0xa, 0, 0x5, 
        0, 0xa9, 0x46, 0xdd, 0x10, 0x5b, 0x77, 0xcf, 0x11, 0x8f, 
        0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 
        0, 0x7, 0, 0, 0, 0x6e, 0x56, 0x61, 0x6c, 0x75, 
        0x65, 0x73, 0x14, 0, 0x34, 0, 0x2a, 0, 0x1, 0, 
        0x6, 0, 0, 0, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 
        0xe, 0, 0x1, 0, 0x7, 0, 0, 0, 0x6e, 0x56, 
        0x61, 0x6c, 0x75, 0x65, 0x73, 0xf, 0, 0x14, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0xe, 0, 0, 0, 0x54, 
        0x69, 0x6d, 0x65, 0x64, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 
        0x65, 0x79, 0x73, 0xa, 0, 0x5, 0, 0x80, 0xb1, 0x6, 
        0xf4, 0x3b, 0x7b, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
        0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0x4, 0, 0, 
        0, 0x74, 0x69, 0x6d, 0x65, 0x14, 0, 0x1, 0, 0x9, 
        0, 0, 0, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 0x65, 
        0x79, 0x73, 0x1, 0, 0x6, 0, 0, 0, 0x74, 0x66, 
        0x6b, 0x65, 0x79, 0x73, 0x14, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0xc, 0, 0, 0, 0x41, 0x6e, 0x69, 0x6d, 
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4b, 0x65, 0x79, 0xa, 0, 
        0x5, 0, 0xa8, 0x46, 0xdd, 0x10, 0x5b, 0x77, 0xcf, 0x11, 
        0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 
        0x1, 0, 0x7, 0, 0, 0, 0x6b, 0x65, 0x79, 0x54, 
        0x79, 0x70, 0x65, 0x14, 0, 0x29, 0, 0x1, 0, 0x5, 
        0, 0, 0, 0x6e, 0x4b, 0x65, 0x79, 0x73, 0x14, 0, 
        0x34, 0, 0x1, 0, 0xe, 0, 0, 0, 0x54, 0x69, 
        0x6d, 0x65, 0x64, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 0x65, 
        0x79, 0x73, 0x1, 0, 0x4, 0, 0, 0, 0x6b, 0x65, 
        0x79, 0x73, 0xe, 0, 0x1, 0, 0x5, 0, 0, 0, 
        0x6e, 0x4b, 0x65, 0x79, 0x73, 0xf, 0, 0x14, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0x10, 0, 0, 0, 0x41, 
        0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4f, 0x70, 
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0xa, 0, 0x5, 0, 0xc0, 
        0x56, 0xbf, 0xe2, 0xf, 0x84, 0xcf, 0x11, 0x8f, 0x52, 0, 
        0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xa, 
        0, 0, 0, 0x6f, 0x70, 0x65, 0x6e, 0x63, 0x6c, 0x6f, 
        0x73, 0x65, 0x64, 0x14, 0, 0x29, 0, 0x1, 0, 0xf, 
        0, 0, 0, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 
        0x6e, 0x71, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x14, 0, 
        0xb, 0, 0x1f, 0, 0x1, 0, 0x9, 0, 0, 0, 
        0x41, 0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0xa, 
        0, 0x5, 0, 0x4f, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 
        0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0xe, 
        0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0xc, 0, 0, 0, 0x41, 
        0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65, 
        0x74, 0xa, 0, 0x5, 0, 0x50, 0xab, 0x82, 0x3d, 0xda, 
        0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 
        0x33, 0xe, 0, 0x1, 0, 0x9, 0, 0, 0, 0x41, 
        0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0xf, 0, 
        0xb, 0, 0x1f, 0, 0x1, 0, 0xa, 0, 0, 0, 
        0x49, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x61, 0x74, 0x61, 
        0xa, 0, 0x5, 0, 0xa0, 0xee, 0x23, 0x3a, 0xb1, 0x94, 
        0xd0, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 
        0xe, 0, 0x1, 0, 0x6, 0, 0, 0, 0x42, 0x49, 
        0x4e, 0x41, 0x52, 0x59, 0xf, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0x3, 0, 0, 0, 0x55, 0x72, 0x6c, 0xa, 
        0, 0x5, 0, 0xa1, 0xee, 0x23, 0x3a, 0xb1, 0x94, 0xd0, 
        0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0x29, 
        0, 0x1, 0, 0x5, 0, 0, 0, 0x6e, 0x55, 0x72, 
        0x6c, 0x73, 0x14, 0, 0x34, 0, 0x31, 0, 0x1, 0, 
        0x4, 0, 0, 0, 0x75, 0x72, 0x6c, 0x73, 0xe, 0, 
        0x1, 0, 0x5, 0, 0, 0, 0x6e, 0x55, 0x72, 0x6c, 
        0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
        0, 0xf, 0, 0, 0, 0x50, 0x72, 0x6f, 0x67, 0x72, 
        0x65, 0x73, 0x73, 0x69, 0x76, 0x65, 0x4d, 0x65, 0x73, 0x68, 
        0xa, 0, 0x5, 0, 0x60, 0xc3, 0x63, 0x8a, 0x7d, 0x99, 
        0xd0, 0x11, 0x94, 0x1c, 0, 0x80, 0xc8, 0xc, 0xfa, 0x7b, 
        0xe, 0, 0x1, 0, 0x3, 0, 0, 0, 0x55, 0x72, 
        0x6c, 0x13, 0, 0x1, 0, 0xa, 0, 0, 0, 0x49, 
        0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x61, 0x74, 0x61, 0xf, 
        0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x4, 0, 0, 
        0, 0x47, 0x75, 0x69, 0x64, 0xa, 0, 0x5, 0, 0xe0, 
        0x90, 0x27, 0xa4, 0x10, 0x78, 0xcf, 0x11, 0x8f, 0x52, 0, 
        0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0x5, 
        0, 0, 0, 0x64, 0x61, 0x74, 0x61, 0x31, 0x14, 0, 
        0x28, 0, 0x1, 0, 0x5, 0, 0, 0, 0x64, 0x61, 
        0x74, 0x61, 0x32, 0x14, 0, 0x28, 0, 0x1, 0, 0x5, 
        0, 0, 0, 0x64, 0x61, 0x74, 0x61, 0x33, 0x14, 0, 
        0x34, 0, 0x2d, 0, 0x1, 0, 0x5, 0, 0, 0, 
        0x64, 0x61, 0x74, 0x61, 0x34, 0xe, 0, 0x3, 0, 0x8, 
        0, 0, 0, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 
        0, 0x1, 0, 0xe, 0, 0, 0, 0x53, 0x74, 0x72, 
        0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 
        0x79, 0xa, 0, 0x5, 0, 0xe0, 0x21, 0xf, 0x7f, 0xe1, 
        0xbf, 0xd1, 0x11, 0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 
        0x71, 0x31, 0, 0x1, 0, 0x3, 0, 0, 0, 0x6b, 
        0x65, 0x79, 0x14, 0, 0x31, 0, 0x1, 0, 0x5, 0, 
        0, 0, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x14, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0xb, 0, 0, 0, 0x50, 
        0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x42, 0x61, 0x67, 
        0xa, 0, 0x5, 0, 0xe1, 0x21, 0xf, 0x7f, 0xe1, 0xbf, 
        0xd1, 0x11, 0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 0x71, 
        0xe, 0, 0x1, 0, 0xe, 0, 0, 0, 0x53, 0x74, 
        0x72, 0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 
        0x74, 0x79, 0xf, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
        0xe, 0, 0, 0, 0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 
        0x61, 0x6c, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0xa, 0, 
        0x5, 0, 0xa0, 0x6a, 0x11, 0x98, 0xba, 0xbd, 0xd1, 0x11, 
        0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 0x71, 0x1, 0, 
        0x4, 0, 0, 0, 0x47, 0x75, 0x69, 0x64, 0x1, 0, 
        0x12, 0, 0, 0, 0x67, 0x75, 0x69, 0x64, 0x45, 0x78, 
        0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x56, 0x69, 0x73, 0x75, 
        0x61, 0x6c, 0x14, 0, 0xe, 0, 0x12, 0, 0x12, 0, 
        0x12, 0, 0xf, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
        0xb, 0, 0, 0, 0x52, 0x69, 0x67, 0x68, 0x74, 0x48, 
        0x61, 0x6e, 0x64, 0x65, 0x64, 0xa, 0, 0x5, 0, 0xa0, 
        0x5e, 0x5d, 0x7f, 0x3a, 0xd5, 0xd1, 0x11, 0x82, 0xc0, 0, 
        0xa0, 0xc9, 0x69, 0x72, 0x71, 0x29, 0, 0x1, 0, 0xc, 
        0, 0, 0, 0x62, 0x52, 0x69, 0x67, 0x68, 0x74, 0x48, 
        0x61, 0x6e, 0x64, 0x65, 0x64, 0x14, 0, 0xb, 0
};

#define D3DRM_XTEMPLATE_BYTES 3278

#include "rmxfguid.h"

#include "XfileObj.h"
#include "XfileSaveObj.h"
#include "XfileEnumObj.h"

WCHAR *szXFileGuids[]={
	L"TID_D3DRMInfo",
	L"TID_D3DRMMesh",
	L"TID_D3DRMVector",
	L"TID_D3DRMMeshFace",
	L"TID_D3DRMMaterial",
	L"TID_D3DRMMaterialArray",
	L"TID_D3DRMFrame",
	L"TID_D3DRMFrameTransformMatrix",
	L"TID_D3DRMMeshMaterialList",
	L"TID_D3DRMMeshTextureCoords",
	L"TID_D3DRMMeshNormals",
	L"TID_D3DRMCoords2d",
	L"TID_D3DRMMatrix4x4",
	L"TID_D3DRMAnimation",
	L"TID_D3DRMAnimationSet",
	L"TID_D3DRMAnimationKey",
	L"TID_D3DRMFloatKeys",
	L"TID_D3DRMMaterialAmbientColor",
	L"TID_D3DRMMaterialDiffuseColor",
	L"TID_D3DRMMaterialSpecularColor",
	L"TID_D3DRMMaterialEmissiveColor",
	L"TID_D3DRMMaterialPower",
	L"TID_D3DRMColorRGBA",
	L"TID_D3DRMColorRGB",
	L"TID_D3DRMGuid",
	L"TID_D3DRMTextureFilename",
	L"TID_D3DRMTextureReference",
	L"TID_D3DRMIndexedColor",
	L"TID_D3DRMMeshVertexColors",
	L"TID_D3DRMMaterialWrap",
	L"TID_D3DRMBoolean",
	L"TID_D3DRMMeshFaceWraps",
	L"TID_D3DRMBoolean2d",
	L"TID_D3DRMTimedFloatKeys",
	L"TID_D3DRMAnimationOptions",
	L"TID_D3DRMFramePosition",
	L"TID_D3DRMFrameVelocity",
	L"TID_D3DRMFrameRotation",
	L"TID_D3DRMLight",
	L"TID_D3DRMCamera",
	L"TID_D3DRMAppData",
	L"TID_D3DRMLightUmbra",
	L"TID_D3DRMLightRange",
	L"TID_D3DRMLightPenumbra",
	L"TID_D3DRMLightAttenuation",
	L"TID_D3DRMInlineData",
	L"TID_D3DRMUrl",
	L"TID_D3DRMProgressiveMesh",
	L"TID_D3DRMExternalVisual",
	L"TID_D3DRMStringProperty",
	L"TID_D3DRMPropertyBag",
	L"TID_D3DRMRightHanded"
};

const GUID *XFileGuids[]={
	&TID_D3DRMInfo,
	&TID_D3DRMMesh,
	&TID_D3DRMVector,
	&TID_D3DRMMeshFace,
	&TID_D3DRMMaterial,
	&TID_D3DRMMaterialArray,
	&TID_D3DRMFrame,
	&TID_D3DRMFrameTransformMatrix,
	&TID_D3DRMMeshMaterialList,
	&TID_D3DRMMeshTextureCoords,
	&TID_D3DRMMeshNormals,
	&TID_D3DRMCoords2d,
	&TID_D3DRMMatrix4x4,
	&TID_D3DRMAnimation,
	&TID_D3DRMAnimationSet,
	&TID_D3DRMAnimationKey,
	&TID_D3DRMFloatKeys,
	&TID_D3DRMMaterialAmbientColor,
	&TID_D3DRMMaterialDiffuseColor,
	&TID_D3DRMMaterialSpecularColor,
	&TID_D3DRMMaterialEmissiveColor,
	&TID_D3DRMMaterialPower,
	&TID_D3DRMColorRGBA,
	&TID_D3DRMColorRGB,
	&TID_D3DRMGuid,
	&TID_D3DRMTextureFilename,
	&TID_D3DRMTextureReference,
	&TID_D3DRMIndexedColor,
	&TID_D3DRMMeshVertexColors,
	&TID_D3DRMMaterialWrap,
	&TID_D3DRMBoolean,
	&TID_D3DRMMeshFaceWraps,
	&TID_D3DRMBoolean2d,
	&TID_D3DRMTimedFloatKeys,
	&TID_D3DRMAnimationOptions,
	&TID_D3DRMFramePosition,
	&TID_D3DRMFrameVelocity,
	&TID_D3DRMFrameRotation,
	&TID_D3DRMLight,
	&TID_D3DRMCamera,
	&TID_D3DRMAppData,
	&TID_D3DRMLightUmbra,
	&TID_D3DRMLightRange,
	&TID_D3DRMLightPenumbra,
	&TID_D3DRMLightAttenuation,
	&TID_D3DRMInlineData,
	&TID_D3DRMUrl,
	&TID_D3DRMProgressiveMesh,
	&TID_D3DRMExternalVisual,
	&TID_D3DRMStringProperty,
	&TID_D3DRMPropertyBag,
	&TID_D3DRMRightHanded
};

#define NUM_XFILE_GUIDS 52

extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);

HRESULT XFILEBSTRtoGUID(LPGUID lpG,BSTR strG)
{
	if (!strG) {
		ZeroMemory(lpG,sizeof(GUID));
		return S_OK;
	}

	if (strG[0]==0) {
		ZeroMemory(lpG,sizeof(GUID));
		return S_OK;
	}

	for(int i=0;i<NUM_XFILE_GUIDS;i++){
		if (0==_wcsicmp((WCHAR*)strG,szXFileGuids[i]))
		{
			memcpy(lpG,XFileGuids[i],sizeof(GUID));
			return S_OK;
		}		
	}

	return BSTRtoGUID (lpG,strG);
}

    #define GUIDS_EQUAL2(g,g2) (\
    	(g->Data1==g2->Data1) && \
    	(g->Data2==g2->Data2) && \
    	(g->Data3==g2->Data3) && \
    	(g->Data4[0]==g2->Data4[0]) && \
    	(g->Data4[1]==g2->Data4[1]) && \
    	(g->Data4[2]==g2->Data4[2]) && \
    	(g->Data4[3]==g2->Data4[3]) && \
    	(g->Data4[4]==g2->Data4[4]) && \
    	(g->Data4[5]==g2->Data4[5]) && \
    	(g->Data4[6]==g2->Data4[6]) && \
    	(g->Data4[7]==g2->Data4[7]) )

BSTR XFILEGUIDtoBSTR(LPGUID lpG)
{
	if (!lpG) return NULL;

	for(int i=0;i<NUM_XFILE_GUIDS;i++)
	{
		//
		if (GUIDS_EQUAL2(XFileGuids[i],lpG)){
			return SysAllocString(szXFileGuids[i]);	
		}
		
	}
	

	return GUIDtoBSTR(lpG);
}


C_dxj_DirectXFileObject::C_dxj_DirectXFileObject()
{
	m_pDirectXFile=NULL;
}
C_dxj_DirectXFileObject::~C_dxj_DirectXFileObject()
{
	if (m_pDirectXFile) m_pDirectXFile->Release();
}

HRESULT C_dxj_DirectXFileObject::create( I_dxj_DirectXFile **ret)
{	
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
	
	
	C_dxj_DirectXFileObject *c=NULL;
	c=new CComObject<C_dxj_DirectXFileObject>;
	if( c == NULL ) return E_OUTOFMEMORY;

	hr=c->Init();

	if FAILED(hr) {
		delete c;
		return hr;
	}
	hr=c->QueryInterface(IID_I_dxj_DirectXFile, (void**)ret);
	return hr;

}

HRESULT C_dxj_DirectXFileObject::Init ()
{
	HRESULT hr;
	hr=DirectXFileCreate(&m_pDirectXFile);	
	return hr;
}

HRESULT C_dxj_DirectXFileObject::CreateEnumObject( 
            /* [in] */ BSTR __RPC_FAR filename,
            /* [retval][out] */ I_dxj_DirectXFileEnum __RPC_FAR *__RPC_FAR *ret)
{
	USES_CONVERSION;
	HRESULT hr;

	LPSTR szName = NULL;
	__try { szName = W2T(filename); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	LPDIRECTXFILEENUMOBJECT pEnum=NULL;

	hr=m_pDirectXFile->CreateEnumObject(szName,DXFILELOAD_FROMFILE ,&pEnum);
	if FAILED(hr) return hr;

	hr=C_dxj_DirectXFileEnumObject::create (pEnum,ret);
	if FAILED(hr) {
		pEnum->Release();
	}
	return hr;

}

        
HRESULT C_dxj_DirectXFileObject::CreateSaveObject( 
            /* [in] */ BSTR filename,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DirectXFileSave __RPC_FAR *__RPC_FAR *ret)
{
	USES_CONVERSION;
	HRESULT hr;

	LPSTR szName = NULL;
	__try { szName = W2T(filename); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	LPDIRECTXFILESAVEOBJECT pSave=NULL;

	hr=m_pDirectXFile->CreateSaveObject(szName,(DWORD)flags, &pSave);
	if FAILED(hr) return hr;

	//Note ::create does addref pSave on success
	hr=C_dxj_DirectXFileSaveObject::create (pSave,ret);
	if (pSave) pSave->Release();

	return hr;
}

        
HRESULT C_dxj_DirectXFileObject::RegisterTemplates( 
            /* [in] */ void __RPC_FAR *temp,
            /* [in] */ long size)
{
	HRESULT hr;

	__try{

		hr=m_pDirectXFile->RegisterTemplates(temp,(DWORD)size);
		if FAILED(hr) return hr;
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}

        
HRESULT C_dxj_DirectXFileObject::RegisterDefaultTemplates( void) 
{
	HRESULT hr;
	hr=m_pDirectXFile->RegisterTemplates(D3DRM_XTEMPLATES2,D3DRM_XTEMPLATE_BYTES );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\xfilesaveobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"

#include "dxfile.h"
#include "XFileSaveObj.h"
#include "XFileDataObj.h"



extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);

C_dxj_DirectXFileSaveObject::C_dxj_DirectXFileSaveObject()
{
	m_pXfileSave=NULL;
}
C_dxj_DirectXFileSaveObject::~C_dxj_DirectXFileSaveObject()
{
	if (m_pXfileSave) m_pXfileSave->Release();
} 

HRESULT C_dxj_DirectXFileSaveObject::create( IDirectXFileSaveObject *pSave, I_dxj_DirectXFileSave **ret)
{	
	HRESULT hr;
	if (!ret) return E_INVALIDARG;	
	if (!pSave) return E_INVALIDARG;

	C_dxj_DirectXFileSaveObject *c=NULL;
	c=new CComObject<C_dxj_DirectXFileSaveObject>;
	if( c == NULL ) return E_OUTOFMEMORY;

	c->m_pXfileSave=pSave;
	pSave->AddRef();

	hr=c->QueryInterface(IID_I_dxj_DirectXFileSave, (void**)ret);
	return hr;

}



STDMETHODIMP C_dxj_DirectXFileSaveObject::SaveTemplates( 
            /* [in] */ long count,
            SAFEARRAY __RPC_FAR * __RPC_FAR *templateGuids) 
{
	HRESULT hr;
	GUID *pGuids=NULL;
	GUID **ppGuids=NULL;

	if (count<=0) return E_INVALIDARG;
	if (!templateGuids) return E_INVALIDARG;
	if (!((SAFEARRAY*)*templateGuids)->pvData) return E_INVALIDARG;

	__try { pGuids=(GUID*)alloca(sizeof(GUID)*count);}	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	__try { ppGuids=(GUID**)alloca(sizeof(GUID*)*count);}	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	if (!pGuids) return E_OUTOFMEMORY;	

	__try 
        {	
	   for (long i=0;i<count;i++)
           {
  	   	hr=BSTRtoGUID(&(pGuids[i]),((BSTR*)(((SAFEARRAY*)*templateGuids)->pvData))[i]);
	   	if FAILED(hr) return E_INVALIDARG;
		ppGuids[i]=&(pGuids[i]);
           }
        }
	__except(1,1)
        {
	   return E_INVALIDARG;
        }

	hr=m_pXfileSave->SaveTemplates((DWORD)count,(const GUID **) ppGuids);

	return hr;

}
        
STDMETHODIMP C_dxj_DirectXFileSaveObject::CreateDataObject( 
            /* [in] */ BSTR templateGuid,
            /* [in] */ BSTR name,
            /* [in] */ BSTR dataTypeGuid,
            /* [in] */ long bytecount,
            /* [in] */ void __RPC_FAR *data,
            /* [retval][out] */ I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *ret) 
{
	USES_CONVERSION;

	HRESULT hr;
	IDirectXFileData *pXFileData=NULL;
	GUID *lpGuidTemplate=NULL;
	GUID *lpGuidDataType=NULL;
	char *szName=NULL;

	//use lazy evaluation
	if ((templateGuid)&&(templateGuid[0]!=0)) 
	{
		__try { lpGuidTemplate=(GUID*)alloca(sizeof(GUID));}	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	  ZeroMemory(lpGuidTemplate,sizeof(GUID));
	  hr=BSTRtoGUID(lpGuidTemplate,templateGuid);
	  if FAILED(hr) return hr;
	}

	if (!lpGuidTemplate) return E_INVALIDARG;
	

	//use lazy evaluation
	if ((name)&&(name[0]!=0))
	{	
		__try { szName = W2T(name); }	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	}

	//use lazy evaluation
	if ((dataTypeGuid)&&(dataTypeGuid[0]!=0)) 
	{
		__try { lpGuidDataType=(GUID*)alloca(sizeof(GUID));}	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	  ZeroMemory(lpGuidDataType,sizeof(GUID));
	  hr=BSTRtoGUID(lpGuidDataType,dataTypeGuid);
	  if FAILED(hr) return hr;
	}

	__try {
		hr=m_pXfileSave->CreateDataObject(*lpGuidTemplate,szName,lpGuidDataType,(DWORD)bytecount,data,&pXFileData);
	}
	__except (1,1)
	{
		return E_INVALIDARG;
	}


	if FAILED(hr) return hr;
		
	hr=C_dxj_DirectXFileDataObject::create(pXFileData,ret);
	
	return hr;
}
 
       
STDMETHODIMP C_dxj_DirectXFileSaveObject::SaveData( 
            /* [in] */ I_dxj_DirectXFileData __RPC_FAR *dataObj) 
{
	HRESULT hr;

	if (!dataObj) return E_INVALIDARG;
	
	IDirectXFileData *pDataObj=NULL;

	dataObj->InternalGetObject((IUnknown**)&pDataObj);	

	hr=m_pXfileSave->SaveData(pDataObj);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\xfilereferenceobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DirectXFileReferenceObject :
		public I_dxj_DirectXFileReference,
		public I_dxj_DirectXFileObject,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DirectXFileReferenceObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectXFileReference)
		COM_INTERFACE_ENTRY(I_dxj_DirectXFileObject)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectXFileReferenceObject)

public:
		C_dxj_DirectXFileReferenceObject();	
		~C_dxj_DirectXFileReferenceObject();

		HRESULT STDMETHODCALLTYPE GetName( /* [retval][out] */ BSTR __RPC_FAR *name) ;
        
		HRESULT STDMETHODCALLTYPE GetId( 	 /* [retval][out] */ BSTR __RPC_FAR *name);
        
		HRESULT STDMETHODCALLTYPE Resolve( /* [retval][out] */ I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *obj) ;
        

		HRESULT Init(IDirectXFileDataReference *pref);

		 static HRESULT C_dxj_DirectXFileReferenceObject::create( IDirectXFileDataReference *pref, I_dxj_DirectXFileReference **ret);		


private:
		IDirectXFileDataReference *m_pXFileReference;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\xfileobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DirectXFileObject :
		public I_dxj_DirectXFile,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DirectXFileObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectXFile)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectXFileObject)

public:
		C_dxj_DirectXFileObject();	
		~C_dxj_DirectXFileObject();

      
        HRESULT STDMETHODCALLTYPE CreateEnumObject( 
            /* [in] */ BSTR __RPC_FAR filename,
            /* [retval][out] */ I_dxj_DirectXFileEnum __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE CreateSaveObject( 
            /* [in] */ BSTR filename,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DirectXFileSave __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE RegisterTemplates( 
            /* [in] */ void __RPC_FAR *temp,
            /* [in] */ long size) ;
        
        HRESULT STDMETHODCALLTYPE RegisterDefaultTemplates( void) ;
        
		HRESULT Init();    

		static HRESULT C_dxj_DirectXFileObject::create( I_dxj_DirectXFile **ret);		

private:
		IDirectXFile *m_pDirectXFile;
	
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\xfilereferenceobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"

#include "dxfile.h"
#include "xfileDataobj.h"
#include "XFileReferenceObj.h"



extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT XFILEBSTRtoGUID(LPGUID,BSTR);
extern BSTR XFILEGUIDtoBSTR(LPGUID);

C_dxj_DirectXFileReferenceObject::C_dxj_DirectXFileReferenceObject()
{
	m_pXFileReference=NULL;
}
C_dxj_DirectXFileReferenceObject::~C_dxj_DirectXFileReferenceObject()
{
	if (m_pXFileReference) m_pXFileReference->Release();
}

HRESULT C_dxj_DirectXFileReferenceObject::create( IDirectXFileDataReference *pRef,I_dxj_DirectXFileReference **ret)
{	
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
	

	C_dxj_DirectXFileReferenceObject *c=NULL;
	c=new CComObject<C_dxj_DirectXFileReferenceObject>;
	if( c == NULL ) return E_OUTOFMEMORY;

	c->Init(pRef);

	hr=IUNK(c)->QueryInterface(IID_I_dxj_DirectXFileReference, (void**)ret);
	return hr;

}

HRESULT C_dxj_DirectXFileReferenceObject::Init(IDirectXFileDataReference *pRef)
{
	m_pXFileReference=pRef;
	return S_OK;
}



STDMETHODIMP C_dxj_DirectXFileReferenceObject::GetName( 
    /* [retval][out] */ BSTR __RPC_FAR *name)
{
	HRESULT hr;
	USES_CONVERSION;

	char szName[1024];
	DWORD dwSize=1024;
	hr=m_pXFileReference->GetName(szName,&dwSize);
	if FAILED(hr) return hr;
	*name=T2BSTR(szName);

	return S_OK;
}


STDMETHODIMP C_dxj_DirectXFileReferenceObject::GetId( 
    /* [retval][out] */ BSTR __RPC_FAR *name)
{
	HRESULT hr;
	GUID g;
	ZeroMemory(&g,sizeof(GUID));

	hr=m_pXFileReference->GetId(&g);
	if FAILED(hr) return hr;

	*name=XFILEGUIDtoBSTR(&g);
	return hr;
}

HRESULT C_dxj_DirectXFileReferenceObject::Resolve( 
            /* [retval][out] */ I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *obj) 
{
	HRESULT hr;
	IDirectXFileData *pData=NULL;
	hr=m_pXFileReference->Resolve(&pData);
	if FAILED(hr) return hr;
	if (!pData) 
	{
		*obj=NULL;
		return S_OK;
	}

	hr=C_dxj_DirectXFileDataObject::create(pData,obj);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx8vb\xfilesaveobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DirectXFileSaveObject :
		public I_dxj_DirectXFileSave,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DirectXFileSaveObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectXFileSave)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectXFileSaveObject)

public:
	C_dxj_DirectXFileSaveObject();	
	~C_dxj_DirectXFileSaveObject();

	HRESULT STDMETHODCALLTYPE SaveTemplates( 
            /* [in] */ long count,
            SAFEARRAY __RPC_FAR * __RPC_FAR *templateGuids) ;
        
        HRESULT STDMETHODCALLTYPE CreateDataObject( 
            /* [in] */ BSTR templateGuid,
            /* [in] */ BSTR name,
            /* [in] */ BSTR dataTypeGuid,
            /* [in] */ long bytecount,
            /* [in] */ void __RPC_FAR *data,
            /* [retval][out] */ I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *ret) ;
        
	HRESULT STDMETHODCALLTYPE SaveData( 
            /* [in] */ I_dxj_DirectXFileData __RPC_FAR *dataObj) ;
        

	static HRESULT C_dxj_DirectXFileSaveObject::create( IDirectXFileSaveObject *pSave ,I_dxj_DirectXFileSave **ret);		

	
	IDirectXFileSaveObject *m_pXfileSave;	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\advanced.cpp ===
/*
File:       Advanced.cpp
Project:    Joystick Control Panel OLE Client
Author: Brycej
Date:       02/07/97
Comments:
    Window proc for Avanced page in cpanel

Copyright (c) 1997, Microsoft Corporation
*/
// This is necessary LVS_EX_INFOTIP
/*
#if (_WIN32_IE < 0x0500)
#undef _WIN32_IE
#define  _WIN32_IE  0x0500
#endif
*/

#include <afxcmn.h>
#include <windowsx.h>

#include <cpl.h>

#include <winuser.h>  // For RegisterDeviceNotification stuff!
#include <dbt.h>      // for DBT_ defines!!!

#include "cpanel.h"
#include "hsvrguid.h"

#include "resource.h"
#include "joyarray.h"

// MyListCtrl prototypes
#include "inplace.h"

#define USE_DEFAULT     0x1000      // If this bit is set, the device is going to use GCDEF!
#define SHOW_DEFAULT 0x2000     // Show default check box if clsidConfig is != CLSID_LegacyServer

// constants
const short NO_ITEM     = -1;                                    

#define DEVICE_ID       0 
#define DEVICE_FRIENDLY 1
#define DEVICE_TYPE     2
#define DEVICE_PORT     3

LPCWSTR lpMSANALOG_VXD = L"MSANALOG.VXD";
LPTSTR  lpstrNone;

#define ADVANCED_ID_COLUMN      0
#define ADVANCED_DEVICE_COLUMN  1

extern const DWORD gaHelpIDs[];

// externs for arguements!
extern BYTE nID, nStartPageDef, nStartPageCPL;

// Update flag!
extern short nFlags;

// local (module-scope) variables
HWND hAdvListCtrl;

#ifdef _UNICODE
static PVOID hAdvNotifyDevNode;
#endif

extern short iItem;
static HWND ghDlg;

//static UINT JoyCfgChangedMsg;
static BOOL bProcess;

// Message Procedures for handling VK_DELETE in Advanced window
static WNDPROC fpMainWndProc;
static BOOL WINAPI SubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Message Procedures for handling the VK_ENTER/VK_DELETE in Adv Window
static WNDPROC fpPageWndProc;
static BOOL WINAPI KeySubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

short iAdvItem = NO_ITEM;   // index of selected item
char  iGameportDriverItem = NO_ITEM;
short nOldID;

// externs
extern IDirectInputJoyConfig *pDIJoyConfig;
extern LPDIRECTINPUT lpDIInterface;

extern BYTE nGameportBus;
extern PJOY pAssigned[MAX_ASSIGNED];  // List of assigned devices
extern BYTE nAssigned;                // Number of elements in pAssigned array
extern HINSTANCE ghInstance;

#ifdef WINNT
    // external function defined in CPANEL.CPP
    extern void RunWDMJOY            ( void );
#endif

// local message handlers
static BOOL OnInitDialog    (HWND, HWND, LPARAM);
static void OnCommand       (HWND, int, HWND, UINT);
static BOOL OnNotify           (HWND, WPARAM, LPNMHDR);
static void OnDestroy       (HWND);
static void OnAdvHelp       (LPARAM);
static void OnContextMenu   (WPARAM wParam, LPARAM lParam);
static void OnListviewContextMenu ( LPARAM lParam );

// local utility fns
static BOOL SetActiveGlobalDriver ( void );
static BOOL AdvUpdateListCtrl        ( void );
static BOOL UpdateChangeListCtrl  ( HWND hCtrl );

#ifndef _UNICODE
static void PopulateGlobalPortDriverComboBox( void );
extern WCHAR *pwszGameportDriverArray[MAX_GLOBAL_PORT_DRIVERS];
extern BYTE nGameportDriver;          // Global Port Driver Enumeration Counter
    #define POLL_FLAGS_REG_STR  TEXT("PollFlags")
#endif

static void LaunchChange             ( HWND     hTmp );
int CALLBACK CompareIDItems      (LPARAM item1, LPARAM item2, LPARAM uDirection);

void EditSubLabel( BYTE nItem, BYTE nCol );

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    AdvancedProc(HWND hDlg, UINT uMsg, WPARAM wParam,  LPARAM lParam)
//
// PARAMETERS:  hDlg    - 
//             uMsg    - 
//             wParam  -
//             lParam  -
//
// PURPOSE:     Main callback function for "Advanced"  sheet
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK AdvancedProc(HWND hDlg, UINT uMsg, WPARAM wParam,  LPARAM lParam)
{
    switch( uMsg )
    {
    case WM_ACTIVATEAPP:
        if( wParam )
            SetListCtrlItemFocus(hAdvListCtrl, (BYTE)iAdvItem);
        break;

    case WM_DEVICECHANGE:
        switch( (UINT)wParam )
        {
        case DBT_DEVICEARRIVAL:
//         case DBT_DEVICEREMOVECOMPLETE:
            // Clear the old "known devices" list
            nFlags |= UPDATE_ALL;

            // Clear pAssigned 
            while( nAssigned )
            {
                if( pAssigned[--nAssigned] )
                {
                    delete[] (pAssigned[nAssigned]);

                    pAssigned[nAssigned] = 0;
                }
            }

            // Rebuild the "known devices" list - pAssigned
            lpDIInterface->EnumDevices(DIDEVTYPE_JOYSTICK, (LPDIENUMDEVICESCALLBACK)DIEnumDevicesProc, (LPVOID)hDlg, DIEDFL_ALLDEVICES);

            AdvUpdateListCtrl();
            break;
        }
        break;

    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(GetParent(hDlg), WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

    case WM_INITDIALOG:
        if( !HANDLE_WM_INITDIALOG(hDlg, wParam, lParam, OnInitDialog) )
        {
            // Fix #108983 NT, Remove Flash on Error condition.
            SetWindowPos(::GetParent(hDlg), HWND_BOTTOM, 0, 0, 0, 0, SWP_HIDEWINDOW);
            DestroyWindow(hDlg);
        }
        return(TRUE);

    case WM_COMMAND:
        HANDLE_WM_COMMAND(hDlg, wParam, lParam, OnCommand);
        return(TRUE);

    case WM_DESTROY:
        return(HANDLE_WM_DESTROY(hDlg, wParam, lParam, OnDestroy));

    case WM_NOTIFY:
        return(HANDLE_WM_NOTIFY(hDlg, wParam, lParam, OnNotify));

    case WM_HELP:
        OnAdvHelp(lParam);
        return(TRUE);

    case WM_CONTEXTMENU:
        OnContextMenu(wParam, lParam);
        return(TRUE);

    default:
        break;
    }
    return(0);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnInitDialog(HWND hDlg, HWND hWnd, LPARAM lParam)
//
// PARAMETERS:  hDlg    - 
//                 hWnd    - 
//                 lParam  -
//
// PURPOSE:     WM_INITDIALOG message handler
///////////////////////////////////////////////////////////////////////////////
BOOL OnInitDialog(HWND hDlg, HWND hWnd, LPARAM lParam)
{
    bProcess = TRUE;

    // Just in case Advanced is launched as the startup page!
    if( !lpDIInterface )
    {
        if( FAILED(DirectInputCreate(ghInstance, DIRECTINPUT_VERSION, &lpDIInterface, NULL)) )
        {
#ifdef _DEBUG
            OutputDebugString(TEXT("GCDEF.DLL: DirectInputCreate() failed\n"));
#endif
            Error((short)IDS_INTERNAL_ERROR, (short)IDS_NO_DIJOYCONFIG);
            return(FALSE);
        }

        if( !pDIJoyConfig )
        {
            if( FAILED(lpDIInterface->QueryInterface(IID_IDirectInputJoyConfig, (LPVOID*)&pDIJoyConfig)) )
            {
#ifdef _DEBUG
                OutputDebugString (TEXT("JOY.CPL: CoCreateInstance Failed... Closing CPL!\n"));
#endif
                Error((short)IDS_INTERNAL_ERROR, (short)IDS_NO_DIJOYCONFIG);

                return(FALSE);
            }

            VERIFY(SUCCEEDED(pDIJoyConfig->SetCooperativeLevel(hDlg, DISCL_EXCLUSIVE | DISCL_BACKGROUND)));

            // Enumerate all the Types! 
            VERIFY(SUCCEEDED(pDIJoyConfig->EnumTypes((LPDIJOYTYPECALLBACK)DIEnumJoyTypeProc, NULL)));

            // If you're here, you came in via the CMD line arg and you need to enumerate for devices so...
            lpDIInterface->EnumDevices(DIDEVTYPE_JOYSTICK, (LPDIENUMDEVICESCALLBACK)DIEnumDevicesProc, (LPVOID)hDlg, DIEDFL_ALLDEVICES);
        }
    }

    // if we find an object, then enable the Change... button
    //HWND hChangeCtrl = GetDlgItem(hDlg, IDC_ADV_CHANGE);

    // Determine Privilege and disable Change accordingly!
    if( pDIJoyConfig->Acquire() == DIERR_INSUFFICIENTPRIVS )
    {
        // Assign here because the Advanced sheet could be launched first
        // via command line args!
        nFlags |= USER_MODE;

        //PostEnableWindow(hChangeCtrl, FALSE);
    }
#ifdef WINNT
    else
    {
        // Run the WDMJOY.INF file!!!
        RunWDMJOY();
    }
#endif

    // set the global dialog handle
    ghDlg = hDlg;

    // blj: TODO: Make advanced page update on JOYCONFIGCHANGED message!
    // JOY_CONFIGCHANGED_MSGSTRING defined in MMDDK.H   
    //JoyCfgChangedMsg = RegisterWindowMessage(JOY_CONFIGCHANGED_MSGSTRING);

    // initialize our list control
    hAdvListCtrl = GetDlgItem(hDlg, IDC_ADV_LIST_DEVICE);

#ifdef _UNICODE
    // Set the Attributes!                                                   Removed LVS_EX_ONECLICKACTIVATE per GSeirra  | LVS_EX_INFOTIP
    ::SendMessage(hAdvListCtrl, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_HEADERDRAGDROP);
#else
    ::SendMessage(hAdvListCtrl, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP);
#endif

    RECT rc;
    GetClientRect(hAdvListCtrl, &rc);
    rc.left = (short)((rc.right-GetSystemMetrics(SM_CXVSCROLL))/5);

    // Set up the columns!
#ifdef _UNICODE
    InsertColumn(hAdvListCtrl, DEVICE_ID,         IDS_ADV_DEVICE_HEADING,  (USHORT)(rc.left >> 1 ));
    InsertColumn(hAdvListCtrl, DEVICE_FRIENDLY, IDS_ADV_DEVICE_FRIENDLY, (USHORT)(rc.left + (rc.left>>1)));
    InsertColumn(hAdvListCtrl, DEVICE_TYPE,       IDS_ADV_GAME_CONTROLLERS,    (USHORT)(rc.left << 1    ));
    InsertColumn(hAdvListCtrl, DEVICE_PORT,       IDS_ADV_DEVICE_PORT,     (USHORT)(rc.left         ));

    // Remove the Global Port Driver stuff!!!
    const USHORT nCtrlArray[] = {IDC_TEXT_PORTDRIVER, IDC_COMBO1, IDC_ADV_GRP2, IDC_TEXT_DRIVER};
    BYTE nIndex = sizeof(nCtrlArray)/sizeof(short);

    while( DestroyWindow(GetDlgItem(hDlg, nCtrlArray[--nIndex])) );

#else
    rc.right = (rc.left << 1) + (rc.left >> 2);
    InsertColumn(hAdvListCtrl, DEVICE_ID,         IDS_ADV_DEVICE_HEADING,  (USHORT)(rc.left >> 1));
    InsertColumn(hAdvListCtrl, DEVICE_FRIENDLY, IDS_ADV_DEVICE_FRIENDLY, (USHORT)rc.right);
    InsertColumn(hAdvListCtrl, DEVICE_TYPE,       IDS_ADV_GAME_CONTROLLERS,    (USHORT)rc.right);
#endif


    lpstrNone = new TCHAR[STR_LEN_32];
    ASSERT (lpstrNone);

    // everyone needs the "None" string so I've loaded it here!
    VERIFY(LoadString(ghInstance, IDS_NONE, lpstrNone, STR_LEN_32));

    fpMainWndProc = (WNDPROC)SetWindowLongPtr(hAdvListCtrl, GWLP_WNDPROC, (LONG_PTR)SubClassProc);

    // Only center the dialog if this was the page that we started on!
    if( nStartPageCPL == 1 )
    {
        HWND hParentWnd = GetParent(hDlg);

        GetWindowRect(hParentWnd, &rc);

        // Centre the Dialog!
        SetWindowPos(hParentWnd, NULL, 
                     (GetSystemMetrics(SM_CXSCREEN) - (rc.right-rc.left))>>1, 
                     (GetSystemMetrics(SM_CYSCREEN) - (rc.bottom-rc.top))>>1, 
                     NULL, NULL, SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

        // Do that move button thing!
        MoveOK(hParentWnd);

        // Set the Update flag...
        nFlags |= UPDATE_FOR_ADV;
    }

    // the user is requesting that the CPL be shown
    // and an extention associated with nID be Launched.
    if( nID < NUMJOYDEVS )
    {
        LaunchExtention(hDlg);

        // Zero out so you don't do it twice!
        nID = 0;
    }

    // SetActive will use this flag to make sure that the ListCtrl is populated!
    nFlags |= UPDATE_FOR_ADV;

    return(TRUE);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code)
//
// PARAMETERS:  hDlg    - 
//             id      - 
//             hWndCtl -
//             code    -
//
// PURPOSE:     WM_COMMAND message handler
///////////////////////////////////////////////////////////////////////////////
void OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code)
{
    // Hit the "What's This..."
    switch( id )
    {
    case IDC_RENAME:
        // Only SubClass when we need to!
        if( !(nFlags & USER_MODE) )
        {
            HWND hParentWnd = GetParent(GetDlgItem(hDlg, IDC_ADV_LIST_DEVICE));
            // this is required because the CPL can be launched via RUNDLL32
            if( ::IsWindow(hParentWnd) )
                hParentWnd = GetParent(hParentWnd);

            if( !fpPageWndProc )
                fpPageWndProc = (WNDPROC)SetWindowLongPtr(hParentWnd, GWLP_WNDPROC, (LONG_PTR)KeySubClassProc);

            nFlags |= UPDATE_INPROCESS;

            // Find the column as it Could have been moved!
            LPTSTR szName = new (TCHAR[STR_LEN_32]);
            ASSERT (szName);

            // First, Load the string of the column we are looking to find!
            if( LoadString(ghInstance, IDS_ADV_DEVICE_FRIENDLY, szName, STR_LEN_32) )
            {
                // Now, traverse the columns to find the one with the title that matches szName!
                HWND hHeader = GetDlgItem(hAdvListCtrl, 0);

                BYTE nColumns = (BYTE)::SendMessage(hHeader, HDM_GETITEMCOUNT, 0, 0L);


                HDITEM *phdItem = new (HDITEM);
                ASSERT (phdItem);

                ZeroMemory(phdItem, sizeof(HD_ITEM));


                phdItem->pszText      = new TCHAR[STR_LEN_32];
                ASSERT (phdItem->pszText);

                phdItem->cchTextMax = STR_LEN_32;
                phdItem->mask         = HDI_TEXT | HDI_ORDER;

                do
                {
                    ::SendMessage(hHeader, HDM_GETITEM, (WPARAM)(int)--nColumns, (LPARAM)(LPHDITEM)phdItem);

                    if( _tcscmp(phdItem->pszText, szName) == 0 )
                    {
                        nColumns = (BYTE)phdItem->iOrder;
                        break;  
                    }
                } while( nColumns );

                if( phdItem->pszText )
                    delete[] (phdItem->pszText);

                if( phdItem )
                    delete (phdItem);

                EditSubLabel( (BYTE)iAdvItem, nColumns );
            }

            if( szName )
                delete[] (szName);
        }
        break;

    case IDS_WHATSTHIS:
        {
            // point to help file
            LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
            ASSERT (pszHelpFileName);

            if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
                WinHelp((HWND)hAdvListCtrl, pszHelpFileName, HELP_WM_HELP, (ULONG_PTR)gaHelpIDs);
#ifdef _DEBUG
            else OutputDebugString(TEXT("JOY.CPL: Advanced.cpp: OnCommand: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif // _DEBUG

            if( pszHelpFileName )
                delete[] (pszHelpFileName);
        }
        break;

#ifndef _UNICODE
        // this is the handler for the Global Port Driver Combo box
    case IDC_COMBO1:
        if( code == CBN_SELCHANGE )
            SetActiveGlobalDriver();
        break;

        // handler for PollFlags entry in the registry for the Global Port Driver
    case IDC_POLLFLAGS:
        if( iGameportDriverItem == NO_ITEM )
            break;

        if( SUCCEEDED(pDIJoyConfig->Acquire()) )
        {
            HKEY hKey; 

            VERIFY(SUCCEEDED(pDIJoyConfig->OpenTypeKey(pwszGameportDriverArray[iGameportDriverItem], KEY_ALL_ACCESS, &hKey)));

            // this entry is only valid if the user is running MSANALOG.VXD!
            DWORD nFlags = (IsDlgButtonChecked(hDlg, id)) ? 1 : 0;

            RegSetValueEx(hKey, POLL_FLAGS_REG_STR, 0, REG_BINARY, (PBYTE)&nFlags, sizeof(nFlags));

            RegCloseKey(hKey);

            pDIJoyConfig->SendNotify();

            pDIJoyConfig->Unacquire();
        }
        break;
#endif // _UNICODE

        // this is the handler for the Device list box
    case IDC_ADV_LIST_DEVICE:
        // Fall into Change on DBLCLK
        if( code != LBN_DBLCLK )
            break;

    case IDC_ADV_CHANGE:
        if( nFlags & USER_MODE )
            Error((short)IDS_USER_MODE_TITLE, (short)IDS_USER_MODE);
        else
        {
            LaunchChange(hDlg);           
        }
        break;

    case IDC_ADV_USEOEMPAGE:
        if( !nAssigned ) {
            break;
        }

        if( IsWindowVisible(GetDlgItem(hDlg,IDC_ADV_USEOEMPAGE)) )
        {
            // Boy are you going to pay the price for making that selection...
            LPDIJOYCONFIG_DX5 lpDIJoyConfig = new (DIJOYCONFIG_DX5);
            ASSERT (lpDIJoyConfig);

            ZeroMemory(lpDIJoyConfig, sizeof(DIJOYCONFIG_DX5));

            lpDIJoyConfig->dwSize = sizeof (DIJOYCONFIG_DX5);

            // Get the index from the selected item (iAdvItem)
            BYTE n1 = (BYTE)GetItemData(hAdvListCtrl, (BYTE)iAdvItem);
            BYTE n = 0;
            do
            {
                if( pAssigned[n] && (n1 == pAssigned[n]->ID) )
                    break;
                n++;
            } while( n < NUMJOYDEVS );

            // Find out the type name...
            if( SUCCEEDED(pDIJoyConfig->GetConfig(pAssigned[n]->ID, (LPDIJOYCONFIG)lpDIJoyConfig, DIJC_REGHWCONFIGTYPE)) )
            {
                LPDIJOYTYPEINFO lpDIJoyTypeInfo = new (DIJOYTYPEINFO);
                ASSERT (lpDIJoyTypeInfo);

                ZeroMemory(lpDIJoyTypeInfo, sizeof(DIJOYTYPEINFO));

                lpDIJoyTypeInfo->dwSize = sizeof(DIJOYTYPEINFO);

                // Get the TypeInfo you start with!
                if( SUCCEEDED(pDIJoyConfig->GetTypeInfo(lpDIJoyConfig->wszType, lpDIJoyTypeInfo, DITC_FLAGS1 | DITC_CLSIDCONFIG)) )
                {
                    DWORD dwFlags = GetItemData(hAdvListCtrl, (BYTE)iAdvItem);

                    // If it's checked... you want the OEM supplied property sheet page!
                    if( IsDlgButtonChecked(hDlg, IDC_ADV_USEOEMPAGE) )
                    {
                        // Turn off the USE_DEFAULT flag
                        dwFlags &= ~USE_DEFAULT;

                        // Update the global pointer!!!
                        pAssigned[n]->clsidPropSheet = lpDIJoyTypeInfo->clsidConfig;

                        // Update the pointer being sent to the registry
                        lpDIJoyTypeInfo->dwFlags1 &= ~JOYTYPE_DEFAULTPROPSHEET;
                    } else
                    {
                        // Turn on the USE_DEFAULT flag
                        dwFlags |= USE_DEFAULT;

                        // Update the global list!
                        pAssigned[n]->clsidPropSheet = CLSID_LegacyServer;

                        // Update the pointer being sent to the registry
                        lpDIJoyTypeInfo->dwFlags1 |= JOYTYPE_DEFAULTPROPSHEET;
                    }

                    if( SUCCEEDED(pDIJoyConfig->Acquire()) ) {
                    
                        // Update the registry
                        VERIFY(SUCCEEDED(pDIJoyConfig->SetTypeInfo(lpDIJoyConfig->wszType, lpDIJoyTypeInfo, DITC_FLAGS1)));
    
                        // Set the data in the list control!
                        SetItemData(hAdvListCtrl, (BYTE)iAdvItem, dwFlags);
                    }
                    
                    pDIJoyConfig->Unacquire();
                }

                if( lpDIJoyTypeInfo )
                    delete (lpDIJoyTypeInfo);
            }

            if( lpDIJoyConfig )
                delete (lpDIJoyConfig);
        }
        break;

    default:
        break;
    }
}

////////////////////////////////////////////////////////////////////////////////
// 
// FUNCTION:    OnNotify(HWND hDlg, WPARAM idFrom, NMHDR* pnmhdr)
//
// PARAMETERS:  hDlg   - 
//             idFrom - ID of control sending WM_NOTIFY message
//             pnmhdr -
//
// PURPOSE:     WM_NOTIFY message handler
////////////////////////////////////////////////////////////////////////////////
BOOL OnNotify(HWND hDlg, WPARAM idFrom, LPNMHDR pnmhdr)
{
    switch( pnmhdr->code )
    {
    case PSN_QUERYCANCEL:
        if( nFlags & UPDATE_INPROCESS )
        {
            nFlags &= ~UPDATE_INPROCESS;
            SetFocus(hAdvListCtrl);
        }
        break;
/*
    case LVN_GETINFOTIP:
        {
        LPLVHITTESTINFO lpHit = new (LVHITTESTINFO);
        ASSERT (lpHit);

        BOOL bRet = FALSE;

        POINT pt;
        GetCursorPos(&pt);
        ScreenToClient(hAdvListCtrl, &pt);

        lpHit->pt    = pt;
        lpHit->flags = lpHit->iItem = lpHit->iSubItem = 0;

        ::SendMessage(hAdvListCtrl, LVM_SUBITEMHITTEST, 0, (LPARAM)(LPLVHITTESTINFO)lpHit);

        if (lpHit->flags & LVHT_ONITEMLABEL)
        {
            // Determine the text length of the column text
            LPTSTR lpStr = new (TCHAR[MAX_STR_LEN+1]);
            ASSERT (lpStr);

            GetItemText(hAdvListCtrl, lpHit->iItem, lpHit->iSubItem, lpStr, MAX_STR_LEN);

            // Determine if the latter will fit inside the former...
            SIZE size;
            HDC hDC = GetDC(hAdvListCtrl);
           GetTextExtentPoint(hDC, lpStr, lstrlen(lpStr), &size);
            ReleaseDC(hAdvListCtrl, hDC);

            // Determine how wide the column is!
            short nWidth = (short)::SendMessage(hAdvListCtrl, LVM_GETCOLUMNWIDTH, lpHit->iSubItem, 0);

            bRet = (BOOL)(size.cx > nWidth);

            if (bRet)
                // if not, copy the text into lpHit->pszText
                _tcscpy(((LPNMLVGETINFOTIP)pnmhdr)->pszText, lpStr);

            if (lpStr)
                delete[] (lpStr);
        }
        if (lpHit)
            delete (lpHit);

        return bRet;
        }
*/

    case LVN_BEGINLABELEDIT:
        if( !(GetItemData(hAdvListCtrl, (BYTE)iAdvItem) & ID_NONE) )
            OnCommand(hDlg, IDC_RENAME, 0, 0);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 1);
        break;

    case LVN_ENDLABELEDIT:
        if( !(nFlags & UPDATE_INPROCESS) )
            return(FALSE);

        if( !bProcess )
            return(FALSE);

        nFlags &= ~UPDATE_INPROCESS;

        if( fpPageWndProc )
        {
            HWND hParentWnd = GetParent(hDlg);
            // this is required because the CPL can be launched via RUNDLL32
            if( ::IsWindow(hParentWnd) )
                hParentWnd = GetParent(hParentWnd);
            // Reset the subclass proc
//         SetWindowLongPtr(hParentWnd, GWLP_WNDPROC, (LONG_PTR)fpPageWndProc);
        }

        // Make sure the name is usable!
        if( _tcschr(((NMLVDISPINFO *)pnmhdr)->item.pszText, TEXT('\\')) )
        {
            Error((short)IDS_INVALID_NAME_TITLE, (short)IDS_INVALID_NAME);
        } else
        {
            nFlags |= UPDATE_ALL;

            LPDIPROPSTRING pDIPropString = new (DIPROPSTRING);
            ASSERT (pDIPropString);

            ZeroMemory(pDIPropString, sizeof(DIPROPSTRING));

            pDIPropString->diph.dwSize       = sizeof(DIPROPSTRING);
            pDIPropString->diph.dwHeaderSize = sizeof(DIPROPHEADER);
            pDIPropString->diph.dwHow        = DIPH_DEVICE;

#ifdef _UNICODE
            wcscpy(pDIPropString->wsz, ((NMLVDISPINFO *)pnmhdr)->item.pszText);
#else
            USES_CONVERSION;
            wcscpy(pDIPropString->wsz, A2W(((NMLVDISPINFO *)pnmhdr)->item.pszText));
#endif
            // Search nAssigned for the ID...
            BYTE n = nAssigned;

            do
            {
                if( pAssigned[--n]->ID == ((NMLVDISPINFO *)pnmhdr)->item.iItem )
                    break;

            } while( n );

            if( SUCCEEDED(pAssigned[n]->fnDeviceInterface->SetProperty(DIPROP_INSTANCENAME, &pDIPropString->diph)) )
            {
                SetItemText(hAdvListCtrl, (BYTE)((NMLVDISPINFO *)pnmhdr)->item.iItem, 1, ((NMLVDISPINFO *)pnmhdr)->item.pszText);
            } else
            {
                Error((short)IDS_NO_RENAME_TITLE, (short)IDS_NO_RENAME);
            }

            if( pDIPropString )
                delete (pDIPropString);
        }
        break;

#if 0
    case LVN_COLUMNCLICK:
        switch( ((NM_LISTVIEW*)pnmhdr)->iSubItem )
        {
        case DEVICE_ID:
            {
                static BOOL bIDDirection = TRUE;
                ::SendMessage(hAdvListCtrl, LVM_SORTITEMS, (WPARAM)(LPARAM)(bIDDirection =! bIDDirection), (LPARAM)(PFNLVCOMPARE)CompareIDItems);
            }
            break;

        default:
            {
                BOOL bDirection;

                CListCtrl *pCtrl = new (CListCtrl);
                ASSERT(pCtrl);

                pCtrl->Attach(hAdvListCtrl);

                switch( ((NM_LISTVIEW*)pnmhdr)->iSubItem )
                {
                case DEVICE_FRIENDLY:
                    {
                        static BOOL bFriendlyDirection   = FALSE;
                        bDirection = (bFriendlyDirection =! bFriendlyDirection);
                    }
                    break;

                case DEVICE_TYPE:
                    {
                        static BOOL bTypeDirection       = FALSE;
                        bDirection = (bTypeDirection        =! bTypeDirection);
                    }
                    break;

                case DEVICE_PORT:
                    {
                        static BOOL bPortDirection          = FALSE;
                        bDirection = (bPortDirection        =! bPortDirection);
                    }
                    break;
                }

                SortTextItems(pCtrl, (short)((NM_LISTVIEW*)pnmhdr)->iSubItem, bDirection, 0, 15);

                pCtrl->Detach();

                if( pCtrl )
                    delete (pCtrl);
            }
            break;
        }

        if( nAssigned )
        {
            iAdvItem = (short)::SendMessage(hAdvListCtrl, LVM_GETNEXTITEM, (WPARAM)(int)-1, MAKELPARAM(LVNI_SELECTED, 0));
            ::PostMessage(hAdvListCtrl, LVM_ENSUREVISIBLE, iAdvItem, TRUE);

            if( !(nFlags & USER_MODE) )
                PostDlgItemEnableWindow(hDlg, IDC_ADV_CHANGE, (GetItemData(hAdvListCtrl, (BYTE)iAdvItem) & ID_NONE) ? FALSE : TRUE);

            SetListCtrlItemFocus(hAdvListCtrl, (BYTE)iAdvItem);
        }
        break;
#endif

    case PSN_KILLACTIVE:
        if( nFlags & UPDATE_INPROCESS )
            SetFocus(hAdvListCtrl);

#ifdef _UNICODE
        if( hAdvNotifyDevNode )
            UnregisterDeviceNotification(hAdvNotifyDevNode);
#endif
        break;

    case NM_DBLCLK:
        switch( idFrom )
        {
        case IDC_ADV_LIST_DEVICE:
            if( !(GetItemData(hAdvListCtrl, (BYTE)iAdvItem) & ID_NONE) )
                LaunchChange(hDlg);
            break;
        }
        break;

    case PSN_SETACTIVE:
#ifdef _UNICODE
        RegisterForDevChange(hDlg, &hAdvNotifyDevNode);
#endif 

        if( nFlags & UPDATE_FOR_ADV )
        {
            if( !AdvUpdateListCtrl() )
            {
#ifdef _DEBUG
                OutputDebugString(TEXT("JOY.CPL: OnNotify: Failed UpdateListCtrl!\n"));
#endif
            }
        }

        if( nAssigned )
        {
            iAdvItem = 0;

            // This will happen when the user comes in via the CMD line!
            if( iItem != NO_ITEM )
            {
                // Find the ID of the device... the Brute Force Method!
                do
                {
                    if( (pAssigned[iItem] != NULL) && ((BYTE)GetItemData(hAdvListCtrl, (BYTE)iAdvItem) == pAssigned[iItem]->ID) )
                        break;

                    iAdvItem++;
                } while( iAdvItem < NUMJOYDEVS );
            }

            if( iAdvItem == NUMJOYDEVS ) {
                iAdvItem = 0;
            }

            SetListCtrlItemFocus(hAdvListCtrl, (BYTE)iAdvItem);
            ::PostMessage(hAdvListCtrl, LVM_ENSUREVISIBLE, iAdvItem, FALSE );
        }

        // No global port drivers in NT so...
        //if (nGameportDriver)
#ifndef _UNICODE
        if( !(nFlags & ON_NT) )
            PopulateGlobalPortDriverComboBox();
#endif

        // disable the Change button if iAdvItem points to a (none) selection
        if( !(nFlags & USER_MODE) )
            PostDlgItemEnableWindow(hDlg, IDC_ADV_CHANGE,  (nAssigned) ? ((iAdvItem & ID_NONE) ? FALSE : TRUE) : FALSE);
        break;

    case LVN_ITEMCHANGED:
        if( iAdvItem != (short)((NM_LISTVIEW*)pnmhdr)->iItem )
        {
            iAdvItem = (short)((NM_LISTVIEW*)pnmhdr)->iItem;

            HWND hCtrl = GetDlgItem(hDlg, IDC_ADV_USEOEMPAGE);

            if( nAssigned )
            {
                SetWindowPos( hCtrl, NULL, NULL, NULL, NULL, NULL, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | 
                              ((((NM_LISTVIEW*)pnmhdr)->lParam & SHOW_DEFAULT) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW) );

                // Check the box appropriatly!
                if( ((NM_LISTVIEW*)pnmhdr)->lParam & SHOW_DEFAULT )
                    ::PostMessage(GetDlgItem(hDlg, IDC_ADV_USEOEMPAGE), BM_SETCHECK, (((NM_LISTVIEW*)pnmhdr)->lParam & USE_DEFAULT) ? BST_UNCHECKED : BST_CHECKED, 0);

                if( ((NM_LISTVIEW*)pnmhdr)->lParam )
                    PostEnableWindow(hCtrl, (BOOL)!(((NM_LISTVIEW*)pnmhdr)->lParam & ID_NONE));

                if( !(nFlags & USER_MODE) )
                    PostDlgItemEnableWindow(hDlg, IDC_ADV_CHANGE, (BOOL)!(((NM_LISTVIEW*)pnmhdr)->lParam & ID_NONE));
            } else SetWindowPos( hCtrl, NULL, NULL, NULL, NULL, NULL, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_HIDEWINDOW);
        }
        break;

    case LVN_KEYDOWN:
        switch( ((LV_KEYDOWN*)pnmhdr)->wVKey )
        {
        case    VK_DELETE:
            iAdvItem = (short)::SendMessage(hAdvListCtrl, LVM_GETNEXTITEM, (WPARAM)(int)-1, MAKELPARAM(LVNI_SELECTED, 0));
            {
                BYTE nRet = (BYTE)GetItemData(hAdvListCtrl, (BYTE)iAdvItem);
                DeleteSelectedItem((PBYTE)&nRet);
            }
            // Missing break intentional!

        case VK_F5:
            Enumerate( hDlg );
            AdvUpdateListCtrl();
            SetListCtrlItemFocus(hAdvListCtrl, (BYTE)iAdvItem);
            ::PostMessage(hAdvListCtrl, LVM_ENSUREVISIBLE, iAdvItem, FALSE );
            break;
        }
        break;
    }
    return(TRUE);
}

////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnDestroy ( HWND hWnd )
//
// PARAMETERS:  hWnd - Handle to window being destroyed
//
// PURPOSE:     WM_DESTROY message handler
////////////////////////////////////////////////////////////////////////////////////////
void OnDestroy(HWND hWnd)
{
    ASSERT (hWnd);

    if( lpstrNone )
        delete[] (lpstrNone);

    // Reset the subclass proc
    SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)fpMainWndProc);

    // release the DI JoyConfig interface pointer
    if( pDIJoyConfig )
    {
        pDIJoyConfig->Release();
        pDIJoyConfig = 0;
    }
}

////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnAdvHelp ( LPARAM lParam )
//
// PARAMETERS:  lParam - Pointer to HELPINFO struct
//
// PURPOSE:     WM_HELP message handler
////////////////////////////////////////////////////////////////////////////////////////
void OnAdvHelp(LPARAM lParam)
{
    ASSERT (lParam);

    // point to help file
    LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
    ASSERT (pszHelpFileName);

    if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
    {
        if( ((LPHELPINFO)lParam)->iContextType == HELPINFO_WINDOW )
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, pszHelpFileName, HELP_WM_HELP, (ULONG_PTR)gaHelpIDs);
    }
#ifdef _DEBUG
    else OutputDebugString(TEXT("JOY.CPL: Advanced.cpp: OnAdvHelp: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif // _DEBUG

    if( pszHelpFileName )
        delete[] (pszHelpFileName);
}

////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnContextMenu ( WPARAM wParam )
//
// PARAMETERS:  wParam - HWND of window under the pointer
//
// PURPOSE:     Handle WM_RBUTTONDOWN over all client windows 
// (except the list control... that's OnListviewContextMenu() job)
////////////////////////////////////////////////////////////////////////////////////////
void OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    ASSERT (wParam);

    // If you are on the ListCtrl...
    if( (HWND)wParam == hAdvListCtrl )
    {
        SetFocus(hAdvListCtrl);

        // Don't attempt if nothing selected
        if( iAdvItem != NO_ITEM )
            OnListviewContextMenu(lParam);
    } else
    {
        // point to help file
        LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
        ASSERT (pszHelpFileName);

        if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
            WinHelp((HWND)wParam, pszHelpFileName, HELP_CONTEXTMENU, (ULONG_PTR)gaHelpIDs);
#ifdef _DEBUG
        else OutputDebugString(TEXT("JOY.CPL: Advanced.cpp: OnContextMenu: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif // _DEBUG

        if( pszHelpFileName )
            delete[] (pszHelpFileName);
    }
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    SetActiveGlobalDriver( void )
//
// PURPOSE:     Commit user selection to persistent storage.
//
// RETURN:      TRUE if successfull, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
#ifndef _UNICODE
BOOL SetActiveGlobalDriver( void )
{
    // It's Perfectly valid to not have a Global Port Driver so... be prepared!
    short n = (short)SendDlgItemMessage(ghDlg, IDC_COMBO1, CB_GETCURSEL, 0, 0);

    if( n == CB_ERR )
        return(FALSE);

    LPDIJOYUSERVALUES pDIJoyUserValues = new (DIJOYUSERVALUES);
    ASSERT (pDIJoyUserValues);

    ZeroMemory(pDIJoyUserValues, sizeof(DIJOYUSERVALUES));

    pDIJoyUserValues->dwSize = sizeof(DIJOYUSERVALUES);

    HWND hCtrl = GetDlgItem(ghDlg, IDC_COMBO1);

    // Don't worry about this not being a TCHAR, this code will never be executed in NT!
    LPSTR pszDisplayName = new char[SendMessage(hCtrl, LB_GETTEXTLEN, (WPARAM)n, 0)+1];
    ASSERT (pszDisplayName);

    SendMessage(hCtrl, CB_GETLBTEXT, n, (LPARAM)(LPCTSTR)pszDisplayName);

    hCtrl = GetDlgItem(ghDlg, IDC_POLLFLAGS);

    SetWindowPos( hCtrl, NULL, NULL, NULL, NULL, NULL, 
                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_HIDEWINDOW );

    // Fix #9815, Set wszGlobalDriver to 
    if( _tcsncmp(pszDisplayName, lpstrNone, sizeof(lpstrNone)/sizeof(TCHAR)) == 0 )
    {
        //wcscpy(pDIJoyUserValues->wszGlobalDriver, L"");

        if( SUCCEEDED(pDIJoyConfig->Acquire()) )
        {
            if( FAILED(pDIJoyConfig->SetUserValues(pDIJoyUserValues, DIJU_GLOBALDRIVER)) )
            {
                TRACE (TEXT("JOY.CPL: SetUserValues failed to set DIJU_GLOBALDRIVER!\n"));
            }
        }
    } else
    {
        LPDIJOYTYPEINFO lpdiJoyInfo = new DIJOYTYPEINFO;
        ASSERT (lpdiJoyInfo);

        ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO));

        lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO);

        USES_CONVERSION;

        short nIndex = 0;

        // traverse the list of Global Port Drivers 'till you find the matching display name
        // this also disallows the user from doing something ugly when they only have "standard gameport"
        while( pwszGameportDriverArray[nIndex] )
        {
            // populate the Type Info                                         
            if( SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszGameportDriverArray[nIndex], lpdiJoyInfo, DITC_DISPLAYNAME | DITC_CALLOUT)) )
            {
                if( _wcsicmp(lpdiJoyInfo->wszDisplayName, A2W(pszDisplayName)) == 0 )
                {
                    wcscpy(pDIJoyUserValues->wszGlobalDriver, lpdiJoyInfo->wszCallout );

                    if( SUCCEEDED(pDIJoyConfig->Acquire()) )
                    {
                        if( FAILED(pDIJoyConfig->SetUserValues(pDIJoyUserValues, DIJU_GLOBALDRIVER)) )
                        {
                            TRACE (TEXT("JOY.CPL: SetUserValues failed to set DIJU_GLOBALDRIVER!\n"));
                        }

                        // check to see if you need to display the poll flags check box!
                        if( _wcsicmp(pDIJoyUserValues->wszGlobalDriver, lpMSANALOG_VXD) == 0 )
                        {
                            SetWindowPos( hCtrl, NULL, NULL, NULL, NULL, NULL, 
                                          SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW );

                            // Get the state from the registry and update the check mark
                            HKEY hKey; 

                            if( FAILED(pDIJoyConfig->OpenTypeKey(pwszGameportDriverArray[nIndex], KEY_ALL_ACCESS, &hKey)) )
                            {
                                TRACE (TEXT("JOY.CPL: OpenTypeKey failed to open key %s!\n"), pwszGameportDriverArray[nIndex]);
                            }

                            DWORD dwFlag;
                            ULONG ulType = REG_BINARY;
                            ULONG ulSize = sizeof(dwFlag);

                            // this will happen if there is no entry for POLL_FLAGS_REG_STR
                            if( ERROR_SUCCESS != RegQueryValueEx(hKey, POLL_FLAGS_REG_STR, NULL, &ulType, (PBYTE)&dwFlag, &ulSize) )
                                dwFlag = 0;

                            ::PostMessage(GetDlgItem(ghDlg, IDC_POLLFLAGS), BM_SETCHECK, (dwFlag) ? BST_CHECKED : BST_UNCHECKED, 0);

                            RegCloseKey(hKey);
                        }
                    }
                    break;
                }
            }
            nIndex++;
        }

        // delete the DIJOYTYPEINFO variable
        if( lpdiJoyInfo )
            delete (lpdiJoyInfo);
    }

    pDIJoyConfig->SendNotify();

    pDIJoyConfig->Unacquire();

    if( pszDisplayName )
        delete[] (pszDisplayName);

    if( pDIJoyUserValues )
        delete pDIJoyUserValues;

    return(TRUE);
}
#endif // _UNICODE


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnListviewContextMenu( void )
//
// PURPOSE:     Handle Context menu in Listview
//
// RETURN:      TRUE if successfull, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
static void OnListviewContextMenu( LPARAM lParam )
{
    HMENU hPopupMenu = CreatePopupMenu();
    ASSERT (hPopupMenu);

    // unlike life, bRet defaults to bliss
    BOOL bRet = TRUE;

    LPTSTR pszText = new TCHAR[STR_LEN_32];
    ASSERT (pszText);

    // Don't display Rename/Change if on (none) entry
    if( !(GetItemData(hAdvListCtrl, (BYTE)iAdvItem) & ID_NONE) )
    {
        if( !(nFlags & USER_MODE) )
        {
            // add the "Change..." string
            ::SendDlgItemMessage(GetParent(hAdvListCtrl), IDC_ADV_CHANGE, WM_GETTEXT, (WPARAM)STR_LEN_32, (LPARAM)(LPCTSTR)pszText);

            bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_ADV_CHANGE, pszText); 
#ifdef _DEBUG
            if( !bRet )
                TRACE(TEXT("JOY.CPL: OnListviewCOntextMenu: AppendMenu Failed to insert %s\n"), pszText);
#endif //_DEBUG

            // Add the Rename text
            VERIFY(LoadString(ghInstance, IDS_RENAME, pszText, STR_LEN_32));
            bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_RENAME, pszText);
#ifdef _DEBUG
            if( !bRet )
                TRACE(TEXT("JOY.CPL: OnListviewCOntextMenu: AppendMenu Failed to insert %s\n"), pszText);
#endif //_DEBUG

            // Add the SEPERATOR and "What's this?"

            //PREFIX #WI279965. False positive.
            //MSDN: if uFlags==MF_SEPARATOR, LPCTSTR lpNewItem is ignored.
            bRet = AppendMenu(hPopupMenu, MF_SEPARATOR, 0, 0); 
#ifdef _DEBUG
            if( !bRet )
                TRACE(TEXT("JOY.CPL: OnListviewCOntextMenu: AppendMenu Failed to insert SEPERATOR!\n"));
#endif //_DEBUG
        }
    }

    VERIFY(LoadString(ghInstance, IDS_WHATSTHIS, pszText, STR_LEN_32));
    bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDS_WHATSTHIS, pszText); 
#ifdef _DEBUG
    if( !bRet )
        TRACE(TEXT("JOY.CPL: OnListviewCOntextMenu: AppendMenu Failed to insert %s\n"), pszText);
#endif //_DEBUG

    if( pszText ) delete[] (pszText);

    POINT pt;

    // lParam is -1 if we got here via Shift+F10
    if( lParam > 0 )
    {
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
    } else
    {
        // Centre the popup on the selected item!

        // This get's a good X pos, but the y is the start of the control!
        ::SendMessage(hAdvListCtrl, LVM_GETITEMPOSITION, iAdvItem, (LPARAM)&pt);

        RECT rc;
        ::GetClientRect(hAdvListCtrl, &rc);

        pt.x = rc.right>>1;

        ClientToScreen(hAdvListCtrl, &pt);
    }

    bRet = TrackPopupMenu (hPopupMenu, TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON, pt.x, pt.y, 0, ghDlg, NULL);
#ifdef _DEBUG
    if( !bRet )
        TRACE (TEXT("JOY.CPL: OnListviewContextMenu: TrackPopupMenu Failed!\n"));
#endif //_DEBUG

    if(hPopupMenu) DestroyMenu (hPopupMenu); // PREFIX 45089
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    UpdateListCtrl( void )
//
// PURPOSE:     Refreshes enumerated device list
//
// RETURN:      TRUE if successfull, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
static BOOL AdvUpdateListCtrl()
{
    // Turn Redraw off here else it will flicker!
    ::SendMessage(hAdvListCtrl, WM_SETREDRAW, (WPARAM)FALSE, 0);

    // Out with the old...
    ::SendMessage(hAdvListCtrl, LVM_DELETEALLITEMS, 0, 0);

    // This buffer is so large because it is used to hold IDS_GEN_STATUS_UNKNOWN
    TCHAR sz1[16];

    // find and assign ID's 
    BYTE n = NUMJOYDEVS;
    BYTE nIndex;

    SendMessage(hAdvListCtrl, LVM_SETITEMCOUNT, (WPARAM)(int)NUMJOYDEVS, (LPARAM)LVSICF_NOINVALIDATEALL | LVSICF_NOSCROLL);

    // Set everything to NONE to start!
    do
    {
        itoa((BYTE)n--, (LPTSTR)&sz1);

        // Insert the ID
        // Set the device ID and ID_NONE in Extended info...
        nIndex = InsertItem( hAdvListCtrl, sz1, n);

        // Populate the columns with "(none)"
        SetItemText(hAdvListCtrl, nIndex, DEVICE_FRIENDLY, lpstrNone);
        SetItemText(hAdvListCtrl, nIndex, DEVICE_TYPE,     lpstrNone);
#ifdef _UNICODE
        SetItemText(hAdvListCtrl, nIndex, DEVICE_PORT,      lpstrNone);
#endif
    }   while( n );

    if( nAssigned )
    {
        // insert the assigned ones!
        n = nAssigned;

        DIPROPSTRING *pDIPropStr = new (DIPROPSTRING);
        ASSERT (pDIPropStr);

        ZeroMemory(pDIPropStr, sizeof(DIPROPSTRING));

        pDIPropStr->diph.dwSize       = sizeof(DIPROPSTRING);
        pDIPropStr->diph.dwHeaderSize = sizeof(DIPROPHEADER);
        pDIPropStr->diph.dwHow        = DIPH_DEVICE;


#ifndef _UNICODE
        USES_CONVERSION;
#endif               

        // The low half will be populated by the ID, the upper by bit flags!
        DWORD dwData;

        do
        {
            // Set the Product Column!
            if( SUCCEEDED(pAssigned[--n]->fnDeviceInterface->GetProperty(DIPROP_PRODUCTNAME, &pDIPropStr->diph)) )
            {
#ifdef _UNICODE
                SetItemText(hAdvListCtrl, pAssigned[n]->ID, DEVICE_TYPE, (LPTSTR)pDIPropStr->wsz);
#else
                SetItemText(hAdvListCtrl, pAssigned[n]->ID, DEVICE_TYPE, (LPTSTR)W2A(pDIPropStr->wsz));
#endif
            }

            // Set the Friendly Name!
            if( SUCCEEDED(pAssigned[n]->fnDeviceInterface->GetProperty(DIPROP_INSTANCENAME, &pDIPropStr->diph)) )
            {
#ifdef _UNICODE
                SetItemText(hAdvListCtrl, pAssigned[n]->ID, DEVICE_FRIENDLY, (LPTSTR)pDIPropStr->wsz);
#else
                SetItemText(hAdvListCtrl, pAssigned[n]->ID, DEVICE_FRIENDLY, (LPTSTR)W2A(pDIPropStr->wsz));
#endif
            }

#ifdef _UNICODE
            // Set the Game Port Column!
            if( SUCCEEDED(pAssigned[n]->fnDeviceInterface->GetProperty(DIPROP_GETPORTDISPLAYNAME, &pDIPropStr->diph)) )
            {
                SetItemText(hAdvListCtrl, pAssigned[n]->ID, DEVICE_PORT, (LPTSTR)pDIPropStr->wsz);
            } else
            {
                VERIFY(LoadString(ghInstance, IDS_GEN_STATUS_UNKNOWN, sz1, sizeof(sz1)/sizeof(TCHAR)));
                SetItemText(hAdvListCtrl, pAssigned[n]->ID, DEVICE_PORT, (LPTSTR)sz1);
            }
#endif // _UNICODE

            // Set the ID in the data... 
            // This is necessary for Sorting!
            dwData = pAssigned[n]->ID;

            //if( pAssigned[n]->clsidPropSheet != CLSID_LegacyServer )
            if( pAssigned[n]->fHasOemSheet )
            {
                LPDIJOYCONFIG_DX5 lpDIJoyConfig = new (DIJOYCONFIG_DX5);
                ASSERT (lpDIJoyConfig);

                ZeroMemory(lpDIJoyConfig, sizeof(DIJOYCONFIG_DX5));

                lpDIJoyConfig->dwSize = sizeof (DIJOYCONFIG_DX5);


                // Set the DefaultPropertySheet flag 
                if( SUCCEEDED(pDIJoyConfig->GetConfig(pAssigned[n]->ID, (LPDIJOYCONFIG)lpDIJoyConfig, DIJC_REGHWCONFIGTYPE)) )
                {
                    LPDIJOYTYPEINFO lpDIJoyTypeInfo = new (DIJOYTYPEINFO);
                    ASSERT (lpDIJoyTypeInfo);

                    ZeroMemory(lpDIJoyTypeInfo, sizeof(DIJOYTYPEINFO));

                    lpDIJoyTypeInfo->dwSize = sizeof (DIJOYTYPEINFO);

                    if( SUCCEEDED(pDIJoyConfig->GetTypeInfo(lpDIJoyConfig->wszType, lpDIJoyTypeInfo, DITC_FLAGS1 )) )
                    {
                        if( lpDIJoyTypeInfo->dwFlags1 & JOYTYPE_DEFAULTPROPSHEET )
                        {
                            // Set the USE_DEFAULT mask!
                            dwData |= USE_DEFAULT;

                            // Update the global list!
                            pAssigned[n]->clsidPropSheet = CLSID_LegacyServer;
                        }
                    }

                    if( lpDIJoyTypeInfo )
                        delete (lpDIJoyTypeInfo);
                }

                dwData |= SHOW_DEFAULT;

                if( lpDIJoyConfig )
                    delete (lpDIJoyConfig);
            }

            // Set the Item Data to the ID!                        
            SetItemData(hAdvListCtrl, pAssigned[n]->ID, dwData);

        }  while( n );

        // clean up, clean up... everybody do your share!
        if( pDIPropStr )
            delete (pDIPropStr);
    }

    // turn the flag off!
    if( nFlags & UPDATE_FOR_ADV )
        nFlags &= ~UPDATE_FOR_ADV;

    // Turn the redraw flag back on!
    ::SendMessage (hAdvListCtrl, WM_SETREDRAW, (WPARAM)TRUE, 0);
    InvalidateRect(hAdvListCtrl, NULL, TRUE);

    return(TRUE);
}

////////////////////////////////////////////////////////////////////////////////
// 
// FUNCTION:    ChangeDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
// PARAMETERS: HWND     hDlg   -
//             UINT     uMsg   -
//             WPARAM   wParam -
//             LPARAM   lParam -
//
// PURPOSE:     
////////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK ChangeDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg )
    {
    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(hDlg, WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

    case WM_HELP:
        OnHelp(lParam);
        return(1);

    case WM_CONTEXTMENU:
        OnContextMenu(wParam, lParam);
        return(TRUE);

    case WM_INITDIALOG:
        {
            HICON hIcon = (HICON)LoadImage(ghInstance, MAKEINTRESOURCE(IDI_CPANEL), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
            ASSERT (hIcon);

            if( hIcon )
                ::PostMessage(hDlg, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)hIcon);

            HWND hCtrl = GetDlgItem(hDlg, IDC_CHANGE_LIST);
            ASSERT (hCtrl);

            UpdateChangeListCtrl( hCtrl );

            BYTE nCounter = nAssigned;
            while( nCounter-- )
            {
                if( (BYTE)::SendMessage(hCtrl, LB_GETITEMDATA, (WPARAM)nCounter, 0) == nOldID )
                    break;
            }

            // Set the list box selections!
            ::PostMessage(hCtrl, LB_SETCURSEL, (WPARAM)nCounter, 0);

            // Done with the ListCtrl, now... on to the ComboBox
            if( nFlags & ON_NT )
            {

                if( !PopulatePortList(hDlg) )
                {
#ifdef _DEBUG 
                    OutputDebugString(TEXT("JOY.CPL: ADVANCED.CPP: PopulatePortList failed!\n"));
#endif
                }
            }

            // Set up the Spin Control!
            HWND hSpinCtrl = GetDlgItem(hDlg, IDC_SPIN);

            ::PostMessage(hSpinCtrl, UDM_SETRANGE,  0, MAKELPARAM(NUMJOYDEVS, 1));
            ::PostMessage(hSpinCtrl, UDM_SETBASE,  10, 0L);
            ::PostMessage(hSpinCtrl, UDM_SETPOS,     0, MAKELPARAM(nOldID+1, 0));
        }
        return(FALSE);

    case WM_COMMAND:
        {
            switch( LOWORD(wParam) )
            {
            /* I'll leave this commented out, as it's likely they'll want double clicking back once I take it out
        case IDC_CHANGE_LIST:
        // Fall into Change on DBLCLK
           if (HIWORD(wParam) != LBN_DBLCLK)
               break;
            */
            
            case IDOK:
                {
                    HWND hCtrl = GetDlgItem(hDlg, IDC_CHANGE_LIST);
                    ASSERT (hCtrl);

                    char nSelectedItem = (char)(SendMessage(hCtrl, LB_GETITEMDATA, SendMessage(hCtrl, LB_GETCURSEL, 0, 0), 0));

                    TCHAR tsz[4];

                    hCtrl = GetDlgItem(hDlg, IDC_SPINBUDDY);

                    tsz[0] = 4;

                    SendMessage(hCtrl, EM_GETLINE, 0, (LPARAM)(LPCSTR)&tsz);

                    // The '-1' is to account for the 1 based list
                    // and the 0 based id's!
                    char nSelectedID = (char)atoi((LPCTSTR)&tsz)-1;

                    pDIJoyConfig->Acquire();

                    // first check to see if the user has selected NONE!
                    if( nSelectedItem == -2 )
                    {
                        // User has selected NONE!
                        VERIFY (SUCCEEDED(pDIJoyConfig->DeleteConfig(nSelectedID)));
                    } else
                    {
                        // see if the selected item and the ID match!
                        // if so... get out of here!
                        if( nSelectedID == nSelectedItem )
                        {
#ifdef _DEBUG
                            OutputDebugString(TEXT("JOY.CPL: ADVANCED.CPP: OnChangeCommand: IDOK: Device already at selected ID!\n"));
#endif
                        } else
                        {
                            SwapIDs(nSelectedID, nSelectedItem);
//                          SetListCtrlItemFocus(hAdvListCtrl, (BYTE)nSelectedID);
                        }
                    }

                    pDIJoyConfig->Unacquire();
                }
                // missing break intentional!

            case IDCANCEL:
                EndDialog(hDlg, LOWORD(wParam));
                break;
            }
        }
        return(1);

    case WM_DESTROY:
        DestroyIcon((HICON)SendMessage(hDlg, WM_GETICON, (WPARAM)ICON_SMALL, 0));
        return(TRUE);
    }
    return(FALSE);
} 



///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    PopulateGlobalPortDriverComboBox( void )
//
// PARAMETERS:  
//
// PURPOSE:     
///////////////////////////////////////////////////////////////////////////////
#ifndef UNICODE
void PopulateGlobalPortDriverComboBox( void )
{
    HWND hCtrl = GetDlgItem(ghDlg, IDC_COMBO1);

    // make sure the combo is clear before we start populating it!
    SendMessage(hCtrl, CB_RESETCONTENT, 0, 0);

    // Type info
    LPDIJOYTYPEINFO_DX5 lpdiJoyInfo = new (DIJOYTYPEINFO_DX5);
    ASSERT (lpdiJoyInfo);

    ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO_DX5));

    lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

    BYTE nIndex = nGameportDriver;
    USES_CONVERSION;

    // Populate the Combobox
    while( nIndex-- )
    {
        // populate the Type Info and place the Index in the extra memory!
        if( SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszGameportDriverArray[nIndex], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_DISPLAYNAME)) )
          ::SendMessage(hCtrl, CB_SETITEMDATA, ::SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)W2A(lpdiJoyInfo->wszDisplayName)), nIndex);
    #ifdef _DEBUG
        else
          OutputDebugString (TEXT("JOY.CPL: ADVANCED.CPP: PopulateGlobalPortDriverComboBox: GetTypeInfo failed!\n"));
    #endif
    }

    // Display the Current selected GlobalPortDriver or None!
    LPDIJOYUSERVALUES pDIJoyUserValues = new DIJOYUSERVALUES;
    ASSERT (pDIJoyUserValues);

    ZeroMemory(pDIJoyUserValues, sizeof(DIJOYUSERVALUES));

    pDIJoyUserValues->dwSize = sizeof(DIJOYUSERVALUES);

    VERIFY (SUCCEEDED(pDIJoyConfig->GetUserValues(pDIJoyUserValues, DIJU_GLOBALDRIVER)));

    // Fix #9815, If the user has No Global port driver label as NONE!
    if( !(*pDIJoyUserValues->wszGlobalDriver && pDIJoyUserValues->wszGlobalDriver) )
    {
        iGameportDriverItem = NO_ITEM; 

        PostMessage(hCtrl, CB_SETCURSEL, (WPARAM)SendMessage(hCtrl, CB_FINDSTRING, (WPARAM)-1, (LPARAM)lpstrNone), (LPARAM)0);
    } else
    {
        ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO_DX5));

        lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

        nIndex = 0;

        // get type info 'till you find the one you want and place it's callout 
        while( pwszGameportDriverArray[nIndex] )
        {
            VERIFY(SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszGameportDriverArray[nIndex], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_CALLOUT | DITC_DISPLAYNAME)));

            if( _wcsicmp(lpdiJoyInfo->wszCallout, pDIJoyUserValues->wszGlobalDriver) == 0 )
            {
                ::PostMessage(hCtrl, CB_SETCURSEL, (WPARAM)::SendMessage(hCtrl, CB_FINDSTRING, (WPARAM)-1, (LPARAM)W2A(lpdiJoyInfo->wszDisplayName)), (LPARAM)0);

                iGameportDriverItem = nIndex; 

                // enable the PollFlags checkbox!
                if( _wcsicmp(pDIJoyUserValues->wszGlobalDriver, lpMSANALOG_VXD) == 0 )
                {
                    SetWindowPos( GetDlgItem( ghDlg, IDC_POLLFLAGS), NULL, NULL, NULL, NULL, NULL, 
                                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW );

                    VERIFY(SUCCEEDED(pDIJoyConfig->Acquire()));

                    // Get the state from the registry and update the check mark
                    HKEY hKey; 
                    DWORD dwFlag;

                    if( SUCCEEDED(pDIJoyConfig->OpenTypeKey(pwszGameportDriverArray[nIndex], KEY_ALL_ACCESS, &hKey)) )
                    {
                        ULONG ulType = REG_BINARY;
                        ULONG ulSize = sizeof(dwFlag);

                        // this will happen if there is no entry for POLL_FLAGS_REG_STR
                        if( ERROR_SUCCESS != RegQueryValueEx(hKey, POLL_FLAGS_REG_STR, NULL, &ulType, (PBYTE)&dwFlag, &ulSize) )
                            dwFlag = 0;

                        RegCloseKey(hKey);
                    }

                    pDIJoyConfig->Unacquire();

                    ::PostMessage(GetDlgItem(ghDlg, IDC_POLLFLAGS), BM_SETCHECK, (dwFlag) ? BST_CHECKED : BST_UNCHECKED, 0);
                }
                break;
            }
            nIndex++;
        }
    }

    // delete the DIJOYUSERVALUES variable
    if( pDIJoyUserValues )
        delete pDIJoyUserValues;

    // clean up, clean up... everybody do your share!
    if( lpdiJoyInfo )
        delete (lpdiJoyInfo);

//    VERIFY(SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)(LPCSTR)lpstrNone) != CB_ERR);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    SubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
// PARAMETERS:  HWND   hWnd   -
//             UINT   uMsg   -
//             WPARAM wParam -
//             LPARAM lParam -
//
// PURPOSE:     SubClass Procedure for Setting the ID to NONE on VK_DELETE on the Advanced Page
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI KeySubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg )
    {
    case WM_COMMAND:
        switch( LOWORD(wParam) )
        {
        case IDCANCEL:
        case IDOK:     
            if( nFlags & UPDATE_INPROCESS )
            {
                bProcess = (LOWORD(wParam) == IDOK) ? TRUE : FALSE;
                SetFocus(hAdvListCtrl);
                nFlags &= ~UPDATE_INPROCESS;
                return(FALSE);
            }
            break;
        }
        break;
    }
    return(BOOL)CallWindowProc(fpPageWndProc, hWnd, uMsg, wParam, lParam);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    SubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
// PARAMETERS:  HWND   hWnd   -
//             UINT   uMsg   -
//             WPARAM wParam -
//             LPARAM lParam -
//
// PURPOSE:     SubClass Procedure for Setting the ID to NONE on VK_DELETE on the Advanced Page
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI SubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg )
    {
    case WM_PARENTNOTIFY:
        if( LOWORD(wParam) == WM_LBUTTONDOWN )
        {
            if( nFlags & UPDATE_INPROCESS )
                SetFocus(hAdvListCtrl);
        }
        break;

    case WM_SYSCOMMAND:
        if( wParam & SC_VSCROLL )
        {
            if( nFlags & UPDATE_INPROCESS )
                SetFocus(hAdvListCtrl);
        }
        break;
    }

    return(BOOL)CallWindowProc(fpMainWndProc, hWnd, uMsg, wParam, lParam);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    UpdateChangeListCtrl ( HWND hCtrl )
//
// PARAMETERS:  HWND   hCtrl - Handle to Change list box
//
// PURPOSE: Update the Change List box
///////////////////////////////////////////////////////////////////////////////
static BOOL UpdateChangeListCtrl ( HWND hCtrl )
{
#ifndef _UNICODE
    USES_CONVERSION;
#endif

    DIPROPSTRING *pDIPropStr = new (DIPROPSTRING);
    ASSERT (pDIPropStr);

    ZeroMemory(pDIPropStr, sizeof(DIPROPSTRING));

    pDIPropStr->diph.dwSize       = sizeof(DIPROPSTRING);
    pDIPropStr->diph.dwHeaderSize = sizeof(DIPROPHEADER);
    pDIPropStr->diph.dwHow        = DIPH_DEVICE;

    BYTE n = nAssigned;

    LPTSTR lpStr = new (TCHAR[MAX_STR_LEN]);
    ASSERT (lpStr);

    // find and assign ID's
    while( n-- )
    {
        if( SUCCEEDED(pAssigned[n]->fnDeviceInterface->GetProperty(DIPROP_INSTANCENAME, &pDIPropStr->diph)) )
        {

            // Our buffer is Only soooo big...
            // besides, it just doesn't make sence to display Everything!
            if( wcslen(pDIPropStr->wsz) > STR_LEN_64 )
            {
                pDIPropStr->wsz[60] = pDIPropStr->wsz[61] = pDIPropStr->wsz[62] = TEXT('.');
                pDIPropStr->wsz[63] = TEXT('\0');
            }

#ifdef _UNICODE
            _tcscpy(lpStr, pDIPropStr->wsz);
#else
            _tcscpy(lpStr, W2A(pDIPropStr->wsz));
#endif

            // Put the first bracket on...
            _tcscat(lpStr, TEXT("  ("));

            // Now, get the productname of the device!
            if( SUCCEEDED(pAssigned[n]->fnDeviceInterface->GetProperty(DIPROP_PRODUCTNAME, &pDIPropStr->diph)) )
            {
#ifdef _UNICODE
                _tcscat(lpStr, pDIPropStr->wsz);
#else
                _tcscat(lpStr, W2A(pDIPropStr->wsz));
#endif
            }

            // put the end bracket on...
            _tcscat(lpStr, TEXT(")"));

            BYTE n1 = (BYTE)SendMessage(hCtrl, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)lpStr);
            SendMessage(hCtrl, LB_SETITEMDATA, n1, pAssigned[n]->ID);
        }
#ifdef _DEBUG
        else OutputDebugString(TEXT("JOY.CPL: Advanced.cpp: UpdateChangeListCtrl: GetProperty failed!\n"));
#endif // _DEBUG
    }

    if( lpStr )
        delete[] (lpStr);

    if( pDIPropStr )
        delete (pDIPropStr);

    return(TRUE);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    itoa(BYTE n, LPTSTR lpStr)
//
// PARAMETERS:  BYTE   n     - Number to be translated
//             LPTSTR lpStr - Buffer to recieve translated value
//
// PURPOSE: Convert BYTE values < 20 to strings.
///////////////////////////////////////////////////////////////////////////////
void itoa(BYTE n, LPTSTR lpStr)
{
    // designed for use with the CPL ONLY!
    // Only supports values < NUMJOYDEVS!
    if( n > NUMJOYDEVS )
    {
#ifdef _DEBUG
        OutputDebugString(TEXT("JOY.CPL: itoa: n > NUMJOYDEVS!\n"));
#endif      
        return;
    }

    lpStr[0] = n % 10 + '0';

    if( n > 9 )
    {
        // Reverse the string and send it back...
        lpStr[1] = lpStr[0];
        lpStr[0] = '1';
        lpStr[2] = '\0';
    } else lpStr[1] = '\0';
}

int CALLBACK CompareIDItems(LPARAM item1, LPARAM item2, LPARAM uDirection)
{
    if( LOWORD(item1) == LOWORD(item2) )
        return(0);

    short nRet = (LOWORD(item1) > LOWORD(item2)) ? 1 : -1;

    return(uDirection) ? nRet : (nRet < 0) ? 1 : -1;
}

void LaunchChange( HWND hTmp )
{
    // Don't allow if you're in USER mode!
    if( (nFlags & USER_MODE) )
        return;

    iAdvItem = (short)::SendMessage(hAdvListCtrl, LVM_GETNEXTITEM, (WPARAM)(int)-1, MAKELPARAM(LVNI_SELECTED, 0));

    nOldID = (BYTE)GetItemData(hAdvListCtrl, (BYTE)iAdvItem);

    if( nOldID & ID_NONE )
        return;

    // valid returns are IDOK, IDCANCEL, and IDC_CHANGE_LIST
    if( IDCANCEL != DialogBox(ghInstance, (PTSTR)IDD_ADV_CHANGE, ghDlg, ChangeDialogProc) )
    {
        // Yeah, it's not really a DEVICEARRIVAL...
        ::SendMessage(hTmp, WM_DEVICECHANGE, DBT_DEVICEARRIVAL, 0);
        ::PostMessage(hAdvListCtrl, LVM_ENSUREVISIBLE, (BYTE)iAdvItem, TRUE);
        SetFocus(hAdvListCtrl);
        SetListCtrlItemFocus(hAdvListCtrl, (BYTE)iAdvItem);
    }
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION: SortTextItems( CListCtrl *pCtrl, short nCol, BOOL bAscending, int low, int high )
//
//    SortTextItems - Sort the list based on column text
//
// PARAMETERS:  
//    pCtrl          - pointer to list to sort
//    nCol             - column that contains the text to be sorted
//    bAscending        - indicate sort order
//    low              - row to start scanning from - default row is 0
//    high             - row to end scan. -1 indicates last row
//
// PURPOSE: Sort text items in ListCtrl
//    Returns          - Returns true for success
///////////////////////////////////////////////////////////////////////////////
BOOL SortTextItems( CListCtrl *pCtrl, short nCol, BOOL bAscending, short low, short high )
{
    CHeaderCtrl* pHeader = (CHeaderCtrl*) pCtrl->GetDlgItem(0);

    if( nCol >= pHeader->GetItemCount() )
        return(FALSE);

    if( high == -1 )
        high = pCtrl->GetItemCount() - 1;

    short lo = low; 
    short hi = high;

    if( hi <= lo ) return(FALSE);

    // The choices here are to malloc a buffer large enough for the largest
    // string, or malloc an LV_ITEM struct to get the length, then malloc 
    // just the size we need.
    CString midItem = pCtrl->GetItemText( (lo+hi)/2, nCol );

    // loop through the list until indices cross    
    while( lo <= hi )
    {
        // rowText will hold all column text for one row        
        CStringArray rowText;

        // find the first element that is greater than or equal to 
        // the partition element starting from the left Index.      
        if( bAscending )
            while( ( lo < high ) && ( pCtrl->GetItemText(lo, nCol) < midItem ) )
                ++lo;
        else
            while( ( lo < high ) && ( pCtrl->GetItemText(lo, nCol) > midItem ) )
                ++lo;

        // find an element that is smaller than or equal to 
        // the partition element starting from the right Index.     
        if( bAscending )
            while( ( hi > low ) && ( pCtrl->GetItemText(hi, nCol) > midItem ) )
                --hi;
        else
            while( ( hi > low ) && ( pCtrl->GetItemText(hi, nCol) < midItem ) )
                --hi;

        // if the indexes have not crossed, swap        
        // and if the items are not equal
        if( lo <= hi )
        {
            // swap only if the items are not equal
            if( pCtrl->GetItemText(lo, nCol) != pCtrl->GetItemText(hi, nCol) )
            {
                // swap the rows
                LV_ITEM lvitemlo, lvitemhi;             
                BYTE nColCount = (BYTE)pHeader->GetItemCount();
                rowText.SetSize( nColCount );                

                for( BYTE i = 0; i < nColCount; i++ )
                    rowText[i] = pCtrl->GetItemText(lo, i);

                lvitemlo.mask      = LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
                lvitemlo.iItem     = lo;                
                lvitemlo.iSubItem  = 0;
                lvitemlo.stateMask = LVIS_CUT | LVIS_DROPHILITED | LVIS_FOCUSED | LVIS_SELECTED | LVIS_OVERLAYMASK | LVIS_STATEIMAGEMASK;               
                lvitemhi           = lvitemlo;
                lvitemhi.iItem     = hi;                

                ListView_GetItem(pCtrl->GetSafeHwnd(), &lvitemlo );

                ListView_GetItem(pCtrl->GetSafeHwnd(), &lvitemhi );

                for( i=0; i<nColCount; i++ )
                    pCtrl->SetItemText(lo, i, pCtrl->GetItemText(hi, i));

                lvitemhi.iItem = lo;                
                ListView_SetItem(pCtrl->GetSafeHwnd(), &lvitemhi );

                for( i=0; i<nColCount; i++ )
                    pCtrl->SetItemText(hi, i, rowText[i]);              

                lvitemlo.iItem = hi;
                ListView_SetItem(pCtrl->GetSafeHwnd(), &lvitemlo );
            }

            ++lo;            
            --hi;        
        }
    }

    // If the right index has not reached the left side of array
    // must now sort the left partition.    
    if( low < hi )
        SortTextItems( pCtrl, nCol, bAscending, low, hi);

    // If the left index has not reached the right side of array
    // must now sort the right partition.   
    if( lo < high )
        SortTextItems( pCtrl, nCol, bAscending, lo, high);

    return(TRUE);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION: EditSubLabel( BYTE nItem, BYTE nCol )
//
// PARAMETERS:  
//       EditSubLabel - Start edit of a sub item label
//       Returns         - Temporary pointer to the new edit control
//       nItem           - The row index of the item to edit
//       nCol            - The column of the sub item.
// PURPOSE:  Provide editing services for any column in a CListCtrl
///////////////////////////////////////////////////////////////////////////////
void EditSubLabel( BYTE nItem, BYTE nCol )
{
#ifdef _DEBUG
    // Make sure that the item is visible
    if( !SendMessage(hAdvListCtrl, LVM_ENSUREVISIBLE, nItem, TRUE ) )
    {
        OutputDebugString(TEXT("JOY.CPL: ADVANCED.CPP: EditSubLabel: requested item not visible!\n"));
        return;
    }
#endif // _DEBUG

    // Get the column offset
    short offset = 0;
    BYTE i = 0;

    // OK, so here's what we have to do...
    // Traverse the columns incrementing the widths of the ones lesser than the one we're looking for!

    HDITEM *phdItem = new (HDITEM);
    ASSERT (phdItem);

    phdItem->mask = HDI_ORDER | HDI_WIDTH;

    HWND hHeader   = GetDlgItem(hAdvListCtrl, 0);
    BYTE nColumns  = (BYTE)::SendMessage(hHeader, HDM_GETITEMCOUNT, 0, 0L);
    BYTE nColWidth;

    do
    {
        ::SendMessage(hHeader, HDM_GETITEM, (WPARAM)(int)--nColumns, (LPARAM)(LPHDITEM)phdItem);

        if( phdItem->iOrder < nCol )
            offset += (short)phdItem->cxy;

        if( phdItem->iOrder == nCol )
            nColWidth = (BYTE)phdItem->cxy;
    } while( nColumns ); 

    if( phdItem )
        delete (phdItem);

    RECT rect;
    ListView_GetItemRect(hAdvListCtrl, nItem, &rect, LVIR_BOUNDS );

    // Now scroll if we need to expose the column
    CRect rcClient;
    ::GetClientRect(hAdvListCtrl, &rcClient);

    if( offset + rect.left < 0 || offset + rect.left > rcClient.right )
    {
        ::SendMessage(hAdvListCtrl, LVM_SCROLL, (WPARAM)(int)offset + rect.left, (LPARAM)(int)0);
        rect.left -= (offset + rect.left);
    }

    rect.left += offset+4;
    rect.right = rect.left + nColWidth - 3;  // + ::SendMessage(hAdvListCtrl, LVM_GETCOLUMNWIDTH, (WPARAM)(int)nCol, (LPARAM)0L) - 3 ;

    if( rect.right > rcClient.right )
        rect.right = rcClient.right;

    CEdit *pEdit = new CInPlaceEdit(nItem, 1); 
    ASSERT (pEdit);

    // malloc the list ctrl
    CWnd  *pListCtrl = new (CWnd);
    ASSERT (pListCtrl);

    pListCtrl->Attach(hAdvListCtrl);

    pEdit->Create(WS_BORDER | WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL | ES_CENTER, rect, pListCtrl, IDC_IPEDIT );

    pListCtrl->Detach();

    if( pListCtrl )
        delete (pListCtrl);
}

#ifdef _UNICODE
void SwapIDs(BYTE nSource, BYTE nTarget)
{
    // malloc and retrieve the data from the selected item
    LPDIJOYCONFIG lpSelectedID = new (DIJOYCONFIG);
    ASSERT (lpSelectedID);

    ZeroMemory(lpSelectedID, sizeof(DIJOYCONFIG));

    lpSelectedID->dwSize = sizeof(DIJOYCONFIG);

    // Get the Config of device on ID taken from Change List box!
    HRESULT hr = pDIJoyConfig->GetConfig(nSource, lpSelectedID, DIJC_ALL);

    if( hr == DIERR_NOTFOUND || hr == S_FALSE )
    {
        // No Object on Selected ID!
        if( lpSelectedID )
            delete (lpSelectedID);

        lpSelectedID = NULL;
    }

    // malloc and retrieve the data from the item associated 
    // with the ID taken from the Item selected in the List box!
    LPDIJOYCONFIG lpSelectedItem = new (DIJOYCONFIG);
    ASSERT (lpSelectedItem);

    ZeroMemory(lpSelectedItem, sizeof(DIJOYCONFIG));

    lpSelectedItem->dwSize = sizeof (DIJOYCONFIG);

    hr = pDIJoyConfig->GetConfig(nTarget, lpSelectedItem, DIJC_ALL);

    if( hr == DIERR_NOTFOUND || hr == S_FALSE )
    {
        if( lpSelectedItem )
            delete (lpSelectedItem);

        lpSelectedItem = NULL;
    }

    // ***********************************************************
    // Delete the configurations!
    // ***********************************************************

    // Set the hour glass
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    // ********************************************************
    // OK, now... at this point you have:
    //    lpSelectedID: containing NULL if the device wasn't present or...
    //                  a valid pointer containing the configuration of nSelectedID
    //    lpSelected  : containing NULL if the device wasn't present or...
    //                  a valid pointer containing the configuration of id
    // ********************************************************
    // Time to Set the Configurations!

    if( lpSelectedID )
    {
        hr = pDIJoyConfig->SetConfig(nTarget, lpSelectedID, DIJC_ALL);

        if( lpSelectedID )
            delete (lpSelectedID);
    } else pDIJoyConfig->DeleteConfig(nSource);

    // delete both configurations
    // pointers will be NULL if the config was not found!
    if( lpSelectedItem )
    {
        hr = pDIJoyConfig->SetConfig(nSource, lpSelectedItem, DIJC_ALL );

        if( lpSelectedItem )
            delete (lpSelectedItem);
    }

    pDIJoyConfig->SendNotify();

    // Set the hour glass
    SetCursor(LoadCursor(NULL, IDC_ARROW));
}

#else

// Memphis version of SwapIDs... 
// Caution!!! Very Sensitive!!!
void SwapIDs(BYTE nSelectedID, BYTE nSelectedItem)
{
    // malloc and retrieve the data from the selected item
    LPDIJOYCONFIG lpSelectedID = new (DIJOYCONFIG);

    DWORD dwSelectedID = 0, dwSelectedItem = 0;

    ASSERT (lpSelectedID);

    ZeroMemory(lpSelectedID, sizeof(DIJOYCONFIG));

    lpSelectedID->dwSize = sizeof(DIJOYCONFIG);

    // Get the Config of device on ID taken from Change List box!
    HRESULT hr = pDIJoyConfig->GetConfig(nSelectedID, lpSelectedID, DIJC_ALL);

    if( hr == DIERR_NOTFOUND || hr == S_FALSE )
    {
        // No Object on Selected ID!
        if( lpSelectedID )
            delete (lpSelectedID);

        lpSelectedID = NULL;
    } else {
        if( lpSelectedID )
            delete (lpSelectedID);

        lpSelectedID = NULL;
        
        Error((short)IDS_DEST_ID_OCCUPIED_TITLE, (short)IDS_DEST_ID_OCCUPIED);
        
        return;
    }


    // malloc and retrieve the data from the item associated 
    // with the ID taken from the Item selected in the List box!
    LPDIJOYCONFIG lpSelectedItem = new (DIJOYCONFIG);
    ASSERT (lpSelectedItem);

    ZeroMemory(lpSelectedItem, sizeof(DIJOYCONFIG));

    lpSelectedItem->dwSize = sizeof (DIJOYCONFIG);

    hr = pDIJoyConfig->GetConfig(nSelectedItem, lpSelectedItem, DIJC_ALL);

    if( hr == DIERR_NOTFOUND || hr == S_FALSE )
    {
        if( lpSelectedItem )
            delete (lpSelectedItem);

        lpSelectedItem = NULL;
        
        return;
    }

    // ***********************************************************
    // Delete the configurations!
    // ***********************************************************

    // Set the hour glass
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    // ********************************************************
    // OK, now... at this point you have:
    //    lpSelectedID: containing NULL if the device wasn't present or...
    //                  a valid pointer containing the configuration of nSelectedID
    //    lpSelected  : containing NULL if the device wasn't present or...
    //                  a valid pointer containing the configuration of id
    // ********************************************************
    // Time to Set the Configurations!


    if( lpSelectedID )
    {
        DWORD dwFlags = DIJC_REGHWCONFIGTYPE |  DIJC_CALLOUT  | DIJC_GAIN | DIJC_GUIDINSTANCE;
        USES_CONVERSION;

        // if the callout is joyhid.vxd then the device is USB so...
        // OR on the DIJC_WDMGAMEPORT flag!
        if( !_stricmp(TEXT("joyhid.vxd"), W2A(lpSelectedID->wszCallout)) )
        {
//            dwFlags |= DIJC_WDMGAMEPORT;
            dwSelectedID = 2;
        } else
        {
            dwSelectedID = 1;
        }

        if( dwSelectedID == 1 ) {
            hr = pDIJoyConfig->DeleteConfig(nSelectedID);
    
            /*
             * This notify is to fix the bug changing id on 2-axis 2-button joystick.
             */
            pDIJoyConfig->SendNotify();
    
            if( SUCCEEDED(hr) )
            {
                hr = pDIJoyConfig->SetConfig(nSelectedItem, lpSelectedID, dwFlags );
                
                if( SUCCEEDED(hr) ) {
                    pDIJoyConfig->SendNotify();
                }
            }
        } else {
            hr = pDIJoyConfig->SetConfig(nSelectedItem, lpSelectedID, dwFlags);
    
            pDIJoyConfig->SendNotify();

            if( SUCCEEDED(hr) )
            {
                hr = pDIJoyConfig->DeleteConfig(nSelectedID);
                
                pDIJoyConfig->SendNotify();

                if( nSelectedID < nSelectedItem ) {
                    pDIJoyConfig->SendNotify();
                }
            
            }
        }

        if( lpSelectedID )
            delete (lpSelectedID);
    }

    // delete both configurations
    // pointers will be NULL if the config was not found!
    if( lpSelectedItem )
    {
        DWORD dwFlags = DIJC_REGHWCONFIGTYPE |  DIJC_CALLOUT  | DIJC_GAIN | DIJC_GUIDINSTANCE;
        USES_CONVERSION;

        if( _tcsicmp(TEXT("joyhid.vxd"), W2A(lpSelectedItem->wszCallout)) == 0 )
        {
//            dwFlags |= DIJC_WDMGAMEPORT;
            dwSelectedItem = 2;  //joyhid.vxd
        } 
#if 0
        /*
         * Since MSGAME.VXD will directly write to the registry with some unhealthy data.
         * We have to change it before we move to other ID.
         */
        else if( _tcsicmp(TEXT("MSGAME.VXD"), W2A(lpSelectedItem->wszCallout)) == 0 )
        {
            lpSelectedItem->hwc.dwType += 1;
            dwSelectedItem = 3;  //msgame.vxd (Sidewinder driver)
        } 
#endif        
        else {
            dwSelectedItem = 1;  //vjoyd.vxd
        }

        if( dwSelectedItem == 1     // VJOYD.VXD,
//         || dwSelectedItem == 3 
         ){  // MSGAME.VXD
            hr = pDIJoyConfig->DeleteConfig(nSelectedItem);
    
            /*
             * This notify is to fix the bug changing id on 2-axis 2-button joystick.
             */
            pDIJoyConfig->SendNotify();
    
            if( SUCCEEDED(hr) )
            {
                hr = pDIJoyConfig->SetConfig(nSelectedID, lpSelectedItem, dwFlags );
                
                if( SUCCEEDED(hr) ) {
                    pDIJoyConfig->SendNotify();
                }
            }
        } else {
            hr = pDIJoyConfig->SetConfig(nSelectedID, lpSelectedItem, dwFlags );
    
            /*
             * This notify is to fix the bug changing id on 2-axis 2-button joystick.
             */
            pDIJoyConfig->SendNotify();
    
            if( SUCCEEDED(hr) )
            {
                hr = pDIJoyConfig->DeleteConfig(nSelectedItem);
                
                pDIJoyConfig->SendNotify();
                
                if( nSelectedID < nSelectedItem ) {
                    pDIJoyConfig->SendNotify();
                }
            
            }

        }

        if( lpSelectedItem )
        {
            delete (lpSelectedItem);
        }
    }

    // Set the hour glass
    SetCursor(LoadCursor(NULL, IDC_ARROW));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\guids.cpp ===
// Defines guids  --ddalal 10/13/99

#include <initguid.h>
//#include <AppManAdmin.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\cpanel.cpp ===
/*
 * File:    Cpanel.cpp
 * Project: Universal Joystick Control Panel OLE Client
 * Author:  Brycej
 * Date:    02/08/95 - Started this maddness...
 *          04/15/97 - Updated to use DI interface
 * Comments:
 *          window proc for General page in cpanel
 *
 * Copyright (c) 1995, Microsoft Corporation
 */                                                      

/*
// This is necessary LVS_EX_INFOTIP
#if (_WIN32_IE < 0x0500)
#undef _WIN32_IE
#define  _WIN32_IE  0x0500
#endif
*/


#include <afxcmn.h>
#include <windowsx.h>

#ifndef _UNICODE
    #define INC_OLE2

    #include <objbase.h>    // For COM stuff!
#endif

#include <initguid.h>

#include <cpl.h>
#include <winuser.h>  // For RegisterDeviceNotification stuff!
#include <dbt.h>      // for DBT_ defines!!!
#include <hidclass.h>
#include <malloc.h>  // for _alloca
#include <regstr.h>		  // for REGSTR_PATH_JOYOEM reference!

#include "hsvrguid.h"
#include "cpanel.h"
#include "resource.h"
#include "joyarray.h"

// constants
const short ID_MYTIMER  = 1000;
const short POLLRATE        = 850;
const short NO_ITEM    = -1;

#define IDC_WHATSTHIS   400

// externs
extern const DWORD gaHelpIDs[];
extern HINSTANCE ghInstance;

// externs for arguements!
extern BYTE nID, nStartPageDef, nStartPageCPL;

// DI globals
IDirectInputJoyConfig* pDIJoyConfig = 0;
LPDIRECTINPUT lpDIInterface = 0;

// Array of all available devices
#ifndef _UNICODE
WCHAR *pwszGameportDriverArray[MAX_GLOBAL_PORT_DRIVERS]; // List of enumerated Gameport Drivers
BYTE nGameportDriver; // Global Port Driver Enumeration Counter
#endif

WCHAR *pwszTypeArray[MAX_DEVICES];    // List of enumerated devices
WCHAR *pwszGameportBus[MAX_BUSSES];   // List of enumerated gameport buses 
PJOY  pAssigned[MAX_ASSIGNED];        // List of assigned devices

BYTE nGamingDevices;     // Gaming Devices Enumeration Counter
BYTE nGameportBus;    // Gameport Bus Enumeration Counter
BYTE nAssigned;       // Number of elements in pAssigned array
BYTE nTargetAssigned;  // Number of elements expected in pAssigned array when pending adds complete
BYTE nReEnum;           // Counter used to decide when to reenumerate

GUID guidOccupied[MAX_BUSSES];  //Whether the gameport bus has been occupied.

short nFlags;         // Flags for Update, User Mode, and if the user is on this page!

// local (module-scope) variables
static HWND hListCtrl;
short  iItem = NO_ITEM; // index of selected item
extern short iAdvItem;

// Global to avoid creating in timer!
static LPDIJOYSTATE   lpDIJoyState;

static UINT JoyCfgChangedMsg;     // vjoyd JoyConfigChanged message
static BOOL WINAPI MsgSubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static WNDPROC fpMainWindowProc; 

#ifdef _UNICODE
static PVOID hNotifyDevNode;     
#endif

// local message handlers
static BOOL OnInitDialog             (HWND, HWND, LPARAM);
static void OnCommand                (HWND, int, HWND, UINT);
static BOOL OnNotify                    (HWND, WPARAM, NMHDR*);
static void OnDestroy                (HWND);
static void OnListViewContextMenu (HWND hDlg,     LPARAM lParam);

#ifndef _UNICODE
BOOL AddListCtrlItem(BYTE nItemID, LPDIJOYCONFIG pJoyConfig);
#endif


// Share these with Add.cpp
void OnContextMenu           (WPARAM wParam, LPARAM lParam);
void OnHelp                      (LPARAM);

#ifdef WINNT
// Share this one with Advanced.cpp
void RunWDMJOY               ( void );
#endif

// local utility fns
static BOOL DetectHotplug     ( HWND hDlg, BYTE nItemSelected );
static BOOL SetActive         ( HWND hDlg );
static void UpdateListCtrl      ( HWND hDlg );
static void UpdateButtonState ( HWND hDlg );
static void StatusChanged     ( HWND hDlg, BYTE i );

JOY::JOY()
{
    ID                  = nStatus = nButtons = -1; 
    clsidPropSheet  = CLSID_LegacyServer;
    fnDeviceInterface = 0;
}

JOY::~JOY()
{
    if( fnDeviceInterface )
    {
        fnDeviceInterface->Unacquire();
        fnDeviceInterface->Release();
        fnDeviceInterface = 0;
    }
}

///////////////////////////////////////////////////////////////////////////////
//CPanelProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CPanelProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg )
    {
    case WM_ACTIVATEAPP:
        if( nFlags & ON_PAGE )
        {
            if( wParam )
            {
                if( nFlags & UPDATE_FOR_GEN )
                {
                    nFlags &= ~UPDATE_FOR_GEN;
                    UpdateListCtrl(hDlg);
                }

                // Set the focus!
                if( nAssigned )
                {
                    if( iItem == NO_ITEM )
                        iItem = 0;

                    if( pDIJoyConfig )
                        SetActive(hDlg);

                    // restore selection focus
                    SetListCtrlItemFocus(hListCtrl, (BYTE)iItem);
                } else {
                    UpdateButtonState(hDlg);
                }

                // the user is requesting that the CPL be shown
                // and an extention associated with nID be Launched.
                if( nID < NUMJOYDEVS )
                {

                    BYTE nCount = (BYTE)::SendMessage(hListCtrl, LVM_GETITEMCOUNT, 0, 0);

                    while( nCount-- )
                    {
                        if( pAssigned[GetItemData(hListCtrl, (BYTE)iItem)]->ID == nID )
                        {
                            KillTimer(hDlg, ID_MYTIMER);

                            OnCommand(hDlg, IDC_BTN_PROPERTIES, 0, 0);

                            SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
                            break;
                        }
                    }

                    // just to get nID > NUMJOYDEVS!
                    nID = (NUMJOYDEVS<<1);
                }
            } else
            {
                KillTimer(hDlg, ID_MYTIMER);
            }
        }
        break;

    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(GetParent(hDlg), WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

    case WM_INITDIALOG:
        if( !HANDLE_WM_INITDIALOG(hDlg, wParam, lParam, OnInitDialog) )
        {
            // Fix #108983 NT, Remove Flash on Error condition.
            SetWindowPos(::GetParent(hDlg), HWND_BOTTOM, 0, 0, 0, 0, SWP_HIDEWINDOW);
            DestroyWindow(hDlg);
        }

        // if we want to set focus, get the control hWnd 
        // and set it as the wParam.
        return(TRUE);

    case WM_DESTROY:
        HANDLE_WM_DESTROY(hDlg, wParam, lParam, OnDestroy);
        return(1);

        // OnTimer
    case WM_TIMER:
        {
            BYTE i = nAssigned; 
            BYTE nButtons;
            BYTE nLoop;

            if( nReEnum )
            {
                if( !( --nReEnum & 3 ) )
                {
                    //  ISSUE-2001/03/29-timgill Much used code
                    //  (MarcAnd) I hope this code is generally appropriate
                    //  it appears in much the same form all over the place.
                    KillTimer(hDlg, ID_MYTIMER);
                    // Set the Update Flag!
                    nFlags |= UPDATE_ALL;
                    UpdateListCtrl(hDlg);
                    SetActive(hDlg);
                    SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
                }
            }

            while( i-- )
            {
                if( pAssigned[i]->fnDeviceInterface )
                {
                    int nPollFail;

                    pAssigned[i]->fnDeviceInterface->Acquire();

                    // LOOKOUT RE-USE of nButtons!
                    nButtons = pAssigned[i]->nStatus;

                    nLoop = 5; 
                    nPollFail = 0;

                    // Special work for the sidewinder folks...
                    // ACT LAB: You can't poll actrs.vxd (ACT LAB) too often, otherwise it fails.
                    //          See Manbug 41049.  - qzheng 8/1/2000
                    do
                    {
                        if( FAILED(pAssigned[i]->fnDeviceInterface->Poll()) ) {
                            nPollFail ++;
                        } else {
                            break;
                        }

                        Sleep(30);
                    } while( nLoop-- );

                    // Check to see if things have changed!
                    pAssigned[i]->nStatus = (nPollFail > 2) ? (BYTE)0 : (BYTE)JOY_US_PRESENT;

                    if( pAssigned[i]->nStatus != nButtons )
                    {
                        StatusChanged(hDlg, i);
                    }

                    // Check for button press and set focus to it!!!
                    if( pAssigned[i]->nStatus == JOY_US_PRESENT )
                    {
                        // Do the button press launch thing!
                        if( SUCCEEDED(pAssigned[i]->fnDeviceInterface->GetDeviceState(sizeof(DIJOYSTATE), lpDIJoyState)) )
                        {
                            nButtons = pAssigned[i]->nButtons;

                            // run up the list of buttons and check if there's one that's down!
                            while( nButtons-- )
                            {
                                if( lpDIJoyState->rgbButtons[nButtons] & 0x80 )
                                {
                                    // SetFocus on Selected Item
                                    SetListCtrlItemFocus(hListCtrl, i);
                                    break;
                                }
                            }
                        }
                    }
                
                }
            }

            if( nAssigned ) {
                /*
                 * If the selected device is "Not Connected", grey out the property button.
                 */
                int id = GetItemData(hListCtrl, (BYTE)iItem);
                PostDlgItemEnableWindow(hDlg, IDC_BTN_PROPERTIES, (BOOL)(pAssigned[id]->nStatus & JOY_US_PRESENT));
            }

        }
        break;

    case WM_COMMAND:
        HANDLE_WM_COMMAND(hDlg, wParam, lParam, OnCommand);
        return(1);

    case WM_NOTIFY:
        return(HANDLE_WM_NOTIFY(hDlg, wParam, lParam, OnNotify));

    case WM_POWERBROADCAST:
        switch( wParam )
        {
        case PBT_APMSUSPEND:
            // Suspend operation!
            KillTimer(hDlg, ID_MYTIMER);
            break;

        case PBT_APMRESUMESUSPEND:
        case PBT_APMRESUMECRITICAL:
            // Resume operation!
            SetActive(hDlg);
            break;
        }
        break;

    case WM_DEVICECHANGE:
        switch( (UINT)wParam )
        {
        case DBT_DEVICEQUERYREMOVE:
            {
                KillTimer(hDlg, ID_MYTIMER);

                BYTE i = (BYTE)::SendMessage(hListCtrl, LVM_GETITEMCOUNT, 0, 0);

                // Acquire All Devices that are Attached!!!
                char nIndex;

                while( i-- )
                {
                    // get joystick config of item
                    nIndex = (char)GetItemData(hListCtrl, i);

                    if( pAssigned[nIndex]->nStatus & JOY_US_PRESENT )
                        pAssigned[nIndex]->fnDeviceInterface->Unacquire();
                }
            }
            break;

        case DBT_DEVICEARRIVAL:
        case DBT_DEVICEREMOVECOMPLETE:
            if( nFlags & ON_PAGE )
            {
                PostMessage(hDlg, WM_COMMAND, IDC_BTN_REFRESH, 0);            	

              #if 0
                if( !(nFlags & BLOCK_UPDATE) )
                {
                    KillTimer(hDlg, ID_MYTIMER);

                    // Set the Update Flag!
                    nFlags |= UPDATE_ALL;

                    UpdateListCtrl(hDlg);

                    SetActive(hDlg);

                    SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
                }
              #endif
            }
            break;
        }
        break;

    case WM_HELP:
        KillTimer(hDlg, ID_MYTIMER);
        OnHelp(lParam);
        SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
        break;

    case WM_CONTEXTMENU:
        nFlags &= ~ON_PAGE;
        KillTimer(hDlg, ID_MYTIMER);
        OnContextMenu(wParam, lParam);
        nFlags |= ON_PAGE;
        SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
        return(1);
    }

    return(0);
}

///////////////////////////////////////////////////////////////////////////////
// StatusChanged( HWND hDlg, BYTE i )
///////////////////////////////////////////////////////////////////////////////
void StatusChanged( HWND hDlg, BYTE i )
{
    // Update the buttons and set focus to changed item!  
    PostDlgItemEnableWindow(hDlg, IDC_BTN_PROPERTIES, (BOOL)(pAssigned[i]->nStatus & JOY_US_PRESENT));

    if( pAssigned[0] )
    {
        PostDlgItemEnableWindow(hDlg, IDC_BTN_REMOVE, TRUE );
    }

    // Don't try to make this buffer any smaller... 
    // Remember... we also have "Not Connected"!
    TCHAR sz[20];

    // display result
    VERIFY(LoadString(ghInstance, (pAssigned[i]->nStatus & JOY_US_PRESENT) ? IDS_GEN_STATUS_OK : IDS_GEN_STATUS_NOTCONNECTED, (LPTSTR)&sz, 20));


    LVFINDINFO *lpFindInfo = new (LVFINDINFO);
    ASSERT (lpFindInfo);

    ZeroMemory(lpFindInfo, sizeof(LVFINDINFO));

    lpFindInfo->flags  = LVFI_PARAM;
    lpFindInfo->lParam = i;

    // Make sure you place i where it's suppose to be!
    i = (BYTE)::SendMessage(hListCtrl, LVM_FINDITEM, (WPARAM)(int)-1, (LPARAM)(const LVFINDINFO*)lpFindInfo);

    if( lpFindInfo )
        delete (lpFindInfo);

    SetItemText(hListCtrl, i, STATUS_COLUMN, sz);
    ::PostMessage(hListCtrl, LVM_UPDATE, (WPARAM)i, 0L);
    SetListCtrlItemFocus(hListCtrl, i);
}


///////////////////////////////////////////////////////////////////////////////
//OnInitDialog(HWND hDlg, HWND hWnd, LPARAM lParam)
///////////////////////////////////////////////////////////////////////////////
BOOL OnInitDialog(HWND hDlg, HWND hWnd, LPARAM lParam)
{
    // initialize our list control
    hListCtrl = GetDlgItem(hDlg, IDC_LIST_DEVICE);
    ASSERT(hListCtrl);

    // LVS_EX_ONECLICKACTIVATE removed per PSierra                                           | LVS_EX_INFOTIP
    ::SendMessage(hListCtrl, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

    if( !lpDIInterface )
    {
        if( FAILED(DirectInputCreate(ghInstance, DIRECTINPUT_VERSION, &lpDIInterface, NULL)) )
        {
#ifdef _DEBUG
            OutputDebugString(TEXT("GCDEF.DLL: DirectInputCreate() failed\n"));
#endif
            Error((short)IDS_INTERNAL_ERROR, (short)IDS_NO_DIJOYCONFIG);
            return(FALSE);
        }
    }

    // Dynamically size the columns!
    RECT rc;
    ::GetClientRect(hListCtrl, &rc);

    // cut the list control into 1/4ths
    rc.right >>= 2;

    // This one get's 3/4ths
    InsertColumn(hListCtrl, DEVICE_COLUMN, IDS_GEN_DEVICE_HEADING, (USHORT)(rc.right*3));   

    // Column heading for Status
    InsertColumn(hListCtrl, STATUS_COLUMN, IDS_GEN_STATUS_HEADING, (USHORT)(rc.right+3));   

    if( !pDIJoyConfig )
    {

        // just in case CoCreateInstanceFailed...
        if( FAILED(lpDIInterface->QueryInterface(IID_IDirectInputJoyConfig, (LPVOID*)&pDIJoyConfig)) )
        {
#ifdef _DEBUG
            OutputDebugString (TEXT("JOY.CPL: CoCreateInstance Failed... Closing CPL!\n"));
#endif
            Error((short)IDS_INTERNAL_ERROR, (short)IDS_NO_DIJOYCONFIG);

            return(FALSE);
        }

        VERIFY (SUCCEEDED(pDIJoyConfig->SetCooperativeLevel(hDlg, DISCL_EXCLUSIVE | DISCL_BACKGROUND)));
    }

    // Zero out the global counters!
#ifndef _UNICODE
    nGameportDriver = 0;
#endif
    nGamingDevices = nGameportBus = 0;

    // Try to Acquire, if you fail... Disable the Add and Remove buttons!
    if( pDIJoyConfig->Acquire() == DIERR_INSUFFICIENTPRIVS )
    {
        nFlags |=  USER_MODE;

        LONG style = ::GetWindowLong(hListCtrl, GWL_STYLE);
        style &= ~LVS_EDITLABELS;

        ::SetWindowLong(hListCtrl, GWL_STYLE, style);
    }
#ifdef WINNT
    else 
    {
        //Run the WDMJOY.INF file!!!
        RunWDMJOY();
        pDIJoyConfig->SendNotify();
    }        
#endif

    if( FAILED(pDIJoyConfig->EnumTypes((LPDIJOYTYPECALLBACK)DIEnumJoyTypeProc, NULL)) )
    {
#ifdef _DEBUG
        OutputDebugString( TEXT("JOY.CPL: Failed BuildEnumList!\n") );
#endif
        return(FALSE);
    }

    // Don't allow Add if there is nothing to add!
    // OR no port to add them to!
    if( ((!nGameportBus) && (!nGamingDevices)) 
#ifdef _UNICODE
        || GetSystemMetrics(SM_REMOTESESSION) 
#endif
    ) {
        PostDlgItemEnableWindow(hDlg, IDC_BTN_ADD, FALSE);
    }

    // register the JOY_CONFIGCHANGED_MSGSTRING defined in MMDDK.H if you're on Memphis
    JoyCfgChangedMsg = (nFlags & ON_NT) ? NULL : RegisterWindowMessage(TEXT("MSJSTICK_VJOYD_MSGSTR"));

    // blj: Warning Message that you can't add any more devices!
    if( nGamingDevices == MAX_DEVICES-1 )
        Error((short)IDS_MAX_DEVICES_TITLE, (short)IDS_MAX_DEVICES_MSG);

    // blj: beginning of fix for 5.0 to turn on all devices!
    LPDIJOYCONFIG_DX5 pJoyConfig = new (DIJOYCONFIG_DX5);
    ASSERT (pJoyConfig);

    ZeroMemory(pJoyConfig, sizeof(DIJOYCONFIG_DX5));

    pJoyConfig->dwSize = sizeof(DIJOYCONFIG_DX5);

    // Set the hour glass
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    BYTE nIndex = nAssigned;
    HRESULT hr;

    while( nIndex )
    {
        hr = pDIJoyConfig->GetConfig(pAssigned[--nIndex]->ID, (LPDIJOYCONFIG)pJoyConfig, DIJC_REGHWCONFIGTYPE);

        if( (hr == S_FALSE) || FAILED(hr) )
            continue;

        if( pJoyConfig->hwc.dwUsageSettings & JOY_US_PRESENT )
            continue;

        pJoyConfig->hwc.dwUsageSettings |= JOY_US_PRESENT;

        VERIFY(SUCCEEDED(pDIJoyConfig->SetConfig(pAssigned[nIndex]->ID, (LPDIJOYCONFIG)pJoyConfig, DIJC_REGHWCONFIGTYPE)));

        // Fix #55524
        VERIFY(SUCCEEDED(pDIJoyConfig->GetConfig(pAssigned[nIndex]->ID, (LPDIJOYCONFIG)pJoyConfig, DIJC_REGHWCONFIGTYPE)));

        if( !(pJoyConfig->hwc.dwUsageSettings & JOY_US_PRESENT) )
        {
            if( SUCCEEDED(pDIJoyConfig->Acquire()) )
            {
                pJoyConfig->hwc.dwUsageSettings |= JOY_US_PRESENT;
                pJoyConfig->hwc.hwv.dwCalFlags  |= 0x80000000;
                VERIFY(SUCCEEDED(pDIJoyConfig->SetConfig(pAssigned[nIndex]->ID, (LPDIJOYCONFIG)pJoyConfig, DIJC_REGHWCONFIGTYPE)));
            }
        }
        // end of Fix #55524
    } 

    if( pJoyConfig ) delete (pJoyConfig);
    // blj: end of fix for 5.0 to turn on all devices!

    // Set the hour glass
    SetCursor(LoadCursor(NULL, IDC_ARROW));

    HWND hParentWnd = GetParent(hDlg);

    GetWindowRect(hParentWnd, &rc);

    // Only center the dialog if this was the page that we started on!
    if( (nStartPageCPL == 0) || (nStartPageCPL == NUMJOYDEVS) )
    {
        // Centre the Dialog!
        SetWindowPos(hParentWnd, NULL, 
                     (GetSystemMetrics(SM_CXSCREEN) - (rc.right-rc.left))>>1, 
                     (GetSystemMetrics(SM_CYSCREEN) - (rc.bottom-rc.top))>>1, 
                     NULL, NULL, SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

        if( nStartPageCPL == NUMJOYDEVS )
            PostMessage(hDlg, WM_COMMAND, IDC_BTN_ADD, 0);
    }

    // Do that move button thing!
    MoveOK(hParentWnd);

    // this is required because the CPL can be launched via RUNDLL32
    if( ::IsWindow(hParentWnd) )
        hParentWnd = GetParent(hParentWnd);

    // Since the JOY_CONFIGCHANGED_MSGSTRING msg only gets sent to top-level
    // windows, this calls for a subclass!
    if( JoyCfgChangedMsg )
        fpMainWindowProc = (WNDPROC)SetWindowLongPtr(hParentWnd, GWLP_WNDPROC, (LONG_PTR)MsgSubClassProc);

    // Set bOnPage so WM_ACTIVATEAPP will work!
    nFlags |= ON_PAGE;

    // Update the list ctrl!
    nFlags |= UPDATE_FOR_GEN;

    // to put the selection on the first item on startup...
    if( nAssigned )
        iItem = 0;

    lpDIJoyState = new (DIJOYSTATE);
    ASSERT (lpDIJoyState);

    ZeroMemory(lpDIJoyState, sizeof(DIJOYSTATE));

    return(TRUE);
}

///////////////////////////////////////////////////////////////////////////////
//OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code)
///////////////////////////////////////////////////////////////////////////////
void OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code)
{                                                
    switch( id )
    {
    case IDC_WHATSTHIS:
        {
            // point to help file
            LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
            ASSERT (pszHelpFileName);

            if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
                WinHelp((HWND)hListCtrl, pszHelpFileName, HELP_WM_HELP, (ULONG_PTR)gaHelpIDs);
#ifdef _DEBUG
            else 
                OutputDebugString(TEXT("JOY.CPL: OnCommand: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif // _DEBUG

            if( pszHelpFileName ) {
                delete[] (pszHelpFileName);
            }
        }
        return;

    case IDC_BTN_REMOVE:
        KillTimer(hDlg, ID_MYTIMER);
        nFlags &= ~ON_PAGE;

        // Block Update, otherwise we'll be forced to update and we don't need to!
        nFlags |= BLOCK_UPDATE;

        if( nFlags & USER_MODE )
            Error((short)IDS_USER_MODE_TITLE, (short)IDS_USER_MODE);
        else if( DeleteSelectedItem((PBYTE)&iItem) )
        {
            UpdateButtonState(hDlg);

            // Set the UpdateFlag!
            nFlags |= UPDATE_FOR_ADV;

            // Set the default push button to the Add button!
            ::PostMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)1, (LPARAM)LOWORD(FALSE));
        }

        // Unblock the WM_DEVICECHANGE message handler!
        nFlags &= ~BLOCK_UPDATE;

        nFlags |= ON_PAGE;
        SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
        break;

    case IDC_BTN_ADD:
        // Don't set ON_PAGE flag!
        // We need the WM_DEVICECHANGE message in the case a user plugs in a device!

        KillTimer(hDlg, ID_MYTIMER);

        ClearArrays();

        // Clear everything up before you call this...
        if( FAILED(pDIJoyConfig->EnumTypes((LPDIJOYTYPECALLBACK)DIEnumJoyTypeProc, NULL)) )
            break;

        nFlags &= ~ON_PAGE;

        if( nFlags & USER_MODE )
        {
            Error((short)IDS_USER_MODE_TITLE, (short)IDS_USER_MODE);
        }
        // call AddDevice dialog
        else if( DialogBox( ghInstance, (PTSTR)IDD_ADD, hDlg, AddDialogProc ) == IDOK )
        {
            SendMessage(hDlg, WM_COMMAND, IDC_BTN_REFRESH, 0);
        }

        SetListCtrlItemFocus(hListCtrl, (BYTE)iItem);

        nFlags &= ~BLOCK_UPDATE;
        nFlags |= ON_PAGE;

        // Now, we set it back active!
        SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
        break;

    case IDC_BTN_REFRESH:
        KillTimer(hDlg, ID_MYTIMER);

        nFlags |= UPDATE_ALL;

        pDIJoyConfig->Acquire();
        pDIJoyConfig->SendNotify();

        UpdateListCtrl(hDlg);
        UpdateButtonState(hDlg);

        pDIJoyConfig->SendNotify();
        pDIJoyConfig->Unacquire();

        SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
        break;

    case IDC_RENAME:
        // Don't allow editing of Mouse or Keyboard names!
        // Don't allow renaming if in USER mode!
        if( !(nFlags & USER_MODE) )
        {
            KillTimer(hDlg, ID_MYTIMER);

            ::PostMessage(hListCtrl, LVM_EDITLABEL, (WPARAM)(int)iItem, 0);
        }
        return;

        /* If we want this back...
        case IDC_SW_HACK:
            {
            // SideWinder Hack button!
            BYTE nID = pAssigned[GetItemData(hListCtrl, (BYTE)iItem)]->ID;
    
            if (nID == 0) 
            {
                ::PostMessage(GetDlgItem(hDlg, IDC_SW_HACK), BM_SETCHECK, BST_CHECKED, 0);
                //CheckDlgButton(hDlg, IDC_SW_HACK, BST_CHECKED);
                break;
            }
    
            // Get the Selected Item and force its ID to Zero!
            SwapIDs((BYTE)nID, (BYTE)0);
            }
        */
        // Missing break intentional!
        // Used to fall into IDC_BTN_REFRESH!

    case IDC_BTN_TSHOOT:
        {
            LPTSTR lpszCmd = new (TCHAR[STR_LEN_64]);
            ASSERT (lpszCmd);

            if( LoadString(ghInstance, IDS_TSHOOT_CMD, lpszCmd, STR_LEN_64) )
            {
                LPSTARTUPINFO pSi           = (LPSTARTUPINFO)_alloca(sizeof(STARTUPINFO));
                LPPROCESS_INFORMATION pPi  = (LPPROCESS_INFORMATION)_alloca(sizeof(PROCESS_INFORMATION));

                ZeroMemory(pSi, sizeof(STARTUPINFO));
                ZeroMemory(pPi, sizeof(PROCESS_INFORMATION));

                pSi->cb              = sizeof(STARTUPINFO);
                pSi->dwFlags     = STARTF_USESHOWWINDOW | STARTF_FORCEONFEEDBACK;
                pSi->wShowWindow = SW_NORMAL;

                if( CreateProcess(0, lpszCmd, 0, 0, 0, 0, 0, 0, pSi, pPi) )
                {
                    CloseHandle(pPi->hThread);
                    CloseHandle(pPi->hProcess);
                }
            }

            if( lpszCmd )
                delete[] (lpszCmd);
        }
        break;
 			
#if 0  //disable UPDATE button, see manbug 33666.
    case IDC_BTN_UPDATE:
        if (DialogBox(ghInstance, MAKEINTRESOURCE(IDD_UPDATE), hDlg, CplUpdateProc) == IDOK)
        {
            Update( hDlg, 1, NULL ); //NO Proxy
        }
        break;
#endif

    case IDC_BTN_PROPERTIES:

        // Because PSN_KILLACTIVE is not sent... we do it ourselves
        // kill status timer
        KillTimer(hDlg, ID_MYTIMER);
        nFlags &= ~ON_PAGE;

        {
            char nIndex = (char)GetItemData(hListCtrl, (BYTE)iItem);

            // default to the first page!
#ifdef _DEBUG
            HRESULT hr = 
#endif _DEBUG
            Launch(hDlg, pAssigned[nIndex], IsEqualIID(pAssigned[nIndex]->clsidPropSheet, CLSID_LegacyServer) ? 1 : 0);

#ifdef _DEBUG
            switch( hr )
            {
            case DIGCERR_NUMPAGESZERO:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_NUMPAGESZERO!\n"), pAssigned[nIndex]->ID, id);
                break;

            case DIGCERR_NODLGPROC:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_NODLGPROC!\n"), pAssigned[nIndex]->ID, id);
                break;

            case DIGCERR_NOPREPOSTPROC:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_NOPREPOSTPROC!\n"), pAssigned[nIndex]->ID, id);
                break;

            case DIGCERR_NOTITLE:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_NOTITLE!\n"), pAssigned[nIndex]->ID, id);
                break;

            case DIGCERR_NOCAPTION:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_NOCAPTION!\n"), pAssigned[nIndex]->ID, id);
                break;

            case DIGCERR_NOICON:            
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_NOICON!\n"), pAssigned[nIndex]->ID, id);
                break;

            case DIGCERR_STARTPAGETOOLARGE:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_STARTPAGETOOLARGE!\n"), pAssigned[nIndex]->ID, id);
                break;

            case DIGCERR_NUMPAGESTOOLARGE:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_NUMPAGESTOOLARGE!\n"), pAssigned[nIndex]->ID, id);
                break;

            case DIGCERR_INVALIDDWSIZE: 
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_INVALIDDWSIZE!\n"), pAssigned[nIndex]->ID, id);
                break;

            case E_NOINTERFACE:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error E_NOINTERFACE!\n"), pAssigned[nIndex]->ID, id);
                break;

            case E_OUTOFMEMORY:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error E_OUTOFMEMORY!\n"), pAssigned[nIndex]->ID, id);
                break;

                //case DIGCERR_NUMPAGESTOOLARGE:
                //case DIGCERR_STARTPAGETOOLARGE:

            default:
// Only display this return code if things are going Really weird.
                TRACE (TEXT("JOY.CPL: Launch return code is %x %s!\n"), hr, strerror(hr));
                break;
            }
#endif // _DEBUG

            nFlags |= ON_PAGE;

            //OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: returned from Property sheet!\n"));

            InvalidateRect(hDlg, NULL, TRUE);
            UpdateWindow(hDlg);

            // Now, we set it back active!
            // create timer
            SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
        }
        break;
    }

    // Set the focus where we left off!
    if( iItem == NO_ITEM )
        iItem = 0;

    SetListCtrlItemFocus(hListCtrl, (BYTE)iItem);
}

////////////////////////////////////////////////////////////////////////////////
// OnNotify(HWND hDlg, WPARAM idFrom, NMHDR* pnmhdr)
// Purpose: WM_NOTIFY Handler
////////////////////////////////////////////////////////////////////////////////
BOOL OnNotify(HWND hDlg, WPARAM idFrom, NMHDR* pnmhdr)
{
    switch( pnmhdr->code )
    {
    case PSN_QUERYCANCEL:
        if( nFlags & UPDATE_INPROCESS )
            nFlags &= ~UPDATE_INPROCESS;
        break;

    case LVN_BEGINLABELEDIT:
        if( nFlags & USER_MODE )
            return(TRUE);

        KillTimer(hDlg, ID_MYTIMER);
        ::PostMessage((HWND)::SendMessage(hListCtrl, LVM_GETEDITCONTROL, 0, 0), EM_SETLIMITTEXT, MAX_STR_LEN, 0);

        // This lets us know if the edit field is up!
        nFlags |= UPDATE_INPROCESS;
        return(FALSE);   

/*
    case LVN_GETINFOTIP:
        {
        LPLVHITTESTINFO lpHit = new (LVHITTESTINFO);
        ASSERT (lpHit);

        BOOL bRet = FALSE;

        POINT pt;
        GetCursorPos(&pt);
        ScreenToClient(hListCtrl, &pt);

        lpHit->pt    = pt;
        lpHit->flags = lpHit->iItem = lpHit->iSubItem = 0;

        ::SendMessage(hListCtrl, LVM_SUBITEMHITTEST, 0, (LPARAM)(LPLVHITTESTINFO)lpHit);

        // We only want to support the device column!
        if (lpHit->iSubItem == 0)
        {
            if (lpHit->flags & LVHT_ONITEMLABEL)
            {
                // Determine the text length of the column text
                LPTSTR lpStr = new (TCHAR[MAX_STR_LEN+1]);
                ASSERT (lpStr);

                GetItemText(hListCtrl, lpHit->iItem, lpHit->iSubItem, lpStr, MAX_STR_LEN);

                // Determine if the latter will fit inside the former...
                SIZE size;
                HDC hDC = GetDC(hListCtrl);
               GetTextExtentPoint(hDC, lpStr, lstrlen(lpStr), &size);
                ReleaseDC(hListCtrl, hDC);

                // Determine how wide the column is!
                short nWidth = (short)::SendMessage(hListCtrl, LVM_GETCOLUMNWIDTH, lpHit->iSubItem, 0);

                bRet = (BOOL)(size.cx > nWidth);

                if (bRet)
                    // if not, copy the text into lpHit->pszText
                    _tcscpy(((LPNMLVGETINFOTIP)pnmhdr)->pszText, lpStr);

                if (lpStr)
                    delete[] (lpStr);
            }
        }

        if (lpHit)
            delete (lpHit);

        return bRet;
        }
*/

    case LVN_ENDLABELEDIT:
        if( nFlags & UPDATE_INPROCESS )
        {
            HWND hCtrl = (HWND)::SendMessage(hListCtrl, LVM_GETEDITCONTROL, 0, 0);
            ASSERT(::IsWindow(hCtrl));

            if( ::SendMessage(hCtrl, EM_GETMODIFY, 0, 0) )
            {
                BYTE nLen = (BYTE)lstrlen(((NMLVDISPINFO *)pnmhdr)->item.pszText);

                if( (nLen > MAX_STR_LEN) || (nLen == 0) )
                    MessageBeep(MB_ICONHAND);

                // Make sure the name is usable!
                else if( _tcschr(((NMLVDISPINFO *)pnmhdr)->item.pszText, TEXT('\\')) )
                {
                    Error((short)IDS_INVALID_NAME_TITLE, (short)IDS_INVALID_NAME);
                } else
                {
                    // Set the Update flag!
                    nFlags |= UPDATE_ALL;

                    LPDIPROPSTRING pDIPropString = new (DIPROPSTRING);
                    ASSERT (pDIPropString);

                    ZeroMemory(pDIPropString, sizeof(DIPROPSTRING));

                    pDIPropString->diph.dwSize       = sizeof(DIPROPSTRING);
                    pDIPropString->diph.dwHeaderSize = sizeof(DIPROPHEADER);
                    pDIPropString->diph.dwHow        = DIPH_DEVICE;

#ifdef _UNICODE
                    wcscpy(pDIPropString->wsz, ((NMLVDISPINFO *)pnmhdr)->item.pszText);
#else
                    USES_CONVERSION;
                    wcscpy(pDIPropString->wsz, A2W(((NMLVDISPINFO *)pnmhdr)->item.pszText));
#endif
                    if( SUCCEEDED(pAssigned[iItem]->fnDeviceInterface->SetProperty(DIPROP_INSTANCENAME, &pDIPropString->diph)) )
                    {
                        SetItemText(hListCtrl, (BYTE)iItem, 0, ((NMLVDISPINFO *)pnmhdr)->item.pszText);
                    } else
                    {
                        Error((short)IDS_NO_RENAME_TITLE, (short)IDS_NO_RENAME);
                    }

                    if( pDIPropString )
                        delete (pDIPropString);

                    // Trip the flag so the Advanced page knows it needs to update!
                    nFlags |= UPDATE_FOR_ADV;
                }
            }
            // Clear the InProcess flag!
            nFlags &= ~UPDATE_INPROCESS;

        }
        SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
        break;

    case LVN_KEYDOWN:
        switch( ((LV_KEYDOWN*)pnmhdr)->wVKey )
        {
        case VK_DELETE:
            if( iItem != NO_ITEM )
                SendMessage(hDlg, WM_COMMAND, IDC_BTN_REMOVE, 0);
            break;

        case VK_F5:
            nFlags |= UPDATE_ALL;

            UpdateListCtrl(hDlg);

            if( GetKeyState(VK_SHIFT) & 0x80 )
            {
#ifdef WINNT
                RunWDMJOY();
#endif
                ClearArrays();

                pDIJoyConfig->EnumTypes((LPDIJOYTYPECALLBACK)DIEnumJoyTypeProc, NULL);
            }
            break;
        }
        break;

#if 0
    case LVN_COLUMNCLICK:
        {
            CListCtrl *pCtrl = new (CListCtrl);
            ASSERT(pCtrl);

            pCtrl->Attach(hListCtrl);

            if( ((NM_LISTVIEW*)pnmhdr)->iSubItem )
            {
                static bItemDirection = TRUE;

                SortTextItems(pCtrl, 0, bItemDirection =! bItemDirection, 0, -1);
            } else
            {
                static bLabelDirection = TRUE;

                SortTextItems(pCtrl, 0, bLabelDirection =! bLabelDirection, 0, -1);
            }

            pCtrl->Detach();

            if( pCtrl )
                delete (pCtrl);
        }
        break;
#endif

    case LVN_ITEMCHANGED:
        if( iItem != NO_ITEM )
        {
            // get index of selected item
            // no point if it's not changed!
            if( iItem != (short)((NM_LISTVIEW*)pnmhdr)->iItem )
            {
                int i = GetItemData(hListCtrl, (char)iItem);

                iItem = (short)((NM_LISTVIEW*)pnmhdr)->iItem;

                iAdvItem = pAssigned[i]->ID;

                UpdateButtonState(hDlg);
            }
        }
        break;

    case NM_DBLCLK:
        switch( idFrom )
        {
        case IDC_LIST_DEVICE:
            if( iItem == NO_ITEM )
            {
                if( !(nFlags & USER_MODE) && nGameportBus )
                    OnCommand(hDlg, IDC_BTN_ADD, 0, 0);
            } else if( IsWindowEnabled(GetDlgItem(hDlg, IDC_BTN_PROPERTIES)) )
            {
                // make sure the connected one has got an interface pointer...
                OnCommand(hDlg, IDC_BTN_PROPERTIES, 0, 0);
            }
            break;
        }
        break;

    case PSN_KILLACTIVE:
        KillTimer(hDlg, ID_MYTIMER);

        nFlags &= ~ON_PAGE;

        if( nFlags & UPDATE_INPROCESS )
            SetFocus(hListCtrl);

#ifdef _UNICODE
        if( hNotifyDevNode )
            UnregisterDeviceNotification(hNotifyDevNode);
#endif
        PostMessage(hDlg, WM_ACTIVATEAPP, FALSE, 0);
        break;

    case PSN_SETACTIVE:
        nFlags |= ON_PAGE;
        nFlags |= UPDATE_FOR_GEN;
        
#ifdef _UNICODE
        // Set up the Device Notification
        RegisterForDevChange(hDlg, &hNotifyDevNode);
#endif
        SendMessage(hDlg, WM_ACTIVATEAPP, TRUE, 0);
        break;
    }
    return(TRUE);
}

////////////////////////////////////////////////////////////////////////////////////////
//  OnDestroy(HWND hWnd)                                              
////////////////////////////////////////////////////////////////////////////////////////
void OnDestroy(HWND hWnd)
{
    SetWindowPos( GetParent(hWnd), NULL, NULL, NULL, NULL, NULL, 
                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_HIDEWINDOW);

    if( lpDIJoyState )
        delete (lpDIJoyState);

    // if you are looking for where the following variables are deleted, look
    // in DLL_PROCESS_DETACH in MAIN.CPP:
    // pwszTypeArray, pwszGameportDriverArray, pwszGameportBus
    // This is done because of the way several Microsoft games load the CPL and
    // Don't Unload it between loads.

    // Clear pAssigned 
    while( nAssigned )
    {
        if( pAssigned[--nAssigned] )
        {
            delete (pAssigned[nAssigned]);

            pAssigned[nAssigned] = 0;
        }
    }
    // delete all existing entries
    //::PostMessage(hListCtrl, LVM_DELETEALLITEMS, 0, 0);

    // release the DI JoyConfig interface pointer
    if( pDIJoyConfig )
    {
        pDIJoyConfig->Release();
        pDIJoyConfig = 0;
    }

    // release the DI Device interface pointer
    if( lpDIInterface )
    {
        lpDIInterface->Release();
        lpDIInterface = 0;
    }

    // Drop the subclass, else you'll crash!
    if( !(nFlags & ON_NT) )
        SetWindowLongPtr(GetParent(GetParent(hWnd)), GWLP_WNDPROC, (LONG_PTR)fpMainWindowProc);
}

////////////////////////////////////////////////////////////////////////////////////////
//  OnHelp(LPARAM lParam)
////////////////////////////////////////////////////////////////////////////////////////
void OnHelp(LPARAM lParam)
{
    // point to help file
    LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
    ASSERT (pszHelpFileName);

    if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
    {
        if( ((LPHELPINFO)lParam)->iContextType == HELPINFO_WINDOW )
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, pszHelpFileName, HELP_WM_HELP, (ULONG_PTR)gaHelpIDs);

    }
#ifdef _DEBUG
    else OutputDebugString(TEXT("JOY.CPL: OnHelp: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif

    if( pszHelpFileName )
        delete[] (pszHelpFileName);
}

////////////////////////////////////////////////////////////////////////////////////////
//  OnContextMenu(WPARAM wParam)
////////////////////////////////////////////////////////////////////////////////////////
void OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    // this prevents double handling of this message
    if( (HWND)wParam == hListCtrl )
    {
        OnListViewContextMenu(GetParent((HWND)wParam), lParam);
        return;
    }

    // point to help file
    LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
    ASSERT (pszHelpFileName);                      

    if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
        WinHelp((HWND)wParam, pszHelpFileName, HELP_CONTEXTMENU, (ULONG_PTR)gaHelpIDs);
#ifdef _DEBUG
    else OutputDebugString(TEXT("JOY.CPL: OnContextMenu: LoadString Failed to find IDS_HELPFILENAME!\n")); 
#endif

    if( pszHelpFileName )
        delete[] (pszHelpFileName);
}

/////////////////////////////////////////////////////////////////////////////////////////
// OnListViewContextMenu(HWND hDlg)
// Purpose: Query the plug-in for the selected device for it's characteristics
//          Then construct a menu to reflect your findings
/////////////////////////////////////////////////////////////////////////////////////////
void OnListViewContextMenu(HWND hDlg, LPARAM lParam)
{
    BOOL bRet = TRUE;

    HMENU hPopupMenu = CreatePopupMenu();
    ASSERT (hPopupMenu);

    LPTSTR psz = new TCHAR[STR_LEN_32];
    ASSERT (psz);

    // Add the Refresh text
    VERIFY(LoadString(ghInstance, IDS_REFRESH, psz, STR_LEN_32));
    bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_BTN_REFRESH, psz);

    // Add the Add text

    HWND hCtrl;

    // Only Display Add menu option if we've found a GameportBus!!!
    if( nGameportBus 
#ifdef _UNICODE
        && !GetSystemMetrics(SM_REMOTESESSION) 
#endif
    )
    {
        hCtrl = GetDlgItem(hDlg, IDC_BTN_ADD);
        ASSERT(hCtrl);

        if( IsWindowEnabled(hCtrl) )
        {
            ::SendMessage(hCtrl, WM_GETTEXT, (WPARAM)STR_LEN_32, (LPARAM)(LPCTSTR)psz);

            bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_BTN_ADD, psz);
            if( !bRet )
                TRACE(TEXT("JOY.CPL: AppendMenu Failed to insert %s\n"), psz);
        }
    }

    // Add the Remove text
    hCtrl = GetDlgItem(hDlg, IDC_BTN_REMOVE);
    ASSERT(hCtrl);

    // Only Show it if it's available
    if( IsWindowEnabled(hCtrl) && (iItem != NO_ITEM) )
    {
        ::SendMessage(hCtrl, WM_GETTEXT, (WPARAM)STR_LEN_32, (LPARAM)(LPCTSTR)psz);

        bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_BTN_REMOVE, psz);
        if( !bRet )
            TRACE(TEXT("JOY.CPL: AppendMenu Failed to insert %s\n"), psz);
    }

    // Add the Properties text
    hCtrl = GetDlgItem(hDlg, IDC_BTN_PROPERTIES);
    ASSERT (hCtrl);

    if( IsWindowEnabled(hCtrl) )
    {
        ::SendMessage(hCtrl, WM_GETTEXT, (WPARAM)STR_LEN_32, (LPARAM)(LPCTSTR)psz);

        bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_BTN_PROPERTIES, psz);
        if( !bRet )
            TRACE(TEXT("JOY.CPL: AppendMenu Failed to insert %s\n"), psz);
    }

    // Add the Rename text if not a USER!
    if( !(nFlags & USER_MODE) )
    {
        if( nAssigned && (iItem != NO_ITEM) )
        {
            VERIFY(LoadString(ghInstance, IDS_RENAME, psz, STR_LEN_32));
            bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_RENAME, psz);
        }
    }

    bRet = AppendMenu(hPopupMenu, MF_SEPARATOR, 0, 0); 
    if( !bRet )
        TRACE(TEXT("JOY.CPL: AppendMenu Failed to insert the separator!\n"), psz);

    VERIFY(LoadString(ghInstance, IDS_WHATSTHIS, psz, STR_LEN_32));
    bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_WHATSTHIS, psz); 
    if( !bRet )
        TRACE(TEXT("JOY.CPL: AppendMenu Failed to insert %s\n"), psz);

    if( psz ) delete[] (psz);

    POINT pt;

    // lParam is -1 if we got here via Shift+F10
    if( lParam > 0 )
    {
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
    } else
    {
        // Centre the popup on the selected item!

        // This get's a good X pos, but the y is the start of the control!
        ::SendMessage(hListCtrl, LVM_GETITEMPOSITION, iItem, (LPARAM)&pt);

        RECT rc;
        ::GetClientRect(hListCtrl, &rc);

        pt.x = rc.right>>1;

        ClientToScreen(hListCtrl, &pt);
    }

    // restore selection focus
    SetListCtrlItemFocus(hListCtrl, (BYTE)iItem);

    bRet = TrackPopupMenu (hPopupMenu, TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON, pt.x, pt.y, 0, hDlg, NULL);
    if( !bRet )
        TRACE (TEXT("JOY.CPL: TrackPopupMenu Failed!\n"));

    if(hPopupMenu) DestroyMenu (hPopupMenu);   // PREFIX 45088

    // Set the focus back to the item it came from!
    SetListCtrlItemFocus(hListCtrl, (BYTE)iItem);
}


int CALLBACK CompareStatusItems(LPARAM item1, LPARAM item2, LPARAM uDirection)
{
    if( (((PJOY)item1)->nStatus & JOY_US_PRESENT) == (((PJOY)item2)->nStatus & JOY_US_PRESENT) )
        return(0);

    return(uDirection) ? -1 : 1;
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    DeleteSelectedItem ( BYTE nItem )
//
// PARAMETERS:  nItem - ID of item to remove
//
// PURPOSE:     Prompt the user, delete the selected device from the listview, and update the registry
//
// RETURN:      TRUE if successfull, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL DeleteSelectedItem( PBYTE pnItem )
{
    BYTE nItem = *pnItem;
    
    // don't process if nothing is selected.
    if( *pnItem == NO_ITEM )
        return(FALSE);

    LV_ITEM lvItem;
    lvItem.mask       = LVIF_PARAM;
    lvItem.iSubItem = 0;
    lvItem.iItem    = *pnItem;

    if( !ListView_GetItem(hListCtrl, &lvItem) )
        return(FALSE);

    ::PostMessage(hListCtrl, LVM_ENSUREVISIBLE, *pnItem, FALSE );

    LPTSTR pszTitle = new TCHAR[STR_LEN_64];
    ASSERT (pszTitle);

    // Query user if they are sure!
    VERIFY(LoadString(ghInstance, IDS_GEN_AREYOUSURE, pszTitle, STR_LEN_64));   

    // Get the name of the device for the message box!

    //PREFIX #WI226554. Won't fix. Obsolete code, from Whistler on replaced with new version.
    LPTSTR lptszTmp = new TCHAR[STR_LEN_64];

    // Make sure the name isn't so long as to over-write the buffer!
    if( GetItemText(hListCtrl, (BYTE)*pnItem, DEVICE_COLUMN, lptszTmp, STR_LEN_64) > 60 )
    {
        lptszTmp[60] = lptszTmp[61] = lptszTmp[62] = TEXT('.');
        lptszTmp[63] = TEXT('\0');
    }

    LPTSTR pszMsg    = new TCHAR[MAX_STR_LEN];
    ASSERT (pszMsg);           

    wsprintf( pszMsg, pszTitle, lptszTmp);

    if( lptszTmp )
        delete[] (lptszTmp);

    VERIFY(LoadString(ghInstance, IDS_GEN_AREYOUSURE_TITLE, pszTitle, STR_LEN_64));

    BOOL bRet = (BOOL)(IDYES == MessageBox(GetFocus(), pszMsg, pszTitle, MB_ICONQUESTION | MB_YESNO | MB_APPLMODAL));

    if( pszMsg )      delete[] (pszMsg);
    if( pszTitle )   delete[] (pszTitle);

    if( bRet )
    {
        HRESULT hr;

        // Check for privileges!
        if( SUCCEEDED(hr = pDIJoyConfig->Acquire()) )
        {
            char nIndex = (char)GetItemData(hListCtrl, (BYTE)*pnItem);

            // Set the hour glass
            SetCursor(LoadCursor(NULL, IDC_WAIT));

            // Verify that you can delete the Config before you release the interface pointers!
            if( SUCCEEDED(hr = pDIJoyConfig->DeleteConfig(pAssigned[nIndex]->ID)) )
            {
                // make sure VJOYD is initialized
                if( !(nFlags & ON_NT) )
                    VERIFY (SUCCEEDED(pDIJoyConfig->SendNotify()));

                ::SendMessage(hListCtrl, LVM_DELETEITEM, (WPARAM)(int)*pnItem, 0);

                // Move the last assigned to the hole... if there is one!
                if( nIndex != (nAssigned-1) )
                {
                    // Before you move the tail to the hole, 
                    // Release() the interfaces at the hole!
                    pAssigned[nIndex]->fnDeviceInterface->Unacquire();
                    pAssigned[nIndex]->fnDeviceInterface->Release();

                    // Move the tail to the hole.
                    CopyMemory(pAssigned[nIndex], pAssigned[nAssigned-1], sizeof (JOY));

                    pAssigned[nAssigned-1]->fnDeviceInterface = 0;

                    // Don't forget to set the index in the item data!
                    SetItemData(hListCtrl, nItem, nIndex);

                    // Assign the tail to the hole so it gets deleted!
                    nIndex = nAssigned-1;

                    // Don't forget to set the index in the item data!
                    // QZheng: This line is very wrong!!!
                    //SetItemData(hListCtrl, (BYTE)*pnItem, nIndex);

                }

                // delete the memory...
                if( pAssigned[nIndex] )
                {
                    delete (pAssigned[nIndex]);
                    pAssigned[nIndex] = 0;
                }

                // Set the focus before you corrupt iItem
                SetListCtrlItemFocus(hListCtrl, nIndex);

                pDIJoyConfig->SendNotify();  //do more to make sure

                pDIJoyConfig->Unacquire();


                // dec nAssigned
                nAssigned--;

                // if there's no items, tell iItem about it!
                if( nAssigned == 0 )
                    *pnItem = NO_ITEM;
            } else if( hr == DIERR_UNSUPPORTED )
            {
                Error((short)IDS_GEN_AREYOUSURE_TITLE, (short)IDS_GEN_NO_REMOVE_USB);
            }

            // Set the hour glass
            SetCursor(LoadCursor(NULL, IDC_ARROW));
        }
    }
    return(bRet);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    DIEnumJoyTypeProc( LPCWSTR pwszTypeName, LPVOID pvRef )
//
// PARAMETERS:  LPCWSTR pwszTypeName - Type name of the device enumerated
//                  LPVOID pvRef            - 
//
// PURPOSE:     To Enumerate the types of devices associated with this system
//
// RETURN:      TRUE if successfull, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK DIEnumJoyTypeProc( LPCWSTR pwszTypeName, LPVOID pvRef )
{
    // Type info
    LPDIJOYTYPEINFO_DX5 lpdiJoyInfo = (LPDIJOYTYPEINFO_DX5)_alloca(sizeof(DIJOYTYPEINFO_DX5));
    ASSERT (lpdiJoyInfo);

    ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO_DX5));

    lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

    // populate the Type Info                                         
    switch( pDIJoyConfig->GetTypeInfo(pwszTypeName, (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_REGHWSETTINGS) )
    {
    // errors to continue with...
    case DIERR_NOTFOUND:
        TRACE(TEXT("JOY.CPL: GetTypeInfo returned DIERR_NOTFOUND for type %s!\n"), pwszTypeName);
        return(DIENUM_CONTINUE);

        // errors to stop with...
    case DIERR_INVALIDPARAM:
        TRACE(TEXT("JOY.CPL: GetTypeInfo returned DIERR_INVALIDPARAM!\n"));
    case DIERR_NOMOREITEMS:
        return(DIENUM_STOP);
    }


    // a quick check to make sure we don't have the infamous array out of bounds problem!
#ifndef _UNICODE
    if( nGameportDriver > MAX_GLOBAL_PORT_DRIVERS-1 )
    {
    #ifdef DEBUG
        OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: DIEnumJoyTypeProc: Global Gameport Drivers have exceeded MAX_GLOBAL_PORT_DRIVERS!\n"));
    #endif
        return(DIENUM_STOP);
    }
#endif

    if( nGameportBus > MAX_BUSSES-1 )
    {
#ifdef DEBUG
        OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: DIEnumJoyTypeProc: Enumerated Gameport busses have exceeded MAX_BUSSES!\n"));
#endif // _DEBUG
        return(DIENUM_STOP);
    }

    if( nGamingDevices > MAX_DEVICES-1 )
    {
#ifdef DEBUG
        OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: DIEnumJoyTypeProc: Enumerated Gameport busses have exceeded MAX_DEVICES!\n"));
#endif // _DEBUG
        return(DIENUM_STOP);
    }

    // check to see if it's a global port driver
#ifndef _UNICODE
    if( lpdiJoyInfo->hws.dwFlags & JOY_HWS_ISGAMEPORTDRIVER )
    {
        if( pwszGameportDriverArray[nGameportDriver] )
            wcsncpy(pwszGameportDriverArray[nGameportDriver], pwszTypeName, wcslen(pwszTypeName)+1);
        else
            pwszGameportDriverArray[nGameportDriver] = _wcsdup(pwszTypeName);
        nGameportDriver++;
    } else
#endif // _UNICODE
        if( lpdiJoyInfo->hws.dwFlags & JOY_HWS_ISGAMEPORTBUS )
    {
        if( pwszGameportBus[nGameportBus] )
            wcscpy(pwszGameportBus[nGameportBus], pwszTypeName);
        else
            pwszGameportBus[nGameportBus] = _wcsdup(pwszTypeName);
        nGameportBus++;
    } else
    {
        if( !(lpdiJoyInfo->hws.dwFlags & JOY_HWS_AUTOLOAD) )
        {
            // it's a standard gaming device
            if( pwszTypeArray[nGamingDevices] )
                wcsncpy(pwszTypeArray[nGamingDevices], pwszTypeName, wcslen(pwszTypeName)+1);
            else
                pwszTypeArray[nGamingDevices] = _wcsdup(pwszTypeName);
            nGamingDevices++;
        }
    }
    return(DIENUM_CONTINUE);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    DIEnumDevicesProc(LPDIDEVICEINSTANCE lpDeviceInst, LPVOID lpVoid)
//
// PARAMETERS:  LPDIDEVICEINSTANCE lpDeviceInst     - Device Instance
//                  LPVOID lpVoid                           -
//
// PURPOSE:     To Enumerate the devices associated with this system
//
// RETURN:      TRUE if successfull, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK DIEnumDevicesProc(LPDIDEVICEINSTANCE lpDeviceInst, LPVOID lpVoid)
{
    LPDIRECTINPUTDEVICE  pdiDevTemp;

    pDIJoyConfig->Acquire();

    // First Create the device
    if( SUCCEEDED(lpDIInterface->CreateDevice(lpDeviceInst->guidInstance, &pdiDevTemp, 0)) )
    {
        PJOY pNewJoy = new JOY;
        ASSERT (pNewJoy);

        // Query for a device2 object
        if( FAILED(pdiDevTemp->QueryInterface(IID_IDirectInputDevice2, (LPVOID*)&pNewJoy->fnDeviceInterface)) )
        {
#ifdef _DEBUG
            OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: DIEnumDevicesProc: QueryInterface failed!\n"));
#endif
            // release the temporary object
            pdiDevTemp->Release();
            return(FALSE);
        }

        DIPROPDWORD *pDIPropDW = new (DIPROPDWORD);
        ASSERT (pDIPropDW);

        ZeroMemory(pDIPropDW, sizeof(DIPROPDWORD));

        pDIPropDW->diph.dwSize       = sizeof(DIPROPDWORD);
        pDIPropDW->diph.dwHeaderSize = sizeof(DIPROPHEADER);
        pDIPropDW->diph.dwHow        = DIPH_DEVICE;

        // Get the device ID
        VERIFY (SUCCEEDED(pdiDevTemp->GetProperty(DIPROP_JOYSTICKID, &pDIPropDW->diph)));

        // release the temporary object
        pdiDevTemp->Release();

        pNewJoy->ID = (char)pDIPropDW->dwData;

        if( pDIPropDW )
            delete (pDIPropDW);

        // Get the Type name
        LPDIJOYCONFIG_DX5 lpDIJoyCfg = new (DIJOYCONFIG_DX5);
        ASSERT (lpDIJoyCfg);

        ZeroMemory(lpDIJoyCfg, sizeof(DIJOYCONFIG_DX5));

        lpDIJoyCfg->dwSize = sizeof(DIJOYCONFIG_DX5);

        VERIFY (SUCCEEDED(pDIJoyConfig->GetConfig(pNewJoy->ID, (LPDIJOYCONFIG)lpDIJoyCfg, DIJC_REGHWCONFIGTYPE | DIJC_CALLOUT)));

        // Get the clsidConfig
        LPDIJOYTYPEINFO lpDIJoyType = new (DIJOYTYPEINFO);
        ASSERT(lpDIJoyType);

        ZeroMemory(lpDIJoyType, sizeof(DIJOYTYPEINFO));

        lpDIJoyType->dwSize = sizeof(DIJOYTYPEINFO);

        VERIFY (SUCCEEDED(pDIJoyConfig->GetTypeInfo(lpDIJoyCfg->wszType, (LPDIJOYTYPEINFO)lpDIJoyType, DITC_CLSIDCONFIG | DITC_REGHWSETTINGS | DITC_FLAGS1 ))); 

        if( lpDIJoyCfg )
            delete (lpDIJoyCfg);

        // if NULL, Leave as default.
        if( !IsEqualIID(lpDIJoyType->clsidConfig, GUID_NULL) ) {
            pNewJoy->fHasOemSheet = TRUE;
            if( !(lpDIJoyType->dwFlags1 & JOYTYPE_DEFAULTPROPSHEET) ) {
                pNewJoy->clsidPropSheet = lpDIJoyType->clsidConfig;
            }
        } else {
            pNewJoy->fHasOemSheet = FALSE;
        }

        // Assign the number of buttons!
        pNewJoy->nButtons = (BYTE)(lpDIJoyType->hws.dwNumButtons);

        if( lpDIJoyType )
            delete (lpDIJoyType);

        // Set it's format!!!
        if( SUCCEEDED(pNewJoy->fnDeviceInterface->SetDataFormat(&c_dfDIJoystick)) )
        {
            // Set it's Cooperative Level!
            if( FAILED(pNewJoy->fnDeviceInterface->SetCooperativeLevel(GetParent((HWND)GetParent(hListCtrl)), DISCL_NONEXCLUSIVE | DISCL_BACKGROUND)) )
            {
#ifdef _DEBUG
                OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: DIEnumDevicesProc: SetCooperativeLevel Failed!\n"));
#endif
            }
        }

        // Add the item to the tree!
        pAssigned[nAssigned] = pNewJoy;

        // If you're on the General page!
        if( nFlags & ON_PAGE )
        {
            // add to tree                                              
            LVITEM lvItem = {LVIF_TEXT | LVIF_PARAM, nAssigned, 0, 0, 0, lpDeviceInst->tszInstanceName, lstrlen(lpDeviceInst->tszInstanceName), 0, (LPARAM)nAssigned, 0};
            ::SendMessage(hListCtrl, LVM_INSERTITEM, 0, (LPARAM) (const LPLVITEM)&lvItem);
            //InsertItem(hListCtrl, lpDeviceInst->tszInstanceName, nAssigned);

            TCHAR sz[STR_LEN_32];
            VERIFY(LoadString(ghInstance, IDS_GEN_STATUS_UNKNOWN, (LPTSTR)&sz, STR_LEN_32));

            SetItemText(hListCtrl, nAssigned, STATUS_COLUMN, sz);
        }

        // Increment the array counter!
        nAssigned++;
        if( nAssigned == nTargetAssigned )
        {
            /*
             *  A new device arrived so assume there's no 
             *  longer any point in checking on the timer.
             */
            nTargetAssigned = (BYTE)-1;
            nReEnum = 0;
        }

    }
    return(DIENUM_CONTINUE);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    ClearArrays ( void )
//
// PARAMETERS:  
//                  
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
void ClearArrays( void )
{
#ifndef _UNICODE
    while( nGameportDriver )
    {
        free(pwszGameportDriverArray[--nGameportDriver]);
        pwszGameportDriverArray[nGameportDriver] = L'\0';
    }    

#endif // _UNICODE
    while( nGamingDevices )
    {
        free(pwszTypeArray[--nGamingDevices]);
        pwszTypeArray[nGamingDevices] = L'\0';
    }  

    while( nGameportBus )
    {
        free(pwszGameportBus[--nGameportBus]);
        pwszGameportBus[nGameportBus] = L'\0';
        memset( &guidOccupied[nGameportBus], 0, sizeof(GUID) );
    }   
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    UpdateListCtrl( HWND hDlg )
//
//  PARAMETERS: HWND hDlg - Handle to window to update
//
// PURPOSE:     Refreshes enumerated device list
//
// RETURN:      TRUE if successfull, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
static void UpdateListCtrl( HWND hDlg )
{
    if( !(nFlags & ON_PAGE) )
        return;

    // Turn Redraw off here else it will flicker!
    ::SendMessage(hListCtrl, WM_SETREDRAW, (WPARAM)FALSE, 0);

    // delete all existing entries
    ::SendMessage(hListCtrl, LVM_DELETEALLITEMS, 0, 0);

    Enumerate( hDlg );

    // turn the flag off!
    if( nFlags & UPDATE_FOR_GEN )
        nFlags &= ~UPDATE_FOR_GEN;

    // Turn the redraw flag back on!
    ::SendMessage (hListCtrl, WM_SETREDRAW, (WPARAM)TRUE, 0);
    InvalidateRect(hListCtrl, NULL, TRUE);
}

//#ifdef _UNICODE
HRESULT Enumerate( HWND hDlg )
{
    nFlags |= UPDATE_ALL;

    // Clear pAssigned 
    while( nAssigned )
    {
        if( pAssigned[--nAssigned] )
        {
            delete (pAssigned[nAssigned]);

            pAssigned[nAssigned] = 0;
        }
    }

    // Enumerate the Joysticks and put them in the list...  | DIEDFL_INCLUDEPHANTOMS
#ifdef _UNICODE
    return(lpDIInterface->EnumDevices(DIDEVTYPE_JOYSTICK, (LPDIENUMDEVICESCALLBACK)DIEnumDevicesProc, (LPVOID)hDlg, 
                                      DIEDFL_ALLDEVICES ));
#else
    return(lpDIInterface->EnumDevices(DIDEVTYPE_JOYSTICK, (LPDIENUMDEVICESCALLBACK)DIEnumDevicesProc, (LPVOID)hDlg, 
                                      DIEDFL_ALLDEVICES | DIEDFL_INCLUDEPHANTOMS));
#endif                                      
}
/*
#else
HRESULT Enumerate( HWND hDlg )
{
   // Clear pAssigned 
    while (nAssigned)
    {
    if (pAssigned[--nAssigned])
        {
        delete (pAssigned[nAssigned]);

            pAssigned[nAssigned] = 0;
        }
    }

    DIJOYCONFIG *pJoyConfig = new DIJOYCONFIG;
    ASSERT (pJoyConfig);

    pJoyConfig->dwSize = sizeof (DIJOYCONFIG);

    LPDIJOYTYPEINFO pdiJoyTypeInfo = new DIJOYTYPEINFO;
    ASSERT (pdiJoyTypeInfo);

    pdiJoyTypeInfo->dwSize = sizeof (DIJOYTYPEINFO);

    HRESULT hr;

    // find and assign ID's  
    for (BYTE n = 0; n < NUMJOYDEVS; n++)
    {
        hr = pDIJoyConfig->GetConfig(n, pJoyConfig, DIJC_REGHWCONFIGTYPE | DIJC_GUIDINSTANCE);

      if (hr == S_OK)
         AddListCtrlItem(n, pJoyConfig);
    }

    // clean up, clean up... everybody do your share!
    if (pJoyConfig)   delete   (pJoyConfig);
    if (pdiJoyTypeInfo) delete    (pdiJoyTypeInfo);

    return hr;
}

BOOL AddListCtrlItem(BYTE nItemID, LPDIJOYCONFIG pJoyConfig)
{
   LPDIRECTINPUTDEVICE  pdiDevTemp;

   pDIJoyConfig->Acquire();

   // First Create the device
   if (SUCCEEDED(lpDIInterface->CreateDevice(pJoyConfig->guidInstance, &pdiDevTemp, 0)))
   {
       PJOY pNewJoy = new JOY;
    ASSERT (pNewJoy);

      // Query for a device2 object
      if (FAILED(pdiDevTemp->QueryInterface(IID_IDirectInputDevice2, (LPVOID*)&pNewJoy->fnDeviceInterface)))
      {
#ifdef _DEBUG
         OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: DIEnumDevicesProc: QueryInterface failed!\n"));
#endif
         // release the temporary object
         pdiDevTemp->Release();
         return FALSE;
      }

      DIPROPDWORD *pDIPropDW = new (DIPROPDWORD);
      ASSERT (pDIPropDW);

      ZeroMemory(pDIPropDW, sizeof(DIPROPDWORD));

    pDIPropDW->diph.dwSize       = sizeof(DIPROPDWORD);
       pDIPropDW->diph.dwHeaderSize = sizeof(DIPROPHEADER);
    pDIPropDW->diph.dwHow        = DIPH_DEVICE;

      // Get the device ID
      VERIFY (SUCCEEDED(pdiDevTemp->GetProperty(DIPROP_JOYSTICKID, &pDIPropDW->diph)));

      // release the temporary object
      pdiDevTemp->Release();

      pNewJoy->ID = (char)pDIPropDW->dwData;

      if (pDIPropDW)
         delete (pDIPropDW);

      // Get the Type name
      LPDIJOYCONFIG_DX5 lpDIJoyCfg = new (DIJOYCONFIG_DX5);
      ASSERT (lpDIJoyCfg);

      ZeroMemory(lpDIJoyCfg, sizeof(DIJOYCONFIG_DX5));

      lpDIJoyCfg->dwSize = sizeof(DIJOYCONFIG_DX5);

      VERIFY (SUCCEEDED(pDIJoyConfig->GetConfig(pNewJoy->ID, (LPDIJOYCONFIG)lpDIJoyCfg, DIJC_REGHWCONFIGTYPE)));
      
      // Get the clsidConfig
      LPDIJOYTYPEINFO_DX5 lpDIJoyType = new (DIJOYTYPEINFO_DX5);
      ASSERT(lpDIJoyType);

      ZeroMemory(lpDIJoyType, sizeof(DIJOYTYPEINFO_DX5));

      lpDIJoyType->dwSize = sizeof(DIJOYTYPEINFO_DX5);

      VERIFY (SUCCEEDED(pDIJoyConfig->GetTypeInfo(lpDIJoyCfg->wszType, (LPDIJOYTYPEINFO)lpDIJoyType, DITC_CLSIDCONFIG))); 
      
    // if NULL, Leave as default.
       if (!IsEqualIID(lpDIJoyType->clsidConfig, GUID_NULL))
           pNewJoy->clsidPropSheet = lpDIJoyType->clsidConfig;

      if (lpDIJoyType)
         delete (lpDIJoyType);

      // Set it's format!!!
      if (FAILED(pNewJoy->fnDeviceInterface->SetDataFormat(&c_dfDIJoystick)))
        {
#ifdef _DEBUG
         OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: DIEnumDevicesProc: SetDataFormat() Failed!\n"));
#endif
        }

      // Set it's Cooperative Level!
      if (FAILED(pNewJoy->fnDeviceInterface->SetCooperativeLevel(GetParent((HWND)GetParent(hListCtrl)), DISCL_NONEXCLUSIVE | DISCL_BACKGROUND)))
        {
#ifdef _DEBUG
         OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: DIEnumDevicesProc: SetCooperativeLevel Failed!\n"));
#endif
        }

      // Add the item to the tree!
      pAssigned[nAssigned] = pNewJoy;

        // Get the number of buttons!
        LPDIDEVCAPS_DX3 lpDIDevCaps = new (DIDEVCAPS_DX3);
        ASSERT (lpDIDevCaps);

        ZeroMemory(lpDIDevCaps, sizeof(DIDEVCAPS_DX3));
       lpDIDevCaps->dwSize = sizeof(DIDEVCAPS_DX3);

        pAssigned[nAssigned]->fnDeviceInterface->Acquire();

      if (SUCCEEDED(pAssigned[nAssigned]->fnDeviceInterface->GetCapabilities((LPDIDEVCAPS)lpDIDevCaps)))
            pAssigned[nAssigned]->nButtons = (BYTE)lpDIDevCaps->dwButtons;

        if (lpDIDevCaps)
            delete (lpDIDevCaps);

        // If you're on the General page!
        if (nFlags & ON_PAGE)
        {
        DIPROPSTRING *pDIPropStr = new (DIPROPSTRING);
           ASSERT (pDIPropStr);
        
           ZeroMemory(pDIPropStr, sizeof(DIPROPSTRING));

        pDIPropStr->diph.dwSize       = sizeof(DIPROPSTRING);
           pDIPropStr->diph.dwHeaderSize = sizeof(DIPROPHEADER);
          pDIPropStr->diph.dwHow        = DIPH_DEVICE;
            
            pAssigned[nAssigned]->fnDeviceInterface->GetProperty(DIPROP_INSTANCENAME, &pDIPropStr->diph);

            USES_CONVERSION;

        // add to tree                                              
            LVITEM lvItem = {LVIF_TEXT | LVIF_PARAM, nAssigned, 0, 0, 0, W2A(pDIPropStr->wsz), lstrlen(W2A(pDIPropStr->wsz)), 0, (LPARAM)nAssigned, 0};
            ::SendMessage(hListCtrl, LVM_INSERTITEM, 0, (LPARAM) (const LPLVITEM)&lvItem);

            TCHAR sz[STR_LEN_32];
           VERIFY(LoadString(ghInstance, IDS_GEN_STATUS_UNKNOWN, (LPTSTR)&sz, STR_LEN_32));

        SetItemText(hListCtrl, nAssigned, STATUS_COLUMN, sz);

            if (pDIPropStr)
                delete (pDIPropStr);
        }

      // Increment the array counter!
      nAssigned++;
   }

   return TRUE;
}

#endif
*/

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:  SetActive ( HWND hDlg )   
//
// PARAMETERS:  
//                  
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
BOOL SetActive(HWND hDlg)
{
    // restore selection focus to nItemSelected
    SetListCtrlItemFocus(hListCtrl, (BYTE)iItem);

    BYTE i = (BYTE)::SendMessage(hListCtrl, LVM_GETITEMCOUNT, 0, 0);

    // Acquire All Devices that are Attached!!!
    char nIndex;

    while( i-- )
    {
        // get joystick config of item
        nIndex = (char)GetItemData(hListCtrl, i);

        if( pAssigned[nIndex]->nStatus & JOY_US_PRESENT )
            pAssigned[nIndex]->fnDeviceInterface->Acquire();
    }

    // create timer
    SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);

    UpdateButtonState( hDlg );

    return(TRUE);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    MsgSubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
// PARAMETERS:  HWND   hWnd
//             UINT   uMsg
//             WPARAM wParam
//             LPARAM lParam
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI MsgSubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Only do this if you are ON THIS PAGE!
    if( nFlags & ON_PAGE )
    {
        if( uMsg == JoyCfgChangedMsg )
        {
            if( !(nFlags & BLOCK_UPDATE) )
            {
                // kill status timer
                KillTimer(hWnd, ID_MYTIMER);
                nFlags |= UPDATE_ALL;
                ClearArrays();
                pDIJoyConfig->EnumTypes((LPDIJOYTYPECALLBACK)DIEnumJoyTypeProc, NULL);
                UpdateListCtrl(hWnd);
                SetActive(hWnd);
            }
        }
    }

    return(BOOL)CallWindowProc(fpMainWindowProc, hWnd, uMsg, wParam, lParam);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    Error ( short nTitleID, short nMsgID )
//
// PARAMETERS:  nTitleID    - Resource ID for Message Title
//                  nMsgID  - Resource ID for Message
//
// PURPOSE:     Prompt user when error occurs
//
// RETURN:      TRUE
///////////////////////////////////////////////////////////////////////////////
void Error(short nTitleID, short nMsgID)
{
    LPTSTR lptTitle = new TCHAR[STR_LEN_64];
    ASSERT (lptTitle);

    if( LoadString(ghInstance, nTitleID, lptTitle, STR_LEN_64) )
    {
        LPTSTR lptMsg = new TCHAR[MAX_STR_LEN];
        ASSERT (lptMsg);

        if( LoadString(ghInstance, nMsgID, lptMsg, MAX_STR_LEN) )
            MessageBox(NULL, lptMsg, lptTitle, MB_ICONHAND | MB_OK | MB_APPLMODAL);

        if( lptMsg )
            delete[] (lptMsg);
    }

    if( lptTitle )
        delete[] (lptTitle);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    MoveOK ( HWND  hParentWnd )
//
// PARAMETERS:  
//                  
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
void MoveOK(HWND hParentWnd)
{
    // Hide the Cancel and move the OK...
    HWND hCtrl = GetDlgItem(hParentWnd, IDCANCEL);

    // if there is no IDCANCEL, we've been here before!
    if( hCtrl )
    {
        RECT rc;
        GetWindowRect(hCtrl, &rc);

        DestroyWindow(hCtrl);

        //POINT pt = {rc.left, rc.top};

        //ScreenToClient(hParentWnd, &pt);

        // This should take care of Mirroring and work for normal windows
        MapWindowPoints(NULL, hParentWnd, (LPPOINT)&rc, 2);

        hCtrl = GetDlgItem(hParentWnd, IDOK);
        ASSERT(hCtrl);

        //SetWindowPos(hCtrl, NULL, pt.x, pt.y, NULL, NULL, SWP_NOSIZE | SWP_NOZORDER);
        SetWindowPos(hCtrl, NULL, rc.left, rc.top, NULL, NULL, SWP_NOSIZE | SWP_NOZORDER);

        LPTSTR lpszDone = new TCHAR[12];
        ASSERT (lpszDone);

        // Used to be IDS_DONE, but we changed it from DONE to OK
        VERIFY(LoadString(ghInstance, IDS_GEN_STATUS_OK, lpszDone, 12));
        ::SendMessage(hCtrl, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)lpszDone);

        if( lpszDone )
            delete[] (lpszDone);
    }
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    UpdateButtonState ( HWND hDlg )
//
// PARAMETERS:  
//                  
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
void UpdateButtonState( HWND hDlg )
{
    PostDlgItemEnableWindow(hDlg, IDC_BTN_REMOVE,      (BOOL)nAssigned);
    PostDlgItemEnableWindow(hDlg, IDC_BTN_PROPERTIES, (BOOL)nAssigned);
}

#ifdef WINNT
///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    RunWDMJoy ( void )
//
// PURPOSE:     Run wdmjoy.inf to install 
//                       
///////////////////////////////////////////////////////////////////////////////
void RunWDMJOY( void )
{
    //Check if we have already placed the first value
    //HKLM,SYSTEM\CurrentControlSet\Control\MediaProperties\PrivateProperties\Joystick\OEM\VID_045E&PID_01F0
    HKEY hKey;

    long lTest = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    REGSTR_PATH_JOYOEM TEXT("\\VID_045E&PID_01F0"),
                    0,
                    KEY_READ,
                    &hKey);
    if (lTest == ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return;
    }


    LPTSTR lpszWDMJoy = new (TCHAR[STR_LEN_64]);
    ASSERT (lpszWDMJoy);

    // Check to see if the file is present
    WIN32_FIND_DATA findData;
    
    BYTE nLen = (BYTE)GetWindowsDirectory(lpszWDMJoy, STR_LEN_64);
    VERIFY(LoadString(ghInstance, IDS_WDMJOY_INF, &lpszWDMJoy[nLen], STR_LEN_64-nLen));

    HANDLE hFind = FindFirstFile(lpszWDMJoy, &findData);

    // If you've found one... run it!
    if( hFind != INVALID_HANDLE_VALUE )
    {
        LPTSTR lpStr = new (TCHAR[MAX_STR_LEN]);
        ASSERT (lpStr);

        // Copy the Windows directory to the buffer!
        _tcsncpy(lpStr, lpszWDMJoy, nLen+1);

        if( LoadString(ghInstance, IDS_WDMJOY, &lpStr[nLen], MAX_STR_LEN-nLen) )
        {
            // Put IDS_WDMJOY_INF on the end of the string!
            _tcscpy(&lpStr[lstrlen(lpStr)], lpszWDMJoy);

            LPSTARTUPINFO psi = new (STARTUPINFO);
            ASSERT (psi);

            ZeroMemory(psi, sizeof(STARTUPINFO));

            psi->cb = sizeof(STARTUPINFO);

            LPPROCESS_INFORMATION ppi = new (PROCESS_INFORMATION);
            ASSERT (ppi);

            ZeroMemory(ppi, sizeof(PROCESS_INFORMATION));

            if( CreateProcess(0, lpStr, 0, 0, 0, 0, 0, 0, psi, ppi) )
            {
                CloseHandle(ppi->hThread);
                CloseHandle(ppi->hProcess);
            }
#ifdef _DEBUG
            else OutputDebugString(TEXT("JOY.CPL: CPANEL.CPP: RunWDMJoy: CreateProcess Failed!\n"));
#endif

            if( ppi )
                delete (ppi);

            if( psi )
                delete (psi);
        }

        if( lpStr )
            delete[] (lpStr);
    }

    FindClose(hFind);

    if( lpszWDMJoy )
        delete[] (lpszWDMJoy);
}
#endif

#ifdef _UNICODE
///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    RegisterForDevChange ( HWND hDlg, PVOID *hNoditfyDevNode )
//
// PARAMETERS:  
//                  
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
void RegisterForDevChange(HWND hDlg, PVOID *hNotifyDevNode)
{
    DEV_BROADCAST_DEVICEINTERFACE *pFilterData = new (DEV_BROADCAST_DEVICEINTERFACE);
    ASSERT (pFilterData);

    ZeroMemory(pFilterData, sizeof(DEV_BROADCAST_DEVICEINTERFACE));

    pFilterData->dbcc_size       = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    pFilterData->dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    pFilterData->dbcc_classguid  = GUID_CLASS_INPUT; 

    *hNotifyDevNode = RegisterDeviceNotification(hDlg, pFilterData, DEVICE_NOTIFY_WINDOW_HANDLE);

    if( pFilterData )
        delete (pFilterData);
}
#endif


// BEGINNING OF LIST CONTROL FUNCTIONS!

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    SetListCtrlItemFocus ( HWND hCtrl, BYTE nItem )
//
// PARAMETERS:  HWND hCtrl - Handle of ListControl to recieve the message
//                  BYTE nItem - Item to set focus to
//
// PURPOSE:     Set focus to item in list control
//
// RETURN:      NONE
///////////////////////////////////////////////////////////////////////////////
void SetListCtrlItemFocus ( HWND hCtrl, BYTE nItem )
{
    LPLVITEM plvItem = (LPLVITEM)_alloca(sizeof(LVITEM));
    ASSERT (plvItem);

    plvItem->lParam       = plvItem->iSubItem = plvItem->iImage = 
                            plvItem->cchTextMax = plvItem->iIndent  = 0;

    plvItem->mask         = LVIF_STATE;
    plvItem->iItem    = nItem;
    plvItem->state    = 
    plvItem->stateMask  = LVIS_FOCUSED | LVIS_SELECTED;
    plvItem->pszText      = NULL;

    ::SendMessage(hCtrl, LVM_SETITEM, 0, (LPARAM)(const LPLVITEM)plvItem);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    GetItemData(HWND hCtrl, BYTE nItem )
//
// PARAMETERS:  HWND hCtrl - Handle of ListControl to recieve the message
//                  
//                  BYTE nItem - Item to retrieve data from
// PURPOSE:     Retrieve the lower char of the item's data
//
// RETURN:      Item's data cast to a char
///////////////////////////////////////////////////////////////////////////////
DWORD GetItemData(HWND hCtrl, BYTE nItem )
{
    LPLVITEM plvItem = (LPLVITEM)_alloca(sizeof(LVITEM));
    ASSERT (plvItem);

    ZeroMemory(plvItem, sizeof(LVITEM));

    plvItem->mask  = LVIF_PARAM;
    plvItem->iItem = nItem;

    VERIFY(::SendMessage(hCtrl, LVM_GETITEM, 0, (LPARAM)(LPLVITEM)plvItem));

    return(DWORD)plvItem->lParam;
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    SetItemData(HWND hCtrl, BYTE nItem, DWORD dwFlag )
//
// PARAMETERS:  HWND hCtrl   - Handle of ListControl to recieve the message
//                  BYTE nItem   - Item to send data to
//                  DWORD dwFlag - DWORD to send to nItem
// PURPOSE:     Set the extra memory associated with nItem to dwFlag
//
// RETURN:      TRUE if Successful, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL  SetItemData(HWND hCtrl, BYTE nItem, DWORD dwFlag )
{
    LPLVITEM plvItem = (LPLVITEM)_alloca(sizeof(LVITEM));
    ASSERT (plvItem);

    ZeroMemory(plvItem, sizeof(LVITEM));

    plvItem->mask   = LVIF_PARAM;
    plvItem->iItem  = nItem;
    plvItem->lParam = dwFlag;

    return(BOOL)::SendMessage(hCtrl, LVM_SETITEM, 0, (LPARAM)(const LPLVITEM)plvItem);
}



///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    InsertColumn (HWND hCtrl, BYTE nColumn, short nStrID, short nWidth)
//
// PARAMETERS:  HWND hCtrl   - Handle of ListControl to recieve the message
//                  BYTE nColumn - Column to place string
//                  short nStrID -  Resource ID for string 
//                  short nWidth - Width of column
//
// PURPOSE:     Insert a column in a list control
//
// RETURN:      NONE
///////////////////////////////////////////////////////////////////////////////
void InsertColumn (HWND hCtrl, BYTE nColumn, USHORT nStrID, USHORT nWidth)
{
    // Allocate the structure
    LPLVCOLUMN plvColumn = (LPLVCOLUMN)_alloca(sizeof(LVCOLUMN));
    ASSERT (plvColumn);

    ZeroMemory(plvColumn, sizeof(LVCOLUMN));

    plvColumn->mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    plvColumn->fmt  = LVCFMT_CENTER;
    plvColumn->cx    = nWidth;

    plvColumn->pszText = (LPTSTR)_alloca(sizeof(TCHAR[STR_LEN_32]));
    ASSERT (plvColumn->pszText);

    plvColumn->cchTextMax = LoadString(ghInstance, nStrID, plvColumn->pszText, STR_LEN_32);

    ::SendMessage(hCtrl, LVM_INSERTCOLUMN, (WPARAM)(int)nColumn, (LPARAM)(const LPLVCOLUMN)plvColumn);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    SetItemText( HWND hCtrl, BYTE nItem, BYTE nSubItem, LPTSTR lpStr)
//
// PARAMETERS:  HWND hCtrl    - Handle of ListControl to recieve the message
//                  BYTE nItem    - Item to set
//                  BYTE nSubItem - SubItem to set
//                  LPTSTR lpStr  - String to set
//
// PURPOSE:     Set list control item text
//
// RETURN:      NONE
///////////////////////////////////////////////////////////////////////////////
void SetItemText( HWND hCtrl, BYTE nItem, BYTE nSubItem, LPTSTR lpStr)
{
    LPLVITEM plvItem = (LPLVITEM)_alloca(sizeof(LVITEM));
    ASSERT (plvItem);

    plvItem->lParam = plvItem->stateMask = plvItem->iImage  = 
                      plvItem->state  = plvItem->iIndent   = 0;

    plvItem->mask         = LVIF_TEXT;
    plvItem->iItem    = nItem;
    plvItem->iSubItem   = nSubItem;
    plvItem->cchTextMax = lstrlen(lpStr);
    plvItem->pszText      = lpStr;

    ::SendMessage(hCtrl, LVM_SETITEM, 0, (LPARAM)(const LPLVITEM)plvItem);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    GetItemText( HWND hCtrl, BYTE nItem, BYTE nSubItem, LPTSTR lpszBuff, BYTE nLen )
//
// PARAMETERS:  HWND hCtrl       - Handle of ListControl to recieve the message
//                  BYTE nItem       - Item to retrive text
//                  BYTE nSubItem    - SubItem to retrieve text
//                  LPTSTR lpszBuff - Buffer for retrieved text
//                  BYTE nLen        - Size of buffer
//
// PURPOSE:     Retrieve text from a list control
//
// RETURN:      length of retrieved string!
///////////////////////////////////////////////////////////////////////////////
BYTE GetItemText( HWND hCtrl, BYTE nItem, BYTE nSubItem, LPTSTR lpszBuff, BYTE nLen )
{
    LPLVITEM plvItem = (LPLVITEM)_alloca(sizeof(LVITEM));
    ASSERT (plvItem);

    plvItem->lParam =   plvItem->stateMask = plvItem->iImage  =  
                        plvItem->state  = plvItem->iIndent   = 0;

    plvItem->mask         = LVIF_TEXT;
    plvItem->iItem    = nItem;
    plvItem->iSubItem   = nSubItem;
    plvItem->pszText      = lpszBuff;
    plvItem->cchTextMax = nLen;

    return(BYTE)::SendMessage(hCtrl, LVM_GETITEMTEXT, (WPARAM)nItem, (LPARAM)(const LPLVITEM)plvItem);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    InsertItem(HWND hCtrl, LPTSTR lpszBuff )
//
// PARAMETERS:  HWND hCtrl       - Handle of ListControl to recieve the message
//                  BYTE nItem       - Item to retrive text
//                  LPTSTR lpszBuff - Text to be inserted
//
// PURPOSE:     Retrieve text from a list control
//
// RETURN:      NONE              BYTE nItem,
///////////////////////////////////////////////////////////////////////////////
BYTE InsertItem( HWND hCtrl, LPTSTR lpszBuff, BYTE nItem )
{
    LPLVITEM plvItem = (LPLVITEM)_alloca(sizeof(LVITEM));
    ASSERT (plvItem);

    plvItem->state = plvItem->stateMask = plvItem->iImage   = 
                     plvItem->iItem = plvItem->iIndent   = plvItem->iSubItem = 0;

    plvItem->mask         = LVIF_TEXT | LVIF_PARAM;
    plvItem->pszText      = lpszBuff;
    plvItem->cchTextMax = lstrlen(lpszBuff);
    plvItem->lParam       = ID_NONE | nItem;

    return(BYTE)::SendMessage(hCtrl, LVM_INSERTITEM, (WPARAM)0, (LPARAM)(const LPLVITEM)plvItem);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    Launch(HWND hWnd, BYTE nJoy, BYTE startpage)
//
// PARAMETERS:  HWND hWnd - Handle to Dialog
//                  BYTE nJoy - Index into pAssigned global array of assigned devices
//                  BYTE nStartPage - Page to show first
//
// PURPOSE:     
//           
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
HRESULT Launch(HWND hWnd, PJOY pJoy, BYTE nStartPage)
{
    HRESULT hresRet;
    
    ASSERT (::IsWindow(hWnd));

    if( nStartPage > MAX_PAGES )
        return(DIGCERR_STARTPAGETOOLARGE);

    LPCDIGAMECNTRLPROPSHEET fnInterface;    

/*  
#ifdef _UNICODE
    LPTSTR lpszWin32 = new (TCHAR[STR_LEN_64]);
    ASSERT (lpszWin32);

    _tcscpy(&lpszWin32[GetSystemDirectory(lpszWin32, STR_LEN_64)], TEXT("\\OLE32.DLL"));
                                                //TEXT("OLE32.DLL")
    HINSTANCE hOleInst = LoadLibrary(lpszWin32);

    if (lpszWin32)
        delete[] (lpszWin32);

    if (!hOleInst)
    {
        return E_NOINTERFACE;
    }
#endif
*/

    // Get the interface pointer if there is one!
    // This reduces the memory footprint of the CPL but takes a bit more time to 
    // launch the property sheet pages!
/*
#ifdef _UNICODE
    fnInterface = HasInterface(pJoy->clsidPropSheet, hOleInst);

    if (!fnInterface)
    {
        // If the propsheet is not mine, try mine!
        if (!IsEqualIID(pJoy->clsidPropSheet, CLSID_LegacyServer))
            fnInterface = HasInterface(CLSID_LegacyServer, hOleInst);
    }
    
    FreeLibrary(hOleInst);
#else
*/
    HRESULT hr;

    //if( SUCCEEDED(hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED| COINIT_SPEED_OVER_MEMORY)) )
    // OLE32 on Win95 does not have CoInitializeEx. 
    if( SUCCEEDED(hr = CoInitialize(NULL)) )
    {
        IClassFactory* ppv_classfactory;

        if( SUCCEEDED(hr = CoGetClassObject(pJoy->clsidPropSheet, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **)&ppv_classfactory)) )
        {
            VERIFY(SUCCEEDED(ppv_classfactory->CreateInstance(NULL, IID_IDIGameCntrlPropSheet, (LPVOID *)&fnInterface)));

            ppv_classfactory->Release();
        } else {
            fnInterface = 0;
        }
    } else {
        fnInterface = 0;
    }

//#endif

    // By this point, you've tried twice (possibly)...
    // if you don't have an interface by this point... 
    // QUIT!
    if( !fnInterface )
    {
        Error((short)IDS_INTERNAL_ERROR, (short)IDS_NO_DIJOYCONFIG);
        return(E_NOINTERFACE);
    }

    // here's where we are sending the property sheet an ID describing the location of the installed device!
    fnInterface->SetID(pJoy->ID);

    LPDIGCSHEETINFO pServerSheet;

    // Get the property sheet info from the server
    if( FAILED(fnInterface->GetSheetInfo(&pServerSheet)) )
    {
        TRACE(TEXT("JOY.CPL: CPANEL.CPP: Launch: GetSheetInfo Failed!\n"));
        return(E_FAIL);
    }

    // test to make sure the number of pages is reasonable
    if( pServerSheet->nNumPages == 0 )
        return(DIGCERR_NUMPAGESZERO);
    else if( (pServerSheet->nNumPages > MAX_PAGES) ||   (pServerSheet->nNumPages < nStartPage) )
        return(DIGCERR_NUMPAGESTOOLARGE);

    LPDIGCPAGEINFO   pServerPage;

    // step 2 : get the information for all the pages from the server
    if( FAILED(fnInterface->GetPageInfo(&pServerPage)) )
    {
        TRACE(TEXT("JOY.CPL: CPANEL.CPP: Launch: GetPageInfo Failed!\n"));
        return(E_FAIL);
    }


    // Allocate Memory for the pages!
    HPROPSHEETPAGE *pPages = new (HPROPSHEETPAGE[pServerSheet->nNumPages]);
    ASSERT (pPages);

    ZeroMemory(pPages, sizeof(HPROPSHEETPAGE)*pServerSheet->nNumPages);

    if( !pPages ) return(E_OUTOFMEMORY);

    // Allocate Memory for the header!
    LPPROPSHEETHEADER   ppsh = new (PROPSHEETHEADER);
    ASSERT (ppsh);

    ZeroMemory(ppsh, sizeof(PROPSHEETHEADER));

    ppsh->dwSize        = sizeof(PROPSHEETHEADER);
    ppsh->hwndParent    = hWnd;
    ppsh->hInstance = pServerPage[0].hInstance;

    if( pServerSheet->fSheetIconFlag )
    {
        if( pServerSheet->lpwszSheetIcon )
        {
            // check to see if you are an INT or a WSTR
            if( HIWORD((INT_PTR)pServerSheet->lpwszSheetIcon) )
            {
                // You are a string!
#ifdef _UNICODE        
                ppsh->pszIcon   = pServerSheet->lpwszSheetIcon;
#else
                USES_CONVERSION;
                ppsh->pszIcon   = W2A(pServerSheet->lpwszSheetIcon);
#endif
            } else ppsh->pszIcon = (LPCTSTR)(pServerSheet->lpwszSheetIcon);

            ppsh->dwFlags =    PSH_USEICONID;
        } else return(DIGCERR_NOICON);
    }

    // do we have a sheet caption ?
    if( pServerSheet->lpwszSheetCaption )
    {
#ifdef _UNICODE
        ppsh->pszCaption    = pServerSheet->lpwszSheetCaption;
#else
        USES_CONVERSION;
        ppsh->pszCaption    = W2A(pServerSheet->lpwszSheetCaption);
#endif
        ppsh->dwFlags |= PSH_PROPTITLE;
    }

    ppsh->nPages        = pServerSheet->nNumPages;  
    ppsh->nStartPage    = nStartPage;

    // set the property pages inofrmation into the header
    ppsh->phpage = pPages;


    // OK, sheet stuff is done... now, time to do the pages!

#ifndef _UNICODE
    USES_CONVERSION;
#endif

    LPPROPSHEETPAGE lpPropPage = new (PROPSHEETPAGE);
    ASSERT(lpPropPage);

    ZeroMemory(lpPropPage, sizeof(PROPSHEETPAGE));

    lpPropPage->dwSize    = sizeof(PROPSHEETPAGE);

    //   3.2 Now proceed to fill up each page
    BYTE nIndex = 0;
    do
    {
        // Assign the things that there are not questionable
        lpPropPage->lParam   = pServerPage[nIndex].lParam;
        lpPropPage->hInstance = pServerPage[nIndex].hInstance;

        // Add the title...
        if( pServerPage[nIndex].lpwszPageTitle )
        {
            lpPropPage->dwFlags = PSP_USETITLE; 

            // Check to see if you are a String!!!
            if( HIWORD((INT_PTR)pServerPage[nIndex].lpwszPageTitle) )
            {
#ifdef _UNICODE
                lpPropPage->pszTitle = pServerPage[nIndex].lpwszPageTitle;
#else
                lpPropPage->pszTitle = W2A(pServerPage[nIndex].lpwszPageTitle);
#endif
            } else lpPropPage->pszTitle = (LPTSTR)pServerPage[nIndex].lpwszPageTitle;
        } else lpPropPage->pszTitle = NULL;

        // if icon is required go ahead and add it.
        if( pServerPage[nIndex].fIconFlag )
        {
            lpPropPage->dwFlags |= PSP_USEICONID;

            // Check to see if you are an INT or a String!
            if( HIWORD((INT_PTR)pServerPage[nIndex].lpwszPageIcon) )
            {
                // You're a string!!!
#ifdef _UNICODE
                lpPropPage->pszIcon = pServerPage[nIndex].lpwszPageIcon;
#else
                lpPropPage->pszIcon = W2A(pServerPage[nIndex].lpwszPageIcon);
#endif
            } else lpPropPage->pszIcon = (LPCTSTR)(pServerPage[nIndex].lpwszPageIcon);

        }

        // if a pre - post processing call back proc is required go ahead and add it
        if( pServerPage[nIndex].fProcFlag )
        {
            if( pServerPage[nIndex].fpPrePostProc )
            {
                lpPropPage->dwFlags |= PSP_USECALLBACK;
                lpPropPage->pfnCallback = (LPFNPSPCALLBACK) pServerPage[nIndex].fpPrePostProc;
            } else return(DIGCERR_NOPREPOSTPROC);
        }

        // and the essential "dialog" proc
        if( pServerPage[nIndex].fpPageProc )
            lpPropPage->pfnDlgProc = pServerPage[nIndex].fpPageProc;
        else return(DIGCERR_NODLGPROC);


        // Assign the Dialog Template!
        if( HIWORD((INT_PTR)pServerPage[nIndex].lpwszTemplate) )
        {
#ifdef _UNICODE
            lpPropPage->pszTemplate = pServerPage[nIndex].lpwszTemplate;
#else
            lpPropPage->pszTemplate = W2A(pServerPage[nIndex].lpwszTemplate);
#endif
        } else lpPropPage->pszTemplate = (LPTSTR)pServerPage[nIndex].lpwszTemplate;

        pPages[nIndex++] = CreatePropertySheetPage(lpPropPage);
    }   while( nIndex < pServerSheet->nNumPages );

    if( lpPropPage )
        delete (lpPropPage);

    // step 5 : launch modal property sheet dialog
    hresRet = (HRESULT)PropertySheet(ppsh);

    if( pPages )
        delete[] (pPages);

    if( ppsh )
        delete (ppsh);

    if( fnInterface )
        fnInterface->Release();

    CoFreeUnusedLibraries();  //to free gcdef.dll now

//#ifndef _UNICODE
    // Let COM go... on Memphis!
    CoUninitialize();

    ::PostMessage(hWnd, WM_COMMAND, (WPARAM)IDC_BTN_REFRESH, 0);

//#endif

    // step 7 : return success / failure code back to the caller
    return(hresRet);
}

/*
#ifdef _UNICODE
//////////////////////////////////////////////////////////////////////
// LPCDIGAMECNTRLPROPSHEET HasInterface(REFCLSID refCLSID, HINSTANCE hOleInst)
// Purpose: Tests for existance of rrid in refCLSID
LPCDIGAMECNTRLPROPSHEET HasInterface(REFCLSID refCLSID, HINSTANCE hOleInst)
{
    typedef HRESULT (STDAPICALLTYPE * LPFNCOGETCLASSOBJECT)(REFCLSID, DWORD, COSERVERINFO *, REFIID, LPVOID *);

    LPFNCOGETCLASSOBJECT fpCoGetClassObject = (LPFNCOGETCLASSOBJECT)GetProcAddress(hOleInst, "CoGetClassObject");

    IClassFactory* ppv_classfactory;
    LPCDIGAMECNTRLPROPSHEET fnInterface = 0;

    if(SUCCEEDED(fpCoGetClassObject( refCLSID, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **)&ppv_classfactory)))
    {
        if(SUCCEEDED(ppv_classfactory->CreateInstance(NULL, IID_IDIGameCntrlPropSheet, (LPVOID *)&fnInterface)))
        {
            ppv_classfactory->Release();
        }
        else
        {
#ifdef _DEBUG
        OutputDebugString(TEXT("CPANEL.cpp: CreateInstance Failed!\n"));
#endif 
            // make sure the pointer is nulled
            fnInterface = 0;

            ppv_classfactory->Release();
        }
    }
    else 
#ifdef _DEBUG
   else OutputDebugString(TEXT("CPANEL.cpp: LoadServerInterface Failed!\n"));
#endif
    return fnInterface; 
}
#endif // _UNICODE
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\cpanel.h ===
/*
File:		cpanel.h
Project:	Universal Joystick Control Panel OLE Client
Author:	Brycej
Date:		02/08/95
Comments: 
         general header file

Copyright (c) 1995, Microsoft Corporation
*/


#define DIRECTINPUT_VERSION         0x05B2

#ifndef _CPANEL_H_
#define _CPANEL_H_

#include <commctrl.h>

#define _INC_MMSYSTEM
#define WINMMAPI    DECLSPEC_IMPORT
typedef UINT        MMRESULT;   /* error return code, 0 means no error */
                                /* call as if(err=xxxx(...)) Error(err); else */
// end of hack to avoid including mmsystem.h!!!

#ifndef _UNICODE
#include <malloc.h>		// for alloca
#include <afxconv.h>	   // for AfxW2AHelper
//USES_CONVERSION;
#endif

// DI includes
#include "dinput.h"
#include "dinputd.h"

#include "resource.h"
#include "sstructs.h"
#include "ifacesvr.h"  // also has HSrvGuid.h!!!

#ifndef PPVOID
typedef LPVOID* PPVOID;
#endif

typedef HRESULT (STDAPICALLTYPE * LPFNDIRECTINPUTCREATE)(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUT *ppDI, LPUNKNOWN punkOuter);

#ifndef USES_CONVERSION
#ifndef _DEBUG
#define USES_CONVERSION int _convert; _convert
#else
#define USES_CONVERSION int _convert = 0;
#endif
#endif // USES_CONVERSION

#ifndef A2W
#define A2W(lpa) (((LPCSTR)lpa == NULL) ? NULL : (_convert = (lstrlenA(lpa)+1),	AfxA2WHelper((LPWSTR) alloca(_convert*2), lpa, _convert)))
#endif // A2W

#ifndef W2A
#define W2A(lpw) (((LPCWSTR)lpw == NULL) ? NULL : (_convert = (wcslen(lpw)+1)*2, AfxW2AHelper((LPTSTR) alloca(_convert), lpw, _convert)))
#endif // W2A

//#define IMAGE_NOTCONNECTED	0
const int IMAGE_DEFAULTJOY = 0;
const BYTE NUMJOYDEVS = 16;

#define ID_NONE 		0x10000	// This gets ID_NONE out of the low word of the extended info!

//#define SUPPORT_TWO_2A2B    1

#define MUTEX_NAME	TEXT("$$$MS_GameControllers_Cpl$$$")

// max string length for language strings
#define MAX_STR_LEN	255
#define STR_LEN_128	128
#define STR_LEN_64	 64
#define STR_LEN_32	 32

#define MAX_DEVICES	 75
#define MAX_BUSSES   10
#define MAX_GLOBAL_PORT_DRIVERS 10
#define MAX_ASSIGNED  32

// flags for bNeedUpdate!
#define UPDATE_FOR_ADV  0x01
#define UPDATE_FOR_GEN  0x02
#define UPDATE_ALL      UPDATE_FOR_ADV | UPDATE_FOR_GEN
#define UPDATE_INPROCESS 0x04
#define ON_PAGE			0x08
#define USER_MODE		0x10
#define BLOCK_UPDATE	0x20	// This Blocks WM_DEVICECHANGE messages from doing anything!!!
								// If you use this, remove it when you are done!
#define ON_NT			0x40

// DI define for Get and Set Config to support all currently support bit flags
#define DIJC_ALL DIJC_REGHWCONFIGTYPE |  DIJC_CALLOUT  | DIJC_WDMGAMEPORT | DIJC_GAIN | DIJC_GUIDINSTANCE
#define DITC_ALL DITC_CLSIDCONFIG  | DITC_REGHWSETTINGS   | DITC_DISPLAYNAME | DITC_CALLOUT | DITC_HARDWAREID 

// General Column IDs
#define DEVICE_COLUMN	0
#define STATUS_COLUMN	1

class CDIGameCntrlPropSheet : public IDIGameCntrlPropSheet
{
	private:
		DWORD				m_cProperty_refcount;
		
	public:
		CDIGameCntrlPropSheet(void);
		~CDIGameCntrlPropSheet(void);
		
		// IUnknown methods
	    STDMETHODIMP            QueryInterface(REFIID, PPVOID);
	    STDMETHODIMP_(ULONG)    AddRef(void);
	    STDMETHODIMP_(ULONG)    Release(void);
		
		// CImpIServerProperty methods
		STDMETHODIMP			GetSheetInfo(LPDIGCSHEETINFO *lpSheetInfo);
		STDMETHODIMP			GetPageInfo (LPDIGCPAGEINFO  *lpPageInfo );
		STDMETHODIMP			SetID(USHORT nID);
	    STDMETHODIMP_(USHORT)   GetID(void);
};
typedef CDIGameCntrlPropSheet *LPCDIGAMECNTRLPROPSHEET;

struct JOY
{
	char ID;
	BYTE nStatus;
	BYTE nButtons;
	CLSID clsidPropSheet;
    BOOL fHasOemSheet;
	LPDIRECTINPUTDEVICE2 fnDeviceInterface;

	JOY();
	virtual ~JOY();
};

typedef JOY *PJOY;

int CALLBACK CompareListItems(LPARAM, LPARAM, LPARAM);
int CALLBACK CompareStatusItems(LPARAM, LPARAM, LPARAM);
LRESULT GetHelpFileName(LPTSTR lpszHelpFileName, short* nSize);
BOOL CreateJoyConfigInterface( void );
BOOL DeleteAssignedType( LPWSTR lpwszType );

void OnHelp(LPARAM);  //  for ? help - lives in Add.cpp!
BOOL PopulatePortList( HWND hCtrl ); // Lives in Add.cpp!
void Error (short nTitleID, short nMsgID); // Lives in Cpanel.cpp
void itoa(BYTE n, LPTSTR lpStr);
BOOL SortTextItems( CListCtrl *pCtrl, short nCol, BOOL bAscending, short low, short high );
BOOL DeleteSelectedItem( PBYTE nItem );

// DI Callback proc for enumerating the DI devices
BOOL CALLBACK DIEnumJoyTypeProc(LPCWSTR pwszTypeName, LPVOID pvRef );
BOOL CALLBACK DIEnumDevicesProc(LPDIDEVICEINSTANCE lpDeviceInst, LPVOID lpVoid);
HRESULT Enumerate( HWND hDlg );

#ifdef DX7
BOOL CALLBACK DIEnumMiceProc(LPDIDEVICEINSTANCE lpDeviceInst, LPVOID lpVoid);
BOOL CALLBACK DIEnumKeyboardsProc(LPDIDEVICEINSTANCE lpDeviceInst, LPVOID lpVoid);
#endif // DX7
//LPCDIGAMECNTRLPROPSHEET HasInterface( REFCLSID refCLSID, HINSTANCE hOleInst );
void ClearArrays			( void );
void PostDlgItemEnableWindow( HWND hDlg, USHORT nItem, BOOL bEnabled);
void PostEnableWindow		( HWND hCtrl, BOOL bEnabled );
void MoveOK	 				( HWND hParentWnd );
void LaunchExtention		( HWND hWnd );

// ListControl helper functions!!!
DWORD GetItemData			( HWND hCtrl, BYTE nItem );
BOOL SetItemData			( HWND hCtrl, BYTE nItem, DWORD dwFlag );
void InsertColumn 			( HWND hCtrl, BYTE nColumn, USHORT nStrID, USHORT nWidth );
void SetListCtrlItemFocus 	( HWND hCtrl, BYTE nItem );
void SetItemText			( HWND hCtrl, BYTE nItem, BYTE nSubItem, LPTSTR lpStr);
BYTE GetItemText			( HWND hCtrl, BYTE nItem, BYTE nSubItem, LPTSTR lpszBuff, BYTE nLen );
BYTE InsertItem				( HWND hCtrl, LPTSTR lpszBuff, BYTE nItem); 
void SwapIDs				( BYTE nSource, BYTE nTarget);


#ifdef _UNICODE
void RegisterForDevChange(HWND hDlg, PVOID *hNodifyDevNode);
#endif


#define SETTINGS_PAGE		0
#define TEST_PAGE			1
#define DIAGNOSTICS_PAGE	2
#define MENU_OFFSET			2800

// Dialog proc definitions
INT_PTR CALLBACK CPanelProc		  (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AdvancedProc	  (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AppManProc  	  (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AppManLockProc   (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AddDialogProc	  (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK CustomDialogProc (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ChangeDialogProc (HWND, UINT, WPARAM, LPARAM);

HRESULT Launch(HWND hWnd, PJOY pJoy, BYTE nStartPage);

// Local String function prototypes
#ifdef STRINGS_IN_LOCAL_RESOURCE
BOOL RCSetDlgItemText( HWND hDlg, USHORT nCtrlID, USHORT nStringID);
#endif // STRINGS_IN_LOCAL_RESOURCE

#ifndef LVM_SETEXTENDEDLISTVIEWSTYLE
#define LVM_SETEXTENDEDLISTVIEWSTYLE	(LVM_FIRST+54)
#endif 

#ifndef LVS_EX_FULLROWSELECT
#define LVS_EX_FULLROWSELECT			0x00000020
#endif 

#ifndef LVS_EX_TRACKSELECT
#define LVS_EX_TRACKSELECT				0x00000008
#endif

DEFINE_GUID(CLSID_NULL,	0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);


inline int atoiW(const WCHAR *sz)
{
    BYTE i = 0;

    while (*sz && *sz >= L'0' && *sz <= L'9')
    	i = i*10 + *sz++ - L'0';
    	
    return i;    	
}

inline int WINAPI atoiA(const CHAR *sz)
{
    BYTE i = 0;

    while (*sz && *sz >= '0' && *sz <= '9')
    	i = i*10 + *sz++ - '0';
    	
    return i;    	
}

#ifdef UNICODE
#define atoi    atoiW
#else
#define atoi    atoiA
#endif

// update.cpp
//  void Update(HWND hDlg, int nAccess, TCHAR *tszProxy);
//  INT_PTR CALLBACK CplUpdateProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif //_CPANEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\dbginfo.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dbginfo.h
 *  Content:	Include for setting debugging information, 1 copy of
 *              this file should be in each directory for debugging.
 *              It requires the include path to start with the local
 *              directory so other copies don't take precedence.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/14/99		aarono	Created
 * 07/16/99		johnkan	Fixed problem with macro redefinition if DPF_MODNAME was already defined in .Cxx file
 *
 ***************************************************************************/

#ifndef _DBGINFO_H_
#define _DBGINFO_H_

/*
 *  Sets the section in Win.ini that the debug code looks at to get the settings
 */

#undef PROF_SECT
#define PROF_SECT "DirectPlayVoice"

/*
 *  This is the per function name that should be set so that it is easier to
 *  track down the section of the code that is generating a DPF
 */
#ifndef	DPF_MODNAME
#define DPF_MODNAME "UNKNOWN_MODULE"
#endif	// DPF_MODNAME

/*
 *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
 *  string when present in a file.  This name is also used as the key to override
 *  the standard debug value for this module.
 */
#undef DPF_MODULE_NAME
#define DPF_MODULE_NAME "UNKNOWN_MODULE"


/*
 * Use this identifier to define which line in WIN.INI [DirectNet] denotes the
 * debug control string.  This string is typically the default debug value, it
 * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DNetDebug"


/*
 * Define this identifier to a DWORD variable in your component if you want to
 * be able to turn debugging of components off and on in your component during
 * a debug session.  This is the variable that holds the mask of the component
 * bits that are ON and you want debug spew for.  You then use DPFSC instead
 * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
 * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
 * displayed.
 */
//#define DPF_SUBCOMP_MASK

#endif // _DBGINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\guid.h ===
// guid.h
#ifndef GUID_H
#define GUID_H

// Flash
// {9A9A1380-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	CLSID_FlashExtension,
	0x9a9a1380, 
	0x0d4f, 
	0x11cf, 
	0xaf, 0x06, 
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);

// Legacy
// {9A9A1381-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	CLSID_LegacyExtension,
	0x9a9a1381, 
	0x0d4f,
	0x11cf,
	0xaf, 0x06,
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);

// {9A9A1382-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	IID_IJoyPropSheetExt, 
	0x9a9a1382, 
	0x0d4f, 
	0x11cf, 
	0xaf, 0x06, 
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);

// Midas
// {9A9A1383-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	CLSID_JoystickExtension,
	0x9a9a1383, 
	0x0d4f, 
	0x11cf, 
	0xaf, 0x06, 
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);

// BEGINNING OF NOT RELIABLE GUIDS!!!
// Jolt
// {9A9A1382-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	CLSID_JoltExtension, 
	0x9a9a1384, 
	0x0d4f, 
	0x11cf, 
	0xaf, 0x06, 
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);


// Juno
// {9A9A1382-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	CLSID_JunoExtension, 
	0x9a9a1385, 
	0x0d4f, 
	0x11cf, 
	0xaf, 0x06, 
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);

// Shazam
// {9A9A1382-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	CLSID_Shazam, 
	0x9a9a1386, 
	0x0d4f, 
	0x11cf, 
	0xaf, 0x06, 
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);

// IServerChar
// {9A9A1382-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	IID_IServerChars, 
	0x9a9a1387, 
	0x0d4f, 
	0x11cf, 
	0xaf, 0x06, 
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);

// CServerChar
// {9A9A1382-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	CLSID_CServerChars, 
	0x9a9a1388, 
	0x0d4f, 
	0x11cf, 
	0xaf, 0x06, 
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);

// END OF NOT RELIABLE GUIDS!!!

#endif // GUID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\add.cpp ===
/*
File:		add.cpp
Project:	Universal Joystick Control Panel OLE Client
Author:  Brycej	
Date:		14/Feb/97
Comments:
    window proc for add dialog

Copyright (c) 1995, Microsoft Corporation
*/

#include <afxcmn.h>
#include <windowsx.h>
#include <regstr.h>		  // for REGSTR_VAL_JOYOEMNAME reference!

#include "cpanel.h"
#include "joyarray.h"

#include <initguid.h>

#pragma warning(disable:4200) 
#include <gameport.h>
#pragma warning(default:4200)

// table of default joystick configs
extern WCHAR *pwszTypeArray[MAX_DEVICES];    // List of enumerated gameport devices
extern WCHAR *pwszGameportBus[MAX_BUSSES];   // List of enumerated gameport buses 
extern PJOY  pAssigned[MAX_ASSIGNED];        // List of assigned devices
extern BYTE  nAssigned;                      // Number of elements in pAssigned array
extern BYTE  nTargetAssigned;                // Number of elements expected when pending adds complete
extern BYTE  nReEnum;                        // Counter used to decide when to reenumerate

extern GUID guidOccupied[MAX_BUSSES];    //Whether the gameport bus has been occupied.

extern BYTE  nGameportBus, nGamingDevices;

extern IDirectInputJoyConfig *pDIJoyConfig;
extern short iItem;
extern short nFlags;        // Flags set in CPANEL.CPP!

// extern functions defined in CPANEL.CPP
extern void OnContextMenu(WPARAM wParam, LPARAM lParam);
extern void OnHelp       (LPARAM);


// local message handlers
static BOOL OnInitDialog(HWND, HWND, LPARAM);
static void OnClose(HWND);
static void OnCommand(HWND, int, HWND, UINT);

static char AddSelectedItem( HWND hDlg );
static BOOL UpdateListCtrl ( HWND hCtrl );
static char GetNextAvailableID( void );
static BOOL IsTypeActive( short *nArrayIndex );
static BOOL GetNextAvailableVIDPID(LPWSTR lpwszType );
//static BOOL IsCustomType(BYTE nIndex);

static void PostHScrollBar(HWND hCtrl, LPCTSTR lpStr, BYTE nStrLen);

extern const DWORD g_aHelpIDs[];

extern HINSTANCE ghInstance;

LPTSTR lpszAutoDetect;

const int NO_ITEM = -1;
#define MAX_ANALOG_BUTTONS 4
#define MAX_ANALOG_AXIS    4

// This will become a problem when we support > 500 ports!
#define AUTODETECT_PORT	   100  

// Consider achieving this from calculation of width of listview
static short iAddItem = NO_ITEM;


INT_PTR CALLBACK AddDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg )
    {
    case WM_DESTROY:
        DestroyIcon((HICON)SendMessage(hDlg, WM_GETICON, (WPARAM)ICON_SMALL, 0));

        if( nGameportBus > 1 )
            if( lpszAutoDetect )
                delete[] (lpszAutoDetect);
        break;

    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(hDlg, WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

    case WM_INITDIALOG:
        return(BOOL)HANDLE_WM_INITDIALOG(hDlg, wParam, lParam, OnInitDialog);

    case WM_COMMAND:
        HANDLE_WM_COMMAND(hDlg, wParam, lParam, OnCommand);
        return(1);

    case WM_VKEYTOITEM:
        if( LOWORD(wParam) == VK_DELETE )
        {
            HWND hWnd = GetDlgItem(hDlg, IDC_DEVICE_LIST);

            // determine if it's a custom type... if so... delete it
            // Get the next object with the SELECTED attribute
            iAddItem = (short)::SendMessage(hWnd, LB_GETCURSEL, 0, 0);

            short nArrayIndex = (short)::SendMessage(hWnd, LB_GETITEMDATA, (WPARAM)iAddItem, 0);

            // test to make sure they aren't trying to delete a standard type
            if( *pwszTypeArray[nArrayIndex] == L'#' )
                break;

            // test that the device is a custom type (user or IHV defined)
            // ISSUE-2001/03/29-timgill the number of times we retrieve the same data is ridiculous
            LPDIJOYTYPEINFO lpdiJoyInfo = new (DIJOYTYPEINFO);
            ASSERT (lpdiJoyInfo);

            if( lpdiJoyInfo )
            {
                /*
                 *  warning, abuse of S_OK == 0 == strcmp( identical strings ) ahead
                 */
                HRESULT CmpRes;

                ZeroMemory(lpdiJoyInfo, sizeof(*lpdiJoyInfo));

                lpdiJoyInfo->dwSize = sizeof(*lpdiJoyInfo);

                /*
                 *  Test the hardware ID
                 */
                CmpRes = pDIJoyConfig->GetTypeInfo(pwszTypeArray[nArrayIndex], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_HARDWAREID);
                if( SUCCEEDED( CmpRes ) )
                {
#ifndef WINNT
                    if( lpdiJoyInfo->wszHardwareId[0] == L'\0' )
                    {
                        /*
                         *  No hardware ID, so look for a callout VxD
                         *  If there is none, we have a custom type.
                         */
                        CmpRes = pDIJoyConfig->GetTypeInfo(pwszTypeArray[nArrayIndex], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_CALLOUT);
                        CmpRes = ( SUCCEEDED( CmpRes ) && ( lpdiJoyInfo->wszCallout[0] == L'\0' ) )
                               ? S_OK : S_FALSE;
                    }
                    else 
#endif
                    {
                        const WCHAR wszAnalogRoot[] = L"gameport\\vid_045e&pid_01";

                        CmpRes = (HRESULT)_wcsnicmp( lpdiJoyInfo->wszHardwareId, wszAnalogRoot, 
                                (sizeof(wszAnalogRoot)/sizeof(wszAnalogRoot[0]) ) - 1 );
                    }
                }
                else
                {
                    CmpRes = S_FALSE;
                }

                // clean-up!
                delete (lpdiJoyInfo);

                if( CmpRes != S_OK )
                {
                    // This is not an analog type so leave alone
                    break;
                }
            }
            else
            {
                //  If we can't test the type, do nothing
                break;
            }


            // test to make sure you are not deleting objects
            if( IsTypeActive(&nArrayIndex) )
            {
                Error((short)IDS_GEN_AREYOUSURE_TITLE, (short)IDS_NO_REMOVE);
                break;
            }

            // This buffer has to be big enough for the name and the "are you sure..." message!
            LPTSTR pszMsg   = new TCHAR[MAX_STR_LEN+STR_LEN_64];
            ASSERT (pszMsg);

            LPTSTR pszTitle = new TCHAR[STR_LEN_128];
            ASSERT (pszTitle);

            // Query user if they are sure!
            VERIFY(LoadString(ghInstance, IDS_GEN_AREYOUSURE, pszTitle, MAX_STR_LEN));

            LPTSTR pszTmp = new TCHAR[(short)SendMessage(hWnd, LB_GETTEXTLEN, (WPARAM)iAddItem, 0)+1];
            ASSERT (pszTmp);

            SendMessage(hWnd, LB_GETTEXT, (WPARAM)iAddItem, (LPARAM)(LPCTSTR)pszTmp);

            wsprintf( pszMsg, pszTitle, pszTmp);

            if( pszTmp )
                delete[] (pszTmp);

            VERIFY(LoadString(ghInstance, IDS_GEN_AREYOUSURE_TITLE, pszTitle, STR_LEN_128));

            HRESULT hr = MessageBox(hWnd, pszMsg, pszTitle, MB_ICONQUESTION | MB_YESNO | MB_APPLMODAL);

            if( pszMsg )     delete[] (pszMsg);
            if( pszTitle )   delete[] (pszTitle);

            if( IDYES == hr )
            {

                if( SUCCEEDED(hr = pDIJoyConfig->Acquire()) )
                {
                    // traverse the list and delete any configuration that may have this type assigned to it!
                    //DeleteAssignedType( pwszTypeArray[nArrayIndex] );

                    // returns E_ACCESSDENIED if it's a default item.
                    hr = pDIJoyConfig->DeleteType(pwszTypeArray[nArrayIndex]);
                    ASSERT(SUCCEEDED(hr));

                    pDIJoyConfig->Unacquire();

                    // the dec is for the zero based device list!
                    // decrement the indexes
                    nGamingDevices--;

                    // don't move if you're on the last entry!
                    if( nArrayIndex != nGamingDevices )
                    {
                        // To avoid deleting and recreating...
                        // Let's see if we have room to put this string!
                        BYTE nLen = (BYTE)wcslen(pwszTypeArray[nArrayIndex])+1;

                        // Make sure pwszTypeArray[nArrayIndex] is larger than pwszTypeArray[nCount]
                        if( nLen < (BYTE)wcslen(pwszTypeArray[nGamingDevices])+1 )
                        {
                            if( pwszTypeArray[nArrayIndex] )
                                free(pwszTypeArray[nArrayIndex]);

                            pwszTypeArray[nArrayIndex] = _wcsdup(pwszTypeArray[nGamingDevices]);
                            ASSERT (pwszTypeArray[nArrayIndex]);
                        }
                        // move the end element to the place of the deleted one
                        else wcsncpy(pwszTypeArray[nArrayIndex], pwszTypeArray[nGamingDevices], wcslen(pwszTypeArray[nGamingDevices])+1);

                        // update the extra memory to reflect the new index!
                        // First, find the item in the listbox and get the index...
                        LPDIJOYTYPEINFO_DX5 lpdiJoyInfo = new (DIJOYTYPEINFO_DX5);
                        ASSERT (lpdiJoyInfo);

                        ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO_DX5));

                        lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

                        if( SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszTypeArray[nArrayIndex], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_DISPLAYNAME)) )
                        {
                            char n = (char)SendMessage(hWnd, LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)lpdiJoyInfo->wszDisplayName);
                            SendMessage(hWnd, LB_SETITEMDATA, (WPARAM)n, (LPARAM)nArrayIndex);
                        }

                        // clean-up!
                        if( lpdiJoyInfo )
                            delete (lpdiJoyInfo);
                    }

                    // delete the end element from the array
                    if( pwszTypeArray[nGamingDevices] )
                    {
                        free(pwszTypeArray[nGamingDevices]);
                        pwszTypeArray[nGamingDevices] = 0;
                    }

                    // Remove the entry from the list control
                    SendMessage(hWnd, LB_DELETESTRING, (WPARAM)iAddItem, 0);

                    // Enable the buttons!
                    if( nGamingDevices < MAX_DEVICES-1 )
                    {
                        HWND hParent = GetParent(hWnd);
                        ASSERT (hParent);

                        PostDlgItemEnableWindow(hParent, IDC_CUSTOM,  TRUE);
                        PostDlgItemEnableWindow(hParent, IDC_ADD_NEW, TRUE);
                    }

                    if( iAddItem != nGamingDevices-1 )
                        iAddItem--;

                    // Set the focus to the next available item
                    PostMessage(hWnd, LB_SETCURSEL, (WPARAM)(iAddItem == NO_ITEM) ? 0 : iAddItem, 0);
                }
            }
            break;
        } else return(-1);

//	case WM_NOTIFY:
///		return HANDLE_WM_NOTIFY(hDlg, wParam, lParam, OnNotify);

    case WM_HELP:
        OnHelp(lParam);
        return(1);

    case WM_CONTEXTMENU:
        OnContextMenu(wParam, lParam);
        return(1);
    }
    return(0);
} 

BOOL OnInitDialog(HWND hDlg, HWND hWnd, LPARAM lParam)
{
    HICON hIcon = (HICON)LoadImage(ghInstance, MAKEINTRESOURCE(IDI_CPANEL), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
    ASSERT (hIcon);

    if( hIcon )
        ::PostMessage(hDlg, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)hIcon);

    if( nFlags & ON_NT )
        DestroyWindow(GetDlgItem(hDlg, IDC_WDM));
    else
    {
        HKEY hKey;

        // remove the WDM flag unless otherwise specified!
        if( RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaResources\\joystick\\<FixedKey>"), &hKey) == ERROR_SUCCESS )
        {
            DWORD n;
            DWORD dwSize = sizeof (DWORD);

            if( RegQueryValueEx(hKey, TEXT("UseWDM"), 0, 0, (LPBYTE)&n, &dwSize) == ERROR_SUCCESS )
            {
                if( n )
                    DestroyWindow(GetDlgItem(hDlg, IDC_WDM));
            }
        }

        RegCloseKey(hKey);
    }


    // a simple debug test to verify that the template hasn't gotten DIALOGEX style again!
    HWND hCtrl = GetDlgItem(hDlg, IDC_DEVICE_LIST);
    ASSERT (hCtrl);

    // Fill up the Device List
    if( !UpdateListCtrl(hCtrl) )
    {
        TRACE(TEXT("JOY.CPL: ADD.CPP: Failed UpdateListCtrl!\n"));
        return(FALSE);
    }

    // If there is only one, don't confuse the user with the combo box
    if( nGameportBus > 1 )
    {
        // Allocate for AutoDetect Gameport!
        lpszAutoDetect = new (TCHAR[STR_LEN_32]);
        ASSERT (lpszAutoDetect);

        VERIFY(LoadString(ghInstance, IDS_AUTO_DETECT, lpszAutoDetect, STR_LEN_32));

        hCtrl = GetDlgItem(hDlg, IDC_GAMEPORTLIST);
        ASSERT (hCtrl);

        if( !PopulatePortList(hCtrl) )
        {
            TRACE(TEXT("JOY.CPL: ADD.CPP: Failed PopulatePortList!\n"));
            return(FALSE);
        }

        LPDIJOYTYPEINFO lpdiJoyInfo = new DIJOYTYPEINFO;
        ASSERT (lpdiJoyInfo);

        ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO));

        lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO);

        VERIFY(SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszTypeArray[0], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_FLAGS1)));

        // Search for AutoDetect in the list!
        char nIndex = (char)::SendMessage(hCtrl, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)(LPCTSTR)lpszAutoDetect);

        // If it's got the JOYTYPE_NOAUTODETECTGAMEPORT flag, remove AutoDetect from the ListCtrl
        if( lpdiJoyInfo->dwFlags1 & JOYTYPE_NOAUTODETECTGAMEPORT )
        {
            // it could fail because the entry is not available...
            if( nIndex != CB_ERR )
                ::SendMessage(hCtrl, CB_DELETESTRING, (WPARAM)nIndex, 0);

        }
        // Otherwise, verify that AutoDetect is present... if not, add it!
        else
        {
            // it could fail because the entry is not available...
            if( nIndex == CB_ERR )
                ::SendMessage(hCtrl, CB_SETITEMDATA, ::SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)lpszAutoDetect), AUTODETECT_PORT);
        }

        if( lpdiJoyInfo )
            delete (lpdiJoyInfo);

        SetWindowPos( hCtrl, NULL, NULL, NULL, NULL, NULL, 
                      SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

        SetWindowPos( GetDlgItem(hDlg, IDC_GAMEPORT), NULL, NULL, NULL, NULL, NULL, 
                      SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);
    }

    // blj: Warning Message that you can't add any more devices!
    if( nGamingDevices == MAX_DEVICES-1 )
    {
        // Disable the Custom Button!
        PostDlgItemEnableWindow(hDlg, IDC_CUSTOM,  FALSE);
        PostDlgItemEnableWindow(hDlg, IDC_ADD_NEW, FALSE);

        // Give the user a error message!
        Error((short)IDS_MAX_DEVICES_TITLE, (short)IDS_MAX_DEVICES_MSG);
    }

    return(0);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:	OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code)
//
// PARAMETERS:	hDlg    - 
//             id      - 
//             hWndCtl -
//             code    -
//
// PURPOSE:		WM_COMMAND message handler
///////////////////////////////////////////////////////////////////////////////
void OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code)
{
    switch( id )
    {
    case IDC_ADD_NEW:    
        if( SUCCEEDED(pDIJoyConfig->AddNewHardware(hDlg, GUID_MediaClass)) )
        {
            ClearArrays();

            if( FAILED(pDIJoyConfig->EnumTypes((LPDIJOYTYPECALLBACK)DIEnumJoyTypeProc, NULL)) )
            {
                TRACE(TEXT("JOY.CPL: ADD.CPP: Failed BuildEnumList!\n"));
                return;
            }

            // Warning Message that you can't add any more devices!
            if( nGamingDevices == MAX_DEVICES-1 )
            {
                // Disable the Custom Button!
                PostDlgItemEnableWindow(hDlg, IDC_CUSTOM,  FALSE);
                PostDlgItemEnableWindow(hDlg, IDC_ADD_NEW, FALSE);

                // Give the user a error message!
                Error((short)IDS_MAX_DEVICES_TITLE, (short)IDS_MAX_DEVICES_MSG);
            }

            if( !UpdateListCtrl(GetDlgItem(hDlg, IDC_DEVICE_LIST)) )
            {
                TRACE(TEXT("JOY.CPL: ADD.CPP: Failed to update the list control on the add page!\n"));
                return;
            }
        }
        break;

    case IDC_CUSTOM:
        // DialogBox returns either IDCANCEL or the index into the list of
        // defined types!
        if( IDOK == DialogBox(ghInstance, (PTSTR)IDD_CUSTOM, hDlg, CustomDialogProc) )
        {
            HWND hCtrl = GetDlgItem(hDlg, IDC_DEVICE_LIST);

            // blj: Warning Message that you can't add any more devices!
            if( nGamingDevices == MAX_DEVICES-1 )
            {
                // Disable the Custom Button!
                PostDlgItemEnableWindow(hDlg, IDC_CUSTOM, FALSE);

                // Give the user a error message!
                Error((short)IDS_MAX_DEVICES_TITLE, (short)IDS_MAX_DEVICES_MSG);
            }

            // Now, put the focus on the newly created item!
            LPDIJOYTYPEINFO_DX5 lpdiJoyInfo = new (DIJOYTYPEINFO_DX5);
            ASSERT (lpdiJoyInfo);

            ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO_DX5));

            lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

            // Get nGamingDevices from pwszTypeArray
            // Subtract 1 from nGamingDevices because the list is 0 based!
            if( SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszTypeArray[nGamingDevices-1], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_DISPLAYNAME | DITC_REGHWSETTINGS)) )
            {
#ifdef _UNICODE                                                               
                iAddItem = (short)SendMessage(hCtrl, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)lpdiJoyInfo->wszDisplayName);
                SendMessage(hCtrl, LB_SETITEMDATA,  (WPARAM)iAddItem, (LPARAM)nGamingDevices-1);
                PostHScrollBar(hCtrl, lpdiJoyInfo->wszDisplayName, (BYTE)wcslen(lpdiJoyInfo->wszDisplayName));
#else
                USES_CONVERSION;
                iAddItem = (short)SendMessage(hCtrl, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)W2A(lpdiJoyInfo->wszDisplayName));
                SendMessage(hCtrl, LB_SETITEMDATA, (WPARAM)iAddItem, (LPARAM)nGamingDevices-1);
                PostHScrollBar(hCtrl, W2A(lpdiJoyInfo->wszDisplayName), (BYTE)wcslen(lpdiJoyInfo->wszDisplayName));
#endif
                // SetFocus to that item!
                SendMessage(hCtrl, LB_SETCURSEL, (WPARAM)iAddItem, 0);

                OnCommand(hDlg, IDC_DEVICE_LIST, 0, LBN_SELCHANGE);
            }


            // clean-up!
            if( lpdiJoyInfo )
                delete (lpdiJoyInfo);
        }
        break;

    case IDC_DEVICE_LIST:
        if( code == LBN_SELCHANGE )
        {
            iAddItem = (short)SendMessage(hWndCtl, LB_GETCURSEL, 0, 0);

            BYTE nArrayID = (BYTE)SendMessage(hWndCtl, LB_GETITEMDATA, (WPARAM)iAddItem, 0);

            LPDIJOYTYPEINFO lpdiJoyInfo = new DIJOYTYPEINFO;
            ASSERT (lpdiJoyInfo);

            ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO));

            lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO);

            DWORD dwFlags = DITC_REGHWSETTINGS;

            if( nGameportBus > 1 )
                dwFlags |= DITC_FLAGS1;

            VERIFY(SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszTypeArray[nArrayID], (LPDIJOYTYPEINFO)lpdiJoyInfo, dwFlags)));
/*
                if (nGameportBus > 1)
                {
                   HWND hCtrl = GetDlgItem(hDlg, IDC_GAMEPORTLIST);

                    // Search for AutoDetect in the list!
                    char nIndex = (char)::SendMessage(hCtrl, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)(LPCTSTR)lpszAutoDetect);

                    // If it's got the JOYTYPE_NOAUTODETECTGAMEPORT flag, remove AutoDetect from the ListCtrl
                    if (lpdiJoyInfo->dwFlags1 & JOYTYPE_NOAUTODETECTGAMEPORT)
                    {
                        // it could fail because the entry is not available...
                        if (nIndex != CB_ERR)
                            ::SendMessage(hCtrl, CB_DELETESTRING, (WPARAM)nIndex, 0);	
                        
                    }
                    // Otherwise, verify that AutoDetect is present... if not, add it!
                    else
                    {
                        // it could fail because the entry is not available...
                        if (nIndex == CB_ERR)
                            ::SendMessage(hCtrl, CB_SETITEMDATA, ::SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)lpszAutoDetect), AUTODETECT_PORT);
                    }
        
                    ::PostMessage(hCtrl, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);
                }
*/

            PostDlgItemEnableWindow(hDlg, IDC_JOY1HASRUDDER, (lpdiJoyInfo->hws.dwFlags & JOY_HWS_HASR) ? FALSE : TRUE);

            if( lpdiJoyInfo )
                delete (lpdiJoyInfo);

            break;
        }

        if( code != LBN_DBLCLK )
            break;

    case IDOK:
        iAddItem = (short)SendDlgItemMessage(hDlg, IDC_DEVICE_LIST, LB_GETCURSEL, 0, 0);

        if( iAddItem == NO_ITEM )
            break;

        // Check to see if they have a GamePortList
        {
            HWND hCtrl = GetDlgItem(hDlg, IDC_GAMEPORTLIST);
            ASSERT (hCtrl);

            if( IsWindowVisible(hCtrl) )
            {
                // Check to see if the user has a port selected!
                if( SendMessage(hCtrl, CB_GETCURSEL, 0, 0) == CB_ERR )
                {
                    // blj: TODO: Clear this message with UE
                    Error((short)IDS_NO_GAMEPORT_TITLE, (short)IDS_NO_GAMEPORT);
                    break;
                }
            }
        }

        iItem = 0;
        AddSelectedItem(hDlg);

    case IDCANCEL:
        EndDialog(hDlg, id);
        break;
    }
}

/// Custom Dialog procedure
INT_PTR CALLBACK CustomDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static LPWSTR lpwszVIDPID;

    switch( uMsg )
    {
    case WM_DESTROY:
        {
            HICON hIcon = (HICON)SendMessage(hDlg, WM_GETICON, (WPARAM)ICON_SMALL, 0);
            DestroyIcon(hIcon);
        }
        break;

    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(hDlg, WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

    case WM_HELP:
        OnHelp(lParam);
        return(1);

    case WM_CONTEXTMENU:
        OnContextMenu(wParam, lParam);
        return(TRUE);

    case WM_INITDIALOG:
        // Set up the Buttons and Axis combo boxs!
        {
            HICON hIcon = (HICON)LoadImage(ghInstance, MAKEINTRESOURCE(IDI_CPANEL), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
            ASSERT (hIcon);

            if( hIcon )
                ::PostMessage(hDlg, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)hIcon);

            // Return if no available VID/PIDs found!
            lpwszVIDPID = new (WCHAR[STR_LEN_32]);
            ASSERT (lpwszVIDPID);

            pDIJoyConfig->Acquire();

            if( !GetNextAvailableVIDPID(lpwszVIDPID) )
            {
                if( lpwszVIDPID )
                    delete[] (lpwszVIDPID);

                EndDialog(hDlg, IDCANCEL);

                // Let the user know that they need to remove some "Custom" devices!
                Error((short)IDS_NO_NAME_TITLE, (short)IDS_NOAVAILABLEVIDPID );

                return(FALSE);
            }

            // init id list
            BYTE nButtons = MAX_ANALOG_BUTTONS;
            TCHAR szTmp[3];

            HWND hCtrl = GetDlgItem(hDlg, IDC_COMBO_BUTTONS);

            // Fill the Buttons combo...
            do
            {
                itoa(nButtons, (LPTSTR)&szTmp);
                SendMessage(hCtrl, CB_ADDSTRING, (WPARAM)0, (LPARAM)(LPCTSTR)szTmp);
            } while( nButtons-- );

            // Set Default to four buttons 
            SendMessage(hCtrl, CB_SETCURSEL, MAX_ANALOG_BUTTONS, 0);

            // Use nButtons for Axis...
            nButtons = MAX_ANALOG_AXIS;

            hCtrl = GetDlgItem(hDlg, IDC_COMBO_AXIS);

            // Fill the Axis combo...
            do
            {
                itoa(nButtons--, (LPTSTR)&szTmp);
                SendMessage(hCtrl, CB_ADDSTRING, (WPARAM)0, (LPARAM)(LPCTSTR)szTmp);
            } while( nButtons > 1 );

            // Set Default to two Axis
            SendMessage(hCtrl, CB_SETCURSEL, 0, 0);
        }

        ::PostMessage(GetDlgItem(hDlg, IDC_SPECIAL_JOYSTICK), BM_SETCHECK, BST_CHECKED, 0);

        SendDlgItemMessage(hDlg, IDC_EDIT_NAME, EM_LIMITTEXT, (WPARAM)MAX_STR_LEN, 0);
        return(1);

    case WM_COMMAND:
        switch( LOWORD(wParam) )
        {
        case IDOK:
            {
                // defines for error states!
#define DUPLICATE_NAME  0x01
#define NO_NAME         0x02
#define INVALID_NAME    0x04

                BYTE nLen = (BYTE)SendDlgItemMessage(hDlg, IDC_EDIT_NAME, EM_LINELENGTH, 0, 0);

                LPTSTR pszTypeName = NULL;

                if( nLen )
                {
                    pszTypeName = new (TCHAR[nLen+1]);
                    ASSERT (pszTypeName);

                    // Get the Type/Display Name
                    GetDlgItemText(hDlg, IDC_EDIT_NAME, (LPTSTR)pszTypeName, nLen+1);

                    if( _tcschr(pszTypeName, TEXT('\\')) )
                        nLen = INVALID_NAME;
                    else
                    {
                        // Make sure it's not a duplicate!
                        // start of fix #9269
                        LPDIJOYTYPEINFO_DX5 lpdiGetJoyInfo = new DIJOYTYPEINFO_DX5;
                        ASSERT (lpdiGetJoyInfo);

                        ZeroMemory(lpdiGetJoyInfo, sizeof(DIJOYTYPEINFO_DX5));

                        lpdiGetJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

                        // Clean-up nLen!
                        BYTE n = nLen = 0;

                        // Search for a Duplicate Display Name!!!
                        while( pwszTypeArray[n] )
                        {
                            if( FAILED(pDIJoyConfig->GetTypeInfo(pwszTypeArray[n++], (LPDIJOYTYPEINFO)lpdiGetJoyInfo, DITC_DISPLAYNAME)) )
                            {
                                TRACE(TEXT("JOY.CPL: ADD.CPP: GetTypeInfo Failed!\n"));
                                continue;
                            }
#ifndef	_UNICODE
                            USES_CONVERSION;
#endif

                            if( _tcsncmp(pszTypeName, 
#ifdef _UNICODE
                                        lpdiGetJoyInfo->wszDisplayName, 
#else
                                        W2A(lpdiGetJoyInfo->wszDisplayName),
#endif
                                        wcslen(lpdiGetJoyInfo->wszDisplayName)+1) == 0 )
                            {
                                nLen = DUPLICATE_NAME;
                                break;
                            }
                        }

                        if( lpdiGetJoyInfo ) {
                            delete (lpdiGetJoyInfo);
                        }
                        // end of fix #9269
                        
                    }
                } else nLen = NO_NAME;

                // Check for an error!
                if( nLen )
                {
                    if( pszTypeName )
                        delete[] (pszTypeName);

                    // Give the user the appropriate error!
                    switch( nLen )
                    {
                    case DUPLICATE_NAME:
                        Error((SHORT)IDS_NO_NAME_TITLE, (SHORT)IDS_DUPLICATE_TYPE);
                        break;

                    case NO_NAME:
                        Error((short)IDS_NO_NAME_TITLE, (short)IDS_NO_NAME);
                        break;

                    case INVALID_NAME:
                        Error((short)IDS_NO_NAME_TITLE, (short)IDS_INVALID_NAME);
                        break;
                    }

                    // Set Focus to the Dialog
                    SetFocus(hDlg);

                    HWND hCtrl = GetDlgItem(hDlg, IDC_EDIT_NAME);
                    ASSERT (hCtrl);

                    // Set Focus to the Control
                    SetFocus(hCtrl);

                    // hilite the error
                    PostMessage(hCtrl, EM_SETSEL, (WPARAM)0, (LPARAM)-1);

                    return(FALSE);
                }

                // set the type information
                LPDIJOYTYPEINFO lpdiJoyInfo = new (DIJOYTYPEINFO);
                ASSERT (lpdiJoyInfo);

                ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO));

                lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO);

#ifndef _UNICODE
                USES_CONVERSION;
#endif

                // Set the Display Name
                wcsncpy(lpdiJoyInfo->wszDisplayName, 
#ifdef _UNICODE
                         pszTypeName, 
#else
                         A2W(pszTypeName),
#endif // _UNICODE
                         lstrlen(pszTypeName)+1);

                if( pszTypeName )
                    delete[] (pszTypeName);

                // Set the GUID - default to LegacyServer
                // Per Marcus, we don't want to do this anymore!
                //lpdiJoyInfo->clsidConfig = CLSID_LegacyServer;

                // Set the Hardware Settings
                lpdiJoyInfo->hws.dwNumButtons = (DWORD)SendDlgItemMessage(hDlg, IDC_COMBO_BUTTONS, CB_GETCURSEL, 0, 0);

                switch( SendDlgItemMessage(hDlg, IDC_COMBO_AXIS, CB_GETCURSEL, 0, 0) )
                {
                // R Axis
                case 1:
                    // Check to see which button got checked...
                    lpdiJoyInfo->hws.dwFlags |= ::SendMessage(GetDlgItem(hDlg, IDC_HASRUDDER), BM_GETCHECK, 0, 0) ? JOY_HWS_HASR : JOY_HWS_HASZ;
                    break;

                    // Z Axis
                case 2:
                    lpdiJoyInfo->hws.dwFlags |= JOY_HWS_HASR;
                    lpdiJoyInfo->hws.dwFlags |= JOY_HWS_HASZ;
                    break;

                    // X/Y are default!
                default:
                    lpdiJoyInfo->hws.dwFlags = 0;
                    break;
                }

                lpdiJoyInfo->hws.dwFlags |= ::SendMessage(GetDlgItem(hDlg, IDS_CUSTOM_HASPOV), BM_GETCHECK, 0, 0) ? JOY_HWS_HASPOV : 0;

                // Get Special char's status
                lpdiJoyInfo->hws.dwFlags |= ::SendMessage(GetDlgItem(hDlg, IDC_SPECIAL_JOYSTICK), BM_GETCHECK, 0, 0) ? 0
                                            :  ::SendMessage(GetDlgItem(hDlg, IDC_SPECIAL_PAD), BM_GETCHECK, 0, 0) ? JOY_HWS_ISGAMEPAD
                                            :  ::SendMessage(GetDlgItem(hDlg, IDC_SPECIAL_AUTO), BM_GETCHECK, 0, 0) ? JOY_HWS_ISCARCTRL
                                            :  JOY_HWS_ISYOKE; // default to Yoke!	

                // Set up wszHardwareId
                wcscpy(lpdiJoyInfo->wszHardwareId, L"GamePort\\");

                // This blocks the Huge DisplayName bug!
                // DINPUT change requires VID/PID at the end of the hardware ID... it was 
                //StrNCatW(lpdiJoyInfo->wszHardwareId, lpwszVIDPID, 245);
                // Win95 does not like StrNCatW, we will use wcsncat

                wcsncat(lpdiJoyInfo->wszHardwareId, lpwszVIDPID, 245);

                if( SUCCEEDED(pDIJoyConfig->Acquire()) )
                {
#ifdef _UNICODE
                    if( FAILED(pDIJoyConfig->SetTypeInfo(lpwszVIDPID, lpdiJoyInfo, DITC_DISPLAYNAME | DITC_CLSIDCONFIG | DITC_REGHWSETTINGS | DITC_HARDWAREID)) )
#else
                    if( FAILED(pDIJoyConfig->SetTypeInfo(lpwszVIDPID, lpdiJoyInfo, DITC_DISPLAYNAME | DITC_CLSIDCONFIG | DITC_REGHWSETTINGS ) ) )
#endif
                    {
#ifdef _DEBUG
                        OutputDebugString(TEXT("JOY.CPL: ADD.CPP: CustomDlgProc: SetTypeInfo Failed!\n"));
#endif                  
                    }

                    // Create the memory for the Custom device and stick it into the array!
                    pwszTypeArray[nGamingDevices++] = _wcsdup(lpwszVIDPID);

                    pDIJoyConfig->Unacquire();
                }

                if( lpdiJoyInfo )  delete   (lpdiJoyInfo);
            }

        case IDCANCEL:
            if( lpwszVIDPID )
                delete[] (lpwszVIDPID);

            EndDialog(hDlg, LOWORD(wParam));
            break;

        case IDC_SPECIAL_JOYSTICK:
        case IDC_SPECIAL_YOKE:
        case IDC_SPECIAL_PAD:
        case IDC_SPECIAL_AUTO:
            CheckRadioButton(hDlg, IDC_SPECIAL_JOYSTICK, IDC_SPECIAL_AUTO, IDC_SPECIAL_JOYSTICK);
            break;

        case IDC_COMBO_AXIS:
            // Show/Hide IDC_HASRUDDER based on Selection of 3 Axis
            if( HIWORD(wParam) == CBN_SELCHANGE )
            {
                const USHORT nCtrlArray[] = {IDC_HASRUDDER, IDC_HASZAXIS};
                BYTE nCtrls = sizeof(nCtrlArray)/sizeof(short);

                // the '1' in the comparison is because the CB is Zero based!
                BOOL bShow = (BOOL)(SendDlgItemMessage(hDlg, IDC_COMBO_AXIS, CB_GETCURSEL, 0, 0) == 1);

                do
                {
                    SetWindowPos( GetDlgItem(hDlg, nCtrlArray[--nCtrls]), NULL, NULL, NULL, NULL, NULL, 
                                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | ((bShow) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));
                } while( nCtrls );

                if( bShow )
                    ::PostMessage(GetDlgItem(hDlg, IDC_HASZAXIS), BM_SETCHECK, BST_CHECKED, 0);
            }
            break;
        }
        return(1);

    case WM_CLOSE:
        EndDialog(hDlg, 0);
        return(1);
    }
    return(0);
}

char GetNextAvailableID( void )
{
    LPDIJOYCONFIG_DX5 pJoyConfig = new (DIJOYCONFIG_DX5);
    ASSERT (pJoyConfig);

    ZeroMemory(pJoyConfig, sizeof(DIJOYCONFIG_DX5));

    pJoyConfig->dwSize = sizeof (DIJOYCONFIG_DX5);

    char i = 0;

    do
    {
        switch( pDIJoyConfig->GetConfig(i, (LPDIJOYCONFIG)pJoyConfig, DIJC_REGHWCONFIGTYPE) )
        {
        case S_FALSE:
        case DIERR_NOMOREITEMS:
        case DIERR_NOTFOUND:
        case E_FAIL:
            goto EXIT;


        default:
            i++;
            break;
        }
    } while( i < NUMJOYDEVS );

    i = -1;

    // And it's Error time!
    Error((short)IDS_NO_IDS_TITLE, (short)IDS_NO_IDS);

    EXIT:
    if( pJoyConfig )
        delete (pJoyConfig);

    return(i);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:	AddSelectedItem(HWND hDlg)
//
// PARAMETERS:	hDlg    - Handle to page
//
// PURPOSE:		Adds selected item from List box.
///////////////////////////////////////////////////////////////////////////////
char AddSelectedItem( HWND hDlg )
{
    static BYTE n;
    DWORD dwFlags;
    HRESULT hr; 
    int   nID;
#ifdef SUPPORT_TWO_2A2B    
    BOOL  f2_2A2B = FALSE;
#endif

    nID = GetNextAvailableID();

    // GetNextAvailableID returns -1 if it fails!
    if( nID < 0 )
        return((char)nID);

    // Type info
    LPDIJOYTYPEINFO_DX5 lpdiJoyInfo = new (DIJOYTYPEINFO_DX5);
    ASSERT (lpdiJoyInfo);

    ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO_DX5));

    lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

    BYTE nArrayID = (BYTE)SendDlgItemMessage(hDlg, IDC_DEVICE_LIST, LB_GETITEMDATA, (WPARAM)iAddItem, 0);

    VERIFY(SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszTypeArray[nArrayID], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_REGHWSETTINGS | DITC_CALLOUT | DITC_DISPLAYNAME)));

#ifdef SUPPORT_TWO_2A2B    
#ifndef _UNICODE
    if( wcscmp( pwszTypeArray[nArrayID], L"#<" ) == 0 ) {
        f2_2A2B = TRUE;
        lpdiJoyInfo->hws.dwFlags = 0;
        pwszTypeArray[nArrayID][1] = L'2';
    } else {
        f2_2A2B = FALSE;
    }
#endif
#endif

    LPDIJOYCONFIG pTempJoyConfig = new DIJOYCONFIG;
    ASSERT (pTempJoyConfig);

    ZeroMemory(pTempJoyConfig, sizeof(DIJOYCONFIG));

    pTempJoyConfig->dwSize = sizeof (DIJOYCONFIG);

    pTempJoyConfig->hwc.hws = lpdiJoyInfo->hws;
    pTempJoyConfig->hwc.hws.dwFlags |= JOY_HWS_ISANALOGPORTDRIVER;

    // Do the Rudder Flags!
    if( ::SendMessage(GetDlgItem(hDlg, IDC_JOY1HASRUDDER), BM_GETCHECK, 0, 0) )
    {
        pTempJoyConfig->hwc.hws.dwFlags     |= JOY_HWS_HASR;
        pTempJoyConfig->hwc.dwUsageSettings |= JOY_US_HASRUDDER;
    }

    // set default to present
    pTempJoyConfig->hwc.dwUsageSettings |= JOY_US_PRESENT;

    pTempJoyConfig->hwc.dwType = nArrayID;

    wcsncpy(pTempJoyConfig->wszCallout, lpdiJoyInfo->wszCallout, wcslen(lpdiJoyInfo->wszCallout)+1);

    wcsncpy(pTempJoyConfig->wszType, pwszTypeArray[nArrayID], wcslen(pwszTypeArray[nArrayID])+1);

    LPWSTR lpszPortName = NULL;

    if( SUCCEEDED(pDIJoyConfig->Acquire()) )
    {
        // This stops Memphis and gameport-less systems!!!
        if( nGameportBus )
        {

            // no point asking the Combo box if there's really no choice!
            if( nGameportBus > 1 )
            {
                n = (BYTE)SendDlgItemMessage(hDlg, IDC_GAMEPORTLIST, CB_GETITEMDATA, 
                                             (WPARAM)SendDlgItemMessage(hDlg, IDC_GAMEPORTLIST, CB_GETCURSEL, 0, 0), 0);
            } else
            {
                n = 0;
            }


            if( n == AUTODETECT_PORT )
            {
#ifdef _DEBUG
                OutputDebugString(TEXT("JOY.CPL: ADD.CPP: Selected Port is AutoDetect!\n"));
#endif 
                pTempJoyConfig->guidGameport = GUID_GAMEENUM_BUS_ENUMERATOR;
            } else
            {
                // Zero the memory because the buffer still contains the old data!!!
                ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO_DX5));
                lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

#ifdef _DEBUG
                TRACE(TEXT("JOY.CPL: ADD.CPP: Port List index is %d or %s!\n"), n, pwszGameportBus[n]);
#endif 																														   
                if( SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszGameportBus[n], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_CLSIDCONFIG | DITC_DISPLAYNAME)) )
                {
                    pTempJoyConfig->guidGameport = lpdiJoyInfo->clsidConfig;
                    lpszPortName = _wcsdup(lpdiJoyInfo->wszDisplayName);
                }
            }
        }


        // This is for Memphis and odd case NT systems!
        if( pTempJoyConfig->guidGameport == GUID_NULL )
        {
            pTempJoyConfig->guidGameport = GUID_GAMEENUM_BUS_ENUMERATOR;
#ifdef _DEBUG
            OutputDebugString(TEXT("JOY.CPL: ADD.CPP: Selected Port did not return a clsidConfig so AutoDetect is being used!\n"));
#endif 
        }

        // Set the hour glass
        SetCursor(LoadCursor(NULL, IDC_WAIT));

//  ISSUE-2001/03/29-timgill (MarcAnd) Why would we want to block updates when we're adding a device?
#if 1
        // Unblock the WM_DEVICECHANGE message handler!
        nFlags &= ~BLOCK_UPDATE;
        nFlags |= ON_PAGE;

        /*
         *  Set the nReEnum counter going so that for the next n WM_TIMER 
         *  messages (or until the device arrives) we can consider 
         *  doing a refresh.
         *  The value is somewhat arbitrary.
         */
        nReEnum = 43;
        /*
         *  Set a target for the number of devices so that the extra 
         *  reenumerations can be avoided if this target is reached.
         */
        nTargetAssigned = nAssigned+1;
#else
		nFlags |= BLOCK_UPDATE;
#endif

        dwFlags = DIJC_REGHWCONFIGTYPE | DIJC_CALLOUT;
        dwFlags |= ::SendDlgItemMessage(hDlg, IDC_WDM, BM_GETCHECK, 0, 0) ? DIJC_WDMGAMEPORT : 0;

        if( FAILED(hr = pDIJoyConfig->SetConfig(nID, pTempJoyConfig, dwFlags)) )
        {
            // Let the user know what happend!
            if( hr == E_ACCESSDENIED )
            {
                // Let the use know that the port is already occupied and that they need to remove that device or 
                // re-assign the device to an unoccupied port.

                LPDIJOYCONFIG lpJoyCfg = new (DIJOYCONFIG);
                ASSERT (lpJoyCfg);

                ZeroMemory(lpJoyCfg, sizeof(DIJOYCONFIG));

                lpJoyCfg->dwSize = sizeof(DIJOYCONFIG);

                // Cycle threw pAssigned and find the device with the same port name!
                BYTE nIndex = nAssigned;

                do
                {
                    if( SUCCEEDED(pDIJoyConfig->GetConfig(pAssigned[--nIndex]->ID, lpJoyCfg, DIJC_WDMGAMEPORT)) )
                    {
                        if( lpJoyCfg->guidGameport == pTempJoyConfig->guidGameport )
                            break;
                    }
                } while( nIndex );

                if( lpJoyCfg )
                    delete (lpJoyCfg);

                DIPROPSTRING *pDIPropStr = new (DIPROPSTRING);
                ASSERT (pDIPropStr);

                ZeroMemory(pDIPropStr, sizeof(DIPROPSTRING));

                pDIPropStr->diph.dwSize       = sizeof(DIPROPSTRING);
                pDIPropStr->diph.dwHeaderSize = sizeof(DIPROPHEADER);
                pDIPropStr->diph.dwHow        = DIPH_DEVICE;

                // Ok now.. you found it... use the Device pointer to get it's Friendly name!
                if( SUCCEEDED(pAssigned[nIndex]->fnDeviceInterface->GetProperty(DIPROP_INSTANCENAME, &pDIPropStr->diph)) )
                {
                    // Put ellipse in text to avoid buffer over-flow.
                    // Limit displayed name to 50 chars... not completely arbitrary,
                    // we need to leave room in the Message string...
                    // who knows how long the string will get when translated!
                    if( wcslen(pDIPropStr->wsz) > 50 )
                    {
                        pDIPropStr->wsz[47] = pDIPropStr->wsz[48] = pDIPropStr->wsz[49] = L'.';
                        pDIPropStr->wsz[50] = L'\0';
                    }

                    LPTSTR lptszMsgFormat = new (TCHAR[MAX_STR_LEN]);
                    ASSERT (lptszMsgFormat);
                    VERIFY(LoadString(ghInstance, IDS_ADD_PORT_MSGFORMAT, lptszMsgFormat, MAX_STR_LEN));

                    LPTSTR lptszMsg = new (TCHAR[MAX_STR_LEN]);
                    ASSERT (lptszMsg);

                    // Format the message
                    wsprintf(lptszMsg, lptszMsgFormat, pDIPropStr->wsz, lpszPortName, pAssigned[nIndex]->ID+1);

                    VERIFY(LoadString(ghInstance, IDS_ADD_PORT_OCCUPIED, lptszMsgFormat, MAX_STR_LEN));

                    MessageBox(hDlg, lptszMsg, lptszMsgFormat, MB_ICONHAND | MB_OK | MB_APPLMODAL);

                    if( lptszMsgFormat )
                        delete[] (lptszMsgFormat);

                    if( lptszMsg )
                        delete[] (lptszMsg);
                }

                if( pDIPropStr )
                    delete (pDIPropStr);
            } else if( hr == DIERR_DEVICEFULL )
            {
                Error((short)IDS_GAMEPORT_OCCUPIED_TITLE, (short)IDS_GAMEPORT_OCCUPIED);
            } else
            {
                // Something Ugly happened!
                Error((short)IDS_NO_GAMENUM_TITLE, (short)IDS_NO_GAMENUM);
            }
        } else
        {
#ifdef _UNICODE
            // Fix #55524
            if( SUCCEEDED(pDIJoyConfig->GetConfig(nID, pTempJoyConfig, DIJC_REGHWCONFIGTYPE)) )
            {
                if( !(pTempJoyConfig->hwc.dwUsageSettings & JOY_US_PRESENT) )
                {
                    pTempJoyConfig->hwc.dwUsageSettings |= JOY_US_PRESENT;
                    pTempJoyConfig->hwc.hwv.dwCalFlags  |= 0x80000000;
                    pTempJoyConfig->hwc.hws.dwFlags     |= JOY_HWS_ISANALOGPORTDRIVER;

                    VERIFY(SUCCEEDED(pDIJoyConfig->SetConfig(nID, pTempJoyConfig, DIJC_REGHWCONFIGTYPE)));
                }
            }
            // end of Fix #55524
#endif

            // make sure VJOYD is notified
            if( !(nFlags & ON_NT) ) {
                pDIJoyConfig->SendNotify();
                Sleep(10);
                pDIJoyConfig->SendNotify();
            }

#ifndef _UNICODE
    #ifdef SUPPORT_TWO_2A2B    
            /*
             * Add the other part of Two_2Axis_2Button joystick.
             */
            if( f2_2A2B ) {
                nID = GetNextAvailableID();
                if( nID >= 0 ){
                    hr = pDIJoyConfig->SetConfig(nID, pTempJoyConfig, dwFlags);

                    if( SUCCEEDED(hr) ) {
                        if( !(nFlags & ON_NT) )
                        pDIJoyConfig->SendNotify();
                    }
                }
                 
            }
    #endif
#endif

        }

        if( lpszPortName )
            free(lpszPortName);

        // Set the standard pointer
        SetCursor(LoadCursor(NULL, IDC_ARROW));

        pDIJoyConfig->Unacquire();
    }

    if( lpdiJoyInfo )
        delete (lpdiJoyInfo);

    if( pTempJoyConfig )
        delete (pTempJoyConfig);

    return((char)nID);
}

BOOL UpdateListCtrl( HWND hCtrl )
{
    // Turn Redraw off here else it will flicker!
    ::SendMessage(hCtrl, WM_SETREDRAW, (WPARAM)FALSE, 0);

    // delete all existing entries
    ::SendMessage(hCtrl, LB_RESETCONTENT, 0, 0);

    // Type info
    LPDIJOYTYPEINFO_DX5 lpdiJoyInfo = new (DIJOYTYPEINFO_DX5);
    ASSERT (lpdiJoyInfo);

    ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO_DX5));

    lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

#ifndef _UNICODE
    USES_CONVERSION;
#endif

    BYTE nIndex = nGamingDevices-1;

    ::SendMessage(hCtrl, LB_SETCOUNT, (WPARAM)(int)nIndex, 0);

    LPWSTR lpStr = new WCHAR[MAX_STR_LEN];
    ASSERT (lpStr);

    BYTE nLargestStringLen = 0;

    do
    {
        if( SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszTypeArray[nIndex], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_DISPLAYNAME)) )
        {
#ifdef _UNICODE
            ::SendMessage(hCtrl, LB_SETITEMDATA, 
                          (WPARAM)::SendMessage(hCtrl, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)lpdiJoyInfo->wszDisplayName), (LPARAM)nIndex);
#else
            ::SendMessage(hCtrl, LB_SETITEMDATA, 
                          (WPARAM)::SendMessage(hCtrl, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)W2A(lpdiJoyInfo->wszDisplayName)), (LPARAM)nIndex);
#endif
            if( wcslen(lpdiJoyInfo->wszDisplayName) > nLargestStringLen )
            {
                nLargestStringLen = (BYTE)wcslen(lpdiJoyInfo->wszDisplayName);
                wcscpy(lpStr, lpdiJoyInfo->wszDisplayName);
            }
        }
    } while( nIndex-- );

    if( lpdiJoyInfo )
        delete (lpdiJoyInfo);

#ifdef _UNICODE
    PostHScrollBar(hCtrl, lpStr, nLargestStringLen);
#else
    PostHScrollBar(hCtrl, W2A(lpStr), nLargestStringLen);
#endif

    if( lpStr )
        delete[] (lpStr);

    // Select the default selection to the 0th device type
    iAddItem = 0;

    ::PostMessage(hCtrl, LB_SETCURSEL, (WPARAM)iAddItem, 0);

    // Turn the redraw flag back on!
    ::SendMessage (hCtrl, WM_SETREDRAW, (WPARAM)TRUE, 0);
    InvalidateRect(hCtrl, NULL, TRUE);
    return(TRUE);
}

// Please check to see if nGameportBus is > 0 before a call to this function!
// It will work, but What a waste!
BOOL PopulatePortList( HWND hCtrl )
{
    if( !::IsWindow(hCtrl) )
    {
        TRACE(TEXT("JOY.CPL: PopulatePortList: HWND passed to PopulatePortList is NOT a valid Window!\n"));
        return(FALSE);
    }

    SendMessage(hCtrl, CB_SETEXTENDEDUI, TRUE, 0);

    // temp so we don't damage the global!
    BYTE n = nGameportBus;

    LPDIJOYTYPEINFO lpDIJoyTypeInfo = new (DIJOYTYPEINFO);
    ASSERT(lpDIJoyTypeInfo);

#ifndef _UNICODE
    USES_CONVERSION;
#endif

    lpDIJoyTypeInfo->dwSize = sizeof(DIJOYTYPEINFO);

    // Populate the list as they were enumerated.
    do
    {
        if( FAILED(pDIJoyConfig->GetTypeInfo(pwszGameportBus[--n], lpDIJoyTypeInfo, DITC_DISPLAYNAME)) )
        {
            TRACE(TEXT("JOY.CPL: ADD.CPP: GetTypeInfo failed!\n"));
            continue;
        }

        // put the name in the list and place the index of the port array 
        // in it's item data...
        SendMessage(hCtrl, CB_SETITEMDATA, 
#ifdef _UNICODE
                    SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)lpDIJoyTypeInfo->wszDisplayName), n);
#else
                    SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)(LPCSTR)W2A(lpDIJoyTypeInfo->wszDisplayName)), n);
#endif

        // Just in case you're curious, we're going backwards so the default
        // port is the lowest available one.
    } while( n );

    // Don't forget Auto-Detect!
    // But only if there's more than one port!
    ::SendMessage(hCtrl, CB_SETITEMDATA, ::SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)lpszAutoDetect), AUTODETECT_PORT);

    // While you're at it, check to see if one is available... 
    // if so, put it as the default!
    ::PostMessage(hCtrl, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);

    if( lpDIJoyTypeInfo )
        delete (lpDIJoyTypeInfo);

    return(TRUE);
}

static BOOL IsTypeActive( short *nArrayIndex )
{
    if( *nArrayIndex > nGamingDevices )
    {
#ifdef _DEBUG
        OutputDebugString(TEXT("JOY.CPL: IsTypeActive: nArrayIndex > nGamingDevices!\n"));
#endif
        return(FALSE);
    }

    BOOL bRet = FALSE;

    BYTE nIndex  = nAssigned;
    BYTE nStrLen = (BYTE)wcslen(pwszTypeArray[*nArrayIndex])+1;

    LPDIJOYCONFIG_DX5 lpDIJoyConfig = new (DIJOYCONFIG_DX5);
    ASSERT (lpDIJoyConfig);

    ZeroMemory(lpDIJoyConfig, sizeof(DIJOYCONFIG_DX5));

    lpDIJoyConfig->dwSize = sizeof (DIJOYCONFIG_DX5);

    // find the assigned ID's  
    while( nIndex-- )
    {
        if( SUCCEEDED(pDIJoyConfig->GetConfig(pAssigned[nIndex]->ID, (LPDIJOYCONFIG)lpDIJoyConfig, DIJC_REGHWCONFIGTYPE)) )
        {
            // if you find it... break out!
            if( wcsncmp(lpDIJoyConfig->wszType, pwszTypeArray[*nArrayIndex], nStrLen) == 0 )
            {
                bRet = TRUE;
                *nArrayIndex = nIndex;
                break;
            }
        }
    } 

    if( lpDIJoyConfig )
        delete (lpDIJoyConfig);

    return(bRet);
}

BOOL GetNextAvailableVIDPID(LPWSTR lpwszType )
{
    // Make the VID/PID to compare from the following formula
    // VID_045e&PID_100+JOY_HW_LASTENTRY to 100+JOY_HW_LASTENTRY+0xf

    HKEY hKey;
    BYTE n = JOY_HW_LASTENTRY;

    wcsncpy(lpwszType, L"VID_045E&PID_0100", 18);

    const WCHAR wszLookup[] = L"0123456789ABCDEF";

    do
    {
        if( n < 0x10 )
        {
            lpwszType[16] = wszLookup[n];
        } else
        {
            lpwszType[15] = wszLookup[1];
            lpwszType[16] = wszLookup[n%0x10];
        }

        n++;

        if( FAILED(pDIJoyConfig->OpenTypeKey(lpwszType, KEY_READ, &hKey)) )
            break;

        RegCloseKey(hKey);

    } while( n < (JOY_HW_LASTENTRY+0x11) );

    return(BOOL)(n < 0x1d);
}

//
// PostDlgItemEnableWindow(HWND hDlg, USHORT nItem, BOOL bEnabled)
//
void PostDlgItemEnableWindow(HWND hDlg, USHORT nItem, BOOL bEnabled)
{
    HWND hCtrl = GetDlgItem(hDlg, nItem);

    if( hCtrl )
        PostEnableWindow(hCtrl, bEnabled);
}

//
// PostEnableWindow(HWND hCtrl, BOOL bEnabled)
//
void PostEnableWindow(HWND hCtrl, BOOL bEnabled)
{
    DWORD dwStyle = GetWindowLong(hCtrl, GWL_STYLE);

    // No point Redrawing the Window if there's no change!
    if( bEnabled )
    {
        if( dwStyle & WS_DISABLED )
            dwStyle &= ~WS_DISABLED;
        else return;
    } else
    {
        if( !(dwStyle & WS_DISABLED) )
            dwStyle |=  WS_DISABLED;
        else return;
    }

    SetWindowLong(hCtrl, GWL_STYLE, dwStyle);

    RedrawWindow(hCtrl, NULL, NULL, RDW_INTERNALPAINT | RDW_INVALIDATE); 
}

/*
BOOL IsCustomType(BYTE nIndex)
{
   BOOL bRet = FALSE;

   // First verify VID is 045E
   WCHAR *pwStr = StrStrW(pwszTypeArray[nIndex],L"VID_");
   
   if (pwStr)
   {
      // Increment the pointer over the VID_ and test for 045E
      pwStr = &pwStr[4];

      if (_wcsnicmp(pwStr, L"045e", 4) == 0)
      {
         OutputDebugString(TEXT("Hit \n"));

         // Now, increment the pointer over 045e and &PID_ and test for the range!
         pwStr = &pwStr[9];

         // Second, verify PID is between 0x100 + JOY_HW_LASTENTRY and 
         // 0x100 + JOY_HW_LASTENTRY + 0xf


         bRet = TRUE;
      }
   }

   return bRet;
}
*/

void PostHScrollBar(HWND hCtrl, LPCTSTR lpStr, BYTE nStrLen)
{
    SIZE sz;
    HDC hDC = GetWindowDC(hCtrl);
    if( hDC != NULL ) /* PREFIX MANBUGS: 29336*/
    {
        GetTextExtentPoint32(hDC, lpStr, nStrLen, &sz);
        ReleaseDC(hCtrl, hDC);
        ::PostMessage(hCtrl, LB_SETHORIZONTALEXTENT, (WPARAM)sz.cx, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\guidutil.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       guidutil.cpp
 *  Content:    Some GUID related utility functions
 *
 *  History:
 *	Date   By  Reason
 *	============
 *	08/19/99	pnewson		created
 ***************************************************************************/

#include "guidutil.h"
#include "stdio.h"

#undef DPF_MODNAME
#define DPF_MODNAME "DVStringFromGUID"
HRESULT DVStringFromGUID(const GUID* lpguid, WCHAR* swzBuf, DWORD dwNumChars)
{
	if (dwNumChars < GUID_STRING_LEN)
	{
		return E_FAIL;
	}
	
    swprintf( 
    	swzBuf, 
    	L"{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}", 
    	lpguid->Data1, 
    	lpguid->Data2, 
    	lpguid->Data3, 
        lpguid->Data4[0], 
        lpguid->Data4[1], 
        lpguid->Data4[2], 
        lpguid->Data4[3],
        lpguid->Data4[4], 
        lpguid->Data4[5], 
        lpguid->Data4[6], 
        lpguid->Data4[7] );
        
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVGUIDFromString"
HRESULT DVGUIDFromString(const WCHAR* wszBuf, GUID* lpguid)
{
    UINT aiTmp[10];

    if( swscanf( wszBuf, L"{%8X-%4X-%4X-%2X%2X-%2X%2X%2X%2X%2X%2X}",
                    &lpguid->Data1, 
                    &aiTmp[0], &aiTmp[1], 
                    &aiTmp[2], &aiTmp[3],
                    &aiTmp[4], &aiTmp[5],
                    &aiTmp[6], &aiTmp[7],
                    &aiTmp[8], &aiTmp[9] ) != 11 )
    {
    	ZeroMemory(lpguid, sizeof(GUID));
        return FALSE;
    }
    else
    {
        lpguid->Data2       = (USHORT) aiTmp[0];
        lpguid->Data3       = (USHORT) aiTmp[1];
        lpguid->Data4[0]    = (BYTE) aiTmp[2];
        lpguid->Data4[1]    = (BYTE) aiTmp[3];
        lpguid->Data4[2]    = (BYTE) aiTmp[4];
        lpguid->Data4[3]    = (BYTE) aiTmp[5];
        lpguid->Data4[4]    = (BYTE) aiTmp[6];
        lpguid->Data4[5]    = (BYTE) aiTmp[7];
        lpguid->Data4[6]    = (BYTE) aiTmp[8];
        lpguid->Data4[7]    = (BYTE) aiTmp[9];
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\guidutil.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       guidutil.h
 *  Content:    Some GUID related utility functions
 *
 *  History:
 *	Date   By  Reason
 *	============
 *	08/19/99	pnewson		created
 ***************************************************************************/

#ifndef _GUIDUTIL_H_
#define _GUIDUTIL_H_

#include <windows.h>

#define GUID_STRING_LEN 39

HRESULT DVStringFromGUID(const GUID* lpguid, WCHAR* wszBuf, DWORD dwNumChars);
HRESULT DVGUIDFromString(const WCHAR* wszBuf, GUID* lpguid);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\joyarray.h ===
#include "joyhelp.h"
#include "resource.h"

const DWORD gaHelpIDs[]=
{
    IDC_BTN_PROPERTIES,     IDH_101_1002,   // Game Controllers: "&Properties..." (Button)
    IDC_BTN_TSHOOT,         IDH_101_1036,   // Trouble Shoot Button
    IDC_LIST_DEVICE,        IDH_101_1058,   // Game Controllers: "List1" (SysListView32)
    IDC_LIST_HEADING,       IDH_101_1058,   // Game Controllers: "&Game Controllers" (Static)
    IDC_BTN_REMOVE,         IDH_101_1028,   // Game Controllers: "&Remove..." (Button)
    IDC_BTN_ADD,            IDH_101_1010,   // Game Controllers: "A&dd..." (Button)
    IDC_BTN_REFRESH,        IDH_101_1022,   // Game Controllers: "Refresh" (Button)
    IDC_POLLFLAGS,          IDH_117_1100,   // -: "P&oll with interrupts enabled" (Button)
    IDC_COMBO1,             IDH_117_1101,   // -: "" (ComboBox)
    IDC_TEXT_PORTDRIVER,    IDH_117_1101,   // -: "&Port Driver:" (Static)
    IDC_GAMEPORT,           IDH_117_1101,   // 
    IDC_GAMEPORTLIST,       IDH_117_1101,   // 
    IDC_ADV_LIST_DEVICE,    IDH_117_8197,   // -: "" (ListBox)
    IDC_ADV_CHANGE,         IDH_117_8198,   // -: "Cha&nge..." (Button)
    IDC_ADV_USEOEMPAGE,     IDH_117_8199,   // Advanced: OEM property sheet check box
    IDC_ADD_NEW,            IDH_119_1039,   // Add Game Controller: "&Add Other..." (Button)
    IDC_CUSTOM,             IDH_119_1049,   // Add's Custom button!
    IDC_DEVICE_LIST_TAG,    IDH_119_1059,   // Add Game Controller: "&Controllers:" (Static)
    IDC_DEVICE_LIST,        IDH_119_1059,   // Add Game Controller: "List1" (SysListView32)
    IDC_COMBO_AXIS,         IDH_4099_1043,  // Custom Game Controller: "" (ComboBox)
    IDC_HASRUDDER,          IDH_4099_1044,  // Rudder checkbox from Custom Page
    IDC_COMBO_BUTTONS,      IDH_4099_1045,  // Custom Game Controller: "" (ComboBox)
    IDC_HASZAXIS,           IDH_4099_1046,  // Z Axis checkbox from Custom Page
    IDC_SPECIAL_YOKE,       IDH_4099_1051,  // Custom Game Controller: "Is a flight yoke/stick" (Button)
    IDC_SPECIAL_PAD,        IDH_4099_1052,  // Custom Game Controller: "Is a game pad" (Button)
    IDC_SPECIAL_AUTO,       IDH_4099_1053,  // Custom Game Controller: "Is a race car controller" (Button)
    IDS_CUSTOM_HASPOV,      IDH_4099_1054,  // Custom Game Controller: "Has a &point of view control" (Button)
    IDC_CUSTOM_NAME,        IDH_4099_1056,  // Custom Game Controller: "" (Edit)
    IDC_EDIT_NAME,          IDH_4099_1056,  // Custom Game Controller: "" (Edit)
    IDC_SPECIAL_JOYSTICK,   IDH_4099_1058,  // Custom Game Controller: "Is a Joystick" (Button)
    IDC_JOY1HASRUDDER,      IDH_4201_1019,  // Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)
    IDC_SPIN,               IDH_8188_8189,  // Spin button in Advanced page Change dialog!
    IDC_SPINBUDDY,          IDH_8188_8189,  // Spin button in Advanced page Change dialog!
    IDC_SELECTEDID,         IDH_8188_8191,  // Change Controller Assignment: "Selected ID" (ListBox)
    IDC_CHANGE_LIST,        IDH_8188_8194,  // Change Controller Assignment: "" (ListBox)
    IDC_LISTTXT,            IDH_8188_8194,
    IDC_ADV_GRP,            (DWORD)-1,
    IDC_ADV_GRP2,           (DWORD)-1,
    IDC_TEXT_DRIVER,        (DWORD)-1,
    IDC_ADD_STR1,           (DWORD)-1,
    IDC_ADD_STR2,           (DWORD)-1,
    IDC_GEN_ICON,           (DWORD)-1,
    IDC_GEN_INTRO,          (DWORD)-1,
    IDC_ASSIGNTXT,          (DWORD)-1,
    IDC_TEXT_TITLE,         (DWORD)-1,
    IDC_SEPERATOR,          (DWORD)-1,
    IDC_AXES_GROUP,         (DWORD)-1,  // Custom Game Controller: "&Axes" (Button)
    IDC_BUTTONS_GROUP,      (DWORD)-1,  // Custom Game Controller: "" (ComboBox)
    IDC_SPECIAL_GROUP,      (DWORD)-1,  // Custom Game Controller: "&Special Characteristics" (Button)

    IDC_VOICECHATGROUP,	    (DWORD)-1,
    IDC_VOICECHATTEXT,      (DWORD)-1,
    IDC_GAMESLISTHOTKEY,    (DWORD)-1,

    IDC_LIST_GAMES,         IDH_VOICE_LIST_GAMES,
    IDC_DETAILS,            IDH_VOICE_DETAILS,
	
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\inplace.h ===
#if !defined(AFX_INPLACEEDIT_H__8424B1E4_BF4A_11D1_82D7_0000F87A3912__INCLUDED_)
#define AFX_INPLACEEDIT_H__8424B1E4_BF4A_11D1_82D7_0000F87A3912__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// InPlaceEdit.h : header file
//

#define IDC_IPEDIT 7896

/////////////////////////////////////////////////////////////////////////////
// CInPlaceEdit window

class CInPlaceEdit : public CEdit
{
// Construction
public:
	CInPlaceEdit(BYTE iItem, BYTE iSubItem);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInPlaceEdit)
//	public:
// 	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CInPlaceEdit();

	// Generated message map functions
protected:
	//{{AFX_MSG(CInPlaceEdit)
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	//}}AFX_MSG										    

	DECLARE_MESSAGE_MAP()

private:
	BYTE m_iItem;
	BYTE m_iSubItem;
	LPTSTR m_sInitText;
	BOOL    m_bESC;	 	// To indicate whether ESC key was pressed
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INPLACEEDIT_H__8424B1E4_BF4A_11D1_82D7_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\inplace.cpp ===
// InPlaceEdit.cpp : implementation file
//

#include "stdafx.h"
#include "InPlace.h"
#include "cpanel.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MAX_STR_LEN 255

extern HWND hAdvListCtrl;

/////////////////////////////////////////////////////////////////////////////
// CInPlaceEdit

CInPlaceEdit::CInPlaceEdit(BYTE iItem, BYTE iSubItem):m_iItem(iItem),m_iSubItem(iSubItem)
//,m_bESC(FALSE),m_sInitText(sInitText)
{
	m_iItem 	  	= iItem;
	m_iSubItem 	= iSubItem;
	m_bESC 	  	= FALSE;

//	_tcscpy(m_sInitText, sInitText);
}

CInPlaceEdit::~CInPlaceEdit()
{
}


BEGIN_MESSAGE_MAP(CInPlaceEdit, CEdit)
	//{{AFX_MSG_MAP(CInPlaceEdit)
	ON_WM_KILLFOCUS()
	ON_WM_CHAR()
	ON_WM_CREATE()
	ON_WM_MOUSEWHEEL()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInPlaceEdit message handlers
/*
BOOL CInPlaceEdit::PreTranslateMessage(MSG* pMsg) 
{
	if( pMsg->message == WM_KEYDOWN )
	{
		if(pMsg->wParam == VK_RETURN
				|| pMsg->wParam == VK_DELETE
				|| pMsg->wParam == VK_ESCAPE
				|| GetKeyState( VK_CONTROL)
				)
		{
			::TranslateMessage(pMsg);
			::DispatchMessage(pMsg);
			return TRUE;		    	// DO NOT process further
		}
	}
	return CEdit::PreTranslateMessage(pMsg);
}
*/

BOOL CInPlaceEdit::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt)
{
	OnKillFocus(this);
	return TRUE;
}

void CInPlaceEdit::OnKillFocus(CWnd* pNewWnd) 
{
	CEdit::OnKillFocus(pNewWnd);

	if (LineLength())
	{
		::GetWindowText(this->GetSafeHwnd(), m_sInitText, MAX_STR_LEN);

	   // No point sending the message if the text hasn't changed!
	   // OR if there's nothing to add!
	   // Send Notification to parent of ListView ctrl
		LV_DISPINFO *lpDispinfo = new (LV_DISPINFO);
	   ASSERT (lpDispinfo);

	   lpDispinfo->hdr.hwndFrom    = GetParent()->m_hWnd;
		lpDispinfo->hdr.idFrom      = GetDlgCtrlID();
	   lpDispinfo->hdr.code        = LVN_ENDLABELEDIT;

		lpDispinfo->item.mask       = LVIF_TEXT;
		lpDispinfo->item.iItem      = m_iItem;
	   lpDispinfo->item.iSubItem   = m_iSubItem;
	   lpDispinfo->item.pszText    = m_bESC ? NULL : m_sInitText;
		lpDispinfo->item.cchTextMax = MAX_STR_LEN;

	   GetParent()->GetParent()->SendMessage( WM_NOTIFY, GetParent()->GetDlgCtrlID(), 
						(LPARAM)lpDispinfo );

	   if (lpDispinfo)
	      delete (lpDispinfo);
   }

	if (m_sInitText)
		delete[] (m_sInitText);

	PostMessage(WM_CLOSE);
}

void CInPlaceEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	CEdit::OnChar(nChar, nRepCnt, nFlags);

	// Get text extent
	BYTE nLen = (BYTE)SendMessage(LB_GETTEXTLEN, (WPARAM)0, 0);

	if (nLen == 255)
		return;

   LPTSTR lpStr = new (TCHAR[nLen+1]);
	ASSERT (lpStr);

   SendMessage(LB_GETTEXT, (WPARAM)0, (LPARAM)(LPCTSTR)lpStr);

	// Resize edit control if needed
	HDC hDC = this->GetDC()->m_hDC;
	SIZE size;
	::GetTextExtentPoint(hDC, lpStr, nLen+1, &size);
	::ReleaseDC(this->m_hWnd, hDC);

	if (lpStr)
		delete[] (lpStr);

	size.cx += 5;			   	// add some extra buffer

	// Get client rect
	RECT rect, parentrect;
	GetClientRect( &rect );
	GetParent()->GetClientRect( &parentrect );

	// Transform rect to parent coordinates
	ClientToScreen( &rect );
	GetParent()->ScreenToClient( &rect );

	// Check whether control needs to be resized
	// and whether there is space to grow
	if( size.cx > (rect.right-rect.left) )
	{
		rect.right = ( size.cx + rect.left < parentrect.right ) ? rect.left + size.cx : parentrect.right;
		MoveWindow( &rect );
	}
}


int CInPlaceEdit::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CEdit::OnCreate(lpCreateStruct) == -1)
		return -1;

	// Allocate the string buffer
	m_sInitText = new (TCHAR[MAX_STR_LEN+1]);
	ASSERT (m_sInitText);

	GetItemText(hAdvListCtrl, m_iItem, m_iSubItem, m_sInitText, MAX_STR_LEN);

	// Set the proper font
	// If you don't, the font is a bold version of the dialog font!
	::SendMessage(this->m_hWnd, WM_SETFONT, ::SendMessage(::GetParent(this->m_hWnd), WM_GETFONT, 0, 0), 0);

	SendMessage(WM_SETTEXT, 0, (LPARAM)(LPCTSTR)m_sInitText);
	SetFocus();
   SendMessage(EM_SETSEL, (WPARAM)0, (LPARAM)-1);
	SendMessage(EM_LIMITTEXT, (WPARAM)MAX_STR_LEN, 0);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\joyhelp.h ===
#define IDH_101_1002    65667173    // Game Controllers: "&Properties..." (Button)
#define IDH_101_1022    65667180    // Game Controllers: "Refresh" (Button)
#define IDH_101_1010    66191461    // Game Controllers: "A&dd..." (Button)
#define IDH_101_1028    67371109    // Game Controllers: "&Remove..." (Button)
#define IDH_101_1036    67548653    // Game Controllers: "Troubleshoot..." (Button)
#define IDH_101_1058    69337189    // Game Controllers: "&Game Controllers" (Static)

#define IDH_117_1100    72089717    // -: "P&oll with interrupts enabled" (Button)
#define IDH_117_1101    72155253    // -: "&Port Driver:" (Static)
#define IDH_117_8195    537067637   // -: "&Controller ID's:" (Static)
#define IDH_117_8196    537133173   // -: "Game Controllers:" (Static)
#define IDH_117_8197    537198709   // -: "" (ListBox)
#define IDH_117_8198    537264245   // -: "Cha&nge..." (Button)
#define IDH_117_8199    537385268   // Advanced: OEM property sheet check box

#define IDH_119_1039    68092023    // Add Game Controller: "&Add Other..." (Button)
#define IDH_119_1049    68092025    // Add Game Controller: "&Custom..." (Button)
#define IDH_119_1059    69402743    // Add Game Controller: "&Controllers:" (Static)

#define IDH_4099_1043   68358147    // Custom Game Controller: "&Axes" (Button)
#define IDH_4099_1044   68358149    // Custom Game Controller: Rudder/Pedals (Button)
#define IDH_4099_1046   68358151    // Custom Game Controller: Z Axis (Button)
#define IDH_4099_1045   68685827    // Custom Game Controller: "" (ComboBox)
#define IDH_4099_1051   68882435    // Custom Game Controller: "Is a flight yoke/stick" (Button)
#define IDH_4099_1052   68947971    // Custom Game Controller: "Is a game pad" (Button)
#define IDH_4099_1053   69013507    // Custom Game Controller: "Is a race car controller" (Button)
#define IDH_4099_1054   69079043    // Custom Game Controller: "Has a &point of view control" (Button)
#define IDH_4099_1056   69210115    // Custom Game Controller: "" (Edit)
#define IDH_4099_1058   69410157    // Custom Game Controller: "Is a Joystick" (Button)

#define IDH_4201_1019   66785385    // Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)

#define IDH_8188_8189   536682492   // Change Controller Assignment: "Controller Assignment" (Button)
#define IDH_8188_8191   537010170   // Change Controller Assignment: "Selected ID" (ListBox) (Label?)
#define IDH_8188_8194   537010172   // Change Controller Assignment: "" (ListBox)

#define IDH_APPMAN_EXCLUDEDRIVE_INSTRUCTIONS		    2768L
#define IDH_APPMAN_RESTOREDEFAULTS_INSTRUCTIONS		  2767L
#define IDH_APPMAN_DISKUSAGE_SETTING_INSTRUCTIONS   2766L
#define IDH_VOICE_LIST_GAMES						            2765L
#define IDH_VOICE_DETAILS							              2764L

/*
#define IDH_117_1101    72155253    // -: "&Port Driver:" (Static)
#define IDH_101_1002    65667173    // Game Controllers: "&Properties..." (Button)
#define IDH_101_1022    65667180    // Game Controllers: "Refresh" (Button)
#define IDH_101_1010    66191461    // Game Controllers: "A&dd..." (Button)
#define IDH_101_1028    67371109    // Game Controllers: "&Remove..." (Button)
#define IDH_101_1058    69337189    // Game Controllers: "&Game Controllers" (Static)
#define IDH_117_1101    72155253    // -: "&Port Driver:" (Static)
#define IDH_117_8195    537067637   // -: "&Controller ID's:" (Static)
#define IDH_117_8196    537133173   // -: "Game Controllers:" (Static)
#define IDH_117_8197    537198709   // -: "" (ListBox)
#define IDH_117_8198    537264245   // -: "Cha&nge..." (Button)
#define IDH_119_1039    68092023    // Add Game Controller: "&Add Other..." (Button)
#define IDH_119_1049    68092025    // Add Game Controller: "&Custom..." (Button)
#define IDH_119_1059    69402743    // Add Game Controller: "&Controllers:" (Static)
#define IDH_4099_1043   68358147    // Custom Game Controller: "&Axes" (Button)
#define IDH_4099_1048   68685827    // Custom Game Controller: "" (ComboBox)
#define IDH_4099_1050   68816899    // Custom Game Controller: "&Special Characteristics" (Button)
#define IDH_4099_1051   68882435    // Custom Game Controller: "Is a flight yoke/stick" (Button)
#define IDH_4099_1052   68947971    // Custom Game Controller: "Is a game pad" (Button)
#define IDH_4099_1053   69013507    // Custom Game Controller: "Is a race car controller" (Button)
#define IDH_4099_1054   69079043    // Custom Game Controller: "Has a &point of view control" (Button)
#define IDH_4099_1056   69210115    // Custom Game Controller: "" (Edit)
#define IDH_4101_12293  805638149   // Joystick Calibration: "" (ListBox)
#define IDH_4101_12308  806621189   // Joystick Calibration: "" (ListBox)
#define IDH_4101_12309  806686725   // Joystick Calibration: "f" (Static)
#define IDH_4101_12328  807931909   // Joystick Calibration: "Capture &POV" (Button)
#define IDH_4101_12329  807997445   // Joystick Calibration: "< &Back" (Button)
#define IDH_4101_12330  808062981   // Joystick Calibration: "&Next >" (Button)
#define IDH_4101_12331  808062983   // Joystick Calibration: "&Finish" (Button)
#define IDH_4101_12334  808325125   // Joystick Calibration: "" (ListBox)
#define IDH_4101_12347  809177093   // Joystick Calibration: "" (ListBox)
#define IDH_4101_12349  809308165   // Joystick Calibration: "" (ListBox)
#define IDH_4201_1019   66785385    // Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)
#define IDH_4201_12291  805507177   // Settings: "&Calibrate..." (Button)
#define IDH_4202_12293  805638250   // Game Controller Calibration: "" (ListBox)
#define IDH_4202_12308  806621290   // Game Controller Calibration: "" (ListBox)
#define IDH_4202_12328  807932010   // Game Controller Calibration: "Set &POV" (Button)
#define IDH_4202_12334  808325226   // Game Controller Calibration: "" (ListBox)
#define IDH_4202_8199   537333866   // Game Controller Calibration: "Calibration Information" (Button)
#define IDH_4203_1023   67047531    // -: "Buttons" (Button)
#define IDH_4203_12293  805638251   // -: "" (ListBox)
#define IDH_4203_12308  806621291   // -: "" (ListBox)
#define IDH_4203_12309  806686827   // -: "" (POVHAT)
#define IDH_4203_12334  808325227   // -: "" (ListBox)
#define IDH_4203_12347  809177195   // -: "" (ListBox)
#define IDH_4203_12349  809308267   // -: "" (ListBox)
#define IDH_4203_12350  809308265   // -: "" (Listbox--Slider 1)
#define IDH_4203_12351  809308269   // -: "" (Listbox--Slider 2)
#define IDH_8188_8189   536682492   // Change Controller Assignment: "Controller Assignment" (Button)
#define IDH_8188_8191   537010170   // Change Controller Assignment: "Selected ID" (ListBox)
#define IDH_8188_8194   537010172   // Change Controller Assignment: "" (ListBox)
#define IDH_4099_1046   68358149    // 
#define IDH_4099_1044   68358151    //
#define IDH_101_1036    67548653    //
#define IDH_4099_1058   69410157    //
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\memlog.h ===
#include <windows.h>
#include <mmsystem.h>

#ifndef _DPLAY_SHARED_MEMLOG_
#define _DPLAY_SHARED_MEMLOG_

#define BASE_LOG_FILENAME  "DPLAYLOG-0"
#define BASE_LOG_MUTEXNAME "DPLAYLOGMUTEX-0"

#define DPLOG_NUMENTRIES	5000
#define DPLOG_ENTRYSIZE		120
#define DPLOG_SIZE (sizeof(SHARED_LOG_FILE)+((sizeof(LOG_ENTRY)+DPLOG_ENTRYSIZE)*DPLOG_NUMENTRIES))

//
// Globals for shared memory based logging
//
typedef struct _SHARED_LOG_FILE{
	CHAR	szAppName[16];
	DWORD   nEntries;
	DWORD	cbLine;
	DWORD 	iWrite;
	DWORD	cInUse;
	// followed by an array of LOGENTRIES.
}SHARED_LOG_FILE, *PSHARED_LOG_FILE;

typedef struct _LOG_ENTRY {
	DWORD	hThread;
	DWORD	tLogged;
	DWORD	DebugLevel;
	CHAR	str[0];
} LOG_ENTRY, *PLOG_ENTRY;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\main.cpp ===
/*
File:		main.cpp
Project:	Universal Joystick Control Panel OLE Client
Author:	Brycej
Date:		02/28/95
Comments:

Copyright (c) 1995, Microsoft Corporation
*/

//#pragma pack (8)

#include <afxcmn.h>
#include <cpl.h>

#include "cpanel.h"
#include "resource.h"
// Windows bug 578471 -- remove from server
//#include "creditst.h" // for the Credit Dialog!

#define JOYSTICK_CPL	0
#define MAX_CPL_PAGES 6

HINSTANCE ghInstance;

extern WCHAR *pwszTypeArray[MAX_DEVICES];
extern WCHAR *pwszGameportDriverArray[MAX_GLOBAL_PORT_DRIVERS];
extern WCHAR *pwszGameportBus[MAX_BUSSES];  // List of enumerated gameport buses 

extern BYTE nGamingDevices;  // Gaming Devices Enumeration Counter
extern BYTE nGameportDriver; // Global Port Driver Enumeration Counter
extern BYTE nGameportBus;    // Gameport Bus Enumeration Counter
extern short nFlags;              // State Flags the CPL defined in CPANEL.H

static void AddPage(LPPROPSHEETHEADER ppsh, short nTemplateID, int nTabID, DLGPROC pfn);

static void DoProperties(HWND hWnd, UINT nStartPage);
void WINAPI ShowJoyCPL(HWND);
void ParseArgs(HWND hDlg, LPTSTR lpArgList);
INT_PTR CALLBACK SplashDialogProc(HWND hDlg, ULONG uMsg, WPARAM wParam, LPARAM lParam);

// From AppMan.cpp
//extern HRESULT AppManInit();

// Windows bug 578471 -- remove from server
// From Retrocfg.cpp
//extern HRESULT  DVoiceCPLInit();
//extern INT_PTR CALLBACK  RetrofitProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
//extern INT_PTR RetrofitDestroyHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


BYTE nID, nStartPageDef, nStartPageCPL;


BOOL WINAPI DllMain(HANDLE  hModule, ULONG  uReason, LPVOID pv)
{
    switch( uReason )
    {
    case DLL_PROCESS_ATTACH:
        ghInstance = (HINSTANCE)hModule;

        // needed because CEdit will Assert without this line!!!
        afxCurrentInstanceHandle = ghInstance;
        afxCurrentResourceHandle = ghInstance;
        break;

//	case DLL_PROCESS_DETACH:
//		ClearArrays();

    case DLL_THREAD_ATTACH:
        DisableThreadLibraryCalls((HMODULE)hModule);
    case DLL_THREAD_DETACH:
        break;
    }
    return(TRUE);
}

/*
function:	CPlApplet()
comments:
    Entry point for control panel applets.
*/
LONG WINAPI CPlApplet(HWND  hWnd, UINT  uMsg, LPARAM  lParam1, LPARAM   lParam2)
{
    switch( uMsg )
    {
    case CPL_INIT:
        return(1);

    case CPL_GETCOUNT:
        return(1);

    case CPL_INQUIRE:
        ((LPCPLINFO)lParam2)->idIcon = IDI_CPANEL; 
        ((LPCPLINFO)lParam2)->idName = IDS_GEN_CPANEL_TITLE; 
        ((LPCPLINFO)lParam2)->idInfo = IDS_GEN_CPANEL_INFO; 
        ((LPCPLINFO)lParam2)->lData  = 0;
        return(1);

    case CPL_DBLCLK:
        nID = (NUMJOYDEVS<<1);

        // Applet icon double clicked -- invoke property sheet with
        // The first property sheet page on top.
        DoProperties(hWnd, 0);
        break;

        /*
         * This function requires Windows 2000. Not available on Win9x.
         */
    case CPL_STARTWPARMS:
        // Same as CPL_DBLCLK, but lParam2 is a long pointer to
        // a string of extra directions that are to be supplied to
        // the property sheet that is to be initiated.
        // The arguments are as follows:
        // @nCPLDialog Index, nStartPageCPL, nStartPageDef

        // Don't do anything if there are no arguments!
        if( *(LPTSTR)lParam2 )
            ParseArgs(hWnd, (LPTSTR)lParam2);
        return(TRUE);  // return non-zero to indicate message handled

    case CPL_EXIT:
    case CPL_STOP:
        break;
    }

    return(0);
}

/*
   Function: DoProperties(HWND hWnd, UINT nStartPage)
   Arguements: hWnd       - Handle to Main Window
               nStartPage - Page number to start
*/
static void DoProperties(HWND hWnd, UINT nStartPage)
{
    static HWND hPrevHwnd;
    static HANDLE hMutex = CreateMutex(NULL, TRUE, MUTEX_NAME);

    if( GetLastError() == ERROR_ALREADY_EXISTS )
    {
        SetForegroundWindow(hPrevHwnd); 
    } else
    {
        hPrevHwnd = hWnd;

        nFlags = (GetVersion() < 0x80000000) ? ON_NT : 0;

        HPROPSHEETPAGE  *pPages = new (HPROPSHEETPAGE[MAX_CPL_PAGES]);
        ASSERT (pPages);

        LPPROPSHEETHEADER ppsh = new (PROPSHEETHEADER);
        ASSERT(ppsh);

        ZeroMemory(ppsh, sizeof(PROPSHEETHEADER));

        ppsh->dwSize     = sizeof(PROPSHEETHEADER);
        ppsh->dwFlags    = PSH_NOAPPLYNOW | PSH_USEICONID;
        ppsh->hwndParent = hWnd;
        ppsh->hInstance  = ghInstance;
        ppsh->pszCaption = MAKEINTRESOURCE(IDS_GEN_CPANEL_TITLE);
        ppsh->pszIcon     = MAKEINTRESOURCE(IDI_CPANEL);
        ppsh->nStartPage = nStartPage;
        ppsh->phpage     = pPages;

        AddPage(ppsh, IDD_CPANEL,   IDS_GENERAL_TAB,  CPanelProc);
        AddPage(ppsh, IDD_ADVANCED, IDS_ADVANCED_TAB, AdvancedProc);

		// Windows bug 578471 -- remove from server
//		if( SUCCEEDED ( DVoiceCPLInit() )) {
//		  AddPage(ppsh, IDD_PROP_RETROFIT, IDS_DVOICE_TAB, RetrofitProc);
//		}

//		if( SUCCEEDED ( AppManInit() ) ) {
//			AddPage(ppsh, IDD_APPMAN,   IDS_APPMAN_TAB, AppManProc);
//			AddPage(ppsh, IDD_APPMAN_LOCKING, IDS_APPMANLOCK_TAB, AppManLockProc);
//		}

#ifdef SYMANTIC_MAPPER
        AddPage(ppsh, IDD_SMAPPER, ID_SMAPPER_TAB, SMapperProc);
#endif // SYMANTIC_MAPPER

        // trap for return...
        VERIFY(PropertySheet(ppsh) != -1);

        if( pPages )
            delete[] (pPages);

        if( ppsh )
            delete (ppsh);

        ReleaseMutex(hMutex);
        CloseHandle(hMutex);

		// Windows bug 578471 -- remove from server
        // Ensure voice is always cleaned up
        //RetrofitDestroyHandler( NULL, 0, 0, 0 );

        ClearArrays();
    }
}

static void AddPage(LPPROPSHEETHEADER ppsh, short nTemplateID, int nTabID, DLGPROC pfn)
{
    if( ppsh->nPages < MAX_CPL_PAGES )
    {
        LPPROPSHEETPAGE ppsp = new (PROPSHEETPAGE);
        ASSERT(ppsp);

        ZeroMemory(ppsp, sizeof(PROPSHEETPAGE));

        ppsp->dwSize      = sizeof(PROPSHEETPAGE);
        ppsp->pszTitle    = MAKEINTRESOURCE(nTabID);
        ppsp->hInstance   = ghInstance;
        ppsp->pfnDlgProc  = pfn;
        ppsp->pszTemplate = MAKEINTRESOURCE(nTemplateID);

        ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(ppsp);

        if( ppsp )
            delete (ppsp);

        if( ppsh->phpage[ppsh->nPages] )
            ppsh->nPages++;
    }
}  // AddPage


// DO NOT REMOVE THIS!!!
// This is here because the games group loads the CPL from the exported function
// If you remove this Hellbender, Monster Truck Maddness, CART, etc will fail to
// load the Joystick CPL!!!
// DO NOT REMOVE THIS!!!
void WINAPI ShowJoyCPL(HWND hWnd)
{
    nID = (NUMJOYDEVS<<1);

    DoProperties(hWnd, 0);
}

void LaunchExtention(HWND hWnd)
{
    // These are defined in CPANEL.CPP
    extern LPDIRECTINPUT lpDIInterface;
    extern IDirectInputJoyConfig* pDIJoyConfig;

    HRESULT hr =  DirectInputCreate(ghInstance, DIRECTINPUT_VERSION, &lpDIInterface, NULL);

    if( FAILED(hr) ) return;

    // Call CreateJoyConfigInterface!
    if( SUCCEEDED(lpDIInterface->QueryInterface(IID_IDirectInputJoyConfig, (LPVOID*)&pDIJoyConfig)) )
    {
        // Create a pJoy and populate it's GUID from GetTypeInfo
        PJOY pJoy = new (JOY);
        ASSERT (pJoy);

        pJoy->ID = nID;

        DIJOYCONFIG_DX5 JoyConfig;

        JoyConfig.dwSize = sizeof (DIJOYCONFIG_DX5);

        if( SUCCEEDED(pDIJoyConfig->GetConfig(nID, (LPDIJOYCONFIG)&JoyConfig, DIJC_REGHWCONFIGTYPE)) )
        {
            LPDIJOYTYPEINFO_DX5 pdiJoyTypeInfo = new (DIJOYTYPEINFO_DX5);
            ASSERT (pdiJoyTypeInfo);

            pdiJoyTypeInfo->dwSize = sizeof (DIJOYTYPEINFO_DX5);

            hr = pDIJoyConfig->GetTypeInfo(JoyConfig.wszType, (LPDIJOYTYPEINFO)pdiJoyTypeInfo, DITC_CLSIDCONFIG);

            if( !IsEqualIID(pdiJoyTypeInfo->clsidConfig, GUID_NULL) )
                pJoy->clsidPropSheet = pdiJoyTypeInfo->clsidConfig;

            if( pdiJoyTypeInfo )
                delete (pdiJoyTypeInfo);

        }

        if( SUCCEEDED(hr) )
            Launch(hWnd, pJoy, nStartPageDef);

        if( pJoy )
            delete (pJoy);

        // release the DI JoyConfig interface pointer
        if( pDIJoyConfig )
        {
            pDIJoyConfig->Release();
            pDIJoyConfig = 0;
        }
    }

    // release the DI Device interface pointer
    if( lpDIInterface )
    {
        lpDIInterface->Release();
        lpDIInterface = 0;
    }
}

void ParseArgs(HWND hDlg, LPTSTR lpArgList)
{
    BOOL bShowCPL = TRUE;

    // Check for '-', as they may not want to show the CPL!
    if( *lpArgList == '-' )
    {
        bShowCPL = FALSE;
        *lpArgList++;
    }

    nStartPageCPL = nStartPageCPL = nStartPageDef = 0;

    // parse command line for nStartPageCPL!
    while( *lpArgList && (*lpArgList != ',') )
    {
        nStartPageCPL *= 10;
        nStartPageCPL += *lpArgList++ - '0';
    }

    // check to make sure nStartPageCPL is within range!
    if( bShowCPL ) {
        if( nStartPageCPL > MAX_CPL_PAGES )
        {
#ifdef _DEBUG
            OutputDebugString(TEXT("JOY.CPL: Command line requested an invalid start page, reset to default!\n"));
#endif      
            // NUMJOYDEVS is used to send the user to the Add dialog on start-up!
            if( nStartPageCPL != NUMJOYDEVS )
                nStartPageCPL = 0;
        }
    }

        // Only continue if you have something further to parse!
    if( *lpArgList == ',' )
    {
        *lpArgList++;

        nID = 0;

        // Parse for ID's
        while( *lpArgList && (*lpArgList != ',') )
        {
            nID *= 10;
            nID += *lpArgList++ - '0';
        }

        // Check for error cases!
        if( (nID < 1) || (nID > NUMJOYDEVS) )
        {
#ifdef _DEBUG
            OutputDebugString(TEXT("JOY.CPL: Command line Device ID out of range!\n"));
#endif
            nID = (NUMJOYDEVS<<1);

            return;
        }

        // Decrement to internal zero based ID
        nID--;

        // Don't parse what you don't have!
        if( *lpArgList == ',' )
        {
            *lpArgList++;

            // Lastly, parse for nStartPageDef!
            while( *lpArgList && (*lpArgList != ',') )
            {
                nStartPageDef *= 10;
                nStartPageDef += *lpArgList++ - '0';
            }
        }
    } else {
        nID = (NUMJOYDEVS<<1);
    }

    // Done with the parsing...
    // Time to get to work!

    // if we're not showing the CPL...
    if( !bShowCPL )
    {
        // check to make sure the next value is a 1
        // we may want to have further negative arguments :)
        switch( nStartPageCPL )
        {
        case 1:
            // Invalid ID...
            if( nID > NUMJOYDEVS ) return;
            LaunchExtention(hDlg);
            break;

#ifdef WE_CAN_HAVE_CREDITS
        case 60:
            // If they ask for the splash, they don't get the CPL!
            DialogBox( ghInstance, (PTSTR)IDD_SPLASH, hDlg, SplashDialogProc );
            break;
#endif
            
        }

    } else {
        DoProperties(NULL, nStartPageCPL); 
    }
}


#ifdef WE_CAN_HAVE_CREDITS
INT_PTR CALLBACK SplashDialogProc(HWND hDlg, ULONG uMsg, WPARAM wParam, LPARAM lParam)
{
    static CCreditStatic *pStatic;

    switch( uMsg )
    {
    case WM_INITDIALOG:
        {
            pStatic = new (CCreditStatic);
            ASSERT (pStatic);

            CWnd *pCWnd = new (CWnd);
            ASSERT (pCWnd);

            pCWnd->Attach(hDlg);

            pStatic->SubclassDlgItem(IDC_MYSTATIC, pCWnd);

            if( pCWnd )
            {
                pCWnd->Detach();
                delete (pCWnd);
                pCWnd = 0;
            }

            LPTSTR lpStr = new (TCHAR[MAX_STR_LEN]);
            ASSERT (lpStr);

            // The Credits come in two lines!
            BYTE nStrLen = (BYTE)LoadString(ghInstance, IDS_SPLASH, lpStr, MAX_STR_LEN);
            LoadString(ghInstance, IDS_SPLASH1, &lpStr[nStrLen], MAX_STR_LEN-nStrLen);

            pStatic->SetCredits(lpStr);

            if( lpStr )
            {
                delete[] (lpStr);
                lpStr = 0;
            }

            pStatic->StartScrolling();
        }
        return(TRUE);  // return TRUE unless you set the focus to a control
        // EXCEPTION: OCX Property Pages should return FALSE}

    case WM_COMMAND:
        switch( LOWORD(wParam) )
        {
        case IDOK:
            EndDialog(hDlg, LOWORD(wParam));
            break;
        }
        break;

//		case WM_TIMER:
        //SendDlgItemMessage(hDlg, IDC_STATIC, WM_TIMER, 0, 0);
//			pStatic->OnTimer(150); //DISPLAY_TIMER_ID
//			break;

    case WM_DESTROY:
        if( pStatic )
        {
            delete (pStatic);
            pStatic = 0;
        }
        break;
    }     

    return(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by gcmain.rc
//
#define IDD_CPANEL                      101
#define IDI_CPANEL                      102
#define IDD_PROPSHEET                   103
#define IDD_ASSIGN                      104
#define IDI_NOTCONNECTED                108
#define IDI_JOYSTICK                    110
#define IDR_MENU1                       116
#define IDD_ADVANCED                    117
#define IDD_ADD                         119
#define IDD_SMAPPER                     122
#define IDB_JOYSTICK                    126
#define IDD_MOREINFO                    127
#define IDI_CHECKBOX_EMPTY              131
#define IDD_DVOICE                      131
#define IDI_CHECKBOX_FULL               132
#define IDD_PROP_RETROFIT               133
#define IDS_DVOICE_TAB                  134
#define IDD_WIZARD_CANCELED             135
#define IDD_WIZARD_LAUNCH               136
#define IDD_VOICE_ENABLED               137
#define IDI_LIST_DEFAULT                138
#define IDD_CONFIRM_HALFDUPLEX          139
#define IDD_CONFIRM_SOUNDINITFAILURE    140
#define IDD_WIZARD_ERROR                141
#define IDD_DETAILS                     143
#define IDD_PREV_HALFDUPLEX             144
#define IDD_APPMAN_MORE_INFO            145
#define IDD_UPDATE                      146
#define IDC_COMBO1                      1000
#define IDC_TEXT_HELP                   1001
#define IDC_BTN_PROPERTIES              1002
#define IDC_BTN_SETTINGS                1003
#define IDC_BTN_TEST                    1004
#define IDC_TAB                         1005
#define IDC_BTN_APPLY                   1006
#define IDC_BTN_TSHOOT                  1007
#define IDC_TEXT_DEVICE                 1008
#define IDC_BTN_REFRESH                 1009
#define IDC_BTN_ASSIGN                  1010
#define IDC_BTN_ADD                     1011
#define IDC_COMBO_JOYSTICKID            1012
#define IDS_TSHOOT_CMD                  1013
#define IDC_BTN_UPDATE                  1014
#define IDC_LIST_DEVICE                 1020
#define IDC_TEXT_DEVICELIST             1025
#define IDC_TEXT_IDLIST                 1026
#define IDC_BTN_REMOVE                  1028
#define IDC_COMBO_AXIS                  1030
#define IDC_TEXT_TITLE                  1031
#define IDC_TEXT_DRIVER                 1032
#define IDC_TEXT_LBTAG                  1033
#define IDC_ADD_STR1                    1037
#define IDC_ADD_STR2                    1038
#define IDC_ADD_NEW                     1039
#define IDS_ADV_TITLE                   1039
#define IDS_ADV_GLOBAL_DESC             1040
#define IDS_ADV_GLOBAL_TAG              1041
#define IDS_ADV_DEVICE_HEADING          1042
#define IDC_AXES_GROUP                  1043
#define IDC_AXES2                       1044
#define IDC_AXES3                       1045
#define IDC_AXES4                       1046
#define IDC_BUTTONS_GROUP               1047
#define IDC_COMBO_BUTTONS               1048
#define IDC_SPECIAL_GROUP               1049
#define IDC_SPECIAL_CHECK               1050
#define IDC_SPECIAL_YOKE                1051
#define IDC_SPECIAL_PAD                 1052
#define IDC_SPECIAL_AUTO                1053
#define IDC_SPECIAL_JOYSTICK            1054
#define IDC_CUSTOM_NAME                 1055
#define IDC_EDIT_NAME                   1056
#define IDC_DEVICE_LIST                 1057
#define IDC_LIST_HEADING                1058
#define IDS_ADD_DESC                    1059
#define IDS_ADD_NEW_DESC                1060
#define IDS_ADD_NEW                     1061
#define IDS_CUSTOM_TITLE                1062
#define IDS_CUSTOM_AXES_GROUP           1063
#define IDS_CUSTOM_2AXES                1064
#define IDS_CUSTOM_3AXES                1065
#define IDS_CUSTOM_4AXES                1066
#define IDS_CUSTOM_BUTTONS_GROUP        1067
#define IDS_CUSTOM_SPECIAL              1068
#define IDS_CUSTOM_ISFLIGHTYOKE         1069
#define IDS_CUSTOM_ISGAMEPAD            1070
#define IDS_CUSTOM_ISRACECAR            1071
#define IDS_CUSTOM_HASPOV               1072
#define IDS_CUSTOM_NAME                 1073
#define IDS_CUSTOM_BUTTONS              1074
#define IDS_GEN_CPANEL_TITLE            1076
#define IDS_GENERAL_TAB                 1077
#define IDC_ADV_USEOEMPAGE              1078
#define IDS_ADVANCED_TAB                1079
#define IDS_NONE                        1080
#define IDC_SCROLLBAR1                  1081
#define IDC_SPIN1                       1083
#define IDS_ADV_DEVICE_FRIENDLY         1084
#define IDC_DATETIMEPICKER1             1085
#define IDC_SW_HACK                     1086
#define IDS_ADD_DEVICE_LIST_TAG         1091
#define IDS_OK                          1092
#define IDS_CANCEL                      1093
#define IDS_ADD_TITLE                   1094
#define IDS_NO_IDS                      1095
#define IDS_NO_IDS_TITLE                1096
#define IDS_NO_NAME                     1097
#define IDS_NO_NAME_TITLE               1098
#define IDS_GEN_CPANEL_INFO             1099
#define IDC_POLLFLAGS                   1100
#define IDC_TEXT_PORTDRIVER             1101
#define IDS_NO_GAMEPORT                 1102
#define IDS_NO_GAMEPORT_TITLE           1103
#define IDS_ADV_STATUS_HEADING          1143
#define IDS_ADV_STD_GAMEPORT            1144
#define IDS_WHATSTHIS                   1145
#define IDS_GEN_PROPERTIES              1146
#define IDS_GEN_REMOVE                  1147
#define IDS_GEN_ADD                     1148
#define IDS_GEN_LIST_HEADING            1149
#define IDS_GEN_TEXT_HELP               1150
#define IDS_GEN_DEVICE_HEADING          1151
#define IDS_GEN_STATUS_HEADING          1152
#define IDS_GEN_AREYOUSURE              1153
#define IDC_VIEW_CTRL                   1154
#define IDS_GEN_STATUS_OK               1155
#define IDS_GEN_STATUS_NOTCONNECTED     1157
#define IDS_GEN_STATUS_NOFORCES         1158
#define IDC_DEVICE_LIST_TAG             1159
#define IDC_ADV_GRP                     1161
#define IDC_ADV_GRP2                    1162
#define IDC_GEN_INTRO                   1164
#define IDC_GEN_ICON                    1166
#define IDC_GAMEPORT                    1167
#define IDC_GAMEPORTLIST                1168
#define IDC_CUSTOM                      1169
#define IDS_ADV_GAME_CONTROLLERS        1170
#define IDC_HASRUDDER                   1172
#define IDC_HASZAXIS                    1174
#define IDC_ADV_OEMSHEET                1175
#define IDC_WDM                         1176
#define IDS_ADV_DEVICE_PORT             1177
#define IDS_NOAVAILABLEVIDPID           1178
#define IDS_GAMES_COLUMN_HEADER         1188
#define IDS_ENABLED_COLUMN_HEADER       1189
#define IDS_GEN_AREYOUSURE_TITLE        1254
#define IDC_MOREINFO                    1280
#define IDC_INFO_ICON                   1300
#define IDC_ICON_NOTCOMPLETE            1301
#define IDC_ICON_INFORMATION            1302
#define IDC_ICON_WARNING                1303
#define IDC_ICON_ERROR                  1304
#define IDC_DETAILS                     1305
#define IDC_WARNING_ICON                1306
#define IDC_RUNTEST                     1307
#define IDC_VOICECHATTEXT               1308
#define IDC_GAMESLISTHOTKEY             1309
#define IDC_VOICECHATGROUP              1310
#define IDD_CUSTOM                      4099
#define IDD_ADV_CHANGE                  8188
#define IDC_CHANGE_BOARDER              8189
#define IDD_APPMAN_ADV                  8189
#define IDD_APPMAN_LOCKING              8189
#define IDC_SELECTEDID                  8190
#define IDD_APPMAN_ADVUSER              8191
#define IDC_CHANGEID                    8192
#define IDC_ASSIGNTXT                   8193
#define IDC_LISTTXT                     8194
#define IDC_CHANGE_LIST                 8195
#define IDS_DEVICEID                    8196
#define IDS_CONTROLLERS                 8197
#define IDC_ADV_LIST_DEVICE             8198
#define IDC_ADV_CHANGE                  8199
#define IDC_GROUPBOX                    8300
#define IDS_CONTROLLERID                8301
#define IDC_GROUPBOX_2                  8302
#define IDC_GROUPBOX_3                  8303
#define IDS_ADV_CHANGE                  8304
#define IDS_CUSTOM_STRING               8305
#define IDC_JOYHASPOV                   12322
#define IDC_JOYISYOKE                   12323
#define IDC_JOYISGAMEPAD                12324
#define IDC_JOYISCARCTRL                12325
#define IDC_JOY2BUTTON                  12326
#define IDC_JOY4BUTTON                  12327
#define IDC_JOYUSESPECIAL               12332
#define IDC_JOY2AXIS                    12336
#define IDC_JOY3AXIS                    12337
#define IDC_JOY4AXIS                    12338
#define IDC_BTN_DIAG                    40001
#define IDS_HELPFILENAME                40002
#define IDS_DUPLICATE_TYPE              40003
#define IDS_DUPLICATE_TYPE_TITLE        40004
#define IDS_INVALID_NAME                40005
#define IDS_INVALID_NAME_TITLE          40006
#define IDS_INTERNAL_ERROR              40007
#define IDS_NO_DIJOYCONFIG              40008
#define IDS_NO_GAMENUM                  40009
#define IDS_NO_GAMENUM_TITLE            40010
#define IDC_SEPERATOR                   40011
#define IDS_MAX_DEVICES_TITLE           40012
#define IDS_MAX_DEVICES_MSG             40013
#define IDS_NO_REMOVE                   40014
#define IDS_RENAME                      40016
#define IDC_RENAME                      40017
#define IDS_DONE                        40018
#define IDS_REFRESH                     40019
#define IDC_JOY1HASRUDDER               40022
#define IDC_SPIN                        40023
#define IDC_SPINBUDDY                   40024
#define IDS_ADD_PORT_MSGFORMAT          40025
#define IDS_ADD_PORT_OCCUPIED           40026
#define IDS_GEN_STATUS_UNKNOWN          40027
#define IDS_GEN_NO_REMOVE_USB           40028
#define IDS_WDMJOY                      40029
#define IDS_AUTO_DETECT                 40030
#define IDS_USER_MODE                   40031
#define IDS_USER_MODE_TITLE             40032
#define IDS_WDMJOY_INF                  40033
#define IDC_MYSTATIC                    40034
#define IDS_NO_RENAME                   40035
#define IDS_NO_RENAME_TITLE             40036
#define IDS_GAMEPORT_OCCUPIED           40037
#define IDS_GAMEPORT_OCCUPIED_TITLE     40038
#define IDS_DEST_ID_OCCUPIED            40039
#define IDS_DEST_ID_OCCUPIED_TITLE      40040
#define IDS_VOICEMOREINFO               40046
#define IDC_PEAKMETER                   41008
#define IDC_P1                          41013
#define IDC_P2                          41014
#define IDC_P3                          41015
#define IDC_WELCOME_IMAGE               41016
#define IDC_COMPLETE_IMAGE              41021
#define IDC_TITLE                       41022
#define IDC_PROGRESSBAR                 41023
#define IDC_RADIO_EXTERNAL              41024
#define IDC_RADIO_HEADSET               41025
#define IDC_COMPLETE_FAILED_GRAPHIC     41026
#define IDC_P4                          41027
#define IDC_DIVIDER                     41028
#define IDC_P5                          41029
#define IDC_LIST_GAMES                  41034
#define IDC_TEST_DEVICES                41042
#define IDC_VOICE_DEVICES               41043
#define IDC_GROUP1                      41044
#define IDC_GROUP2                      41045
#define IDS_UPDATE_SITEDIR              41046
#define IDS_UPDATE_INI                  41047
#define IDS_UPDATE_LASTUPDATED          41048
#define IDS_UPDATE_NOTCONNECTED_TITLE   41049
#define IDS_UPDATE_NOTCONNECTED         41050
#define IDS_UPDATE_FTP_ERROR            41051
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        147
#define _APS_NEXT_COMMAND_VALUE         41052
#define _APS_NEXT_CONTROL_VALUE         1311
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>       
#include <afxext.h>       
#include <afxcmn.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mfccpl.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\res\dijoy.h ===
#define IDH_101_1002	65667173	// Game Controllers: "&Properties..." (Button)
#define IDH_101_1022	65667180	// Game Controllers: "Refresh" (Button)
#define IDH_101_1010	66191461	// Game Controllers: "A&dd..." (Button)
#define IDH_101_1028	67371109	// Game Controllers: "&Remove..." (Button)
#define IDH_101_1036	67548653	// Game Controllers: "Troubleshoot..." (Button)
#define IDH_101_1058	69337189	// Game Controllers: "&Game Controllers" (Static)
#define IDH_117_1101	72155253	// -: "&Port Driver:" (Static)
#define IDH_117_8197	537198709	// -: "" (ListBox)
#define IDH_117_8198	537264245	// -: "Cha&nge..." (Button)
#define IDH_117_8199	537385268	// Advanced: OEM property sheet check box
#define IDH_119_1039	68092023	// Add Game Controller: "&Add Other..." (Button)
#define IDH_119_1049	68092025	// Add Game Controller: "&Custom..." (Button)
#define IDH_119_1059	69402743	// Add Game Controller: "&Controllers:" (Static)
#define IDH_4099_1043	68358147	// Custom Game Controller: "&Axes" (Button)
#define IDH_4099_1044	68358149	// Custom Game Controller: Rudder/Pedals (Button)
#define IDH_4099_1046	68358151	// Custom Game Controller: Z Axis (Button)
#define IDH_4099_1045	68685827	// Custom Game Controller: "" (ComboBox)
#define IDH_4099_1051	68882435	// Custom Game Controller: "Is a flight yoke/stick" (Button)
#define IDH_4099_1052	68947971	// Custom Game Controller: "Is a game pad" (Button)
#define IDH_4099_1053	69013507	// Custom Game Controller: "Is a race car controller" (Button)
#define IDH_4099_1056	69210115	// Custom Game Controller: "" (Edit)
#define IDH_4099_1058	69410157	// Custom Game Controller: "Is a Joy stick" (Button)
#define IDH_4201_1019	66785385	// Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)
#define IDH_4201_12290	805507175	// Settings: "Reset to &default" (Button)
#define IDH_4201_12291	805507177	// Settings: "&Calibrate..." (Button)
#define IDH_4203_1023	67047531	// -: "Buttons" (Button)
#define IDH_4203_12293	805638251	// -: "" (ListBox) (X/Y test box)
#define IDH_4203_12308	806621291	// -: "" (ListBox) (all other test boxes)
#define IDH_4203_12309	806686827	// -: "" (POVHAT)
#define IDH_8188_8189	536682492	// Change Controller Assignment: "Controller Assignment" (Button)
#define IDH_8188_8191	537010170	// Change Controller Assignment: "Selected ID" (ListBox) (Label?)
#define IDH_8188_8194	537010172	// Change Controller Assignment: "" (ListBox)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\client\sources.inc ===
!IFNDEF DXROOT
DXROOT = $(BASEDIR)\MultiMedia\DirectX
!ENDIF

!INCLUDE $(DXROOT)\Project.mk

#
#   Use an empty binplace file to dump this version in the Windows build
#
!IFNDEF TARGET_WIN95
!IFNDEF DIRECTX_REDIST
BINPLACE_PLACEFILE=..\..\noplace.txt
!ENDIF
!ENDIF

LINKER_STACKSIZE=-STACK:4096,1024

MAJORCOMP=shell
MINORCOMP=accessory

TARGETNAME=joy
TARGETEXT=cpl
TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows

DLLENTRY=DllMain


# Need to define IE_VERSION as 0x300, otherwise, joy.cpl won't launch in Win95 gold.
!IFDEF TARGET_WIN95
WIN32_IE_VERSION=0x0300
!ENDIF


#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\ole32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\uuid.lib     \
           $(SDK_LIB_PATH)\dinput.lib   \
           $(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib   \
           $(SDK_LIB_PATH)\gdi32.lib    \
           $(SDK_LIB_PATH)\comctl32.lib \
           $(SDK_LIB_PATH)\winmm.lib \
           $(SDK_LIB_PATH)\shell32.lib \
           $(SDK_LIB_PATH)\setupapi.lib \
           $(SDK_LIB_PATH)\wininet.lib 
           

INCLUDES=$(INCLUDES);                       \
     ..;                                    \
     ..\..\handler;                         \
     ..\..\default;                         \
     $(DXROOT)\inc;                         \
     $(SDK_INC_PATH)\MFC42;  


SOURCES=\
    ..\gcmain.rc    \
    ..\add.cpp      \
    ..\advanced.cpp \
    ..\cpanel.cpp   \
    ..\main.cpp     \
    ..\inplace.cpp  \
	..\guids.cpp \
	..\guidutil.cpp 

DLLDEF=..\joy.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\gamectrl\clientnt\core.cpp ===
/****************************************************************************
 *
 *  Copyright (C) 2000, 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  Author:     Tomislav Markoc, (tmarkoc), SDE
 *
 ****************************************************************************/

#include <windows.h>
#include <commctrl.h>//UI only
#include <shfusion.h>//UI only
#define _INC_MMSYSTEM
#define WINMMAPI    DECLSPEC_IMPORT
typedef UINT        MMRESULT;   /* error return code, 0 means no error */
                                /* call as if(err=xxxx(...)) Error(err); else */
// end of hack to avoid including mmsystem.h!!!
#include <gameport.h>
#include <dinput.h>
#include <dinputd.h>
#include <list>
#include <exception>
#include <string>
#include <algorithm>
#include <tchar.h>
#include <windowsx.h>
#include <regstr.h>
#include <new.h>
#include "resource.h"
#include "ifacesvr.h"
#include "joyarray.h"

using namespace std;

#define NUMJOYDEVS 16//Max joy id-s. Why is this hardcoded?
#define MAX_DEVICES 75
#define IDC_WHATSTHIS 400

#ifdef UNICODE
#define String  wstring
#else
#define String  string
#endif // !UNICODE

#ifdef _CHECKED
#define JOY_EXCEPTION(A) JoyException(_T(__FILE__),__LINE__,A)
#else
#define JOY_EXCEPTION(A) JoyException(A)
#endif

#define cA(a) (sizeof(a)/sizeof(a[0]))

class JoyException:public exception
{
    HRESULT m_hRes;
#ifdef _CHECKED
    String m_SourceFile;
    DWORD m_dwLine;
#endif
public:
    HRESULT GetResult(){return m_hRes;};
    JoyException(
#ifdef _CHECKED
        LPCTSTR lpSourceFile,DWORD dwLine,
#endif
        HRESULT hRes);
};

JoyException::JoyException(
#ifdef _CHECKED
    LPCTSTR lpSourceFile,DWORD dwLine,
#endif
    HRESULT hRes)
{
    m_hRes=hRes;
#ifdef _CHECKED
    m_SourceFile=lpSourceFile;
    m_dwLine=dwLine;
#endif
}

int __cdecl my_new_handler(size_t) {
throw JOY_EXCEPTION(E_OUTOFMEMORY);
return 0;
}

template <class p> class AutoRelease
{
    p m_p;
public:
    AutoRelease(){m_p=NULL;};
    ~AutoRelease(){Clear();};
    void Clear(){
        ULONG nRef=-1;
        if(m_p)
        {
            nRef=m_p->Release();//If last ptr, nRef falls to 0.
        };
        m_p=NULL;};

    AutoRelease(const AutoRelease<p> &R)
        {m_p=R.m_p;m_p->AddRef();};
    AutoRelease<p> &operator=(const AutoRelease<p> &R)
        {m_p=R.m_p;m_p->AddRef();return *this;};
    AutoRelease<p> &operator=(p ptr)
        {m_p=ptr;if(m_p)m_p->AddRef();return *this;};
    p operator->(){return m_p;};
    operator p&(){return m_p;};
    operator p*(){return &m_p;};
};
typedef AutoRelease<LPDIRECTINPUT8> LPDIRECTINPUT_AR;
typedef AutoRelease<LPDIRECTINPUTDEVICE8> LPDIRECTINPUTDEVICE_AR;
typedef AutoRelease<LPDIRECTINPUTJOYCONFIG8> LPDIRECTINPUTJOYCONFIG_AR;

template <class p> class AutoDeleteArray
{
    p m_p;
public:
    AutoDeleteArray(){m_p=NULL;};
    AutoDeleteArray(const p P){m_p=P;};
    ~AutoDeleteArray(){delete[] m_p;};
    p operator=(const p P){m_p=P;return m_p;};
    p operator->(){return m_p;};
    operator p&(){return m_p;};
    operator p*(){return &m_p;};
};

enum EStatus{EConnected,ENotConnected,EUnknown};

//ISSUE-2001/03/29-timgill Should use predefined NULLGUID
const GUID NULLGUID;

class CCore;
class CDIDev
{
friend BOOL CALLBACK DIEnumDevicesProc(
    const DIDEVICEINSTANCE * lpddi,LPVOID pvRef);

    LPDIRECTINPUTDEVICE_AR m_pDID;
    DIDEVICEINSTANCE m_DIDevInst;
    DIDEVCAPS_DX3 m_DIDevCaps;
    DIJOYCONFIG m_DIJoyCfg;
    DWORD m_dwId;

    bool m_bInitialized;
    CCore *m_pCore;
public:
    CDIDev(){m_bInitialized=false;};
    DWORD Id(){return m_dwId;};
    const GUID &InstGUID(){return m_DIDevInst.guidInstance;};
    const GUID &PortGUID(){return m_DIJoyCfg.guidGameport;};
    LPCTSTR InstName(){return m_DIDevInst.tszInstanceName;};
    EStatus Status(){if(m_DIDevCaps.dwFlags&DIDC_ATTACHED)return EConnected;return ENotConnected;};
    void Update(LPDIRECTINPUTJOYCONFIG8 pJoyCfg);
    HRESULT Rename(LPCTSTR pName);
    bool operator==(const GUID &G){if(InstGUID()==G)return true;return false;};
};

class CGprtDev
{
friend BOOL CALLBACK DIEnumJoyTypePr(LPCWSTR pwszTypeName,LPVOID pvRef);
friend class CCore;
    String m_Name;
    DIJOYTYPEINFO m_Info;
public:
    LPCTSTR TypeName(){return m_Name.data();};
    LPCTSTR Name(){return m_Info.wszDisplayName;};
    bool operator==(LPCTSTR pTypeName){if(m_Name==pTypeName)return true;return false;};
    bool Rudder(){if(m_Info.hws.dwFlags&JOY_HWS_HASR)return true;return false;};
};

typedef list<CDIDev> LISTDIDEV;
typedef list<String> LISTSTRING;
typedef list<CGprtDev> LISTGPRTDEV;

class CCore
{
friend HRESULT Properties(HMODULE hMod,HWND hWnd,CCore *pCore,DWORD dwId);
friend BOOL CALLBACK DIEnumJoyTypePr(LPCWSTR pwszTypeName,LPVOID pvRef);
friend class CDIDev;
friend BOOL CALLBACK DIEnumDevicesProc(const DIDEVICEINSTANCE *lpddi,LPVOID pvRef);

    bool m_bAccess;
    bool m_bInitialized;

    virtual void UIUpdate(){};
    LPDIRECTINPUT_AR m_pDI;
    LPDIRECTINPUTJOYCONFIG_AR m_pDIJoyCfg;

    int GetNextAvailableId();
    bool FullJoyOemAccess();
public:
    LISTDIDEV m_ListDIDev;
    LISTSTRING m_GprtDrv;
    LISTGPRTDEV m_GprtBus;
    LISTGPRTDEV m_GprtDev;

    CCore();
    void Initialize(HWND hWnd);
    void Update();
    void UpdateType();
    bool Access(){return m_bAccess;};
    CDIDev *FindDIDev(GUID &G);
    HRESULT Remove(GUID &G);
    void Preferred(GUID &G);
    HRESULT AddDevice
            (LPCTSTR pTypeName,bool bRudder,LPCTSTR pGprtId,GUID &GOccupied);
    bool IsAutoDetectGprt();
    bool IsAvailableVIDPID(String &VIDPIDName);
    bool DuplicateDeviceName(LPCTSTR pName);
    void AddCustomDevice(bool bJoy,bool bPad,bool bYoke,bool bCar,
             int nAxes,bool bZAxis,int nButtons,bool bHasPov,LPCTSTR pName,
             LPCTSTR pVIDPIDName);
    bool IsCustomDevice(LPCTSTR pTypeName);
    bool IsDeviceActive(LPCTSTR pTypeName);
    void DeleteType(LPCTSTR pTypeName);
    CGprtDev *FindGprtDev(LPCTSTR pTypeName);
};

struct SEnumDev
{
    LPDIRECTINPUT8 m_pDI;
    CCore *m_pCore;
    SEnumDev(LISTDIDEV &ListDIDev,LPDIRECTINPUT8 pDI,CCore *pCore)
        {m_pDI=pDI;m_pCore=pCore;};
};

/******************************************************************************
End of header
******************************************************************************/


/******************************************************************************
CDIDev
******************************************************************************/

HRESULT CDIDev::Rename(LPCTSTR pName)
{
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
    if(!m_pCore->Access())return DIERR_INSUFFICIENTPRIVS;

    DIPROPSTRING DIPropString;
    ZeroMemory(&DIPropString,sizeof(DIPROPSTRING));
    DIPropString.diph.dwSize=sizeof(DIPROPSTRING);
    DIPropString.diph.dwHeaderSize=sizeof(DIPROPHEADER);
    DIPropString.diph.dwHow=DIPH_DEVICE;
    wcsncpy(DIPropString.wsz,pName,MAX_PATH-1);
    DIPropString.wsz[MAX_PATH-1]=0;
    HRESULT hRes=m_pDID->SetProperty(DIPROP_INSTANCENAME,&DIPropString.diph);
    Update(m_pCore->m_pDIJoyCfg);
    return hRes;
}

void CDIDev::Update(LPDIRECTINPUTJOYCONFIG8 pJoyCfg)
{
    HRESULT hRes=S_OK;

    ZeroMemory(&m_DIDevInst,sizeof(m_DIDevInst));
    m_DIDevInst.dwSize=sizeof(m_DIDevInst);
    hRes=m_pDID->GetDeviceInfo(&m_DIDevInst);
    if(FAILED(hRes))
    {
        throw JOY_EXCEPTION(hRes);
    }

    ZeroMemory(&m_DIDevCaps,sizeof(m_DIDevCaps));
    m_DIDevCaps.dwSize=sizeof(m_DIDevCaps);
    hRes=m_pDID->GetCapabilities((LPDIDEVCAPS)&m_DIDevCaps);
    if(FAILED(hRes))
    {
        throw JOY_EXCEPTION(hRes);
    }

    //Get Id.
    m_dwId=-1;
    DIPROPDWORD DIPropDW;
    ZeroMemory(&DIPropDW,sizeof(DIPropDW));
    DIPropDW.diph.dwSize=sizeof(DIPROPDWORD);
    DIPropDW.diph.dwHeaderSize=sizeof(DIPROPHEADER);
    DIPropDW.diph.dwHow=DIPH_DEVICE;
    hRes=m_pDID->GetProperty(DIPROP_JOYSTICKID,&DIPropDW.diph);
    if(FAILED(hRes))
    {
        throw JOY_EXCEPTION(hRes);
    }
    m_dwId=DIPropDW.dwData;

    //Get gameport.
    ZeroMemory(&m_DIJoyCfg,sizeof(m_DIJoyCfg));
    m_DIJoyCfg.dwSize=sizeof(m_DIJoyCfg);
    hRes=pJoyCfg->GetConfig(m_dwId,&m_DIJoyCfg,DIJC_WDMGAMEPORT);
    if(FAILED(hRes))
    {
        //throw JOY_EXCEPTION(hRes);
    }
}

/******************************************************************************
CCore
******************************************************************************/

BOOL CALLBACK DIEnumDevicesProc(
    const DIDEVICEINSTANCE *lpddi,LPVOID pvRef)
{
    try
    {
        SEnumDev &ED=*(SEnumDev*)pvRef;

        CDIDev Dev;
        Dev.m_pCore=ED.m_pCore;
        HRESULT hRes=ED.m_pDI->CreateDevice(lpddi->guidInstance,Dev.m_pDID,NULL);
        if(FAILED(hRes))
        {
            throw JOY_EXCEPTION(hRes);
        }
        Dev.Update(ED.m_pCore->m_pDIJoyCfg);
        Dev.m_bInitialized=true;
        ED.m_pCore->m_ListDIDev.push_back(Dev);
    }
    catch(JoyException E)
    {
    }
    catch(exception)
    {
    }

    return DIENUM_CONTINUE;
}

BOOL CALLBACK DIEnumJoyTypePr(LPCWSTR pwszTypeName,LPVOID pvRef)
{
    try
    {
        HRESULT hRes=S_OK;
        
        String TN=pwszTypeName;
        
        SEnumDev &ED=*(SEnumDev*)pvRef;

        DIJOYTYPEINFO JoyInfo;
        ZeroMemory(&JoyInfo,sizeof(JoyInfo));
        JoyInfo.dwSize=sizeof(JoyInfo);

        switch(ED.m_pCore->m_pDIJoyCfg->GetTypeInfo(pwszTypeName,&JoyInfo,DITC_REGHWSETTINGS))
        {
        //Errors to continue with.
        case DIERR_NOTFOUND:
            return DIENUM_CONTINUE;
        //Errors to stop with.
        case DIERR_INVALIDPARAM:
        case DIERR_NOMOREITEMS:
            return DIENUM_STOP;
        }

        if(JoyInfo.hws.dwFlags&JOY_HWS_ISGAMEPORTBUS)
        {
            CGprtDev D;
            D.m_Name=TN;

            ZeroMemory(&D.m_Info,sizeof(D.m_Info));
            D.m_Info.dwSize=sizeof(D.m_Info);
            DWORD dwFlags=DITC_CLSIDCONFIG|DITC_DISPLAYNAME;
            if(FAILED(ED.m_pCore->m_pDIJoyCfg->GetTypeInfo(D.m_Name.data(),&D.m_Info,dwFlags)))
            {
                throw JOY_EXCEPTION(hRes);
            }
            ED.m_pCore->m_GprtBus.push_back(D);
        }
        else if(!(JoyInfo.hws.dwFlags&JOY_HWS_AUTOLOAD))
        {
            CGprtDev D;
            D.m_Name=TN;

            ZeroMemory(&D.m_Info,sizeof(D.m_Info));
            D.m_Info.dwSize=sizeof(D.m_Info);
            DWORD dwFlags=DITC_REGHWSETTINGS|DITC_FLAGS1|DITC_HARDWAREID|DITC_CALLOUT|DITC_DISPLAYNAME;
            if(FAILED(ED.m_pCore->m_pDIJoyCfg->GetTypeInfo(D.m_Name.data(),&D.m_Info,dwFlags)))
            {
                throw JOY_EXCEPTION(hRes);
            }
            ED.m_pCore->m_GprtDev.push_back(D);
        }
    }
    catch(JoyException E)
    {
    }
    catch(exception)
    {
    }
    
    return DIENUM_CONTINUE;
}

CCore::CCore()
{
    m_bAccess=false;
    m_bInitialized=false;
}

bool CCore::IsAutoDetectGprt()
{
    if(!m_GprtDev.size())return false;
    if(m_GprtDev.front().m_Info.dwFlags1&
        JOYTYPE_NOAUTODETECTGAMEPORT)return false;
    return true;
}

int CCore::GetNextAvailableId()
{
    if(!m_bInitialized)return -1;
    DIJOYCONFIG JoyCfg;
    ZeroMemory(&JoyCfg,sizeof(JoyCfg));
    JoyCfg.dwSize=sizeof(JoyCfg);

    for(int i=0;i<NUMJOYDEVS;i++)
    {
        switch(m_pDIJoyCfg->GetConfig(i,&JoyCfg,DIJC_REGHWCONFIGTYPE))
        {
        case S_FALSE:
        case DIERR_NOMOREITEMS:
        case DIERR_NOTFOUND:
        case E_FAIL:
            return i;
        }
    }
    return -1;
}

bool CCore::FullJoyOemAccess()
{
    LONG lRc;
    HKEY hk;
    bool bRc;

    lRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                       REGSTR_PATH_JOYOEM, 
                       0, 
                       KEY_ALL_ACCESS & ~WRITE_DAC & ~WRITE_OWNER,
                       &hk);
    
    if( lRc == ERROR_SUCCESS ) {
        bRc = true;
        RegCloseKey(hk);
    } else {
        bRc = false;
    }

    return bRc;
}

HRESULT CCore::AddDevice(LPCTSTR pTypeName,bool bRudder,LPCTSTR pGprtId,GUID &GOccupied)
{
    HRESULT hRes=S_OK;
    GOccupied=NULLGUID;

    if(!m_bInitialized)return E_FAIL;

    if(m_GprtDev.size()>=MAX_DEVICES)return E_FAIL;
    
    LISTGPRTDEV::iterator It;
    It=find(m_GprtDev.begin(),m_GprtDev.end(),pTypeName);
    if(It==m_GprtDev.end())return E_FAIL;
    CGprtDev *pGprtDev=&*It;

    int nId=GetNextAvailableId();
    if(nId==-1)return DIERR_NOTFOUND;

    DIJOYCONFIG JoyCfg;
    ZeroMemory(&JoyCfg,sizeof(JoyCfg));
    JoyCfg.dwSize=sizeof(JoyCfg);
    JoyCfg.hwc.hws=pGprtDev->m_Info.hws;
    JoyCfg.hwc.hws.dwFlags|=JOY_HWS_ISANALOGPORTDRIVER;
    if(bRudder)
    {
        JoyCfg.hwc.hws.dwFlags|=JOY_HWS_HASR;
        JoyCfg.hwc.dwUsageSettings|=JOY_US_HASRUDDER;
    }
    JoyCfg.hwc.dwUsageSettings|=JOY_US_PRESENT;
    //JoyCfg.hwc.dwType=nArrayID;WHY is this beeing set to index?????????????????????????????????????????????????????????????????????????????????
    wcsncpy(JoyCfg.wszCallout,pGprtDev->m_Info.wszCallout,sizeof(JoyCfg.wszCallout)/sizeof(JoyCfg.wszCallout[0])-1);
    wcsncpy(JoyCfg.wszType,pGprtDev->m_Name.data(),sizeof(JoyCfg.wszType)/sizeof(JoyCfg.wszType[0])-1);

    if(SUCCEEDED(hRes=m_pDIJoyCfg->Acquire()))
    {
        if(m_GprtBus.size())
        {
            if(m_GprtBus.size()>1)
            {
                if(pGprtId)
                {
                    String GId=pGprtId;
                    LISTGPRTDEV::iterator It;
                    It=find(m_GprtBus.begin(),m_GprtBus.end(),GId.data());
                    if(It!=m_GprtDev.end())
                    {
                        JoyCfg.guidGameport=It->m_Info.clsidConfig;
                    }
                }
            }
            else
            {
                JoyCfg.guidGameport=m_GprtBus.front().m_Info.clsidConfig;
            }
        }

        if(FAILED(hRes=m_pDIJoyCfg->SetConfig(nId,&JoyCfg,DIJC_REGHWCONFIGTYPE|DIJC_CALLOUT)))
        {
            m_pDIJoyCfg->Unacquire();
            if(hRes==E_ACCESSDENIED)
                GOccupied=JoyCfg.guidGameport;
            return hRes;
        }
        else
        {
            //Fix #55524.
            if(SUCCEEDED(m_pDIJoyCfg->GetConfig(nId,&JoyCfg,DIJC_REGHWCONFIGTYPE)))
            {
                if(!(JoyCfg.hwc.dwUsageSettings&JOY_US_PRESENT))
                {
                    JoyCfg.hwc.dwUsageSettings|=JOY_US_PRESENT;
                    JoyCfg.hwc.hwv.dwCalFlags|=0x80000000;
                    JoyCfg.hwc.hws.dwFlags|=JOY_HWS_ISANALOGPORTDRIVER;
                    m_pDIJoyCfg->SetConfig(nId,&JoyCfg,DIJC_REGHWCONFIGTYPE);
                }
            }
            //End of fix #55524.
        }
        m_pDIJoyCfg->Unacquire();
    }
    Update();
    UpdateType();
    return hRes;
}

void CCore::Initialize(HWND hWnd)
{
    if((LPDIRECTINPUTJOYCONFIG8)m_pDIJoyCfg)
        m_pDIJoyCfg->Release();
    m_pDIJoyCfg=NULL;
    
    if((LPDIRECTINPUT8)m_pDI)
        m_pDI->Release();
    m_pDI=NULL;

    HMODULE hM=GetModuleHandle(NULL);
    if(!hM)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
    HRESULT hRes=DirectInput8Create(hM,DIRECTINPUT_VERSION,
        IID_IDirectInput8,(LPVOID*)&m_pDI,NULL);
    if(FAILED(hRes))
    {
        throw JOY_EXCEPTION(hRes);
    }
    hRes=m_pDI->QueryInterface(IID_IDirectInputJoyConfig8,(LPVOID*)&m_pDIJoyCfg);
    if(hRes!=DI_OK)
    {
        throw JOY_EXCEPTION(hRes);
    }
    hRes=m_pDIJoyCfg->SetCooperativeLevel(hWnd,DISCL_EXCLUSIVE|DISCL_BACKGROUND);
    if(hRes!=DI_OK)
    {
        throw JOY_EXCEPTION(hRes);
    }
    m_bAccess = FullJoyOemAccess();
    m_bInitialized=true;
}

void CCore::Update()
{
    HRESULT hRes;
    
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }

    m_ListDIDev.clear();

    SEnumDev ED(m_ListDIDev,m_pDI,this);
    hRes=m_pDI->EnumDevices(DI8DEVCLASS_GAMECTRL,DIEnumDevicesProc,&ED,DIEDFL_ALLDEVICES);
    if(FAILED(hRes))
    {
        //EnumDevices goes wrong
        ; //throw JOY_EXCEPTION(hRes);
    }

    UIUpdate();
}

void CCore::UpdateType()
{
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }

    m_GprtDrv.clear();
    m_GprtBus.clear();
    m_GprtDev.clear();

    HRESULT hRes=S_OK;

    SEnumDev ED(m_ListDIDev,m_pDI,this);
    hRes=m_pDIJoyCfg->EnumTypes(DIEnumJoyTypePr,&ED);
    if(FAILED(hRes))
    {
        throw JOY_EXCEPTION(hRes);
    }

    UIUpdate();
}

CDIDev *CCore::FindDIDev(GUID &Guid)
{
    LISTDIDEV::iterator It;
    It=find(m_ListDIDev.begin(),m_ListDIDev.end(),Guid);
    if(It==m_ListDIDev.end())return NULL;
    return &*It;
}

HRESULT CCore::Remove(GUID &Guid)
{
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
    
    CDIDev *pDev=FindDIDev(Guid);
    if(!pDev)return E_FAIL;
    
    HRESULT hRes;
    
    if(FAILED(hRes=m_pDIJoyCfg->Acquire()))return hRes;
    if(FAILED(hRes=m_pDIJoyCfg->DeleteConfig(pDev->Id())))
    {    
        m_pDIJoyCfg->Unacquire();
        return hRes;
    }
    m_pDIJoyCfg->SendNotify();
    m_pDIJoyCfg->Unacquire();
    return S_OK;
}

#define DIJC_ALL DIJC_REGHWCONFIGTYPE|DIJC_CALLOUT|DIJC_WDMGAMEPORT|DIJC_GAIN|DIJC_GUIDINSTANCE

void CCore::Preferred(GUID &G)
{
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
//Set Id of preferred device to 0.
    
    //Find Id of device to be set to 0.
    CDIDev *pDev=FindDIDev(G);
    if(!pDev)return;
    int nId=pDev->Id();
    if(nId==0)//Already preferred.
        return;
    
    if(SUCCEEDED(m_pDIJoyCfg->Acquire()))
    {
//We could call SetConfig only once and DInput on NT or Whistler should
//swap Id-s of two devices. However, it will not work if gameport device
//is unplugged, so we still must swap by salling SetConfig twice.

        DIJOYCONFIG OldId0;
        ZeroMemory(&OldId0,sizeof(OldId0));
        OldId0.dwSize=sizeof(OldId0);
        bool bOldId0=true;
        HRESULT hRes = m_pDIJoyCfg->GetConfig(0,&OldId0,DIJC_ALL);
        if(hRes==DIERR_NOTFOUND||hRes==S_FALSE)
            bOldId0=false;

        DIJOYCONFIG NewId0;
        ZeroMemory(&NewId0,sizeof(NewId0));
        NewId0.dwSize=sizeof(NewId0);
        bool bNewId0=true;
        hRes=m_pDIJoyCfg->GetConfig(nId,&NewId0,DIJC_ALL);
        if(hRes==DIERR_NOTFOUND||hRes==S_FALSE)
            bNewId0=false;

        if(bOldId0)
            m_pDIJoyCfg->SetConfig(nId,&OldId0,DIJC_ALL);
        else 
            //We must still delete because GetConfig could fail for other
            //reasons than device with Id 0 not present.
            m_pDIJoyCfg->DeleteConfig(0);

        if(bNewId0)
            m_pDIJoyCfg->SetConfig(0,&NewId0,DIJC_ALL);

        m_pDIJoyCfg->SendNotify();
        m_pDIJoyCfg->Unacquire();
    }
    Update();
}

//Partialy copied from old joy.cpl.
//I strongly suspect this is not documented anywhere.
bool CCore::IsAvailableVIDPID(String &VIDPIDName)
{
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }

    HRESULT hRes=m_pDIJoyCfg->Acquire();
    if(FAILED(hRes))throw JOY_EXCEPTION(hRes);
    
    //Make the VID/PID to compare from the following formula:
    //VID_045e&PID_100+JOY_HW_LASTENTRY to 100+JOY_HW_LASTENTRY+0xf

    TCHAR Type[18];
    _tcsncpy(Type,_T("VID_045E&PID_0100"),18);
    Type[17] = 0;

    const WCHAR Lookup[]=_T("0123456789ABCDEF");

    int i=JOY_HW_LASTENTRY;
    do
    {
        if(i<0x10)
        {
            Type[16]=Lookup[i];
        }
        else
        {
            Type[15]=Lookup[1];
            Type[16]=Lookup[i%0x10];
        }
        i++;

        HKEY hKey;
        if(FAILED(m_pDIJoyCfg->OpenTypeKey(Type,KEY_READ,&hKey)))
            break;
        RegCloseKey(hKey);
    }
    while(i<(JOY_HW_LASTENTRY+0x11));

    m_pDIJoyCfg->Unacquire();
    if(i<0x1d)
    {
        VIDPIDName=Type;
        return true;
    }
    return false;
}

CGprtDev *CCore::FindGprtDev(LPCTSTR pTypeName)
{
    if(!pTypeName)return NULL;
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
    for(LISTGPRTDEV::iterator It=m_GprtDev.begin();
            It!=m_GprtDev.end();It++)
    {
        if(It->m_Name==pTypeName)
            return &(*It);
    }
    return NULL;
}

bool CCore::IsCustomDevice(LPCTSTR pTypeName)
{
    if(!pTypeName)return false;
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
    if(pTypeName[0]==_T('#'))return false;//Standard type.
    CGprtDev *pDevType=FindGprtDev(pTypeName);
    if(!pDevType)
        //This should never happend, but just in case.
        throw JOY_EXCEPTION(E_FAIL);
    if(!pDevType->m_Info.wszHardwareId[0])
    {
        if(!pDevType->m_Info.wszCallout[0])
            return true;
    }
    else
    {
        TCHAR AnalogRoot[]=_T("gameport\\vid_045e&pid_01");
        //Test if it is predefined custom. Do not delete.
        TCHAR C=pDevType->m_Info.wszHardwareId[(sizeof(AnalogRoot)/
                sizeof(AnalogRoot[0]))-1];
        if((C==_T('f'))||(C==_T('F')))
            return false;
        //Now test if it is custom.
        if(!_tcsnicmp(pDevType->m_Info.wszHardwareId,AnalogRoot,
                (sizeof(AnalogRoot)/sizeof(AnalogRoot[0]))-1))
            return true;
    }
    return false;
}

void CCore::DeleteType(LPCTSTR pTypeName)
{
    if(!pTypeName)return;
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
    HRESULT hRes=m_pDIJoyCfg->Acquire();
    if(FAILED(hRes))throw JOY_EXCEPTION(hRes);
    m_pDIJoyCfg->DeleteType(pTypeName);
    m_pDIJoyCfg->Unacquire();
    UpdateType();
}

bool CCore::IsDeviceActive(LPCTSTR pTypeName)
{
    if(!pTypeName)return false;
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
    for(LISTDIDEV::iterator It=m_ListDIDev.begin();
            It!=m_ListDIDev.end();It++)
    {
        DIJOYCONFIG JoyCfg;
        ZeroMemory(&JoyCfg,sizeof(JoyCfg));
        JoyCfg.dwSize=sizeof(JoyCfg);
        if(SUCCEEDED(m_pDIJoyCfg->GetConfig(It->Id(),&JoyCfg,
            DIJC_REGHWCONFIGTYPE)))
        {
            if(!_tcscmp(JoyCfg.wszType,pTypeName))
                return true;
        }
    }
    return false;
}

bool CCore::DuplicateDeviceName(LPCTSTR pName)
{
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }

    for(LISTGPRTDEV::iterator It=m_GprtDev.begin();
            It!=m_GprtDev.end();It++)
    {
        if(!_tcsncmp(pName,It->Name(),
                (sizeof(It->m_Info.wszDisplayName)/
                sizeof(It->m_Info.wszDisplayName[0]))-1))
            return true;
    }
    return false;
}

void CCore::AddCustomDevice(bool bJoy,bool bPad,bool bYoke,bool bCar,
             int nAxes,bool bZAxis,int nButtons,bool bHasPov,LPCTSTR pName,
             LPCTSTR pVIDPIDName)
{
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
    
    String VIDPIDName=_T("GamePort\\");
    VIDPIDName+=pVIDPIDName;

    HRESULT hRes=m_pDIJoyCfg->Acquire();
    if(FAILED(hRes))throw JOY_EXCEPTION(hRes);

    DIJOYTYPEINFO JTI;
    ZeroMemory(&JTI,sizeof(JTI));
    JTI.dwSize=sizeof(JTI);
    int nCh=sizeof(JTI.wszDisplayName)/
            sizeof(JTI.wszDisplayName[0]);
    _tcsncpy(JTI.wszDisplayName,pName,nCh);
    JTI.wszDisplayName[nCh-1]=0;
    JTI.hws.dwNumButtons=nButtons;
    if(nAxes==3)
    {
        if(bZAxis)
            JTI.hws.dwFlags|=JOY_HWS_HASZ;
        else
            JTI.hws.dwFlags|=JOY_HWS_HASR;
    }
    else if(nAxes==4)
    {
        JTI.hws.dwFlags|=JOY_HWS_HASR|JOY_HWS_HASZ;
    }
    if(bHasPov)
        JTI.hws.dwFlags|=JOY_HWS_HASPOV|JOY_HWS_POVISBUTTONCOMBOS;
    if(!bJoy)
    {
        if(bPad)
        {
            JTI.hws.dwFlags|=JOY_HWS_ISGAMEPAD;
        }
        else if(bCar)
        {
            JTI.hws.dwFlags|=JOY_HWS_ISCARCTRL;
        }
        else
        {
            JTI.hws.dwFlags|=JOY_HWS_ISYOKE;
        }
    }
    nCh=sizeof(JTI.wszHardwareId)/
            sizeof(JTI.wszHardwareId[0]);
    _tcsncpy(JTI.wszHardwareId,VIDPIDName.data(),nCh);
    JTI.wszDisplayName[nCh-1]=0;

    hRes=m_pDIJoyCfg->SetTypeInfo(pVIDPIDName,&JTI,
            DITC_DISPLAYNAME|DITC_CLSIDCONFIG|
            DITC_REGHWSETTINGS|DITC_HARDWAREID,NULL);
    m_pDIJoyCfg->Unacquire();
    if(FAILED(hRes))throw JOY_EXCEPTION(hRes);
    
    UpdateType();
}

/******************************************************************************
UI
******************************************************************************/

/******************************************************************************
UI header
******************************************************************************/

class CDlgProcHandler//this is not in CDlg because we want to reuse for property sheets...
{
protected:
    HWND m_hWnd;
    HMODULE  m_hModule;

    static INT_PTR CALLBACK DialogProc
            (HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
    virtual INT_PTR DialogProc(UINT uMsg,WPARAM wParam,LPARAM lParam);
    virtual BOOL InitDialog(HWND hFocus,LPARAM lParam){return TRUE;};
    virtual BOOL Timer(WPARAM wTimerID){return FALSE;};
    virtual INT_PTR Command(WORD wNotifyCode,WORD wID,HWND hwndCtl);
    virtual INT_PTR Notify(int idCtrl,LPNMHDR pnmh){return 0;};
    HWND HDlgItem(int nIDDlgItem){return GetDlgItem(m_hWnd,nIDDl