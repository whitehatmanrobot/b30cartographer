ver
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CFactoryRouter::LockServer( BOOL a_fLock )
{
	if ( a_fLock )
	{
		g_FactoryRouterData.AddLock();
	}
	else
	{
		g_FactoryRouterData.ReleaseLock();
	}
	return S_OK	;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CFactoryRouter::CreateInstance
//
// Purpose: Instantiates a Event Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CFactoryRouter::CreateInstance (LPUNKNOWN a_pUnkOuter ,REFIID a_riid ,LPVOID FAR *a_ppvObject)
{
	HRESULT t_status = S_OK ;
	if ( a_pUnkOuter )
	{
		t_status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		// resolve request to whomever derived from us
		IUnknown *t_lpunk = (IUnknown *) CreateInstance( a_riid, a_ppvObject ) ; 
	
		if ( t_lpunk == NULL )
		{
			t_status = E_OUTOFMEMORY ;
		}
		else
		{
			// declare interface support
			t_status = t_lpunk->QueryInterface ( a_riid , a_ppvObject ) ;
			if ( FAILED ( t_status ) )
			{
				delete t_lpunk ;
			}
		}			
	}
	return t_status ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
REFGUID CFactoryRouter::GetClsId()
{
    return m_ClsId;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
LPCWSTR CFactoryRouter::GetClassDescription() 
{ 
    return (LPCWSTR)m_sDescription; 
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
DWORD CFactoryRouter::GetRegister() 
{ 
    return m_Register; 
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFactoryRouter::SetRegister( DWORD a_dwRegister )  
{ 
    m_Register = a_dwRegister; 
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*************************************************************************************************************
//
//*************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
CFactoryRouterData::CFactoryRouterData()
{
	s_LocksInProgress = s_ObjectsInProgress = m_ReferenceCount = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
CFactoryRouterData::~CFactoryRouterData()
{
	CAutoLock cal( m_cs);
LogMessage(L"************ Clearing the FactoryRouterMap");

		mg_oFactoryMap.clear() ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFactoryRouterData::AddToMap( REFGUID a_rClsId, CFactoryRouter * pFactory ) 
{
	CHString t_chsClsId ;
	ClsToString( t_chsClsId, a_rClsId ) ;
	CAutoLock cal( m_cs);

LogMessage2(L"************ Adding to map %s", (WCHAR*)(const WCHAR*) t_chsClsId);
		// map class and instance 
		mg_oFactoryMap[ t_chsClsId ] = pFactory ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*void CFactoryRouterData::RemoveFromMap( REFGUID a_rClsId ) 
{
	CHString t_chsClsId ;
	ClsToString( t_chsClsId, a_rClsId ) ;
	CAutoLock cal( m_cs);
		mg_oFactoryMap.erase( t_chsClsId ) ;
}*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CFactoryRouterData::DllCanUnloadNow()
{
	return !(s_ObjectsInProgress || s_LocksInProgress) ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFactoryRouterData::AddLock()
{
	InterlockedIncrement ( &s_LocksInProgress ) ;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFactoryRouterData::ReleaseLock()
{
	InterlockedDecrement ( &s_LocksInProgress ) ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CFactoryRouterData::AddRef()
{	
	InterlockedIncrement ( &s_ObjectsInProgress ) ;
	return InterlockedIncrement ( &m_ReferenceCount ) ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CFactoryRouterData::Release()
{
	InterlockedDecrement ( &s_ObjectsInProgress ) ;
	return InterlockedDecrement( &m_ReferenceCount ) ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CFactoryRouterData::DllGetClassObject( REFCLSID a_rclsid, REFIID a_riid, PPVOID a_ppv )
{	
	HRESULT t_hResult = E_FAIL ;
	CHString t_chsClsId ;
    Factory_Map::iterator	t_FactoryIter;
	
	ClsToString( t_chsClsId, a_rclsid ) ;
	CAutoLock cal(m_cs);

LogMessage2(L"************ Looking for %s in DllGetClassObject", (WCHAR*)(const WCHAR*) t_chsClsId);

		t_FactoryIter = mg_oFactoryMap.find( t_chsClsId ) ;
		if( t_FactoryIter != mg_oFactoryMap.end() )
		{
			t_hResult = t_FactoryIter->second->QueryInterface( a_riid, a_ppv ) ;
		}
LogMessage2(L"************ DllGetClassObject QueryInterface returned %x",t_hResult);

	return t_hResult ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CFactoryRouterData::DllRegisterServer() 
{
	HRESULT t_hResult = NOERROR;
	CAutoLock cal(m_cs);

		Factory_Map::iterator	t_FactoryIter ;
		t_FactoryIter = mg_oFactoryMap.begin() ;

		while( t_FactoryIter != mg_oFactoryMap.end() )
		{
			bstr_t t_bstrPreface( "WMI instrumentation: " ) ;
			bstr_t t_bstrClassDescription( t_FactoryIter->second->GetClassDescription() ) ;

			t_bstrPreface += t_bstrClassDescription ; 
			t_hResult = ::RegisterServer( t_bstrPreface, t_FactoryIter->second->GetClsId() ) ;
			
			if( NOERROR != t_hResult )
			{
				break ;
			}

			++t_FactoryIter ;
		}
	return t_hResult ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CFactoryRouterData::DllUnregisterServer() 
{
	HRESULT t_hResult = NOERROR ;
	CAutoLock cal(m_cs);

		Factory_Map::iterator	t_FactoryIter ;

		t_FactoryIter = mg_oFactoryMap.begin() ;

		while( t_FactoryIter != mg_oFactoryMap.end() )
		{
			t_hResult = ::UnregisterServer( t_FactoryIter->second->GetClsId() ) ;
			
			if( NOERROR != t_hResult )
			{
				break ;
			}

			++t_FactoryIter ;
		}
	return t_hResult ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CFactoryRouterData::InitComServer()
{
	HRESULT t_hResult = S_OK ;
	CAutoLock cal(m_cs);

		Factory_Map::iterator	t_FactoryIter ;

		t_FactoryIter = mg_oFactoryMap.begin() ;

		while( t_FactoryIter != mg_oFactoryMap.end() )
		{
			DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
			DWORD t_Flags = REGCLS_MULTIPLEUSE ;
			DWORD t_dwRegister = 0 ;

			t_hResult = CoRegisterClassObject(t_FactoryIter->second->GetClsId(),t_FactoryIter->second,t_ClassContext,t_Flags,&t_dwRegister);
			if( NOERROR != t_hResult )
			{
				break ;
			}
			
			t_FactoryIter->second->SetRegister( t_dwRegister ) ;
			++t_FactoryIter ;
		}
	return t_hResult ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CFactoryRouterData::UninitComServer()
{
	HRESULT t_hResult = S_OK ;
	CAutoLock cal( m_cs);

		Factory_Map::iterator	t_FactoryIter ;
		t_FactoryIter = mg_oFactoryMap.begin() ;

		while( t_FactoryIter != mg_oFactoryMap.end() )
		{
			DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
			DWORD t_Flags = REGCLS_MULTIPLEUSE ;
			DWORD t_dwRegister = t_FactoryIter->second->GetRegister() ;
			
			if( t_dwRegister )
			{ 
				t_hResult = CoRevokeClassObject ( t_dwRegister ) ;
				t_FactoryIter->second->SetRegister( 0 ) ;
			}
		
			if( NOERROR != t_hResult )
			{
				break ;
			}

			++t_FactoryIter ;
		}

	return t_hResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\implogonuser.cpp ===
//=================================================================
//
// ImpLogonUser.CPP -- Class to perform impersonation of logged on user.
//
//  Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    09/09/97    a-sanjes        Created
//
//=================================================================
//#define _WIN32_DCOM // For CoImpersonateUser and CoRevertToSelf
//#include <objbase.h>

#include "precomp.h"

#ifdef NTONLY
#include <tchar.h>
#include <winerror.h>

#include <cominit.h>
#include <lockwrap.h>
#include "Sid.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "CToken.h"
#include "SecureKernelObj.h"
#include "implogonuser.h"

#include "cluidhelper.h"

static DWORD s_dwProcessID = 0;
static CCritSec g_csImpersonate;

//////////////////////////////////////////////////////////////////////////////
//
//	implogonuser.cpp - Class implementation of CImpersonateLoggedOnUser.
//
//	This class is intended to provide a way for a process to identify the shell
//	process on a Windows NT system, and using the access token of that process
//	to attempt to impersonate the user logged onto the Interactive Desktop of
//	a workstation.
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//	FUNCTION    :	CImpersonateLoggedOnUser::CImpersonateLoggedOnUser
//
//	DESCRIPTION :	Constructor
//
//	INPUTS      :	NONE		
//
//	OUTPUTS     :	none
//
//	RETURNS     :	nothing
//
//	COMMENTS    :	Constructs empty instance to prepare for impersonation of user.
//
//////////////////////////////////////////////////////////////////////////////

CImpersonateLoggedOnUser::CImpersonateLoggedOnUser() :
	m_hShellProcess(NULL),
	m_hUserToken(NULL),
	m_fImpersonatingUser(FALSE) ,
	m_hThreadToken ( INVALID_HANDLE_VALUE )
{
}

//////////////////////////////////////////////////////////////////////////////
//
//	FUNCTION    :	CImpersonateLoggedOnUser::~CImpersonateLoggedOnUser
//
//	DESCRIPTION :	Destructor
//
//	INPUTS      :	none
//
//	OUTPUTS     :	none
//
//	RETURNS     :	nothing
//
//	COMMENTS    :	Class destructor
//
//////////////////////////////////////////////////////////////////////////////

CImpersonateLoggedOnUser::~CImpersonateLoggedOnUser( void )
{
	// Stop any current impersonation
	End();
}

//////////////////////////////////////////////////////////////////////////////
//
//	FUNCTION    :	CImpersonateLoggedOnUser::Begin
//
//	DESCRIPTION :	Attempts to begin impersonation of user.
//
//	INPUTS      :	none
//
//	OUTPUTS     :	none
//
//	RETURNS     :	BOOL		TRUE/FALSE - Success/Failure
//
//	COMMENTS    :	Uses helper functions to try to impersonate the
//						currently logged on user.  The process must have
//						the proper level of access to perform the operation.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::Begin( void )
{
	BOOL	fReturn = FALSE;
	TCHAR	szShellProcessName[256];
	LogMessage(_T("CImpersonateLoggedOnUser::Begin"));
	
	// Only continue if we are not already impersonating a user
	if (!m_fImpersonatingUser )
	{
		//Store the current thread token, assuming that the thread is impersonating somebody (DCOM client)
        if ( !OpenThreadToken ( GetCurrentThread(), TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE, TRUE, &m_hThreadToken ) )
		{
			m_hThreadToken = INVALID_HANDLE_VALUE;
		}

		// We will need a copy of PSAPI.DLL and a bunch of entry point
		// addresses before we can continue, so let our base class take
		// care of this.
	
		// We need a handle for the Shell Process in order to
		// successfully impersonate the user.
		if ( NULL == m_hShellProcess )
		{
			if ( LoadShellName( szShellProcessName, sizeof(szShellProcessName) ) )
				FindShellProcess( szShellProcessName);
			else
				LogErrorMessage(_T("LoadShellName failed"));
		}

		if ( NULL != m_hShellProcess )
		{
			fReturn = ImpersonateUser();
		}
		else
		{
			// We didn't find the Shell Process Name that we extracted from the
			// registry.  We saw this happening on Alphas that seem to get "fx32strt.exe"
			// dumped in the shell.  In these cases, it seems to cause explorer to run.
			// So with that in mind, if we drop down in this branch of code, we're going
			// to retry the locate shell process operation using Explorer.Exe.

			if ( IsErrorLoggingEnabled() )
			{
				CHString sTemp;
				sTemp.Format(_T("Shell Name %s in Registry not found in process list."), szShellProcessName);
				LogErrorMessage(sTemp);
			}

			FindShellProcess( IDS_WINNT_SHELLNAME_EXPLORER ) ;

			// m_hShellProcess will be non-NULL if and only if we got one.
			if ( NULL != m_hShellProcess )
			{
				fReturn = ImpersonateUser();
			}
			else
			{
				LogErrorMessage(_T("Unable to locate Shell Process, Impersonation failed."));
				SetLastError(0);
			}
		}
	}
	else
	{
		LogMessage(_T("CImpersonateLoggedOnUser::Begin - Already impersonated"));
		fReturn = TRUE;	// Already initialized
	}

	// We don't yet have a way to know whether explorer is really alive
	// because we're impersonating someone and I can't find a way to
	// revert back to LocalSystem.  So, for now just set it to 0.
	SetLastError(0);

	return fReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	FUNCTION    :	CImpersonateLoggedOnUser::End
//
//	DESCRIPTION :	Ends impersonation of logged on user
//
//	INPUTS      :	none
//
//	OUTPUTS     :	none
//
//	RETURNS     :	BOOL		TRUE/FALSE - Success/Failure
//
//	COMMENTS    :	Ends impersonation of logged on user.  Clears all elements
//						of class as a byproduct.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::End( void )
{
	BOOL	fReturn = FALSE;

	// Only initiate a Revert if we are impersonating the user.

	if ( m_fImpersonatingUser )
	{
		LogMessage(_T("CImpersonateLoggedOnUser::End"));
		fReturn = Revert();
	}
	else
	{
		fReturn = TRUE;
	}

	// Clear the handles out
	if ( NULL != m_hUserToken )
	{
		CloseHandle( m_hUserToken );
		m_hUserToken = NULL;
	}

	if ( NULL != m_hShellProcess )
	{
		CloseHandle( m_hShellProcess );
		m_hShellProcess = NULL;
	}
	if ( m_hThreadToken != INVALID_HANDLE_VALUE )
	{
		CloseHandle( m_hThreadToken );
		m_hThreadToken = INVALID_HANDLE_VALUE ;
	}
	return fReturn;

}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    : CImpersonateLoggedOnUser::LoadShellName
//
//  DESCRIPTION : Loads Windows NT Shell name from registry
//
//  INPUTS      :	DWORD		cbShellNameBuffer - Shell Name Buffer Size (in bytes)
//
//  OUTPUTS     : LPTSTR	pszShellName - Buffer to contain shell name.
//
//  RETURNS     : BOOL		TRUE/FALSE - Success/Failure
//
//  COMMENTS    : Jumps into Windows Registry and attempts to determine the
//						NT Shell Name.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::LoadShellName( LPTSTR pszShellName, DWORD cbShellNameBuffer )
{
	BOOL	fReturn = FALSE;
	LONG	lErrReturn = ERROR_SUCCESS;

	// Only continue if we have a buffer to work with first

	if ( NULL != pszShellName )
	{
		HKEY	hReg = NULL;

		// Open the key in HKEY_LOCAL_MACHINE, if that succeeds, get the
		// value associated with "Shell".
		if ( ( lErrReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
										 WINNT_WINLOGON_KEY,
										 0,
										 KEY_READ,
										 &hReg ) ) == ERROR_SUCCESS )
		{
            try
            {

			    DWORD		dwType = REG_SZ;

			    if ( ( lErrReturn = RegQueryValueEx( hReg,
													 WINNT_SHELL_VALUE,
													 0,
													 &dwType,
													 (LPBYTE) pszShellName,
													 &cbShellNameBuffer ) ) == ERROR_SUCCESS )
			    {
				    fReturn = TRUE;
			    }
			    else
                {
				    LogErrorMessage(_T("RegQueryValueEx FAILED"));
                }
            }
            catch ( ... )
            {
    			RegCloseKey( hReg );
                throw ;
            }

			RegCloseKey( hReg );

		}	// RegOpenKeyEx
		else
        {
			LogErrorMessage(_T("RegOpenKeyEx FAILED"));
        }

	}	// NULL != pszShellName

	return fReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    : CImpersonateLoggedOnUser::FindShellProcess
//
//  DESCRIPTION : Enumerates the processes to locate the Shell Process.
//
//  INPUTS      :	LPCTSTR	pszShellName - Name of the process to locate.
//
//  OUTPUTS     : None.
//
//  RETURNS     : BOOL		TRUE/FALSE - Success/Failure
//
//  COMMENTS    : Enumerates the processes on the local system using PSAPI.DLL
//						functions, attempting to locate the one that corresponds to
//						the WINNT Shell passed into this function.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::FindShellProcess( LPCTSTR pszShellName )
{
	BOOL fReturn = FALSE;
	HANDLE	hProcess = NULL;
	HMODULE *phModules = NULL;
    DWORD dwModuleArraySize = 0;
	DWORD*	pdwProcessIds = NULL;

	if ( NULL != pszShellName )
	{
	    CPSAPI *t_psapi = (CPSAPI*) CResourceManager::sm_TheResourceManager.GetResource ( guidPSAPI, NULL ) ;
		if ( t_psapi )
		{
			try
			{
				CLuidHelper luid ;
				LUID processLUID ;

				// This locks access to the s_dwProcessID value.  WATCH THE SCOPING HERE!
				CLockWrapper t_lockImp(g_csImpersonate);

				// First check to see if we have a cached value.  If so, check to see if it's still valid.
				if (s_dwProcessID != 0)
				{
					if ( ( hProcess = OpenProcess(	PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
													FALSE,
													s_dwProcessID ) )
										!= NULL )
					{
						try
						{
							// Now search the process modules for a match to the supplied
							// shell name.

							fReturn = FindShellModuleInProcess( pszShellName, hProcess, phModules, dwModuleArraySize, t_psapi );

							if ( TRUE == fReturn )
							{
								if ( STATUS_SUCCESS == luid.GetLUIDFromProcess ( hProcess, &processLUID ) )
								{
									if ( ! luid.IsInteractiveSession ( &processLUID ) )
									{
										fReturn = FALSE ;
									}
								}
								else
								{
									fReturn = FALSE ;
								}
							}
						}
						catch ( ... )
						{
							CloseHandle (hProcess);
							throw ;
						}

						// Close the process handle if it's not the shell (in which
						// case we'll save the value and close it as part of the
						// Clear() function.

						if ( !fReturn )
						{
							CloseHandle( hProcess );
							hProcess = NULL;

							// Not valid anymore
							s_dwProcessID = 0;
						}
						else
						{
							m_hShellProcess = hProcess;
                    		LogMessage(L"Using cached handle for impersonation");

							hProcess = NULL;
						}

					}	// if OpenProcess
					else
					{
						// We didn't open the process, so we need to set the value to zero so that
						// we will look for a new process below.
						s_dwProcessID = 0;
					}
				}

				// Did we find a cached value?
				if (s_dwProcessID == 0)
				{
					// Nope.  Scan all processes to see if we can find the explorer

					DWORD		dwProcessIdArraySize	=	0,
								dwNumProcesses			=	0,
								cbDataReturned			=	0;
					BOOL		fEnumSucceeded	=	FALSE;

					// Perform initial allocations of our arrays.  Since
					// pointers and values are 0, this will just fill out
					// said values.

					do
					{
						ReallocProcessIdArray( pdwProcessIds, dwProcessIdArraySize );

						fEnumSucceeded = t_psapi->EnumProcesses( pdwProcessIds, dwProcessIdArraySize, &cbDataReturned );

					} while ( (dwProcessIdArraySize == cbDataReturned) && fEnumSucceeded);

					// Only walk the array if we sucessfully populated it
					if ( fEnumSucceeded )
					{
						// Count of Bytes returned / sizeof(DWORD) tells us how many
						// processes are out in the world.

						dwNumProcesses = cbDataReturned / sizeof(DWORD);

						DWORD	dwId = 0;

						// Enum processes until we obtain a shell process or run out
						// of processes to query.

						while ( dwId < dwNumProcesses && !fReturn )
						{
							if ( ( hProcess = OpenProcess(	PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
															FALSE,
															pdwProcessIds[dwId] ) )
												!= NULL )
							{
								try
								{
									// Now search the process modules for a match to the supplied
									// shell name.

									fReturn = FindShellModuleInProcess( pszShellName, hProcess, phModules, dwModuleArraySize, t_psapi );

									if ( TRUE == fReturn )
									{
										if ( STATUS_SUCCESS == luid.GetLUIDFromProcess ( hProcess, &processLUID ) )
										{
											if ( ! luid.IsInteractiveSession ( &processLUID ) )
											{
												fReturn = FALSE ;
											}
										}
										else
										{
											fReturn = FALSE ;
										}
									}
								}
								catch ( ... )
								{
									CloseHandle (hProcess);
									throw ;
								}

								// Close the process handle if it's not the shell (in which
								// case we'll save the value and close it as part of the
								// Clear() function.

								if ( !fReturn )
								{
									CloseHandle( hProcess );
									hProcess = NULL;
								}
								else
								{
									m_hShellProcess = hProcess;
									s_dwProcessID = pdwProcessIds[dwId];
									hProcess = NULL;
								}

							}	// if OpenProcess

							// Increment the Id counter

							++dwId;

						}	// While OpenProcesses

					}	// If !fRetryEnumProcesses
				}
			}
			catch ( ... )
			{
				if (phModules)
				{
					delete [] phModules;
				}

				if (pdwProcessIds)
				{
					delete [] pdwProcessIds;
				}

				if ( t_psapi )
				{
					CResourceManager::sm_TheResourceManager.ReleaseResource ( guidPSAPI, t_psapi ) ;
					t_psapi = NULL ;
				}
				throw ;
			}
		}

        if (pdwProcessIds)
        {
			delete [] pdwProcessIds;
        }

        if (phModules)
        {
            delete [] phModules;
        }

	    if ( t_psapi )
	    {
		    CResourceManager::sm_TheResourceManager.ReleaseResource ( guidPSAPI, t_psapi ) ;
//		    t_psapi = NULL ;
	    }
    }

	return fReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    : CImpersonateLoggedOnUser::FindShellModuleInProcess
//
//  DESCRIPTION : Enumerates the modules in a process to find our
//						shell.
//
//  INPUTS      :	LPCTSTR		pszShellName - Name of the process to locate.
//						HANDLE		hProcess - Process we are enumerating modules in.
//
//  OUTPUTS     : HMODULE*&	phModules - Array of module handle pointers.
//						DWORD&		dwModuleArraySize - Size of Module Array (in bytes)
//
//  RETURNS     : BOOL		TRUE/FALSE - Success/Failure
//
//  COMMENTS    : Enumerates the modules specified by a process identifier and
//						attemptsto locate the one that corresponds to the WINNT Shell
//						passed into this function.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::FindShellModuleInProcess( LPCTSTR pszShellName, HANDLE hProcess, HMODULE*& phModules, DWORD& dwModuleArraySize, CPSAPI *a_psapi )
{
	BOOL	fReturn				=	FALSE,
			fRetryEnumModules	=	FALSE;
	DWORD	cbDataReturned		=	0;

	TCHAR	szModuleName[MAX_PATH];

    if (dwModuleArraySize == 0)
    {
	    ReallocModuleHandleArray( phModules, dwModuleArraySize );
    }

	do
	{
		// Get a list of the process HMODULEs and for each HMODULE, get
		// the base file name.

		if ( a_psapi->EnumProcessModules( hProcess, phModules, dwModuleArraySize, &cbDataReturned ) )
		{

			// Because m_pfnEnumProcessModules will NOT fail if there are more process
			// modules than bytes available in the array, if the amount returned is
			// the same size as the array, realloc the array and retry the Enum.

			if ( dwModuleArraySize == cbDataReturned )
			{
				fRetryEnumModules = ReallocModuleHandleArray( phModules, dwModuleArraySize );
			}
			else
			{
				fRetryEnumModules = FALSE;
			}

			// Only walk the array if we don't need to retry the enum
			if ( !fRetryEnumModules )
			{
                DWORD dwModuleCtr = 0;

                // Executable name always returned in entry 0

				if ( a_psapi->GetModuleBaseName( hProcess, phModules[dwModuleCtr], szModuleName, sizeof(szModuleName) ) )
				{
					fReturn = ( lstrcmpi( pszShellName, szModuleName ) == 0 );
				}

			}	// If !fRetryEnumModules

		}	// if EnumProcessModules

	}
	while ( fRetryEnumModules );

	return fReturn;
}

DWORD CImpersonateLoggedOnUser::AdjustSecurityDescriptorOfImpersonatedToken(
    CSid& csidSidOfCurrentProcess )
{
	DWORD dwRet = E_FAIL;
    
    // Get the thread token...
    CThreadToken ctt;
	if ( ctt.IsValidToken () )
	{
		// Obtain access to its security descriptor...
		CSecureKernelObj sko(ctt.GetTokenHandle(), FALSE);
		// Modify the security descriptor...
		if(sko.AddDACLEntry(
			csidSidOfCurrentProcess,
			ENUM_ACCESS_ALLOWED_ACE_TYPE,
			TOKEN_ALL_ACCESS,
			0,
			NULL,
			NULL))
		{
			dwRet = sko.ApplySecurity(
				DACL_SECURITY_INFORMATION);
		}
	}

    return dwRet ;
}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    : CImpersonateLoggedOnUser::ImpersonateUser
//
//  DESCRIPTION : Attempts to impersonate the user.
//
//  INPUTS      :	None.
//
//  OUTPUTS     : None.
//
//  RETURNS     : BOOL		TRUE/FALSE - Success/Failure
//
//  COMMENTS    : Opens the security token of the Shell Process and
//						uses it to try to impersonate the user.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::ImpersonateUser( void )
{
	BOOL fRet = FALSE;
    // Make sure we have a shell process
	if (m_hShellProcess)
    {
        CSid csidCurrentProcess;
        if(GetCurrentProcessSid(csidCurrentProcess))
        {
            // Get the Process User token if we don't have one (token of the explorer process).
	        //Removed the TOKEN_ALL_ACCESS desired access mask to this call as Winmgmt(Local system) can't open the token of the
	        //shell process (with all access rights)if the logged-in user is an Admin. So open the token with 'desired access' sufficient
	        //enough to use it for impersonation only.
	        if (m_hUserToken ||
		        OpenProcessToken(m_hShellProcess, TOKEN_READ | TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE, &m_hUserToken))
		    {
	            // Now we should have what we need.  Impersonate the user.

				HANDLE hCurThread = ::GetCurrentThread () ;

				CProcessToken cpt ( m_hUserToken );
				if ( cpt.IsValidToken () )
				{
					TOKEN_TYPE type;
					if ( cpt.GetTokenType ( type ) )
					{
						if ( TokenPrimary == type )
						{
							CToken ct;
							if ( ct.Duplicate ( cpt, FALSE ) )
							{
								if( ::SetThreadToken ( &hCurThread, ct.GetTokenHandle () ) )
								{
									m_fImpersonatingUser = TRUE ;
								}
							}
						}
						else
						{
							if( ::SetThreadToken ( &hCurThread, cpt.GetTokenHandle () ) )
							{
								m_fImpersonatingUser = TRUE ;
							}
						}

						if ( m_fImpersonatingUser )
						{
							if(AdjustSecurityDescriptorOfImpersonatedToken ( csidCurrentProcess ) == ERROR_SUCCESS)
							{
								fRet = TRUE;
							}
							else
							{
								Revert () ;
							}
						}
					}
				}
            }
        }
    }
	return (m_fImpersonatingUser = fRet);
}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    : CImpersonateLoggedOnUser::Revert
//
//  DESCRIPTION : Attempts to revert to self.
//
//  INPUTS      :	None.
//
//  OUTPUTS     : None.
//
//  RETURNS     : BOOL		TRUE/FALSE - Success/Failure
//
//  COMMENTS    : If we're impersonating a user, we now revert to
//						ourselves.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::Revert( void )
{
	HRESULT hRes = WBEM_E_FAILED ;
	BOOL bRet = FALSE ;
	// See if we're currently impersonating prior to reverting.
	if (m_fImpersonatingUser)
	{
		// Now get back to to the previous impersonation or impersonate the DCOM client.
		if ( m_hThreadToken != INVALID_HANDLE_VALUE )
		{
			HANDLE hCurThread = ::GetCurrentThread () ;

			CThreadToken cpt ( m_hThreadToken );
			if ( cpt.IsValidToken () )
			{
				TOKEN_TYPE type;
				if ( cpt.GetTokenType ( type ) )
				{
					if ( TokenPrimary == type )
					{
						CToken ct;
						if ( ct.Duplicate ( cpt, FALSE ) )
						{
							bRet = ::SetThreadToken ( &hCurThread, ct.GetTokenHandle () );
						}
					}
					else
					{
						bRet = ::SetThreadToken ( &hCurThread, cpt.GetTokenHandle () ) ;
					}

					if (!bRet)
					{
						throw CFramework_Exception(L"SetThreadToken failed", GetLastError());
					}
				}
			}
		}
		else
		{
			hRes = WbemCoImpersonateClient();

			if (FAILED(hRes))
			{
				throw CFramework_Exception(L"WbemCoImpersonateClient failed", hRes);
			}
		}

		if (SUCCEEDED(hRes) || hRes == E_NOTIMPL || bRet )
		{
			m_fImpersonatingUser = FALSE;
		}
	}
	return ( !m_fImpersonatingUser );
}



//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    : CImpersonateLoggedOnUser::ReallocProcessIdArray
//
//  DESCRIPTION : Helper function to alloc a process id array.
//
//  INPUTS      :	None.
//
//  OUTPUTS     : PDWORD&	pdwProcessIds - Process Id Array pointer
//						DWORD&	dwArraySize - Size of array in bytes
//
//  RETURNS     : BOOL		TRUE/FALSE - Success/Failure
//
//  COMMENTS    : Call when we need to realloc our process id array.
//						This will grow the array by a fixed size, but not
//						preserve values.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::ReallocProcessIdArray( PDWORD& pdwProcessIds, DWORD& dwArraySize )
{
	DWORD		dwNewArraySize	=	dwArraySize + ( PROCESSID_ARRAY_BLOCKSIZE * sizeof(DWORD) );
	PDWORD	pdwNewArray		=	new DWORD[dwNewArraySize];

	// Make sure the allocation succeeded before overwriting any existing values.
	if ( NULL != pdwNewArray )
	{
		if ( NULL != pdwProcessIds )
		{
			delete [] pdwProcessIds;
		}

		pdwProcessIds = pdwNewArray;
		dwArraySize = dwNewArraySize;
	}
    else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

	return ( NULL != pdwNewArray );
}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    : CImpersonateLoggedOnUser::ReallocModuleHandleArray
//
//  DESCRIPTION : Helper function to alloc a module handle array.
//
//  INPUTS      :	None.
//
//  OUTPUTS     : HMODULE*&	phModules - Module Handle Array pointer
//						DWORD&		dwArraySize - size of array in bytes
//
//  RETURNS     : BOOL		TRUE/FALSE - Success/Failure
//
//  COMMENTS    : Call when we need to realloc our module handle array.
//						This will grow the array by a fixed size, but not
//						preserve values.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::ReallocModuleHandleArray( HMODULE*& phModules, DWORD& dwArraySize )
{
	DWORD		dwNewArraySize	=	dwArraySize + ( HMODULE_ARRAY_BLOCKSIZE * sizeof(HMODULE) );
	HMODULE*	phNewArray		=	new HMODULE[dwNewArraySize];

	// Make sure the allocation succeeded before overwriting any existing values.

	if ( NULL != phNewArray )
	{
		if ( NULL != phModules )
		{
			delete [] phModules;
		}

		phModules = phNewArray;
		dwArraySize = dwNewArraySize;
	}
    else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }


	return ( NULL != phNewArray );
}

bool CImpersonateLoggedOnUser::GetCurrentProcessSid(CSid& sidCurrentProcess)
{
    bool fRet = false;

    PBYTE pbuff = NULL;

    // I am going to revert here in order to access the process's
    // sid.  This is not privileged information, so this doesn't
    // present a security breach.

    WbemCoRevertToSelf();

    try
    {
        CProcessToken cpt(NULL, true, TOKEN_QUERY);

        DWORD dwLen = 0;
        if(!::GetTokenInformation(
            cpt.GetTokenHandle(),    // the PR0CESS token
            TokenUser,
            NULL,
            0L,
            &dwLen) && (::GetLastError() == ERROR_INSUFFICIENT_BUFFER))
        {
            pbuff = new BYTE[dwLen];
            if(pbuff)
            {
                if(::GetTokenInformation(
                    cpt.GetTokenHandle(),
                    TokenUser,
                    pbuff,
                    dwLen,
                    &dwLen))
                {
                    PTOKEN_USER ptu = (PTOKEN_USER)pbuff;
                    CSid sidTemp(ptu->User.Sid);
                    if(sidTemp.IsOK() &&
                        sidTemp.IsValid())
                    {
                        sidCurrentProcess = sidTemp;
                        fRet = true;
                    }
                }
                delete pbuff;
                pbuff = NULL;
            }
        }
    }
    catch(...)
    {
		//on our way out not returning anything to user except failure
		//can't do anything on this impersonation failure...
        WbemCoImpersonateClient();
        delete pbuff;
        pbuff = NULL;
        throw;
    }

	HRESULT hr = WbemCoImpersonateClient() ;

	if (FAILED(hr))
	{
		throw CFramework_Exception(L"WbemCoImpersonateClient failed", hr);
	}

    return fRet;     
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\iodesc.h ===
/////////////////////////////////////////////////////////////////////////

//

//  iodesc.h    

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    10/15/97        Sanj        Created by Sanj     
//              10/17/97        jennymc     Moved things a tiny bit
//  
/////////////////////////////////////////////////////////////////////////

#ifndef __IODESC_H__
#define __IODESC_H__

// This structure is a munge of 16-bit and 32-bit values that basically combine both
// structures into one with common information (sigh...)

typedef struct _IOWBEM_DES{
	DWORD		IOD_Count;          // number of IO_RANGE structs in IO_RESOURCE
	DWORD		IOD_Type;           // size (in bytes) of IO_RANGE (IOType_Range)
	DWORDLONG	IOD_Alloc_Base;     // base of allocated port range
	DWORDLONG	IOD_Alloc_End;      // end of allocated port range
	DWORD		IOD_DesFlags;       // flags relating to allocated port range
	BYTE		IOD_Alloc_Alias;	// From 16-bit-land
	BYTE		IOD_Alloc_Decode;	// From 16-bit-land
} IOWBEM_DES;

typedef IOWBEM_DES*	PIOWBEM_DES;

class 
__declspec(uuid("571D3187-D45D-11d2-B35E-00104BC97924"))
CIODescriptor : public CResourceDescriptor
{
	
public:

	// Construction/Destruction
	CIODescriptor( PPOORMAN_RESDESC_HDR pResDescHdr, CConfigMgrDevice* pDevice );
	CIODescriptor( DWORD dwResourceId, IOWBEM_DES& ioDes, CConfigMgrDevice* pOwnerDevice );
	CIODescriptor( const CIODescriptor& io );
	~CIODescriptor();

	DWORDLONG GetBaseAddress( void );
	DWORDLONG GetEndAddress( void );
	DWORD GetFlags( void );
	BYTE GetAlias( void );
	BYTE GetDecode( void );

	// Override of base class functionality
	virtual void * GetResource();
	
};

_COM_SMARTPTR_TYPEDEF(CIODescriptor, __uuidof(CIODescriptor));

inline DWORDLONG CIODescriptor::GetBaseAddress( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIOWBEM_DES) m_pbResourceDescriptor)->IOD_Alloc_Base : 0 );
}

inline DWORDLONG CIODescriptor::GetEndAddress( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIOWBEM_DES) m_pbResourceDescriptor)->IOD_Alloc_End : 0 );
}

inline DWORD CIODescriptor::GetFlags( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIOWBEM_DES) m_pbResourceDescriptor)->IOD_DesFlags : 0 );
}

inline BYTE CIODescriptor::GetAlias( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIOWBEM_DES) m_pbResourceDescriptor)->IOD_Alloc_Alias : 0 );
}

inline BYTE CIODescriptor::GetDecode( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIOWBEM_DES) m_pbResourceDescriptor)->IOD_Alloc_Decode : 0 );
}

// A collection of IO Port Descriptors
class CIOCollection : public TRefPtr<CIODescriptor>
{
public:

	// Construction/Destruction
	CIOCollection();
	~CIOCollection();

	// Because we're inheriting, we need to declare this here
	// (= operator is not inherited).

	const CIOCollection& operator = ( const CIOCollection& srcCollection );

};

inline const CIOCollection& CIOCollection::operator = ( const CIOCollection& srcCollection )
{
	// Call into the templated function
	Copy( srcCollection );
	return *this;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\iodesc.cpp ===
//=================================================================

//

//  IODesc.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    10/15/97        Sanj        Created by Sanj
//              10/17/97        jennymc     Moved things a tiny bit
//
/////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <assertbreak.h>
#include "poormansresource.h"
#include "resourcedesc.h"
#include "iodesc.h"
////////////////////////////////////////////////////////////////////////
//
//	Function:	CIODescriptor::CIODescriptor
//
//	Class Constructor.
//
//	Inputs:		PPOORMAN_RESDESC_HDR	pResDescHdr - Resource Descriptor
//										header used to get resource info
//										plus the raw bytes following.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIODescriptor::CIODescriptor(	PPOORMAN_RESDESC_HDR	pResDescHdr,
								CConfigMgrDevice*		pOwnerDevice )
:	CResourceDescriptor( pResDescHdr, pOwnerDevice )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIODescriptor::CIODescriptor
//
//	Class Constructor.
//
//	Inputs:		DWORD					dwResourceId - Resource Id with flags
//				IOWBEM_DES				ioDes - IO Descriptor.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIODescriptor::CIODescriptor(	DWORD				dwResourceId,
								IOWBEM_DES&				ioDes,
								CConfigMgrDevice*		pOwnerDevice )
:	CResourceDescriptor( dwResourceId, &ioDes, sizeof(IOWBEM_DES), pOwnerDevice )
{
	ASSERT_BREAK( ResType_IO == GetResourceType() );
}

// Copy Constructor
CIODescriptor::CIODescriptor( const CIODescriptor& io )
: CResourceDescriptor( io )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIODescriptor::~CIODescriptor
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIODescriptor::~CIODescriptor( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIODescriptor::GetString
//
//	Returns a string representation of the associated IO Port Address.
//
//	Inputs:		None.
//
//	Outputs:	CHString&		str - Storage for string.
//
//	Return:		TRUE/FALSE		Function successful or not.
//
//	Comments:	Do NOT call down to the base class.
//
////////////////////////////////////////////////////////////////////////
void *CIODescriptor::GetResource()
{

	if ( NULL != m_pbResourceDescriptor ){
		// Cast to an IO Resource Descriptor, and place it's IO address values
		// in the string.
		PIO_DES	pIO = (PIO_DES) m_pbResourceDescriptor;
        return pIO;
	}

	return NULL;
}

//
//	Constructor and Destructor for the IO Port Descriptor Collection
//	object.
//

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIOCollection::CIOCollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIOCollection::CIOCollection( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIOCollection::~CIOCollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIOCollection::~CIOCollection( void )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\implogonuser.h ===
//=================================================================

//

// ImpLogonUser.H -- Class to perform impersonation of logged on user.

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    09/09/97    a-sanjes        Created
//
//=================================================================

#ifndef __IMPLOGONUSER_H__
#define __IMPLOGONUSER_H__

//////////////////////////////////////////////////////////////////////////////
//
//	ImpLogonUser.H - Class definition of CImpersonateLoggedOnUser.
//	
//	This class is intended to provide a way for a process to identify the shell
//	process on a Windows NT system, and using the access token of that process
//	to attempt to impersonate the user logged onto the Interactive Desktop of
//	a workstation.
//	
//	To use this class, simply construct it, and call the Begin() function.  If
//	it succeeds, you may then access information that would otherwise not be
//	available to your process (such as network connection info).  When you are
//	finished, call End() to clear out the class.  
//
//	Caveats:
//	1>	This class is NOT thread safe, so don't share it across multiple
//		threads!  Besides, ImpersonateLoggedOnUser() is only good for the thread
//		it was called on.
//	2>	If multiple instances of the Shell process are running, this method
//		may or may not be accurate.  It will probably work in a large percentage
//		of cases however.
//	3>	Multiple logged on users will cause problems for this code (see #2).
//	4>	This class may need to be optimized for speed, as it currently makes no
//		use of caches and "redicovers" the shell process each time an instance
//		is implemented.
//	5>	PSAPI.DLL must be available.
//
//////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
#include "wbempsapi.h"

// String Constants

// Resides under HKEY_LOCAL_MACHINE
#define	WINNT_WINLOGON_KEY	_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon")
#define	WINNT_SHELL_VALUE		_T("Shell")

// Memory allocation definitions
#define	PROCESSID_ARRAY_BLOCKSIZE	1024
#define	HMODULE_ARRAY_BLOCKSIZE		1024

class CImpersonateLoggedOnUser
{
public:

	CImpersonateLoggedOnUser();
	~CImpersonateLoggedOnUser();

	// User Interface
	BOOL Begin( void );
	BOOL End( void );

	// inlines

	BOOL IsImpersonatingUser( void );

protected:

private:

	// Helpers for identifying the shell process and locating it
	BOOL LoadShellName( LPTSTR pszShellName, DWORD cbShellNameBuffer );
	BOOL FindShellProcess( LPCTSTR pszShellProcessName );
	BOOL FindShellModuleInProcess( LPCTSTR pszShellName, HANDLE hProcess, HMODULE*& phModules, DWORD& dwModuleArraySize, CPSAPI *a_psapi );
    bool GetCurrentProcessSid(CSid& csidCurrentProcess);
    DWORD AdjustSecurityDescriptorOfImpersonatedToken(CSid& csidSidOfCurrentProcess);


	// Perform actual impersonation and revert
	BOOL ImpersonateUser( void );
	BOOL Revert( void );

	// Memory Allocation Helpers

	BOOL ReallocProcessIdArray( PDWORD& pdwProcessIds, DWORD& dwArraySize );
	BOOL ReallocModuleHandleArray( HMODULE*& phModules, DWORD& dwArraySize );

	// Data for impersonating data
	BOOL		m_fImpersonatingUser;
	HANDLE	m_hShellProcess, m_hThreadToken ,
				m_hUserToken;
};

inline BOOL CImpersonateLoggedOnUser::IsImpersonatingUser( void )
{
	return m_fImpersonatingUser;
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\irqdesc.cpp ===
//=================================================================

//

//  IRQDesc.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//
//  History:    10/15/97        Sanj        Created by Sanj
//              10/17/97        jennymc     Moved things a tiny bit
//
/////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <assertbreak.h>
#include "refptr.h"
#include "poormansresource.h"
#include "resourcedesc.h"
#include "irqdesc.h"
////////////////////////////////////////////////////////////////////////
//
//	Function:	CIRQDescriptor::CIRQDescriptor
//
//	Class Constructor.
//
//	Inputs:		PPOORMAN_RESDESC_HDR	pResDescHdr - Resource Descriptor
//										header used to get resource info
//										plus the raw bytes following.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIRQDescriptor::CIRQDescriptor(	PPOORMAN_RESDESC_HDR	pResDescHdr,
								CConfigMgrDevice*		pOwnerDevice )
:	CResourceDescriptor( pResDescHdr, pOwnerDevice )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIRQDescriptor::CIRQDescriptor
//
//	Class Constructor.
//
//	Inputs:		DWORD					dwResourceId - Resource Id with flags
//				IRQ_DES					irqDes - IRQ Descriptor.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIRQDescriptor::CIRQDescriptor(	DWORD				dwResourceId,
							    IRQ_DES&				irqDes,
								CConfigMgrDevice*		pOwnerDevice )
:	CResourceDescriptor( dwResourceId, &irqDes, sizeof(IRQ_DES), pOwnerDevice )
{
	ASSERT_BREAK( ResType_IRQ == GetResourceType() );
}

// Copy Constructor
CIRQDescriptor::CIRQDescriptor( const CIRQDescriptor& irq )
: CResourceDescriptor( irq )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIRQDescriptor::~CIRQDescriptor
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIRQDescriptor::~CIRQDescriptor( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIRQDescriptor::GetResource()
//
//	Returns a string representation of the associated IRQ Number.
//
//	Inputs:		None.
//
//	Outputs:	CHString&		str - Storage for string.
//
//	Return:		TRUE/FALSE		Function successful or not.
//
//	Comments:	Do NOT call down to the base class.
//
////////////////////////////////////////////////////////////////////////

void *CIRQDescriptor::GetResource()
{
	if ( NULL != m_pbResourceDescriptor )
	{
		// Traverse an IRQ Resource Descriptor and place it's IRQ valuestring

		PIRQ_DES	pIRQ = (PIRQ_DES) m_pbResourceDescriptor;
        return pIRQ;

	}
	return NULL;
}

//
//	Constructor and Destructor for the IRQ Descriptor Collection
//	object.
//

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIRQCollection::CIRQCollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIRQCollection::CIRQCollection( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIRQCollection::~CIRQCollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIRQCollection::~CIRQCollection( void )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\kernel32api.h ===
//=================================================================

//

// Kernel32Api.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_KERNEL32API_H_
#define	_KERNEL32API_H_


#include <tlhelp32.h>
//#include <resource.h>

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "DllWrapperBase.h"

extern const GUID g_guidKernel32Api;
extern const TCHAR g_tstrKernel32[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/
typedef BOOL (WINAPI *PFN_KERNEL32_GET_DISK_FREE_SPACE_EX)
(
	LPCTSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
);

typedef HANDLE (WINAPI *PFN_KERNEL32_CREATE_TOOLHELP32_SNAPSHOT) 
(
    DWORD, 
    DWORD
);

typedef BOOL (WINAPI *PFN_KERNEL32_THREAD32_FIRST)  
(
    HANDLE, 
    LPTHREADENTRY32
);

typedef BOOL (WINAPI *PFN_KERNEL32_THREAD32_NEXT)  
(
    HANDLE, 
    LPTHREADENTRY32
);


typedef BOOL (WINAPI *PFN_KERNEL32_PROCESS32_FIRST)
(
    HANDLE, 
    LPPROCESSENTRY32
);

typedef BOOL (WINAPI *PFN_KERNEL32_PROCESS32_NEXT)
(
    HANDLE, 
    LPPROCESSENTRY32
);

typedef BOOL (WINAPI *PFN_KERNEL32_MODULE32_FIRST)  
(
    HANDLE, 
    LPMODULEENTRY32
);

typedef BOOL (WINAPI *PFN_KERNEL32_MODULE32_NEXT)  
(
    HANDLE, 
    LPMODULEENTRY32
);

typedef BOOL (WINAPI *PFN_KERNEL32_HEAP32_LIST_FIRST)    
(
    HANDLE, 
    LPHEAPLIST32
);

typedef BOOL (WINAPI *PFN_KERNEL32_GLOBAL_MEMORY_STATUS_EX) 
(
    IN OUT LPMEMORYSTATUSEX lpBuffer
);

typedef LANGID (WINAPI *PFN_KERNEL32_GET_SYSTEM_DEFAULT_U_I_LANGUAGE)
(
);

typedef BOOL (WINAPI *PFN_KERNEL32_GET_VOLUME_PATH_NAME)
(
    LPCTSTR lpszFileName,
    LPTSTR lpszVolumePathName,
    DWORD cchBufferLength
);



/******************************************************************************
 * Wrapper class for Kernel32 load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class 
__declspec(uuid("3CA401C6-D477-11d2-B35E-00104BC97924"))
CKernel32Api : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to kernel32 functions.
    // Add new functions here as required.
    PFN_KERNEL32_GET_DISK_FREE_SPACE_EX m_pfnGetDiskFreeSpaceEx;
    PFN_KERNEL32_CREATE_TOOLHELP32_SNAPSHOT m_pfnCreateToolhelp32Snapshot;
	PFN_KERNEL32_THREAD32_FIRST  m_pfnThread32First;
    PFN_KERNEL32_THREAD32_NEXT  m_pfnThread32Next;
    PFN_KERNEL32_PROCESS32_FIRST m_pfnProcess32First;
    PFN_KERNEL32_PROCESS32_NEXT m_pfnProcess32Next;
    PFN_KERNEL32_MODULE32_FIRST  m_pfnModule32First;
    PFN_KERNEL32_MODULE32_NEXT  m_pfnModule32Next;
    PFN_KERNEL32_HEAP32_LIST_FIRST m_pfnHeap32ListFirst;
    PFN_KERNEL32_GLOBAL_MEMORY_STATUS_EX m_pfnGlobalMemoryStatusEx;
    PFN_KERNEL32_GET_SYSTEM_DEFAULT_U_I_LANGUAGE m_pfnGetSystemDefaultUILanguage;
    PFN_KERNEL32_GET_VOLUME_PATH_NAME m_pfnGetVolumePathName;

public:

    // Constructor and destructor:
    CKernel32Api(LPCTSTR a_tstrWrappedDllName);
    ~CKernel32Api();

    // Inherrited initialization function.
    virtual bool Init();

    // Member functions wrapping kernel32 functions.
    // Add new functions here as required:
    bool GetDiskFreeSpaceEx
    (
        LPCTSTR lpDirectoryName,
        PULARGE_INTEGER a_lpFreeBytesAvailableToCaller,
        PULARGE_INTEGER a_lpTotalNumberOfBytes,
        PULARGE_INTEGER a_lpTotalNumberOfFreeBytes,
        BOOL *a_pfRetval 
    );

    bool CreateToolhelp32Snapshot
    (
        DWORD a_dwFlags, 
        DWORD a_th32ProcessID,
        HANDLE *a_hRetval 
    );

	bool Thread32First
    (
        HANDLE a_hSnapshot, 
        LPTHREADENTRY32 a_lpte,
        BOOL *a_pfRetval 
    );

    bool Thread32Next
    (
        HANDLE a_hSnapshot,  
        LPTHREADENTRY32 a_lpte,
        BOOL *a_pfRetval 
    );

    bool Process32First
    (
        HANDLE a_hSnapshot, 
        LPPROCESSENTRY32 a_lppe,
        BOOL *a_pfRetval 
    );

    bool Process32Next
    (
        HANDLE a_hSnapshot, 
        LPPROCESSENTRY32 a_lppe,
        BOOL *a_pfRetval 
    );

    bool Module32First
    (
        HANDLE a_hSnapshot, 
        LPMODULEENTRY32 a_lpme,
        BOOL *a_pfRetval 
    );

    bool Module32Next
    (
        HANDLE a_hSnapshot, 
        LPMODULEENTRY32 a_lpme,
        BOOL *a_pfRetval 
    );

    bool Heap32ListFirst
    (
        HANDLE a_hSnapshot, 
        LPHEAPLIST32 a_lphl,
        BOOL *a_pfRetval 
    );

    bool GlobalMemoryStatusEx 
    (
        IN OUT LPMEMORYSTATUSEX a_lpBuffer,
        BOOL *a_pfRetval 
    );

    bool GetSystemDefaultUILanguage
    (
        LANGID *a_plidRetval 
    );

    bool GetVolumePathName
    (
        LPCTSTR lpszFileName,
        LPTSTR lpszVolumePathName,
        DWORD cchBufferLength,
        BOOL *pfRetval 
    );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\kernel32api.cpp ===
//=================================================================

//

// Kernel32API.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>
#include "Kernel32Api.h"
#include "DllWrapperCreatorReg.h"



// {DDEA7E32-CCE8-11d2-911E-0060081A46FD}
static const GUID g_guidKernel32Api =
{0xddea7e32, 0xcce8, 0x11d2, {0x91, 0x1e, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};

static const TCHAR g_tstrKernel32[] = _T("KERNEL32.DLL");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CKernel32Api, &g_guidKernel32Api, g_tstrKernel32> MyRegisteredKernel32Wrapper;


/******************************************************************************
 * Constructor
 ******************************************************************************/
CKernel32Api::CKernel32Api(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnGetDiskFreeSpaceEx(NULL),
   m_pfnCreateToolhelp32Snapshot(NULL),
   m_pfnThread32First(NULL),
   m_pfnThread32Next(NULL),
   m_pfnProcess32First(NULL),
   m_pfnProcess32Next(NULL),
   m_pfnModule32First(NULL),
   m_pfnModule32Next(NULL),
   m_pfnHeap32ListFirst(NULL),
   m_pfnGlobalMemoryStatusEx(NULL),
   m_pfnGetSystemDefaultUILanguage(NULL)
{
}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CKernel32Api::~CKernel32Api()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CKernel32Api::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {

#ifdef NTONLY

        m_pfnGetDiskFreeSpaceEx = (PFN_KERNEL32_GET_DISK_FREE_SPACE_EX)
                                    GetProcAddress("GetDiskFreeSpaceExW");

        m_pfnGetVolumePathName = (PFN_KERNEL32_GET_VOLUME_PATH_NAME)
                                    GetProcAddress("GetVolumePathNameW");
#endif

#ifdef WIN9XONLY

        m_pfnGetDiskFreeSpaceEx = (PFN_KERNEL32_GET_DISK_FREE_SPACE_EX)
                                    GetProcAddress("GetDiskFreeSpaceExA");

        m_pfnGetVolumePathName = (PFN_KERNEL32_GET_VOLUME_PATH_NAME)
                                    GetProcAddress("GetVolumePathNameA");

#endif
        // NT5 ONLY FUNCTIONS
        m_pfnCreateToolhelp32Snapshot = (PFN_KERNEL32_CREATE_TOOLHELP32_SNAPSHOT)
                                    GetProcAddress("CreateToolhelp32Snapshot");

        m_pfnThread32First = (PFN_KERNEL32_THREAD32_FIRST)
                                    GetProcAddress("Thread32First");

        m_pfnThread32Next = (PFN_KERNEL32_THREAD32_NEXT)
                                    GetProcAddress("Thread32Next");

        m_pfnProcess32First = (PFN_KERNEL32_PROCESS32_FIRST)
                                    GetProcAddress("Process32First");

        m_pfnProcess32Next = (PFN_KERNEL32_PROCESS32_NEXT)
                                    GetProcAddress("Process32Next");

        m_pfnModule32First = (PFN_KERNEL32_MODULE32_FIRST)
                                    GetProcAddress("Module32First");

        m_pfnModule32Next = (PFN_KERNEL32_MODULE32_NEXT)
                                    GetProcAddress("Module32Next");

        m_pfnHeap32ListFirst = (PFN_KERNEL32_HEAP32_LIST_FIRST)
                                    GetProcAddress("Heap32ListFirst");

        m_pfnGlobalMemoryStatusEx = (PFN_KERNEL32_GLOBAL_MEMORY_STATUS_EX)
                                    GetProcAddress("GlobalMemoryStatusEx");

        m_pfnGetSystemDefaultUILanguage = (PFN_KERNEL32_GET_SYSTEM_DEFAULT_U_I_LANGUAGE)
                                    GetProcAddress("GetSystemDefaultUILanguage");

        // Check that we have function pointers to functions that should be
        // present in all versions of this dll...
        // ( in this case, ALL these are functions that may or may not be
        //   present, so don't bother)
    }
    return fRet;
}




/******************************************************************************
 * Member functions wrapping Kernel32 api functions. Add new functions here
 * as required.
 ******************************************************************************/

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::GetDiskFreeSpaceEx
(
    LPCTSTR a_lpDirectoryName,
    PULARGE_INTEGER a_lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER a_lpTotalNumberOfBytes,
    PULARGE_INTEGER a_lpTotalNumberOfFreeBytes,
    BOOL *a_pfRetval
)
{
    BOOL t_fExists = FALSE;
    BOOL t_fTemp = FALSE;
    if(m_pfnGetDiskFreeSpaceEx != NULL)
    {
        t_fTemp = m_pfnGetDiskFreeSpaceEx(a_lpDirectoryName,
                                       a_lpFreeBytesAvailableToCaller,
                                       a_lpTotalNumberOfBytes,
                                       a_lpTotalNumberOfFreeBytes);
        t_fExists = TRUE;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::CreateToolhelp32Snapshot
(
    DWORD a_dwFlags,
    DWORD a_th32ProcessID,
    HANDLE *a_phRetval
)
{
    bool t_fExists = false;
    HANDLE t_hTemp;
    if(m_pfnCreateToolhelp32Snapshot != NULL)
    {
        t_hTemp = m_pfnCreateToolhelp32Snapshot(a_dwFlags, a_th32ProcessID);

        t_fExists = true;

        if(a_phRetval != NULL)
        {
            *a_phRetval = t_hTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::Thread32First
(
    HANDLE a_hSnapshot,
    LPTHREADENTRY32 a_lpte,
    BOOL *a_pfRetval
)
{
    bool t_fExists = false;
    BOOL t_fTemp = FALSE;
    if(m_pfnThread32First != NULL)
    {
        t_fTemp = m_pfnThread32First(a_hSnapshot, a_lpte);

        t_fExists = true;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::Thread32Next
(
    HANDLE a_hSnapshot,
    LPTHREADENTRY32 a_lpte,
    BOOL *a_pfRetval
)
{
    bool t_fExists = false;
    BOOL t_fTemp = FALSE;
    if(m_pfnThread32Next != NULL)
    {
        t_fTemp = m_pfnThread32Next(a_hSnapshot, a_lpte);

        t_fExists = true;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::Process32First
(
    HANDLE a_hSnapshot,
    LPPROCESSENTRY32 a_lppe,
    BOOL *a_pfRetval
)
{
    bool t_fExists = false;
    BOOL t_fTemp = FALSE;
    if(m_pfnProcess32First != NULL)
    {
        t_fTemp = m_pfnProcess32First(a_hSnapshot, a_lppe);

        t_fExists = true;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::Process32Next
(
    HANDLE a_hSnapshot,
    LPPROCESSENTRY32 a_lppe,
    BOOL *a_pfRetval
)
{
    bool t_fExists = false;
    BOOL t_fTemp = FALSE;
    if(m_pfnProcess32Next != NULL)
    {
        t_fTemp = m_pfnProcess32Next(a_hSnapshot, a_lppe);

        t_fExists = true;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::Module32First
(
    HANDLE a_hSnapshot,
    LPMODULEENTRY32 a_lpme,
    BOOL *a_pfRetval
)
{
    bool t_fExists = false;
    BOOL t_fTemp = FALSE;
    if(m_pfnModule32First != NULL)
    {
        t_fTemp = m_pfnModule32First(a_hSnapshot, a_lpme);

        t_fExists = true;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::Module32Next
(
    HANDLE a_hSnapshot,
    LPMODULEENTRY32 a_lpme,
    BOOL *a_pfRetval
)
{
    bool t_fExists = false;
    BOOL t_fTemp = FALSE;
    if(m_pfnModule32Next != NULL)
    {
        t_fTemp = m_pfnModule32Next(a_hSnapshot, a_lpme);

        t_fExists = true;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::Heap32ListFirst
(
    HANDLE a_hSnapshot,
    LPHEAPLIST32 a_lphl,
    BOOL *a_pfRetval
)
{
    bool t_fExists = false;
    BOOL t_fTemp = FALSE;
    if(m_pfnHeap32ListFirst != NULL)
    {
        t_fTemp = m_pfnHeap32ListFirst(a_hSnapshot, a_lphl);

        t_fExists = true;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::GlobalMemoryStatusEx
(
    IN OUT LPMEMORYSTATUSEX a_lpBuffer,
    BOOL *a_pfRetval
)
{
    BOOL t_fExists = FALSE;
    BOOL t_fTemp = FALSE;
    if(m_pfnGlobalMemoryStatusEx != NULL && a_pfRetval != NULL)
    {
        t_fTemp = m_pfnGlobalMemoryStatusEx(a_lpBuffer);

        t_fExists = TRUE;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::GetSystemDefaultUILanguage
(
    LANGID *a_plidRetval
)
{
    BOOL t_fExists = FALSE;
    LANGID t_lidTemp;
    if(m_pfnGetSystemDefaultUILanguage != NULL && a_plidRetval != NULL)
    {
        t_lidTemp = m_pfnGetSystemDefaultUILanguage();

        t_fExists = TRUE;

        if(a_plidRetval != NULL)
        {
            *a_plidRetval = t_lidTemp;
        }
    }
    return t_fExists;
}


// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::GetVolumePathName(
        LPCTSTR lpszFileName,
        LPTSTR lpszVolumePathName,
        DWORD dwBufferLength,
        BOOL *pfRetval)
{
    bool fExists = false;
    BOOL fTemp = FALSE;
    if(m_pfnGetVolumePathName != NULL && 
        pfRetval != NULL)
    {
        fTemp = m_pfnGetVolumePathName(
            lpszFileName,
            lpszVolumePathName,
            dwBufferLength);

        fExists = true;

        if(pfRetval != NULL)
        {
            *pfRetval = fTemp;
        }
    }
    return fExists;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\lpvparams.h ===
//=================================================================

//

// LPVParams.h 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    2/18/99    a-kevhu        Created
//
//=================================================================

#ifndef _LPVPARAMS_H
#define _LPVPARAMS_H
// Parameter class for LoadPropertyValues
//=======================================
class CLPVParams
{
    public:
        CLPVParams() {}

        CLPVParams(CInstance* pInstance, CConfigMgrDevice* pDevice, DWORD dwReqProps);
        ~CLPVParams() {}

        CInstance* m_pInstance;
        CConfigMgrDevice* m_pDevice;
        DWORD m_dwReqProps;
};

inline CLPVParams::CLPVParams(CInstance* pInstance, CConfigMgrDevice* pDevice, DWORD dwReqProps)
:m_pInstance(pInstance), m_pDevice(pDevice), m_dwReqProps(dwReqProps)
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\irqdesc.h ===
#ifndef __IRQDESC_H__

#define __IRQDESC_H__

/////////////////////////////////////////////////////////////////////////

//

//  cfgmgrdevice.h    

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    10/15/97        Sanj        Created by Sanj     
//              10/17/97        jennymc     Moved things a tiny bit
//  
/////////////////////////////////////////////////////////////////////////


class 
__declspec(uuid("CB0E0537-D375-11d2-B35E-00104BC97924"))
CIRQDescriptor : public CResourceDescriptor
{
	
public:

	// Construction/Destruction
	CIRQDescriptor( PPOORMAN_RESDESC_HDR pResDescHdr, CConfigMgrDevice* pDevice );
	CIRQDescriptor(	DWORD dwResourceId, IRQ_DES& irqDes, CConfigMgrDevice* pOwnerDevice );
	CIRQDescriptor( const CIRQDescriptor& irq );
	~CIRQDescriptor();

	// Accessors
	DWORD	GetFlags( void );
	BOOL	IsShareable( void );
	ULONG	GetInterrupt( void );
	ULONG	GetAffinity( void );

	// Override of base class functionality
	virtual void * GetResource();
	
};

_COM_SMARTPTR_TYPEDEF(CIRQDescriptor, __uuidof(CIRQDescriptor));

inline DWORD CIRQDescriptor::GetFlags( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIRQ_DES) m_pbResourceDescriptor)->IRQD_Flags : 0 );
}

inline BOOL CIRQDescriptor::IsShareable( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIRQ_DES) m_pbResourceDescriptor)->IRQD_Flags & fIRQD_Share : FALSE );
}

inline DWORD CIRQDescriptor::GetInterrupt( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIRQ_DES) m_pbResourceDescriptor)->IRQD_Alloc_Num : 0 );
}

inline DWORD CIRQDescriptor::GetAffinity( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIRQ_DES) m_pbResourceDescriptor)->IRQD_Affinity : 0 );
}

// A collection of IRQ Descriptors
class CIRQCollection : public TRefPtr<CIRQDescriptor>
{
public:

	// Construction/Destruction
	CIRQCollection();
	~CIRQCollection();

	// Because we're inheriting, we need to declare this here
	// (= operator is not inherited).

	const CIRQCollection& operator = ( const CIRQCollection& srcCollection );

};

inline const CIRQCollection& CIRQCollection::operator = ( const CIRQCollection& srcCollection )
{
	// Call into the templated function
	Copy( srcCollection );
	return *this;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\msacm32api.cpp ===
//=================================================================

//

// MsAcm32API.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <cominit.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>

#include "DllWrapperBase.h"
#include "MsAcm32Api.h"
#include "DllWrapperCreatorReg.h"

// {7D65D31E-0FB5-11d3-910C-00105AA630BE}
static const GUID g_guidMsAcm32Api =
{ 0x7d65d31e, 0xfb5, 0x11d3, { 0x91, 0xc, 0x0, 0x10, 0x5a, 0xa6, 0x30, 0xbe } };

static const TCHAR g_tstrMsAcm32 [] = _T("MsAcm32.Dll");

/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CMsAcm32Api, &g_guidMsAcm32Api, g_tstrMsAcm32> MyRegisteredMsAcm32Wrapper;

/******************************************************************************
 * Constructor
 *****************************************************************************/
CMsAcm32Api::CMsAcm32Api(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
	m_pfnacmDriverDetails (NULL),
	m_pfnacmDriverEnum (NULL)
{
}

/******************************************************************************
 * Destructor
 *****************************************************************************/
CMsAcm32Api::~CMsAcm32Api()
{
}

/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 ******************************************************************************/
bool CMsAcm32Api::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
#ifdef UNICODE
		m_pfnacmDriverDetails = ( PFN_MsAcm32_acmDriverDetails ) GetProcAddress ( "acmDriverDetailsW" ) ;
#else
		m_pfnacmDriverDetails = ( PFN_MsAcm32_acmDriverDetails ) GetProcAddress ( "acmDriverDetailsA" ) ;

#endif
		m_pfnacmDriverEnum = ( PFN_MsAcm32_acmDriverEnum ) GetProcAddress ( "acmDriverEnum" ) ;
    }

    // We require these function for all versions of this dll.

	if ( m_pfnacmDriverDetails == NULL ||
		 m_pfnacmDriverEnum == NULL )
	{
        fRet = false;
        LogErrorMessage(L"Failed find entrypoint in msacm32api");
	}

    return fRet;
}

/******************************************************************************
 * Member functions wrapping Tapi api functions. Add new functions here
 * as required.
 *****************************************************************************/

#ifdef UNICODE
MMRESULT CMsAcm32Api :: MsAcm32acmDriverDetails (

	HACMDRIVERID            hadid,
	LPACMDRIVERDETAILSW     padd,
	DWORD                   fdwDetails
)
#else
MMRESULT CMsAcm32Api :: MsAcm32acmDriverDetails (

	HACMDRIVERID            hadid,
	LPACMDRIVERDETAILSA     padd,
	DWORD                   fdwDetails
)
#endif
{
	return m_pfnacmDriverDetails (

		hadid,
		padd,
		fdwDetails
	) ;
}

MMRESULT CMsAcm32Api :: MsAcm32acmDriverEnum (

	ACMDRIVERENUMCB         fnCallback,
	DWORD_PTR               dwInstance,
	DWORD                   fdwEnum
)
{
	return m_pfnacmDriverEnum (

		fnCallback,
		dwInstance,
		fdwEnum
	) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\mprapi.cpp ===
//=================================================================

//

// MprAPI.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <cominit.h>

#include <lmuse.h>
#include "DllWrapperBase.h"
#include "MprApi.h"
#include "DllWrapperCreatorReg.h"

// {EA6034F1-0FAD-11d3-910C-00105AA630BE}
static const GUID g_guidMprApi =
{ 0xea6034f1, 0xfad, 0x11d3, { 0x91, 0xc, 0x0, 0x10, 0x5a, 0xa6, 0x30, 0xbe } };

static const TCHAR g_tstrMpr [] = _T("Mpr.Dll");

/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CMprApi, &g_guidMprApi, g_tstrMpr> MyRegisteredMprWrapper;

/******************************************************************************
 * Constructor
 *****************************************************************************/
CMprApi::CMprApi(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
	m_pfnWNetEnumResource (NULL),
	m_pfnWNetOpenEnum(NULL),
	m_pfnWNetCloseEnum(NULL),
	m_pfnWNetGetUser(NULL),
	m_pfnWNetGetConnection(NULL)
{
}

/******************************************************************************
 * Destructor
 *****************************************************************************/
CMprApi::~CMprApi()
{
}

/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 ******************************************************************************/
bool CMprApi::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
#ifdef UNICODE
		m_pfnWNetGetUser = ( PFN_Mpr_WNetGetUser ) GetProcAddress ( "WNetGetUserW" ) ;
		m_pfnWNetEnumResource = ( PFN_Mpr_WNetEnumResource ) GetProcAddress ( "WNetEnumResourceW" ) ;
		m_pfnWNetOpenEnum = ( PFN_Mpr_WNetOpenEnum ) GetProcAddress ( "WNetOpenEnumW" ) ;
		m_pfnWNetGetConnection = ( PFN_Mpr_WNetGetConnection ) GetProcAddress ( "WNetGetConnectionW" ) ;
#else
		m_pfnWNetGetUser = ( PFN_Mpr_WNetGetUser ) GetProcAddress ( "WNetGetUserA" ) ;
		m_pfnWNetEnumResource = ( PFN_Mpr_WNetEnumResource ) GetProcAddress ( "WNetEnumResourceA" ) ;
		m_pfnWNetOpenEnum = ( PFN_Mpr_WNetOpenEnum ) GetProcAddress ( "WNetOpenEnumA" ) ;
		m_pfnWNetGetConnection = ( PFN_Mpr_WNetGetConnection ) GetProcAddress ( "WNetGetConnectionA" ) ;
#endif
		m_pfnWNetCloseEnum = ( PFN_Mpr_WNetCloseEnum ) GetProcAddress ( "WNetCloseEnum" ) ;
    }

    // We require these function for all versions of this dll.

	if ( m_pfnWNetEnumResource == NULL ||
		 m_pfnWNetOpenEnum == NULL ||
		 m_pfnWNetCloseEnum == NULL ||
		 m_pfnWNetGetUser == NULL )
	{
        fRet = false;
        LogErrorMessage(L"Failed find entrypoint in MPRAPI");
	}

    return fRet;
}

/******************************************************************************
 * Member functions wrapping Tapi api functions. Add new functions here
 * as required.
 *****************************************************************************/

#ifdef UNICODE
DWORD CMprApi :: WNetEnumResource (

     IN HANDLE  hEnum,
     IN OUT LPDWORD lpcCount,
     OUT LPVOID  lpBuffer,
     IN OUT LPDWORD lpBufferSize
)
#else
DWORD CMprApi :: WNetEnumResource (

     IN HANDLE  hEnum,
     IN OUT LPDWORD lpcCount,
     OUT LPVOID  lpBuffer,
     IN OUT LPDWORD lpBufferSize
)
#endif
{
	return m_pfnWNetEnumResource (

		hEnum,
		lpcCount,
		lpBuffer,
		lpBufferSize
	) ;
}

#ifdef UNICODE
DWORD CMprApi :: WNetOpenEnum (

     IN DWORD          dwScope,
     IN DWORD          dwType,
     IN DWORD          dwUsage,
     IN LPNETRESOURCEW lpNetResource,
     OUT LPHANDLE       lphEnum
)
#else
DWORD CMprApi :: WNetOpenEnum (

     IN DWORD          dwScope,
     IN DWORD          dwType,
     IN DWORD          dwUsage,
     IN LPNETRESOURCEA lpNetResource,
     OUT LPHANDLE       lphEnum
)
#endif
{
	return m_pfnWNetOpenEnum (

		dwScope,
		dwType,
		dwUsage,
		lpNetResource,
		lphEnum
	) ;
}

#ifdef UNICODE
DWORD CMprApi :: WNetGetUser (

     IN LPCWSTR  lpName,
     OUT LPWSTR   lpUserName,
     IN OUT LPDWORD   lpnLength
)
#else
DWORD CMprApi :: WNetGetUser (

     IN LPCSTR  lpName,
     OUT LPSTR   lpUserName,
     IN OUT LPDWORD   lpnLength
)
#endif
{
	return m_pfnWNetGetUser (

		lpName,
		lpUserName,
		lpnLength
	) ;
}

DWORD CMprApi :: WNetCloseEnum (

	IN HANDLE   hEnum
)
{
	return m_pfnWNetCloseEnum (

		hEnum
	) ;
}

#ifdef UNICODE
DWORD CMprApi :: WNetGetConnection (

	 IN LPCWSTR lpLocalName,
	 OUT LPWSTR  lpRemoteName,
	 IN OUT LPDWORD  lpnLength
)
#else
DWORD CMprApi :: WNetGetConnection (

	 IN LPCSTR lpLocalName,
	 OUT LPSTR  lpRemoteName,
	 IN OUT LPDWORD  lpnLength
)
#endif
{
	return m_pfnWNetGetConnection (

		lpLocalName,
		lpRemoteName,
		lpnLength
	) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\mprapi.h ===
//=================================================================

//

// MprApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_MprApi_H_
#define	_MprApi_H_

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidMprApi;
extern const TCHAR g_tstrMpr[];

/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

#ifdef UNICODE
typedef DWORD (APIENTRY *PFN_Mpr_WNetEnumResource )
(
     IN HANDLE  hEnum,
     IN OUT LPDWORD lpcCount,
     OUT LPVOID  lpBuffer,
     IN OUT LPDWORD lpBufferSize
);
#else
typedef DWORD (APIENTRY *PFN_Mpr_WNetEnumResource )
(
     IN HANDLE  hEnum,
     IN OUT LPDWORD lpcCount,
     OUT LPVOID  lpBuffer,
     IN OUT LPDWORD lpBufferSize
);
#endif

#ifdef UNICODE
typedef DWORD (APIENTRY *PFN_Mpr_WNetOpenEnum )
(
     IN DWORD          dwScope,
     IN DWORD          dwType,
     IN DWORD          dwUsage,
     IN LPNETRESOURCEW lpNetResource,
     OUT LPHANDLE       lphEnum
);
#else
typedef DWORD (APIENTRY *PFN_Mpr_WNetOpenEnum )
(
     IN DWORD          dwScope,
     IN DWORD          dwType,
     IN DWORD          dwUsage,
     IN LPNETRESOURCEA lpNetResource,
     OUT LPHANDLE       lphEnum
);
#endif

typedef DWORD (APIENTRY *PFN_Mpr_WNetCloseEnum )
(
    IN HANDLE   hEnum
);

#ifdef UNICODE
typedef DWORD (APIENTRY *PFN_Mpr_WNetGetUser )
(
     IN LPCWSTR  lpName,
     OUT LPWSTR   lpUserName,
     IN OUT LPDWORD   lpnLength
    );
#else
typedef DWORD (APIENTRY *PFN_Mpr_WNetGetUser )
(
     IN LPCSTR  lpName,
     OUT LPSTR   lpUserName,
     IN OUT LPDWORD   lpnLength
);
#endif

#ifdef UNICODE
typedef DWORD (APIENTRY *PFN_Mpr_WNetGetConnection )
(
     IN LPCWSTR lpLocalName,
     OUT LPWSTR  lpRemoteName,
     IN OUT LPDWORD  lpnLength
    );
#else
typedef DWORD (APIENTRY *PFN_Mpr_WNetGetConnection )
(
     IN LPCSTR lpLocalName,
     OUT LPSTR  lpRemoteName,
     IN OUT LPDWORD  lpnLength
 );
#endif

/******************************************************************************
 * Wrapper class for Tapi load/unload, for registration with CResourceManager. 
 *****************************************************************************/
class CMprApi : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to Tapi functions.
    // Add new functions here as required.

	PFN_Mpr_WNetEnumResource m_pfnWNetEnumResource ;
	PFN_Mpr_WNetOpenEnum m_pfnWNetOpenEnum ;
	PFN_Mpr_WNetCloseEnum m_pfnWNetCloseEnum ;
	PFN_Mpr_WNetGetUser m_pfnWNetGetUser ;
	PFN_Mpr_WNetGetConnection m_pfnWNetGetConnection ;

public:

    // Constructor and destructor:
    CMprApi(LPCTSTR a_tstrWrappedDllName);
    ~CMprApi();

    // Initialization function to check function pointers.
    virtual bool Init();

    // Member functions wrapping Tapi functions.
    // Add new functions here as required:

#ifdef UNICODE
	DWORD WNetEnumResource (

		 IN HANDLE  hEnum,
		 IN OUT LPDWORD lpcCount,
		 OUT LPVOID  lpBuffer,
		 IN OUT LPDWORD lpBufferSize
	) ;
#else
	DWORD WNetEnumResource (

		 IN HANDLE  hEnum,
		 IN OUT LPDWORD lpcCount,
		 OUT LPVOID  lpBuffer,
		 IN OUT LPDWORD lpBufferSize
	) ;
#endif

#ifdef UNICODE
	DWORD WNetOpenEnum (

		 IN DWORD          dwScope,
		 IN DWORD          dwType,
		 IN DWORD          dwUsage,
		 IN LPNETRESOURCEW lpNetResource,
		 OUT LPHANDLE       lphEnum
	) ;
#else
	DWORD WNetOpenEnum (

		 IN DWORD          dwScope,
		 IN DWORD          dwType,
		 IN DWORD          dwUsage,
		 IN LPNETRESOURCEA lpNetResource,
		 OUT LPHANDLE       lphEnum
	) ;
#endif

#ifdef UNICODE
	DWORD WNetGetUser (

		 IN LPCWSTR  lpName,
		 OUT LPWSTR   lpUserName,
		 IN OUT LPDWORD   lpnLength
	) ;
#else
	DWORD WNetGetUser (

		 IN LPCSTR  lpName,
		 OUT LPSTR   lpUserName,
		 IN OUT LPDWORD   lpnLength
	) ;
#endif

#ifdef UNICODE
	DWORD WNetGetConnection (

		 IN LPCWSTR lpLocalName,
		 OUT LPWSTR  lpRemoteName,
		 IN OUT LPDWORD  lpnLength
	) ;
#else
	DWORD WNetGetConnection (

		 IN LPCSTR lpLocalName,
		 OUT LPSTR  lpRemoteName,
		 IN OUT LPDWORD  lpnLength
	) ;
#endif

	DWORD WNetCloseEnum (

		IN HANDLE   hEnum
	) ;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\ndismisc.h ===
//=================================================================

//

// ndismisc.h -- 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// 
//=================================================================

#ifndef _NDISMISC_
#define _NDISMISC_

#define _PNP_POWER_
#include <ntddip.h> 

// Taken from Ndisapi.h the __stdcall is required here
//
// Definitions for Layer
//
#define NDIS            0x01
#define TDI             0x02

//
// Definitions for Operation
//
#define BIND            0x01
#define UNBIND          0x02
#define RECONFIGURE     0x03
#define UNBIND_FORCE    0x04
#define UNLOAD          0x05
#define REMOVE_DEVICE   0x06    // This is a notification that a device is about to be removed.
//
// Return code from this api is to be treated as a BOOL. Link with ndispnp.lib for this.
//
#ifdef __cplusplus
extern "C" {
#endif

extern
UINT __stdcall
NdisHandlePnPEvent(
    IN  UINT            Layer,
    IN  UINT            Operation,
    IN  PUNICODE_STRING LowerComponent,
    IN  PUNICODE_STRING UpperComponent,
    IN  PUNICODE_STRING BindList,
    IN  PVOID           ReConfigBuffer      OPTIONAL,
    IN  UINT            ReConfigBufferSize  OPTIONAL
    );

#ifdef __cplusplus
}       // extern "C"
#endif


// the following is found in /nt/private/net/config/netcfg/nwlnkcfg/nwlnkipx.cpp and 
//							 /nt/private/net/routing/ipx/autonet/netnum.cpp
#define IPX_RECONFIG_VERSION        0x1

#define RECONFIG_AUTO_DETECT        1
#define RECONFIG_MANUAL             2
#define RECONFIG_PREFERENCE_1       3
#define RECONFIG_NETWORK_NUMBER_1   4
#define RECONFIG_PREFERENCE_2       5
#define RECONFIG_NETWORK_NUMBER_2   6
#define RECONFIG_PREFERENCE_3       7
#define RECONFIG_NETWORK_NUMBER_3   8
#define RECONFIG_PREFERENCE_4       9
#define RECONFIG_NETWORK_NUMBER_4   10

#define RECONFIG_PARAMETERS         10

//
// Main configuration structure.
//

typedef struct _RECONFIG {
   unsigned long  ulVersion;
   BOOLEAN        InternalNetworkNumber;
   BOOLEAN        AdapterParameters[RECONFIG_PARAMETERS];
} RECONFIG, *PRECONFIG;


#endif // _NDISMISC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\msacm32api.h ===
//=================================================================

//

// MsAcm32Api.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_MsAcm32Api_H_
#define	_MsAcm32Api_H_

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidMsAcm32Api;
extern const TCHAR g_tstrMsAcm32[];

/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

#ifdef UNICODE
typedef MMRESULT  (ACMAPI *PFN_MsAcm32_acmDriverDetails )
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILSW     padd,
    DWORD                   fdwDetails
);
#else
typedef MMRESULT  (ACMAPI *PFN_MsAcm32_acmDriverDetails )
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILSA     padd,
    DWORD                   fdwDetails
);
#endif

typedef MMRESULT  (ACMAPI *PFN_MsAcm32_acmDriverEnum )
(
    ACMDRIVERENUMCB         fnCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwEnum
);

/******************************************************************************
 * Wrapper class for Tapi load/unload, for registration with CResourceManager. 
 *****************************************************************************/
class CMsAcm32Api : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to Tapi functions.
    // Add new functions here as required.

	PFN_MsAcm32_acmDriverDetails m_pfnacmDriverDetails ;
	PFN_MsAcm32_acmDriverEnum m_pfnacmDriverEnum ;

public:

    // Constructor and destructor:
    CMsAcm32Api(LPCTSTR a_tstrWrappedDllName);
    ~CMsAcm32Api();

    // Initialization function to check function pointers.
    virtual bool Init();

    // Member functions wrapping Tapi functions.
    // Add new functions here as required:

#ifdef UNICODE
	MMRESULT MsAcm32acmDriverDetails 
	(
		HACMDRIVERID            hadid,
		LPACMDRIVERDETAILSW     padd,
		DWORD                   fdwDetails
	);
#else
	MMRESULT MsAcm32acmDriverDetails
	(
		HACMDRIVERID            hadid,
		LPACMDRIVERDETAILSA     padd,
		DWORD                   fdwDetails
	);
#endif

	MMRESULT  MsAcm32acmDriverEnum (

		ACMDRIVERENUMCB         fnCallback,
		DWORD_PTR               dwInstance,
		DWORD                   fdwEnum
	);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\netapi32api.h ===
//=================================================================

//

// NetApi32Api.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_NETAPI32API_H_
#define	_NETAPI32API_H_



#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmserver.h>
#include <lmerr.h>
#include <ntsecapi.h>
#include <stack>
#include <comdef.h>
#include <dsrole.h> 
#include <dsgetdc.h>

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "DllWrapperBase.h"

extern const GUID g_guidNetApi32Api;
extern const TCHAR g_tstrNetApi32[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_GROUP_ENUM)
(
    LPCWSTR servername, 
    DWORD level, 
    LPBYTE *bufptr,
    DWORD prefmaxlen, 
    LPDWORD entriesread,
    LPDWORD totalentries, 
    PDWORD_PTR  resume_handle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_GROUP_GET_INFO)
(
    LPCWSTR servername,
    LPCWSTR groupname,
    DWORD level,
    LPBYTE *bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_GROUP_SET_INFO)
(
	LPCWSTR servername,
	LPCWSTR groupname,
	DWORD level,
	LPBYTE buf,
	LPDWORD parm_err
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_LOCAL_GROUP_GET_INFO)
(
    LPCWSTR servername,
    LPCWSTR groupname,
    DWORD level,
    LPBYTE *bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_LOCAL_GROUP_SET_INFO)
(
    LPCWSTR servername,
    LPCWSTR groupname,
    DWORD level,
    LPBYTE buf,
	LPDWORD a_parm_err
);
typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_GROUP_GET_USERS)
(
    LPCWSTR servername,
    LPCWSTR groupname,
    DWORD level,
    LPBYTE *bufptr,
    DWORD prefmaxlen,
    LPDWORD entriesread,
    LPDWORD totalentries,
    PDWORD_PTR ResumeHandle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_LOCAL_GROUP_GET_MEMBERS)
(
    LPCWSTR servername,
    LPCWSTR groupname,
    DWORD level,
    LPBYTE *bufptr,
    DWORD prefmaxlen,
    LPDWORD entriesread,
    LPDWORD totalentries,
    PDWORD_PTR ResumeHandle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_LOCAL_GROUP_ENUM)
(
    LPCWSTR servername,
    DWORD level,
    LPBYTE *bufptr,
    DWORD prefmaxlen,
    LPDWORD entriesread,
    LPDWORD totalentries,
    PDWORD_PTR resumehandle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SHARE_ENUM)
(
    LPTSTR servername,
    DWORD level,
    LPBYTE *bufptr,
    DWORD prefmaxlen,
    LPDWORD entriesread,
    LPDWORD totalentries,
    LPDWORD resume_handle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SHARE_GET_INFO)
(
    LPTSTR servername,
    LPTSTR netname,
    DWORD level,
    LPBYTE *bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SHARE_ADD) 
(
	IN  LPTSTR  servername,
	IN  DWORD   level,
	IN  LPBYTE  buf,
	OUT LPDWORD parm_err
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SHARE_ENUM_STICKY) 
(
	IN  LPTSTR      servername,
	IN  DWORD       level,
	OUT LPBYTE      *bufptr,
	IN  DWORD       prefmaxlen,
	OUT LPDWORD     entriesread,
	OUT LPDWORD     totalentries,
	IN OUT LPDWORD  resume_handle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SHARE_SET_INFO) 
(
	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   level,
	IN  LPBYTE  buf,
	OUT LPDWORD parm_err
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SHARE_DEL) 
(
	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   reserved
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SHARE_DEL_STICKY) 
(
	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   reserved
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SHARE_CHECK) 
(
	IN  LPTSTR  servername,
	IN  LPTSTR  device,
	OUT LPDWORD type
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_USER_ENUM)
(
    LPCWSTR servername,
    DWORD level,
    DWORD filter,
    LPBYTE *bufptr,
    DWORD prefmaxlen,
    LPDWORD entriesread,
    LPDWORD totalentries,
    LPDWORD resume_handle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_USER_GET_INFO)
(
    LPCWSTR servername,
    LPCWSTR username,
    DWORD level,
    LPBYTE *bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_USER_SET_INFO)
(
	LPCWSTR a_servername, 
	LPCWSTR a_username,   
	DWORD a_level,       
	LPBYTE a_buf,        
	LPDWORD a_parm_err
);
typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_API_BUFFER_FREE)
(
    void *bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_QUERY_DISPLAY_INFORMATION)
(	
    LPWSTR ServerName,
    DWORD Level,
    DWORD Index,
    DWORD EntriesRequested,
    DWORD PreferredMaximumLength,
    LPDWORD ReturnedEntryCount,
    PVOID *SortedBuffer
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SERVER_SET_INFO)
(
    LPTSTR  servername,
    DWORD level,
    LPBYTE  buf,
    LPDWORD ParmError
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SERVER_GET_INFO)
(
    LPTSTR servername,
    DWORD level,
    LPBYTE *bufptr
);


typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_GET_DC_NAME)
(	LPCWSTR servername,
    LPCWSTR domainname,
    LPBYTE *bufptr 
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_WKSTA_GET_INFO)
(	
    LPWSTR servername,
    DWORD level,
    LPBYTE *bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_GET_ANY_DC_NAME)
(	
    LPWSTR servername,
    LPWSTR domainname,
    LPBYTE *bufptr 
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SERVER_ENUM)
(	
    LPTSTR servername,
    DWORD level,
    LPBYTE *bufptr,
    DWORD prefmaxlen,
    LPDWORD entriesread,
    LPDWORD totalentries,
    DWORD servertype,
    LPTSTR domain,
    LPDWORD resume_handle 
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_USER_MODALS_GET)
(	
    LPWSTR servername,
    DWORD level,
    LPBYTE *bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SCHEDULE_JOB_ADD) 
(
    IN      LPCWSTR         Servername          OPTIONAL,
    IN      LPBYTE          Buffer,
    OUT     LPDWORD         JobId
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SCHEDULE_JOB_DEL) 
(
    IN      LPCWSTR         Servername          OPTIONAL,
    IN      DWORD           MinJobId,
    IN      DWORD           MaxJobId
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SCHEDULE_JOB_ENUM) 
(
    IN      LPCWSTR         Servername          OPTIONAL,
    OUT     LPBYTE          *PointerToBuffer,
    IN      DWORD           PrefferedMaximumLength,
    OUT     LPDWORD         EntriesRead,
    OUT     LPDWORD         TotalEntries,
    IN OUT  LPDWORD         ResumeHandle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SCHEDULE_JOB_GET_INFO) 
(
    IN      LPCWSTR         Servername          OPTIONAL,
    IN      DWORD           JobId,
    OUT     LPBYTE          *PointerToBuffer
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_USE_GET_INFO) 
(
    IN      LPCWSTR         UncServerName       OPTIONAL,
    IN      LPCWSTR         UseName,
    IN      DWORD           Level,
    OUT     LPBYTE          *BufPtr
);

// ******* BEGIN:  NT 4 and over only *******
typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_ENUMERATE_TRUSTED_DOMAINS)
(	
    LPCWSTR servername,
	LPWSTR *domainNames 
) ;

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_DS_GET_DC_NAME)
(	
    LPCTSTR ComputerName, 
	LPCTSTR DomainName,
	GUID *DomainGuid, 
	LPCTSTR SiteName, 
	ULONG Flags,
	PDOMAIN_CONTROLLER_INFO *DomainControllerInfo 
);
// ******* END: NT4 and over only ***********



// ******* BEGIN:  NT 5 and over only *******
typedef NET_API_STATUS (NET_API_FUNCTION *PFN_DS_ROLE_GET_PRIMARY_DOMAIN_INFORMATION)
(
    LPCWSTR servername,
    DSROLE_PRIMARY_DOMAIN_INFO_LEVEL level,
    LPBYTE *bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_DS_ROLE_FREE_MEMORY)
(
    LPBYTE bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NET_RENAME_MACHINE_IN_DOMAIN)
(
  LPCWSTR lpServer,
  LPCWSTR lpNewMachineName,
  LPCWSTR lpAccount,
  LPCWSTR lpPassword,
  DWORD fRenameOptions
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NET_JOIN_DOMAIN)
(
  LPCWSTR lpServer,
  LPCWSTR lpDomain,
  LPCWSTR lpAccountOU,
  LPCWSTR lpAccount,
  LPCWSTR lpPassword,
  DWORD fJoinOptions
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NET_UNJOIN_DOMAIN)
(
  LPCWSTR lpServer,
  LPCWSTR lpAccount,
  LPCWSTR lpPassword,
  DWORD   fUnjoinOptions
);
    
// ******* END: NT5 and over only ***********



/******************************************************************************
 * Wrapper class for Kernel32 load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CNetApi32Api : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to kernel32 functions.
    // Add new functions here as required.
    
    PFN_NETAPI32_NET_GROUP_ENUM                    m_pfnNetGroupEnum;
    PFN_NETAPI32_NET_GROUP_GET_INFO                m_pfnNetGroupGetInfo;
	PFN_NETAPI32_NET_GROUP_SET_INFO                m_pfnNetGroupSetInfo;
    PFN_NETAPI32_NET_LOCAL_GROUP_GET_INFO          m_pfnNetLocalGroupGetInfo;
    PFN_NETAPI32_NET_LOCAL_GROUP_SET_INFO          m_pfnNetLocalGroupSetInfo;
    PFN_NETAPI32_NET_GROUP_GET_USERS               m_pfnNetGroupGetUsers;
    PFN_NETAPI32_NET_LOCAL_GROUP_GET_MEMBERS       m_pfnNetLocalGroupGetMembers;
    PFN_NETAPI32_NET_LOCAL_GROUP_ENUM              m_pfnNetLocalGroupEnum;
    PFN_NETAPI32_NET_SHARE_ENUM                    m_pfnNetShareEnum;
    PFN_NETAPI32_NET_SHARE_GET_INFO                m_pfnNetShareGetInfo;
    PFN_NETAPI32_NET_SHARE_SET_INFO                m_pfnNetShareSetInfo;
    PFN_NETAPI32_NET_SHARE_ADD                     m_pfnNetShareAdd;
    PFN_NETAPI32_NET_SHARE_ENUM_STICKY             m_pfnNetShareEnumSticky;
    PFN_NETAPI32_NET_SHARE_DEL                     m_pfnNetShareDel;
    PFN_NETAPI32_NET_SHARE_DEL_STICKY              m_pfnNetShareDelSticky;
    PFN_NETAPI32_NET_SHARE_CHECK                   m_pfnNetShareCheck;
    PFN_NETAPI32_NET_USER_ENUM                     m_pfnNetUserEnum;
    PFN_NETAPI32_NET_USER_GET_INFO                 m_pfnNetUserGetInfo;
	PFN_NETAPI32_NET_USER_SET_INFO                 m_pfnNetUserSetInfo;
    PFN_NETAPI32_NET_API_BUFFER_FREE               m_pfnNetApiBufferFree;
    PFN_NETAPI32_NET_QUERY_DISPLAY_INFORMATION     m_pfnNetQueryDisplayInformation;
    PFN_NETAPI32_NET_SERVER_SET_INFO               m_pfnNetServerSetInfo;
    PFN_NETAPI32_NET_SERVER_GET_INFO               m_pfnNetServerGetInfo;
    PFN_NETAPI32_NET_GET_DC_NAME                   m_pfnNetGetDCName;
    PFN_NETAPI32_NET_WKSTA_GET_INFO                m_pfnNetWkstaGetInfo;
    PFN_NETAPI32_NET_GET_ANY_DC_NAME               m_pfnNetGetAnyDCName;
    PFN_NETAPI32_NET_SERVER_ENUM                   m_pfnNetServerEnum;
    PFN_NETAPI32_NET_USER_MODALS_GET               m_pfnNetUserModalsGet;
    PFN_NETAPI32_NET_SCHEDULE_JOB_ADD              m_pfnNetScheduleJobAdd;
    PFN_NETAPI32_NET_SCHEDULE_JOB_DEL              m_pfnNetScheduleJobDel;
    PFN_NETAPI32_NET_SCHEDULE_JOB_ENUM             m_pfnNetScheduleJobEnum;
    PFN_NETAPI32_NET_SCHEDULE_JOB_GET_INFO         m_pfnNetScheduleJobGetInfo;
    PFN_NETAPI32_NET_USE_GET_INFO                  m_pfnNetUseGetInfo;
// ******* BEGIN:  NT 4 and over only *******
    PFN_NETAPI32_NET_ENUMERATE_TRUSTED_DOMAINS     m_pfnNetEnumerateTrustedDomains;

#ifdef NTONLY    
	PFN_NETAPI32_DS_GET_DC_NAME                    m_pfnDsGetDcNameW ;
#else
	PFN_NETAPI32_DS_GET_DC_NAME                    m_pfnDsGetDcNameA ;
#endif

	// ******* END: NT4 and over only ***********
// ******* BEGIN:  NT 5 and over only *******
    PFN_DS_ROLE_GET_PRIMARY_DOMAIN_INFORMATION     m_pfnDsRoleGetPrimaryDomainInformation;
    PFN_DS_ROLE_FREE_MEMORY                        m_pfnDsRoleFreeMemory;
    PFN_NET_RENAME_MACHINE_IN_DOMAIN               m_pfnNetRenameMachineInDomain;
    PFN_NET_JOIN_DOMAIN                            m_pfnNetJoinDomain;
    PFN_NET_UNJOIN_DOMAIN                          m_pfnNetUnjoinDomain;
// ******* END: NT5 and over only ***********



public:

    // Constructor and destructor:
    CNetApi32Api(LPCTSTR a_tstrWrappedDllName);
    ~CNetApi32Api();

    // Inherrited initialization function.
    virtual bool Init();

    // Member functions wrapping kernel32 functions.
    // Add new functions here as required:
    NET_API_STATUS NET_API_FUNCTION NetGroupEnum
    (
        LPCWSTR a_servername, 
        DWORD a_level, 
        LPBYTE *a_bufptr,
        DWORD a_prefmaxlen, 
        LPDWORD a_entriesread,
        LPDWORD a_totalentries, 
        PDWORD_PTR  a_resume_handle
    );

    NET_API_STATUS NET_API_FUNCTION NetGroupGetInfo
    (
        LPCWSTR a_servername,
        LPCWSTR a_groupname,
        DWORD a_level,
        LPBYTE *a_bufptr
    );

	NET_API_STATUS NET_API_FUNCTION NetGroupSetInfo
    (
        LPCWSTR servername,
		LPCWSTR groupname,
		DWORD level,
		LPBYTE buf,
		LPDWORD parm_err
    );

    NET_API_STATUS NET_API_FUNCTION NetLocalGroupGetInfo
    (
        LPCWSTR a_servername,
        LPCWSTR a_groupname,
        DWORD a_level,
        LPBYTE *a_bufptr
    );

	NET_API_STATUS NET_API_FUNCTION NetLocalGroupSetInfo
	(  
		LPCWSTR a_servername,      
		LPCWSTR a_groupname,       
		DWORD a_level,             
		LPBYTE a_buf,              
		LPDWORD a_parm_err         
	);


    NET_API_STATUS NET_API_FUNCTION NetGroupGetUsers
    (
        LPCWSTR a_servername,
        LPCWSTR a_groupname,
        DWORD a_level,
        LPBYTE *a_bufptr,
        DWORD a_prefmaxlen,
        LPDWORD a_entriesread,
        LPDWORD a_totalentries,
        PDWORD_PTR a_ResumeHandle
    );

    NET_API_STATUS NET_API_FUNCTION NetLocalGroupGetMembers
    (
        LPCWSTR a_servername,
        LPCWSTR a_groupname,
        DWORD a_level,
        LPBYTE *a_bufptr,
        DWORD a_prefmaxlen,
        LPDWORD a_entriesread,
        LPDWORD a_totalentries,
        PDWORD_PTR a_ResumeHandle
    );

    NET_API_STATUS NET_API_FUNCTION NetLocalGroupEnum
    (
        LPCWSTR a_servername,
        DWORD a_level,
        LPBYTE *a_bufptr,
        DWORD a_prefmaxlen,
        LPDWORD a_entriesread,
        LPDWORD a_totalentries,
        PDWORD_PTR a_resumehandle
    );

    NET_API_STATUS NET_API_FUNCTION NetShareEnum
    (
        LPTSTR a_servername,
        DWORD a_level,
        LPBYTE *a_bufptr,
        DWORD a_prefmaxlen,
        LPDWORD a_entriesread,
        LPDWORD a_totalentries,
        LPDWORD a_resume_handle
    );

    NET_API_STATUS NET_API_FUNCTION NetShareGetInfo
    (
        LPTSTR a_servername,
        LPTSTR a_netname,
        DWORD a_level,
        LPBYTE *a_bufptr
    );

    NET_API_STATUS NET_API_FUNCTION NetShareAdd 
    (
	    LPTSTR  a_servername,
	    DWORD   a_level,
	    LPBYTE  a_buf,
	    LPDWORD a_parm_err
    );

    NET_API_STATUS NET_API_FUNCTION NetShareEnumSticky 
    (
	    LPTSTR      a_servername,
	    DWORD       a_level,
	    LPBYTE      *a_bufptr,
	    DWORD       a_prefmaxlen,
	    LPDWORD     a_entriesread,
	    LPDWORD     a_totalentries,
	    LPDWORD     a_resume_handle
    );

    NET_API_STATUS NET_API_FUNCTION NetShareSetInfo 
    (
	    LPTSTR  a_servername,
	    LPTSTR  a_netname,
	    DWORD   a_level,
	    LPBYTE  a_buf,
	    LPDWORD a_parm_err
    );

    NET_API_STATUS NET_API_FUNCTION NetShareDel 
    (
	    LPTSTR  a_servername,
	    LPTSTR  a_netname,
	    DWORD   a_reserved
    );

    NET_API_STATUS NET_API_FUNCTION NetShareDelSticky 
    (
	    LPTSTR  a_servername,
	    LPTSTR  a_netname,
	    DWORD   a_reserved
    );

    NET_API_STATUS NET_API_FUNCTION NetShareCheck 
    (
	    LPTSTR  a_servername,
	    LPTSTR  a_device,
	    LPDWORD a_type
    );

    NET_API_STATUS NET_API_FUNCTION NetUserEnum
    (
        LPCWSTR a_servername,
        DWORD a_level,
        DWORD a_filter,
        LPBYTE *a_bufptr,
        DWORD a_prefmaxlen,
        LPDWORD a_entriesread,
        LPDWORD a_totalentries,
        LPDWORD a_resume_handle
    );

    NET_API_STATUS NET_API_FUNCTION NetUserGetInfo
    (
        LPCWSTR a_servername,
        LPCWSTR a_username,
        DWORD a_level,
        LPBYTE *a_bufptr
    );

	NET_API_STATUS NET_API_FUNCTION NetUserSetInfo(

		LPCWSTR a_servername, 
		LPCWSTR a_username,   
		DWORD a_level,       
		LPBYTE a_buf,        
		LPDWORD a_parm_err   
	);

    NET_API_STATUS NET_API_FUNCTION NetApiBufferFree
    (
        void *a_bufptr
    );

    NET_API_STATUS NET_API_FUNCTION NetQueryDisplayInformation
    (	
        LPWSTR a_ServerName,
        DWORD a_Level,
        DWORD a_Index,
        DWORD a_EntriesRequested,
        DWORD a_PreferredMaximumLength,
        LPDWORD a_ReturnedEntryCount,
        PVOID *a_SortedBuffer
    );

    NET_API_STATUS NET_API_FUNCTION NetServerSetInfo
    (
        LPTSTR  a_servername,
        DWORD a_level,
        LPBYTE  a_buf,
        LPDWORD a_ParmError
    );

    NET_API_STATUS NET_API_FUNCTION NetServerGetInfo
    (
        LPTSTR a_servername,
        DWORD a_level,
        LPBYTE *a_bufptr
    );


    NET_API_STATUS NET_API_FUNCTION NetGetDCName
    (	LPCWSTR a_servername,
        LPCWSTR a_domainname,
        LPBYTE *a_bufptr 
    );

    NET_API_STATUS NET_API_FUNCTION NetWkstaGetInfo
    (	
        LPWSTR a_servername,
        DWORD a_level,
        LPBYTE *a_bufptr
    );

    NET_API_STATUS NET_API_FUNCTION NetGetAnyDCName
    (	
        LPWSTR a_servername,
        LPWSTR a_domainname,
        LPBYTE *a_bufptr 
    );

    NET_API_STATUS NET_API_FUNCTION NetServerEnum
    (	
        LPTSTR a_servername,
        DWORD a_level,
        LPBYTE *a_bufptr,
        DWORD a_prefmaxlen,
        LPDWORD a_entriesread,
        LPDWORD a_totalentries,
        DWORD a_servertype,
        LPTSTR a_domain,
        LPDWORD a_resume_handle 
    );

    NET_API_STATUS NET_API_FUNCTION NetUserModalsGet
    (	
        LPWSTR a_servername,
        DWORD a_level,
        LPBYTE *a_bufptr
    );

    NET_API_STATUS NET_API_FUNCTION NetScheduleJobAdd 
    (
        LPCWSTR         a_Servername,
        LPBYTE          a_Buffer,
        LPDWORD         a_JobId
    );

    NET_API_STATUS NET_API_FUNCTION NetScheduleJobDel 
    (
        LPCWSTR         a_Servername,
        DWORD           a_MinJobId,
        DWORD           a_MaxJobId
    );

    NET_API_STATUS NET_API_FUNCTION NetScheduleJobEnum 
    (
        LPCWSTR         a_Servername,
        LPBYTE         *a_PointerToBuffer,
        DWORD           a_PrefferedMaximumLength,
        LPDWORD         a_EntriesRead,
        LPDWORD         a_TotalEntries,
        LPDWORD         a_ResumeHandle
    );

    NET_API_STATUS NET_API_FUNCTION NetScheduleJobGetInfo 
    (
        LPCWSTR         a_Servername,
        DWORD           a_JobId,
        LPBYTE         *a_PointerToBuffer
    );

    NET_API_STATUS NET_API_FUNCTION NetUseGetInfo 
    (
        LPCWSTR         a_UncServerName,
        LPCWSTR         a_UseName,
        DWORD           a_Level,
        LPBYTE         *a_BufPtr
    );

    // ******* BEGIN:  NT 4 and over only *******
    bool NET_API_FUNCTION NetEnumerateTrustedDomains
    (	
        LPCWSTR a_servername,
	    LPWSTR *a_domainNames,
        NET_API_STATUS *a_pnasRetval
    ) ;

    bool NET_API_FUNCTION DsGetDCName
    (	
        LPCTSTR a_ComputerName, 
	    LPCTSTR a_DomainName,
	    GUID *a_DomainGuid, 
	    LPCTSTR a_SiteName, 
	    ULONG a_Flags,
	    PDOMAIN_CONTROLLER_INFO *a_DomainControllerInfo,
        NET_API_STATUS *a_pnasRetval 
    );
    // ******* END: NT4 and over only ***********



    // ******* BEGIN:  NT 5 and over only *******
    bool NET_API_FUNCTION DSRoleGetPrimaryDomainInformation
    (
        LPCWSTR a_servername,
        DSROLE_PRIMARY_DOMAIN_INFO_LEVEL a_level,
        LPBYTE *a_bufptr,
        NET_API_STATUS *a_pnasRetval 
    );

    bool NET_API_FUNCTION DSRoleFreeMemory
    (
        LPBYTE a_bufptr,
        NET_API_STATUS *a_pnasRetval 
    );

    bool NET_API_FUNCTION NetRenameMachineInDomain
    (
        LPCWSTR a_lpServer,
        LPCWSTR a_lpNewMachineName,
        LPCWSTR a_lpAccount,
        LPCWSTR a_lpPassword,
        DWORD a_fRenameOptions,
        NET_API_STATUS *a_pnasRetval
    );

    bool NET_API_FUNCTION NetJoinDomain
	(
		LPCWSTR lpServer,
		LPCWSTR lpDomain,
		LPCWSTR lpAccountOU,
		LPCWSTR lpAccount,
		LPCWSTR lpPassword,
		DWORD fJoinOptions,
		NET_API_STATUS *a_pnasRetval
    );

    bool NET_API_FUNCTION NetUnjoinDomain(
		LPCWSTR lpServer,
		LPCWSTR lpAccount,
		LPCWSTR lpPassword,
		DWORD   fUnjoinOptions,
		NET_API_STATUS *a_pnasRetval
    );

    // ******* END: NT5 and over only ***********

};






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\netapi32api.cpp ===
//=================================================================

//

// NetApi32API.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>
#include <winerror.h>
#include "NetApi32Api.h"
#include "DllWrapperCreatorReg.h"

// {EDC5C632-D027-11d2-911F-0060081A46FD}
static const GUID g_guidNetApi32Api =
{0xedc5c632, 0xd027, 0x11d2, { 0x91, 0x1f, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};


static const TCHAR g_tstrNetApi32[] = _T("NETAPI32.DLL");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CNetApi32Api, &g_guidNetApi32Api, g_tstrNetApi32> MyRegisteredNetApi32Wrapper;


/******************************************************************************
 * Constructor
 ******************************************************************************/
CNetApi32Api::CNetApi32Api(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnNetGroupEnum(NULL),
   m_pfnNetGroupGetInfo(NULL),
   m_pfnNetGroupSetInfo(NULL),
   m_pfnNetLocalGroupGetInfo(NULL),
   m_pfnNetLocalGroupSetInfo(NULL),
   m_pfnNetGroupGetUsers(NULL),
   m_pfnNetLocalGroupGetMembers(NULL),
   m_pfnNetLocalGroupEnum(NULL),
   m_pfnNetShareEnum(NULL),
   m_pfnNetShareGetInfo(NULL),
   m_pfnNetShareAdd(NULL),
   m_pfnNetShareEnumSticky(NULL),
   m_pfnNetShareSetInfo(NULL),
   m_pfnNetShareDel(NULL),
   m_pfnNetShareDelSticky(NULL),
   m_pfnNetShareCheck(NULL),
   m_pfnNetUserEnum(NULL),
   m_pfnNetUserGetInfo(NULL),
   m_pfnNetUserSetInfo(NULL),
   m_pfnNetApiBufferFree(NULL),
   m_pfnNetQueryDisplayInformation(NULL),
   m_pfnNetServerSetInfo(NULL),
   m_pfnNetServerGetInfo(NULL),
   m_pfnNetGetDCName(NULL),
   m_pfnNetWkstaGetInfo(NULL),
   m_pfnNetGetAnyDCName(NULL),
   m_pfnNetServerEnum(NULL),
   m_pfnNetUserModalsGet(NULL),
   m_pfnNetScheduleJobAdd(NULL),
   m_pfnNetScheduleJobDel(NULL),
   m_pfnNetScheduleJobEnum(NULL),
   m_pfnNetScheduleJobGetInfo(NULL),
   m_pfnNetUseGetInfo(NULL),
// ******* BEGIN:  NT 4 and over only *******
   m_pfnNetEnumerateTrustedDomains(NULL),

#ifdef NTONLY
   m_pfnDsGetDcNameW(NULL),
#else
   m_pfnDsGetDcNameA(NULL),
#endif

// ******* END: NT4 and over only ***********
// ******* BEGIN:  NT 5 and over only *******
   m_pfnDsRoleGetPrimaryDomainInformation(NULL),
   m_pfnDsRoleFreeMemory(NULL),
   m_pfnNetRenameMachineInDomain(NULL),
   m_pfnNetJoinDomain(NULL),
   m_pfnNetUnjoinDomain(NULL)

// ******* END: NT5 and over only ***********
{
}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CNetApi32Api::~CNetApi32Api()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CNetApi32Api::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
        m_pfnNetGroupEnum = (PFN_NETAPI32_NET_GROUP_ENUM)
                                    GetProcAddress("NetGroupEnum");
        m_pfnNetGroupGetInfo = (PFN_NETAPI32_NET_GROUP_GET_INFO)
                                    GetProcAddress("NetGroupGetInfo");
		m_pfnNetGroupSetInfo = (PFN_NETAPI32_NET_GROUP_SET_INFO)
                                    GetProcAddress("NetGroupSetInfo");
        m_pfnNetLocalGroupGetInfo = (PFN_NETAPI32_NET_LOCAL_GROUP_GET_INFO)
                                    GetProcAddress("NetLocalGroupGetInfo");
		m_pfnNetLocalGroupSetInfo = (PFN_NETAPI32_NET_LOCAL_GROUP_SET_INFO)
                                    GetProcAddress("NetLocalGroupSetInfo");
        m_pfnNetGroupGetUsers = (PFN_NETAPI32_NET_GROUP_GET_USERS)
                                    GetProcAddress("NetGroupGetUsers");
        m_pfnNetLocalGroupGetMembers = (PFN_NETAPI32_NET_LOCAL_GROUP_GET_MEMBERS)
                                    GetProcAddress("NetLocalGroupGetMembers");
        m_pfnNetLocalGroupEnum = (PFN_NETAPI32_NET_LOCAL_GROUP_ENUM)
                                    GetProcAddress("NetLocalGroupEnum");
        m_pfnNetShareEnum = (PFN_NETAPI32_NET_SHARE_ENUM)
                                    GetProcAddress("NetShareEnum");
        m_pfnNetShareGetInfo = (PFN_NETAPI32_NET_SHARE_GET_INFO)
                                    GetProcAddress("NetShareGetInfo");
        m_pfnNetShareAdd = (PFN_NETAPI32_NET_SHARE_ADD)
                                    GetProcAddress("NetShareAdd");
        m_pfnNetShareEnumSticky = (PFN_NETAPI32_NET_SHARE_ENUM_STICKY)
                                    GetProcAddress("NetShareEnumSticky");
        m_pfnNetShareSetInfo = (PFN_NETAPI32_NET_SHARE_SET_INFO)
                                    GetProcAddress("NetShareSetInfo");
        m_pfnNetShareDel = (PFN_NETAPI32_NET_SHARE_DEL)
                                    GetProcAddress("NetShareDel");
        m_pfnNetShareDelSticky = (PFN_NETAPI32_NET_SHARE_DEL_STICKY)
                                    GetProcAddress("NetShareDelSticky");
        m_pfnNetShareCheck = (PFN_NETAPI32_NET_SHARE_CHECK)
                                    GetProcAddress("NetShareCheck");
        m_pfnNetUserEnum = (PFN_NETAPI32_NET_USER_ENUM)
                                    GetProcAddress("NetUserEnum");
        m_pfnNetUserGetInfo = (PFN_NETAPI32_NET_USER_GET_INFO)
                                    GetProcAddress("NetUserGetInfo");
		m_pfnNetUserSetInfo = (PFN_NETAPI32_NET_USER_SET_INFO)
                                    GetProcAddress("NetUserSetInfo");
        m_pfnNetGroupEnum = (PFN_NETAPI32_NET_GROUP_ENUM)
                                    GetProcAddress("NetGroupEnum");
        m_pfnNetApiBufferFree = (PFN_NETAPI32_NET_API_BUFFER_FREE)
                                    GetProcAddress("NetApiBufferFree");
        m_pfnNetQueryDisplayInformation = (PFN_NETAPI32_NET_QUERY_DISPLAY_INFORMATION)
                                    GetProcAddress("NetQueryDisplayInformation");
        m_pfnNetServerSetInfo = (PFN_NETAPI32_NET_SERVER_SET_INFO)
                                    GetProcAddress("NetServerSetInfo");
        m_pfnNetServerGetInfo = (PFN_NETAPI32_NET_SERVER_GET_INFO)
                                    GetProcAddress("NetServerGetInfo");
        m_pfnNetGetDCName = (PFN_NETAPI32_NET_GET_DC_NAME)
                                    GetProcAddress("NetGetDCName");
        m_pfnNetWkstaGetInfo = (PFN_NETAPI32_NET_WKSTA_GET_INFO)
                                    GetProcAddress("NetWkstaGetInfo");
        m_pfnNetGetAnyDCName = (PFN_NETAPI32_NET_GET_ANY_DC_NAME)
                                    GetProcAddress("NetGetAnyDCName");
        m_pfnNetServerEnum = (PFN_NETAPI32_NET_SERVER_ENUM)
                                    GetProcAddress("NetServerEnum");
        m_pfnNetUserModalsGet = (PFN_NETAPI32_NET_USER_MODALS_GET)
                                    GetProcAddress("NetUserModalsGet");
        m_pfnNetScheduleJobAdd = (PFN_NETAPI32_NET_SCHEDULE_JOB_ADD)
                                    GetProcAddress("NetScheduleJobAdd");
        m_pfnNetScheduleJobDel = (PFN_NETAPI32_NET_SCHEDULE_JOB_DEL)
                                    GetProcAddress("NetScheduleJobDel");
        m_pfnNetScheduleJobEnum = (PFN_NETAPI32_NET_SCHEDULE_JOB_ENUM)
                                    GetProcAddress("NetScheduleJobEnum");
        m_pfnNetScheduleJobGetInfo = (PFN_NETAPI32_NET_SCHEDULE_JOB_GET_INFO)
                                    GetProcAddress("NetScheduleJobGetInfo");
        m_pfnNetUseGetInfo = (PFN_NETAPI32_NET_USE_GET_INFO)
                                    GetProcAddress("NetUseGetInfo");

        // ******* BEGIN:  NT 4 and over only *******
        m_pfnNetEnumerateTrustedDomains = (PFN_NETAPI32_NET_ENUMERATE_TRUSTED_DOMAINS)
                                    GetProcAddress("NetEnumerateTrustedDomains");
#ifdef NTONLY
        m_pfnDsGetDcNameW = (PFN_NETAPI32_DS_GET_DC_NAME)
                                    GetProcAddress("DsGetDcNameW");
#else
		m_pfnDsGetDcNameA = (PFN_NETAPI32_DS_GET_DC_NAME)
                                    GetProcAddress("DsGetDcNameA");
#endif

        // ******* END: NT4 and over only ***********
        // ******* BEGIN:  NT 5 and over only *******
        m_pfnDsRoleGetPrimaryDomainInformation = (PFN_DS_ROLE_GET_PRIMARY_DOMAIN_INFORMATION)
                                    GetProcAddress("DsRoleGetPrimaryDomainInformation");
        m_pfnDsRoleFreeMemory = (PFN_DS_ROLE_FREE_MEMORY)
                                    GetProcAddress("DsRoleFreeMemory");
        m_pfnNetRenameMachineInDomain = (PFN_NET_RENAME_MACHINE_IN_DOMAIN)
                                    GetProcAddress("NetRenameMachineInDomain");
        m_pfnNetJoinDomain = (PFN_NET_JOIN_DOMAIN)
                                    GetProcAddress("NetJoinDomain");
        m_pfnNetUnjoinDomain = (PFN_NET_UNJOIN_DOMAIN)
                                    GetProcAddress("NetUnjoinDomain");
        // ******* END: NT5 and over only ***********



        // Note: Returns true as long as the core functions are there.  The
        // nt4 and nt5 and over functions are optionally present; users should
        // call the function GetDllVersion (inherrited from the base class)
        // to check if the function is expected to be present based on the
        // version of the dll. Or they can rely on the fact that the function
        // will return false if the pointer is invalid (see function definition
        // below).
        if(m_pfnNetGroupEnum == NULL ||
           m_pfnNetGroupGetInfo == NULL ||
		   m_pfnNetGroupSetInfo == NULL ||
           m_pfnNetLocalGroupGetInfo == NULL ||
           m_pfnNetLocalGroupSetInfo == NULL ||
           m_pfnNetGroupGetUsers == NULL ||
           m_pfnNetLocalGroupGetMembers == NULL ||
           m_pfnNetLocalGroupEnum == NULL ||
           m_pfnNetShareEnum == NULL ||
           m_pfnNetShareGetInfo == NULL ||
           m_pfnNetShareAdd == NULL ||
           m_pfnNetShareEnumSticky == NULL ||
           m_pfnNetShareSetInfo == NULL ||
           m_pfnNetShareDel == NULL ||
           m_pfnNetShareDelSticky == NULL ||
           m_pfnNetShareCheck == NULL ||
           m_pfnNetUserEnum == NULL ||
           m_pfnNetUserGetInfo == NULL ||
		   m_pfnNetUserSetInfo == NULL ||
           m_pfnNetApiBufferFree == NULL ||
           m_pfnNetQueryDisplayInformation == NULL ||
           m_pfnNetServerSetInfo == NULL ||
           m_pfnNetServerGetInfo == NULL ||
           m_pfnNetGetDCName == NULL ||
           m_pfnNetWkstaGetInfo == NULL ||
           m_pfnNetGetAnyDCName == NULL ||
           m_pfnNetServerEnum == NULL ||
           m_pfnNetUserModalsGet == NULL ||
           m_pfnNetScheduleJobAdd == NULL ||
           m_pfnNetScheduleJobDel == NULL ||
           m_pfnNetScheduleJobEnum == NULL ||
           m_pfnNetScheduleJobGetInfo == NULL ||
           m_pfnNetUseGetInfo == NULL)
        {
            fRet = false;
            LogErrorMessage(L"Failed find entrypoint in NetApi32Api");
        }
    }
    return fRet;
}




/******************************************************************************
 * Member functions wrapping NetApi32 api functions. Add new functions here
 * as required.
 ******************************************************************************/
NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetGroupEnum
(
    LPCWSTR a_servername,
    DWORD a_level,
    LPBYTE *a_bufptr,
    DWORD a_prefmaxlen,
    LPDWORD a_entriesread,
    LPDWORD a_totalentries,
    PDWORD_PTR  a_resume_handle
)
{
    return m_pfnNetGroupEnum(a_servername, a_level, a_bufptr, a_prefmaxlen,
                             a_entriesread, a_totalentries, a_resume_handle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetGroupGetInfo
(
    LPCWSTR a_servername,
    LPCWSTR a_groupname,
    DWORD a_level,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetGroupGetInfo(a_servername, a_groupname, a_level, a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetGroupSetInfo
(
    LPCWSTR a_servername,
    LPCWSTR a_groupname,
    DWORD a_level,
    LPBYTE a_buf,
	LPDWORD parm_err
)
{
    return m_pfnNetGroupSetInfo(a_servername, a_groupname, a_level, a_buf, parm_err ) ;
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetLocalGroupGetInfo
(
    LPCWSTR a_servername,
    LPCWSTR a_groupname,
    DWORD a_level,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetLocalGroupGetInfo(a_servername, a_groupname,
                                     a_level, a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetLocalGroupSetInfo
(
	LPCWSTR a_servername,
	LPCWSTR a_groupname,
	DWORD a_level,
	LPBYTE a_buf,
	LPDWORD a_parm_err
)
{
    return m_pfnNetLocalGroupSetInfo(	a_servername,
										a_groupname,
										a_level,
										a_buf,
										a_parm_err ) ;
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetGroupGetUsers
(
    LPCWSTR a_servername,
    LPCWSTR a_groupname,
    DWORD a_level,
    LPBYTE *a_bufptr,
    DWORD a_prefmaxlen,
    LPDWORD a_entriesread,
    LPDWORD a_totalentries,
    PDWORD_PTR a_ResumeHandle
)
{
    return m_pfnNetGroupGetUsers(a_servername, a_groupname, a_level, a_bufptr,
                                 a_prefmaxlen, a_entriesread, a_totalentries,
                                 a_ResumeHandle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetLocalGroupGetMembers
(
    LPCWSTR a_servername,
    LPCWSTR a_groupname,
    DWORD a_level,
    LPBYTE *a_bufptr,
    DWORD a_prefmaxlen,
    LPDWORD a_entriesread,
    LPDWORD a_totalentries,
    PDWORD_PTR a_ResumeHandle
)
{
    return m_pfnNetLocalGroupGetMembers(a_servername, a_groupname, a_level,
                                        a_bufptr, a_prefmaxlen, a_entriesread,
                                        a_totalentries, a_ResumeHandle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetLocalGroupEnum
(
    LPCWSTR a_servername,
    DWORD a_level,
    LPBYTE *a_bufptr,
    DWORD a_prefmaxlen,
    LPDWORD a_entriesread,
    LPDWORD a_totalentries,
    PDWORD_PTR a_resumehandle
)
{
    return m_pfnNetLocalGroupEnum(a_servername, a_level, a_bufptr, a_prefmaxlen,
                                  a_entriesread, a_totalentries,
                                  a_resumehandle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetShareEnum
(
    LPTSTR a_servername,
    DWORD a_level,
    LPBYTE *a_bufptr,
    DWORD a_prefmaxlen,
    LPDWORD a_entriesread,
    LPDWORD a_totalentries,
    LPDWORD a_resume_handle
)
{
    return m_pfnNetShareEnum(a_servername, a_level, a_bufptr, a_prefmaxlen,
                             a_entriesread, a_totalentries, a_resume_handle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetShareGetInfo
(
    LPTSTR a_servername,
    LPTSTR a_netname,
    DWORD a_level,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetShareGetInfo(a_servername, a_netname, a_level, a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetShareAdd
(
	LPTSTR  a_servername,
	DWORD   a_level,
	LPBYTE  a_buf,
	LPDWORD a_parm_err
)
{
    return m_pfnNetShareAdd(a_servername, a_level, a_buf , a_parm_err);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetShareEnumSticky
(
	LPTSTR      a_servername,
	DWORD       a_level,
	LPBYTE      *a_bufptr,
	DWORD       a_prefmaxlen,
	LPDWORD     a_entriesread,
	LPDWORD     a_totalentries,
	LPDWORD     a_resume_handle
)
{
    return m_pfnNetShareEnumSticky(a_servername, a_level, a_bufptr,
                                   a_prefmaxlen, a_entriesread,
                                   a_totalentries, a_resume_handle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetShareSetInfo
(
	LPTSTR  a_servername,
	LPTSTR  a_netname,
	DWORD   a_level,
	LPBYTE  a_buf,
	LPDWORD a_parm_err
)
{
    return m_pfnNetShareSetInfo(a_servername, a_netname,
                                a_level, a_buf, a_parm_err);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetShareDel
(
	LPTSTR  a_servername,
	LPTSTR  a_netname,
	DWORD   a_reserved
)
{
    return m_pfnNetShareDel(a_servername, a_netname, a_reserved);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetShareDelSticky
(
	LPTSTR  a_servername,
	LPTSTR  a_netname,
	DWORD   a_reserved
)
{
    return m_pfnNetShareDelSticky(a_servername, a_netname, a_reserved);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetShareCheck
(
	LPTSTR  a_servername,
	LPTSTR  a_device,
	LPDWORD a_type
)
{
    return m_pfnNetShareCheck(a_servername, a_device, a_type);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetUserEnum
(
    LPCWSTR a_servername,
    DWORD a_level,
    DWORD a_filter,
    LPBYTE *a_bufptr,
    DWORD a_prefmaxlen,
    LPDWORD a_entriesread,
    LPDWORD a_totalentries,
    LPDWORD a_resume_handle
)
{
    return m_pfnNetUserEnum(a_servername, a_level, a_filter,
                            a_bufptr, a_prefmaxlen, a_entriesread,
                            a_totalentries, a_resume_handle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetUserGetInfo
(
    LPCWSTR a_servername,
    LPCWSTR a_username,
    DWORD a_level,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetUserGetInfo(a_servername, a_username, a_level, a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetUserSetInfo(

  LPCWSTR a_servername,
  LPCWSTR a_username,
  DWORD a_level,
  LPBYTE a_buf,
  LPDWORD a_parm_err
)
{
	return m_pfnNetUserSetInfo( a_servername, a_username, a_level, a_buf, a_parm_err) ;
}


NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetApiBufferFree
(
    void *a_bufptr
)
{
    return m_pfnNetApiBufferFree(a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetQueryDisplayInformation
(
    LPWSTR a_ServerName,
    DWORD a_Level,
    DWORD a_Index,
    DWORD a_EntriesRequested,
    DWORD a_PreferredMaximumLength,
    LPDWORD a_ReturnedEntryCount,
    PVOID *a_SortedBuffer
)
{
    return m_pfnNetQueryDisplayInformation(a_ServerName, a_Level, a_Index,
                                           a_EntriesRequested,
                                           a_PreferredMaximumLength,
                                           a_ReturnedEntryCount,
                                           a_SortedBuffer);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetServerSetInfo
(
    LPTSTR  a_servername,
    DWORD a_level,
    LPBYTE  a_buf,
    LPDWORD a_ParmError
)
{
    return m_pfnNetServerSetInfo(a_servername, a_level, a_buf, a_ParmError);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetServerGetInfo
(
    LPTSTR a_servername,
    DWORD a_level,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetServerGetInfo(a_servername, a_level, a_bufptr);
}


NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetGetDCName
(	LPCWSTR a_servername,
    LPCWSTR a_domainname,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetGetDCName(a_servername, a_domainname, a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetWkstaGetInfo
(
    LPWSTR a_servername,
    DWORD a_level,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetWkstaGetInfo(a_servername, a_level, a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetGetAnyDCName
(
    LPWSTR a_servername,
    LPWSTR a_domainname,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetGetAnyDCName(a_servername, a_domainname, a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetServerEnum
(
    LPTSTR a_servername,
    DWORD a_level,
    LPBYTE *a_bufptr,
    DWORD a_prefmaxlen,
    LPDWORD a_entriesread,
    LPDWORD a_totalentries,
    DWORD a_servertype,
    LPTSTR a_domain,
    LPDWORD a_resume_handle
)
{
    return m_pfnNetServerEnum(a_servername, a_level, a_bufptr, a_prefmaxlen,
                              a_entriesread, a_totalentries, a_servertype,
                              a_domain, a_resume_handle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetUserModalsGet
(
    LPWSTR a_servername,
    DWORD a_level,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetUserModalsGet(a_servername, a_level, a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetScheduleJobAdd
(
    LPCWSTR a_Servername,
    LPBYTE  a_Buffer,
    LPDWORD a_JobId
)
{
    return m_pfnNetScheduleJobAdd(a_Servername, a_Buffer, a_JobId);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetScheduleJobDel
(
    LPCWSTR a_Servername,
    DWORD   a_MinJobId,
    DWORD   a_MaxJobId
)
{
    return m_pfnNetScheduleJobDel(a_Servername, a_MinJobId , a_MaxJobId);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetScheduleJobEnum
(
    LPCWSTR  a_Servername,
    LPBYTE  *a_PointerToBuffer,
    DWORD    a_PrefferedMaximumLength,
    LPDWORD  a_EntriesRead,
    LPDWORD  a_TotalEntries,
    LPDWORD  a_ResumeHandle
)
{
    return m_pfnNetScheduleJobEnum(a_Servername, a_PointerToBuffer,
                                   a_PrefferedMaximumLength, a_EntriesRead,
                                   a_TotalEntries, a_ResumeHandle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetScheduleJobGetInfo
(
    LPCWSTR  a_Servername,
    DWORD    a_JobId,
    LPBYTE  *a_PointerToBuffer
)
{
    return m_pfnNetScheduleJobGetInfo(a_Servername, a_JobId ,
                                      a_PointerToBuffer);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetUseGetInfo
(
    LPCWSTR  a_UncServerName,
    LPCWSTR  a_UseName,
    DWORD    a_Level,
    LPBYTE  *a_BufPtr
)
{
    return m_pfnNetUseGetInfo(a_UncServerName, a_UseName, a_Level, a_BufPtr);
}


// ******* BEGIN:  NT 4 and over only *******

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool NET_API_FUNCTION CNetApi32Api::NetEnumerateTrustedDomains
(
    LPCWSTR a_servername,
	LPWSTR *a_domainNames,
    NET_API_STATUS *a_pnasRetval
)
{
    bool t_fExists = false;
    if(m_pfnNetEnumerateTrustedDomains != NULL)
    {
        NET_API_STATUS t_nasTemp = m_pfnNetEnumerateTrustedDomains(a_servername,
                                                                   a_domainNames);
        t_fExists = true;

        if(a_pnasRetval != NULL)
        {
            *a_pnasRetval = t_nasTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool NET_API_FUNCTION CNetApi32Api::DsGetDCName
(
    LPCTSTR a_ComputerName,
	LPCTSTR a_DomainName,
	GUID *a_DomainGuid,
	LPCTSTR a_SiteName,
	ULONG a_Flags,
	PDOMAIN_CONTROLLER_INFO *a_DomainControllerInfo,
    NET_API_STATUS *a_pnasRetval
)
{
    bool t_fExists = false;
	PVOID pfn = NULL ;

#ifdef NTONLY
	pfn = m_pfnDsGetDcNameW ;
#else
	pfn = m_pfnDsGetDcNameA ;
#endif

    if( pfn != NULL )
    {
#ifdef NTONLY
        NET_API_STATUS t_nasTemp = m_pfnDsGetDcNameW(a_ComputerName,
                            a_DomainName, a_DomainGuid, a_SiteName, a_Flags,
                            a_DomainControllerInfo);
#else
        NET_API_STATUS t_nasTemp = m_pfnDsGetDcNameA(a_ComputerName,
                            a_DomainName, a_DomainGuid, a_SiteName, a_Flags,
                            a_DomainControllerInfo);
#endif
        t_fExists = true;

        if(a_pnasRetval != NULL)
        {
            *a_pnasRetval = t_nasTemp;
        }
    }
    return t_fExists;
}
// ******* END: NT4 and over only ***********



// ******* BEGIN:  NT 5 and over only *******


// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool NET_API_FUNCTION CNetApi32Api::DSRoleGetPrimaryDomainInformation
(
    LPCWSTR a_servername,
    DSROLE_PRIMARY_DOMAIN_INFO_LEVEL a_level,
    LPBYTE *a_bufptr,
    NET_API_STATUS *a_pnasRetval
)
{
    bool t_fExists = false;
    if(m_pfnDsRoleGetPrimaryDomainInformation != NULL)
    {
        NET_API_STATUS t_nasTemp = m_pfnDsRoleGetPrimaryDomainInformation(
                                                  a_servername, a_level,
                                                  a_bufptr);
        t_fExists = true;

        if(a_pnasRetval != NULL)
        {
            *a_pnasRetval = t_nasTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool NET_API_FUNCTION CNetApi32Api::DSRoleFreeMemory
(
    LPBYTE a_bufptr,
    NET_API_STATUS *a_pnasRetval
)
{
    bool t_fExists = false;
    if(m_pfnDsRoleFreeMemory != NULL)
    {
        NET_API_STATUS t_nasTemp = m_pfnDsRoleFreeMemory(a_bufptr);
        t_fExists = true;

        if(a_pnasRetval != NULL)
        {
            *a_pnasRetval = t_nasTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool NET_API_FUNCTION CNetApi32Api::NetRenameMachineInDomain
(
  LPCWSTR a_lpServer,
  LPCWSTR a_lpNewMachineName,
  LPCWSTR a_lpAccount,
  LPCWSTR a_lpPassword,
  DWORD a_fRenameOptions,
  NET_API_STATUS *a_pnasRetval
)
{
    bool t_fExists = false;
    if(m_pfnNetRenameMachineInDomain != NULL)
    {
        NET_API_STATUS t_nasTemp = m_pfnNetRenameMachineInDomain(a_lpServer,
                                                                    a_lpNewMachineName,
                                                                    a_lpAccount,
                                                                    a_lpPassword,
                                                                    a_fRenameOptions                                                                 
                                                                    );
        t_fExists = true;

        if(a_pnasRetval != NULL)
        {
            *a_pnasRetval = t_nasTemp;
        }
    }
    return t_fExists;

}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool NET_API_FUNCTION CNetApi32Api::NetJoinDomain
(
	LPCWSTR lpServer,
	LPCWSTR lpDomain,
	LPCWSTR lpAccountOU,
	LPCWSTR lpAccount,
	LPCWSTR lpPassword,
	DWORD fJoinOptions,
	NET_API_STATUS *a_pnasRetval
)
{
    bool t_fExists = false;
    if(m_pfnNetJoinDomain != NULL)
    {
        NET_API_STATUS t_nasTemp = m_pfnNetJoinDomain(lpServer,
														lpDomain,
														lpAccountOU,
														lpAccount,
														lpPassword,
														fJoinOptions);
        t_fExists = true;

        if(a_pnasRetval != NULL)
        {
            *a_pnasRetval = t_nasTemp;
        }
    }

    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool NET_API_FUNCTION CNetApi32Api::NetUnjoinDomain
(
	LPCWSTR lpServer,
	LPCWSTR lpAccount,
	LPCWSTR lpPassword,
	DWORD   fUnjoinOptions,
	NET_API_STATUS *a_pnasRetval
)
{
    bool t_fExists = false;
    if(m_pfnNetUnjoinDomain != NULL)
    {
        NET_API_STATUS t_nasTemp = m_pfnNetUnjoinDomain(lpServer,
														lpAccount,
														lpPassword,
														fUnjoinOptions);
        t_fExists = true;

        if(a_pnasRetval != NULL)
        {
            *a_pnasRetval = t_nasTemp;
        }
    }

    return t_fExists;
}
// ******* END: NT5 and over only ***********
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\nt4svctoresmap.h ===
//=================================================================

//

// NT4SvcToResMap.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __NT4SVCTORESMAP_H__
#define __NT4SVCTORESMAP_H__

#ifdef NTONLY

#include <map>
#include "chwres.h"

typedef	std::map<CHString,CHPtrArray*>				NT4SvcToResourceMap;
typedef	std::map<CHString,CHPtrArray*>::iterator	NT4SvcToResourceMapIter;

class CNT4ServiceToResourceMap
{
	public:
		CNT4ServiceToResourceMap();
		~CNT4ServiceToResourceMap();

		DWORD NumServiceResources( LPCTSTR pszServiceName );
		LPRESOURCE_DESCRIPTOR GetServiceResource( LPCTSTR pszServiceName, DWORD dwIndex );

	private:

		BOOL InitializeMap( void );
		BOOL WalkResourceNodes( LPRESOURCE_DESCRIPTOR pResourceDescriptor );
		void Clear( void );

		NT4SvcToResourceMap		m_map;
	    CHWResource				m_HardwareResource;

};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\ntdevtosvcsearch.h ===
//=================================================================

//

// NtDevToSvcSearch.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __NTDEVTOSVCSEARCH_H__
#define __NTDEVTOSVCSEARCH_H__

#define DEVTOSVC_BASEKEYPATH		_T("HARDWARE\\RESOURCEMAP")
#define	RAWVALUENAME_FMAT			_T("\\Device\\%s.Raw")
#define	TRANSLATEDVALUENAME_FMAT	_T("\\Device\\%s.Translated")

class CNTDeviceToServiceSearch : public CRegistrySearch
{

public:

	//Construction/Destruction
	CNTDeviceToServiceSearch();
	~CNTDeviceToServiceSearch();

	// Single method for finding an NT service name based off of a device name
	BOOL	Find( LPCTSTR pszDeviceName, CHString& strServiceName );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\nt4svctoresmap.cpp ===
/////////////////////////////////////////////////////////////////////////

//

//  Nt4SvcToResMap.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    10/15/97        Sanj        Created by Sanj
//              10/17/97        jennymc     Moved things a tiny bit
//
/////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <assertbreak.h>
#include <cregcls.h>
#include "ntdevtosvcsearch.h"
#include "nt4svctoresmap.h"

#ifdef NTONLY
// The Map we use to back up this class is an STL Template, so make sure we have the
// std namespace available to us.

using namespace std;

CNT4ServiceToResourceMap::CNT4ServiceToResourceMap( void )
:	m_HardwareResource(),
	m_map()
{
	InitializeMap();
}

CNT4ServiceToResourceMap::~CNT4ServiceToResourceMap( void )
{
	Clear();
}

BOOL CNT4ServiceToResourceMap::InitializeMap( void )
{
	BOOL	fReturn = FALSE;

	//=======================================
	// Create hardware system resource list &
	// get the head of the list
	//=======================================
	m_HardwareResource.CreateSystemResourceLists();

	if ( WalkResourceNodes( m_HardwareResource._SystemResourceList.InterruptHead ) )
	{
		if ( WalkResourceNodes( m_HardwareResource._SystemResourceList.PortHead ) )
		{
			if ( WalkResourceNodes( m_HardwareResource._SystemResourceList.MemoryHead ) )
			{
				fReturn = WalkResourceNodes( m_HardwareResource._SystemResourceList.DmaHead );
			}
		}
	}

	return fReturn;
}

BOOL CNT4ServiceToResourceMap::WalkResourceNodes( LPRESOURCE_DESCRIPTOR pResourceDescriptor )
{
   	CNTDeviceToServiceSearch	devSearch;
	CHString					strOwnerServiceName;
	BOOL						fReturn = TRUE;
	NT4SvcToResourceMapIter		mapIter;

	// For each descriptor we find, get the resource owner, then convert the name (if
	// it is not a HAL resource) to an NT service name.  From there, if the name does
	// not already exist in the map, we need to allocate a new array, otherwise, get
	// the existing pointer.  Then add the resource descriptor to the array, so we end
	// up with a structure where a service name will get us to a list of resources owned
	// by said service.

	while ( NULL != pResourceDescriptor && fReturn )
	{
//		if	(	!strstr( pResourceDescriptor->Owner->Name,"HAL")
//			&&	devSearch.Find( pResourceDescriptor->Owner->Name, strOwnerServiceName ) )

//		{
			// Because the CHString compare is case sensitive, and the names
			// of our services as we retrieve them are not necessarily so,
			// we uppercase everything so we are theoretically forcing
			// case insensitivity.

        // Before we used to do an (expensive) scan of the registry.  Now,
        // I store the registry key in the resource structure.
        strOwnerServiceName.Empty();
        CHString sParse(pResourceDescriptor->Owner->KeyName);

        // Parse off the last part of the registry key name
        int iWhere = sParse.ReverseFind(_T('\\'));
        if (iWhere != -1)
        {
            strOwnerServiceName = sParse.Mid(iWhere + 1);
        }
        else
        {
            // If something went wrong, fall back to the other way
            devSearch.Find( pResourceDescriptor->Owner->Name, strOwnerServiceName);
            ASSERT_BREAK(0);
        }

        if (!strOwnerServiceName.IsEmpty())
        {

			strOwnerServiceName.MakeUpper();
			CHPtrArray*	pPtrArray = NULL;

			if( ( mapIter = m_map.find( strOwnerServiceName ) ) == m_map.end() )
			{
				pPtrArray = new CHPtrArray;
                if (pPtrArray == NULL)
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                try
                {
				    m_map[strOwnerServiceName] = pPtrArray;
                }
                catch ( ... )
                {
                    delete pPtrArray;
                    throw ;
                }
			}
			else
			{
				pPtrArray = mapIter->second;
			}

			if ( NULL != pPtrArray )
			{
				pPtrArray->Add( pResourceDescriptor );
			}
			else
			{
				fReturn = FALSE;
			}

		}	// If owner generated a valid service name

		pResourceDescriptor = pResourceDescriptor->NextSame;
	}

	return fReturn;

}

DWORD CNT4ServiceToResourceMap::NumServiceResources( LPCTSTR pszServiceName )
{
	DWORD						dwNumResources = 0;
	NT4SvcToResourceMapIter		mapIter;

	// Upper case for case-insensitivity
	CHString					strUpperCaseServiceName( pszServiceName );
	strUpperCaseServiceName.MakeUpper();

	if( ( mapIter = m_map.find( strUpperCaseServiceName ) ) != m_map.end() )
	{

		CHPtrArray*	pResources = mapIter->second;

		if ( NULL != pResources )
		{
			dwNumResources = pResources->GetSize();
		}

	}

	return dwNumResources;
}

LPRESOURCE_DESCRIPTOR CNT4ServiceToResourceMap::GetServiceResource( LPCTSTR pszServiceName, DWORD dwIndex )
{
	LPRESOURCE_DESCRIPTOR		pResourceDescriptor = NULL;
	NT4SvcToResourceMapIter		mapIter;

	// Upper case for case-insensitivity
	CHString					strUpperCaseServiceName( pszServiceName );
	strUpperCaseServiceName.MakeUpper();

	if( ( mapIter = m_map.find( strUpperCaseServiceName ) ) != m_map.end() )
	{

		CHPtrArray*	pResources = mapIter->second;

		if	(	NULL	!=	pResources
			&&	dwIndex	<	pResources->GetSize() )
		{
			pResourceDescriptor = (LPRESOURCE_DESCRIPTOR) pResources->GetAt( dwIndex );
		}

	}

	return pResourceDescriptor;

}

void CNT4ServiceToResourceMap::Clear( void )
{
	CHPtrArray*	pPtrArray = NULL;

	// Delete all list entries and then clear out the list.

	for (	NT4SvcToResourceMapIter	mapIter	=	m_map.begin();
			mapIter != m_map.end();
			mapIter++ )
	{
		pPtrArray = mapIter->second;
		if ( NULL != pPtrArray )
		{
			delete pPtrArray;
		}
	}

	m_map.erase( m_map.begin(), m_map.end() );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\ntdevtosvcsearch.cpp ===
//=================================================================

//

// NTDEVTOSVCSEARCH.CPP -- Class to use the registry to find an

//							NT Service name based on a device name.

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    09/18/97    a-sanjes        Created
//
//=================================================================
#include "precomp.h"
#include <winerror.h>
#include <cregcls.h>
#include "ntdevtosvcsearch.h"

#ifdef NTONLY

//////////////////////////////////////////////////////////////////////////////
//
//	ntdevtosvcsearch.cpp - Class implementation of CNTDeviceToServiceSearch.
//
//	This class is intended to provide a way for an NT implementation to locate
//	an NT Service name based off of an owner device name given to it by the
//	HAL Layer.  For  example, we may be working with KeyboardPort0, but actually
//	need to report a service name of i8042prt (what scares me is that I
//	pulled "i8042prt" out of memory.  Someone shoot me now).
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//	FUNCTION    :	CNTDeviceToServiceSearch::CNTDeviceToServiceSearch
//
//	DESCRIPTION :	Constructor
//
//	INPUTS      :	none.
//
//	OUTPUTS     :	none
//
//	RETURNS     :	nothing
//
//	COMMENTS    :	none.
//
//////////////////////////////////////////////////////////////////////////////

CNTDeviceToServiceSearch::CNTDeviceToServiceSearch( void )
:	CRegistrySearch()
{
}

//////////////////////////////////////////////////////////////////////////////
//
//	FUNCTION    :	CNTDeviceToServiceSearch::~CNTDeviceToServiceSearch
//
//	DESCRIPTION :	Destructor
//
//	INPUTS      :	none
//
//	OUTPUTS     :	none
//
//	RETURNS     :	nothing
//
//	COMMENTS    :	Class destructor
//
//////////////////////////////////////////////////////////////////////////////

CNTDeviceToServiceSearch::~CNTDeviceToServiceSearch( void )
{
}

//////////////////////////////////////////////////////////////////////////////
//
//	FUNCTION    :	CNTDeviceToServiceSearch::Find
//
//	DESCRIPTION :	Traverses registry, looking for the supplied owner
//					device name (obtained from the HAL) and upon finding
//					it, stores the name in strServiceName.
//
//	INPUTS      :	LPCTSTR		pszOwnerDeviceName - Owner Device name to
//														locate.
//
//	OUTPUTS     :	CHString&	strServiceName - Service name found in
//													registry.
//
//	RETURNS     :	BOOL		TRUE/FALSE - Success/Failure
//
//	COMMENTS    :	Only applicable to Windows NT.  Searches the following key:
//					HKLM\HARDWARE\RESOURCEMAP.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CNTDeviceToServiceSearch::Find( LPCTSTR pszOwnerDeviceName, CHString& strServiceName )
{

	//////////////////////////////////////////////////////////////////////////
	//
	//	We will need to traverse the HKEY_LOCAL_MACHINE\HARDWARE\RESOURCE_MAP
	//	tree in order to locate the correct service name.
	//
	//	A SubKey Name will identify an owner if it:
	//
	//	a>	Matches the pszOwnerDeviceName that was passed in
	//	b>	We successfully query a value for the Raw
	//		or translated device name.  The Raw device
	//		name is something along the lines of
	//		\Device\PointerPort0.Raw and the Translated
	//		device name is something along the lines of
	//		\Device\PointerPort0.Translated.  In either
	//		case, replace "PointerPort0" with the value
	//		of pszOwnerDeviceName.
	//
	//////////////////////////////////////////////////////////////////////////

	CHString	strRawDeviceValue,
				strTranslatedDeviceValue,
				strServiceNamePath;

	LPCTSTR		ppszValueNames[2];

	strRawDeviceValue.Format( RAWVALUENAME_FMAT, pszOwnerDeviceName );
	strTranslatedDeviceValue.Format( TRANSLATEDVALUENAME_FMAT, pszOwnerDeviceName );

	ppszValueNames[0] = (LPCTSTR) strRawDeviceValue;
	ppszValueNames[1] = (LPCTSTR) strTranslatedDeviceValue;

	// We're all setup, so go ahead and traverse the registry

	return LocateKeyByNameOrValueName(	HKEY_LOCAL_MACHINE,
										DEVTOSVC_BASEKEYPATH,
										pszOwnerDeviceName,
										ppszValueNames,
										2,
										strServiceName,
										strServiceNamePath );

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\perfdata.h ===
//============================================================

//

// PerfData.h - Performance Data helper class definition

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 11/23/97     a-sanjes     created
//
//============================================================

#ifndef __PERFDATA_H__
#define __PERFDATA_H__

#include <winperf.h>

#ifdef NTONLY
class CPerformanceData
{
	public :

		CPerformanceData() ;
		~CPerformanceData() ;

		DWORD	Open( LPCTSTR pszValue, LPDWORD pdwType, LPBYTE *lppData, LPDWORD lpcbData );
//		void	Close( void );
      DWORD GetPerfIndex(LPCTSTR pszName);
      bool GetValue(DWORD dwObjIndex, DWORD dwCtrIndex, const WCHAR *szInstanceName, PBYTE pbData, unsigned __int64 *pTime);

	private:
		LONG RegQueryValueExExEx( HKEY hKey, LPTSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData ); 

		static bool m_fCloseKey;
        LPBYTE m_pBuff;
        
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\ntdllapi.cpp ===
//=================================================================

//

// NtDllApi.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <ntseapi.h>
#include <cominit.h>

#include <ntsecapi.h>
#include "DllWrapperBase.h"
#include "NtDllApi.h"
#include "DllWrapperCreatorReg.h"


// {77609C22-CDAA-11d2-911E-0060081A46FD}
static const GUID g_guidNtDllApi =
{0x77609c22, 0xcdaa, 0x11d2, {0x91, 0x1e, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};

static const TCHAR g_tstrNtDll[] = _T("NTDLL.DLL");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CNtDllApi, &g_guidNtDllApi, g_tstrNtDll> MyRegisteredNtDllWrapper;


/******************************************************************************
 * Constructor
 *****************************************************************************/
CNtDllApi::CNtDllApi(LPCTSTR a_tstrWrappedDllName)
	: CDllWrapperBase(a_tstrWrappedDllName),
	m_pfnRtlInitUnicodeString(NULL),
	m_pfnNtSetSystemEnvironmentValue(NULL),
	m_pfnNtQuerySystemEnvironmentValue(NULL),
#if defined(_IA64_) //EFI_NVRAM_ENABLED)
	m_pfnNtQueryBootOptions(NULL),
	m_pfnNtSetBootOptions(NULL),
	m_pfnNtQueryBootEntryOrder(NULL),
	m_pfnNtSetBootEntryOrder(NULL),
	m_pfnNtEnumerateBootEntries(NULL),
#endif // defined(EFI_NVRAM_ENABLED)
	m_pfnNtCreateFile(NULL),
	m_pfnNtQuerySystemInformation(NULL),
	m_pfnNtQueryDirectoryObject(NULL),
	m_pfnNtQueryObject(NULL),
	m_pfnNtOpenDirectoryObject(NULL) ,
	m_pfnNtQueryInformationProcess(NULL),
	m_pfnNtQueryInformationToken(NULL),
	m_pfnNtOpenFile(NULL),
	m_pfnNtClose(NULL),
	m_pfnNtFsControlFile(NULL)
{
}


/******************************************************************************
 * Destructor
 *****************************************************************************/
CNtDllApi::~CNtDllApi()
{
}

/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 ******************************************************************************/
bool CNtDllApi::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {


        m_pfnRtlInitUnicodeString = (PFN_NTDLL_RTL_INIT_UNICODE_STRING)
                                        GetProcAddress("RtlInitUnicodeString");

		m_pfnRtlFreeUnicodeString = (PFN_NTDLL_RTL_FREE_UNICODE_STRING)
										GetProcAddress("RtlFreeUnicodeString");

        m_pfnNtSetSystemEnvironmentValue =
                                    (PFN_NTDLL_NT_SET_SYSTEM_ENVIRONMENT_VALUE)
                                 GetProcAddress("NtSetSystemEnvironmentValue");

        m_pfnNtQuerySystemEnvironmentValue =
                                  (PFN_NTDLL_NT_QUERY_SYSTEM_ENVIRONMENT_VALUE)
                               GetProcAddress("NtQuerySystemEnvironmentValue");

#if defined(_IA64_)//EFI_NVRAM_ENABLED)
        m_pfnNtQueryBootOptions =
                                  (PFN_NTDLL_NT_QUERY_BOOT_OPTIONS)
                               GetProcAddress("NtQueryBootOptions");

        m_pfnNtSetBootOptions =
                                  (PFN_NTDLL_NT_SET_BOOT_OPTIONS)
                               GetProcAddress("NtSetBootOptions");

        m_pfnNtQueryBootEntryOrder =
                                  (PFN_NTDLL_NT_QUERY_BOOT_ENTRY_ORDER)
                               GetProcAddress("NtQueryBootEntryOrder");

        m_pfnNtSetBootEntryOrder =
                                  (PFN_NTDLL_NT_SET_BOOT_ENTRY_ORDER)
                               GetProcAddress("NtSetBootEntryOrder");

        m_pfnNtEnumerateBootEntries =
                                  (PFN_NTDLL_NT_ENUMERATE_BOOT_ENTRIES)
                               GetProcAddress("NtEnumerateBootEntries");
#endif // defined(EFI_NVRAM_ENABLED)

        m_pfnNtCreateFile = (PFN_NTDLL_NT_CREATE_FILE)
                                                GetProcAddress("NtCreateFile");

        m_pfnNtQuerySystemInformation = (PFN_NT_QUERY_SYSTEM_INFORMATION)
                                    GetProcAddress("NtQuerySystemInformation");

        m_pfnNtQueryDirectoryObject = (PFN_NT_QUERY_DIRECTORY_OBJECT)
                                      GetProcAddress("NtQueryDirectoryObject");

        m_pfnNtQueryObject = (PFN_NT_QUERY_OBJECT)
                                               GetProcAddress("NtQueryObject");

        m_pfnNtOpenDirectoryObject = (PFN_NT_OPEN_DIRECTORY_OBJECT)
                                       GetProcAddress("NtOpenDirectoryObject");

		m_pfnNtQueryInformationProcess = ( PFN_NTQUERYINFORMATIONPROCESS )
										GetProcAddress("NtQueryInformationProcess");

		m_pfnNtQueryInformationToken = ( PFN_NT_QUERY_INFORMATION_TOKEN )
										GetProcAddress("NtQueryInformationToken");

		m_pfnNtOpenFile = ( PFN_NT_OPEN_FILE ) GetProcAddress("NtOpenFile");
		
        m_pfnNtClose = ( PFN_NT_CLOSE ) GetProcAddress("NtClose");
		
        m_pfnNtFsControlFile = ( PFN_NT_FS_CONTROL_FILE ) GetProcAddress("NtFsControlFile") ;

        m_pfnNtQueryVolumeInformationFile = (PFN_NT_QUERY_VOLUME_INFORMATION_FILE)
                                        GetProcAddress("NtQueryVolumeInformationFile");

    }

    // We require these function for all versions of this dll.
    if (
			m_pfnRtlInitUnicodeString == NULL ||
			m_pfnNtSetSystemEnvironmentValue == NULL ||
			m_pfnNtQuerySystemEnvironmentValue == NULL ||
#if defined(_IA64_)//(EFI_NVRAM_ENABLED)
			m_pfnNtQueryBootOptions == NULL ||
			m_pfnNtSetBootOptions == NULL ||
			m_pfnNtQueryBootEntryOrder == NULL ||
			m_pfnNtSetBootEntryOrder == NULL ||
			m_pfnNtEnumerateBootEntries == NULL ||
#endif // defined(EFI_NVRAM_ENABLED)
			m_pfnNtCreateFile == NULL ||
			m_pfnNtQuerySystemInformation == NULL ||
			m_pfnNtQueryDirectoryObject == NULL ||
			m_pfnNtQueryObject == NULL ||
			m_pfnNtOpenDirectoryObject == NULL ||
			m_pfnNtQueryInformationProcess == NULL ||
			m_pfnNtQueryInformationToken == NULL ||
			m_pfnNtOpenFile == NULL ||
			m_pfnNtClose == NULL ||
			m_pfnNtFsControlFile == NULL ||
			m_pfnRtlFreeUnicodeString == NULL 
	)
    {
        fRet = false;
        LogErrorMessage(L"Failed find entrypoint in ntdllapi");
    }
    return fRet;
}

/******************************************************************************
 * Member functions wrapping NtDll api functions. Add new functions here
 * as required.
 *****************************************************************************/
DWORD CNtDllApi::RtlInitUnicodeString
(
    UNICODE_STRING* a_pustr,
    LPCWSTR a_wstr
)
{
    return m_pfnRtlInitUnicodeString(a_pustr,
                                     a_wstr);
}

VOID CNtDllApi::RtlFreeUnicodeString (

	PUNICODE_STRING UnicodeString
)
{
	m_pfnRtlFreeUnicodeString (

		UnicodeString
	) ;
}

DWORD CNtDllApi::NtSetSystemEnvironmentValue
(
    UNICODE_STRING* a_pustr1,
    UNICODE_STRING* a_pustr2
)
{
    return m_pfnNtSetSystemEnvironmentValue(a_pustr1,
                                            a_pustr2);
}

DWORD CNtDllApi::NtQuerySystemEnvironmentValue
(
    PUNICODE_STRING a_pustr,
    PWSTR a_pwstr,
    USHORT a_us,
    PUSHORT a_pus
)
{
    return m_pfnNtQuerySystemEnvironmentValue(a_pustr,
                                              a_pwstr,
                                              a_us,
                                              a_pus);
}

#if defined(_IA64_)//(EFI_NVRAM_ENABLED)

DWORD CNtDllApi::NtQueryBootOptions
(
    PBOOT_OPTIONS BootOptions,
    PULONG BootOptionsLength
)
{
    return m_pfnNtQueryBootOptions(BootOptions,
                                   BootOptionsLength);
}

DWORD CNtDllApi::NtSetBootOptions
(
    PBOOT_OPTIONS BootOptions,
    ULONG FieldsToChange
)
{
    return m_pfnNtSetBootOptions(BootOptions,
                                 FieldsToChange);
}

DWORD CNtDllApi::NtQueryBootEntryOrder
(
    PULONG Ids,
    PULONG Count
)
{
    return m_pfnNtQueryBootEntryOrder(Ids,
                                    Count);
}

DWORD CNtDllApi::NtSetBootEntryOrder
(
    PULONG Ids,
    ULONG Count
)
{
    return m_pfnNtSetBootEntryOrder(Ids,
                                    Count);
}

DWORD CNtDllApi::NtEnumerateBootEntries
(
    PVOID Buffer,
    PULONG BufferLength
)
{
    return m_pfnNtEnumerateBootEntries(Buffer,
                                       BufferLength);
}

#endif // defined(EFI_NVRAM_ENABLED)

NTSTATUS CNtDllApi::NtCreateFile
(
    HANDLE *a_ph,
    ACCESS_MASK a_am,
    POBJECT_ATTRIBUTES a_pa,
    PIO_STATUS_BLOCK a_sb,
    PLARGE_INTEGER a_pla,
    ULONG a_ul1,
    ULONG a_ul2,
    ULONG a_ul3,
    ULONG a_ul4,
    PVOID a_pv,
    ULONG a_ul5
)
{
    return m_pfnNtCreateFile(a_ph, a_am, a_pa, a_sb, a_pla, a_ul1, a_ul2,
                             a_ul3, a_ul4, a_pv, a_ul5);
}

NTSTATUS CNtDllApi::NtQuerySystemInformation
(
    SYSTEM_INFORMATION_CLASS a_SystemInformationClass,
    PVOID a_SystemInformation,
    ULONG a_SystemInformationLength,
    PULONG a_ReturnLength
)
{
    return m_pfnNtQuerySystemInformation(a_SystemInformationClass,
                                         a_SystemInformation,
                                         a_SystemInformationLength,
                                         a_ReturnLength);
}

NTSTATUS CNtDllApi::NtQueryDirectoryObject
(
    HANDLE a_DirectoryHandle,
    PVOID a_Buffer,
    ULONG a_Length,
    BOOLEAN a_ReturnSingleEntry,
    BOOLEAN a_RestartScan,
    PULONG a_Context,
    PULONG a_ReturnLength
)
{
    return m_pfnNtQueryDirectoryObject(a_DirectoryHandle,
                                       a_Buffer,
                                       a_Length,
                                       a_ReturnSingleEntry,
                                       a_RestartScan,
                                       a_Context,
                                       a_ReturnLength);
}

NTSTATUS CNtDllApi::NtQueryObject
(
    HANDLE a_Handle,
    OBJECT_INFORMATION_CLASS a_ObjectInformationClass,
    PVOID a_ObjectInformation,
    ULONG a_Length,
    PULONG a_ReturnLength
)
{
    return m_pfnNtQueryObject(a_Handle,
                              a_ObjectInformationClass,
                              a_ObjectInformation,
                              a_Length,
                              a_ReturnLength);
}

NTSTATUS CNtDllApi::NtOpenDirectoryObject
(
    PHANDLE a_DirectoryHandle,
    ACCESS_MASK a_DesiredAccess,
    POBJECT_ATTRIBUTES a_ObjectAttributes
)
{
    return m_pfnNtOpenDirectoryObject(a_DirectoryHandle,
                                      a_DesiredAccess,
                                      a_ObjectAttributes);
}

NTSTATUS CNtDllApi::NtQueryInformationProcess (

	IN HANDLE ProcessHandle,
	IN PROCESSINFOCLASS ProcessInformationClass,
	OUT PVOID ProcessInformation,
	IN ULONG ProcessInformationLength,
	OUT PULONG ReturnLength OPTIONAL
)
{
	return m_pfnNtQueryInformationProcess (

		ProcessHandle,
		ProcessInformationClass,
		ProcessInformation,
		ProcessInformationLength,
		ReturnLength
	) ;
}

NTSTATUS CNtDllApi::NtQueryInformationToken (

	IN HANDLE TokenHandle,
	IN TOKEN_INFORMATION_CLASS TokenInformationClass,
	OUT PVOID TokenInformation,
	IN ULONG TokenInformationLength,
	OUT PULONG ReturnLength
)
{
	return m_pfnNtQueryInformationToken (

		TokenHandle,
		TokenInformationClass,
		TokenInformation,
		TokenInformationLength,
		ReturnLength
	) ;
}

NTSTATUS CNtDllApi::NtOpenFile (

	OUT PHANDLE FileHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG ShareAccess,
	IN ULONG OpenOptions
)
{
	return m_pfnNtOpenFile (

		FileHandle,
		DesiredAccess,
		ObjectAttributes,
		IoStatusBlock,
		ShareAccess,
		OpenOptions
	) ;
}

NTSTATUS CNtDllApi::NtClose (

	IN HANDLE Handle
)
{
	return m_pfnNtClose (

		Handle
	) ;
}

NTSTATUS CNtDllApi::NtFsControlFile (

	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG FsControlCode,
	IN PVOID InputBuffer OPTIONAL,
	IN ULONG InputBufferLength,
	OUT PVOID OutputBuffer OPTIONAL,
	IN ULONG OutputBufferLength
)
{
	return m_pfnNtFsControlFile (

		FileHandle,
		Event ,
		ApcRoutine ,
		ApcContext ,
		IoStatusBlock,
		FsControlCode,
		InputBuffer ,
		InputBufferLength,
		OutputBuffer ,
		OutputBufferLength
	) ;
}

NTSTATUS CNtDllApi::NtQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass)
{
    DWORD dwStatus = -1L;

    if(m_pfnNtQueryVolumeInformationFile)
    {
        dwStatus = m_pfnNtQueryVolumeInformationFile(
            FileHandle,
            IoStatusBlock,
            FsInformation,
            Length,
            FsInformationClass);
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\precomp.h ===
#pragma message("Precompiling header...")

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define WIN32_NO_STATUS

#include <comdef.h>
#include <helper.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include <scopeguard.h>
#include <autoptr.h>

#include <fwcommon.h>
#include <smartptr.h>

#include <brodcast.h>
#include "dllutils.h"
#include "strings.h"
#include "ConfgMgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\objaccessrights.cpp ===
/*****************************************************************************/



/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /

/*****************************************************************************/





//=================================================================

//

// ObjAccessRights.CPP -- Class for obtaining effective access

//                      rights on an unspecified object for a particular

//                      user or group.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/29/99    a-kevhu         Created
//
//=================================================================



#include "precomp.h"

#ifdef NTONLY


#include <assertbreak.h>
#include "AdvApi32Api.h"
#include "accctrl.h"
#include "sid.h"
#include "AccessEntryList.h"
#include "AccessRights.h"
#include "ObjAccessRights.h"
#include "ImpLogonUser.h"
#include "aclapi.h"
#include "DACL.h"


// Default initialization...
CObjAccessRights::CObjAccessRights(bool fUseCurThrTok /* = false */)
: CAccessRights(fUseCurThrTok)
{
}

CObjAccessRights::CObjAccessRights(LPCWSTR wstrObjName, SE_OBJECT_TYPE ObjectType, bool fUseCurThrTok /* = false */)
: CAccessRights(fUseCurThrTok)
{
    m_dwError = SetObj(wstrObjName, ObjectType);
}

CObjAccessRights::CObjAccessRights(const USER user, USER_SPECIFIER usp)
: CAccessRights(user, usp)
{
}

CObjAccessRights::CObjAccessRights(const USER user, LPCWSTR wstrObjName, SE_OBJECT_TYPE ObjectType, USER_SPECIFIER usp)
: CAccessRights(user, usp)
{
    m_dwError = SetObj(wstrObjName, ObjectType);
}



// Members clean up after themselves. Nothing to do here.
CObjAccessRights::~CObjAccessRights()
{
}

// Extracts the Obj's acl, and stores a copy of it.
DWORD CObjAccessRights::SetObj(LPCWSTR wstrObjName, SE_OBJECT_TYPE ObjectType)
{
    DWORD dwRet = E_FAIL;
    PACL pacl = NULL;
    PSECURITY_DESCRIPTOR psd = NULL;
    CAdvApi32Api *pAdvApi32 = NULL;


        if(wcslen(wstrObjName) != 0)
        {
            pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
            if(pAdvApi32 == NULL) return E_FAIL;

            CRelResource RelMe(&CResourceManager::sm_TheResourceManager,g_guidAdvApi32Api,pAdvApi32 );
                

            if(pAdvApi32->GetNamedSecurityInfoW(_bstr_t(wstrObjName),
                                                ObjectType,
                                                DACL_SECURITY_INFORMATION,
                                                NULL,
                                                NULL,
                                                &pacl,
                                                NULL,
                                                &psd,
                                                &dwRet))
            {
                if(dwRet == ERROR_SUCCESS && psd != NULL)
                {
                    OnDelete<HLOCAL,HLOCAL(*)(HLOCAL),LocalFree> FreeMeSD(psd);

                    
                    if(pacl != NULL) // might be null in the case of a null dacl!
                    {
                        if(!SetAcl(pacl))
                        {
                            dwRet = ERROR_INVALID_PARAMETER;
                        }
                        else
                        {
                            m_chstrObjName = wstrObjName;
                        }
                    }
                    else
                    {
                        // We have a security descriptor, we returned ERROR_SUCCESS from GetNamedSecurityInfo, so this
                        // means we have a null dacl.  In this case, we will create a NULL dacl using our security classes -
                        // more overhead, but will happen relatively infrequently.
                        CDACL newnulldacl;
                        if(newnulldacl.CreateNullDACL())
                        {
                            if((dwRet = newnulldacl.ConfigureDACL(pacl)) == ERROR_SUCCESS)
                            {
                                if(pacl != NULL)  // might be null in the case of a null dacl!
                                {
                                    OnDelete<void *,void(__cdecl *)(void *),free> FreeMeACL(pacl);   
                                    
                                    if(!SetAcl(pacl))
                                    {
                                        dwRet = ERROR_INVALID_PARAMETER;
                                    }
                                    else
                                    {
                                        m_chstrObjName = wstrObjName;
                                    }
                                    // Since the memory we used for pacl, in this case, is not part of psd, and therefor
                                    // won't be freed via the call to LocalFree(psd), we free it here.

                                    pacl = NULL;
                                }
                            }
                        }
                    }
                }
            }

        }

    return dwRet;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\objaccessrights.h ===
/*****************************************************************************/



/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /

/*****************************************************************************/





//=================================================================

//

// ObjAccessRights.CPP -- Class for obtaining effective access

//                      rights on a Obj.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/11/99    a-kevhu         Created
//
//=================================================================
#ifndef _COBJACCESSRIGHTS_H_
#define _COBJACCESSRIGHTS_H_


#ifdef NTONLY

class CObjAccessRights : public CAccessRights
{

    public:
        
        // Constructors and destructor...
        CObjAccessRights(bool fUseCurThrTok = false);
        CObjAccessRights(LPCWSTR wstrObjName, SE_OBJECT_TYPE ObjectType, bool fUseCurThrTok = false);
        CObjAccessRights(const USER user, USER_SPECIFIER usp);
        CObjAccessRights(const USER user, LPCWSTR wstrObjName, SE_OBJECT_TYPE ObjectType, USER_SPECIFIER usp);

        ~CObjAccessRights();

        // Useage functions...
        DWORD SetObj(LPCWSTR wstrObjName, SE_OBJECT_TYPE ObjectType);

    protected:


    private:

        CHString m_chstrObjName;

};


#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\ntdllapi.h ===
//=================================================================

//

// NTDllApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_NTDLLAPI_H_
#define	_NTDLLAPI_H_

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidNtDllApi;
extern const TCHAR g_tstrNtDll[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

typedef DWORD (WINAPI *PFN_NTDLL_RTL_INIT_UNICODE_STRING)
(
    UNICODE_STRING*, 
    LPCWSTR
);

typedef void ( NTAPI *PFN_NTDLL_RTL_FREE_UNICODE_STRING ) 
(
    PUNICODE_STRING UnicodeString
);

typedef DWORD (WINAPI *PFN_NTDLL_NT_SET_SYSTEM_ENVIRONMENT_VALUE)
(
    UNICODE_STRING*, 
    UNICODE_STRING*
);

typedef DWORD (WINAPI *PFN_NTDLL_NT_QUERY_SYSTEM_ENVIRONMENT_VALUE)
(
    PUNICODE_STRING,
    PWSTR,
    USHORT,
    PUSHORT
);

//#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)
typedef DWORD (WINAPI *PFN_NTDLL_NT_QUERY_BOOT_OPTIONS)
(
    PBOOT_OPTIONS,
    PULONG
);

typedef DWORD (WINAPI *PFN_NTDLL_NT_SET_BOOT_OPTIONS)
(
    PBOOT_OPTIONS,
    ULONG
);

typedef DWORD (WINAPI *PFN_NTDLL_NT_QUERY_BOOT_ENTRY_ORDER)
(
    PULONG,
    PULONG
);

typedef DWORD (WINAPI *PFN_NTDLL_NT_SET_BOOT_ENTRY_ORDER)
(
    PULONG,
    ULONG
);

typedef DWORD (WINAPI *PFN_NTDLL_NT_ENUMERATE_BOOT_ENTRIES)
(
    PVOID,
    PULONG
);

#endif // defined(EFI_NVRAM_ENABLED)

typedef NTSTATUS (WINAPI *PFN_NTDLL_NT_CREATE_FILE)
( 
    HANDLE*, 
    ACCESS_MASK,
    POBJECT_ATTRIBUTES, 
    PIO_STATUS_BLOCK,
    PLARGE_INTEGER,
    ULONG, 
    ULONG, 
    ULONG, 
    ULONG, 
    PVOID, 
    ULONG 
);

typedef NTSTATUS (NTAPI *PFN_NT_QUERY_SYSTEM_INFORMATION)
(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
);

typedef NTSTATUS (NTAPI *PFN_NTQUERYINFORMATIONPROCESS)
(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
);

typedef NTSTATUS (NTAPI *PFN_NT_QUERY_DIRECTORY_OBJECT)
(
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
);

typedef NTSTATUS (NTAPI *PFN_NT_QUERY_OBJECT)
(
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
);

typedef NTSTATUS (NTAPI *PFN_NT_OPEN_DIRECTORY_OBJECT)
(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
);

typedef NTSTATUS ( NTAPI *PFN_NT_QUERY_INFORMATION_TOKEN )
(
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT PVOID TokenInformation,
    IN ULONG TokenInformationLength,
    OUT PULONG ReturnLength
);

typedef NTSTATUS ( NTAPI *PFN_NT_OPEN_FILE )
(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
);

typedef NTSTATUS ( NTAPI *PFN_NT_CLOSE )
(
	IN HANDLE Handle
);

typedef NTSTATUS ( NTAPI *PFN_NT_FS_CONTROL_FILE ) 
(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
);

typedef NTSTATUS ( NTAPI *PFN_NT_QUERY_VOLUME_INFORMATION_FILE )
(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
);

/******************************************************************************
 * Wrapper class for NtDll load/unload, for registration with CResourceManager. 
 *****************************************************************************/
class CNtDllApi : public CDllWrapperBase
{
private:

    // Member variables (function pointers) pointing to NtDll functions.
    // Add new functions here as required.

    PFN_NTDLL_RTL_INIT_UNICODE_STRING m_pfnRtlInitUnicodeString;
	PFN_NTDLL_RTL_FREE_UNICODE_STRING m_pfnRtlFreeUnicodeString;
    PFN_NTDLL_NT_SET_SYSTEM_ENVIRONMENT_VALUE m_pfnNtSetSystemEnvironmentValue;
    PFN_NTDLL_NT_QUERY_SYSTEM_ENVIRONMENT_VALUE m_pfnNtQuerySystemEnvironmentValue;
//#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)
    PFN_NTDLL_NT_QUERY_BOOT_OPTIONS m_pfnNtQueryBootOptions;
    PFN_NTDLL_NT_SET_BOOT_OPTIONS m_pfnNtSetBootOptions;
    PFN_NTDLL_NT_QUERY_BOOT_ENTRY_ORDER m_pfnNtQueryBootEntryOrder;
    PFN_NTDLL_NT_SET_BOOT_ENTRY_ORDER m_pfnNtSetBootEntryOrder;
    PFN_NTDLL_NT_ENUMERATE_BOOT_ENTRIES m_pfnNtEnumerateBootEntries;
#endif // defined(EFI_NVRAM_ENABLED)
    PFN_NTDLL_NT_CREATE_FILE m_pfnNtCreateFile;
    PFN_NT_QUERY_SYSTEM_INFORMATION m_pfnNtQuerySystemInformation;
    PFN_NT_QUERY_DIRECTORY_OBJECT m_pfnNtQueryDirectoryObject;
    PFN_NT_QUERY_OBJECT m_pfnNtQueryObject;
    PFN_NT_OPEN_DIRECTORY_OBJECT m_pfnNtOpenDirectoryObject;
	PFN_NTQUERYINFORMATIONPROCESS m_pfnNtQueryInformationProcess ;
	PFN_NT_QUERY_INFORMATION_TOKEN m_pfnNtQueryInformationToken ;
	PFN_NT_OPEN_FILE m_pfnNtOpenFile ;
	PFN_NT_CLOSE m_pfnNtClose ;
	PFN_NT_FS_CONTROL_FILE m_pfnNtFsControlFile ;
    PFN_NT_QUERY_VOLUME_INFORMATION_FILE m_pfnNtQueryVolumeInformationFile;

public:

    // Constructor and destructor:
    CNtDllApi(LPCTSTR a_tstrWrappedDllName);
    ~CNtDllApi();

    // Initialization function to check function pointers.
    virtual bool Init();

    // Member functions wrapping NtDll functions.
    // Add new functions here as required:

    DWORD RtlInitUnicodeString (

        UNICODE_STRING* a_pustr, 
        LPCWSTR a_wstr
    );

	VOID RtlFreeUnicodeString (

		PUNICODE_STRING UnicodeString
	) ;

    DWORD NtSetSystemEnvironmentValue (

        UNICODE_STRING* a_pustr1, 
        UNICODE_STRING* a_pustr2
    );

    DWORD NtQuerySystemEnvironmentValue (

        PUNICODE_STRING a_pustr,
        PWSTR a_pwstr,
        USHORT a_us,
        PUSHORT a_pus
    );

//#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)

    DWORD NtQueryBootOptions (

        PBOOT_OPTIONS BootOptions,
        PULONG BootOptionsLength
    );

    DWORD NtSetBootOptions (

        PBOOT_OPTIONS BootOptions,
        ULONG FieldsToChange
    );

    DWORD NtQueryBootEntryOrder (

        PULONG Ids,
        PULONG Count
    );

    DWORD NtSetBootEntryOrder (

        PULONG Ids,
        ULONG Count
    );

    DWORD NtEnumerateBootEntries (

        PVOID Buffer,
        PULONG BufferLength
    );

#endif // defined(EFI_NVRAM_ENABLED)

    NTSTATUS NtCreateFile ( 

        HANDLE *a_ph, 
        ACCESS_MASK a_am,
        POBJECT_ATTRIBUTES a_pa, 
        PIO_STATUS_BLOCK a_sb,
        PLARGE_INTEGER a_pla,
        ULONG a_ul1, 
        ULONG a_ul2, 
        ULONG a_ul3, 
        ULONG a_ul4, 
        PVOID a_pv, 
        ULONG a_ul5 
    );

    NTSTATUS NtQuerySystemInformation
    (
        SYSTEM_INFORMATION_CLASS a_SystemInformationClass,
        PVOID a_SystemInformation,
        ULONG a_SystemInformationLength,
        PULONG a_ReturnLength 
    );

    NTSTATUS NtQueryDirectoryObject
    (
        HANDLE a_DirectoryHandle,
        PVOID a_Buffer,
        ULONG a_Length,
        BOOLEAN a_ReturnSingleEntry,
        BOOLEAN a_RestartScan,
        PULONG a_Context,
        PULONG a_ReturnLength 
    );

    NTSTATUS NtQueryObject
    (
        HANDLE a_Handle,
        OBJECT_INFORMATION_CLASS a_ObjectInformationClass,
        PVOID a_ObjectInformation,
        ULONG a_Length,
        PULONG a_ReturnLength 
    );

    NTSTATUS NtOpenDirectoryObject
    (
        PHANDLE a_DirectoryHandle,
        ACCESS_MASK a_DesiredAccess,
        POBJECT_ATTRIBUTES a_ObjectAttributes
    );

	NTSTATUS NtQueryInformationProcess (

		IN HANDLE ProcessHandle,
		IN PROCESSINFOCLASS ProcessInformationClass,
		OUT PVOID ProcessInformation,
		IN ULONG ProcessInformationLength,
		OUT PULONG ReturnLength OPTIONAL
    );

	NTSTATUS NtQueryInformationToken (

		IN HANDLE TokenHandle,
		IN TOKEN_INFORMATION_CLASS TokenInformationClass,
		OUT PVOID TokenInformation,
		IN ULONG TokenInformationLength,
		OUT PULONG ReturnLength
    ) ;

	NTSTATUS NtOpenFile (

		OUT PHANDLE FileHandle,
		IN ACCESS_MASK DesiredAccess,
		IN POBJECT_ATTRIBUTES ObjectAttributes,
		OUT PIO_STATUS_BLOCK IoStatusBlock,
		IN ULONG ShareAccess,
		IN ULONG OpenOptions
    );

	NTSTATUS NtClose (

	    IN HANDLE Handle
    );

	NTSTATUS NtFsControlFile (

		IN HANDLE FileHandle,
		IN HANDLE Event OPTIONAL,
		IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
		IN PVOID ApcContext OPTIONAL,
		OUT PIO_STATUS_BLOCK IoStatusBlock,
		IN ULONG FsControlCode,
		IN PVOID InputBuffer OPTIONAL,
		IN ULONG InputBufferLength,
		OUT PVOID OutputBuffer OPTIONAL,
		IN ULONG OutputBufferLength
	);

    NTSTATUS NtQueryVolumeInformationFile(
        IN HANDLE FileHandle,
        OUT PIO_STATUS_BLOCK IoStatusBlock,
        OUT PVOID FsInformation,
        IN ULONG Length,
        IN FS_INFORMATION_CLASS FsInformationClass);

};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\perfdata.cpp ===
//=================================================================

//

// PerfData.CPP -- Performance Data Helper class

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:   11/23/97    a-sanjes        Created
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>
#include "perfdata.h"
#include <cregcls.h>
#include <createmutexasprocess.h>

#ifdef NTONLY

// Static Initialization
bool    CPerformanceData::m_fCloseKey = false;

//////////////////////////////////////////////////////////
//
//  Function:   CPerformanceData::CPerformanceData
//
//  Default constructor
//
//  Inputs:
//              None
//
//  Outputs:
//              None
//
//  Returns:
//              None
//
//  Comments:
//
//////////////////////////////////////////////////////////

CPerformanceData::CPerformanceData( void )
{
    m_pBuff = NULL;
}

//////////////////////////////////////////////////////////
//
//  Function:   CPerformanceData::~CPerformanceData
//
//  Destructor
//
//  Inputs:
//              None
//
//  Outputs:
//              None
//
//  Returns:
//              None
//
//  Comments:
//
//////////////////////////////////////////////////////////

CPerformanceData::~CPerformanceData( void )
{
    if (m_pBuff != NULL)
    {
        delete [] m_pBuff;
    }
}


//////////////////////////////////////////////////////////
//
//  Function:   CPerformanceData::RegQueryValueExExEx
//
//  Inputs: HKEY hKey handle of key to query
//          LPTSTR lpValueName, address of name of value to query
//          LPDWORD lpReserved reserved
//          LPDWORD lpType, address of buffer for value type
//          LPBYTE lpData address of data buffer
//          LPDWORD lpcbData address of data buffer size
//
//
//  Returns: everything documented by RegQueryValueEx AND ERROR_SEM_TIMEOUT or ERROR_OPEN_FAILED
//
//////////////////////////////////////////////////////////
LONG CPerformanceData::RegQueryValueExExEx( HKEY hKey, LPTSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
    LONG ret = -1;
    ret = RegQueryValueEx( hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

    return ret;
}

//////////////////////////////////////////////////////////
//
//  Function:   CPerformanceData::Open
//
//  Opens and retrieves data from the performance data
//  registry key.
//
//  Inputs:
//              LPCTSTR pszValue    - Value to retrieve
//
//  Outputs:
//              LPDWORD pdwType     - Type returned
//              LPBYTE  lpData      - Buffer
//              LPDWORD lpcbData    - Amount of data returned
//
//  Returns:
//              ERROR_SUCCESS if successful
//
//  Comments:
//
//////////////////////////////////////////////////////////

DWORD CPerformanceData::Open( LPCTSTR pszValue, LPDWORD pdwType, LPBYTE *lppData, LPDWORD lpcbData )
{
    DWORD   dwReturn = ERROR_OUTOFMEMORY;
    BOOL    fStackTrashed = FALSE;
    LogMessage(_T("CPerformanceData::Open"));

    LPCTSTR     pszOldValue     =   pszValue;
    LPDWORD     pdwOldType      =   pdwType;
    LPBYTE*     lppOldData      =   lppData;
    LPDWORD     lpcbOldData     =   lpcbData;

    ASSERT_BREAK(*lppData == NULL);

    DWORD dwSize = 16384;
    *lpcbData = dwSize;
    *lppData = new byte [*lpcbData];

    if (*lppData == NULL)
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    if (    pszOldValue     !=  pszValue
        ||  pdwOldType      !=  pdwType
        ||  lppOldData      !=  lppData
        ||  lpcbOldData     !=  lpcbData    )
    {
        LogErrorMessage(_T("CPerformanceData::stack trashed after malloc"));
        fStackTrashed = TRUE;
        ASSERT_BREAK(0);
    }
    else
    {

        try
        {
            while ((*lppData != NULL) &&
                // remember precedence & associativity?
                ((dwReturn = RegQueryValueEx( HKEY_PERFORMANCE_DATA,
                (LPTSTR)pszValue,
                NULL,
                pdwType,
                (LPBYTE) *lppData,
                lpcbData )) == ERROR_MORE_DATA)

                )
            {

                if (    pszOldValue     !=  pszValue
                    ||  pdwOldType      !=  pdwType
                    ||  lppOldData      !=  lppData
                    ||  lpcbOldData     !=  lpcbData    )
                {
                    LogErrorMessage(_T("CPerformanceData::stack trashed after RegQueryValueEx"));
                    fStackTrashed = TRUE;
                    ASSERT_BREAK(0);
                    break;
                }

                // Get a buffer that is big enough.
                LogMessage(_T("CPerformanceData::realloc"));
                dwSize += 16384;
                *lpcbData = dwSize ;

                if (    pszOldValue     !=  pszValue
                    ||  pdwOldType      !=  pdwType
                    ||  lppOldData      !=  lppData
                    ||  lpcbOldData     !=  lpcbData    )
                {
                    LogErrorMessage(_T("CPerformanceData::stack trashed after size reset"));
                    fStackTrashed = TRUE;
                    ASSERT_BREAK(0);
                    break;
                }
                delete [] *lppData;
                *lppData = new BYTE [*lpcbData];
                if (*lppData == NULL)
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                if (    pszOldValue     !=  pszValue
                    ||  pdwOldType      !=  pdwType
                    ||  lppOldData      !=  lppData
                    ||  lpcbOldData     !=  lpcbData    )
                {
                    LogErrorMessage(_T("CPerformanceData::stack trashed after realloc"));
                    fStackTrashed = TRUE;
                    ASSERT_BREAK(0);
                    break;
                }

            }   // While
        }
        catch ( ... )
        {
            if (*lppData != NULL)
            {
                delete [] *lppData;
            }
            throw ;
        }
	}

    if ( fStackTrashed )
    {
        dwReturn = ERROR_INVALID_FUNCTION;
    }
    else
    {
        // if we got here in an error condition, try to recoup
        if ((dwReturn != ERROR_SUCCESS)
            &&
            (*lppData != NULL))
        {
            LogErrorMessage(_T("CPerformanceData::failed to alloc enough memory"));
            delete [] *lppData;
            *lppData = NULL;
        }

        if (!m_fCloseKey)
        {
            m_fCloseKey = ( ERROR_SUCCESS == dwReturn );
            if (m_fCloseKey)
                LogMessage(_T("Opened perf counters"));
        }

        if ((dwReturn != ERROR_SUCCESS) && IsErrorLoggingEnabled())
        {
            CHString sTemp;
            sTemp.Format(_T("Performance RegQueryValueEx returned %d\n"), dwReturn);
            LogErrorMessage(sTemp);
        }

        if (*lppData == NULL)
        {
            dwReturn = ERROR_OUTOFMEMORY;
        }

    }

    return dwReturn;

}

//////////////////////////////////////////////////////////
//
//  Function:   CPerformanceData::Close
//
//  Closes the performance data registry key if the
//  static value is TRUE.
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:
//
//  Per the KB, calling RegCloseKey on HKEY_PERFORMANCE_DATA
//  causes a memory leak, so you do NOT want to do lots of
//  these.
//
//////////////////////////////////////////////////////////
#if 0 // From raid 48395
void CPerformanceData::Close( void )
{
    if ( m_fCloseKey )
    {
        if ( m_fCloseKey )
        {
            RegCloseKey( HKEY_PERFORMANCE_DATA );
            m_fCloseKey = FALSE;
            LogMessage(_T("Closed Perf Counters"));
        }
    }
}
#endif
//////////////////////////////////////////////////////////
//
//  Function:   CPerformanceData::GetPerfIndex
//
//  Given a perf object name, this function returns
// the perf object number.
//
//  Inputs:
//              Object name
//
//  Outputs:
//              None
//
//  Returns:
//              Associated Number or 0 on error.
//
//  Comments:
//
//
//////////////////////////////////////////////////////////
DWORD CPerformanceData::GetPerfIndex(LPCTSTR pszName)
{
    DWORD dwRetVal = 0;

    if (m_pBuff == NULL)
    {
        LONG lRet = ERROR_SUCCESS;

        if (m_pBuff == NULL)
        {
			CRegistry RegInfo;

            // Hardcoding 009 should be ok since according to the docs:
            // "The langid is the ASCII representation of the 3-digit hexadecimal language identifier. "
            // "For example, the U.S. English langid is 009. In a non-English version of Windows NT, "
            // "counters are stored in both the native language of the system and in English. "

            if ((lRet = RegInfo.Open(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009"), KEY_QUERY_VALUE)) == ERROR_SUCCESS)
            {
                // Get the size of the key
                DWORD dwSize;
                lRet = RegInfo.GetCurrentBinaryKeyValue(_T("Counter"), NULL, &dwSize);
                if (lRet == ERROR_SUCCESS)
                {
                    // Allocate a buffer to hold it
                    m_pBuff = new BYTE[dwSize];

                    if (m_pBuff != NULL)
                    {
                        // Get the actual data
                        if ((lRet = RegInfo.GetCurrentBinaryKeyValue(_T("Counter"), m_pBuff, &dwSize)) != ERROR_SUCCESS)
                        {
                            delete [] m_pBuff;
                            m_pBuff = NULL;
                        }
                    }
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }
                }
            }
        }

        if (lRet != ERROR_SUCCESS)
        {
            LogErrorMessage2(L"Failed to read Perflib key: %x", lRet);
        }
    }

    // If we got the registry key
    if (m_pBuff != NULL)
    {
        const TCHAR *pCounter;
        const TCHAR *ptemp;
        int stringlength;

        pCounter = (TCHAR *)m_pBuff;
        stringlength = _tcslen((LPCTSTR)pCounter);

        // Exit the loop when we hit the end
        while(stringlength)
        {
            // Strings are stored in the form <counternumber>\0<countername>\0.
            // What we want to return is the counter number.  ptemp will point to the name
            ptemp = pCounter + stringlength+1;
            stringlength = _tcslen((LPCTSTR)ptemp);

            if (stringlength > 0)
            {
                // Did we find it
                if (_tcscmp((TCHAR *)ptemp, pszName) != 0)
                {
                    // Nope, position to the next pair
                    pCounter = ptemp + stringlength+1;
                    stringlength = _tcslen((LPCTSTR)pCounter);
                }
                else
                {
                    // Yup, calculate the value to return
                    dwRetVal = _ttoi(pCounter);
                    break;
                }
            }
        }
    }

    ASSERT_BREAK(dwRetVal > 0);

    return dwRetVal;

}

//////////////////////////////////////////////////////////
//
//  Function:   CPerformanceData::GetValue
//
//  Given a perf object index, counter index, and optional
//      instance name, returns the value and the time.
//
//  Inputs:
//              Value, Time
//
//  Outputs:
//              Value, Time
//
//  Returns:
//              True if it finds the value
//
//  Comments:
//
//
//////////////////////////////////////////////////////////
bool CPerformanceData::GetValue(DWORD dwObjIndex, DWORD dwCtrIndex, const WCHAR *szInstanceName, PBYTE pbData, unsigned __int64 *pTime)
{
   PPERF_DATA_BLOCK PerfData = NULL;
   DWORD            dwBufferSize = 0;
   LONG             lReturn = 0;
   BOOL             fReturn = FALSE;
   TCHAR szBuff[MAXITOA];
   bool bFound = false;
   PPERF_INSTANCE_DEFINITION pInstBlock;
   DWORD dwInstances;
   unsigned __int64 *pbCounterData;

   // The subsequent close happens in our destructor (read comment there).
   lReturn = Open( _itot(dwObjIndex, szBuff, 10),
      NULL,
      (LPBYTE *) (&PerfData),
      &dwBufferSize );

   if ( NULL            !=  PerfData
      &&    ERROR_SUCCESS   ==  lReturn )
   {

       try
       {
          // Surf through the objects returned until we find the one we are looking for.
          PPERF_OBJECT_TYPE         pPerfObject = (PPERF_OBJECT_TYPE)((PBYTE)PerfData + PerfData->HeaderLength);

          for ( DWORD       dwObjectCtr = 0;

             dwObjectCtr    < PerfData->NumObjectTypes
             && pPerfObject->ObjectNameTitleIndex != dwObjIndex;

             dwObjectCtr++ );

          // Did we find the Object?
          if ( dwObjectCtr < PerfData->NumObjectTypes )
          {

             // Now surf through the Counter Definition Data until we locate the
             // counter we are hunting for.

             PPERF_COUNTER_DEFINITION   pPerfCtrDef = (PPERF_COUNTER_DEFINITION)((PBYTE) pPerfObject + pPerfObject->HeaderLength);

             for (  DWORD   dwCtr   =   0;

                dwCtr < pPerfObject->NumCounters
                &&  pPerfCtrDef->CounterNameTitleIndex != dwCtrIndex;

                dwCtr++,

                // Go to the next counter
                pPerfCtrDef = (PPERF_COUNTER_DEFINITION)((PBYTE) pPerfCtrDef + pPerfCtrDef->ByteLength )

                );

             // Did we find the counter?
             if ( dwCtr < pPerfObject->NumCounters )
             {
                // Finally go to the data offset we retrieved from the counter definitions
                // and access the data (finally).

                DWORD   dwCounterOffset = pPerfCtrDef->CounterOffset;
                PPERF_COUNTER_BLOCK pPerfCtrBlock = NULL;

                // If we are looking for an instance
                if ((szInstanceName == NULL) && (pPerfObject->NumInstances == PERF_NO_INSTANCES))
                {
                   pPerfCtrBlock = (PPERF_COUNTER_BLOCK) ((PBYTE) pPerfObject + pPerfObject->DefinitionLength);
                   bFound = true;
                }
                else if (pPerfObject->NumInstances != PERF_NO_INSTANCES)
                {
                   // Walk the instances looking for the requested one
                   pInstBlock = (PPERF_INSTANCE_DEFINITION) ((PBYTE)pPerfObject + pPerfObject->DefinitionLength);
                   dwInstances = 1;
                   while ((dwInstances <= pPerfObject->NumInstances) &&
                          (wcscmp((WCHAR *)((pInstBlock->NameOffset) + (PBYTE)pInstBlock), szInstanceName) != 0))
                   {
                         pPerfCtrBlock = (PPERF_COUNTER_BLOCK) ((PBYTE)pInstBlock + pInstBlock->ByteLength);
                         pInstBlock = (PPERF_INSTANCE_DEFINITION)((PBYTE) pInstBlock + (pInstBlock->ByteLength + pPerfCtrBlock->ByteLength));
                         dwInstances ++;
                   }

                   // Did we find it?
                   if (dwInstances <= pPerfObject->NumInstances)
                   {
                      bFound = true;
                      pPerfCtrBlock = (PPERF_COUNTER_BLOCK) ((PBYTE)pInstBlock + pInstBlock->ByteLength);
                   }
                }

                // Grab the appropriate time field based on the counter definition
                if (bFound) {
                   if (pPerfCtrDef->CounterType & PERF_TIMER_100NS)
                   {
                      *pTime = PerfData->PerfTime100nSec.QuadPart;
                   }
                   else
                   {
                      // Unverified
                      *pTime = PerfData->PerfTime.QuadPart;
                   }

                   // Get a pointer to the data, then copy in the correct number of bytes (based on counter def)
                   pbCounterData = (unsigned __int64 *)(((PBYTE) pPerfCtrBlock ) + dwCounterOffset);
                   if (pPerfCtrDef->CounterType & PERF_SIZE_DWORD)
                   {
                      memcpy(pbData, pbCounterData, 4);
                   }
                   else if (pPerfCtrDef->CounterType & PERF_SIZE_LARGE)
                   {
                      memcpy(pbData, pbCounterData, 8);
                   }
                }

             }  // If Counter Definition found

          } // If Object found

       }    // If memory allocated
       catch ( ... )
       {
          delete [] PerfData ;
          throw ;
       }
   }

   // Free up any transient memory
   if ( NULL != PerfData )
   {
      delete [] PerfData ;
   }

   ASSERT_BREAK(bFound);

   return bFound;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\poormansresource.h ===
/////////////////////////////////////////////////////////////////////////

//

//  poormansresource.h    

//  

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    10/15/97        Sanj        Created by Sanj     
//              10/17/97        jennymc     Moved things a tiny bit
//				06/05/98		Sanj		Removed extraneous definitions.
//  
/////////////////////////////////////////////////////////////////////////


#ifndef __POORMANSRESOURCE_H__
#define __POORMANSRESOURCE_H__

#include "cfgmgr32.h"

/*XLATOFF*/
#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(1)
#else
#pragma pack(1)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
/*XLATON*/

struct	Mem_Des16_s {
	WORD			MD_Count;
	WORD			MD_Type;
	ULONG			MD_Alloc_Base;
	ULONG			MD_Alloc_End;
	WORD			MD_Flags;
	WORD			MD_Reserved;
};

typedef	struct Mem_Des16_s 	MEM_DES16;

struct	IO_Des16_s {
	WORD			IOD_Count;
	WORD			IOD_Type;
	WORD			IOD_Alloc_Base;
	WORD			IOD_Alloc_End;
	WORD			IOD_DesFlags;
	BYTE			IOD_Alloc_Alias;
	BYTE			IOD_Alloc_Decode;
};

typedef	struct IO_Des16_s 	IO_DES16;

struct	DMA_Des16_s {
	BYTE			DD_Flags;
	BYTE			DD_Alloc_Chan;	// Channel number allocated
	BYTE			DD_Req_Mask;	// Mask of possible channels
	BYTE			DD_Reserved;
};


typedef	struct DMA_Des16_s 	DMA_DES16;

struct	IRQ_Des16_s {
	WORD			IRQD_Flags;
	WORD			IRQD_Alloc_Num;		// Allocated IRQ number
	WORD			IRQD_Req_Mask;		// Mask of possible IRQs
	WORD			IRQD_Reserved;
};

typedef	struct IRQ_Des16_s 	IRQ_DES16;

typedef	MEM_DES16			*PMEM_DES16;
typedef	IO_DES16			*PIO_DES16;
typedef	DMA_DES16			*PDMA_DES16;
typedef	IRQ_DES16			*PIRQ_DES16;

// BUS Info structs from KBASE
typedef struct PnPAccess_s    {
       BYTE    bCSN;   // card slot number
       BYTE    bLogicalDevNumber;      // Logical Device #
       WORD    wReadDataPort;          // Read data port
} sPnPAccess;

typedef struct  PCIAccess_s     {
       BYTE    bBusNumber;     // Bus no 0-255
       BYTE    bDevFuncNumber; // Device # in bits 7:3 and
                               // Function # in bits 2:0
       WORD    wPCIReserved;   //
} sPCIAccess;

typedef struct EISAAccess_s     {
       BYTE    bSlotNumber;    // EISA board slot number
       BYTE    bFunctionNumber;
       WORD    wEisaReserved;
} sEISAAccess;

typedef struct PCMCIAAccess_s   {
       WORD    wLogicalSocket;     // Card socket #
       WORD    wPCMCIAReserved;    // Reserved
} sPCMCIAAccess;

typedef struct BIOSAccess_s     {
       BYTE    bBIOSNode;          // Node number
} sBIOSAccess;

/****************************************************************************
 *
 *				CONFIGURATION MANAGER BUS TYPE
 *
 ***************************************************************************/
#define	BusType_None		0x00000000
#define	BusType_ISA		0x00000001
#define	BusType_EISA		0x00000002
#define	BusType_PCI		0x00000004
#define	BusType_PCMCIA		0x00000008
#define	BusType_ISAPNP		0x00000010
#define	BusType_MCA		0x00000020
#define	BusType_BIOS		0x00000040

/*********************************************************************

  The following information was not copied, it is information I pieced
  together on my own.  It probably exists somewhere but I was too
  lazy to find it, so I pieced it together myself.

**********************************************************************/

// OKAY, Here's my definition of the header that precedes each and every resource
// descriptor as far as I can tell.

// This is the size (as far as I can tell) of the resource header that precedes
// each resource descriptor.  The header consists of a DWORD indicating the total
// size of the resource (including the header), a WORD which is the 16-bit Resource
// Id being described, and a byte of padding.

#pragma pack (1)
struct	POORMAN_RESDESC_HDR		// Hacked out with much pain and frustration
{
	DWORD	dwResourceSize;		// Size of resource including header
	DWORD	dwResourceId;		// Resource Id
};
#pragma pack()

typedef POORMAN_RESDESC_HDR*	PPOORMAN_RESDESC_HDR;

#define	SIZEOF_RESDESC_HDR		sizeof(POORMAN_RESDESC_HDR)

#define	FIRST_RESOURCE_OFFSET	8	// Offset off first resource

// Use to mask out all values other than Resource Type (first 5 bits)
#define	RESOURCE_TYPE_MASK		0x0000001F

// Use to mask out all values other than OEM Number
#define	OEM_NUMBER_MASK		0x00007FE0

/*XLATOFF*/
#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(pop)
#else
#pragma pack()
#endif
#else
#pragma pack()
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
/*XLATON*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\profilestringimpl.h ===
// Copyright (c) 2001 Microsoft Corporation, All Rights Reserved

#ifndef	__PROFILE_STRING_IMPL__
#define	__PROFILE_STRING_IMPL__

#if	_MSC_VER > 1000
#pragma once
#endif

///////////////////////////////////////////////////////////////////////////////
// get profile string
///////////////////////////////////////////////////////////////////////////////
DWORD	APIENTRY	WMIRegistry_PrivateProfileString	(
															LPCWSTR	lpAppName,
															LPCWSTR	lpKeyName,
															LPCWSTR	lpDefault,
															LPWSTR	lpReturnedString,
															DWORD	nSize,
															LPCWSTR	lpFileName
														);

DWORD	APIENTRY	WMIRegistry_ProfileString	(
													LPCWSTR lpAppName,
													LPCWSTR lpKeyName,
													LPCWSTR lpDefault,
													LPWSTR lpReturnedString,
													DWORD nSize
												);

///////////////////////////////////////////////////////////////////////////////
// get profile section
///////////////////////////////////////////////////////////////////////////////
DWORD	APIENTRY	WMIRegistry_PrivateProfileSection	(
															LPCWSTR	lpAppName,
															LPWSTR	lpReturnedString,
															DWORD	nSize,
															LPCWSTR	lpFileName
														);

DWORD	APIENTRY	WMIRegistry_ProfileSection	(
													LPCWSTR lpAppName,
													LPWSTR lpReturnedString,
													DWORD nSize
												);

///////////////////////////////////////////////////////////////////////////////
// get profile integer
///////////////////////////////////////////////////////////////////////////////
UINT	APIENTRY	WMIRegistry_PrivateProfileInt	(
														LPCWSTR lpAppName,
														LPCWSTR lpKeyName,
														INT nDefault
													);

UINT	APIENTRY	WMIRegistry_ProfileInt	(
												LPCWSTR lpAppName,
												LPCWSTR lpKeyName,
												INT nDefault
											);

#endif	__PROFILE_STRING_IMPL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\profilestring.h ===
// Copyright (c) 2001 Microsoft Corporation, All Rights Reserved

#ifndef	__PROFILE_STRING__
#define	__PROFILE_STRING__

#if	_MSC_VER > 1000
#pragma once
#endif

// MAPPINGS
#define MY_SHARED_PTR(TYPE_NAME) ULONG_PTR
#define MY_SHARED_STRING LPWSTR 

#define REGISTRY_MAPPING_WRITE_TO_INIFILE_TOO    0x00000001
#define REGISTRY_MAPPING_INIT_FROM_INIFILE       0x00000002
#define REGISTRY_MAPPING_READ_FROM_REGISTRY_ONLY 0x00000004
#define REGISTRY_MAPPING_APPEND_BASE_NAME        0x10000000
#define REGISTRY_MAPPING_APPEND_APPLICATION_NAME 0x20000000
#define REGISTRY_MAPPING_SOFTWARE_RELATIVE       0x40000000
#define REGISTRY_MAPPING_USER_RELATIVE           0x80000000

typedef struct _REGISTRY_MAPPING_TARGET
{
    MY_SHARED_PTR(struct _REGISTRY_MAPPING_TARGET *) Next;
    MY_SHARED_STRING RegistryPath;
} REGISTRY_MAPPING_TARGET, *PREGISTRY_MAPPING_TARGET;

typedef struct _REGISTRY_MAPPING_VARNAME
{
    MY_SHARED_PTR(struct _REGISTRY_MAPPING_VARNAME *) Next;
    MY_SHARED_STRING Name;
    ULONG MappingFlags;
    MY_SHARED_PTR(PREGISTRY_MAPPING_TARGET) MappingTarget;
} REGISTRY_MAPPING_VARNAME, *PREGISTRY_MAPPING_VARNAME;

typedef struct _REGISTRY_MAPPING_APPNAME
{
    MY_SHARED_PTR(struct _REGISTRY_MAPPING_APPNAME *) Next;
    MY_SHARED_STRING Name;
    MY_SHARED_PTR(PREGISTRY_MAPPING_VARNAME) VariableNames;
    MY_SHARED_PTR(PREGISTRY_MAPPING_VARNAME) DefaultVarNameMapping;
} REGISTRY_MAPPING_APPNAME, *PREGISTRY_MAPPING_APPNAME;

typedef struct _REGISTRY_MAPPING_NAME
{
    MY_SHARED_PTR(struct _REGISTRY_MAPPING_NAME *) Next;
    MY_SHARED_STRING Name;
    MY_SHARED_PTR(PREGISTRY_MAPPING_APPNAME) ApplicationNames;
    MY_SHARED_PTR(PREGISTRY_MAPPING_APPNAME) DefaultAppNameMapping;
} REGISTRY_MAPPING_NAME, *PREGISTRY_MAPPING_NAME;

typedef struct _REGISTRY_MAPPING
{
	MY_SHARED_PTR(PREGISTRY_MAPPING_NAME) MyRegistryMapping;
	ULONG Reserved;

} REGISTRY_MAPPING, *PREGISTRY_MAPPING;

// operation enum
typedef enum _REGISTRY_OPERATION
{
    Registry_None,
	Registry_ReadKeyValue,
    Registry_ReadKeyName,
    Registry_ReadSectionValue,
    Registry_ReadSectionName

} REGISTRY_OPERATION;

// parameters
typedef struct _REGISTRY_PARAMETERS
{
	#ifdef	WRITE_OPERATION
	BOOLEAN					WriteOperation;
	#endif	WRITE_OPERATION

	REGISTRY_OPERATION		Operation;
	BOOLEAN					MultiValueStrings;
	BOOLEAN					ValueBufferAllocated;
	PREGISTRY_MAPPING_NAME	Mapping;

	LPCWSTR					FileName;
	LPCWSTR					ApplicationName;
	LPCWSTR					VariableName;

	union
	{
		#ifdef	WRITE_OPERATION
		//
		// This structure filled in for write operations
		//
		struct
		{
			LPWSTR	ValueBuffer;
			ULONG	ValueLength;
		};
		#endif	WRITE_OPERATION

		//
		// This structure filled in for read operations
		//
		struct
		{
			ULONG	ResultChars;		// number of characters
			ULONG	ResultMaxChars;		// number of max characters
			LPWSTR	ResultBuffer;
		};
	};

} REGISTRY_PARAMETERS, *PREGISTRY_PARAMETERS;

#endif	__PROFILE_STRING__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\refptrlite.cpp ===
//=================================================================

//

// refptrlite.CPP - Implementation of CRefPtrLite class

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/15/97    a-sanjes        Created
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>
#include "refptrlite.h"

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPtrLite::CRefPtrLite
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CRefPtrLite::CRefPtrLite( void )
:	m_lRefCount( 1 )	// Our initial ref count is always 1
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPtrLite::~CRefPtrLite
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CRefPtrLite::~CRefPtrLite( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPtrLite::OnFinalRelease
//
//	Virtual function called by Release() when our RefCount reaches 0.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	Override if you want, but always call down to the base
//				implementation and let it call delete on 'this'.
//
////////////////////////////////////////////////////////////////////////

void CRefPtrLite::OnFinalRelease( void )
{
	delete this;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPtrLite::AddRef
//
//	Increases our Reference count by one.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:
//
////////////////////////////////////////////////////////////////////////

LONG CRefPtrLite::AddRef( void )
{
	LONG nRet = InterlockedIncrement(&m_lRefCount);

	return nRet;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPtrLite::Release
//
//	Decreases our Reference count by one.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:
//
////////////////////////////////////////////////////////////////////////

LONG CRefPtrLite::Release( void )
{
	LONG nRet;

	BOOL	fFinalRelease = ( (nRet = InterlockedDecrement(&m_lRefCount)) == 0 );

    ASSERT_BREAK(nRet >= 0);

	if ( fFinalRelease )
	{
		OnFinalRelease();
	}

	return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\profilestring.cpp ===
// Copyright (c) 2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include "profilestring.h"
#include "profilestringimpl.h"

/////////////////////////////////////////////////////////////////////////////////////////
// TOOLS
/////////////////////////////////////////////////////////////////////////////////////////
DWORD	WMIREG_GetBaseFileName ( IN LPCWSTR FileName, OUT LPWSTR* BaseFileName )
{
	DWORD Status = ERROR_INVALID_PARAMETER;

	if ( FileName && BaseFileName )
	{
		*BaseFileName = NULL;

		LPWSTR wsz = NULL;
		wsz = const_cast < LPWSTR > ( FileName ) + wcslen ( FileName );

		while ( --wsz > FileName )
		{
			if ( *wsz == OBJ_NAME_PATH_SEPARATOR || *wsz == L'/' || *wsz == L':' )
			{
				wsz++;
				break;
			}
		}

		if ( wsz )
		{
			try
			{
				if ( ( *BaseFileName = new WCHAR [ wcslen ( wsz ) + 1 ] ) != NULL )
				{
					wcscpy ( *BaseFileName, wsz );
					Status = ERROR_SUCCESS;
				}
				else
				{
					Status = ERROR_NOT_ENOUGH_MEMORY;
				}
			}
			catch ( ... )
			{
				if ( *BaseFileName )
				{
					delete [] *BaseFileName;
					*BaseFileName = NULL;
				}

				Status = ERROR_GEN_FAILURE;
			}
		}
	}

	return Status;
}

BOOLEAN	WMIREG_GetApplicationName	(
										IN PREGISTRY_PARAMETERS a,
										OUT LPCWSTR *ApplicationNameU
									)
{
	if ( ApplicationNameU )
	{
		*ApplicationNameU = a->ApplicationName;
		return TRUE;
	}

    return FALSE;
}

BOOLEAN	WMIREG_GetVariableName	(
									IN PREGISTRY_PARAMETERS a,
									OUT LPCWSTR *VariableNameU
								)
{
	if ( VariableNameU )
	{
		*VariableNameU = a->VariableName;
		return TRUE;
	}

	return FALSE;
}

// get appname mapping
PREGISTRY_MAPPING_NAME	WMIREG_FindMapping	(
												IN PREGISTRY_MAPPING_NAME NameMapping,
												IN LPCWSTR MappingName
											)
{
    PREGISTRY_MAPPING_NAME Mapping	= NULL;
    Mapping = NameMapping;

    while ( Mapping != NULL )
	{
		try
		{
			if ( wcslen( Mapping->Name ) == wcslen( MappingName ) )
			{
				if ( _wcsnicmp ( Mapping->Name, MappingName, wcslen( MappingName ) ) == 0 )
				{
					break;
				}
			}

			Mapping = (PREGISTRY_MAPPING_NAME)Mapping->Next;
		}
		catch ( ... )
		{
			Mapping = NULL;
		}
    }

	return Mapping;
}

// get appname mapping
PREGISTRY_MAPPING_APPNAME	WMIREG_FindAppNameMapping	(
															IN PREGISTRY_MAPPING_NAME NameMapping,
															IN LPCWSTR ApplicationName
														)
{
    PREGISTRY_MAPPING_APPNAME AppNameMapping	= NULL;
    AppNameMapping = (PREGISTRY_MAPPING_APPNAME)NameMapping->ApplicationNames;

    while ( AppNameMapping != NULL )
	{
		try
		{
			if ( wcslen( AppNameMapping->Name ) == wcslen( ApplicationName ) )
			{
				if ( _wcsnicmp ( AppNameMapping->Name, ApplicationName, wcslen( ApplicationName ) ) == 0 )
				{
					break;
				}
			}

			AppNameMapping = (PREGISTRY_MAPPING_APPNAME)AppNameMapping->Next;
		}
		catch ( ... )
		{
			AppNameMapping = NULL;
		}
    }

	if ( !AppNameMapping )
	{
		AppNameMapping = (PREGISTRY_MAPPING_APPNAME)NameMapping->DefaultAppNameMapping;
	}

	return AppNameMapping;
}

//get varname mapping
PREGISTRY_MAPPING_VARNAME	WMIREG_FindVarNameMapping	(
															IN PREGISTRY_MAPPING_APPNAME AppNameMapping,
															IN LPCWSTR VariableName
														)
{
	PREGISTRY_MAPPING_VARNAME VarNameMapping	= NULL;
	VarNameMapping = (PREGISTRY_MAPPING_VARNAME)AppNameMapping->VariableNames;

	while ( VarNameMapping != NULL )
	{
		try
		{
			if ( wcslen ( VarNameMapping->Name ) == wcslen( VariableName ) )
			{
				if ( _wcsnicmp ( VarNameMapping->Name, VariableName, wcslen( VariableName ) ) == 0 )
				{
					break;
				}
			}

			VarNameMapping = (PREGISTRY_MAPPING_VARNAME)VarNameMapping->Next;
		}
		catch ( ... )
		{
			VarNameMapping = NULL;
		}
	}

	if ( !VarNameMapping )
	{
		VarNameMapping = (PREGISTRY_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
	}

	return VarNameMapping;
}

// get string representing user's registry
BOOL	WMIREG_UserPROFILE	( UNICODE_STRING * UserKeyPath )
{
	OBJECT_ATTRIBUTES ObjectAttributes;
	HANDLE Key	= NULL;

	if ( NT_SUCCESS ( RtlFormatCurrentUserKeyPath( UserKeyPath ) ) )
	{
		InitializeObjectAttributes	(	&ObjectAttributes,
										UserKeyPath,
										OBJ_CASE_INSENSITIVE,
										NULL,
										NULL
									);

		if ( NT_SUCCESS ( NtOpenKey( &Key, GENERIC_READ, &ObjectAttributes ) ) )
		{
			NtClose( Key );
		}
		else
		{
			RtlFreeUnicodeString( UserKeyPath );
			RtlInitUnicodeString( UserKeyPath, NULL );
		}
	}

	if ( UserKeyPath->Length == 0)
	{
		if ( !RtlCreateUnicodeString ( UserKeyPath, L"\\REGISTRY\\USER\\.DEFAULT"  ) )
		{
			return FALSE;
		}
	}

	return TRUE;
}

// open registry key
DWORD	WMIREG_OpenMappingTarget	(
										IN PREGISTRY_PARAMETERS a,
										IN PREGISTRY_MAPPING_VARNAME VarNameMapping,
										IN LPCWSTR ApplicationName,
										OUT PHANDLE Key
									)
{
	DWORD Status	= ERROR_INVALID_PARAMETER;

	PREGISTRY_MAPPING_TARGET	MappingTarget	= NULL;
	ULONG						MappingFlags	= 0L;

	BOOLEAN AppendApplicationName	= FALSE;

	OBJECT_ATTRIBUTES ObjectAttributes;

	PUNICODE_STRING RegistryPathPrefix = NULL;
	UNICODE_STRING RegistryPath;

	UNICODE_STRING UserKeyPath;
	UNICODE_STRING SoftwareKeyPath;

	// initialization of strings
    RtlInitUnicodeString( &UserKeyPath, NULL );
    RtlInitUnicodeString( &SoftwareKeyPath, L"\\Registry\\Machine\\Software" );

	// temporary unicode_string
	UNICODE_STRING temp;

	ULONG n	= 0L;	// size of reg key

	// init key
	*Key = INVALID_HANDLE_VALUE;

	// get mapping
	MappingTarget = (PREGISTRY_MAPPING_TARGET)VarNameMapping->MappingTarget;
	MappingFlags = VarNameMapping->MappingFlags &	(	REGISTRY_MAPPING_APPEND_BASE_NAME |
														REGISTRY_MAPPING_APPEND_APPLICATION_NAME |
														REGISTRY_MAPPING_SOFTWARE_RELATIVE |
														REGISTRY_MAPPING_USER_RELATIVE
													);

	if ( MappingTarget != NULL && MappingTarget->RegistryPath )
	{
		// everything's ok
		Status = ERROR_SUCCESS;

		if ( ApplicationName && ( MappingFlags & REGISTRY_MAPPING_APPEND_APPLICATION_NAME ) )
		{
			AppendApplicationName = TRUE;
		}
		else
		{
			AppendApplicationName = FALSE;
		}

		if ( MappingFlags & REGISTRY_MAPPING_USER_RELATIVE )
		{
			if ( WMIREG_UserPROFILE ( &UserKeyPath ) )
			{
				if ( UserKeyPath.Length == 0 )
				{
					Status = ERROR_ACCESS_DENIED;
				}
			}
			else
			{
				Status = ERROR_INVALID_PARAMETER;
			}

			if ( Status == ERROR_SUCCESS )
			{
				RegistryPathPrefix = &UserKeyPath;
			}
		}
		else
		if ( MappingFlags & REGISTRY_MAPPING_SOFTWARE_RELATIVE )
		{
			RegistryPathPrefix = &SoftwareKeyPath;
		}
		else
		{
			RegistryPathPrefix = NULL;
		}

		if ( Status == ERROR_SUCCESS )
		{
			LPWSTR BaseFileName = NULL;

			if ( MappingFlags & REGISTRY_MAPPING_APPEND_BASE_NAME )
			{
				Status = WMIREG_GetBaseFileName ( a->FileName, &BaseFileName );
			}

			if ( Status == ERROR_SUCCESS )
			{
				if ( RegistryPathPrefix )
				{
					n = RegistryPathPrefix->Length + sizeof( WCHAR );
				}

				n += sizeof( WCHAR ) + wcslen ( MappingTarget->RegistryPath ) * sizeof ( WCHAR );
				if ( MappingFlags & REGISTRY_MAPPING_APPEND_BASE_NAME )
				{
					n += sizeof( WCHAR ) + wcslen ( BaseFileName ) * sizeof ( WCHAR );
				}

				if (AppendApplicationName)
				{
					n += sizeof( WCHAR ) + wcslen ( ApplicationName ) * sizeof ( WCHAR );
				}

				n += sizeof( UNICODE_NULL );

				RegistryPath.Buffer = reinterpret_cast < LPWSTR > ( RtlAllocateHeap( RtlProcessHeap(), 0, n ) );
				if (RegistryPath.Buffer == NULL)
				{
					Status = ERROR_NOT_ENOUGH_MEMORY;
				}

				if ( Status == ERROR_SUCCESS )
				{
					RegistryPath.Length = 0;
					RegistryPath.MaximumLength = (USHORT)n;

					if (RegistryPathPrefix != NULL)
					{
						RtlAppendUnicodeStringToString( &RegistryPath, RegistryPathPrefix );
						RtlAppendUnicodeToString( &RegistryPath, L"\\" );
					}

					RtlInitUnicodeString( &temp, MappingTarget->RegistryPath );
					RtlAppendUnicodeStringToString( &RegistryPath, &temp );
					RtlInitUnicodeString( &temp, NULL );

					if (MappingFlags & REGISTRY_MAPPING_APPEND_BASE_NAME)
					{
						RtlAppendUnicodeToString( &RegistryPath, L"\\" );

						RtlInitUnicodeString( &temp, BaseFileName );
						RtlAppendUnicodeStringToString( &RegistryPath, &temp );
						RtlInitUnicodeString( &temp, NULL );
					}

					if (AppendApplicationName)
					{
						RtlAppendUnicodeToString( &RegistryPath, L"\\" );

						RtlInitUnicodeString( &temp, ApplicationName );
						RtlAppendUnicodeStringToString( &RegistryPath, &temp );
						RtlInitUnicodeString( &temp, NULL );
					}

					// open real registry
					InitializeObjectAttributes	(	&ObjectAttributes,
													&RegistryPath,
													OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
													NULL,
													NULL
												);

					Status = NtOpenKey	( Key, GENERIC_READ, &ObjectAttributes );

					// clear registry path
					RtlFreeHeap( RtlProcessHeap(), 0, RegistryPath.Buffer );
				}
			}

			// clear use string
			if ( UserKeyPath.Length )
			{
				RtlFreeUnicodeString ( &UserKeyPath );
			}

			if ( BaseFileName )
			{
				delete [] BaseFileName;
			}
		}
	}

	return Status;
}

// append string to result buffer
DWORD	REGISTRY_AppendBufferToResultBuffer	(
												IN PREGISTRY_PARAMETERS a,
												IN PUNICODE_STRING Buffer,
												IN BOOLEAN IncludeNull
											)
{
	DWORD OverflowStatus = ERROR_INVALID_PARAMETER;

	if ( Buffer )
	{
		ULONG Chars = Buffer->Length / sizeof( WCHAR );

		if ( a->ResultChars + Chars >= a->ResultMaxChars )
		{
			OverflowStatus = ERROR_MORE_DATA;

			Chars = a->ResultMaxChars - a->ResultChars;
			if ( Chars )
			{
				Chars -= 1;
			}
		}

		if ( Chars )
		{
			memcpy( reinterpret_cast < PBYTE > ( a->ResultBuffer ) + ( a->ResultChars * sizeof( WCHAR ) ), Buffer->Buffer, Chars * sizeof( WCHAR ) );
			a->ResultChars += Chars;
		}

		if ( OverflowStatus != ERROR_MORE_DATA )
		{
			OverflowStatus = ERROR_SUCCESS;
		}
	}

	if (IncludeNull)
	{
		if ( a->ResultChars + 1 >= a->ResultMaxChars )
		{
			OverflowStatus = ERROR_MORE_DATA;
		}
		else
		{
			a->ResultBuffer[ a->ResultChars ] = L'\0';
			a->ResultChars += 1;
		}
	}

	return OverflowStatus;
}

DWORD	REGISTRY_AppendNULLToResultBuffer ( IN PREGISTRY_PARAMETERS a )
{
    return REGISTRY_AppendBufferToResultBuffer( a, NULL, TRUE );
}

NTSTATUS	REGISTRY_CheckSubKeyNotEmpty ( IN HANDLE Key, IN PUNICODE_STRING SubKeyName )
{
	NTSTATUS Status = STATUS_SUCCESS;
	OBJECT_ATTRIBUTES ObjectAttributes;
	HANDLE SubKey	= INVALID_HANDLE_VALUE;
	KEY_VALUE_BASIC_INFORMATION KeyValueInformation;
	ULONG ResultLength;

	InitializeObjectAttributes( &ObjectAttributes,
								SubKeyName,
								OBJ_CASE_INSENSITIVE,
								Key,
								NULL
							  );

	Status = NtOpenKey( &SubKey, GENERIC_READ, &ObjectAttributes );
	if ( NT_SUCCESS ( Status ) )
	{
		Status = NtEnumerateValueKey	(	SubKey,
											0,
											KeyValueBasicInformation,
											&KeyValueInformation,
											sizeof( KeyValueInformation ),
											&ResultLength
										);

		if ( Status == STATUS_BUFFER_OVERFLOW )
		{
			Status = STATUS_SUCCESS;
		}

		NtClose( SubKey );
	}

	return Status;
}

/////////////////////////////////////////////////////////////////////////////////////////
// REAL REGISTRY FUNCTIONALITY
/////////////////////////////////////////////////////////////////////////////////////////
DWORD REGISTRY_ReadVariableValue	(
										IN PREGISTRY_PARAMETERS a,
										PREGISTRY_MAPPING_APPNAME AppNameMapping,
										PREGISTRY_MAPPING_VARNAME VarNameMapping,
										LPCWSTR VariableName
									)
{
	DWORD Status			= ERROR_INVALID_PARAMETER;
	LPCWSTR	ApplicationName	= NULL;

	BOOLEAN	OutputVariableName = FALSE;

	UNICODE_STRING EqualSign;

	if ( VariableName )
	{
		RtlInitUnicodeString ( &EqualSign, L"=" );
		OutputVariableName = TRUE;
	}

	if ( !VariableName )
	{
		if ( ! WMIREG_GetVariableName ( a, &VariableName ) )
		{
			VariableName = NULL;
		}
	}

	if ( VariableName != NULL )
	{
		if ( ! VarNameMapping )
		{
			VarNameMapping = WMIREG_FindVarNameMapping ( AppNameMapping, VariableName );
		}

		if ( VarNameMapping != NULL )
		{
			if ( WMIREG_GetApplicationName ( a, &ApplicationName ) )
			{
				HANDLE Key = INVALID_HANDLE_VALUE;

				Status = WMIREG_OpenMappingTarget	(	a,
														VarNameMapping,
														ApplicationName,
														&Key
													);

				if ( Status == ERROR_SUCCESS && Key != INVALID_HANDLE_VALUE )
				{
					NTSTATUS NtStatus;

					KEY_VALUE_PARTIAL_INFORMATION	KeyValueInformation;
					PKEY_VALUE_PARTIAL_INFORMATION	p = NULL;

					DWORD ResultLength = 0L;

					UNICODE_STRING temp;
					RtlInitUnicodeString ( &temp, VariableName );

					NtStatus = NtQueryValueKey	(	Key,
													&temp,
													KeyValuePartialInformation,
													&KeyValueInformation,
													sizeof( KeyValueInformation ),
													&ResultLength
												);

					if ( ! NT_SUCCESS ( NtStatus ) )
					{
						if ( NtStatus == STATUS_BUFFER_OVERFLOW )
						{
							p = reinterpret_cast < PKEY_VALUE_PARTIAL_INFORMATION > ( RtlAllocateHeap ( RtlProcessHeap(), HEAP_ZERO_MEMORY, ResultLength ) );
							if ( p != NULL )
							{
								NtStatus = NtQueryValueKey	(	Key,
																&temp,
																KeyValuePartialInformation,
																p,
																ResultLength,
																&ResultLength
															);

								Status = NtStatus;
							}
							else
							{
								Status = ERROR_NOT_ENOUGH_MEMORY;
							}
						}
						else
						{
							Status = NtStatus;
						}
					}
					else
					{
						p = &KeyValueInformation;
					}

					// create results
					if ( Status == ERROR_SUCCESS )
					{
						if ( OutputVariableName )
						{
							Status = REGISTRY_AppendBufferToResultBuffer( a, &temp, FALSE );
							if ( Status == ERROR_SUCCESS )
							{
								Status = REGISTRY_AppendBufferToResultBuffer( a, &EqualSign, FALSE );
							}
						}

						if ( Status == ERROR_SUCCESS )
						{
							if ( p->Type == REG_SZ )
							{
								UNICODE_STRING	Value;
								LPWSTR			s = NULL;

								Value.Buffer = reinterpret_cast < LPWSTR > ( &p->Data[ 0 ] );
								if ( p->DataLength >= sizeof( UNICODE_NULL ) )
								{
									Value.Length = static_cast< USHORT > ( p->DataLength - sizeof ( UNICODE_NULL ) );
								}
								else
								{
									Value.Length = 0;
								}

								Value.MaximumLength = static_cast < USHORT > (p->DataLength);
								s = reinterpret_cast < LPWSTR > ( Value.Buffer );

								if (	a->Operation == Registry_ReadKeyValue &&
										Value.Length >= ( 2 * sizeof( WCHAR ) ) &&
										( s[ 0 ] == s[ ( Value.Length - sizeof( WCHAR ) ) / sizeof( WCHAR ) ] ) &&
										( s[ 0 ] == L'"' || s[ 0 ] == L'\'' )
								   )
								{
									Value.Buffer += 1;
									Value.Length -= (2 * sizeof( WCHAR ));
								}

								Status = REGISTRY_AppendBufferToResultBuffer( a, &Value, TRUE );
							}
							else
							{
								Status = STATUS_OBJECT_TYPE_MISMATCH;
							}
						}
					}

					// clear buffer
					if ( p && p != &KeyValueInformation )
					{
						RtlFreeHeap( RtlProcessHeap(), 0, p );
					}

					NtClose ( Key );
				}
			}
		}
	}

	return Status;
}

DWORD REGISTRY_ReadVariableName ( IN PREGISTRY_PARAMETERS a, PREGISTRY_MAPPING_APPNAME AppNameMapping )
{
	DWORD Status = ERROR_SUCCESS;

	PREGISTRY_MAPPING_VARNAME	VarNameMapping	= NULL;
	LPCWSTR						ApplicationName	= NULL;

	HANDLE Key = INVALID_HANDLE_VALUE;

	WCHAR Buffer[ 256 ];
	PKEY_VALUE_BASIC_INFORMATION KeyValueInformation = NULL;

	// temporary unicode strings
	UNICODE_STRING temp;

	VarNameMapping = (PREGISTRY_MAPPING_VARNAME)AppNameMapping->VariableNames;
	while ( VarNameMapping != NULL && Status == ERROR_SUCCESS )
	{
		RtlInitUnicodeString ( &temp, VarNameMapping->Name );
		Status = REGISTRY_AppendBufferToResultBuffer( a, &temp, TRUE );

		if ( Status == ERROR_SUCCESS )
		{
			VarNameMapping = (PREGISTRY_MAPPING_VARNAME)VarNameMapping->Next;
		}
	}

	if ( Status == ERROR_SUCCESS )
	{
		VarNameMapping = (PREGISTRY_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
		if ( VarNameMapping != NULL )
		{
			if ( WMIREG_GetApplicationName ( a, &ApplicationName ) )
			{
				Status = WMIREG_OpenMappingTarget	(	a,
														VarNameMapping,
														ApplicationName,
														&Key
													);

				if ( Status == ERROR_SUCCESS && Key != INVALID_HANDLE_VALUE )
				{
					KeyValueInformation = (PKEY_VALUE_BASIC_INFORMATION)Buffer;
					for ( ULONG ValueIndex = 0; Status == ERROR_SUCCESS; ValueIndex++ )
					{
						ULONG ResultLength	= 0L;

						Status = NtEnumerateValueKey( Key,
													  ValueIndex,
													  KeyValueBasicInformation,
													  KeyValueInformation,
													  sizeof( Buffer ),
													  &ResultLength
													);

						if ( Status == STATUS_NO_MORE_ENTRIES )
						{
							break;
						}

						if ( NT_SUCCESS ( Status ) )
						{
							temp.Buffer = KeyValueInformation->Name;
							temp.Length = (USHORT)KeyValueInformation->NameLength;
							temp.MaximumLength = (USHORT)KeyValueInformation->NameLength;

							Status = REGISTRY_AppendBufferToResultBuffer( a, &temp, TRUE );
						}
					}

					if ( Status == STATUS_NO_MORE_ENTRIES )
					{
						Status = ERROR_SUCCESS;
					}

					NtClose ( Key );
				}
			}
			else
			{
				Status = ERROR_INVALID_PARAMETER;
			}
		}
	}

	return Status;
}

DWORD	REGISTRY_ReadSectionValue ( IN PREGISTRY_PARAMETERS a, PREGISTRY_MAPPING_APPNAME AppNameMapping )
{
	DWORD Status = ERROR_SUCCESS;

	PREGISTRY_MAPPING_VARNAME	VarNameMapping = NULL;
	LPCWSTR						ApplicationName= NULL;

	WCHAR Buffer[ 256 ];
	PKEY_VALUE_BASIC_INFORMATION KeyValueInformation = NULL;

	HANDLE Key = INVALID_HANDLE_VALUE;

	VarNameMapping = (PREGISTRY_MAPPING_VARNAME)AppNameMapping->VariableNames;
	while ( VarNameMapping != NULL && Status == ERROR_SUCCESS )
	{
		if ( VarNameMapping->Name )
		{
			Status = REGISTRY_ReadVariableValue ( a, AppNameMapping, VarNameMapping, VarNameMapping->Name );
			if ( Status != ERROR_SUCCESS )
			{
				if ( Status == STATUS_OBJECT_TYPE_MISMATCH )
				{
					Status = STATUS_SUCCESS;
				}
			}
		}

		if ( Status == ERROR_SUCCESS )
		{
			VarNameMapping = (PREGISTRY_MAPPING_VARNAME)VarNameMapping->Next;
		}
	}

	if ( Status == ERROR_SUCCESS )
	{
		VarNameMapping = (PREGISTRY_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
		if ( VarNameMapping != NULL)
		{
			if ( WMIREG_GetApplicationName ( a, &ApplicationName ) )
			{
				Status = WMIREG_OpenMappingTarget	(	a,
														VarNameMapping,
														ApplicationName,
														&Key
													);

				if ( Status == ERROR_SUCCESS && Key != INVALID_HANDLE_VALUE )
				{
					KeyValueInformation = (PKEY_VALUE_BASIC_INFORMATION)Buffer;
					for ( ULONG ValueIndex = 0; Status == ERROR_SUCCESS; ValueIndex++ )
					{
						ULONG ResultLength = 0L;

						Status = NtEnumerateValueKey(	Key,
														ValueIndex,
														KeyValueBasicInformation,
														KeyValueInformation,
														sizeof( Buffer ),
														&ResultLength
													);

						if ( Status == STATUS_NO_MORE_ENTRIES )
						{
							break;
						}

						if ( NT_SUCCESS ( Status ) )
						{
							LPWSTR VariableName = NULL;

							try
							{
								if ( ( VariableName = new WCHAR [ KeyValueInformation->NameLength / sizeof ( WCHAR ) + 1 ] ) != NULL )
								{
									wcsncpy ( VariableName, (LPWSTR)&(KeyValueInformation->Name[0]), KeyValueInformation->NameLength / sizeof ( WCHAR ) );
									VariableName [ KeyValueInformation->NameLength / sizeof ( WCHAR ) ] = L'\0';
								}
								else
								{
									Status = ERROR_NOT_ENOUGH_MEMORY;
								}
							}
							catch ( ... )
							{
								if ( VariableName )
								{
									delete [] VariableName;
									VariableName = NULL;
								}

								Status = ERROR_GEN_FAILURE;
							}

							if ( Status == ERROR_SUCCESS )
							{
								Status = REGISTRY_ReadVariableValue( a, AppNameMapping, NULL, VariableName );

								delete [] VariableName;
								VariableName = NULL;

								if ( Status != ERROR_SUCCESS )
								{
									if ( Status == STATUS_OBJECT_TYPE_MISMATCH )
									{
										Status = STATUS_SUCCESS;
									}
								}
							}
						}
					}

					if ( Status == STATUS_NO_MORE_ENTRIES )
					{
						Status = ERROR_SUCCESS;
					}

					NtClose ( Key );
				}
			}
		}
	}

	return Status;
}

DWORD REGISTRY_ReadSectionName ( IN PREGISTRY_PARAMETERS a )
{
	DWORD Status = ERROR_SUCCESS;

	PREGISTRY_MAPPING_APPNAME AppNameMapping	= NULL;
	HANDLE Key									= INVALID_HANDLE_VALUE;

	WCHAR Buffer[ 256 ];
	PKEY_BASIC_INFORMATION KeyInformation		= NULL;

	// temporary unicode strings
	UNICODE_STRING temp;

	PREGISTRY_MAPPING_NAME Mapping = NULL;

	LPWSTR BaseFileName = NULL;
	Status = WMIREG_GetBaseFileName ( a->FileName, &BaseFileName );

	if ( Status == ERROR_SUCCESS && BaseFileName )
	{
		Mapping = WMIREG_FindMapping ( a->Mapping, BaseFileName );

		delete [] BaseFileName;
		BaseFileName = NULL;
	}

	if ( Mapping )
	{
		AppNameMapping = (PREGISTRY_MAPPING_APPNAME)Mapping->ApplicationNames;
		while ( AppNameMapping != NULL && Status == ERROR_SUCCESS )
		{
			RtlInitUnicodeString ( &temp, AppNameMapping->Name );
			Status = REGISTRY_AppendBufferToResultBuffer( a, &temp, TRUE );

			if ( Status == ERROR_SUCCESS )
			{
				AppNameMapping = (PREGISTRY_MAPPING_APPNAME)AppNameMapping->Next;
			}
		}

		if ( Status == ERROR_SUCCESS )
		{
			AppNameMapping = (PREGISTRY_MAPPING_APPNAME)a->Mapping->DefaultAppNameMapping;
			if ( AppNameMapping != NULL )
			{
				Status = WMIREG_OpenMappingTarget	(	a,
														reinterpret_cast < PREGISTRY_MAPPING_VARNAME > ( AppNameMapping->DefaultVarNameMapping ),
														NULL,
														&Key
													);

				if ( Status == ERROR_SUCCESS && Key != INVALID_HANDLE_VALUE )
				{
					KeyInformation = (PKEY_BASIC_INFORMATION)Buffer;
					for ( ULONG SubKeyIndex = 0; Status == ERROR_SUCCESS; SubKeyIndex++ )
					{
						ULONG ResultLength	= 0L;

						Status = NtEnumerateKey( Key,
												  SubKeyIndex,
												  KeyBasicInformation,
												  KeyInformation,
												  sizeof( Buffer ),
												  &ResultLength
											   );

						if ( Status == STATUS_NO_MORE_ENTRIES )
						{
							break;
						}

						if ( NT_SUCCESS ( Status ) )
						{
							temp.Buffer = (PWSTR)&(KeyInformation->Name[0]);
							temp.Length = (USHORT)KeyInformation->NameLength;
							temp.MaximumLength = (USHORT)KeyInformation->NameLength;

							Status = REGISTRY_CheckSubKeyNotEmpty( Key, &temp );

							if ( NT_SUCCESS ( Status ) )
							{
								Status = REGISTRY_AppendBufferToResultBuffer( a, &temp, TRUE );
							}
							else
							if ( Status != STATUS_NO_MORE_ENTRIES )
							{
								break;
							}
							else
							{
								Status = STATUS_SUCCESS;
							}
						}
					}

					if ( Status == STATUS_NO_MORE_ENTRIES )
					{
						Status = ERROR_SUCCESS;
					}

					NtClose ( Key );
				}
			}
		}
	}

	return Status;
}

/////////////////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION
/////////////////////////////////////////////////////////////////////////////////////////

DWORD	WMIRegistry_Mapping	( IN PREGISTRY_PARAMETERS a )
{
    DWORD Status	= ERROR_INVALID_PARAMETER;

	if ( a )
	{
		if ( a->Operation == Registry_ReadSectionName )
		{
			Status = REGISTRY_ReadSectionName ( a );
		}
		else
		{
			LPCWSTR ApplicationName = NULL;
			if ( WMIREG_GetApplicationName ( a, &ApplicationName ) )
			{
				PREGISTRY_MAPPING_NAME Mapping = NULL;

				LPWSTR BaseFileName = NULL;
				Status = WMIREG_GetBaseFileName ( a->FileName, &BaseFileName );

				if ( Status == ERROR_SUCCESS && BaseFileName )
				{
					Mapping = WMIREG_FindMapping ( a->Mapping, BaseFileName );

					delete [] BaseFileName;
					BaseFileName = NULL;
				}

				if ( Mapping )
				{
					PREGISTRY_MAPPING_APPNAME AppNameMapping = NULL;
					AppNameMapping = WMIREG_FindAppNameMapping ( Mapping, ApplicationName );

					if ( AppNameMapping )
					{
						if ( a->Operation == Registry_ReadKeyValue )
						{
							Status = REGISTRY_ReadVariableValue ( a, AppNameMapping, NULL, NULL );
						}
						else
						if ( a->Operation == Registry_ReadKeyName )
						{
							Status = REGISTRY_ReadVariableName ( a, AppNameMapping );
						}
						else
						if ( a->Operation == Registry_ReadSectionValue )
						{
							Status = REGISTRY_ReadSectionValue ( a, AppNameMapping );
						}
						else
						{
							// not supported operation
							// possible write ?
							Status	= ERROR_INVALID_PARAMETER;
						}
					}
					else
					{
						// no registry for this section
						// you should use file function

						Status = STATUS_MORE_PROCESSING_REQUIRED;
					}
				}
			}
		}
	}

	return Status;
}

///////////////////////////////////////////////////////////////////////////////
// ALLOCATION of reg structures
///////////////////////////////////////////////////////////////////////////////

PREGISTRY_MAPPING_TARGET	MappingTargetAlloc	(
													IN LPCWSTR RegistryPath,
													OUT PULONG MappingFlags
												)
{
	BOOLEAN RelativePath = FALSE;
	UNICODE_STRING RegistryPathString;

	PREGISTRY_MAPPING_TARGET MappingTarget = NULL;

    LPCWSTR SaveRegistryPath = RegistryPath;
	ULONG Flags = 0L;

	// simulate result
	*MappingFlags = Flags;

	BOOLEAN	Continue = TRUE;

	while ( Continue )
	{
		try
		{
			if ( *RegistryPath == L'!' )
			{
				Flags |= REGISTRY_MAPPING_WRITE_TO_INIFILE_TOO;
				RegistryPath += 1;
			}
			else
			if ( *RegistryPath == L'#' )
			{
				Flags |= REGISTRY_MAPPING_INIT_FROM_INIFILE;
				RegistryPath += 1;
			}
			else
			if ( *RegistryPath == L'@' )
			{
				Flags |= REGISTRY_MAPPING_READ_FROM_REGISTRY_ONLY;
				RegistryPath += 1;
			}
			else
			if ( !_wcsnicmp ( RegistryPath, L"USR:", 4 ) )
			{
				Flags |= REGISTRY_MAPPING_USER_RELATIVE;
				RegistryPath += 4;
				break;
			}
			else
			if ( !_wcsnicmp ( RegistryPath, L"SYS:", 4 ) )
			{
				Flags |= REGISTRY_MAPPING_SOFTWARE_RELATIVE;
				RegistryPath += 4;
				break;
			}
			else
			{
				break;
			}
		}
		catch ( ... )
		{
			Continue = FALSE;
		}
	}

	if ( Continue )
	{
		if ( Flags & ( REGISTRY_MAPPING_USER_RELATIVE | REGISTRY_MAPPING_SOFTWARE_RELATIVE ) )
		{
			RelativePath = TRUE;
		}

		if ( ( RelativePath && *RegistryPath != OBJ_NAME_PATH_SEPARATOR ) ||
			 ( !RelativePath && *RegistryPath == OBJ_NAME_PATH_SEPARATOR )
		   )
		{
			RtlInitUnicodeString( &RegistryPathString, RegistryPath );
		}
		else
		if ( !RelativePath && *RegistryPath == UNICODE_NULL )
		{
			RtlInitUnicodeString( &RegistryPathString, NULL );
		}
		else
		{
			Continue = FALSE;
		}

		if ( Continue )
		{
			MappingTarget = reinterpret_cast < PREGISTRY_MAPPING_TARGET > ( RtlAllocateHeap( RtlProcessHeap (), HEAP_ZERO_MEMORY, sizeof( REGISTRY_MAPPING_TARGET ) ) );
			if ( MappingTarget != NULL )
			{
				*MappingFlags = Flags;

				MappingTarget->RegistryPath = NULL;
				if ( RegistryPathString.Length != 0 )
				{
					try
					{
						if ( ( MappingTarget->RegistryPath = new WCHAR [ RegistryPathString.Length / sizeof ( WCHAR ) + 1 ] ) != NULL )
						{
							wcsncpy ( MappingTarget->RegistryPath, RegistryPathString.Buffer, RegistryPathString.Length / sizeof ( WCHAR ) );
							MappingTarget->RegistryPath [RegistryPathString.Length / sizeof ( WCHAR )] = L'\0';
						}
					}
					catch ( ... )
					{
						if ( MappingTarget->RegistryPath )
						{
							delete [] MappingTarget->RegistryPath;
							MappingTarget->RegistryPath = NULL;
						}
					}
				}
			}
		}
	}

    return MappingTarget;
}

DWORD	MappingTargetFree	( IN PREGISTRY_MAPPING_TARGET MappingTarget )
{
	DWORD Status = ERROR_INVALID_PARAMETER;

	if ( MappingTarget )
	{
		PREGISTRY_MAPPING_TARGET MappingTargetNext = NULL;
		MappingTargetNext = reinterpret_cast < PREGISTRY_MAPPING_TARGET > ( MappingTarget->Next );

		if ( MappingTargetNext )
		{
			MappingTargetFree ( MappingTargetNext );
		}
		if ( MappingTarget->RegistryPath )
		{
			delete [] MappingTarget->RegistryPath;
			MappingTarget->RegistryPath = NULL;
		}

		RtlFreeHeap( RtlProcessHeap(), 0, MappingTarget );

		// success
		Status = ERROR_SUCCESS;
	}

	return Status;
}

DWORD	MappingVarNameFree	( IN PREGISTRY_MAPPING_VARNAME VarNameMapping );
BOOLEAN	MappingVarNameAlloc	(
								PREGISTRY_MAPPING_NAME FileNameMapping,
								PREGISTRY_MAPPING_APPNAME AppNameMapping,
								PUNICODE_STRING VariableName,
								LPCWSTR RegistryPath,
								PREGISTRY_MAPPING_VARNAME *ReturnedVarNameMapping
							)
{
	PREGISTRY_MAPPING_TARGET MappingTarget	= NULL;;
	PREGISTRY_MAPPING_VARNAME VarNameMapping	= NULL;
	PREGISTRY_MAPPING_VARNAME  *pp;

	ULONG MappingFlags = 0L;

	BOOLEAN	Result = FALSE;
	BOOLEAN	Continue = TRUE;

	if ( VariableName->Length != 0 )
	{
		pp = reinterpret_cast < PREGISTRY_MAPPING_VARNAME* > ( &AppNameMapping->VariableNames );
		while ( VarNameMapping = *pp )
		{
			try
			{
				if ( VarNameMapping->Name )
				{
					if ( ! _wcsnicmp ( VariableName->Buffer, VarNameMapping->Name, VariableName->Length ) )
					{
						break;
					}
				}
			}
			catch ( ... )
			{
				Continue = FALSE;
				break;
			}

			pp = reinterpret_cast < PREGISTRY_MAPPING_VARNAME* > ( &VarNameMapping->Next );
		}
	}
	else
	{
		pp = reinterpret_cast < PREGISTRY_MAPPING_VARNAME* > ( &AppNameMapping->DefaultVarNameMapping );
		VarNameMapping = *pp;
	}

	if ( Continue && VarNameMapping == NULL )
	{
		MappingTarget = MappingTargetAlloc ( RegistryPath, &MappingFlags );
		if (MappingTarget != NULL)
		{
			VarNameMapping = reinterpret_cast < PREGISTRY_MAPPING_VARNAME > ( RtlAllocateHeap( RtlProcessHeap (), HEAP_ZERO_MEMORY, sizeof( REGISTRY_MAPPING_VARNAME ) ) );
			if (VarNameMapping != NULL)
			{
				VarNameMapping->MappingFlags	= MappingFlags;
				VarNameMapping->MappingTarget	= reinterpret_cast < ULONG_PTR > ( MappingTarget );

				if ( VariableName->Length != 0 )
				{
					try
					{
						if ( ( VarNameMapping->Name = new WCHAR [ VariableName->Length / sizeof ( WCHAR ) + 1 ] ) != NULL )
						{
							wcsncpy ( VarNameMapping->Name, VariableName->Buffer, VariableName->Length / sizeof ( WCHAR ) );
							VarNameMapping->Name [VariableName->Length / sizeof ( WCHAR )] = L'\0';

							Result = TRUE;
						}
					}
					catch ( ... )
					{
						if ( VarNameMapping->Name )
						{
							delete [] VarNameMapping->Name;
							VarNameMapping->Name = NULL;
						}

						MappingVarNameFree ( VarNameMapping );
						throw;
					}
				}
				else
				{
					Result = TRUE;
				}

				*pp = VarNameMapping;

				// return value
				*ReturnedVarNameMapping = VarNameMapping;
			}
		}
	}

    return Result;
}

DWORD	MappingVarNameFree	( IN PREGISTRY_MAPPING_VARNAME VarNameMapping )
{
	DWORD Status = ERROR_INVALID_PARAMETER;

	if ( VarNameMapping )
	{
		PREGISTRY_MAPPING_VARNAME VarNameMappingNext = NULL;
		VarNameMappingNext = reinterpret_cast < PREGISTRY_MAPPING_VARNAME > ( VarNameMapping->Next );

		if ( VarNameMappingNext )
		{
			MappingVarNameFree ( VarNameMappingNext );
		}

		// return status from helper ?
		Status = MappingTargetFree ( reinterpret_cast < PREGISTRY_MAPPING_TARGET > ( VarNameMapping->MappingTarget ) );

		if ( VarNameMapping->Name )
		{
			delete [] VarNameMapping->Name;
			VarNameMapping->Name = NULL;
		}

		RtlFreeHeap( RtlProcessHeap(), 0, VarNameMapping );
		VarNameMapping = NULL;

		// success
		Status = ERROR_SUCCESS;
	}

	return Status;
}

DWORD	MappingAppNameFree	( IN PREGISTRY_MAPPING_APPNAME AppNameMapping );
BOOLEAN	MappingAppNameAlloc	(
								PREGISTRY_MAPPING_NAME FileNameMapping,
								PUNICODE_STRING ApplicationName,
								PREGISTRY_MAPPING_APPNAME *ReturnedAppNameMapping
							)
{
	PREGISTRY_MAPPING_APPNAME AppNameMapping	= NULL;
	PREGISTRY_MAPPING_APPNAME *pp;

	BOOLEAN	Result = FALSE;
	BOOLEAN	Continue = TRUE;

	if ( ApplicationName->Length != 0 )
	{
		pp = reinterpret_cast < PREGISTRY_MAPPING_APPNAME* > ( &FileNameMapping->ApplicationNames );
		while ( AppNameMapping = *pp )
		{
			try
			{
				if ( AppNameMapping->Name )
				{
					if ( ! _wcsnicmp ( ApplicationName->Buffer, AppNameMapping->Name, ApplicationName->Length ) )
					{
						break;
					}
				}
			}
			catch ( ... )
			{
				Continue = FALSE;
				break;
			}

			pp = reinterpret_cast < PREGISTRY_MAPPING_APPNAME* > ( &AppNameMapping->Next );
		}
	}
	else
	{
		pp = reinterpret_cast < PREGISTRY_MAPPING_APPNAME* > ( &FileNameMapping->DefaultAppNameMapping );
		AppNameMapping = *pp;
	}

	if ( Continue && AppNameMapping == NULL)
	{
		AppNameMapping = reinterpret_cast < PREGISTRY_MAPPING_APPNAME > ( RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof( REGISTRY_MAPPING_APPNAME ) ) );
		if (AppNameMapping != NULL)
		{
			if (ApplicationName->Length != 0)
			{
				try
				{
					if ( ( AppNameMapping->Name = new WCHAR [ ApplicationName->Length / sizeof ( WCHAR ) + 1 ] ) != NULL )
					{
						wcsncpy ( AppNameMapping->Name, ApplicationName->Buffer, ApplicationName->Length / sizeof ( WCHAR ) );
						AppNameMapping->Name [ApplicationName->Length / sizeof ( WCHAR )] = L'\0';

						Result = TRUE;
					}
				}
				catch ( ... )
				{
					if ( AppNameMapping->Name )
					{
						delete [] AppNameMapping->Name;
						AppNameMapping->Name = NULL;
					}

					MappingAppNameFree ( AppNameMapping );
					throw;
				}
			}
			else
			{
				Result = TRUE;
			}

			*pp = AppNameMapping;

			// return value
			*ReturnedAppNameMapping = AppNameMapping;
		}
	}

    return Result;
}

DWORD	MappingAppNameFree	( IN PREGISTRY_MAPPING_APPNAME AppNameMapping )
{
	DWORD Status = ERROR_INVALID_PARAMETER;

	if ( AppNameMapping )
	{
		PREGISTRY_MAPPING_APPNAME AppNameMappingNext = NULL;
		AppNameMappingNext = reinterpret_cast < PREGISTRY_MAPPING_APPNAME > ( AppNameMapping->Next );

		if ( AppNameMappingNext )
		{
			MappingAppNameFree ( AppNameMappingNext );
		}

		MappingVarNameFree( reinterpret_cast < PREGISTRY_MAPPING_VARNAME > ( AppNameMapping->VariableNames ) );
		MappingVarNameFree( reinterpret_cast < PREGISTRY_MAPPING_VARNAME > ( AppNameMapping->DefaultVarNameMapping ) );

		if ( AppNameMapping->Name )
		{
			delete [] AppNameMapping->Name;
			AppNameMapping->Name = NULL;
		}

		RtlFreeHeap( RtlProcessHeap(), 0, AppNameMapping );
		AppNameMapping = NULL;

		// success
		Status = ERROR_SUCCESS;
	}

	return Status;
}

BOOLEAN	MappingNameAlloc	(
								IN PUNICODE_STRING FileName,
								OUT PREGISTRY_MAPPING_NAME *ReturnedFileNameMapping
							)
{
    PREGISTRY_MAPPING_NAME FileNameMapping = NULL;

	BOOLEAN Result = FALSE;

	FileNameMapping = reinterpret_cast < PREGISTRY_MAPPING_NAME > ( RtlAllocateHeap( RtlProcessHeap (), HEAP_ZERO_MEMORY, sizeof( REGISTRY_MAPPING_NAME ) ) );
	if ( FileNameMapping != NULL)
	{
		if (FileName->Length != 0)
		{
			try
			{
				if ( ( FileNameMapping->Name = new WCHAR [ FileName->Length / sizeof ( WCHAR ) + 1 ] ) != NULL )
				{
					wcsncpy ( FileNameMapping->Name, FileName->Buffer, FileName->Length / sizeof ( WCHAR ) );
					FileNameMapping->Name [FileName->Length / sizeof ( WCHAR )] = L'\0';

					Result = TRUE;
				}
			}
			catch ( ... )
			{
				if ( FileNameMapping->Name )
				{
					delete [] FileNameMapping->Name;
					FileNameMapping->Name = NULL;
				}
			}
		}
		else
		{
			Result = TRUE;
		}

		// return value
		*ReturnedFileNameMapping = FileNameMapping;
	}

    return Result;
}

DWORD	MappingNameFree	( IN PREGISTRY_MAPPING_NAME FileNameMapping )
{
	DWORD Status = ERROR_INVALID_PARAMETER;

	if ( FileNameMapping )
	{
		PREGISTRY_MAPPING_NAME FileNameMappingNext = NULL;
		FileNameMappingNext = reinterpret_cast < PREGISTRY_MAPPING_NAME > ( FileNameMapping->Next );

		if ( FileNameMappingNext )
		{
			MappingNameFree ( FileNameMappingNext );
		}

		MappingAppNameFree( reinterpret_cast < PREGISTRY_MAPPING_APPNAME > ( FileNameMapping->ApplicationNames ) );
		MappingAppNameFree( reinterpret_cast < PREGISTRY_MAPPING_APPNAME > ( FileNameMapping->DefaultAppNameMapping ) );

		if ( FileNameMapping->Name )
		{
			delete [] FileNameMapping->Name;
			FileNameMapping->Name = NULL;
		}

		RtlFreeHeap( RtlProcessHeap(), 0, FileNameMapping );
		FileNameMapping = NULL;

		// success
		Status = ERROR_SUCCESS;
	}

	return Status;
}

NTSTATUS	IniFileMapping	(
								IN PREGISTRY_MAPPING_NAME FileNameMapping,
								IN HANDLE Key,

								IN LPCWSTR MyApplicationName,
								IN LPCWSTR MyVariableName
							)
{
	NTSTATUS Status	= STATUS_SUCCESS;
	WCHAR Buffer[ 512 ];
	PKEY_BASIC_INFORMATION		KeyInformation		= NULL;
	PKEY_VALUE_FULL_INFORMATION	KeyValueInformation	= NULL;

	OBJECT_ATTRIBUTES ObjectAttributes;

	PREGISTRY_MAPPING_APPNAME AppNameMapping	= NULL;
	PREGISTRY_MAPPING_VARNAME VarNameMapping = NULL;

	HANDLE SubKeyHandle = INVALID_HANDLE_VALUE;
	ULONG SubKeyIndex;
	UNICODE_STRING ValueName;
	UNICODE_STRING SubKeyName;

	UNICODE_STRING NullString;
    RtlInitUnicodeString( &NullString, NULL );

    //
    // Enumerate node
    //

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;
	for ( ULONG ValueIndex = 0; TRUE; ValueIndex++ )
	{
		ULONG ResultLength = 0L;
		Status = NtEnumerateValueKey	(	Key,
											ValueIndex,
											KeyValueFullInformation,
											KeyValueInformation,
											sizeof( Buffer ),
											&ResultLength
										);

		if ( Status == STATUS_NO_MORE_ENTRIES )
		{
			Status = STATUS_SUCCESS;
			break;
		}
		else
		if ( !NT_SUCCESS( Status ) )
		{
			break;
		}

		ValueName.Buffer = (PWSTR)&(KeyValueInformation->Name[0]);
		ValueName.Length = (USHORT)KeyValueInformation->NameLength;
		ValueName.MaximumLength = (USHORT)KeyValueInformation->NameLength;

		if ( KeyValueInformation->Type == REG_SZ )
		{
			BOOL Continue = TRUE;
			if ( MyApplicationName && MyVariableName )
			{
				if ( _wcsnicmp ( ValueName.Buffer, MyVariableName, ValueName.Length / sizeof ( WCHAR ) ) )
				{
					Continue = FALSE;
				}
			}

			if ( Continue )
			{
				if ( MappingAppNameAlloc ( FileNameMapping, &ValueName, &AppNameMapping ) )
				{
					if ( MappingVarNameAlloc	(	FileNameMapping,
													AppNameMapping,
													&NullString,
													(PWSTR)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset),
													&VarNameMapping
												)
					   )
					{
						if (ValueName.Length == 0)
						{
							VarNameMapping->MappingFlags |= REGISTRY_MAPPING_APPEND_APPLICATION_NAME;
						}
					}
				}
			}
		}
	}

    //
    // Enumerate node's children and apply ourselves to each one
    //

	KeyInformation = (PKEY_BASIC_INFORMATION)Buffer;
	for ( ULONG SubKeyIndex = 0; TRUE; SubKeyIndex++ )
	{
		ULONG ResultLength = 0L;
		Status = NtEnumerateKey	(	Key,
									SubKeyIndex,
									KeyBasicInformation,
									KeyInformation,
									sizeof( Buffer ),
									&ResultLength
								);

		if ( Status == STATUS_NO_MORE_ENTRIES)
		{
			Status = STATUS_SUCCESS;
			break;
		}
		else
		if ( !NT_SUCCESS ( Status ) )
		{
			break;
		}

		SubKeyName.Buffer = (PWSTR)&(KeyInformation->Name[0]);
		SubKeyName.Length = (USHORT)KeyInformation->NameLength;
		SubKeyName.MaximumLength = (USHORT)KeyInformation->NameLength;

		InitializeObjectAttributes (	&ObjectAttributes,
										&SubKeyName,
										OBJ_CASE_INSENSITIVE,
										Key,
										NULL
									);

		BOOL Continue = TRUE;
		if ( MyApplicationName )
		{
			if ( _wcsnicmp ( SubKeyName.Buffer, MyApplicationName, SubKeyName.Length / sizeof ( WCHAR ) ) )
			{
				Continue = FALSE;
			}
		}

		if ( Continue )
		{
			Status = NtOpenKey( &SubKeyHandle, GENERIC_READ, &ObjectAttributes );

			try
			{
				if ( NT_SUCCESS( Status ) && SubKeyHandle != INVALID_HANDLE_VALUE && MappingAppNameAlloc( FileNameMapping, &SubKeyName, &AppNameMapping ) )
				{
					KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;
					for ( ULONG ValueIndex = 0; AppNameMapping != NULL; ValueIndex++ )
					{
						Status = NtEnumerateValueKey	(	SubKeyHandle,
															ValueIndex,
															KeyValueFullInformation,
															KeyValueInformation,
															sizeof( Buffer ),
															&ResultLength
														);

						if ( Status == STATUS_NO_MORE_ENTRIES )
						{
							Status = STATUS_SUCCESS;
							break;
						}
						else
						if ( !NT_SUCCESS ( Status ) )
						{
							break;
						}

						ValueName.Buffer = (PWSTR)&(KeyValueInformation->Name[0]);
						ValueName.Length = (USHORT)KeyValueInformation->NameLength;
						ValueName.MaximumLength = (USHORT)KeyValueInformation->NameLength;

						BOOL ContinueValue = TRUE;
						if ( MyApplicationName && MyVariableName )
						{
							if ( _wcsnicmp ( ValueName.Buffer, MyVariableName, ValueName.Length / sizeof ( WCHAR ) ) )
							{
								ContinueValue = FALSE;
							}
						}

						if ( ContinueValue )
						{
							if ( KeyValueInformation->Type == REG_SZ )
							{
								MappingVarNameAlloc	(	FileNameMapping,
														AppNameMapping,
														&ValueName,
														(PWSTR)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset),
														&VarNameMapping
													);
							}
						}
					}

					NtClose( SubKeyHandle );
					SubKeyHandle = INVALID_HANDLE_VALUE;
				}
			}
			catch ( ... )
			{
				if ( SubKeyHandle && SubKeyHandle != INVALID_HANDLE_VALUE )
				{
					NtClose( SubKeyHandle );
					SubKeyHandle = INVALID_HANDLE_VALUE;
				}

				throw;
			}
		}
	}

    return Status;
}

DWORD	WMIRegistry_InitMapping	( PREGISTRY_PARAMETERS a )
{
    DWORD					Status			= ERROR_INVALID_PARAMETER;
    PREGISTRY_MAPPING_NAME	RegistryMapping = NULL;

	if ( a )
	{
		// prepare mapping
		a->Mapping = NULL;

		NTSTATUS NtStatus = STATUS_SUCCESS;

		PREGISTRY_MAPPING_NAME	DefaultFileNameMapping	= NULL;
		PREGISTRY_MAPPING_NAME	FileNames				= NULL;

		PREGISTRY_MAPPING_APPNAME AppNameMapping	= NULL;
		PREGISTRY_MAPPING_VARNAME VarNameMapping	= NULL;

		OBJECT_ATTRIBUTES ObjectAttributes;

		HANDLE IniFileMappingRoot	= INVALID_HANDLE_VALUE;

		PKEY_VALUE_PARTIAL_INFORMATION	KeyValueInformation	= NULL;
		PKEY_BASIC_INFORMATION			KeyInformation		= NULL;

		WCHAR Buffer[ 512 ];

		LPWSTR BaseFileName = NULL;
		Status = WMIREG_GetBaseFileName ( a->FileName, &BaseFileName );

		if ( Status == ERROR_SUCCESS && BaseFileName )
		{
			UNICODE_STRING	FullKeyName;

			FullKeyName.Length = 0;
			FullKeyName.MaximumLength = ( wcslen ( L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping\\" ) + wcslen ( BaseFileName ) + 1 ) * sizeof ( WCHAR );
			FullKeyName.Buffer = reinterpret_cast < PWSTR > ( RtlAllocateHeap( RtlProcessHeap(), 0, FullKeyName.MaximumLength ) );

			if ( FullKeyName.Buffer != NULL )
			{
				RtlAppendUnicodeToString ( &FullKeyName, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping\\" );
				RtlAppendUnicodeToString ( &FullKeyName, BaseFileName );

				InitializeObjectAttributes	(	&ObjectAttributes,
												&FullKeyName,
												OBJ_CASE_INSENSITIVE,
												NULL,
												NULL
											);

				NtStatus = NtOpenKey	(	&IniFileMappingRoot,
											GENERIC_READ,
											&ObjectAttributes
										);

				if ( NT_SUCCESS ( NtStatus ) && IniFileMappingRoot != INVALID_HANDLE_VALUE )
				{
					UNICODE_STRING BaseFile;
					RtlInitUnicodeString ( &BaseFile, BaseFileName );

					if ( ! MappingNameAlloc( &BaseFile, &FileNames ) )
					{
						NtStatus = STATUS_NO_MEMORY;
					}
					else
					{
						try
						{
							NtStatus = IniFileMapping( FileNames, IniFileMappingRoot, a->ApplicationName, a->VariableName );
						}
						catch ( ... )
						{
							MappingNameFree ( FileNames );
							FileNames = NULL;

							NtStatus = STATUS_NO_MEMORY;
						}

						if ( ! NT_SUCCESS ( NtStatus ) )
						{
							if ( FileNames )
							{
								RtlFreeHeap( RtlProcessHeap(), 0, FileNames );
								FileNames = NULL;
							}
						}
					}

					if ( NT_SUCCESS ( NtStatus ) )
					{
						a->Mapping = FileNames;
					}

					// close main root
					if ( IniFileMappingRoot && IniFileMappingRoot != INVALID_HANDLE_VALUE )
					{
						NtClose ( IniFileMappingRoot );
						IniFileMappingRoot = NULL;
					}
				}

				// clear buffer
				RtlFreeHeap ( RtlProcessHeap (), 0, FullKeyName.Buffer );
			}
			else
			{
				NtStatus = STATUS_NO_MEMORY;
			}

			// we are done with looking for 
			delete [] BaseFileName;
			BaseFileName = NULL;
		}

		// name has not found ( get ready for default )
		if ( NT_SUCCESS ( NtStatus ) && a->Mapping == NULL )
		{
			UNICODE_STRING	KeyName;
			RtlInitUnicodeString	(	&KeyName,
										L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping"
									);

			InitializeObjectAttributes	(	&ObjectAttributes,
											&KeyName,
											OBJ_CASE_INSENSITIVE,
											NULL,
											NULL
										);

			NtStatus = NtOpenKey	(	&IniFileMappingRoot,
										GENERIC_READ,
										&ObjectAttributes
									);

			if ( NT_SUCCESS ( NtStatus ) && IniFileMappingRoot != INVALID_HANDLE_VALUE )
			{
				ULONG ResultLength = 0L;

				UNICODE_STRING NullString;
				RtlInitUnicodeString( &NullString, NULL );

				UNICODE_STRING ValueName;
				RtlInitUnicodeString( &ValueName, NULL );

				NtStatus = NtQueryValueKey	(	IniFileMappingRoot,
												&ValueName,
												KeyValuePartialInformation,
												KeyValueInformation,
												sizeof( Buffer ),
												&ResultLength
											);

				try
				{
					if ( NT_SUCCESS ( NtStatus ) )
					{
						if ( MappingNameAlloc( &NullString, &DefaultFileNameMapping ) )
						{
							if ( MappingAppNameAlloc ( DefaultFileNameMapping, &NullString, &AppNameMapping ) )
							{
								if ( MappingVarNameAlloc ( DefaultFileNameMapping, AppNameMapping, &NullString, (PWSTR)(KeyValueInformation->Data), &VarNameMapping ) )
								{
									VarNameMapping->MappingFlags |= REGISTRY_MAPPING_APPEND_BASE_NAME | REGISTRY_MAPPING_APPEND_APPLICATION_NAME;

									// assign proper mapping
									a->Mapping = DefaultFileNameMapping;
								}
							}
						}
					}
				}
				catch ( ... )
				{
					MappingNameFree ( DefaultFileNameMapping );
					DefaultFileNameMapping = NULL;

					a->Mapping = NULL;

					NtStatus = STATUS_NO_MEMORY;
				}

				// close main root
				if ( IniFileMappingRoot && IniFileMappingRoot != INVALID_HANDLE_VALUE )
				{
					NtClose ( IniFileMappingRoot );
					IniFileMappingRoot = NULL;
				}
			}
		}

		if ( a->Mapping )
		{
			// return success
			Status = ERROR_SUCCESS;
		}
		else
		{
			if ( NT_SUCCESS ( NtStatus ) )
			{
				// we do not have mapping
				Status = STATUS_MORE_PROCESSING_REQUIRED;
			}
			else
			{
				Status = NtStatus;
			}
		}
	}

    return Status;
}

DWORD	WMIRegistry_ParametersInit	(
										#ifdef	WRITE_OPERATION
										BOOLEAN WriteOperation,
										#endif	WRITE_OPERATION

										REGISTRY_OPERATION Operation,
										BOOLEAN MultiValueStrings,

										LPCWSTR FileName,
										LPCWSTR	ApplicationName,
										LPCWSTR	VariableName,
										LPWSTR	VariableValue,
										PULONG ResultMaxChars,

										PREGISTRY_PARAMETERS *ReturnedParameterBlock
									)
{
    DWORD					Status	= ERROR_SUCCESS;
	PREGISTRY_PARAMETERS	a		= NULL;

	if ( ! ReturnedParameterBlock )
	{
		Status = ERROR_INVALID_PARAMETER;
	}

	if ( Status == ERROR_SUCCESS )
	{
		try
		{
			a = new REGISTRY_PARAMETERS();
			if ( a== NULL )
			{
				Status = ERROR_NOT_ENOUGH_MEMORY;
			}
		}
		catch ( ... )
		{
			if ( a )
			{
				delete a;
				a = NULL;
			}

			Status = ERROR_NOT_ENOUGH_MEMORY;
		}
	}

	if ( Status == ERROR_SUCCESS )
	{
		#ifdef	WRITE_OPERATION
		a->WriteOperation		= WriteOperation;
		#endif	WRITE_OPERATION

		a->ValueBufferAllocated	= FALSE;

		a->Operation			= Operation;
		a->MultiValueStrings	= MultiValueStrings;

		if ( FileName )
		{
			a->FileName = FileName;
		}
		else
		{
			a->FileName = L"win.ini";
		}

		// section name
		if ( ApplicationName )
		{
			a->ApplicationName = ApplicationName;
		}
		else
		{
			a->ApplicationName = NULL;
		}

		// key name
		if ( VariableName )
		{
			a->VariableName= VariableName;
		}
		else
		{
			a->VariableName= NULL;
		}

		Status = WMIRegistry_InitMapping ( a );
		if ( Status != ERROR_SUCCESS )
		{
			delete a;
			a = NULL;
		}
		else
		{
			// key value
			if ( VariableValue )
			{
				#ifdef	WRITE_OPERATION
				if (a->WriteOperation)
				{
					a->ValueBuffer	= VariableValue;
					a->ValueLength	= wcslen ( VariableValue );
				}
				else
				#endif	WRITE_OPERATION
				{
					if ( ResultMaxChars )
					{
						a->ResultMaxChars = *ResultMaxChars;
					}
					else
					{
						a->ResultMaxChars = 0;
					}

					a->ResultChars	= 0;
					a->ResultBuffer	= VariableValue;
				}
			}
			else
			{
				#ifdef	WRITE_OPERATION
				if ( a->WriteOperation )
				{
					a->ValueBuffer	= NULL;
					a->ValueLength	= 0;
				}
				else
				#endif	WRITE_OPERATION
				{
					a->ResultMaxChars	= 0;
					a->ResultChars		= 0;
					a->ResultBuffer		= NULL;
				}
			}
		}
	}

	if ( ReturnedParameterBlock )
	{
		*ReturnedParameterBlock = a;
	}

	return Status;
}

DWORD	WMIRegistry_ParametersClear	(
										PREGISTRY_PARAMETERS ParameterBlock
									)
{
    DWORD Status	= ERROR_SUCCESS;

	if ( ! ParameterBlock )
	{
		Status = ERROR_INVALID_PARAMETER;
	}

	if ( Status == ERROR_SUCCESS )
	{
		if ( ParameterBlock->Mapping )
		{
			MappingNameFree ( ParameterBlock->Mapping );
			ParameterBlock->Mapping = NULL;
		}

		delete ParameterBlock;
		ParameterBlock = NULL;
	}

	return Status;
}

///////////////////////////////////////////////////////////////////////////////
// read function
///////////////////////////////////////////////////////////////////////////////
DWORD	WMIRegistry	(
						#ifdef	WRITE_OPERATION
						IN BOOLEAN WriteOperation,
						#endif	WRITE_OPERATION

						IN BOOLEAN SectionOperation,
						IN LPCWSTR FileName,
						IN LPCWSTR ApplicationName,
						IN LPCWSTR VariableName,
						IN OUT LPWSTR VariableValue,
						IN OUT PULONG VariableValueLength
					)
{
	// variables
	DWORD				Status				= ERROR_INVALID_PARAMETER;
    REGISTRY_OPERATION	Operation			= Registry_None;
    BOOLEAN				MultiValueStrings	= FALSE;

	if ( SectionOperation )
	{
		VariableName = NULL;
	}

	if ( ApplicationName )
	{
		if ( VariableValue )
		{
			if ( VariableName )
			{
				Operation = Registry_ReadKeyValue;
			}
			else
			{
				if ( SectionOperation )
				{
					Operation = Registry_ReadSectionValue;
					MultiValueStrings = TRUE;
				}
				else
				{
					Operation = Registry_ReadKeyName;
					MultiValueStrings = TRUE;
				}
			}
		}
	}
	else
	{
		if ( ! ( SectionOperation || ! VariableValue ) )
		{
			Operation = Registry_ReadSectionName;
			MultiValueStrings = TRUE;
		}
	}

	// real operation
	if ( Operation != Registry_None )
	{
		PREGISTRY_PARAMETERS a = NULL;

		Status = WMIRegistry_ParametersInit	(
												#ifdef	WRITE_OPERATION
												WriteOperation,
												#endif	WRITE_OPERATION

												Operation,
												MultiValueStrings,
												FileName,
												ApplicationName,
												VariableName,
												VariableValue,
												VariableValueLength,
												&a
											);

		if ( Status == ERROR_SUCCESS )
		{
			if ( a->Mapping != NULL )
			{
				Status = WMIRegistry_Mapping( a );

				if ( Status == ERROR_SUCCESS || Status == ERROR_MORE_DATA )
				{
					if (	a->Operation == Registry_ReadKeyName ||
							a->Operation == Registry_ReadSectionName ||
							a->Operation == Registry_ReadSectionValue
					   )
					{
						REGISTRY_AppendNULLToResultBuffer ( a );
					}

					if ( VariableValueLength )
					{
						*VariableValueLength = a->ResultChars;
					}
				}
			}
			else
			{
				Status = ERROR_INVALID_PARAMETER;

				if ( VariableValueLength )
				{
					*VariableValueLength = 0;
				}
			}
		}

		WMIRegistry_ParametersClear ( a );
	}

	::SetLastError ( Status );
	return Status;
}

///////////////////////////////////////////////////////////////////////////////
// get profile string
///////////////////////////////////////////////////////////////////////////////
DWORD	APIENTRY	WMIRegistry_PrivateProfileString	(
															LPCWSTR	lpAppName,
															LPCWSTR	lpKeyName,
															LPCWSTR	lpDefault,
															LPWSTR	lpReturnedString,
															DWORD	nSize,
															LPCWSTR	lpFileName
														)
{
    DWORD Status	= ERROR_SUCCESS;
    ULONG n			= nSize;

    if ( lpDefault == NULL )
	{
        lpDefault = L"";
    }

    Status = WMIRegistry	(
								#ifdef	WRITE_OPERATION
								FALSE,		// Write operation
								#endif	WRITE_OPERATION

								FALSE,		// SectionOperation
								lpFileName,
								lpAppName,
								lpKeyName,
								lpReturnedString,
								&n
							);

	if ( n && ( Status == ERROR_SUCCESS || Status == STATUS_BUFFER_OVERFLOW ) )
	{
		if ( Status == ERROR_SUCCESS )
		{
			n--;
		}
		else
		{
			if ( !lpAppName || !lpKeyName )
			{
				if ( nSize >= 2 )
				{
					n = nSize - 2;
					lpReturnedString[ n+1 ] = L'\0';
				}
				else
				{
					n = 0;
				}
			}
			else
			{
				if ( nSize >= 1 )
				{
					n = nSize - 1;
				}
				else
				{
					n = 0;
				}
			}
		}
	}
	else
	{
		n = wcslen( lpDefault );
		while ( n > 0 && lpDefault[n-1] == L' ')
		{
			n -= 1;
		}

		if (n >= nSize)
		{
			n = nSize;
		}

		wcsncpy ( lpReturnedString, lpDefault, n );
	}

	if ( n < nSize )
	{
		lpReturnedString[ n ] = L'\0';
	} 
	else
	{
		if ( nSize > 0 )
		{
			lpReturnedString[ nSize-1 ] = L'\0';
		}
	}

	return n;
}

///////////////////////////////////////////////////////////////////////////////
// get profile section
///////////////////////////////////////////////////////////////////////////////
DWORD	APIENTRY	WMIRegistry_PrivateProfileSection	(
															LPCWSTR	lpAppName,
															LPWSTR	lpReturnedString,
															DWORD	nSize,
															LPCWSTR	lpFileName
														)
{
    NTSTATUS Status;
    ULONG n;

    n = nSize;
    Status = WMIRegistry	(
								#ifdef	WRITE_OPERATION
								FALSE,		// Write operation
								#endif	WRITE_OPERATION

								TRUE,		// SectionOperation
								lpFileName,
								lpAppName,
								NULL,
								lpReturnedString,
								&n
							);

	if ( Status == ERROR_SUCCESS || Status == STATUS_BUFFER_OVERFLOW )
	{
		if ( Status == ERROR_SUCCESS )
		{
			n--;
		}
		else
		{
			if ( nSize >= 2 )
			{
				n = nSize - 2;
				lpReturnedString[ n+1 ] = L'\0';
			}
			else
			{
				n = 0;
			}
		}
	}
	else
	{
		n = 0;
	}

	if ( n < nSize )
	{
		lpReturnedString[ n ] = L'\0';
	} 
	else
	{
		if ( nSize > 0 )
		{
			lpReturnedString[ nSize-1 ] = L'\0';
		}
	}

	return n;
}

///////////////////////////////////////////////////////////////////////////////
// get profile integer
///////////////////////////////////////////////////////////////////////////////
UINT	APIENTRY	WMIRegistry_PrivateProfileInt	(
														LPCWSTR lpAppName,
														LPCWSTR lpKeyName,
														INT nDefault
													)
{
    WCHAR ValueBuffer[ 256 ];

    ULONG ReturnValue	= nDefault;
    ULONG cb			= 0;

    cb = WMIRegistry_PrivateProfileString	(	lpAppName,
												lpKeyName,
												NULL,
												ValueBuffer,
												sizeof( ValueBuffer ) / sizeof( WCHAR ),
												NULL
											);
    if ( cb )
	{
		// convert value to integer
		_wtoi ( ValueBuffer );
    }

    return ReturnValue;
}

///////////////////////////////////////////////////////////////////////////////
// get profile integer caller
///////////////////////////////////////////////////////////////////////////////
UINT	APIENTRY	WMIRegistry_ProfileInt	(
												LPCWSTR lpAppName,
												LPCWSTR lpKeyName,
												INT nDefault
											)
{
    return( WMIRegistry_PrivateProfileInt	(	lpAppName,
												lpKeyName,
												nDefault
											)
          );
}

///////////////////////////////////////////////////////////////////////////////
// get profile section caller
///////////////////////////////////////////////////////////////////////////////
DWORD	APIENTRY	WMIRegistry_ProfileSection	(
													LPCWSTR lpAppName,
													LPWSTR lpReturnedString,
													DWORD nSize
												)
{
    return( WMIRegistry_PrivateProfileSection	(	lpAppName,
													lpReturnedString,
													nSize,
													NULL
												)
          );
}

///////////////////////////////////////////////////////////////////////////////
// get profile string caller
///////////////////////////////////////////////////////////////////////////////
DWORD	APIENTRY	WMIRegistry_ProfileString	(
													LPCWSTR lpAppName,
													LPCWSTR lpKeyName,
													LPCWSTR lpDefault,
													LPWSTR lpReturnedString,
													DWORD nSize
												)
{
    return( WMIRegistry_PrivateProfileString	(	lpAppName,
													lpKeyName,
													lpDefault,
													lpReturnedString,
													nSize,
													NULL
												)
          );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\refptrlite.h ===
//=================================================================

//

// ThreadBase.h - Definition of Referenced Pointer class

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/15/97    Created
//
//=================================================================

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __REFPTRLITE_H__
#define __REFPTRLITE_H__

class CRefPtrLite
{
public:

	// Construction/Destruction
	CRefPtrLite();
	virtual ~CRefPtrLite();

	// Ref/Counting functions
	LONG	AddRef( void );
	LONG	Release( void );

protected:

	virtual void	OnFinalRelease( void );

private:

	LONG					m_lRefCount;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\refptr.h ===
//

// RefPtr.h -- definition of TRefPtr template

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//
//=================================================================

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __TREFPTR_H__
#define __TREFPTR_H__

#include <chptrarr.h>

// Enumeration helpers
typedef	DWORD	REFPTR_POSITION;
#define	REFPTR_START	0xFFFFFFFF;

template <class TYPED_PTR> class TRefPtr
{
public:

	// Construction/Destruction
	TRefPtr();
	~TRefPtr();

	// Allows addition and enumeration of collection
	BOOL	Add( TYPED_PTR* ptr );
    BOOL    Remove( DWORD dwElement );

	BOOL		BeginEnum( REFPTR_POSITION& pos );
	TYPED_PTR*	GetNext( REFPTR_POSITION& pos );
	void		EndEnum( void );

	// Allows for direct access
	TYPED_PTR*	GetAt( DWORD dwElement );
	void		Empty( void );
	DWORD		GetSize( void );

	const TRefPtr<TYPED_PTR>& Append( const TRefPtr<TYPED_PTR>& );

protected:

	// Allows easy and quick transference of data (it was =, but
	// because we'll inherit classes off the template, we won't
	// inherit that particular overload (some C++ thingie)

	const TRefPtr<TYPED_PTR>& Copy( const TRefPtr<TYPED_PTR>& );


private:

	CHPtrArray		m_ptrArray;

};

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::TRefPtr
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TRefPtr<TYPED_PTR>::TRefPtr( void ):	m_ptrArray()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPtr::~CRefPtr
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TRefPtr<TYPED_PTR>::~TRefPtr( void )
{
	Empty();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::Add
//
//	Adds a new referenced pointer to the collection.
//
//	Inputs:		T*				ptr - Pointer to add.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE		Success/Failure of Add.
//
//	Comments:	AddRefs the pointer, then adds it to the array.  We
//				will need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPtr<TYPED_PTR>::Add( TYPED_PTR* ptr )
{
	BOOL	fReturn = FALSE;

	if ( NULL != ptr )
	{
		if ( m_ptrArray.Add( (void*) ptr ) >= 0 )
		{
			// Corresponding Release() is in Empty().
			ptr->AddRef();
			fReturn = TRUE;
		}
	}

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::Remove
//
//	Removes an element based on an index.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE		Success/Failure of remove.
//
//	Comments:	
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPtr<TYPED_PTR>::Remove( DWORD dwElement )
{
	BOOL	fReturn = FALSE;
	TYPED_PTR*	ptr = NULL;

	if ( dwElement < m_ptrArray.GetSize() )
	{
		ptr = (TYPED_PTR*) m_ptrArray[dwElement];

		if ( NULL != ptr )
		{
			// Clean up our pointer
			ptr->Release();
		}

		m_ptrArray.RemoveAt( dwElement );
		fReturn = TRUE;
	}

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::BeginEnum
//
//	Gains Read Access to the collection, then returns an appropriate
//	REFPTR_POSITION to get the first index in the array.
//
//	Inputs:		None.
//
//	Outputs:	REFPTR_POSITION&	pos - Position we retrieved.
//
//	Return:		BOOL		TRUE/FALSE - Access was granted
//
//	Comments:	We need Read Access to do this.  This can effectively
//				lock out other threads.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPtr<TYPED_PTR>::BeginEnum( REFPTR_POSITION& pos )
{
	BOOL	fReturn	=	FALSE;

	pos = REFPTR_START;
	fReturn = TRUE;
	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::EndEnum
//
//	Signals the end of an enumeration.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	Place Holder should we make Begin do something that
//				needs cleaning up.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
void TRefPtr<TYPED_PTR>::EndEnum( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::GetNext
//
//	Uses the REFPTR_POSITION to get the next index in the
//	collection.
//
//	Inputs:		None.
//
//	Outputs:	REFPTR_POSITION&	pos - Position we retrieved.
//
//	Return:		T*		NULL if failure.
//
//	Comments:	We need Read Access to do this.  The pointer is AddRef'd
//				on the way out.  User must Release the pointer himself.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TYPED_PTR* TRefPtr<TYPED_PTR>::GetNext( REFPTR_POSITION& pos )
{
	TYPED_PTR*	ptr = NULL;

	if ( ++pos < (DWORD) m_ptrArray.GetSize() )
	{
		ptr = (TYPED_PTR*) m_ptrArray.GetAt( pos );

		if ( NULL != ptr )
		{
			ptr->AddRef();
		}
	}


	return ptr;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::GetAt
//
//	Gets at the requested member of the device list.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		T*		NULL if failure.
//
//	Comments:	We need Read Access to do this.  The pointer is AddRef'd
//				on the way out.  User must Release the pointer himself.
//
////////////////////////////////////////////////////////////////////////
template <class TYPED_PTR>
TYPED_PTR*	TRefPtr<TYPED_PTR>::GetAt( DWORD dwElement )
{
	TYPED_PTR*	ptr = NULL;

	if ( dwElement < m_ptrArray.GetSize() )
	{
		ptr = (TYPED_PTR*) m_ptrArray.GetAt( dwElement );

		if ( NULL != ptr )
		{
			ptr->AddRef();
		}
	}

	return ptr;
}


////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::Empty
//
//	Empties out the collection, Releasing Pointers as it does do.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
void TRefPtr<TYPED_PTR>::Empty( void )
{
	// By default this is an infinite wait, so it best come back

    int				nSize	=	m_ptrArray.GetSize();

	// Only empty it if it is not empty
	if ( nSize > 0 )
	{
		TYPED_PTR*	ptr		=	NULL;

		for ( int nCtr = 0; nCtr < nSize; nCtr++ )
		{
			ptr = (TYPED_PTR*) m_ptrArray[nCtr];

			if ( NULL != ptr )
			{
				// Clean up our pointers (not AddRef/Releasing so delete)
				ptr->Release();
			}
		}

		// Now dump the array
		m_ptrArray.RemoveAll();

	}	// IF nSize > 0
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::GetSize
//
//	Returns the size of the collection
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		DWORD	Number of elements
//
//	Comments:	We need Read Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
DWORD TRefPtr<TYPED_PTR>::GetSize( void )
{
    return m_ptrArray.GetSize();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::Copy
//
//	Empties out the collection, copies in another one, addrefing
//	pointers as we go.
//
//	Inputs:		const T&	collection
//
//	Outputs:	None.
//
//	Return:		const T&	this
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
const TRefPtr<TYPED_PTR>& TRefPtr<TYPED_PTR>::Copy( const TRefPtr<TYPED_PTR>& collection )
{
	// Dump out the array
	Empty();

	int	nSize = collection.m_ptrArray.GetSize();

	for ( int nCount = 0; nCount < nSize; nCount++ )
	{
		TYPED_PTR*	ptr = (TYPED_PTR*) collection.m_ptrArray[nCount];

		// Add will automatically AddRef the pointer again.
		Add( ptr );
	}

	return *this;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::Append
//
//	Appends the supplied collection to this one.
	//
//	Inputs:		const T&	collection
//
//	Outputs:	None.
//
//	Return:		const T&	this
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
const TRefPtr<TYPED_PTR>& TRefPtr<TYPED_PTR>::Append( const TRefPtr<TYPED_PTR>& collection )
{

	int	nSize = collection.m_ptrArray.GetSize();

	for ( int nCount = 0; nCount < nSize; nCount++ )
	{
		TYPED_PTR*	ptr = (TYPED_PTR*) collection.m_ptrArray[nCount];

		// Add will automatically AddRef the pointer again.
		Add( ptr );
	}

	return *this;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\resourcedesc.cpp ===
/////////////////////////////////////////////////////////////////////////

//

//  ResourceDesc.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    10/15/97        Sanj        Created by Sanj
//              10/17/97        jennymc     Moved things a tiny bit
//
/////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "refptr.h"
#include "poormansresource.h"

#include "resourcedesc.h"
#include "cfgmgrdevice.h"

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceDescriptor::CResourceDescriptor
//
//	Class Constructor.
//
//	Inputs:		PPOORMAN_RESDESC_HDR	pResDescHdr - Resource Descriptor
//										header used to get resource info
//										plus the raw bytes following.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CResourceDescriptor::CResourceDescriptor(	PPOORMAN_RESDESC_HDR	pResDescHdr,
											CConfigMgrDevice*		pOwnerDevice )
:	CRefPtrLite(),
	m_pbResourceDescriptor( NULL ),
	m_dwResourceSize( 0 ),
	m_dwResourceId( 0 ),
	m_pOwnerDevice( pOwnerDevice )
{
	// At least try to validate the pointer first

	if ( NULL != pResDescHdr )
	{
		m_dwResourceSize = pResDescHdr->dwResourceSize;

		if ( 0 != m_dwResourceSize )
		{
			m_dwResourceId = pResDescHdr->dwResourceId;

			// Now axe the size of the resource descriptor, since we have
			// stored the necessary information therein.
			m_dwResourceSize -= SIZEOF_RESDESC_HDR;

			BYTE*	pbData = new BYTE[m_dwResourceSize];

			if ( NULL != pbData )
			{
				// The header tells us how long the block of data including the
				// header is.

                try
                {
				    CopyMemory( pbData, ( ( (PBYTE) pResDescHdr ) + SIZEOF_RESDESC_HDR ), m_dwResourceSize );
                }
                catch ( ... )
                {
                    delete [] pbData;
                    throw ;
                }

				// A derived class will interpret the raw bytes pointed to by this
				// value.

				m_pbResourceDescriptor = pbData;
			}
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }


		}	// IF 0 != m_dwSizeOfData

	}	// IF NULL != pResDescHdr

	// AddRef the owner device
	if ( NULL != m_pOwnerDevice )
	{
		m_pOwnerDevice->AddRef();
	}
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceDescriptor::CResourceDescriptor
//
//	Class Constructor.
//
//	Inputs:		DWORD					dwResourceId - Type of Resource
//				LPVOID					pResource - Data Buffer containing
//										resource specific data.
//				DWORD					dwResourceSize - Size of Buffer
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CResourceDescriptor::CResourceDescriptor(	DWORD					dwResourceId,
											LPVOID					pResource,
											DWORD					dwResourceSize,
											CConfigMgrDevice*		pOwnerDevice )
:	CRefPtrLite(),
	m_pbResourceDescriptor( NULL ),
	m_dwResourceSize( dwResourceSize ),
	m_dwResourceId( dwResourceId ),
	m_pOwnerDevice( pOwnerDevice )
{

	if	(	0		!=	m_dwResourceSize
		&&	NULL	!=	pResource			)
	{
		BYTE*	pbData = new BYTE[m_dwResourceSize];

		if ( NULL != pbData )
		{
			// The header tells us how long the block of data including the
			// header is.

			CopyMemory( pbData, pResource, m_dwResourceSize );

			// A derived class will interpret the raw bytes pointed to by this
			// value.

			m_pbResourceDescriptor = pbData;

		}	// IF NULL != pbData

	}	// IF 0 != m_dwResourceSize && pResource

	// AddRef the owner device
	if ( NULL != m_pOwnerDevice )
	{
		m_pOwnerDevice->AddRef();
	}

}

CResourceDescriptor::CResourceDescriptor( const CResourceDescriptor& resource )
:	CRefPtrLite(),
	m_pbResourceDescriptor( NULL ),
	m_dwResourceSize( 0 ),
	m_dwResourceId( 0 ),
	m_pOwnerDevice( NULL )
{
	m_dwResourceSize = resource.m_dwResourceSize;
	m_dwResourceId = resource.m_dwResourceId;
	m_pbResourceDescriptor = new BYTE[m_dwResourceSize];

	if ( NULL != m_pbResourceDescriptor )
	{
		CopyMemory( m_pbResourceDescriptor, resource.m_pbResourceDescriptor, m_dwResourceSize );
	}

	m_pOwnerDevice = resource.m_pOwnerDevice;

	// AddRef the owner device
	if ( NULL != m_pOwnerDevice )
	{
		m_pOwnerDevice->AddRef();
	}

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceDescriptor::~CResourceDescriptor
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CResourceDescriptor::~CResourceDescriptor( void )
{
	if ( NULL != m_pbResourceDescriptor )
	{
		delete [] m_pbResourceDescriptor;
	}

	// Owner device should be released now.
	if ( NULL != m_pOwnerDevice )
	{
		m_pOwnerDevice->Release();
	}

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceDescriptor::GetResource()
//
//	Returns a string representation of the associated resource value.
//	This value may be a number, a range or whatever the overriding
//	implementation returns.
//
//	Inputs:		None.
//
//	Outputs:	CHString&		str - Storage for string.
//
//	Return:		None.
//
//	Comments:	Derived classes MUST implement this function to get
//				a useful value.  This base implementation just empties
//				the string.
//
////////////////////////////////////////////////////////////////////////

void *CResourceDescriptor::GetResource()
{
	return NULL;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceDescriptor::GetOwnerHardwareKey
//
//	Queries the owner device for its hardware key.
//
//	Inputs:		None.
//
//	Outputs:	CHString&		str - Storage for string.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

BOOL CResourceDescriptor::GetOwnerHardwareKey( CHString& str )
{
	BOOL	fReturn = ( NULL != m_pOwnerDevice );

	if ( NULL != m_pOwnerDevice )
	{
		str = m_pOwnerDevice->GetHardwareKey();
	}

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceDescriptor::GetOwnerDeviceID
//
//	Queries the owner device for its Device ID
//
//	Inputs:		None.
//
//	Outputs:	CHString&		str - Storage for string.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

BOOL CResourceDescriptor::GetOwnerDeviceID( CHString& str )
{
	BOOL	fReturn = ( NULL != m_pOwnerDevice );

	if ( NULL != m_pOwnerDevice )
	{
		fReturn = m_pOwnerDevice->GetDeviceID( str );
	}

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceDescriptor::GetOwnerName
//
//	Queries the owner device for its Name (DeviceDesc).
//
//	Inputs:		None.
//
//	Outputs:	CHString&		str - Storage for string.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

BOOL CResourceDescriptor::GetOwnerName( CHString& str )
{
	BOOL	fReturn = ( NULL != m_pOwnerDevice );

	if ( NULL != m_pOwnerDevice )
	{
		fReturn = m_pOwnerDevice->GetDeviceDesc( str );
	}

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceDescriptor::GetOwner
//
//	Returns an AddRef'd pointer to the owner device
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		CConfigMgrDevice*	NULL if no pointer
//
//	Comments:	Caller MUST call release on the returned
//				pointer.
//
////////////////////////////////////////////////////////////////////////

CConfigMgrDevice *CResourceDescriptor::GetOwner( void )
{
	if ( NULL != m_pOwnerDevice )
	{
		m_pOwnerDevice->AddRef();
	}

	return m_pOwnerDevice;
}

//
//	Constructor and Destructor for the Resource Descriptor Collection
//	object.
//

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceCollection::CResourceCollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CResourceCollection::CResourceCollection( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceCollection::~CResourceCollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CResourceCollection::~CResourceCollection( void )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\resourcedesc.h ===
/////////////////////////////////////////////////////////////////////////

//

//  resourcedesc.h    

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    10/15/97        Sanj        Created by Sanj     
//              10/17/97        jennymc     Moved things a tiny bit
//  
/////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCEDESC_H__
#define __RESOURCEDESC_H__
#include "refptr.h"
#include "refptrlite.h"

#define	ResType_DeviceMgr_Ignored_Bit	0x00000040	// Don't know the exact reason for this but Device manager ignores them, so we will also ignore.

// Forward Class Definitions
class CConfigMgrDevice;

class 
__declspec(uuid("CD545F0E-D350-11d2-B35E-00104BC97924")) 
CResourceDescriptor : public CRefPtrLite
{
	
public:

	// Construction/Destruction
	CResourceDescriptor( PPOORMAN_RESDESC_HDR pResDescHdr, CConfigMgrDevice* pDevice );
	CResourceDescriptor( DWORD dwResourceId, LPVOID pResource, DWORD dwResourceSize, CConfigMgrDevice* pOwnerDevice );\
	CResourceDescriptor( const CResourceDescriptor& resource );
	~CResourceDescriptor();

	// Must be overridden by derived class, since we will only know
	// about the resource header.  From there, we assume that a class
	// derived off of us knows what to do with the remainder (if any)
	// of the data.

	virtual void * GetResource();

	BOOL	GetOwnerDeviceID( CHString& str );
	BOOL	GetOwnerHardwareKey( CHString& str );
	BOOL	GetOwnerName( CHString& str );
	CConfigMgrDevice*	GetOwner( void );

	DWORD	GetOEMNumber( void );
	DWORD	GetResourceType( void );
	BOOL	IsIgnored( void );

protected:

	BYTE*	m_pbResourceDescriptor;
	DWORD	m_dwResourceSize;

private:

	DWORD				m_dwResourceId;
	CConfigMgrDevice*	m_pOwnerDevice;
};

_COM_SMARTPTR_TYPEDEF(CResourceDescriptor, __uuidof(CResourceDescriptor));

inline DWORD CResourceDescriptor::GetOEMNumber( void )
{
	return ( m_dwResourceId & OEM_NUMBER_MASK );
}

inline DWORD CResourceDescriptor::GetResourceType( void )
{
	return ( m_dwResourceId & RESOURCE_TYPE_MASK );
}

inline BOOL CResourceDescriptor::IsIgnored( void )
{
	return ( (m_dwResourceId & ResType_Ignored_Bit) || (m_dwResourceId & ResType_DeviceMgr_Ignored_Bit) );
}

// A collection of Resource Descriptors
class CResourceCollection : public TRefPtr<CResourceDescriptor>
{
public:

	// Construction/Destruction
	CResourceCollection();
	~CResourceCollection();

	// Because we're inheriting, we need to declare this here
	// (= operator is not inherited).

	const CResourceCollection& operator = ( const CResourceCollection& srcCollection );

};

inline const CResourceCollection& CResourceCollection::operator = ( const CResourceCollection& srcCollection )
{
	// Call into the templated function
	Copy( srcCollection );
	return *this;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\resourcemanager.h ===
//=================================================================
//
// ResourceManager.h
//
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __RESOURCEMANAGER_H__
#define __RESOURCEMANAGER_H__
#include <windows.h>
#include <list>
#include <BrodCast.h>
#include <fwcommon.h>
#include <assertbreak.h>
#include <ccriticalsec.h>
#include <helper.h>

#define DUPLICATE_RELEASE FALSE

class CResourceManager ;
class CResourceList ;
class CResource ;
class CRule ;
class CBinaryRule ;
class CAndRule ;
class COrRule ;

typedef CResource* (*PFN_RESOURCE_INSTANCE_CREATOR) ( PVOID pData ) ;

class CResourceList
{
friend class CResourceManager ;

protected:

	CResource* GetResource ( LPVOID pData ) ;
	ULONG ReleaseResource ( CResource* pResource ) ;
	void ShutDown () ;

protected:

	typedef std::list<CResource*>  tagInstances ;
	tagInstances m_Instances ;	
	PFN_RESOURCE_INSTANCE_CREATOR m_pfnInstanceCreator ;
	GUID guidResourceId ;
	
	CCriticalSec m_csList ; 

public:	

	CResourceList () ;
	~CResourceList () ;

	void RemoveFromList ( CResource* pResource ) ;

	BOOL LockList(){ m_csList.Enter(); return TRUE; };
	BOOL UnLockList(){ m_csList.Leave(); return TRUE; };
public:

	BOOL m_bShutDown ;
} ;

class CResourceListAutoLock
{
	CResourceList* resourcelist ;
	BOOL bLocked ;

	public:

	CResourceListAutoLock ( CResourceList* list ) :
		resourcelist ( list ),
		bLocked ( FALSE )
	{
		if ( resourcelist )
		{
			bLocked = resourcelist->LockList () ;
		}
	}

	~CResourceListAutoLock ()
	{
		if ( bLocked )
		{
			resourcelist->UnLockList () ;
		}
	}
};



class CResourceManager 
{
protected:

	std::list < CResourceList* > m_Resources ;
	CStaticCritSec m_csResourceManager ;

public:

	CResourceManager () ;
	~CResourceManager () ;

	CResource* GetResource ( GUID ResourceId, LPVOID pData ) ;
	ULONG ReleaseResource ( GUID ResourceId, CResource* pResource ) ;	

	BOOL AddInstanceCreator ( GUID ResourceId, PFN_RESOURCE_INSTANCE_CREATOR pfnResourceInstanceCreator ) ;
	void CResourceManager :: ForcibleCleanUp () ;

	static CResourceManager sm_TheResourceManager ;
};


typedef OnDeleteObj2< GUID, CResource* ,
	                            CResourceManager,
	                            ULONG (CResourceManager:: *)(GUID, CResource*), 
	                            &CResourceManager::ReleaseResource >                    CRelResource;

class CResource
{
protected:

	CRule *m_pRules ;
	CResourceList *m_pResources ; //pointer to container
	LONG m_lRef ;

protected:

	virtual BOOL OnAcquire ()			{ return TRUE ; } ;
	virtual BOOL OnRelease ()			{ return TRUE ; } ;
	virtual BOOL OnInitialAcquire ()	{ return TRUE ; } ;
	virtual BOOL OnFinalRelease()		{ return TRUE ; } ;

	BOOL	m_bValid;
	DWORD	m_dwCreationError;

public:

	CResource () ;
	virtual ~CResource () ;

	virtual void RuleEvaluated ( const CRule *a_RuleEvaluated ) = 0;


	BOOL Acquire () ;
	ULONG Release () ;
	void SetParent ( CResourceList *pList ) { m_pResources = pList ; }

	virtual BOOL IsOneOfMe ( LPVOID pData ) { return TRUE ; } 

	virtual BOOL	IsValid ( )				{ return m_bValid; }
	virtual DWORD	GetCreationError ( )	{ return m_dwCreationError; }
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//													Rules
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CRule
{
protected:	

	CResource* m_pResource ;
	LONG m_lRef ;

public:

	CRule ( CResource* pResource ) : m_pResource ( pResource ), m_lRef ( 0 ) {}
	virtual ~CRule () {} ;
	
	virtual ULONG AddRef () 
	{
		return ( InterlockedIncrement ( &m_lRef ) ) ;
	}
	
	virtual ULONG Release () 
	{
		LONG lCount ;

		lCount = InterlockedDecrement ( &m_lRef );
		try
		{
			if (IsVerboseLoggingEnabled())
			{
				LogMessage2(L"CRule::Release, count is (approx) %d", m_lRef);
			}
		}
		catch ( ... )
		{
		}

		if ( lCount == 0 )
		{
		   try
		   {
				LogMessage(L"CRule Ref Count = 0");
		   }
		   catch ( ... )
		   {
		   }
		   delete this;
		}
		else if (lCount > 0x80000000)
		{
			ASSERT_BREAK(DUPLICATE_RELEASE);
			LogErrorMessage(L"Duplicate CRule Release()");
		}

		return lCount ;
	}

	virtual void Detach ()
	{
		if ( m_pResource )
		{
			m_pResource = NULL ;
		}
	}

	//Checkrule returns true if rule is satisfied
	virtual BOOL CheckRule () { return FALSE ; } 
} ;


#endif //__RESOURCEMANAGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\resourcemanager.cpp ===
//=================================================================
//
// ResourceManager.cpp
//
//  Copyright (c) 1998-2002 Microsoft Corporation, All Rights Reserved
//
//=================================================================

/*
 * Currently  the implementations of std::_Lockit::_Lockit() are in framedyn.dll
 * If this class is being used outside the scope of win32providers then an implementation of std::_Lockit::_Lockit() has to be provided
 * by the client ( I think!) .
 */

#include "precomp.h"

#include <assertbreak.h>
#include "ResourceManager.h"
#include "ProvExce.h"
#include <comdef.h>
#include "TimerQueue.h"

// automatic crit sec
#include "cautolock.h"

//
// resource management failures
//
BOOL bAddInstanceCreatorFailure = FALSE ;

//initialize statics
/*
 * All the resources not released by clients or cached in the ResourceManager are forcibly freed in the ResourceManager destructor.
 * When a resource is freed , the resource tries to deregister the timeout rule from the TimerQueue, which means that the TimerQueue
 * has to be present when the ResourceManager destructor is fired,else we'll have a crash on Win9x. --RAID 50454
 */
//CTimerQueue CTimerQueue :: s_TimerQueue ;
//CResourceManager CResourceManager::sm_TheResourceManager ;

CResourceManager :: CResourceManager ()
{
}

CResourceManager :: ~CResourceManager ()
{
	std::list < CResourceList* >::iterator pInstanceList ;
/*
 * Ideally, at this point of time when the global destructors get fired there should not be any resources in the resource manager,
 * but if there are any , we've to forcibly delete them. We're safe in doing this becuase the scheduler thread would've exited already
 * in DllCanUnloadNow & no other thread would be calling into the resource manager
 */
	LogMessage ( L"Entering ~CResourceManager" ) ;

	CAutoLock cs ( m_csResourceManager ) ;
	while ( !m_Resources.empty () )
	{
		delete m_Resources.front() ;
		m_Resources.pop_front() ;
	}
	cs.Exec () ;
	LogMessage ( L"Leaving ~CResourceManager" ) ;
}


/*
 * This method checks if we've any resource leak
 */
void CResourceManager :: ForcibleCleanUp ()
{
	LogMessage ( L"Entering CResourceManager :: ForcibleCleanUp" ) ;
	std::list < CResourceList* >::iterator pInstanceList ;

	CAutoLock cs ( m_csResourceManager ) ;
	for ( pInstanceList = m_Resources.begin () ; pInstanceList != m_Resources.end () ; pInstanceList++ )
	{
		 ( *pInstanceList )->ShutDown () ;
	}
	cs.Exec () ;
	LogMessage  ( L"Leaving CResourceManager :: ForcibleCleanUp" ) ;
}

CResource* CResourceManager :: GetResource ( GUID ResourceId, PVOID pData )
{
	std::list < CResourceList* >::iterator pInstanceList ;
	for ( pInstanceList = m_Resources.begin () ; pInstanceList != m_Resources.end () ; pInstanceList++ )
	{
		if ( IsEqualGUID ( (*pInstanceList)->guidResourceId, ResourceId ) )
		{
			return (*pInstanceList)->GetResource ( pData ) ;
		}
	}
	return NULL ;
}

ULONG CResourceManager :: ReleaseResource ( GUID ResourceId, CResource* pResource )
{
	std::list < CResourceList* >::iterator pInstanceList ;
	for ( pInstanceList = m_Resources.begin () ; pInstanceList != m_Resources.end () ; pInstanceList++ )
	{
		if ( IsEqualGUID ( (*pInstanceList)->guidResourceId, ResourceId ) )
		{
			return (*pInstanceList)->ReleaseResource ( pResource ) ;
		}
	}
	return ULONG ( -1 )  ;
}

BOOL CResourceManager :: AddInstanceCreator ( GUID ResourceId, PFN_RESOURCE_INSTANCE_CREATOR pfnResourceInstanceCreator )
{
	CAutoLock cs ( m_csResourceManager ) ;

	//create a node & add it
	CResourceList *stResourceInstances = new CResourceList ;
	if ( stResourceInstances == NULL )
	{
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}
	stResourceInstances->guidResourceId = ResourceId ;
	stResourceInstances->m_pfnInstanceCreator = pfnResourceInstanceCreator ;
	m_Resources.push_back ( stResourceInstances ) ;

	return TRUE ;
}


CResourceList :: CResourceList ()
{
	m_bShutDown = FALSE ;	
}

CResourceList :: ~CResourceList ()
{
	m_bShutDown = TRUE ;
	ShutDown () ;	
}

CResource* CResourceList :: GetResource ( LPVOID pData )
{
	CResource* pTmpInstance = NULL ;
	tagInstances::iterator ppInstance ;
	BOOL bRet ;

	//check if we're shutting down
	if ( m_bShutDown )
	{
		return NULL ;
	}

	//Lock the list
	CResourceListAutoLock cs ( this ) ;

	//check if we're shutting down
	if ( m_bShutDown )
	{
		return NULL ;
	}

	try
	{
		//go thru all the instances of this resource & hand out the first valid one
		for ( ppInstance  = m_Instances.begin(); ppInstance != m_Instances.end (); ppInstance++ )
		{
			//Check out if we've cached a similar instance
			if ( ( *ppInstance )->IsOneOfMe ( pData ) )
			{
				//try to acquire the resource...this will up the refcount.
				bRet = ( *ppInstance )->Acquire () ;

				if ( bRet )
				{
					pTmpInstance = *ppInstance ;
					break ;		//got the instance so break
				}
			}
		}

		//if we haven't got a cached instance to hand out, create a new instance
		if ( !pTmpInstance )
		{
			//this will create a new instance but the ref-count is still zero
			pTmpInstance = m_pfnInstanceCreator ( pData ) ;

			//Try to acquire the instance for the client ..which will up the ref-count
			if ( pTmpInstance )
			{
				if ( pTmpInstance->IsValid () )
				{
					pTmpInstance->SetParent ( this ) ;
					bRet = pTmpInstance->Acquire () ;

					//if the acquire succeeded on the instance, add it to our list of cached instances
					if ( bRet )
					{
						m_Instances.insert ( m_Instances.begin (), pTmpInstance ) ;
					}
					else
					{
						delete pTmpInstance ;
						pTmpInstance = NULL ;
					}
				}
				else
				{
					// set creation error as they can look for it
					::SetLastError ( pTmpInstance->GetCreationError () );

					delete pTmpInstance ;
					pTmpInstance = NULL ;
				}
			}
		}
	}
	catch ( ... )
	{
		if ( pTmpInstance )
		{
			delete pTmpInstance ;
			pTmpInstance = NULL ;
		}

		throw ;
	}

	return pTmpInstance ;
}

ULONG CResourceList :: ReleaseResource ( CResource* pResource )
{
	CResource* pTmpInstance = NULL ;
	tagInstances::iterator ppInstance ;
	LONG lCount = -1 ;

	//check if we're shutting down
	if ( m_bShutDown )
	{
		return NULL ;
	}


	//Lock the list
	CResourceListAutoLock cs ( this ) ;

	//check if we're shutting down
	if ( m_bShutDown )
	{
		return lCount ;
	}

	//Go thru the list & release the resource
	for ( ppInstance  = m_Instances.begin(); ppInstance != m_Instances.end (); ppInstance++ )
	{
		if ( *ppInstance == pResource )
		{
			lCount = pResource->Release () ;
			break ;
		}
	}
	return lCount ;
}

//This function will be called by the CResource to remove it's entry from the list of instances. The resource should have a
//lock on the list before it attempts to do this
void CResourceList :: RemoveFromList ( CResource* pResource )
{
	tagInstances::iterator ppInstance ;

	//Go thru the list & remove the link to the resource
	for ( ppInstance  = m_Instances.begin(); ppInstance != m_Instances.end (); ppInstance++ )
	{
		if ( *ppInstance == pResource )
		{
			m_Instances.erase ( ppInstance ) ;
			break ;
		}
	}
}

void CResourceList :: ShutDown ()
{
	CResourceListAutoLock cs ( this ) ;

	LPOLESTR t_pOleStr = NULL ;
	CHString t_chsListGuid ;
	if ( StringFromCLSID ( guidResourceId , &t_pOleStr ) == S_OK )
	{
		t_chsListGuid = t_pOleStr ;
		CoTaskMemFree ( t_pOleStr ) ;
	}

	tagInstances::iterator ppInstance ;

	//Go thru the list & remove the link to the resource
	while ( !m_Instances.empty () )
	{
#if (defined DEBUG || defined _DEBUG)
        // Note that this COULD be because there is a timer rule, and the time hasn't expired
        // before the DllCanUnloadNow function is called by com (that's who calls this function).
		LogErrorMessage3 ( L"%s%s" , L"Resource not released before shutdown = " , t_chsListGuid ) ;
#endif
		m_Instances.pop_front() ;
	}
}

CResource :: CResource () :
m_bValid ( TRUE ),
m_dwCreationError ( ERROR_SUCCESS )
{
	m_pRules = NULL ;
	m_lRef = 0 ;
	m_pResources = NULL ;
}

CResource :: ~CResource ()
{
}

//This function increments ref-count of the object & calls into the virtual overridables OnAcquire or OnInitialAcquire
//The derived class should override these functions if it wants to & decrement the ref-count if it wants the Acquire
//operation to fail
BOOL CResource::Acquire ()
{
	BOOL bRet ;
	++m_lRef ;
	if ( m_lRef == 1 )
	{
		bRet = OnInitialAcquire () ;
	}
	else
	{
		bRet = OnAcquire () ;
	}

	if ( m_lRef == 0 )
	{
		m_pResources->RemoveFromList ( this ) ;
		if ( m_pRules )
		{
			//since we're going away, we detach ourselves from the rule so that the rules don't call into us
			m_pRules->Detach () ;
			m_pRules->Release () ;
			m_pRules = NULL ;
		}
		delete this ;

		//we do not want to use instance which got deleted
		bRet = FALSE;
	}

	return bRet ;
}

ULONG CResource::Release ()
{
	BOOL bRet ;
	ULONG lCount = 0 ;
	--m_lRef ;
	if ( m_lRef == 0 )
	{
		bRet = OnFinalRelease () ;
	}
	else
	{
		bRet = OnRelease () ;
	}

	if ( bRet )
	{
		if ( m_lRef == 0 )
		{
			m_pResources->RemoveFromList ( this ) ;
			if ( m_pRules )
			{
				//since we're going away, we detach ourselves from the rule so that the rules don't call into us
				m_pRules->Detach () ;
				m_pRules->Release () ;
				m_pRules = NULL ;
			}
			delete this ;
			return lCount ;
		}
	}

	return m_lRef ;
}
/*
void CResource :: RuleEvaluated ( const CRule *a_RuleEvaluated )
{
	if ( m_pRules )
	{
		return m_pRules->CheckRule () ;
	}
	else
	{
		return FALSE ;
	}
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\sacl.cpp ===
/*****************************************************************************/
/*  Copyright (c) 1999-2002 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CSACL.cpp - implementation file for CAccessEntry class.
 */

#include "precomp.h"
#include "aclapi.h"
#include "AccessEntryList.h"
#include "SACL.h"
#include <accctrl.h>
#include "wbemnetapi32.h"
#include "SecUtils.h"

///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::CSACL
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSACL::CSACL( void )
 : m_SACLSections(NULL)
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::~CSACL
//
//	Class destructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSACL::~CSACL( void )
{
    Clear();
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSCL::Init
//
//	Initializes the SACL member list.
//
//	Inputs:
//
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
DWORD CSACL::Init(PACL	a_pSACL)
{
    DWORD t_dwRes = E_FAIL;
    if(a_pSACL == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(m_SACLSections != NULL)
    {
        delete m_SACLSections;
        m_SACLSections = NULL;
    }

    try
    {
        m_SACLSections = new CAccessEntryList;
    }
    catch(...)
    {
        if(m_SACLSections != NULL)
        {
            delete m_SACLSections;
            m_SACLSections = NULL;
        }
        throw;
    }

    t_dwRes = m_SACLSections->InitFromWin32ACL(a_pSACL);

    return t_dwRes;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::AddSACLEntry
//
//	Adds a System Audit entry to the ACL.  By default, these go
//	to the front of the list.
//
//	Inputs:
//				PSID		psid - PSID
//				DWORD		dwAccessMask - Access Mask
//				BYTE		bAceFlags - Flags
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CSACL::AddSACLEntry( PSID psid, SACLTYPE SaclType, DWORD dwAccessMask, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool fReturn = true;
    BYTE bACEType;

	// Sid must be valid
	if ( (psid != NULL) && IsValidSid( psid ) )
	{
		switch(SaclType)
        {
            case ENUM_SYSTEM_AUDIT_ACE_TYPE:
                bACEType = SYSTEM_AUDIT_ACE_TYPE;
                break;
/********************************* type not yet supported under w2k ********************************************
            case ENUM_SYSTEM_ALARM_ACE_TYPE:
                bACEType = SYSTEM_ALARM_ACE_TYPE;
                break;
/********************************* type not yet supported under w2k ********************************************/
            case ENUM_SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                bACEType = SYSTEM_AUDIT_OBJECT_ACE_TYPE;
                break;
/********************************* type not yet supported under w2k ********************************************
            case ENUM_SYSTEM_ALARM_OBJECT_ACE_TYPE:
                bACEType = SYSTEM_ALARM_OBJECT_ACE_TYPE;
                break;
/********************************* type not yet supported under w2k ********************************************/
            default:
                fReturn = false;
                break;
        }

        // We will overwrite the Access Mask of a duplicate entry.
		if(fReturn)
        {
            if(m_SACLSections == NULL)
            {
                try
                {
                    m_SACLSections = new CAccessEntryList;
                }
                catch(...)
                {
                    if(m_SACLSections != NULL)
                    {
                        delete m_SACLSections;
                        m_SACLSections = NULL;
                    }
                    throw;
                }
                if(m_SACLSections != NULL)
                {
                    fReturn = m_SACLSections->AppendNoDup( psid, bACEType, bAceFlags, dwAccessMask, pguidObjGuid, pguidInhObjGuid );
                }
            }
            else
            {
                fReturn = m_SACLSections->AppendNoDup( psid, bACEType, bAceFlags, dwAccessMask, pguidObjGuid, pguidInhObjGuid );
            }
        }
	}
    else
    {
        fReturn = true;
    }

	return fReturn;
}



///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::RemoveSACLEntry
//
//	Removes a system audit entry from the ACL.
//
//	Inputs:
//				CSid&		sid - PSID
//				DWORD		dwAccessMask - Access Mask
//				BYTE		bAceFlags - Flags
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
//	Removed entry MUST match the supplied parameters.
//
///////////////////////////////////////////////////////////////////

bool CSACL::RemoveSACLEntry( CSid& sid, SACLTYPE SaclType, DWORD dwAccessMask, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool	fReturn = false;

	// We need an ACE to compare
	CAccessEntry	ACE( &sid, SYSTEM_AUDIT_ACE_TYPE, bAceFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask );
	ACLPOSITION		pos;

	if ( m_SACLSections->BeginEnum( pos ) )
	{
		ON_BLOCK_EXIT_OBJ ( *m_SACLSections, CAccessEntryList::EndEnum, ByRef ( pos ) ) ;

		CAccessEntry*	pACE = NULL;
        try
        {
            // For loop will try to find a matching ACE in the list
		    for (	CAccessEntry*	pACE = m_SACLSections->GetNext( pos );
				    NULL != pACE
			    ||	ACE == *pACE;
				    pACE = m_SACLSections->GetNext( pos ) );
        }
        catch(...)
        {
            if(pACE != NULL)
            {
                delete pACE;
                pACE = NULL;
            }
            throw;
        }

		// If we got a match, delete the ACE.
		if ( NULL != pACE )
		{
			m_SACLSections->Remove( pACE );
			delete pACE;
			fReturn = true;
		}
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::RemoveSACLEntry
//
//	Removes a system audit entry from the ACL.
//
//	Inputs:
//				CSid&		sid - PSID
//				BYTE		bAceFlags - Flags
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
//	Removed entry MUST match the supplied parameters.
//
///////////////////////////////////////////////////////////////////

bool CSACL::RemoveSACLEntry( CSid& sid, SACLTYPE SaclType, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool	fReturn = false;

	// We need an ACE to compare
	ACLPOSITION		pos;

	if ( m_SACLSections->BeginEnum( pos ) )
	{
		ON_BLOCK_EXIT_OBJ ( *m_SACLSections, CAccessEntryList::EndEnum, ByRef ( pos ) ) ;

		// For loop will try to find a matching ACE in the list
        CAccessEntry*	pACE = NULL;
        try
        {
		    for (	pACE = m_SACLSections->GetNext( pos );
				    NULL != pACE;
				    pACE = m_SACLSections->GetNext( pos ) )
		    {
                CAccessEntry caeTemp(sid, SaclType, bAceFlags, pguidObjGuid, pguidInhObjGuid, pACE->GetAccessMask());
			    // If we got a match, delete the ACE.
			    if (*pACE == caeTemp)
			    {
				    m_SACLSections->Remove( pACE );
				    fReturn = true;
				    break;
			    }
                delete pACE;
		    }
        }
        catch(...)
        {
            if(pACE != NULL)
            {
                delete pACE;
                pACE = NULL;
            }
            throw;
        }
	}
	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::RemoveSACLEntry
//
//	Removes a system audit entry from the ACL.
//
//	Inputs:
//				CSid&		sid - PSID
//				DWORD		dwIndex - Index to remove.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
//	Removes dwIndex entry matching sid.
//
///////////////////////////////////////////////////////////////////

bool CSACL::RemoveSACLEntry( CSid& sid, SACLTYPE SaclType, DWORD dwIndex /*= 0*/ )
{
	bool	fReturn = false;

	// We need an ACE to compare
	CSid			tempsid;
	ACLPOSITION		pos;
	DWORD			dwCtr = 0;

	if ( m_SACLSections->BeginEnum( pos ) )
	{
		ON_BLOCK_EXIT_OBJ ( *m_SACLSections, CAccessEntryList::EndEnum, ByRef ( pos ) ) ;

		// For each ACE we find, see if it is an SYSTEM_AUDIT_ACE_TYPE,
		// and if the Sid matches the one passed in.  If it does, increment
		// the counter, then if we're on the right index remove the ACE,
		// delete it and quit.
        CAccessEntry*	pACE = NULL;
        try
        {
		    for (	pACE = m_SACLSections->GetNext( pos );
				    NULL != pACE;
				    pACE = m_SACLSections->GetNext( pos ) )
		    {
			    if ( SYSTEM_AUDIT_ACE_TYPE == pACE->GetACEType() )
			    {
				    pACE->GetSID( tempsid );

				    if ( sid == tempsid )
				    {
					    if ( dwCtr == dwIndex )
					    {
						    m_SACLSections->Remove( pACE );
						    fReturn = true;
						    break;
					    }
					    else
					    {
						    ++dwCtr;
					    }
				    }
                    delete pACE;
			    }
		    }
        }
        catch(...)
        {
            if(pACE != NULL)
            {
                delete pACE;
                pACE = NULL;
            }
            throw;
        }
	}
	return fReturn;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::Find
//
//	Finds the specified ace in the dacl
//
//
//	Returns:
//				true if found it.
//
//	Comments:
//
//	Helps support NT 5 canonical order in DACLs.
//
///////////////////////////////////////////////////////////////////
bool CSACL::Find( const CSid& sid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace )
{
     return m_SACLSections->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::Find
//
//	Finds the specified ace in the dacl
//
//
//	Returns:
//				true if found it.
//
//	Comments:
//
//	Helps support NT 5 canonical order in DACLs.
//
///////////////////////////////////////////////////////////////////
bool CSACL::Find( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace )
{
    return m_SACLSections->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::::ConfigureSACL
//
//	Configures a Win32 PACL with SACL information.
//
//	Inputs:
//				None.
//
//	Outputs:
//				PACL&			pSacl - Pointer to a SACL.
//
//	Returns:
//				DWORD			ERROR_SUCCESS if successful.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSACL::ConfigureSACL( PACL& pSacl )
{
	DWORD		dwReturn		=	ERROR_SUCCESS,
				dwSACLLength	=	0;

	if ( CalculateSACLSize( &dwSACLLength ) )
	{

		if ( 0 != dwSACLLength )
		{
            pSacl = NULL;
            try
            {
			    pSacl = (PACL) malloc( dwSACLLength );

			    if ( NULL != pSacl )
			    {
				    if ( !InitializeAcl( (PACL) pSacl, dwSACLLength, ACL_REVISION ) )
				    {
					    dwReturn = ::GetLastError();
				    }

			    }	// If NULL != pSACL
            }
            catch(...)
            {
                if(pSacl != NULL)
                {
                    free(pSacl);
                    pSacl = NULL;
                }
                throw;
            }

		}	// If 0 != dwSACLLength

	}	// If Calcaulate SACL Size
	else
	{
		dwReturn = ERROR_INVALID_PARAMETER;	// One or more of the SACLs is bad
	}

	if ( ERROR_SUCCESS == dwReturn )
	{
		dwReturn = FillSACL( pSacl );
	}

	if ( ERROR_SUCCESS != dwReturn )
	{
		free( pSacl );
		pSacl = NULL;
	}

	return dwReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::::CalculateSACLSize
//
//	Obtains the size necessary to populate a SACL.
//
//	Inputs:
//				None.
//
//	Outputs:
//				LPDWORD			pdwSACLLength - Calculated Length.
//
//	Returns:
//				BOOL			TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

BOOL CSACL::CalculateSACLSize( LPDWORD pdwSACLLength )
{
	BOOL			fReturn			=	FALSE;

	*pdwSACLLength = 0;

	if ( NULL != m_SACLSections )
	{
		fReturn = m_SACLSections->CalculateWin32ACLSize( pdwSACLLength );
	}

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::FillSACL
//
//	Fills out a SACL.
//
//	Inputs:
//				PACL			pSacl - Sacl to fill out.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL			TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSACL::FillSACL( PACL pSACL )
{
	DWORD	dwReturn = ERROR_SUCCESS;

	if ( NULL != m_SACLSections )
	{
		dwReturn = m_SACLSections->FillWin32ACL( pSACL );
	}

	return dwReturn;

}


void CSACL::Clear()
{
	if ( NULL != m_SACLSections )
	{
		delete m_SACLSections;
        m_SACLSections = NULL;
	}
}


bool CSACL::GetMergedACL
(
    CAccessEntryList& a_aclIn
)
{
    // Actually somewhat of a misnomer for the time being (until the
    // day when the sacl ordering matters, and we have multiple sections
    // as we do in dacl for that reason).  We just hand back our
    // member acl, if it is not null:
    bool fRet = false;
    if(m_SACLSections != NULL)
    {
        fRet = a_aclIn.Copy(*m_SACLSections);
    }
    return fRet;
}

void CSACL::DumpSACL(LPCWSTR wstrFilename)
{
    Output(L"SACL contents follow...", wstrFilename);
    if(m_SACLSections != NULL)
    {
        m_SACLSections->DumpAccessEntryList(wstrFilename);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\securefile.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CSecureFile.h - header file for CSecureFile class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CSECUREFILE_H__
#define __CSECUREFILE_H__

		


////////////////////////////////////////////////////////////////
//
//	Class:	CSecureFile
//
//	This class is intended to encapsulate the security of an
//	NT File or Directory.  It inherits off of CSecurityDescriptor
//	and it is that class to which it passes Security Descriptors
//	it obtains, and from which it receives previously built
//	security descriptors to apply.  It supplies implementations
//	for AllAccessMask(), WriteOwner() and WriteAcls().
//
////////////////////////////////////////////////////////////////

class CSecureFile : public CSecurityDescriptor
{
	// Constructors and destructor
	public:
		CSecureFile();
		CSecureFile( LPCTSTR pszFileName, BOOL fGetSACL = TRUE );
        CSecureFile
        (   
            LPCTSTR a_pszFileName,
            CSid* a_psidOwner,
            bool a_fOwnerDefaulted,
            CSid* a_psidGroup,
            bool a_fGroupDefaulted,
            CDACL* a_pDacl,
            bool a_fDaclDefaulted,
            bool a_fDaclAutoInherited,
            CSACL* a_pSacl,
            bool a_fSaclDefaulted,
            bool a_fSaclAutoInherited
        );
		CSecureFile( LPCTSTR pszFileName, PSECURITY_DESCRIPTOR pSD ) ;
		~CSecureFile();

		DWORD	SetFileName( LPCTSTR pszFileName, BOOL fGetSACL = TRUE );

		virtual DWORD AllAccessMask( void );
		virtual DWORD WriteOwner( PSECURITY_DESCRIPTOR pAbsoluteSD );
		virtual DWORD WriteAcls( PSECURITY_DESCRIPTOR pAbsoluteSD , SECURITY_INFORMATION securityinfo  );

	private:
		CHString	m_strFileName;

};

#endif // __CSecureFile_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\securefile.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	SecurityDescriptor.cpp - implementation file for CSecureFile class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#include "precomp.h"

#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "aclapi.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"					// CSACL class


#include "SecurityDescriptor.h"
#include "securefile.h"
#include "tokenprivilege.h"
#include "ImpLogonUser.h"
#include "AdvApi32Api.h"


///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureFile::CSecureFile
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureFile::CSecureFile()
:	CSecurityDescriptor(),
	m_strFileName()
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureFile::CSecureFile
//
//	Alternate Class CTOR
//
//	Inputs:
//				LPCTSTR		pszFileName - The FileName to handle
//							security for.
//				BOOL		fGetSACL - Should we get the SACL?
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureFile::CSecureFile( LPCTSTR pszFileName, BOOL fGetSACL /*= TRUE*/ )
:	CSecurityDescriptor(),
	m_strFileName()
{
	SetFileName( pszFileName );
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureFile::CSecureFile
//
//	Alternate Class CTOR
//
//	Inputs:
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
CSecureFile::CSecureFile
(
    LPCTSTR a_pszFileName,
    CSid* a_psidOwner,
    bool a_fOwnerDefaulted,
    CSid* a_psidGroup,
    bool a_fGroupDefaulted,
    CDACL* a_pDacl,
    bool a_fDaclDefaulted,
    bool a_fDaclAutoInherited,
    CSACL* a_pSacl,
    bool a_fSaclDefaulted,
    bool a_fSaclAutoInherited
)
:  CSecurityDescriptor(a_psidOwner,
                       a_fOwnerDefaulted,
                       a_psidGroup,
                       a_fGroupDefaulted,
                       a_pDacl,
                       a_fDaclDefaulted,
                       a_fDaclAutoInherited,
                       a_pSacl,
                       a_fSaclDefaulted,
                       a_fSaclAutoInherited)
{
    m_strFileName = a_pszFileName;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureFile::CSecureFile
//
//	Alternate Class CTOR
//
//	Inputs:
//				LPCTSTR					pszFileName	-	The FileName to handle
//														security for.
//
//				PSECURITY_DESCRIPTOR	pSD			-	The Security Descriptor to associate with this file
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureFile::CSecureFile( LPCTSTR pszFileName, PSECURITY_DESCRIPTOR pSD )
:	CSecurityDescriptor(),
	m_strFileName()
{
	if ( InitSecurity( pSD ) )
	{
		m_strFileName = pszFileName;
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureFile::~CSecureFile
//
//	Class Destructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureFile::~CSecureFile( void )
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureFile::SetFileName
//
//	Public Entry point to set which file/directory this instance
//	of the class is to supply security for.
//
//	Inputs:
//				LPCTSTR		pszFileName - The FileName to handle
//							security for.
//				BOOL		fGetSACL - Should we get the SACL?
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
//	This will clear any previously set filenames and/or security
//	information.
//
///////////////////////////////////////////////////////////////////

DWORD CSecureFile::SetFileName( LPCTSTR pszFileName, BOOL fGetSACL /*= TRUE*/ )
{
	DWORD					dwError = ERROR_SUCCESS;
	SECURITY_INFORMATION	siFlags = OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;

    // GetFileSecurity uses DCOM long logon ids.  If we are connected from a remote machine,
    // even though we might be the same user as the local logged on user, the long id will be
    // different, and GetFileSecurity will give an access denied.  Hence the following
    // impersonation of the connected user.  Note also that this impersonation must be
    // done prior to setting the SE_SECURITY_NAME privilage, otherwise we would set that
    // privilage for one person, then impersonate another, who probably wouldn't have it!
	// This phenomenon can be observed most easily when asking to see an instance of
	// win32_logicalfilesecuritysetting of a root directory of a mapped drive, on a machine
	// that we have remoted into via wbem.

#ifdef NTONLY
    // NOTE: THE FOLLOWING PRESENTS A SECURITY BREACH, AND SHOULD BE REMOVED.
    bool fImp = false;

    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif

    // We must have the security privilege enabled in order to access the object's SACL
    CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
	BOOL			fDisablePrivilege = FALSE;

	if ( fGetSACL )
	{
		fDisablePrivilege = ( securityPrivilege.Enable() == ERROR_SUCCESS );
		siFlags |= SACL_SECURITY_INFORMATION;
	}


	// Determine the length needed for self-relative SD
	DWORD dwLengthNeeded = 0;

	BOOL	fSuccess = ::GetFileSecurity( pszFileName,
										siFlags,
										NULL,
										0,
										&dwLengthNeeded );

	dwError = ::GetLastError();

    // It is possible that the user lacked the permissions required to obtain the SACL,
    // even though we set the token's SE_SECURITY_NAME privilege.  So if we obtained an
    // access denied error, try it again, this time without requesting the SACL.
    if(dwError == ERROR_ACCESS_DENIED  || dwError == ERROR_PRIVILEGE_NOT_HELD)
    {
        siFlags = OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;
        fSuccess = ::GetFileSecurity(pszFileName,
									 siFlags,
									 NULL,
									 0,
									 &dwLengthNeeded);
		dwError = ::GetLastError();
    }

	// The only expected error at this point is insuficient buffer
	if ( !fSuccess && ERROR_INSUFFICIENT_BUFFER == dwError )
	{
        PSECURITY_DESCRIPTOR	pSD = NULL;
        try
        {
		    pSD = malloc( dwLengthNeeded );

		    if ( NULL != pSD )
		    {

			    // Now obtain security descriptor
			    if ( ::GetFileSecurity( pszFileName,
							    siFlags,
							    pSD,
							    dwLengthNeeded,
							    &dwLengthNeeded ) )
			    {

				    dwError = ERROR_SUCCESS;

				    if ( InitSecurity( pSD ) )
				    {
					    m_strFileName = pszFileName;
				    }
				    else
				    {
					    dwError = ERROR_INVALID_PARAMETER;
				    }

			    }
			    else
			    {
				    dwError = ::GetLastError();
			    }

			    // free up the security descriptor
			    free( pSD );

		    }	// IF NULL != pSD
        }
        catch(...)
        {
            if(pSD != NULL)
            {
                free(pSD);
                pSD = NULL;
            }
            throw;
        }

	}	// IF INSUFFICIENTBUFFER

	// Cleanup the Name Privilege as necessary.
	if ( fDisablePrivilege )
	{
		securityPrivilege.Enable(FALSE);
	}

#ifdef NTONLY
    if(fImp)
    {
        icu.End();
    }
#endif

	return dwError;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureFile::WriteAcls
//
//	Protected entry point called by CSecurityDescriptor when
//	a user Applies Security and wants to apply security for
//	the DACL and/or SACL.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security
//										descriptor to apply to
//										the file.
//				SECURITY_INFORMATION	securityinfo - Flags
//										indicating which ACL(s)
//										to set.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSecureFile::WriteAcls( PSECURITY_DESCRIPTOR pAbsoluteSD, SECURITY_INFORMATION securityinfo )
{
	DWORD		dwError = ERROR_SUCCESS;

	// We must have the security privilege enabled in order to access the object's SACL

	CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
	BOOL			fDisablePrivilege = FALSE;

	if ( securityinfo & SACL_SECURITY_INFORMATION || securityinfo & PROTECTED_SACL_SECURITY_INFORMATION || securityinfo & UNPROTECTED_SACL_SECURITY_INFORMATION)
	{
		fDisablePrivilege = ( securityPrivilege.Enable() == ERROR_SUCCESS );
	}

#if NTONLY >= 5
//    CAdvApi32Api *t_pAdvApi32 = NULL;
//    CActrl t_actrlAccess;
//    CActrl t_actrlAudit;
//
//
//    if((dwError = ConfigureActrlAudit(t_actrlAudit, pAbsoluteSD)) == ERROR_SUCCESS && (dwError = ConfigureActrlAccess(t_actrlAccess, pAbsoluteSD)) == ERROR_SUCCESS)
//    {
//        t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
//        if(t_pAdvApi32 != NULL)
//        {
//            t_pAdvApi32->SetNamedSecurityInfoEx(m_strFileName,
//                                                SE_FILE_OBJECT,
//                                                securityinfo,
//                                                NULL,
//                                                t_actrlAccess,
//                                                t_actrlAudit,
//                                                NULL,           //owner (not specified in securityinfo)
//                                                NULL,           //group (not specified in securityinfo)
//                                                NULL,           //callback function
//                                                &dwError);
//            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
//            t_pAdvApi32 = NULL;
//        }
//    }

    // This is new new and improved (hah!) NT5 way.  The following is more efficient (although more lines of
    // code in *this* module) than making use of our CSecurityDescriptor class to extract all this stuff.

    // Need to see if the control flags specify dacl/sacl protection.  If so, impacts what we set in the securityinfo structure.


// NEXT FEW LINES AND RELATED LINES NOT REQUIRED AS THE NEW APPROACH, WITH THE NEW PROTECTED_DACL_SECURITY_INFORMATION flag in the SECURITY_INFORMATION
// structure is to not have to, ever, touch or get the control flags (hence, for instance, the call to SetSecurityDescriptorControl in SecurityDescriptor.cpp
// is now superfluous.
//
//    SECURITY_DESCRIPTOR_CONTROL Control;
//    DWORD dwRevision = 0;
//
//    if(GetSecurityDescriptorControl(pAbsoluteSD, &Control, &dwRevision))
//    {
//        // We got the control structure; now see about dacl/sacl protection, and alter securityinfo accordingly...
//        if(Control & SE_DACL_PROTECTED)
//        {
//            securityinfo |= PROTECTED_DACL_SECURITY_INFORMATION;
//        }
//        if(Control & SE_SACL_PROTECTED)
//        {
//            securityinfo |= PROTECTED_SACL_SECURITY_INFORMATION;
//        }

        PACL pDACL = NULL;
        BOOL fDACLPresent = FALSE;
		BOOL fDACLDefaulted = FALSE;
        // Need to get the PDACL and PSACL if they exist...
        if(::GetSecurityDescriptorDacl(pAbsoluteSD, &fDACLPresent, &pDACL, &fDACLDefaulted))
        {
            PACL pSACL = NULL;
            BOOL fSACLPresent = FALSE;
		    BOOL fSACLDefaulted = FALSE;
            if(::GetSecurityDescriptorSacl(pAbsoluteSD, &fSACLPresent, &pSACL, &fSACLDefaulted))
            {
                // Now need the owner...
                PSID psidOwner = NULL;
                BOOL bTemp;
                if(::GetSecurityDescriptorOwner(pAbsoluteSD, &psidOwner, &bTemp))
                {
                    PSID psidGroup = NULL;
                    // Now need the group...
                    if(::GetSecurityDescriptorGroup(pAbsoluteSD, &psidGroup, &bTemp))
                    {
                        dwError = ::SetNamedSecurityInfo((LPWSTR)(LPCWSTR)m_strFileName,
                                                         SE_FILE_OBJECT,
                                                         securityinfo,
                                                         psidOwner,
                                                         psidGroup,
                                                         pDACL,
                                                         pSACL);
                    }
                    else // couldn't get group
                    {
                        dwError = ::GetLastError();
                    }
                }
                else // couldn't get owner
                {
                    dwError = ::GetLastError();
                }
            } // couldn't get sacl
            else
            {
                dwError = ::GetLastError();
            }
        } // couldn't get dacl
        else
        {
            dwError = ::GetLastError();
        }
//    } // couldn't get control
//    else
//    {
//        dwError = ::GetLastError();
//    }


#else

	if(!::SetFileSecurity(TOBSTRT(m_strFileName),
						  securityinfo,
						  pAbsoluteSD))
	{
		dwError = ::GetLastError();
	}

#endif


	// Cleanup the Name Privilege as necessary.
	if ( fDisablePrivilege )
	{
		securityPrivilege.Enable(FALSE);
	}

	return dwError;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureFile::WriteOwner
//
//	Protected entry point called by CSecurityDescriptor when
//	a user Applies Security and wants to apply security for
//	the owner.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security
//										descriptor to apply to
//										the file.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSecureFile::WriteOwner( PSECURITY_DESCRIPTOR pAbsoluteSD )
{
	DWORD		dwError = ERROR_SUCCESS;

#if NTONLY >= 5
    SECURITY_INFORMATION securityinfo = OWNER_SECURITY_INFORMATION;
    PSID psidOwner = NULL;
    BOOL bTemp;
    if(::GetSecurityDescriptorOwner(pAbsoluteSD, &psidOwner, &bTemp))
    {
        dwError = ::SetNamedSecurityInfo((LPWSTR)(LPCWSTR)m_strFileName,
                                                         SE_FILE_OBJECT,
                                                         securityinfo,
                                                         psidOwner,
                                                         NULL,
                                                         NULL,
                                                         NULL);
    }
    else
    {
        dwError = ::GetLastError();
    }
#else
	// Open with the appropriate access, set the security and leave
	if ( !::SetFileSecurity(TOBSTRT(m_strFileName),
							OWNER_SECURITY_INFORMATION,
							pAbsoluteSD))
	{
		dwError = ::GetLastError();
	}
#endif
	return dwError;
}

DWORD CSecureFile::AllAccessMask( void )
{
	// File specific All Access Mask
	return FILE_ALL_ACCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\securekernelobj.cpp ===
/*****************************************************************************/

/*  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	SecurityDescriptor.cpp - implementation file for CSecureKernelObj class.
 *
 *	Created:	11-27-00 by Kevin Hughes
 */

#include "precomp.h"

#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "aclapi.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"					// CSACL class


#include "SecurityDescriptor.h"
#include "securefile.h"
#include "tokenprivilege.h"
#include "ImpLogonUser.h"
#include "AdvApi32Api.h"
#include "smartptr.h"
#include "SecureKernelObj.h"


///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureKernelObj::CSecureKernelObj
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureKernelObj::CSecureKernelObj()
:	CSecurityDescriptor()
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureKernelObj::CSecureKernelObj
//
//	Alternate Class CTOR
//
//	Inputs:
//				LPCWSTR		wszObjName - The kernel object to handle
//							security for.
//				BOOL		fGetSACL - Should we get the SACL?
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureKernelObj::CSecureKernelObj(
    HANDLE hObject, 
    BOOL fGetSACL /*= TRUE*/ )
:	CSecurityDescriptor()
{
	SetObject(hObject, fGetSACL);
}



///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureKernelObj::CSecureKernelObj
//
//	Alternate Class CTOR
//
//	Inputs:
//				LPCWSTR					wszObjName	-	The object name to handle
//														security for.
//
//				PSECURITY_DESCRIPTOR	pSD			-	The Security Descriptor to associate with this object
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureKernelObj::CSecureKernelObj(
    HANDLE hObject, 
    PSECURITY_DESCRIPTOR pSD)
:	CSecurityDescriptor()
{
	if(InitSecurity(pSD))
	{
		// we just get a copy - we don't take ownership.
        m_hObject = hObject;
	}
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureKernelObj::~CSecureKernelObj
//
//	Class Destructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureKernelObj::~CSecureKernelObj(void)
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureKernelObj::SetObject
//
//	Public Entry point to set which object this instance
//	of the class is to supply security for.
//
//	Inputs:
//				HANDLE		hObject - The object to handle
//							security for.
//				BOOL		fGetSACL - Should we get the SACL?
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
//	This will clear any previously set filenames and/or security
//	information.
//
///////////////////////////////////////////////////////////////////

DWORD CSecureKernelObj::SetObject(
    HANDLE hObject, 
    BOOL fGetSACL /*= TRUE*/ )
{
	DWORD					dwError = ERROR_SUCCESS;
	SECURITY_INFORMATION	siFlags = OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;


    // We must have the security privilege enabled in order to access the object's SACL
    CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
	BOOL			fDisablePrivilege = FALSE;

	if ( fGetSACL )
	{
		fDisablePrivilege = (securityPrivilege.Enable() == ERROR_SUCCESS);
		siFlags |= SACL_SECURITY_INFORMATION;
	}


	// Determine the length needed for self-relative SD
	DWORD dwLengthNeeded = 0;

    BOOL fSuccess = ::GetKernelObjectSecurity(
        hObject,
		siFlags,
		NULL,
		0,
		&dwLengthNeeded);

    dwError = ::GetLastError();

    // It is possible that the user lacked the permissions required to obtain the SACL,
    // even though we set the token's SE_SECURITY_NAME privilege.  So if we obtained an
    // access denied error, try it again, this time without requesting the SACL.
    if(dwError == ERROR_ACCESS_DENIED  || dwError == ERROR_PRIVILEGE_NOT_HELD)
    {
        siFlags = OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;
        fSuccess = ::GetKernelObjectSecurity(
            hObject,
			siFlags,
			NULL,
			0,
			&dwLengthNeeded);
		
        dwError = ::GetLastError();
    }

	// The only expected error at this point is insuficient buffer
	if(!fSuccess && ERROR_INSUFFICIENT_BUFFER == dwError)
	{
        PSECURITY_DESCRIPTOR pSD = NULL;
        try
        {
		    pSD = new BYTE[dwLengthNeeded];
		    if(pSD)
		    {
			    // Now obtain security descriptor
			    if(::GetKernelObjectSecurity(
                        hObject,
						siFlags,
						pSD,
						dwLengthNeeded,
						&dwLengthNeeded))
			    {

				    dwError = ERROR_SUCCESS;

				    if(InitSecurity(pSD))
				    {
					    m_hObject = hObject;
				    }
				    else
				    {
					    dwError = ERROR_INVALID_PARAMETER;
				    }
			    }
			    else
			    {
				    dwError = ::GetLastError();
			    }

			    // free up the security descriptor
			    delete pSD;
		    }	
        }
        catch(...)
        {
            delete pSD;
            throw;
        }

	}	

	// Cleanup the Name Privilege as necessary.
	if(fDisablePrivilege)
	{
		securityPrivilege.Enable(FALSE);
	}

	return dwError;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureKernelObj::WriteAcls
//
//	Protected entry point called by CSecurityDescriptor when
//	a user Applies Security and wants to apply security for
//	the DACL and/or SACL.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security
//										descriptor to apply to
//										the object.
//				SECURITY_INFORMATION	securityinfo - Flags
//										indicating which ACL(s)
//										to set.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSecureKernelObj::WriteAcls( 
    PSECURITY_DESCRIPTOR pAbsoluteSD, 
    SECURITY_INFORMATION securityinfo)
{
	DWORD dwError = ERROR_SUCCESS;

	// We must have the security privilege enabled in order to access the object's SACL
	CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
	BOOL fDisablePrivilege = FALSE;

	if(securityinfo & SACL_SECURITY_INFORMATION || 
        securityinfo & PROTECTED_SACL_SECURITY_INFORMATION || 
        securityinfo & UNPROTECTED_SACL_SECURITY_INFORMATION)
	{
		fDisablePrivilege = (securityPrivilege.Enable() == ERROR_SUCCESS);
	}
    
    if(!::SetKernelObjectSecurity(
        m_hObject,
        securityinfo,
        pAbsoluteSD))
    {
        dwError = ::GetLastError();
    }


	// Cleanup the Name Privilege as necessary.
	if(fDisablePrivilege)
	{
		securityPrivilege.Enable(FALSE);
	}

	return dwError;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureKernelObj::WriteOwner
//
//	Protected entry point called by CSecurityDescriptor when
//	a user Applies Security and wants to apply security for
//	the owner.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security
//										descriptor to apply to
//										the object.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSecureKernelObj::WriteOwner(PSECURITY_DESCRIPTOR pAbsoluteSD)
{
	DWORD		dwError = ERROR_SUCCESS;

	// Open with the appropriate access, set the security and leave
	if(!::SetKernelObjectSecurity(
        m_hObject,
		OWNER_SECURITY_INFORMATION,
		pAbsoluteSD))
	{
		dwError = ::GetLastError();
	}

	return dwError;
}



DWORD CSecureKernelObj::AllAccessMask(void)
{
	// File specific All Access Mask
	return TOKEN_ALL_ACCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\sacl.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CSACL.h - header file for CSACL class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CSACL_H__
#define __CSACL_H__

#include "AccessEntryList.h"



enum SACL_Types
{
    ENUM_SYSTEM_AUDIT_OBJECT_ACE_TYPE = 0,
/********************************* type not yet supported under w2k ********************************************
    ENUM_SYSTEM_ALARM_OBJECT_ACE_TYPE,
/**************************************************************************************************************/
    ENUM_SYSTEM_AUDIT_ACE_TYPE,
/********************************* type not yet supported under w2k ********************************************
    ENUM_SYSTEM_ALARM_ACE_TYPE,
/**************************************************************************************************************/
    // Keep this as the last entry in this enum:
    NUM_SACL_TYPES
};

#define SACLTYPE short


//////////////////////////////////////////////////////////////////
//
//	Class: CSACL
//
//	Class encapsulates a Win32 SACL, by providing public methods
//	for manipulating System Auditing entries only.
//
//////////////////////////////////////////////////////////////////

class CSACL
{
	// Constructors and destructor
	public:
		CSACL();
		~CSACL( void );

        DWORD Init(PACL	pSACL);

		bool AddSACLEntry( PSID psid, 
                           SACLTYPE SaclType, 
                           DWORD dwAccessMask, 
                           BYTE bAceFlags,
                           GUID *pguidObjGuid, 
                           GUID *pguidInhObjGuid );

        bool RemoveSACLEntry( CSid& sid, SACLTYPE SaclType, DWORD dwIndex = 0  );
		bool RemoveSACLEntry( CSid& sid, SACLTYPE SaclType, DWORD dwAccessMask, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid );
		bool RemoveSACLEntry( CSid& sid, SACLTYPE SaclType, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid ); 
        

		bool CopySACL ( CSACL & dacl );
		bool AppendSACL ( CSACL & dacl );
        bool IsEmpty();
        bool GetMergedACL(CAccessEntryList& a_aclIn);

        DWORD ConfigureSACL( PACL& pSACL );
		DWORD FillSACL( PACL pSACL );
		BOOL CalculateSACLSize( LPDWORD pdwSACLLength );

        // Override of functions of same name from CAccessEntry
        virtual bool Find( const CSid& sid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace );
        virtual bool Find( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace );
        void Clear();

        void DumpSACL(LPCWSTR wstrFilename = NULL);
    
    private:

        CAccessEntryList* m_SACLSections;  // at the moment, sacl's only have one section, so this is not an array as it is in DACL.CPP
};





inline bool CSACL::CopySACL ( CSACL& sacl )
{
	bool fRet = true;

    if(m_SACLSections != NULL)
    {
        delete m_SACLSections;
        m_SACLSections = NULL;
    }

    try
    {
        m_SACLSections = new CAccessEntryList;   
    }
    catch(...)
    {
        if(m_SACLSections != NULL)
        {
            delete m_SACLSections;
            m_SACLSections = NULL;
        }
        throw;
    }

    if(m_SACLSections != NULL)
    {
        fRet = m_SACLSections->Copy(*(sacl.m_SACLSections));
    }
    else
    {
        fRet = false;
    }
    
    return fRet;
}

inline bool CSACL::AppendSACL ( CSACL& sacl )
{
	bool fRet = FALSE;

    if(m_SACLSections == NULL)
    {
        try
        {
            m_SACLSections = new CAccessEntryList;   
        }
        catch(...)
        {
            if(m_SACLSections != NULL)
            {
                delete m_SACLSections;
                m_SACLSections = NULL;
            }
            throw;
        }
    }

    if(m_SACLSections != NULL)
    {
        fRet = m_SACLSections->AppendList(*(sacl.m_SACLSections));
    }
    else
    {
        fRet = false;
    }
    
    return fRet;
}

inline bool CSACL::IsEmpty()
{
    bool fIsEmpty = true;
    if(m_SACLSections != NULL)
    {
        fIsEmpty = m_SACLSections->IsEmpty();
    }
    return fIsEmpty;
}


#endif // __CAccessEntry_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\securekernelobj.h ===
/*****************************************************************************/

/*  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	SecureKernelObj.h - header file for CSecureKernelObj class.
 *
 *	Created:	11-27-00 by Kevin Hughes
 *				
 */

#pragma once

		


////////////////////////////////////////////////////////////////
//
//	Class:	CSecureKernelObj
//
//	This class is intended to encapsulate the security of an
//	NT kernel securable object.  It inherits off of CSecurityDescriptor
//	and it is that class to which it passes Security Descriptors
//	it obtains, and from which it receives previously built
//	security descriptors to apply.  It supplies implementations
//	for AllAccessMask(), WriteOwner() and WriteAcls().
//
////////////////////////////////////////////////////////////////

class CSecureKernelObj : public CSecurityDescriptor
{
	// Constructors and destructor
	public:
		CSecureKernelObj();

		CSecureKernelObj(
            HANDLE hObject,
            BOOL fGetSACL = TRUE);


		CSecureKernelObj(
            HANDLE hObject,
            PSECURITY_DESCRIPTOR pSD);

		virtual ~CSecureKernelObj();

		DWORD SetObject(
            HANDLE hObject, 
            BOOL fGetSACL = TRUE);

		virtual DWORD AllAccessMask(void);
		virtual DWORD WriteOwner(PSECURITY_DESCRIPTOR pAbsoluteSD);
		virtual DWORD WriteAcls(
            PSECURITY_DESCRIPTOR pAbsoluteSD, 
            SECURITY_INFORMATION securityinfo);

	private:

        HANDLE m_hObject;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\secureshare.h ===
/*

 *	CSecureShare.h - header file for CSecureShare class.

 *

*  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
 *
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CSECURESHARE_H__
#define __CSECURESHARE_H__

#include "SecurityDescriptor.h"			// CSid class


////////////////////////////////////////////////////////////////
//
//	Class:	CSecureShare
//
//	This class is intended to encapsulate the security of an
//	NT File or Directory.  It inherits off of CSecurityDescriptor
//	and it is that class to which it passes Security Descriptors
//	it obtains, and from which it receives previously built
//	security descriptors to apply.  It supplies implementations
//	for AllAccessMask(), WriteOwner() and WriteAcls().
//
////////////////////////////////////////////////////////////////

#ifdef NTONLY
class CSecureShare : public CSecurityDescriptor
{
	// Constructors and destructor
	public:
		CSecureShare();
		CSecureShare(PSECURITY_DESCRIPTOR pSD);
		~CSecureShare();

		CSecureShare( CHString& chsShareName);
		DWORD	SetShareName( const CHString& chsShareName);

		virtual DWORD AllAccessMask( void );

	protected:

		virtual DWORD WriteOwner( PSECURITY_DESCRIPTOR pAbsoluteSD  );
		virtual DWORD WriteAcls( PSECURITY_DESCRIPTOR pAbsoluteSD , SECURITY_INFORMATION securityinfo  );

	private:
		CHString	m_strFileName;

};
#endif

#endif // __CSecureShare_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\securityapi.h ===
//=================================================================

//

// SecurityApi.h

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_SECUR_H_
#define	_SECUR_H_

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidSecurApi;
extern const TCHAR g_tstrSecur[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

#define SECURITY_WIN32
#include <sspi.h>
#include <schnlsp.h> //for UNISP_NAME_A

/******************************************************************************
 * Wrapper class for Ws2_32 load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CSecurityApi : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to CSecur functions.
    // Add new functions here as required.
    PSecurityFunctionTableW (WINAPI *m_pfnInitSecurityInterface)();
	PSecurityFunctionTableW m_pSecFuncTable;


public:

    // Constructor and destructor:
    CSecurityApi( LPCTSTR a_tstrWrappedDllName ) ;
    ~CSecurityApi();

    // Inherrited initialization function.
    virtual bool Init();

    // suppoorted APIs
    SECURITY_STATUS AcquireCredentialsHandleW 
    (
		SEC_WCHAR SEC_FAR * pszPrincipal,    // Name of principal
		SEC_WCHAR SEC_FAR * pszPackage,      // Name of package
		unsigned long fCredentialUse,       // Flags indicating use
		void SEC_FAR * pvLogonId,           // Pointer to logon ID
		void SEC_FAR * pAuthData,           // Package specific data
		SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
		void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
		PCredHandle phCredential,           // (out) Cred Handle
		PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    );

	SECURITY_STATUS QueryCredentialsAttributesW(
		PCredHandle phCredential,             // Credential to query
		unsigned long ulAttribute,          // Attribute to query
		void SEC_FAR * pBuffer              // Buffer for attributes
		);

	SECURITY_STATUS FreeCredentialsHandle(
		PCredHandle phCredential            // Handle to free
		);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\secutils.h ===
/*****************************************************************************/



/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /

/*****************************************************************************/



//=================================================================

//

// SecUtils.cpp -- Security utilities useful to wbem mof classes

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/9/99    a-kevhu        Created
//
//=================================================================
#ifndef _SECUTILS_H_
#define _SECUTILS_H_

// Forward class declarations...
class CDACL;
class CSACL;
class CSid;


void FillTrusteeFromSid (CInstance *pInstance, CSid &sid);

void FillInstanceDACL(CInstance *pInstance, CDACL &dacl);

void FillInstanceSACL(CInstance *pInstance, CSACL &sacl);

DWORD FillDACLFromInstance(CInstance *pInstance, 
                           CDACL &dacl, 
                           MethodContext *pMethodContext);

DWORD FillSACLFromInstance(CInstance *pInstance, 
                           CSACL &sacl, 
                           MethodContext *pMethodContext);

bool GetArray(IWbemClassObject *piClassObject, 
              const CHString &name, 
              VARIANT &v, 
              VARTYPE eVariantType);

DWORD FillSIDFromTrustee(CInstance *pTrustee, CSid &sid);

#ifdef NTONLY
void DumpWin32Descriptor(PSECURITY_DESCRIPTOR psd, LPCWSTR wstrFilename = NULL);
void Output(LPCWSTR wstrOut, LPCWSTR wstrFilename = NULL);

bool AmIAnOwner(const CHString &chstrName, SE_OBJECT_TYPE ObjectType);
bool IsUserInGroup(const CSid &csidUser, 
                   const CSid &csidGroup, 
                   SID_NAME_USE snuGroup);
bool RecursiveFindUserInGroup(CNetAPI32 &netapi, 
                              const CHString &chstrDomainName,
                              const CHString &chstrGroupName, 
                              SID_NAME_USE snuGroup,
                              const CSid &csidUser);
#endif




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\secureshare.cpp ===
/*

 *	SecurityDescriptor.cpp - implementation file for CSecureShare class.

 *

*  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
 *
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "secureshare.h"
#include "tokenprivilege.h"
#include <windef.h>
#include <lmcons.h>
#include <lmshare.h>
#include "wbemnetapi32.h"


#ifdef NTONLY
///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureShare::CSecureShare
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureShare::CSecureShare()
:	CSecurityDescriptor(),
	m_strFileName()
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureShare::CSecureShare
//
//	Alternate Class CTOR
//
//	Inputs:
//				LPCTSTR		pszFileName - The FileName to handle
//							security for.
//				BOOL		fGetSACL - Should we get the SACL?
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureShare::CSecureShare( PSECURITY_DESCRIPTOR pSD)
:	CSecurityDescriptor(pSD)
{
//	SetFileName( pszFileName );
}


CSecureShare::CSecureShare( CHString& chsShareName)
:	CSecurityDescriptor()
{
	SetShareName( chsShareName);
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureShare::~CSecureShare
//
//	Class Destructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureShare::~CSecureShare( void )
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureShare::SetFileName
//
//	Public Entry point to set which file/directory this instance
//	of the class is to supply security for.
//
//	Inputs:
//				LPCTSTR		pszFileName - The FileName to handle
//							security for.
//				BOOL		fGetSACL - Should we get the SACL?
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
//	This will clear any previously set filenames and/or security
//	information.
//
///////////////////////////////////////////////////////////////////

DWORD CSecureShare::SetShareName( const CHString& chsShareName)
{
#ifdef WIN9XONLY
    return WBEM_E_FAILED;
#endif

#ifdef NTONLY

	_bstr_t bstrName ( chsShareName.AllocSysString(), false ) ;
	SHARE_INFO_502 *pShareInfo502 = NULL ;
	DWORD dwError = ERROR_INVALID_PARAMETER ;

	CNetAPI32 NetAPI;
	try
	{
	if(	NetAPI.Init() == ERROR_SUCCESS			&&
		NetAPI.NetShareGetInfo(	NULL,
								(LPTSTR) bstrName,
								502,
								(LPBYTE *) &pShareInfo502) == NERR_Success )
	{

		//Sec. Desc. is not returned for IPC$ ,C$ ...shares for Admin purposes
		if(pShareInfo502->shi502_security_descriptor)
		{
			if(InitSecurity(pShareInfo502->shi502_security_descriptor) )
			{
				dwError = ERROR_SUCCESS ;
			}
		}

		NetAPI.NetApiBufferFree(pShareInfo502) ;
		pShareInfo502 = NULL ;
	}

	return dwError ;
	}
	catch ( ... )
	{
		if ( pShareInfo502 )
		{
			NetAPI.NetApiBufferFree(pShareInfo502) ;
			pShareInfo502 = NULL ;
		}

		throw ;
	}
#endif
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureShare::WriteAcls
//
//	Protected entry point called by CSecurityDescriptor when
//	a user Applies Security and wants to apply security for
//	the DACL and/or SACL.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security
//										descriptor to apply to
//										the file.
//				SECURITY_INFORMATION	securityinfo - Flags
//										indicating which ACL(s)
//										to set.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

#ifdef NTONLY
DWORD CSecureShare::WriteAcls( PSECURITY_DESCRIPTOR pAbsoluteSD, SECURITY_INFORMATION securityinfo )
{
	DWORD		dwError = ERROR_SUCCESS;

	// We must have the security privilege enabled in order to access the object's SACL
/*	CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
	BOOL			fDisablePrivilege = FALSE;

	if ( securityinfo & SACL_SECURITY_INFORMATION )
	{
		fDisablePrivilege = ( securityPrivilege.Enable() == ERROR_SUCCESS );
	}

	if  ( !::SetFileSecurity( m_strFileName,
							securityinfo,
							pAbsoluteSD ) )
	{
		dwError = ::GetLastError();
	}

	// Cleanup the Name Privilege as necessary.
	if ( fDisablePrivilege )
	{
		securityPrivilege.Enable(FALSE);
	}

*/	return dwError;
}
#endif

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureShare::WriteOwner
//
//	Protected entry point called by CSecurityDescriptor when
//	a user Applies Security and wants to apply security for
//	the owner.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security
//										descriptor to apply to
//										the file.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSecureShare::WriteOwner( PSECURITY_DESCRIPTOR pAbsoluteSD )
{
	DWORD		dwError = ERROR_SUCCESS;

	// Open with the appropriate access, set the security and leave

/*	if ( !::SetFileSecurity( m_strFileName,
								OWNER_SECURITY_INFORMATION,
								pAbsoluteSD ) )
	{
		dwError = ::GetLastError();
	}

*/	return dwError;
}

DWORD CSecureShare::AllAccessMask( void )
{
	// File specific All Access Mask
	return FILE_ALL_ACCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\securitydescriptor.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*
 *	SecurityDescriptor.cpp - implementation file for CSecurityDescriptor class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#include "precomp.h"
#include <assertbreak.h>

#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "aclapi.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"					// CSACL class


#include "SecurityDescriptor.h"
#include "TokenPrivilege.h"
#include "AdvApi32Api.h"
#include "accctrl.h"
#include "wbemnetapi32.h"
#include "SecUtils.h"


/*
 *	This constructor is the default
 */

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::CSecurityDescriptor
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecurityDescriptor::CSecurityDescriptor()
:	m_pOwnerSid( NULL ),
	m_pGroupSid( NULL ),
	m_pSACL( NULL ),
    m_pDACL(NULL),
    m_fOwnerDefaulted( false ),
    m_fGroupDefaulted( false ),
    m_fDACLDefaulted( false ),
    m_fSACLDefaulted( false ),
    m_fDaclAutoInherited( false ),
    m_fSaclAutoInherited( false ),
    m_SecurityDescriptorControl(0)
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::CSecurityDescriptor
//
//	Alternate class constructor.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	psd - descriptor to initialize
//										from.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecurityDescriptor::CSecurityDescriptor( PSECURITY_DESCRIPTOR psd )
:	m_pOwnerSid( NULL ),
	m_pGroupSid( NULL ),
	m_pSACL( NULL ),
    m_pDACL(NULL),
    m_fOwnerDefaulted( false ),
    m_fGroupDefaulted( false ),
    m_fDACLDefaulted( false ),
    m_fSACLDefaulted( false ),
    m_fDaclAutoInherited( false ),
    m_fSaclAutoInherited( false ),
    m_SecurityDescriptorControl(0)
{
	InitSecurity( psd );
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::CSecurityDescriptor
//
//	Alternate class constructor.
//
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
CSecurityDescriptor::CSecurityDescriptor
(
    CSid* a_psidOwner,
    bool a_fOwnerDefaulted,
    CSid* a_psidGroup,
    bool a_fGroupDefaulted,
    CDACL* a_pDacl,
    bool a_fDaclDefaulted,
    bool a_fDaclAutoInherited,
    CSACL* a_pSacl,
    bool a_fSaclDefaulted,
    bool a_fSaclAutoInherited
)
:   m_pOwnerSid( NULL ),
	m_pGroupSid( NULL ),
	m_pSACL( NULL ),
    m_pDACL(NULL),
    m_fOwnerDefaulted( false ),
    m_fGroupDefaulted( false ),
    m_fDACLDefaulted( false ),
    m_fSACLDefaulted( false ),
    m_fDaclAutoInherited( false ),
    m_fSaclAutoInherited( false ),
    m_SecurityDescriptorControl(0)
{
	try
	{
		bool fRet = true;
		if(a_psidOwner != NULL )
		{
			fRet = (SetOwner(*a_psidOwner) == ERROR_SUCCESS);
			if(fRet)
			{
				m_fOwnerDefaulted = a_fOwnerDefaulted;
			}
		}

		if(fRet)
		{
			if(a_psidGroup != NULL )
			{
				fRet = (SetGroup(*a_psidGroup) == ERROR_SUCCESS);
				if(fRet)
				{
					m_fGroupDefaulted = a_fGroupDefaulted;
				}
			}
		}

		if(fRet)
		{
			// Handle the DACL
			if(a_pDacl != NULL)
			{
				fRet = InitDACL(a_pDacl);
				if(fRet)
				{
					m_fDACLDefaulted = a_fDaclDefaulted;
					m_fDaclAutoInherited = a_fDaclAutoInherited;
				}
			}
		}

		// Handle the SACL
		if(fRet)
		{
			if(a_pSacl != NULL)
			{
				fRet = InitSACL(a_pSacl);
				if(fRet)
				{
					m_fSACLDefaulted = a_fSaclDefaulted;
					m_fSaclAutoInherited = a_fSaclAutoInherited;
				}
			}
		}

		// Clean us up if something beefed
		if(!fRet)
		{
			Clear();
		}
	}
	catch(...)
	{
		Clear();
		throw;
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::~CSecurityDescriptor
//
//	Class Destructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecurityDescriptor::~CSecurityDescriptor( void )
{
	Clear();
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::IsNT5
//
//	Tells us if we're running on NT 5 or not, in which case
//	we need to do some special handling.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL			TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::InitSecurity
//
//	Initializes the class with data from the supplied security
//	descriptor.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	psd - Security Descriptor
//
//	Outputs:
//				None.
//
//	Returns:
//				TRUE/FALSE				Success/Failure.
//
//	Comments:
//
//	Keep this function protected so only derived classes have
//	access to laying waste to our internals.
//
///////////////////////////////////////////////////////////////////

BOOL CSecurityDescriptor::InitSecurity( PSECURITY_DESCRIPTOR psd )
{
	BOOL	fReturn = FALSE;
	PSID	psid = NULL;
	DWORD 	dwRevision = 0;
	SECURITY_DESCRIPTOR_CONTROL Control;
    BOOL bTemp;

	// Clean up existing values.
	Clear();

	// Get the security descriptor Owner Sid.
	fReturn = GetSecurityDescriptorOwner( psd, &psid, &bTemp );
	if ( fReturn )
	{
		// As long as we have a psid, intialize the owner member
		if ( NULL != psid )
		{
			if(SetOwner(CSid(psid)) != ERROR_SUCCESS)
            {
                fReturn = FALSE;
            }
		}
	}
	else
	{
		bTemp = FALSE;
	}

    bTemp ? m_fOwnerDefaulted = true : m_fOwnerDefaulted = false;

	fReturn = GetSecurityDescriptorGroup (psd, &psid, &bTemp );
	if ( fReturn )
	{
		// as long as we have a psid, initialize the group member
		if ( NULL != psid )
		{
            if(SetGroup(CSid(psid)) != ERROR_SUCCESS)
            {
                fReturn = FALSE;
            }
		}
	}
	else
	{
		bTemp = FALSE;
	}

    bTemp ? m_fGroupDefaulted = true : m_fGroupDefaulted = false;

	fReturn = GetSecurityDescriptorControl( psd, &Control, &dwRevision);
	if (fReturn)
	{
		SetControl( &Control );
		// BAD, BAD, BAD, BAD
	}

	// Handle the DACL and then the SACL
	if ( fReturn )
	{
		fReturn = InitDACL( psd );
	}

	if ( fReturn )
	{
		fReturn = InitSACL( psd );
	}

	// Clean us up if something beefed
	if ( !fReturn )
	{
		Clear();
	}

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::InitDACL
//
//	Initializes the DACL data member.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	psd - Security Descriptor
//
//	Outputs:
//				None.
//
//	Returns:
//				TRUE/FALSE				Success/Failure.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

BOOL CSecurityDescriptor::InitDACL ( PSECURITY_DESCRIPTOR psd )
{
	BOOL	fReturn			=	FALSE,
			fDACLPresent	=	FALSE,
			fDACLDefaulted	=	FALSE;

	PACL	pDACL = NULL;

	if ( GetSecurityDescriptorDacl( psd, &fDACLPresent, &pDACL,	&fDACLDefaulted ) )
	{
		ACE_HEADER*	pACEHeader	=	NULL;
		DWORD		dwAceIndex	=	0;
		BOOL		fGotACE		=	FALSE;

		// Be optimistic.  Shut up, be happy, etc.
		fReturn = TRUE;

		// Note that although fDACLPresent is SUPPOSED to tell us whether or not the
		// DACL is there, I'm seeing cases when this is returning TRUE, but the pDACL
		// value is NULL.  Not what the documenetation sez, but I'll take reality.

		if (fDACLPresent && (pDACL != NULL))
		{
			// Create a working dacl and initialize it with all ace entries...
            if(m_pDACL != NULL)
            {
                delete m_pDACL;
                m_pDACL = NULL;
            }

            try
            {
                m_pDACL = new CDACL;
            }
            catch(...)
            {
                if(m_pDACL != NULL)
                {
                    delete m_pDACL;
                    m_pDACL = NULL;
                }
                throw;
            }

            if(m_pDACL != NULL)
            {
                if(m_pDACL->Init(pDACL) == ERROR_SUCCESS)
                {
                    fReturn = TRUE;
                    // Allocated a dacl for that type only if an entry of that type was present.

                    // If we had an empty dacl (dacl present, yet empty), we won't have allocated
                    // any dacls in the array m_rgDACLPtrArray.  This won't be confused with a NULL
                    // DACL, as this module knows that it always represents a NULL DACL as all of
                    // the elements of m_rgDACLPtrArray as null except for ACCESS_ALLOWED_OBJECT,
                    // which will have one entry - namely, the Everyone ace.
                }
            }
		}	// IF fDACL Present
		else
		{
			if(m_pDACL != NULL)
            {
                delete m_pDACL;
                m_pDACL = NULL;
            }

            try
            {
                m_pDACL = new CDACL;
            }
            catch(...)
            {
                if(m_pDACL != NULL)
                {
                    delete m_pDACL;
                    m_pDACL = NULL;
                }
                throw;
            }

            if(m_pDACL != NULL)
            {
                fReturn = m_pDACL->CreateNullDACL();	// No DACL, so gin up an Empty Dacl
            }
		}

	}	// IF Got DACL

	return fReturn;
}

// Another version
bool CSecurityDescriptor::InitDACL( CDACL* a_pDACL )
{
    bool fRet = false;
    if (a_pDACL != NULL)
	{
		// Create a working dacl and initialize it with all ace entries...
        if(m_pDACL != NULL)
        {
            delete m_pDACL;
            m_pDACL = NULL;
        }

        try
        {
            m_pDACL = new CDACL;
        }
        catch(...)
        {
            if(m_pDACL != NULL)
            {
                delete m_pDACL;
                m_pDACL = NULL;
            }
            throw;
        }

        if(m_pDACL != NULL)
        {
            if(m_pDACL->CopyDACL(*a_pDACL))
            {
                fRet = true;
                // Allocated a dacl for that type only if an entry of that type was present.

                // If we had an empty dacl (dacl present, yet empty), we won't have allocated
                // any dacls in the array m_rgDACLPtrArray.  This won't be confused with a NULL
                // DACL, as this module knows that it always represents a NULL DACL as all of
                // the elements of m_rgDACLPtrArray as null except for ACCESS_ALLOWED_OBJECT,
                // which will have one entry - namely, the Everyone ace.
            }
        }
	}	// IF fDACL Present
	else
	{
		if(m_pDACL != NULL)
        {
            delete m_pDACL;
            m_pDACL = NULL;
        }

        try
        {
            m_pDACL = new CDACL;
        }
        catch(...)
        {
            if(m_pDACL != NULL)
            {
                delete m_pDACL;
                m_pDACL = NULL;
            }
            throw;
        }

        if(m_pDACL != NULL)
        {
            fRet = m_pDACL->CreateNullDACL();	// No DACL, so gin up an Empty Dacl
        }
	}
    return fRet;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::InitSACL
//
//	Initializes the SACL data member.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	psd - Security Descriptor
//
//	Outputs:
//				None.
//
//	Returns:
//				TRUE/FALSE				Success/Failure.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

BOOL CSecurityDescriptor::InitSACL ( PSECURITY_DESCRIPTOR psd )
{
	BOOL	fReturn			=	FALSE,
			fSACLPresent	=	FALSE,
			fSACLDefaulted	=	FALSE;

	PACL	pSACL = NULL;

	if ( GetSecurityDescriptorSacl( psd, &fSACLPresent, &pSACL,	&fSACLDefaulted ) )
	{

		// Be optimistic.  Shut up, be happy, etc.
		fReturn = TRUE;

		// Note that although fSACLPresent is SUPPOSED to tell us whether or not the
		// SACL is there, I'm seeing cases when this is returning TRUE, but the pSACL
		// value is NULL.  Not what the documenetation sez, but I'll take reality
		// for a thousand, Alex.

		if (	fSACLPresent
			&&	NULL != pSACL )
		{
			// Allocate SACL although it may stay empty
            if(m_pSACL != NULL)
            {
                delete m_pSACL;
                m_pSACL = NULL;
            }

            try
            {
                m_pSACL = new CSACL;
            }
            catch(...)
            {
                if(m_pSACL != NULL)
                {
                    delete m_pSACL;
                    m_pSACL = NULL;
                }
                throw;
            }

            if(m_pSACL != NULL)
            {
                if(m_pSACL->Init(pSACL) == ERROR_SUCCESS)
                {
                    fReturn = TRUE;
                }
            }

		}	// IF fSACL Present
		else
		{
			fReturn = TRUE;	// No SACL, so no worries
		}

	}	// IF Got SACL

	return fReturn;
}

// Another version...
bool CSecurityDescriptor::InitSACL( CSACL* a_pSACL )
{
    bool fRet = false;

    if (a_pSACL != NULL)
	{
		// Allocate SACL although it may stay empty
        if(m_pSACL != NULL)
        {
            delete m_pSACL;
            m_pSACL = NULL;
        }

        try
        {
            m_pSACL = new CSACL;
        }
        catch(...)
        {
            if(m_pSACL != NULL)
            {
                delete m_pSACL;
                m_pSACL = NULL;
            }
            throw;
        }

        if(m_pSACL != NULL)
        {
            if(m_pSACL->CopySACL(*a_pSACL))
            {
                fRet = true;
            }
        }

	}	// IF fSACL Present
	else
	{
		fRet = true;	// No SACL, so no worries
	}

    return fRet;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::SecureObject
//
//	Private entry point function which takes an Absolute Security
//	Descriptor, and depending on the user supplied security
//	information flags, divvies the actual object security handling
//	out to the appropriate WriteOwner() and WriteAcls() virtual
//	functions.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security Descriptor
//				SECURITY_INFORMATION	securityinfo - Security flags.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD					ERROR_SUCCESS if ok.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSecurityDescriptor::SecureObject( PSECURITY_DESCRIPTOR pAbsoluteSD, SECURITY_INFORMATION securityinfo )
{
	DWORD	dwReturn = ERROR_SUCCESS;

	// We might need this guy to handle some special access stuff
	CTokenPrivilege	restorePrivilege( SE_RESTORE_NAME );

    //try to set the owner first, since setting the dacl may preclude setting the owner, depending on what access we set
	if ( securityinfo & OWNER_SECURITY_INFORMATION )
	{
		dwReturn = WriteOwner( pAbsoluteSD ) ;

        if ( ERROR_INVALID_OWNER == dwReturn )
		{
			// If we enable the privilege, retry setting the owner info
			if ( ERROR_SUCCESS == restorePrivilege.Enable() )
			{
				dwReturn = WriteOwner( pAbsoluteSD );

				// Clear the privilege
				restorePrivilege.Enable( FALSE );
			}
		}
	}

	// If we need to write sacl/dacl information, try to write that piece now
	if ( dwReturn == ERROR_SUCCESS && ( securityinfo & DACL_SECURITY_INFORMATION ||
                                        securityinfo & SACL_SECURITY_INFORMATION ||
                                        securityinfo & PROTECTED_DACL_SECURITY_INFORMATION ||
                                        securityinfo & PROTECTED_SACL_SECURITY_INFORMATION ||
                                        securityinfo & UNPROTECTED_DACL_SECURITY_INFORMATION ||
                                        securityinfo & UNPROTECTED_SACL_SECURITY_INFORMATION) )
	{
	    SECURITY_INFORMATION	daclsecinfo = 0;

	    // Fill out security information with only the appropriate DACL/SACL values.
	    if ( securityinfo & DACL_SECURITY_INFORMATION )
	    {
		    daclsecinfo |= DACL_SECURITY_INFORMATION;
	    }

	    if ( securityinfo & SACL_SECURITY_INFORMATION )
	    {
		    daclsecinfo |= SACL_SECURITY_INFORMATION;
	    }

#if NTONLY >= 5
        if(securityinfo & PROTECTED_DACL_SECURITY_INFORMATION)
        {
            daclsecinfo |= PROTECTED_DACL_SECURITY_INFORMATION;
        }
        if(securityinfo & PROTECTED_SACL_SECURITY_INFORMATION)
        {
            daclsecinfo |= PROTECTED_SACL_SECURITY_INFORMATION;
        }
        if(securityinfo & UNPROTECTED_DACL_SECURITY_INFORMATION)
        {
            daclsecinfo |= UNPROTECTED_DACL_SECURITY_INFORMATION;
        }
        if(securityinfo & UNPROTECTED_SACL_SECURITY_INFORMATION)
        {
            daclsecinfo |= UNPROTECTED_SACL_SECURITY_INFORMATION;
        }
#endif


        dwReturn = WriteAcls( pAbsoluteSD, daclsecinfo );
	}
	return dwReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::SetOwner
//
//	Sets the owner data member to the supplied SID.
//
//	Inputs:
//				CSid&		sid - New Owner.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD					ERROR_SUCCESS if ok.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSecurityDescriptor::SetOwner( CSid& sid )
{
	DWORD	dwError = ERROR_SUCCESS;

	// Make sure the new sid is valid
	if ( sid.IsValid() )
	{

		// We will write in the sid, if the Owner is NULL, or the
		// sids are not equal.

		if (	NULL == m_pOwnerSid
			||	!( *m_pOwnerSid == sid ) )
		{

			if ( NULL != m_pOwnerSid )
			{
				delete m_pOwnerSid;
			}

            m_pOwnerSid = NULL;
            try
            {
			    m_pOwnerSid = new CSid( sid );
            }
            catch(...)
            {
                if(m_pOwnerSid != NULL)
                {
                    delete m_pOwnerSid;
                    m_pOwnerSid = NULL;
                }
                throw;
            }

			if ( NULL == m_pOwnerSid )
			{
				dwError = ERROR_NOT_ENOUGH_MEMORY;
			}
			else
			{
				m_fOwnerDefaulted = FALSE;
			}

		}	// IF NULL == m_pOwnerSid || !SidsEqual

	}	// IF IsValidSid
	else
	{
		dwError = ::GetLastError();
	}

	return dwError;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::SetGroup
//
//	Sets the group data member to the supplied SID.
//
//	Inputs:
//				CSid&		sid - New Group.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD					ERROR_SUCCESS if ok.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSecurityDescriptor::SetGroup( CSid& sid )
{
	DWORD	dwError = ERROR_SUCCESS;

	// Make sure the new sid is valid
	if ( sid.IsValid() )
	{

		// We will write in the sid, if the Owner is NULL, or the
		// sids are not equal.

		if (	NULL == m_pGroupSid
			||	!( *m_pGroupSid == sid ) )
		{

			if ( NULL != m_pGroupSid )
			{
				delete m_pGroupSid;
			}

            m_pGroupSid = NULL;
            try
            {
			    m_pGroupSid = new CSid( sid );
            }
            catch(...)
            {
                if(m_pGroupSid != NULL)
                {
                    delete m_pGroupSid;
                    m_pGroupSid = NULL;
                }
                throw;
            }


			if ( NULL == m_pGroupSid )
			{
				dwError = ERROR_NOT_ENOUGH_MEMORY;
			}
			else
			{
				m_fGroupDefaulted = FALSE;
			}

		}	// IF NULL == m_pOwnerSid || !SidsEqual

	}	// IF IsValidSid
	else
	{
		dwError = ::GetLastError();
	}

	return dwError;

}




///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::AddDACLEntry
//
//	Adds an entry to our DACL.  Replaces an
//	existing entry if it meets the matching criteria.
//
//	Inputs:
//				CSid&		sid - Sid for the entry.
//				DWORD		dwAccessMask - The access mask
//				BOOL		bACEFlags - ACE Flags.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::AddDACLEntry( CSid& sid, DACL_Types DaclType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool fReturn = false;

    if(m_pDACL == NULL)
    {
        try
        {
            m_pDACL = new CDACL;
        }
        catch(...)
        {
            if(m_pDACL != NULL)
            {
                delete m_pDACL;
                m_pDACL = NULL;
            }
            throw;
        }
        if(m_pDACL != NULL)
        {
            fReturn = m_pDACL->AddDACLEntry(sid.GetPSid(), DaclType, dwAccessMask, bACEFlags, pguidObjGuid, pguidInhObjGuid);
        }
    }
    else
    {
        fReturn = m_pDACL->AddDACLEntry(sid.GetPSid(), DaclType, dwAccessMask, bACEFlags, pguidObjGuid, pguidInhObjGuid);
    }

    return fReturn;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::AddSACLEntry
//
//	Adds an entry to our SACL.  Replaces an
//	existing entry if it meets the matching criteria.
//
//	Inputs:
//				CSid&		sid - Sid for the entry.
//				DWORD		dwAccessMask - The access mask
//				BOOL		bACEFlags - ACE Flags.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::AddSACLEntry( CSid& sid, SACL_Types SaclType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool fReturn = false;

    if(m_pSACL == NULL)
    {
        try
        {
            m_pSACL = new CSACL;
        }
        catch(...)
        {
            if(m_pSACL != NULL)
            {
                delete m_pSACL;
                m_pSACL = NULL;
            }
            throw;
        }
        if(m_pSACL != NULL)
        {
            fReturn = m_pSACL->AddSACLEntry(sid.GetPSid(), SaclType, dwAccessMask, bACEFlags, pguidObjGuid, pguidInhObjGuid);
        }
    }
    else
    {
        fReturn = m_pSACL->AddSACLEntry(sid.GetPSid(), SaclType, dwAccessMask, bACEFlags, pguidObjGuid, pguidInhObjGuid);
    }

    return fReturn;
}




///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::RemoveDACLEntry
//
//	Removes a DACL entry from our DACL.
//
//	Inputs:
//				CSid&		sid - Sid for the entry.
//				DWORD		dwAccessMask - The access mask
//				BOOL		bACEFlags - ACE Flags.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	The entry that is removed must match all specified criteria.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::RemoveDACLEntry( CSid& sid, DACL_Types DaclType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool			fReturn = false;

	if ( NULL != m_pDACL )
	{
		fReturn = m_pDACL->RemoveDACLEntry( sid, DaclType, dwAccessMask, bACEFlags, pguidObjGuid, pguidInhObjGuid );
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::RemoveDACLEntry
//
//	Removes a DACL entry from our DACL.
//
//	Inputs:
//				CSid&		sid - Sid for the entry.
//				BOOL		bACEFlags - ACE Flags.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	The entry that is removed must match only the specified criteria.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::RemoveDACLEntry( CSid& sid, DACL_Types DaclType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool			fReturn = false;

	if ( NULL != m_pDACL )
	{
		fReturn = m_pDACL->RemoveDACLEntry( sid, DaclType, bACEFlags, pguidObjGuid, pguidInhObjGuid );
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::RemoveDACLEntry
//
//	Removes a DACL entry from our DACL.
//
//	Inputs:
//				CSid&		sid - Sid for the entry.
//				DWORD		dwIndex - Index of entry.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Removes the dwIndex instance of a SID in the SACL.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::RemoveDACLEntry( CSid& sid, DACL_Types DaclType, DWORD dwIndex   )
{
	bool			fReturn = false;

	if ( NULL != m_pDACL )
	{
		fReturn = m_pDACL->RemoveDACLEntry( sid, DaclType, dwIndex );
	}

	return fReturn;
}



///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::RemoveSACLEntry
//
//	Removes a SACL entry from our SACL.
//
//	Inputs:
//				CSid&		sid - Sid for the entry.
//				DWORD		dwAccessMask - The access mask
//				BOOL		bACEFlags - ACE Flags.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	The entry that is removed must match all specified criteria.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::RemoveSACLEntry( CSid& sid, SACL_Types SaclType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool			fReturn = false;

	if ( NULL != m_pSACL )
	{
		fReturn = m_pSACL->RemoveSACLEntry( sid, SaclType, dwAccessMask, bACEFlags, pguidObjGuid, pguidInhObjGuid );
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::RemoveSACLEntry
//
//	Removes a SACL entry from our SACL.
//
//	Inputs:
//				CSid&		sid - Sid for the entry.
//				BOOL		bACEFlags - ACE Flags.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	The entry that is removed must match only the specified criteria.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::RemoveSACLEntry( CSid& sid, SACL_Types SaclType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool			fReturn = false;

	if ( NULL != m_pSACL )
	{
		fReturn = m_pSACL->RemoveSACLEntry( sid, SaclType, bACEFlags, pguidObjGuid, pguidInhObjGuid );
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::RemoveSACLEntry
//
//	Removes a SACL entry from our SACL.
//
//	Inputs:
//				CSid&		sid - Sid for the entry.
//				DWORD		dwIndex - Index of entry.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Removes the dwIndex instance of a SID in the SACL.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::RemoveSACLEntry( CSid& sid, SACL_Types SaclType, DWORD dwIndex   )
{
	bool			fReturn = false;

	if ( NULL != m_pSACL )
	{
		fReturn = m_pSACL->RemoveSACLEntry( sid, SaclType, dwIndex );
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::FindACE
//
//	Locates an ACE in either the SACL or DACL based on the supplied
//	criteria.
//
//	Inputs:
//				const CSid&		sid - Sid for the entry.
//				BYTE			bACEType - ACE Type
//				DWORD			dwMask - Access Mask
//				BYTE			bACEFlags - Flags
//
//	Outputs:
//				CAccessEntry&	ace - Filled out with located values.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Locates an ACE that matches ALL supplied criteria
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::FindACE( const CSid& sid, BYTE bACEType, DWORD dwMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, CAccessEntry& ace  )
{
	bool fReturn = false;

	if ( SYSTEM_AUDIT_ACE_TYPE        == bACEType ||
         SYSTEM_AUDIT_OBJECT_ACE_TYPE == bACEType /*   ||
         SYSTEM_ALARM_ACE_TYPE        == bACEType      ||  <- ALARM ACE TYPES NOT YET SUPPORTED UNDER W2K
         SYSTEM_ALARM_OBJECT_ACE_TYPE == bACEType */ )
	{
		if ( NULL != m_pSACL )
		{
			fReturn = m_pSACL->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwMask, ace );
		}
	}
	else
	{
        if ( NULL != m_pDACL )
		{
			fReturn = m_pDACL->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwMask, ace );
		}
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::FindACE
//
//	Locates an ACE in either the SACL or DACL based on the supplied
//	criteria.
//
//	Inputs:
//				const CSid&		sid - Sid for the entry.
//				BYTE			bACEType - ACE Type
//				BYTE			bACEFlags - Flags
//
//	Outputs:
//				CAccessEntry&	ace - Filled out with located values.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Locates an ACE that matches ALL supplied criteria
//
///////////////////////////////////////////////////////////////////
bool CSecurityDescriptor::FindACE( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace  )
{
	bool fReturn = false;

	if ( SYSTEM_AUDIT_ACE_TYPE        == bACEType ||
         SYSTEM_AUDIT_OBJECT_ACE_TYPE == bACEType ||
         SYSTEM_ALARM_ACE_TYPE        == bACEType ||
         SYSTEM_ALARM_OBJECT_ACE_TYPE == bACEType)
	{
		if ( NULL != m_pSACL )
		{
			fReturn = m_pSACL->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
		}
	}
	else
	{
        if ( NULL != m_pDACL )
		{
			fReturn = m_pDACL->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
		}
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::ApplySecurity
//
//	Using the user specified flags, builds an appropriate descriptor
//	and loads it with the necessary information, then passes this
//	descriptor off to SecureObject() which will farm out the
//	actual setting of security to the virtual Write functions.
//
//	Inputs:
//				SECURITY_INFORMATION	securityinfo	- flags to control
//										how the descriptor is used.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD					ERROR_SUCCESS if successful.
//
//	Comments:
//
//	This should be the only public method for applying security
//	to an object.
//
///////////////////////////////////////////////////////////////////

DWORD CSecurityDescriptor::ApplySecurity( SECURITY_INFORMATION securityinfo )
{
	DWORD	dwError		=	ERROR_SUCCESS;

	PSID	pOwnerSid	=	NULL;
	PACL	pDacl		=	NULL,
			pSacl		=	NULL;

	// Allocate and initialize the security descriptor
	PSECURITY_DESCRIPTOR	pAbsoluteSD = NULL;
    try
    {
        pAbsoluteSD = new SECURITY_DESCRIPTOR;
    }
    catch(...)
    {
        if(pAbsoluteSD != NULL)
        {
            delete pAbsoluteSD;
            pAbsoluteSD = NULL;
        }
        throw;
    }

	if ( NULL != pAbsoluteSD )
	{
		if ( !InitializeSecurityDescriptor( pAbsoluteSD, SECURITY_DESCRIPTOR_REVISION ) )
		{
			dwError = ::GetLastError();
		}
	}
	else
	{
		dwError = ERROR_NOT_ENOUGH_MEMORY;
	}

	// If we're supposed to set the owner, place the sid from the internal
	// value in the absoluteSD.

	if (	ERROR_SUCCESS == dwError
		&&	securityinfo & OWNER_SECURITY_INFORMATION )
	{
		if ( NULL != m_pOwnerSid )
		{
			pOwnerSid = m_pOwnerSid->GetPSid();
		}

		if ( !SetSecurityDescriptorOwner( pAbsoluteSD, pOwnerSid, m_fOwnerDefaulted ) )
		{
			dwError = ::GetLastError();
		}
	}

	// If we're supposed to set the DACL, this is a non-trivial operation so
	// call out for reinforcements.

	if (	ERROR_SUCCESS == dwError
		&&	securityinfo & DACL_SECURITY_INFORMATION || securityinfo & PROTECTED_DACL_SECURITY_INFORMATION || securityinfo & UNPROTECTED_DACL_SECURITY_INFORMATION
        &&  m_pDACL != NULL)
	{

		if ( ( dwError = m_pDACL->ConfigureDACL( pDacl ) ) == ERROR_SUCCESS )
		{

			if ( !SetSecurityDescriptorDacl( pAbsoluteSD,
											( NULL != pDacl ),	// Set Dacl present flag
											pDacl,
											m_fDACLDefaulted ) )
			{
				dwError = ::GetLastError();
			}

		}

	}

	// If we're supposed to set the SACL, this also is a non-trivial operation so
	// call out for reinforcements.

	if (ERROR_SUCCESS == dwError)
    {
        if((securityinfo & SACL_SECURITY_INFORMATION || securityinfo & PROTECTED_SACL_SECURITY_INFORMATION || securityinfo & UNPROTECTED_SACL_SECURITY_INFORMATION)
           &&  (m_pSACL != NULL))
	    {

		    if ( ( dwError = m_pSACL->ConfigureSACL( pSacl ) ) == ERROR_SUCCESS )
		    {

			    if ( !SetSecurityDescriptorSacl( pAbsoluteSD,
											    ( NULL != pSacl ),	// Set Sacl present flag
											    pSacl,
											    m_fSACLDefaulted ) )
			    {
				    dwError = ::GetLastError();
			    }

		    }
        }
	}


	// If we're OK, let the object try to secure itself, the default implementation
	// fails with ERROR_INVALID_FUNCTION.

	if ( ERROR_SUCCESS == dwError )
	{
		ASSERT_BREAK( IsValidSecurityDescriptor( pAbsoluteSD ) );
		dwError = SecureObject( pAbsoluteSD, securityinfo );
	}

	// Clean up allocated memory
	if ( NULL != pAbsoluteSD )
	{
		delete pAbsoluteSD;
	}

	if ( NULL != pDacl )
	{
		// This guy gets malloced in ConfigureDACL
		free( pDacl );
	}

	if ( NULL != pSacl )
	{
		// This guy gets malloced in ConfigureSACL
		free( pSacl );
	}

	return dwError;
}




///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::Clear
//
//	Empties out our class, freeing up all allocated memory.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

void CSecurityDescriptor::Clear( void )
{
	if ( NULL != m_pOwnerSid )
	{
		delete m_pOwnerSid;
		m_pOwnerSid = NULL;
	}

	m_fOwnerDefaulted = FALSE;

    if ( NULL != m_pDACL )
	{
		delete m_pDACL;
		m_pDACL = NULL;
	}

	if ( NULL != m_pSACL )
	{
		delete m_pSACL;
		m_pSACL = NULL;
	}

	if ( NULL != m_pGroupSid )
	{
		delete m_pGroupSid;
		m_pGroupSid = NULL;
	}

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::GetDACL
//
//	Makes a copy of our DACL entries and places them in the supplied
//	DACL, in proper canonical order.
//
//	Inputs:
//				None.
//
//	Outputs:
//				CDACL&		DACL - Dacl to copy into.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::GetDACL ( CDACL&	DACL )
{
    bool fRet = false;
    if(m_pDACL != NULL)
    {
        fRet = DACL.CopyDACL( *m_pDACL );
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::GetSACL
//
//	Makes a copy of our SACL entries and places them in the supplied
//	SACL.
//
//	Inputs:
//				None.
//
//	Outputs:
//				CSACL&		SACL - Sacl to copy into.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::GetSACL ( CSACL&	SACL )
{
    bool fRet = false;
    if(m_pSACL != NULL)
    {
        fRet = SACL.CopySACL( *m_pSACL );
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::EmptyDACL
//
//	Clears our DACL lists, allocating them if they DO NOT exist.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Remember, an empty DACL is different from a NULL DACL, in that
//	empty means nobody has access and NULL means everyone has
//	full control.
//
///////////////////////////////////////////////////////////////////

void CSecurityDescriptor::EmptyDACL()
{
    if(m_pDACL != NULL)
    {
        m_pDACL->Clear();
    }
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::EmptySACL
//
//	Clears our SACL lists, allocating it if it DOES NOT exist
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	In the case of a sacl, there is no distinction between a NULL
//  and an Empty. So we will consider this sacl Empty if its data
//  member is NULL.
//
///////////////////////////////////////////////////////////////////

void CSecurityDescriptor::EmptySACL()
{
    if(m_pSACL != NULL)
    {
        m_pSACL->Clear();
    }
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::ClearSACL
//
//	Deletes our SACL list.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	In the case of a sacl, there is no distinction between a NULL
//  and an Empty. So we will consider this sacl Empty if its data
//  member is NULL.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::MakeSACLNull()
{
	bool fReturn = false;
    if(m_pSACL == NULL)
    {
        try
        {
            m_pSACL = new CSACL;
        }
        catch(...)
        {
            if(m_pSACL != NULL)
            {
                delete m_pSACL;
                m_pSACL = NULL;
            }
            throw;
        }
        if(m_pSACL != NULL)
        {
            m_pSACL->Clear();
            fReturn = true;
        }
    }
    else
    {
        m_pSACL->Clear();
        m_pSACL->Clear();
        fReturn = true;
    }

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::MakeDACLNull
//
//	NULLs out our DACL Lists except for the ACCESS_ALLOWED_ACE_TYPE
//  list, which it clears, then enters an Everybody ace into.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Remember, an empty DACL is different from a NULL DACL, in that
//	empty means nobody has access and NULL means everyone has
//	full control.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::MakeDACLNull( void )
{
	bool fReturn = false;
    if(m_pDACL == NULL)
    {
        try
        {
            m_pDACL = new CDACL;
        }
        catch(...)
        {
            if(m_pDACL != NULL)
            {
                delete m_pDACL;
                m_pDACL = NULL;
            }
            throw;
        }
        if(m_pDACL != NULL)
        {
            m_pDACL->CreateNullDACL();
            fReturn = true;
        }
    }
    else
    {
        m_pDACL->Clear();
        fReturn = m_pDACL->CreateNullDACL();
        fReturn = true;
    }

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::IsNULLDACL
//
//	Checks our DACL Lists to see if we have a NULL DACL.  Which
//  means that all our lists are NULL, except for the
//  ACCESS_ALLOWED_ACE_TYPE list, which will have exactly one entry
//  in it - namely, an ACE for Everyone.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Remember, a NULL DACL is the same as "Everyone" has Full Control,
//	so if a single Access Allowed entry exists that meets these
//	criteria, we consider ourselves to be NULL.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::IsNULLDACL()
{
	bool fRet = false;
    if(m_pDACL != NULL)
    {
        fRet = m_pDACL->IsNULLDACL();
    }
    return fRet;
}


void CSecurityDescriptor::DumpDescriptor(LPCWSTR wstrFilename)
{
    CHString chstrTemp;

    Output(L"Security descriptor contents follow...", wstrFilename);
    // Output the control flags
    chstrTemp.Format(L"Control Flags (hex): %x", m_SecurityDescriptorControl);
    Output(chstrTemp, wstrFilename);

    // Ouput the owner
    Output(L"Owner contents: ", wstrFilename);
    if(m_pOwnerSid != NULL)
    {
        m_pOwnerSid->DumpSid(wstrFilename);
    }
    else
    {
        Output(L"(Owner is null)", wstrFilename);
    }


    // Output the group
    Output(L"Group contents: ", wstrFilename);
    if(m_pGroupSid != NULL)
    {
        m_pGroupSid->DumpSid(wstrFilename);
    }
    else
    {
        Output(L"(Group is null)", wstrFilename);
    }

    // Output the DACL
    Output(L"DACL contents: ", wstrFilename);
    if(m_pDACL != NULL)
    {
        m_pDACL->DumpDACL(wstrFilename);
    }
    else
    {
        Output(L"(DACL is null)", wstrFilename);
    }

    // Output the SACL
    Output(L"SACL contents: ", wstrFilename);
    if(m_pSACL != NULL)
    {
        m_pSACL->DumpSACL(wstrFilename);
    }
    else
    {
        Output(L"(SACL is null)", wstrFilename);
    }
}



///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::GetPSD
//
//	Takes our internal members and constructs a PSECURITY_DESCRIPTOR,
//      which the caller must free.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Remember, a NULL DACL is the same as "Everyone" has Full Control,
//	so if a single Access Allowed entry exists that meets these
//	criteria, we consider ourselves to be NULL.
//
///////////////////////////////////////////////////////////////////

DWORD CSecurityDescriptor::GetSelfRelativeSD(
	SECURITY_INFORMATION securityinfo,
	PSECURITY_DESCRIPTOR psd)
{
	DWORD	dwError		=	ERROR_SUCCESS;

	PSID	pOwnerSid	=	NULL;
	PACL	pDacl		=	NULL,
			pSacl		=	NULL;

	// Allocate and initialize the security descriptor
	PSECURITY_DESCRIPTOR	pAbsoluteSD = NULL;
    try
    {
        pAbsoluteSD = new SECURITY_DESCRIPTOR;
    }
    catch(...)
    {
        if(pAbsoluteSD != NULL)
        {
            delete pAbsoluteSD;
            pAbsoluteSD = NULL;
        }
        throw;
    }

	if ( NULL != pAbsoluteSD )
	{
		if ( !::InitializeSecurityDescriptor( pAbsoluteSD, SECURITY_DESCRIPTOR_REVISION ) )
		{
			dwError = ::GetLastError();
		}
	}
	else
	{
		dwError = ERROR_NOT_ENOUGH_MEMORY;
	}

	// If we're supposed to set the owner, place the sid from the internal
	// value in the absoluteSD.

	if (	ERROR_SUCCESS == dwError
		&&	securityinfo & OWNER_SECURITY_INFORMATION )
	{
		if ( NULL != m_pOwnerSid )
		{
			pOwnerSid = m_pOwnerSid->GetPSid();
		}

		if ( !::SetSecurityDescriptorOwner( pAbsoluteSD, pOwnerSid, m_fOwnerDefaulted ) )
		{
			dwError = ::GetLastError();
		}
	}

	// If we're supposed to set the DACL, this is a non-trivial operation so
	// call out for reinforcements.

	if (	ERROR_SUCCESS == dwError
		&&	securityinfo & DACL_SECURITY_INFORMATION || securityinfo & PROTECTED_DACL_SECURITY_INFORMATION || securityinfo & UNPROTECTED_DACL_SECURITY_INFORMATION
        &&  m_pDACL != NULL)
	{

		if ( ( dwError = m_pDACL->ConfigureDACL( pDacl ) ) == ERROR_SUCCESS )
		{

			if ( !::SetSecurityDescriptorDacl( pAbsoluteSD,
											( NULL != pDacl ),	// Set Dacl present flag
											pDacl,
											m_fDACLDefaulted ) )
			{
				dwError = ::GetLastError();
			}

		}

	}

	// If we're supposed to set the SACL, this also is a non-trivial operation so
	// call out for reinforcements.

	if (ERROR_SUCCESS == dwError)
    {
        if((securityinfo & SACL_SECURITY_INFORMATION || securityinfo & PROTECTED_SACL_SECURITY_INFORMATION || securityinfo & UNPROTECTED_SACL_SECURITY_INFORMATION)
           &&  (m_pSACL != NULL))
	    {

		    if ( ( dwError = m_pSACL->ConfigureSACL( pSacl ) ) == ERROR_SUCCESS )
		    {

				if ( !::SetSecurityDescriptorSacl( pAbsoluteSD,
											    ( NULL != pSacl ),	// Set Sacl present flag
											    pSacl,
											    m_fSACLDefaulted ) )
			    {
				    dwError = ::GetLastError();
			    }

		    }
        }
	}


	// If we're OK, let the object try to secure itself, the default implementation
	// fails with ERROR_INVALID_FUNCTION.

	if ( ERROR_SUCCESS == dwError )
	{
		ASSERT_BREAK( ::IsValidSecurityDescriptor( pAbsoluteSD ) );

		// Now make it self relative... Caller frees this...
		DWORD dwSize = 0L;
		if(!::MakeSelfRelativeSD(
			pAbsoluteSD,
			NULL,
			&dwSize) &&
			(dwError = ::GetLastError()) == ERROR_INSUFFICIENT_BUFFER)
		{
			PSECURITY_DESCRIPTOR pSelfRelSD = NULL;
			pSelfRelSD = new BYTE[dwSize];

			if(pSelfRelSD && 
				!::MakeSelfRelativeSD(
				pAbsoluteSD,
				pSelfRelSD,
				&dwSize))
			{
				dwError = ::GetLastError();
			}
			else
			{
				psd = pSelfRelSD;
				dwError = ERROR_SUCCESS;
			}
		}
	}

	// Clean up allocated memory
	if ( NULL != pAbsoluteSD )
	{
		delete pAbsoluteSD;
	}

	if ( NULL != pDacl )
	{
		// This guy gets malloced in ConfigureDACL
		free( pDacl );
	}

	if ( NULL != pSacl )
	{
		// This guy gets malloced in ConfigureSACL
		free( pSacl );
	}

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\securityapi.cpp ===
//=================================================================

//

// Ws2_32Api.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>


#include "DllWrapperBase.h"

#include "SecurityApi.h"
#include "DllWrapperCreatorReg.h"


// {C9369990-F3A8-4bac-A360-47BAA0EC47A0}
static const GUID g_guidSecurApi =
{ 0xc9369990, 0xf3a8, 0x4bac, { 0xa3, 0x60, 0x47, 0xba, 0xa0, 0xec, 0x47, 0xa0 } };

#if NTONLY >= 5
		static const TCHAR g_tstrSecur[] = _T("SECURITY.DLL");
#else
		static const TCHAR g_tstrSecur[] = _T("SECUR32.DLL");
#endif


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CSecurityApi, &g_guidSecurApi, g_tstrSecur> g_RegisteredCSecurityWrapper;


/******************************************************************************
 * Constructor
 ******************************************************************************/
CSecurityApi::CSecurityApi( LPCTSTR a_tstrWrappedDllName )
 : CDllWrapperBase( a_tstrWrappedDllName ),
   m_pfnInitSecurityInterface(NULL),
   m_pSecFuncTable(NULL)
{
}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CSecurityApi::~CSecurityApi()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CSecurityApi::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
        m_pfnInitSecurityInterface =
			(PSecurityFunctionTableW(WINAPI *)())GetProcAddress( "InitSecurityInterfaceW" );

		m_pSecFuncTable = (PSecurityFunctionTableW)((*m_pfnInitSecurityInterface)());


        // Check that we have function pointers to functions that should be
        // present in all versions of this dll...
        if(m_pfnInitSecurityInterface == NULL ||
           m_pSecFuncTable == NULL )
        {
            fRet = false;
            LogErrorMessage(L"Failed find entrypoint in securityapi");
        }
		else
		{
			fRet = true;
		}
    }
    return fRet;
}


/******************************************************************************
 * Member functions wrapping Ws2_32 api functions. Add new functions here
 * as required.
 ******************************************************************************/

//
SECURITY_STATUS CSecurityApi::AcquireCredentialsHandleW
(
SEC_WCHAR SEC_FAR	*a_pszPrincipal,    // Name of principal
SEC_WCHAR SEC_FAR	*a_pszPackage,      // Name of package
unsigned long		a_fCredentialUse,       // Flags indicating use
void SEC_FAR		*a_pvLogonId,           // Pointer to logon ID
void SEC_FAR		*a_pAuthData,           // Package specific data
SEC_GET_KEY_FN		a_pGetKeyFn,           // Pointer to GetKey() func
void SEC_FAR		*a_pvGetKeyArgument,    // Value to pass to GetKey()
PCredHandle			a_phCredential,           // (out) Cred Handle
PTimeStamp			a_ptsExpiry                // (out) Lifetime (optional)
)
{
	if( m_pSecFuncTable && m_pSecFuncTable->AcquireCredentialsHandleW )
	{
		return (*m_pSecFuncTable->AcquireCredentialsHandleW)(
								a_pszPrincipal,
								a_pszPackage,
								a_fCredentialUse,
								a_pvLogonId,
								a_pAuthData,
								a_pGetKeyFn,
								a_pvGetKeyArgument,
								a_phCredential,
								a_ptsExpiry ) ;
	}
	else
	{
		return E_POINTER ;
	}
}

//
SECURITY_STATUS CSecurityApi::QueryCredentialsAttributesW(
PCredHandle		a_phCredential,             // Credential to query
unsigned long	a_ulAttribute,          // Attribute to query
void SEC_FAR	*a_pBuffer              // Buffer for attributes
)
{
	if( m_pSecFuncTable && m_pSecFuncTable->QueryCredentialsAttributesW )
	{
		return (*m_pSecFuncTable->QueryCredentialsAttributesW)(
									a_phCredential,
									a_ulAttribute,
									a_pBuffer ) ;
	}
	else
	{
		return E_POINTER ;
	}
}

//
SECURITY_STATUS CSecurityApi::FreeCredentialsHandle(
PCredHandle a_phCredential            // Handle to free
)
{
	if( m_pSecFuncTable && m_pSecFuncTable->FreeCredentialsHandle )
	{
		return (*m_pSecFuncTable->FreeCredentialsHandle)(
									a_phCredential ) ;
	}
	else
	{
		return E_POINTER ;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\secutils.cpp ===
/*****************************************************************************/



/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /

/*****************************************************************************/



//=================================================================

//

// SecUtils.cpp -- Security utilities useful to wbem mof classes

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/9/99    a-kevhu        Created
//
//=================================================================


#include "precomp.h"
#include <assertbreak.h>
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "SecurityDescriptor.h"
#include <accctrl.h>
#include "AccessRights.h"
#include "SecureFile.h"
#include "SecureShare.h"
#include "wbemnetapi32.h"
#include "SecUtils.h"

///////////////////////////////////////////////////////////////////
//
//	Function:	FillTrusteeFromSid
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
void FillTrusteeFromSid (CInstance *pInstance, CSid &sid)
{
	if (pInstance)
	{
		PSID pSid;
		CHString chstrName;
		CHString chstrDomain;
		VARIANT vValue;


		if (sid.IsValid())
		{
			pSid = sid.GetPSid();
			chstrName = sid.GetAccountName();
			chstrDomain = sid.GetDomainName();

			// set the UINT8 array for the pSid
			DWORD dwSidLength = sid.GetLength();
 //			BYTE bByte;
			SAFEARRAY* sa;
			SAFEARRAYBOUND rgsabound[1];
            VariantInit(&vValue);
			rgsabound[0].cElements = dwSidLength;

			PSID pSidTrustee = NULL ;

			rgsabound[0].lLbound = 0;
			sa = SafeArrayCreate(VT_UI1, 1, rgsabound);

 		     // Get a pointer to read the data into
      		SafeArrayAccessData(sa, &pSidTrustee);
      		memcpy(pSidTrustee, pSid, rgsabound[0].cElements);
      		SafeArrayUnaccessData(sa);

			// Put the safearray into a variant, and send it off
			V_VT(&vValue) = VT_UI1 | VT_ARRAY; V_ARRAY(&vValue) = sa;
			pInstance->SetVariant(IDS_Sid, vValue);

			VariantClear(&vValue);

			// fill in the rest of the stuff.
			if(!chstrName.IsEmpty())
			{
				pInstance->SetCHString(IDS_Name, chstrName);
			}

			if(!chstrDomain.IsEmpty())
			{
				pInstance->SetCHString(IDS_Domain, chstrDomain);
			}

            pInstance->SetDWORD(IDS_SidLength, dwSidLength);

            // Fill in the SIDString property...
            pInstance->SetCHString(IDS_SIDString, sid.GetSidString());

		}
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	FillInstanceDACL
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
void FillInstanceDACL(CInstance *pInstance, CDACL &dacl)
{
	CAccessEntry ace;
	SAFEARRAY* saDACL;
	SAFEARRAYBOUND rgsabound[1];
	VARIANT vValue;


	if ( pInstance && !dacl.IsEmpty() )
	{
		// First need merged list...
        CAccessEntryList t_cael;
        if(dacl.GetMergedACL(t_cael))
        {
		    DWORD dwSize;
		    long ix[1];
		    dwSize = t_cael.NumEntries();

            rgsabound[0].cElements = dwSize;
		    rgsabound[0].lLbound = 0;
		    saDACL = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
		    ix[0] = 0;

		    ACLPOSITION pos;

		    t_cael.BeginEnum(pos);
		    while (t_cael.GetNext(pos, ace))
		    {
			    CInstancePtr pAce;
	            CInstancePtr pTrustee;
                // now that we have the ACE, let's create a Win32_ACE object so we can
			    // add it to the embedded object list.
			    if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Ace", &pAce, IDS_CimWin32Namespace ) ) )
			    {
				    // fill trustee from SID
				    CSid sid;
				    ace.GetSID(sid);
				    if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Trustee", &pTrustee, IDS_CimWin32Namespace )))
				    {

					    FillTrusteeFromSid(pTrustee, sid);
					    pAce->SetEmbeddedObject(IDS_Trustee, *pTrustee);
//					    pTrustee->Release() ;
				    }	// end if

				    DWORD dwAceType = ace.GetACEType();
				    DWORD dwAceFlags = ace.GetACEFlags();
				    DWORD dwAccessMask = ace.GetAccessMask ();

				    pAce->SetDWORD(IDS_AceType, dwAceType);
				    pAce->SetDWORD(IDS_AceFlags, dwAceFlags);
				    pAce->SetDWORD(IDS_AccessMask, dwAccessMask);

#ifdef NTONLY
#if NTONLY > 5
					// fill Guids
                    GUID guidObjType, guidInhObjType;
                    if(ace.GetObjType(guidObjType))
                    {
                        WCHAR wstrGuid[39];
                        if(::StringFromGUID2(&guidObjType, wstrGuid, 39))
                        {
                            pAce->SetWCHARSplat(IDS_GuidObjectType, wstrGuid);
                        }
                    }

                    if(ace.GetInhObjType(guidInhObjType))
                    {
                        WCHAR wstrGuid[39];
                        if(::StringFromGUID2(&guidInhObjType, wstrGuid, 39))
                        {
                            pAce->SetWCHARSplat(IDS_GuidInheritedObjectType, wstrGuid);
                        }
                    }
#endif
#endif

				    // Get the IUnknown of the Win32_ACE object.   Convert it to a
				    // variant of type VT_UNKNOWN.  Then, add the variant to the
				    // SafeArray.   Eventually, to add the list to the actual
				    // Win32_SecurityDescriptor object, we will be using SetVariant.
                    // Note: it is intentional that we are not decrementing the Addref
                    // done on pAce by the following call.
				    IWbemClassObjectPtr pClassObject(pAce->GetClassObjectInterface());
				    if ( pClassObject )
				    {

					    VARIANT v;
					    VariantInit(&v);

					    v.vt   = VT_UNKNOWN;
					    v.punkVal = pClassObject ;


					    SafeArrayPutElement(saDACL, ix, pClassObject);

					    VariantClear(&v);
				    }	// end if
			    }	// end if

			    ix[0]++ ;
		    }	// end while
            VariantInit(&vValue);
		    V_VT(&vValue) = VT_UNKNOWN | VT_ARRAY; V_ARRAY(&vValue) = saDACL;
		    pInstance->SetVariant(IDS_DACL, vValue);
		    VariantClear(&vValue);
		    t_cael.EndEnum(pos);
        }
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	FillInstanceSACL
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
void FillInstanceSACL(CInstance *pInstance, CSACL &sacl)
{
	CAccessEntry ace;
	CInstancePtr pAce;
	CInstancePtr pTrustee;
	SAFEARRAY* saSACL;
	SAFEARRAYBOUND rgsabound[1];
	VARIANT vValue;


	if ( pInstance && !sacl.IsEmpty() )
	{
        // First need merged list...
        CAccessEntryList t_cael;
        if(sacl.GetMergedACL(t_cael))
        {
		    DWORD dwSize;
		    long ix[1];
		    dwSize = t_cael.NumEntries();

		    rgsabound[0].cElements = dwSize;
		    rgsabound[0].lLbound = 0;
		    saSACL = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
		    ix[0] = 0;

		    ACLPOSITION pos;

		    t_cael.BeginEnum(pos);
		    while (t_cael.GetNext(pos, ace))
		    {
			    // now that we have the ACE, let's create a Win32_ACE object so we can
			    // add it to the embedded object list.
			    if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Ace", &pAce, IDS_CimWin32Namespace)))
			    {
				    // fill trustee from SID
				    CSid sid;
				    ace.GetSID(sid);
				    if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Trustee", &pTrustee, IDS_CimWin32Namespace )))
				    {

					    FillTrusteeFromSid(pTrustee, sid);
					    pAce->SetEmbeddedObject(IDS_Trustee, *pTrustee);
				    }	// end if

				    DWORD dwAceType = ace.GetACEType();
				    DWORD dwAceFlags = ace.GetACEFlags();
				    DWORD dwAccessMask = ace.GetAccessMask ();

				    pAce->SetDWORD(IDS_AceType, dwAceType);
				    pAce->SetDWORD(IDS_AceFlags, dwAceFlags);
				    pAce->SetDWORD(IDS_AccessMask, dwAccessMask);

#ifdef NTONLY
#if NTONLY > 5
					// fill Guids
                    GUID guidObjType, guidInhObjType;
                    if(ace.GetObjType(guidObjType))
                    {
                        WCHAR wstrGuid[39];
                        if(::StringFromGUID2(&guidObjType, wstrGuid, 39))
                        {
                            pAce->SetWCHARSplat(IDS_GuidObjectType, wstrGuid);
                        }
                    }

                    if(ace.GetInhObjType(guidInhObjType))
                    {
                        WCHAR wstrGuid[39];
                        if(::StringFromGUID2(&guidInhObjType, wstrGuid, 39))
                        {
                            pAce->SetWCHARSplat(IDS_GuidInheritedObjectType, wstrGuid);
                        }
                    }
#endif
#endif

				    // Get the IUnknown of the Win32_ACE object.   Convert it to a
				    // variant of type VT_UNKNOWN.  Then, add the variant to the
				    // SafeArray.   Eventually, to add the list to the actual
				    // Win32_SecurityDescriptor object, we will be using SetVariant
				    IWbemClassObjectPtr pClassObject(pAce->GetClassObjectInterface());
				    if ( pClassObject )
				    {

					    VARIANT v;
					    VariantInit(&v);

					    v.vt   = VT_UNKNOWN;
					    v.punkVal = pClassObject ;


					    SafeArrayPutElement(saSACL, ix, pClassObject);

					    VariantClear(&v);
				    }	// end if
			    }	// end if
			    ix[0]++ ;
		    }	// end while
            VariantInit(&vValue);
		    V_VT(&vValue) = VT_UNKNOWN | VT_ARRAY; V_ARRAY(&vValue) = saSACL;
		    pInstance->SetVariant(IDS_SACL, vValue);
		    VariantClear(&vValue);
		    t_cael.EndEnum(pos);
        }
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	FillDACLFromInstance
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
DWORD FillDACLFromInstance(CInstance *pInstance,
                           CDACL &dacl,
                           MethodContext *pMethodContext)
{
	IWbemClassObjectPtr piClassObject;
    piClassObject.Attach(pInstance->GetClassObjectInterface());
	DWORD dwStatus = ERROR_SUCCESS ;

	if(piClassObject)
	{
		VARIANT vDacl ;
		if(GetArray(piClassObject,IDS_DACL, vDacl, VT_UNKNOWN|VT_ARRAY) )
		{

			if( vDacl.vt != VT_NULL && vDacl.parray != NULL )
			{
				// walk DACL
				LONG lDimension = 1 ;
				LONG lLowerBound ;
				SafeArrayGetLBound ( vDacl.parray , lDimension , &lLowerBound ) ;
				LONG lUpperBound ;
				SafeArrayGetUBound ( vDacl.parray , lDimension , &lUpperBound ) ;

				for ( LONG lIndex = lLowerBound ; lIndex <= lUpperBound ; lIndex++ )
				{
					if( dwStatus != ERROR_SUCCESS )
					{
						break ;
					}
					IWbemClassObjectPtr pACEObject;
					SafeArrayGetElement ( vDacl.parray , &lIndex , &pACEObject ) ;
					// take out IWbemClassObject and cast it to a Win32_ACE object.
					if(pACEObject)
					{
						CInstance ACEInstance(pACEObject, pMethodContext);

						// create an AccessEntry object from the Win32_ACE object.

						bool bExists =false ;
						VARTYPE eType ;
						// get Win32_Trustee object from Win32_ACE ...& decipher the ACE
						if ( ACEInstance.GetStatus ( IDS_Trustee, bExists , eType ) && bExists && eType == VT_UNKNOWN )
						{
							CInstancePtr pTrustee;
							if ( ACEInstance.GetEmbeddedObject ( IDS_Trustee, &pTrustee, ACEInstance.GetMethodContext() ) )
							{
								CSid sid ;
								if((dwStatus = FillSIDFromTrustee(pTrustee, sid)) == ERROR_SUCCESS)
								{
									DWORD dwAceType, dwAceFlags, dwAccessMask ;
                                    CHString chstrInhObjGuid;
                                    GUID *pguidInhObjGuid = NULL;
                                    CHString chstrObjGuid;
                                    GUID *pguidObjGuid = NULL;

									ACEInstance.GetDWORD(IDS_AceType, dwAceType);
									ACEInstance.GetDWORD(IDS_AceFlags, dwAceFlags);
									ACEInstance.GetDWORD(IDS_AccessMask, dwAccessMask);

                                    // The OS doesn't seem to support 0x01000000 or 0x02000000, so we won't either.  We
                                    // will translate 0x02000000 into FILE_ALL_ACCESS, however (seems like the nice thing to do)
                                    // but only if that is the exact value they set.
                                    if(dwAccessMask == 0x02000000)
                                    {
                                        dwAccessMask = FILE_ALL_ACCESS;
                                    }

#if NTONLY >= 5
                                    // On NT5 and greater, if the user specified an ACE with the Ace Flag bit INHERIT_ACE set,
                                    // the OS will make these local, not inherited ACE entries.  However, the OS will not reorder
                                    // the DACL, possibly resulting in a situation in which denied ACEs (that had been inherited)
                                    // follow allowed ACEs.

                                    // So if the Ace flags specify INHERITED_ACE, we need to turn
                                    // off this bit...
                                    dwAceFlags &= ~INHERITED_ACE;
#endif
                                    if(!(dwAceFlags & INHERITED_ACE))
                                    {
									    switch (dwAceType)
									    {
									    case ACCESS_DENIED_ACE_TYPE:
										    {
											    dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_DENIED_ACE_TYPE, dwAccessMask, dwAceFlags, NULL, NULL );
											    break;
										    }
									    case ACCESS_ALLOWED_ACE_TYPE:
										    {
											    dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_ALLOWED_ACE_TYPE, dwAccessMask, dwAceFlags, NULL, NULL );
											    break;
										    }
#if NTONLY >= 5
                                        // Not yet supported under W2K
                                        //case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
										//    {
										//	    dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE, dwAccessMask, dwAceFlags, NULL, NULL );
										//	    break;
										//    }
                                        case ACCESS_DENIED_OBJECT_ACE_TYPE:
										    {
											    // Need to get the guids for this type...
                                                if(!ACEInstance.IsNull(IDS_ObjectTypeGUID) && ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid))
                                                {
                                                    if(chstrObjGuid.GetLength() != 0)
                                                    {
                                                        try
                                                        {
                                                            pguidObjGuid = new GUID;
                                                        }
                                                        catch(...)
                                                        {
                                                            if(pguidObjGuid != NULL)
                                                            {
                                                                delete pguidObjGuid;
                                                                pguidObjGuid = NULL;
                                                            }
                                                        }
                                                        CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                    }
                                                }
                                                if(!ACEInstance.IsNull(IDS_InheritedObjectGUID) && ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid))
                                                {
                                                    if(chstrInhObjGuid.GetLength() != 0)
                                                    {
                                                        try
                                                        {
                                                            pguidInhObjGuid = new GUID;
                                                        }
                                                        catch(...)
                                                        {
                                                            if(pguidInhObjGuid != NULL)
                                                            {
                                                                delete pguidInhObjGuid;
                                                                pguidInhObjGuid = NULL;
                                                            }
                                                        }
                                                        CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                    }
                                                }
                                                dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid);
                                                if(pguidObjGuid != NULL) delete pguidObjGuid;
                                                if(pguidInhObjGuid != NULL) delete pguidInhObjGuid;
											    break;
										    }
                                        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
										    {
                                                // Need to get the guids for this type...
                                                if(!ACEInstance.IsNull(IDS_ObjectTypeGUID) && ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid))
                                                {
                                                    if(chstrObjGuid.GetLength() != 0)
                                                    {
                                                        try
                                                        {
                                                            pguidObjGuid = new GUID;
                                                        }
                                                        catch(...)
                                                        {
                                                            if(pguidObjGuid != NULL)
                                                            {
                                                                delete pguidObjGuid;
                                                                pguidObjGuid = NULL;
                                                            }
                                                        }
                                                        CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                    }
                                                }
                                                if(!ACEInstance.IsNull(IDS_InheritedObjectGUID) && ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid))
                                                {
                                                    if(chstrInhObjGuid.GetLength() != 0)
                                                    {
                                                        try
                                                        {
                                                            pguidInhObjGuid = new GUID;
                                                        }
                                                        catch(...)
                                                        {
                                                            if(pguidInhObjGuid != NULL)
                                                            {
                                                                delete pguidInhObjGuid;
                                                                pguidInhObjGuid = NULL;
                                                            }
                                                        }
                                                        CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                    }
                                                }
                                                dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid);
                                                if(pguidObjGuid != NULL) delete pguidObjGuid;
                                                if(pguidInhObjGuid != NULL) delete pguidInhObjGuid;
											    break;
										    }
#endif
									    default:
										    {
											    dwStatus = ERROR_INVALID_PARAMETER ;
											    break ;
										    }
									    }
                                    }
                                    else
                                    {
                                        switch (dwAceType)
									    {
									    case ACCESS_DENIED_ACE_TYPE:
										    {
											    dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_DENIED_ACE_TYPE, dwAccessMask, dwAceFlags, NULL, NULL );
											    break;
										    }
									    case ACCESS_ALLOWED_ACE_TYPE:
										    {
											    dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_ALLOWED_ACE_TYPE, dwAccessMask, dwAceFlags, NULL, NULL );
											    break;
										    }
#if NTONLY >= 5
                                        // Not yet supported under W2K
                                        //case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
										//    {
										//	    dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE, dwAccessMask, dwAceFlags, NULL, NULL );
										//	    break;
										//    }
                                        case ACCESS_DENIED_OBJECT_ACE_TYPE:
										    {
											    // Need to get the guids for this type...
                                                if(!ACEInstance.IsNull(IDS_ObjectTypeGUID) && ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid))
                                                {
                                                    if(chstrObjGuid.GetLength() != 0)
                                                    {
                                                        try
                                                        {
                                                            pguidObjGuid = new GUID;
                                                        }
                                                        catch(...)
                                                        {
                                                            if(pguidObjGuid != NULL)
                                                            {
                                                                delete pguidObjGuid;
                                                                pguidObjGuid = NULL;
                                                            }
                                                        }
                                                        CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                    }
                                                }
                                                if(!ACEInstance.IsNull(IDS_InheritedObjectGUID) && ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid))
                                                {
                                                    if(chstrInhObjGuid.GetLength() != 0)
                                                    {
                                                        try
                                                        {
                                                            pguidInhObjGuid = new GUID;
                                                        }
                                                        catch(...)
                                                        {
                                                            if(pguidInhObjGuid != NULL)
                                                            {
                                                                delete pguidInhObjGuid;
                                                                pguidInhObjGuid = NULL;
                                                            }
                                                        }
                                                        CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                    }
                                                }
                                                dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                                if(pguidObjGuid != NULL) delete pguidObjGuid;
                                                if(pguidInhObjGuid != NULL) delete pguidInhObjGuid;
											    break;
										    }
                                        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
										    {
											    // Need to get the guids for this type...
                                                if(!ACEInstance.IsNull(IDS_ObjectTypeGUID) && ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid))
                                                {
                                                    if(chstrObjGuid.GetLength() != 0)
                                                    {
                                                        try
                                                        {
                                                            pguidObjGuid = new GUID;
                                                        }
                                                        catch(...)
                                                        {
                                                            if(pguidObjGuid != NULL)
                                                            {
                                                                delete pguidObjGuid;
                                                                pguidObjGuid = NULL;
                                                            }
                                                        }
                                                        CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                    }
                                                }
                                                if(!ACEInstance.IsNull(IDS_InheritedObjectGUID) && ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid))
                                                {
                                                    if(chstrInhObjGuid.GetLength() != 0)
                                                    {
                                                        try
                                                        {
                                                            pguidInhObjGuid = new GUID;
                                                        }
                                                        catch(...)
                                                        {
                                                            if(pguidInhObjGuid != NULL)
                                                            {
                                                                delete pguidInhObjGuid;
                                                                pguidInhObjGuid = NULL;
                                                            }
                                                        }
                                                        CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                    }
                                                }
                                                dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                                if(pguidObjGuid != NULL) delete pguidObjGuid;
                                                if(pguidInhObjGuid != NULL) delete pguidInhObjGuid;
											    break;
										    }
#endif
									    default:
										    {
											    dwStatus = ERROR_INVALID_PARAMETER ;
											    break ;
										    }
									    }
                                    }
								}
                                else
				                {
                                    dwStatus = ERROR_INVALID_PARAMETER;
				                }

                                //pTrustee->Release();  // smartpointer already releases when goes out of scope
							}
						}  // get Win32_Trustee object from Win32_ACE ...& decipher the ACE
					}
				} // end for loop
                if(lLowerBound == 0 && lUpperBound == -1L)
                {
                    // DACL was EMPTY - not necessarily wrong
                    dwStatus = STATUS_EMPTY_DACL;
                }
			}
			VariantClear( &vDacl ) ;
		}
		else //DACL was NULL - not nescessarily wrong.
		{
			 dwStatus = STATUS_NULL_DACL ;
		}
	}
	return dwStatus ;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	FillSACLFromInstance
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
DWORD FillSACLFromInstance(CInstance *pInstance,
                           CSACL &sacl,
                           MethodContext *pMethodContext)
{
	IWbemClassObjectPtr piClassObject;
    piClassObject.Attach(pInstance->GetClassObjectInterface());
	DWORD dwStatus = ERROR_SUCCESS ;

	if(piClassObject)
	{
		VARIANT vSacl ;
		if(GetArray(piClassObject, IDS_SACL, vSacl, VT_UNKNOWN|VT_ARRAY ) )
		{

			if( vSacl.vt != VT_NULL && vSacl.parray != NULL )
			{

				// walk DACL
				LONG lDimension = 1 ;
				LONG lLowerBound ;
				SafeArrayGetLBound ( vSacl.parray , lDimension , &lLowerBound ) ;
				LONG lUpperBound ;
				SafeArrayGetUBound ( vSacl.parray , lDimension , &lUpperBound ) ;

				for ( LONG lIndex = lLowerBound ; lIndex <= lUpperBound ; lIndex++ )
				{
					if( dwStatus != ERROR_SUCCESS )
					{
						break ;
					}
					IWbemClassObjectPtr pACEObject;
					SafeArrayGetElement ( vSacl.parray , &lIndex , &pACEObject ) ;
					// take out IWbemClassObject and cast it to a Win32_ACE object.
					if(pACEObject)
					{
						CInstance ACEInstance(pACEObject, pMethodContext);

						// create an AccessEntry object from the Win32_ACE object.

						bool bExists =false ;
						VARTYPE eType ;
						// get Win32_Trustee object from Win32_ACE ...& decipher the ACE
						if ( ACEInstance.GetStatus ( IDS_Trustee, bExists , eType ) && bExists && eType == VT_UNKNOWN )
						{

							CInstancePtr pTrustee;
							if ( ACEInstance.GetEmbeddedObject ( IDS_Trustee, &pTrustee, ACEInstance.GetMethodContext() ) )
							{

								CSid sid ;
								if(FillSIDFromTrustee(pTrustee, sid) == ERROR_SUCCESS)
								{

									DWORD dwAceType, dwAceFlags, dwAccessMask ;
                                    CHString chstrInhObjGuid;
                                    GUID *pguidInhObjGuid = NULL;
                                    CHString chstrObjGuid;
                                    GUID *pguidObjGuid = NULL;

									ACEInstance.GetDWORD(IDS_AceType, dwAceType);
									ACEInstance.GetDWORD(IDS_AceFlags, dwAceFlags);
									ACEInstance.GetDWORD(IDS_AccessMask, dwAccessMask);

									switch(dwAceType)
									{
                                    case SYSTEM_AUDIT_ACE_TYPE:
									    {
										    sacl.AddSACLEntry( sid.GetPSid(), ENUM_SYSTEM_AUDIT_ACE_TYPE, dwAccessMask, dwAceFlags, NULL, NULL );
                                            break;
									    }
#if NTONLY >= 5
                                    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
									    {
										    // Need to get the guids for this type...
                                            if(!ACEInstance.IsNull(IDS_ObjectTypeGUID) && ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid))
                                            {
                                                if(chstrObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidObjGuid != NULL)
                                                        {
                                                            delete pguidObjGuid;
                                                            pguidObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                }
                                            }
                                            if(!ACEInstance.IsNull(IDS_InheritedObjectGUID) && ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid))
                                            {
                                                if(chstrInhObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidInhObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidInhObjGuid != NULL)
                                                        {
                                                            delete pguidInhObjGuid;
                                                            pguidInhObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                }
                                            }
                                            sacl.AddSACLEntry( sid.GetPSid(), ENUM_SYSTEM_AUDIT_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                            if(pguidObjGuid != NULL) delete pguidObjGuid;
                                            if(pguidInhObjGuid != NULL) delete pguidInhObjGuid;
                                            break;
									    }
/********************************* type not yet supported under w2k ********************************************
                                    case SYSTEM_ALARM_ACE_TYPE:
									    {
										    sacl.AddSACLEntry( sid.GetPSid(), ENUM_SYSTEM_ALARM_ACE_TYPE, dwAccessMask, dwAceFlags, NULL, NULL );
                                            break;
									    }
/********************************* type not yet supported under w2k ********************************************

/********************************* type not yet supported under w2k ********************************************
                                    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
									    {
										    // Need to get the guids for this type...
                                            if(!ACEInstance.IsNull(IDS_ObjectTypeGUID) && ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid))
                                            {
                                                if(chstrObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidObjGuid != NULL)
                                                        {
                                                            delete pguidObjGuid;
                                                            pguidObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                }
                                            }
                                            if(!ACEInstance.IsNull(IDS_InheritedObjectGUID) && ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid))
                                            {
                                                if(chstrInhObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidInhObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidInhObjGuid != NULL)
                                                        {
                                                            delete pguidInhObjGuid;
                                                            pguidInhObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                }
                                            }
                                            sacl.AddSACLEntry( sid.GetPSid(), ENUM_SYSTEM_ALARM_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                            if(pguidObjGuid != NULL) delete pguidObjGuid;
                                            if(pguidInhObjGuid != NULL) delete pguidInhObjGuid;
                                            break;
									    }
/********************************* type not yet supported under w2k ********************************************/

#endif
									default:
									    {
										    dwStatus = ERROR_INVALID_PARAMETER ;
                                            break;
									    }
                                    }
								}
                                else
				                {
                                    dwStatus = ERROR_INVALID_PARAMETER;
				                }
                                //pTrustee->Release(); // smartpointer already releases when goes out of scope
							}

						}  // get Win32_Trustee object from Win32_ACE ...& decipher the ACE

					} //if(pACEObject)

				} //for
			}	//if(pSACL)

			VariantClear( &vSacl ) ;
		}
		else
		{
			dwStatus = ERROR_INVALID_PARAMETER ;
		}

	}

	return dwStatus ;
}

bool GetArray(IWbemClassObject *piClassObject,
              const CHString &name,
              VARIANT &v,
              VARTYPE eVariantType)
{
	bool bRet = FALSE;
	VariantInit(&v);

	if (piClassObject)
	{
		BSTR pName = NULL;
		HRESULT hr;
        try
        {
            pName = name.AllocSysString();


		    hr = piClassObject->Get(pName, 0, &v, NULL, NULL);
		    SysFreeString(pName);
        }
        catch(...)
        {
            if(pName != NULL)
            {
                SysFreeString(pName);
                pName = NULL;
            }
            throw;
        }

		ASSERT_BREAK((SUCCEEDED(hr)) && ((v.vt == VT_NULL) || (v.vt == eVariantType )));

		if (bRet = (bool)SUCCEEDED(hr))
		{
			if ( v.vt != VT_NULL && v.parray != NULL )
			{
                if (v.vt == eVariantType )
                {
					bRet = TRUE ;
                }
                else
                {
                    bRet = FALSE;
                }
			}
			else
			{
				bRet = FALSE;
			}
		}
	}


	if (!bRet)
	{
		VariantClear(&v);
	}

	return bRet;
}


DWORD FillSIDFromTrustee(CInstance *pTrustee, CSid &sid)
{
	IWbemClassObjectPtr m_piClassObject;
    DWORD dwStatus = ERROR_SUCCESS ;

    if(pTrustee)
    {
        m_piClassObject.Attach(pTrustee->GetClassObjectInterface());

	    VARIANT vtmp ;
        bool fSidObtained = false;
    
	    if(GetArray(m_piClassObject,IDS_SID,  vtmp, VT_UI1|VT_ARRAY ) )
	    {
		    if( vtmp.vt != VT_NULL && vtmp.parray != NULL )
		    {
			    if ( ::SafeArrayGetDim ( vtmp.parray ) == 1 )
			    {
				    long lLowerBound , lUpperBound = 0 ;

				    ::SafeArrayGetLBound ( vtmp.parray, 1, & lLowerBound ) ;
				    ::SafeArrayGetUBound ( vtmp.parray, 1, & lUpperBound ) ;

				    PSID pSid = NULL ;
				    PVOID pTmp = NULL ;
				    if(SUCCEEDED(::SafeArrayAccessData(vtmp.parray, &pTmp) ) )
				    {
					    pSid = (PSID) malloc(lUpperBound - lLowerBound + 1) ;
                        if(pSid)
                        {
                            try
                            {
					            memcpy(pSid,pTmp,lUpperBound - lLowerBound + 1) ;
					            ::SafeArrayUnaccessData(vtmp.parray) ;
					            sid = CSid(pSid);
					            free(pSid) ;
                                pSid = NULL;
                                fSidObtained = true;
                            }
                            catch(...)
                            {
                                free(pSid) ;
                                pSid = NULL;
                                throw;
                            }
                        }
                        else
                        {
                            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                        }
				    }
				    else
				    {
					    dwStatus = ERROR_INVALID_PARAMETER ;
				    }
			    }
			    else
			    {
				    dwStatus = ERROR_INVALID_PARAMETER ;
			    }
		    }
		    ::VariantClear( &vtmp ) ;
	    }
	    
        if(!fSidObtained && (dwStatus == ERROR_SUCCESS))
        {
            // If we couldn't obtain the sid from the binary
            // representation, try to do so from the sid string
            // representation (the SIDString property)...
            CHString chstrSIDString;

            if(pTrustee->GetCHString(IDS_SIDString, chstrSIDString) &&
                chstrSIDString.GetLength() > 0)
            {    
                PSID pSid = NULL;
                pSid = StrToSID(chstrSIDString);
                if(pSid)
                {
                    try
                    {
                        sid = CSid(pSid);
					    ::FreeSid(pSid); 
                        pSid = NULL;
                        fSidObtained = true;
                    }
                    catch(...)
                    {
                        ::FreeSid(pSid); 
                        pSid = NULL;
                        throw;
                    }
                }
                else
                {
                    dwStatus = ERROR_INVALID_PARAMETER;
                }
            }

            // If we couldn't obtain the sid from either the binary
            // representation or the SIDString representation, try to 
            // do so from the Domain and Name properties (attempting
            // resolution on the local machine for lack of a better
            // choice)...
            if(!fSidObtained && (dwStatus == ERROR_SUCCESS))
            {
                CHString chstrDomain, chstrName;

                pTrustee->GetCHString(IDS_Domain, chstrDomain);

                // Although we don't care whether we were able
                // to get the Domain above, we must at least have
                // a Name property specified...
                if(pTrustee->GetCHString(IDS_Name, chstrName) &&
                    chstrName.GetLength() > 0)
                {
                    CSid csTmp(chstrDomain, chstrName, NULL);
                    if(csTmp.IsOK() && csTmp.IsValid())
                    {
                        sid = csTmp;
                        fSidObtained = true;
                    }
                }
            }
        }

        if(!fSidObtained && (dwStatus == ERROR_SUCCESS))
	    {
		    dwStatus = ERROR_INVALID_PARAMETER ;
	    }
    }
    else
    {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

	return dwStatus ;
}

#ifdef NTONLY
// Handy utility to dump the contents of a descriptor to
// our log file.
void DumpWin32Descriptor(PSECURITY_DESCRIPTOR psd, LPCWSTR wstrFilename)
{
    CSecurityDescriptor csd(psd);
    csd.DumpDescriptor();
}
#endif

#ifdef NTONLY
void Output(LPCWSTR wstrOut, LPCWSTR wstrFilename)
{
    // Single point where we can control where output from
    // all security utility class Dump routines goes...
    if(wstrFilename == NULL)
    {
        LogMessage(wstrOut);
    }
    else
    {
        FILE *fp = NULL;
        if((fp = _wfopen(wstrFilename, L"at")) != NULL)
        {
            fwprintf(fp, wstrOut);
            fwprintf(fp,L"\r\n");
			fclose(fp);
        }
        fp = NULL;
    }
}
#endif


// Returns true if the user associated with the current
// thread is either the owner or is a member of the group
// that is the owner - e.g., it returns true if said user
// has ownership of the object specified by chstrName.
#ifdef NTONLY
bool AmIAnOwner(const CHString &chstrName, SE_OBJECT_TYPE ObjectType)
{
    bool fRet = false;

    // ALGORITHM OVERVIEW
    // 1) Get the sid of the user associated with the current thread.

    // 2) Get the owner of the object.

    // 3a) Compare the sid from #2 to that from #1.  fRet is true if they are equal.

    // 3b) If not, owner's sid may be that of a group, and the user might be a
    //     member of that group, or of a group (which would have to be a global group)
    //     within that group.  Fortunately that doesnt't recurse indefinitely, since
    //     local groups can contain only global groups, and global groups can contain
    //     only users (they can't be a container for other global or local groups) - see
    //     "Windows NT Security" (Nik Okuntseff), pp. 34-35.

    // So here we go...


    // 1) Get the sid of the user associated with the current thread.  Also filter out only object types we are equiped to deal with...
    if(ObjectType == SE_FILE_OBJECT || ObjectType == SE_LMSHARE)
    {
        CAccessRights car(true);    // true tells car to use the user associated with the current thread token
        CSid csidCurrentUser;
        if(car.GetCSid(csidCurrentUser, true)) // true signals that we want car to be initialized with the domain and name looked up
        {
        // 2) Get the owner of the object.
            CSid csidOwner;
            switch(ObjectType)
            {
                case SE_FILE_OBJECT:
                {
                    CSecureFile csf;
                    if(csf.SetFileName(chstrName, FALSE) == ERROR_SUCCESS) //FALSE means we don't need the SACL
                    {
                        csf.GetOwner(csidOwner);
                    }
                    break;
                }
                case SE_LMSHARE:
                {
                    CSecureShare css;
                    if(css.SetShareName(chstrName) == ERROR_SUCCESS)
                    {
                        css.GetOwner(csidOwner);
                    }
                    break;
                }
                default:
                {
                    ASSERT_BREAK(0);
                }
            }

            //  Proceed as long as the owner sid is valid and 'ok'...
            if(csidOwner.IsValid() && csidOwner.IsOK())
            {
                // 3a) Compare the sid from #2 to that from #1.  fRet is true if they are equal.
                if(csidCurrentUser == csidOwner)
                {
                    fRet = true;
                }
                else // owner might be a group...
                {
                    // 3b) If not, owner's sid may be that of a group, and the user might be a
                    //     member of that group, or of a group (which would have to be a global group)
                    //     within that group.  Fortunately that doesnt't recurse indefinitely, since
                    //     local groups can contain only global groups, and global groups can contain
                    //     only users (they can't be a container for other global or local groups) - see
                    //     "Windows NT Security" (Nik Okuntseff), pp. 34-35.

                    // Since this could be a pain, call a friendly helper...
                    SID_NAME_USE snuOwner = csidOwner.GetAccountType();
                    if(snuOwner == SidTypeGroup || snuOwner == SidTypeAlias || snuOwner == SidTypeWellKnownGroup)
                    {
                        if(IsUserInGroup(csidCurrentUser, csidOwner, snuOwner))
                        {
                            fRet = true;
                        }
                    }
                }
            }
        }  // we got the thread sid
    } // its an object we like

    return fRet;
}
#endif


// Helper to determine if a particular is a member of a group, or of one of the
// (global) groups that might be a member of that group.
#ifdef NTONLY
bool IsUserInGroup(const CSid &csidUser,
                   const CSid &csidGroup,
                   SID_NAME_USE snuGroup)
{
    bool fRet = false;
    CNetAPI32 netapi ;
    if(netapi.Init() == ERROR_SUCCESS)
    {
        fRet = RecursiveFindUserInGroup(netapi,
                                        csidGroup.GetDomainName(),
                                        csidGroup.GetAccountName(),
                                        snuGroup,
                                        csidUser);
    }
    return fRet;
}
#endif



#ifdef NTONLY
bool RecursiveFindUserInGroup(CNetAPI32 &netapi,
                              const CHString &chstrDomainName,
                              const CHString &chstrGroupName,
                              SID_NAME_USE snuGroup,
                              const CSid &csidUser)
{
    bool fRet = false;
    NET_API_STATUS stat;
    DWORD dwNumReturnedEntries = 0, dwIndex = 0, dwTotalEntries = 0;
	DWORD_PTR dwptrResume = NULL;

    // Domain Groups
    if (snuGroup == SidTypeGroup)
    {
        GROUP_USERS_INFO_0 *pGroupMemberData = NULL;
        CHString chstrDCName;
        if (netapi.GetDCName(chstrDomainName, chstrDCName) == ERROR_SUCCESS)
        {
            do
            {
                // Accept up to 256k worth of data.
                stat = netapi.NetGroupGetUsers(chstrDCName,
                                               chstrGroupName,
                                               0,
                                               (LPBYTE *)&pGroupMemberData,
                                               262144,
                                               &dwNumReturnedEntries,
                                               &dwTotalEntries,
                                               &dwptrResume);

                // If we got some data
                if(ERROR_SUCCESS == stat || ERROR_MORE_DATA == stat)
                {
                    try
                    {
                        // Walk through all the returned entries...
                        for(DWORD dwCtr = 0; dwCtr < dwNumReturnedEntries; dwCtr++)
                        {
                            // Get the sid type for this object...
                            CSid sid(chstrDomainName, CHString(pGroupMemberData[dwCtr].grui0_name), NULL);
                            if(sid == csidUser)
                            {
                                fRet = true;
                            }
                        }
                    }
                    catch ( ... )
                    {
                        netapi.NetApiBufferFree( pGroupMemberData );
                        throw ;
                    }
                    netapi.NetApiBufferFree( pGroupMemberData );
                }	// IF stat OK

            } while ( ERROR_MORE_DATA == stat && !fRet);
        }

    // Local Groups
    }
    else if(snuGroup == SidTypeAlias || snuGroup == SidTypeWellKnownGroup)
    {
        LOCALGROUP_MEMBERS_INFO_1 *pGroupMemberData = NULL;
        do
        {
            // Accept up to 256k worth of data.
            stat = netapi.NetLocalGroupGetMembers(NULL,
                                                  chstrGroupName,
                                                  1,
                                                  (LPBYTE *)&pGroupMemberData,
                                                  262144,
                                                  &dwNumReturnedEntries,
                                                  &dwTotalEntries,
                                                  &dwptrResume);

            // If we got some data
            if ( ERROR_SUCCESS == stat || ERROR_MORE_DATA == stat )
            {
                try
                {
                    // Walk through all the returned entries
                    for(DWORD dwCtr = 0; dwCtr < dwNumReturnedEntries && !fRet; dwCtr++)
                    {
                        // If this is a recognized type...
                        CSid sid(pGroupMemberData[dwCtr].lgrmi1_sid);

                        switch(pGroupMemberData[dwCtr].lgrmi1_sidusage)
                        {
                            case SidTypeUser:
                            {
                                if(sid == csidUser)
                                {
                                    fRet = true;
                                }
                                break;
                            }
                            case SidTypeGroup:
                            {
                                // If the group contained a group (would be a global group),
                                // we need to recurse.
                                fRet = RecursiveFindUserInGroup(netapi,
                                                                sid.GetDomainName(),
                                                                sid.GetAccountName(),
                                                                pGroupMemberData[dwCtr].lgrmi1_sidusage,
                                                                csidUser);
                                break;
                            }
                            case SidTypeWellKnownGroup:
                            {
                                // If the group contained a group (would be a global group),
                                // we need to recurse.
                                fRet = RecursiveFindUserInGroup(netapi,
                                                                sid.GetDomainName(),
                                                                sid.GetAccountName(),
                                                                pGroupMemberData[dwCtr].lgrmi1_sidusage,
                                                                csidUser);
                                break;
                            }
                            default:
                            {
                                ASSERT_BREAK(0);
                                break;
                            }
                        }
                    }
                }
                catch ( ... )
                {
                    netapi.NetApiBufferFree( pGroupMemberData );
                    throw ;
                }

                netapi.NetApiBufferFree( pGroupMemberData );
            }	// IF stat OK
        } while ( ERROR_MORE_DATA == stat && !fRet);
    }
	else
    {
        // Unrecognized Group type
        ASSERT_BREAK(0);
    }
    return fRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\securitydescriptor.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*
 *	CSecurityDescriptor.h - header file for CSecurityDescriptor class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CSECURITYDESCRIPTOR_H__
#define __CSECURITYDESCRIPTOR_H__



#define ALL_ACCESS_WITHOUT_GENERIC	0x01FFFFFF	// all possible access rights
												// without generic

////////////////////////////////////////////////////////////////
//
//	Class:	CSecurityDescriptor
//
//	This class is intended to provide a wrapper for Windows NT
//	Security Dscriptors.  The idea here is that a client class
//	would inherit from this class, obtain a security descriptor
//	from an as yet to be determined object, and pass said
//	descriptor into this class via InitSecurity(), at which
//	point we will take apart the descriptor and store the
//	data internally.  A user may then change security as needed
//	then call the ApplySecurity() function which will call
//	a couple of virtual functions, WriteAcls() and WriteOwner()
//	that must be implemented by a derived class, supplying
//	said class with an appropriately filled out Win32 Security
//	Descriptor.  Derived classes should also provide an
//	implementation for AllAccessMask() in order to provide
//	a mask specific to the object they are securing, that
//	indicates Full Control access.
//
////////////////////////////////////////////////////////////////

/*
 *	Class CSecurityDescriptor is a helper class. It groups user CSid together with its access mask.
 */ 

class CSecurityDescriptor
{
	// Constructors and destructor
	public:

		CSecurityDescriptor();
		CSecurityDescriptor( PSECURITY_DESCRIPTOR psd );
        CSecurityDescriptor
        (
            CSid* a_psidOwner,
            bool a_fOwnerDefaulted,
            CSid* a_psidGroup,
            bool a_fGroupDefaulted,
            CDACL* a_pDacl,
            bool a_fDaclDefaulted,
            bool a_fDaclAutoInherited,
            CSACL* a_pSacl,
            bool a_fSaclDefaulted,
            bool a_fSaclAutoInherited
        );

		virtual ~CSecurityDescriptor();

		// public entry to specify which attributes to set.
		DWORD ApplySecurity( SECURITY_INFORMATION securityinfo );

		// Allows setting various entries
		DWORD SetOwner( CSid& sid );
		DWORD SetGroup( CSid& sid );
		DWORD SetControl ( PSECURITY_DESCRIPTOR_CONTROL pControl );

        bool AddDACLEntry( CSid& sid, DACL_Types DaclType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid);
        bool AddSACLEntry( CSid& sid, SACL_Types SaclType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid);
        
        bool RemoveDACLEntry(  CSid& sid, DACL_Types DaclType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid );
		bool RemoveDACLEntry(  CSid& sid, DACL_Types DaclType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid );
		bool RemoveDACLEntry(  CSid& sid, DACL_Types DaclType, DWORD dwIndex = 0 );
        bool RemoveSACLEntry(  CSid& sid, SACL_Types SaclType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid );
		bool RemoveSACLEntry(  CSid& sid, SACL_Types SaclType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid );
		bool RemoveSACLEntry(  CSid& sid, SACL_Types SaclType, DWORD dwIndex = 0 );


		// ACE Location methods
		bool FindACE( const CSid& sid, BYTE bACEType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, CAccessEntry& ace );
		bool FindACE( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask,   CAccessEntry& ace );

		// Empty the ACLs (creates Empty if NULL).
		void EmptyDACL();
		void EmptySACL();

		// Clear (NULL) the ACLs (for DACL, this means a NULL or empty Denied Access,
		// DACL and a single entry of "Everyone", "Full Control" for Allowed Access DACL.

		bool MakeDACLNull();
		bool MakeSACLNull();

		// Checks our DACL objects for a NULL DACL condition
		bool IsNULLDACL();

		// Get owner and ACLs
		void GetOwner( CSid& sid );
		void GetGroup( CSid& sid );
		bool GetDACL( CDACL& DACL );
		bool GetSACL( CSACL& SACL );
		void GetControl ( PSECURITY_DESCRIPTOR_CONTROL pControl );

		// Derived classes should override, and this is called with the appropriate values set
		// Derived classes MUST NOT mess with the values in pAbsoluteSD!
		virtual DWORD WriteOwner( PSECURITY_DESCRIPTOR pAbsoluteSD ) { return E_FAIL; }
		virtual DWORD WriteAcls( PSECURITY_DESCRIPTOR pAbsoluteSD , SECURITY_INFORMATION securityinfo  ) { return E_FAIL; }

        void DumpDescriptor(LPCWSTR wstrFilename = NULL);
		DWORD GetSelfRelativeSD(
				SECURITY_INFORMATION securityinfo, 
				PSECURITY_DESCRIPTOR psd);

	protected:

		BOOL InitSecurity( PSECURITY_DESCRIPTOR psd );

	private:
		CSid*	m_pOwnerSid;
		CSid* 	m_pGroupSid;
		bool	m_fOwnerDefaulted;
        bool    m_fGroupDefaulted;
        bool    m_fDACLDefaulted;
        bool    m_fSACLDefaulted;
        bool    m_fDaclAutoInherited;
        bool    m_fSaclAutoInherited;

        // As of NT5, it is no longer sufficient to just maintain two lists for the dacls, since
        // we now have five, not two, types of ACEs that can go into a DACL. Double that since we
        // have inherited and non-inherited...
		//CDACL*	m_pAccessAllowedDACL;
		//CDACL*	m_pAccessDeniedDACL;
        CDACL* m_pDACL;
		CSACL* m_pSACL;
		SECURITY_DESCRIPTOR_CONTROL m_SecurityDescriptorControl;

		void Clear( void );
		DWORD SecureObject( PSECURITY_DESCRIPTOR pAbsoluteSD, SECURITY_INFORMATION securityinfo );
		BOOL InitDACL( PSECURITY_DESCRIPTOR psd );
		BOOL InitSACL( PSECURITY_DESCRIPTOR psd );
        bool InitDACL( CDACL* a_pDACL );
		bool InitSACL( CSACL* a_pSACL );
		
};

inline void CSecurityDescriptor::GetOwner( CSid& sid )
{
	if ( NULL != m_pOwnerSid )
	{
		sid = *m_pOwnerSid;
	}
}

inline void CSecurityDescriptor::GetGroup( CSid& sid )
{
	if (NULL != m_pGroupSid )
	{
		sid = *m_pGroupSid;
	}
}

inline void CSecurityDescriptor::GetControl ( PSECURITY_DESCRIPTOR_CONTROL pControl )
{
	//pControl = &m_SecurityDescriptorControl;
	
	//changed to copy the Sec. Desc. Control properly
	if(pControl)
	{
		*pControl = m_SecurityDescriptorControl;
	}
	
}

inline DWORD CSecurityDescriptor::SetControl (PSECURITY_DESCRIPTOR_CONTROL pControl )
{
	m_SecurityDescriptorControl = *pControl;
	return (ERROR_SUCCESS);
}

#endif // __CSecurityDescriptor_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\sources.inc ===
############################################################################
#
# Copyright (c) 2000-2002 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################
WMIPRECOMPSHARED=1
!include ..\..\..\..\common\makefile.cmn
SOURCES_USED=..\..\..\..\common\makefile.cmn

TARGETNAME=Cimwin32Library
TARGETPATH=obj
TARGETTYPE=LIBRARY

# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(UTILLIB_INC); \
	$(STDLIBRARY_INC); \
	$(CIMWIN32_LIB_INC); \
	$(FRAMEDYN_PRIVATE); \
	$(WMIIDL_INC); \
	$(CRT_INC_PATH); \
	$(NET_INC_PATH); \
	$(BASE_INC_PATH)

# The developer defines the SOURCES macro. It contains a list of all the
# source files for this component. Specify each source file on a separate
# line using the line-continuation character. This minimizes merge
# conflicts if two developers are adding source files to the same component.

MISCSOURCES= \
	..\confgmgr.cpp

PRESOURCES= \
	..\assoc.cpp \
	..\binding.cpp \
	..\AdvApi32Api.cpp \
	..\cfgmgrdevice.cpp \
 	..\chwres.cpp \
	..\configmgrapi.cpp \
	..\CAutoLock.cpp \
	..\CCriticalSec.cpp \
	..\CGlobal.cpp \
	..\CKernel.cpp \
	..\CMutex.cpp \
	..\devdesc.cpp \
	..\dllcommon.cpp \
	..\dllutils.cpp \
	..\dllunreg.cpp \
	..\DllWrapperbase.cpp \
	..\DMADesc.cpp	\
	..\EventProvider.cpp \
	..\FactoryRouter.cpp \
	..\iodesc.cpp \
	..\irqdesc.cpp \
	..\implogonuser.cpp \
	..\Kernel32Api.cpp \
	..\RefPtrLite.cpp \
	..\ResourceDesc.cpp 	\
 	..\ResourceManager.cpp \
	..\secureshare.cpp \
	..\securityApi.cpp \
	..\strings.cpp \
	..\Sid.cpp	\
	..\SvrApiApi.cpp \
	..\TimerQueue.cpp	\
	..\TimedDllResource.cpp	\
	..\TimeOutRule.cpp	\
	..\NetApi32Api.cpp \
	..\Nt4SvcToResMap.cpp	\
	..\NtDevToSvcSearch.cpp \
	..\perfdata.cpp \
	..\UserEnvApi.cpp \
	..\userhive.cpp \
	..\WbemPsApi.cpp \
	..\WmiApi.cpp \
	..\Ws2_32Api.cpp \
	..\Wsock32Api.cpp \
	..\wbemnetapi32.cpp \
	..\cluidhelper.cpp


NTSOURCES=$(NTSOURCES) \
	..\WMI_FilePrivateProfile.cpp \
	..\profilestring.cpp \
	..\session.cpp \
	..\MprApi.cpp \
	..\MsAcm32Api.cpp \
	..\NtDllApi.cpp \
	..\WinmmApi.cpp \
#	..\WinSpoolApi.cpp \
	..\computerAPI.cpp

# Next, specify options for the compiler using C_DEFINES. 
C_DEFINES=$(C_DEFINES) /D__WINNT_BUILD__
WIN32_WINNT_VERSION=0x0500
USE_NATIVE_EH=ASYNC
USE_MSVCRT=1
USE_VCCOM=1
USE_IOSTREAM=1
USE_STL=1

!ifdef USE_FRAMEDYD
DEBUG_CRTS=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\sms95lanexp.h ===
//=================================================================

//

// Sms95lanexp.h

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __SMS95LANEXP_H__
#define __SMS95LANEXP_H__

typedef ULONG* LPULONG;
typedef DWORD CMBUSTYPE;
typedef CMBUSTYPE* PCMBUSTYPE;

// Function prototypes for dynamic linking
typedef DWORD (WINAPI* PCIM32THK_CM_LOCATE_DEVNODE) ( PDEVNODE pdn, LPSTR HardwareKey, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_CHILD) ( PDEVNODE pdn, DEVNODE dnParent, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_SIBLING) ( PDEVNODE pdn, DEVNODE dnParent, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_READ_REGISTRY_VALUE) ( DEVNODE dnDevNode, LPSTR pszSubKey, LPSTR pszValueName, ULONG ulExpectedType, LPVOID Buffer, LPULONG pulLength, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_DEVNODE_STATUS) ( LPULONG pulStatus, LPULONG pulProblemNumber, DEVNODE dnDevNode, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_DEVICE_ID) ( DEVNODE dnDevNode, LPVOID Buffer, ULONG BufferLen, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_DEVICE_ID_SIZE) ( LPULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_FIRST_LOG_CONF) ( PLOG_CONF plcLogConf, DEVNODE dnDevNode, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_NEXT_RES_DES) ( PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_RES_DES_DATA_SIZE) ( LPULONG pulSize, RES_DES rdResDes, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_RES_DES_DATA) ( RES_DES rdResDes, LPVOID Buffer, ULONG BufferLen, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_BUS_INFO) (DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, LPULONG pulSizeOfInfo, LPVOID pInfo, ULONG ulFlags);
typedef DWORD (WINAPI* PCIM32THK_CM_GET_PARENT) ( PDEVNODE pdn, DEVNODE dnChild, ULONG ulFlags );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\strings.cpp ===
//=================================================================
//
// Strings.cpp
//
//  Copyright (c) 1995-2002 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

// Needed to fix warning message.  I believe this is fixed in vc6.
#if ( _MSC_VER <= 1100 )
void strings_cpp(void) { ; };
#endif

// registry strings
//
///////////////////////////////////////////////////////////

// LOGGING MESSAGES
LPCWSTR IDS_LogImpersonationFailed = L"Failed to impersonate logged on user.\n";
LPCWSTR IDS_LogImpersonationRevertFailed = L"Unable to revert back from impersonated user.\n";
LPCWSTR IDS_LogOutOfMemory = L"Out of Memory";

// SHARE DISPOSITIONS
LPCWSTR IDS_SDDeviceExclusive = L"DeviceExclusive";
LPCWSTR IDS_SDDriverExclusive = L"DriverExclusive";
LPCWSTR IDS_SDShared = L"Shared";
LPCWSTR IDS_SDUndetermined = L"Undetermined";

//      MEMORY TYPES
LPCWSTR IDS_MTReadWrite = L"ReadWrite";
LPCWSTR IDS_MTReadOnly = L"ReadOnly";
LPCWSTR IDS_MTWriteOnly = L"WriteOnly";
LPCWSTR IDS_MTPrefetchable = L"Prefetchable";

//      MEDIA TYPES
LPCWSTR IDS_MDT_RandomAccess = L"Random Access";
LPCWSTR IDS_MDT_SupportsWriting = L"Supports Writing";
LPCWSTR IDS_MDT_Removable = L"Removable Media";
LPCWSTR IDS_MDT_CD = L"CD-ROM";

// Processor Architectures
LPCWSTR IDS_ProcessorX86 = L"X86-based PC";
LPCWSTR IDS_ProcessorX86Nec98 = L"X86-Nec98 PC";
LPCWSTR IDS_ProcessorMIPS = L"MIPS-based PC";
LPCWSTR IDS_ProcessorALPHA = L"ALPHA-based PC";
LPCWSTR IDS_ProcessorPowerPC = L"Power PC";
LPCWSTR IDS_ProcessorIA64 = L"Itanium (TM) -based System";
LPCWSTR IDS_ProcessorAMD64 = L"AMD64-based PC";
LPCWSTR IDS_ProcessorUnknown = L"Unknown";


// COMMON STRINGS
LPCWSTR IDS_Unknown     = L"UNKNOWN";
LPCWSTR IDS_OK = L"OK";
LPCWSTR IDS_Degraded = L"Degraded";
LPCWSTR IDS_Error    = L"Error";
LPCWSTR IDS_WINNT_SHELLNAME_EXPLORER = L"EXPLORER.EXE";

// Win32_Bios
LPCWSTR IDS_RegBiosSystem       = L"HARDWARE\\Description\\System";
LPCWSTR IDS_RegSystemBiosDate   = L"SystemBiosDate";
LPCWSTR IDS_RegSystemBiosVersion        = L"SystemBiosVersion";
LPCWSTR IDS_RegEnumRootBios = L"Enum\\Root\\*PNP0C01\\0000";
LPCWSTR IDS_RegBIOSName = L"BIOSName";
LPCWSTR IDS_RegBIOSDate = L"BIOSDate";
LPCWSTR IDS_RegBIOSVersion = L"BIOSVersion";
LPCWSTR IDS_BIOS_NAME_VALUE  = L"Default System BIOS";

//      Win32_BootConfiguration
LPCWSTR IDS_BOOT_CONFIG_NAME = L"BootConfiguration";
LPCWSTR IDS_RegSetupLog = L"\\Repair\\Setup.Log";
LPCWSTR IDS_Paths = L"Paths";
LPCWSTR IDS_TargetDirectory = L"TargetDirectory";
LPCWSTR IDS_EnvBootDirectory = L"WinBootDir";
LPCWSTR IDS_Temp = L"Temp";
LPCWSTR IDS_Environment = L"Environment";

//  Win32_Bus
LPCWSTR IDS_Win32_Bus = L"Win32_Bus";
LPCWSTR IDS_Bus = L"Bus";
LPCWSTR IDS_BusType = L"BusType";
LPCWSTR IDS_BusNum  = L"BusNum";
LPCWSTR IDS_BUS_DEVICEID_TAG = L"_BUS_";
LPCWSTR IDS_WIN98_USB_REGISTRY_KEY = L"System\\CurrentControlSet\\Services\\Class\\USB";
LPCWSTR IDS_NT5_USB_REGISTRY_KEY = L"System\\CurrentControlSet\\Services\\usbhub";
LPCWSTR IDS_USB_Bus_Tag = L"USB";

//      Win32_CDRom
LPCWSTR IDS_RegSCSICDDevice = L"HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port %d\\Scsi Bus %d\\Target Id %d\\Logical Unit Id %d";
LPCWSTR IDS_RegIdentifier = L"Identifier";
LPCWSTR IDS_RegEnumSCSI = L"Enum\\SCSI";
LPCWSTR IDS_RegCurrentDriveLetterKey = L"CurrentDriveLetterAssignment";
LPCWSTR IDS_RegProductIDKey = L"ProductId";
LPCWSTR IDS_RegClassKey = L"Class";
LPCWSTR IDS_RegHardwareIDKey = L"HardwareID";
LPCWSTR IDS_RegRevisionLevelKey = L"RevisionLevel";
LPCWSTR IDS_RegSCSITargetIDKey = L"SCSITargetId";
LPCTSTR IDT_REG_KEY_CD_CACHE = _T("System\\CurrentControlSet\\Control\\FileSystem\\CDFS");
LPCTSTR IDT_REG_VAL_CD_CACHE = _T("CacheSize");
LPCWSTR IDS_DriveIntegrity = L"DriveIntegrity";
LPCWSTR IDS_TransferRate = L"TransferRate";


//      Win32_ComputerSystemn
LPCWSTR IDS_Win32ComputerSystem = L"Win32_ComputerSystem";
LPCWSTR IDS_DefaultSystemName = L"DEFAULT";
LPCWSTR IDS_RegInfrared = L"Infrared";
LPCWSTR IDS_Workstation = L"Workstation";
LPCWSTR IDS_PrimaryOwnerName = L"PrimaryOwnerName";
LPCWSTR IDS_SystemStartupSetting = L"SystemStartupSetting";
LPCWSTR IDS_SystemStartupOptions = L"SystemStartupOptions";
LPCWSTR IDS_OEMLogoBitmap = L"OEMLogoBitmap";
LPCWSTR IDS_RegCrashControl = L"SYSTEM\\CurrentControlSet\\Control\\CrashControl";
LPCWSTR IDS_RegAutoRebootKey = L"AutoReboot";
LPCWSTR IDS_RegCurrentNTVersion = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
LPCWSTR IDS_RegCurrent95Version = L"Software\\Microsoft\\Windows\\CurrentVersion";
LPCWSTR IDS_RegRegisteredOwnerKey = L"RegisteredOwner";
LPCWSTR IDS_RegProductOptions = L"SYSTEM\\CurrentControlSet\\Control\\ProductOptions";
LPCWSTR IDS_RegProductTypeKey = L"ProductType";
LPCWSTR IDS_RegNetworkLogon = L"Network\\Logon";
LPCWSTR IDS_RegPrimaryProvider = L"PrimaryProvider";
LPCWSTR IDS_RegNetworkProvider = L"System\\CurrentControlSet\\Services\\MSNP32\\NetworkProvider";
LPCWSTR IDS_RegAuthenticatingAgent = L"AuthenticatingAgent";
LPCWSTR IDS_MicrosoftNetwork = L"Microsoft Network";
LPCWSTR IDS_LanmanNT = L"LanmanNT";
LPCWSTR IDS_ServerNT = L"ServerNT";
LPCWSTR IDS_Server = L"Server";
LPCWSTR IDS_RegCurrentNTVersionSetup = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup";
LPCWSTR IDS_RegBootDirKey = L"BootDir";
LPCWSTR IDS_BootIni = L"boot.ini";
LPCWSTR IDS_CBootIni = L"c:\\boot.ini";
LPCTSTR IDT_BootLoader = _T("Boot Loader");
LPCTSTR IDT_Timeout = _T("timeout");
LPCTSTR IDT_OperatingSystems = _T("Operating Systems");
LPCTSTR IDT_OemLogoBmp = _T("OemLogo.Bmp");
LPCTSTR IDT_Line = _T("Line");
LPCTSTR IDT_SupportInformation = _T("Support Information");
LPCTSTR IDT_General = _T("General");
LPCTSTR IDT_OEMInfoIni = _T("OemInfo.Ini");
LPCWSTR IDS_RegCSEnumRootKey = L"Enum\\Root\\*PNP0C01\\0000";
LPCWSTR IDS_RegPowerManagementKey = L"Enum\\Root\\*PNP0C05\\0000";
LPCWSTR IDS_ATDescription = L"AT/AT COMPATIBLE";
LPCWSTR IDS_RegIdentifierKey = L"Identifier";
LPCWSTR IDS_EnableDaylightSavingsTime = L"EnableDaylightSavingsTime";
LPCWSTR IDS_LargeSystemCache = L"LargeSystemCache";

	// boot states
LPCWSTR IDS_BootupStateNormal = L"Normal boot";
LPCWSTR IDS_BootupStateFailSafe = L"Fail-safe boot";
LPCWSTR IDS_BootupStateFailSafeWithNetBoot = L"Fail-safe with network boot";
        // log messages
LPCWSTR IDS_LogNoAPMForNT5 = L"APM not returned for NT 5+";

//      Win32_Desktop
LPCWSTR IDS_RegNTProfileList = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList";
LPCWSTR IDS_RegControlPanelDesktop = L"\\Control Panel\\Desktop";
LPCWSTR IDS_RegControlPanelAppearance = L"\\Control Panel\\Appearance";
LPCWSTR IDS_RegControlPanelDesktop95 = L"%s\\Control Panel\\Desktop";
LPCWSTR IDS_RegScreenSaveActive = L"ScreenSaveActive";
LPCWSTR IDS_RegSCRNSAVEEXE      = L"SCRNSAVE.EXE";
LPCWSTR IDS_RegScreenSaverIsSecure = L"ScreenSaverIsSecure";
LPCWSTR IDS_RegScreenSaveTimeOut = L"ScreenSaveTimeOut";
LPCWSTR IDS_RegTileWallpaper = L"TileWallpaper";
LPCWSTR IDS_RegWindowMetricsKey = L"\\WindowMetrics";
LPCWSTR IDS_RegScreenSaveUsePassword = L"ScreenSaveUsePassword";

//      Win32_DeviceMemory
LPCWSTR IDS_RegAddressRange = L"0x%8.8I64lX-0x%8.8I64lX";
LPCWSTR IDS_RegStartingAddress = L"0x%4.4X-0x%4.4X";

// Win32_Directory

// Win32_SerialPort
LPCWSTR IDS_NT4_PortKey = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Ports";
LPCWSTR IDS_WIN9XCurCtlSet_Svcs_Class = L"System\\CurrentControlSet\\Services\\Class";

//      Win32_DiskPartition
LPCWSTR IDS_Bootable = L"Bootable";
LPCWSTR IDS_PhysicalDrive = L"\\\\.\\PHYSICALDRIVE%d";
LPCWSTR IDS_PartitionDescUnused = L"Unused";
LPCWSTR IDS_PartitionDesc12bitFAT = L"12-bit FAT";
LPCWSTR IDS_PartitionDescXenixOne = L"Xenix Type 1";
LPCWSTR IDS_PartitionDescXenixTwo = L"Xenix Type 2";
LPCWSTR IDS_PartitionDesc16bitFAT = L"16-bit FAT";
LPCWSTR IDS_PartitionDescExtPartition = L"Extended Partition";
LPCWSTR IDS_PartitionDescDOSV4Huge = L"MS-DOS V4 Huge";
LPCWSTR IDS_PartitionDescInstallable = L"Installable File System";
LPCWSTR IDS_PartitionDescPowerPCRef = L"PowerPC Reference Platform";
LPCWSTR IDS_PartitionDescUnix = L"UNIX";
LPCWSTR IDS_PartitionDescNTFT = L"NTFT";
LPCWSTR IDS_PartitionDescWin95Ext = L"Win95 w/Extended Int 13";
LPCWSTR IDS_PartitionDescExt13 = L"Extended w/Extended Int 13";
LPCWSTR IDS_PartitionDescUnknown = L"Unknown";
LPCWSTR IDS_PartitionDescGPTUnused = L"GPT: Unused";
LPCWSTR IDS_PartitionDescGPTSystem = L"GPT: System";
LPCWSTR IDS_PartitionDescGPTMSFTReserved = L"GPT: Microsoft Reserved";
LPCWSTR IDS_PartitionDescGPTBasicData = L"GPT: Basic Data";
LPCWSTR IDS_PartitionDescGPTLDMMetaData = L"GPT: Logical Disk Manager Metadata";
LPCWSTR IDS_PartitionDescGPTLDMData = L"GPT: Logical Disk Manager Data";
LPCWSTR IDS_PartitionDescGPTUnknown = L"GPT: Unknown";

// Win32_DisplayControlConfiguration
LPCWSTR IDS_AdapterConfiguredIncorrect = L"Display Adapter Not Configured Correctly";

// Win32_Environment
LPCWSTR IDS_SystemUser = L"<SYSTEM>";
LPCWSTR IDS_DefaultUser = L"<DEFAULT>";
LPCWSTR IDS_RegEnvironmentNT = L"System\\CurrentControlSet\\Control\\Session Manager\\Environment";
LPCWSTR IDS_RegEnvironmentKey = L"\\Environment";
LPCWSTR IDS_LogInvalidEnvFlags = L"Invalid lFlags to Environment::PutInstance (0x%x)";
LPCWSTR IDS_LogUserSystemMismatch = L"Username and SystemVariable mismatch.";
LPCWSTR IDS_LogInvalidEnvDelFlags = L"Invalid lFlags to Environment::DeleteInstance (0x%x)";

// Win32_Keyboard
LPCWSTR IDS_PCXT = L"PC/XT or compatible (83-key)";
LPCWSTR IDS_ICO = L"\"ICO\" (102-key)";
LPCWSTR IDS_PCAT = L"PC/AT or similar (84-key)";
LPCWSTR IDS_ENHANCED101102 = L"Enhanced (101- or 102-key)";
LPCWSTR IDS_NOKIA1050 = L"Nokia 1050 or similar";
LPCWSTR IDS_NOKIA9140 = L"Nokia 9140 or similar";
LPCWSTR IDS_UnknownKeyboard = L"Unknown keyboard";
LPCWSTR IDS_Japanese = L"Japanese";

// Win32_LogicalDisk
LPCWSTR IDS_SupportsFileBasedCompression = L"SupportsFileBasedCompression";

// CIM_LogicalFile
LPCWSTR IDS_Filename = L"Filename";
LPCWSTR IDS_Filesize = L"FileSize";
LPCWSTR IDS_Directory = L"Directory";
LPCWSTR IDS_EightDotThreeFileName = L"EightDotThreeFileName";
LPCWSTR IDS_Archive = L"Archive";
LPCWSTR IDS_Hidden = L"Hidden";
LPCWSTR IDS_System = L"System";
LPCWSTR IDS_LocalDisk = L"Local Disk";
LPCWSTR IDS_FileFolder = L"File Folder";
LPCWSTR IDS_FileTypeKeyNT4 = L"Software\\Classes\\";
LPCWSTR IDS_File = L"File";
LPCWSTR IDS_CompressionMethod = L"CompressionMethod";
LPCWSTR IDS_EncryptionMethod = L"EncryptionMethod";

// CIM_LogicalDevice_CIMDataFile
LPCWSTR IDS___Path = L"__PATH";
LPCWSTR IDS___Class = L"__CLASS";
LPCWSTR IDS___Relpath = L"__RELPATH";
LPCWSTR IDS_NT_CurCtlSetEnum = L"System\\CurrentControlSet\\Enum\\";
LPCWSTR IDS_NT_CurCtlSetSvcs = L"System\\CurrentControlSet\\Services\\";
LPCWSTR IDS_ImagePath = L"ImagePath";
LPCWSTR IDS_98_CurCtlSetSvcCls = L"System\\CurrentControlSet\\Services\\Class\\";
LPCWSTR IDS_DevLoader = L"DevLoader";
LPCWSTR IDS_98_Vmm32Files = L"System\\CurrentControlSet\\Control\\VMM32Files";
LPCWSTR IDS_CIMDataFile = L"CIM_DataFile";
LPCWSTR IDS_DriversSubdir = L"Drivers";
LPCWSTR IDS_Extension_sys = L".sys";
LPCWSTR IDS_DeviceVxDs = L"DeviceVxDs";
LPCWSTR IDS_Enum = L"Enum";
LPCWSTR IDS_Count = L"Count";
LPCWSTR IDS_Purpose = L"Purpose";

// Win32_ShortcutFile
LPCWSTR IDS_Target = L"Target";

// Win32_Win32LogicalProgramGroup
LPCWSTR IDS_BASE_REG_KEY = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Program Manager";


// Win32_Win32ProgramGroup_CIMDataFile
LPCWSTR IDS_Start_MenuWhackPrograms = L"Start Menu\\Programs";
LPCWSTR IDS_Default_User = L"Default User";
LPCWSTR IDS_All_Users = L"All Users";
LPCWSTR IDS_Profiles = L"Profiles";
LPCWSTR IDS_Start_Menu = L"Start Menu";



LPCWSTR IDS_Caption     = L"Caption";
LPCWSTR IDS_Device     = L"Device";
LPCWSTR IDS_CreationClassName = L"CreationClassName";
LPCWSTR IDS_CSCreationClassName = L"CSCreationClassName";
LPCWSTR IDS_Description = L"Description";
LPCWSTR IDS_HotSwappable = L"HotSwappable";
LPCWSTR IDS_Installed   = L"Installed";
LPCWSTR IDS_XOnXMitThreshold = L"XOnXMitThreshold";
LPCWSTR IDS_XOffXMitThreshold = L"XOffXMitThreshold";
LPCWSTR IDS_Name = L"Name";
LPCWSTR IDS_DNSName = L"DNSHostName";
LPCWSTR IDS_WorkingSetSize = L"WorkingSetSize";
LPCWSTR IDS_Manufacturer    = L"Manufacturer";
LPCWSTR IDS_FSCreationClassName = L"FSCreationClassName";
LPCWSTR IDS_CSName = L"CSName";
LPCWSTR IDS_Handle = L"Handle";
LPCWSTR IDS_OSCreationClassName = L"OSCreationClassName";
LPCWSTR IDS_OSName = L"OSName";
LPCWSTR IDS_FSName = L"FSName";
LPCWSTR IDS_CreationDate = L"CreationDate";
LPCWSTR IDS_InstallDate = L"InstallDate";
LPCTSTR IDT_Model           = _T("Model");
LPCWSTR IDS_Model           = L"Model";
LPCWSTR IDS_PowerState      = L"PowerState";
LPCWSTR IDS_SerialNumber    = L"SerialNumber";
LPCWSTR IDS_SKU             = L"SKU";
LPCWSTR IDS_Tag             = L"Tag";
LPCWSTR IDS_Version         = L"Version";
LPCWSTR IDS_Control             = L"Control";
LPCWSTR IDS_InUse           = L"InUse";
LPCWSTR IDS_PrimaryOwner    = L"PrimaryOwnerName";
LPCWSTR IDS_MaxTransmissionSpeed = L"MaxBaudRateToSerialPort";
LPCWSTR IDS_MaxTransmissionSpeedToPhone = L"MaxBaudRateToPhone";
LPCWSTR IDS_AnswerMode          = L"AnswerMode";
LPCWSTR IDS_LINEANSWERMODENODE = L"No effect on line";
LPCWSTR IDS_LINEANSWERMODEDROP = L"Drops current call";
LPCWSTR IDS_LINEANSWERMODEHOLD = L"Holds current call";
LPCWSTR IDS_BasePriority    = L"Priority";
LPCWSTR IDS_ProcessID       = L"ProcessID";
LPCWSTR IDS_JobCount = L"JobCount";
LPCWSTR IDS_JobCountSinceLastReset = L"JobCountSinceLastReset";
LPCWSTR IDS_BuildNumber         = L"BuildNumber";
LPCWSTR IDS_BuildType           = L"BuildType";
LPCWSTR IDS_CodeSet             = L"CodeSet";
LPCWSTR IDS_Installable         = L"Installable";
LPCWSTR IDS_InstallationDate    = L"InstallDate";
LPCWSTR IDS_InUseCount          = L"InUseCount";
LPCWSTR IDS_Locale              = L"Locale";
LPCWSTR IDS_CasePreserved   = L"CasePreserved";
LPCWSTR IDS_CaseSensitive   = L"CaseSensitive";
LPCWSTR IDS_Unicode         = L"Unicode";
LPCWSTR IDS_Archived        = L"Archive";
LPCWSTR IDS_Compressed      = L"Compressed";
LPCWSTR IDS_Created         = L"Created";
LPCWSTR IDS_Extension       = L"Extension";
LPCWSTR IDS_FileType        = L"FileType";
LPCWSTR IDS_LastAccessed    = L"LastAccessed";
LPCWSTR IDS_LastModified    = L"LastModified";
LPCWSTR IDS_Open            = L"Open";
LPCWSTR IDS_Path            = L"Path";
LPCWSTR IDS_Readable        = L"Readable";
LPCWSTR IDS_Size            = L"Size";
LPCWSTR IDS_Writeable       = L"Writeable";
LPCWSTR IDS_ServiceType = L"ServiceType";
LPCWSTR IDS_State       = L"State";
LPCWSTR IDS_ServiceName     = L"ServiceName";
LPCWSTR IDS_Status          = L"Status";
LPCWSTR IDS_StatusInfo      = L"StatusInfo";
LPCWSTR IDS_MaxNumberControlled = L"MaxNumberControlled";
LPCWSTR IDS_TimeOfLastReset     = L"TimeOfLastReset";
LPCWSTR IDS_ProtocolSupported    = L"ProtocolSupported";
LPCWSTR IDS_BatteryChargeStatus         = L"BatteryChargeStatus";
LPCWSTR IDS_BatteryInstalled            = L"BatteryInstalled";
LPCWSTR IDS_BatteryLifeLeft             = L"BatteryLifeLeft";
LPCWSTR IDS_BatteryLifetime             = L"BatteryLifetime";
LPCWSTR IDS_CanTurnOffRemotely          = L"CanTurnOffRemotely";
LPCWSTR IDS_CommandFile                 = L"CommandFile";
LPCWSTR IDS_FirstMessageDelay           = L"FirstMessageDelay";
LPCWSTR IDS_LowBatterySignal            = L"LowBatterySignal";
LPCWSTR IDS_MessageInterval             = L"MessageInterval";
LPCWSTR IDS_RemainingCapacityStatus     = L"RemainingCapacityStatus";
LPCWSTR IDS_EstimatedChargeRemaining    = L"EstimatedChargeRemaining";
LPCWSTR IDS_EstimatedRunTime            = L"EstimatedRunTime";
LPCWSTR IDS_PowerFailSignal             = L"PowerFailSignal";
LPCWSTR IDS_RechargeRate                = L"RechargeRate";
LPCWSTR IDS_Type                        = L"Type";
LPCWSTR IDS_UPSPort                     = L"UPSPort";
LPCWSTR IDS_VoltageCapability           = L"VoltageCapability";
LPCWSTR IDS_FreeSpace                                   = L"FreeSpace";
LPCWSTR IDS_PeakUsage                                   = L"PeakUsage";
LPCWSTR IDS_LastBootupTime                              = L"LastBootupTime";
LPCWSTR IDS_SupportContact                              = L"SupportContact";
LPCWSTR IDS_SupportContactDescription   = L"SupportContactDescription";
LPCWSTR IDS_SystemTime                                  = L"SystemTime";
LPCWSTR IDS_ConnectionlessService       = L"ConnectionlessService";
LPCWSTR IDS_GuaranteesDelivery          = L"GuaranteesDelivery";
LPCWSTR IDS_GuaranteesSequencing        = L"GuaranteesSequencing";
LPCWSTR IDS_MaximumAddressSize          = L"MaximumAddressSize";
LPCWSTR IDS_MaximumMessageSize          = L"MaximumMessageSize";
LPCWSTR IDS_MessageOriented             = L"MessageOriented";
LPCWSTR IDS_MinimumAddressSize          = L"MinimumAddressSize";
LPCWSTR IDS_PseudoStreamOriented        = L"PseudoStreamOriented";
LPCWSTR IDS_SupportsBroadcasting        = L"SupportsBroadcasting";
LPCWSTR IDS_SupportsConnectData         = L"SupportsConnectData";
LPCWSTR IDS_SupportsDisconnectData      = L"SupportsDisconnectData";
LPCWSTR IDS_SupportsEncryption          = L"SupportsEncryption";
LPCWSTR IDS_SupportsExpeditedData       = L"SupportsExpeditedData";
LPCWSTR IDS_SupportsFragmentation       = L"SupportsFragmentation";
LPCWSTR IDS_SupportsGracefulClosing     = L"SupportsGracefulClosing";
LPCWSTR IDS_SupportsGuaranteedBandwidth = L"SupportsGuaranteedBandwidth";
LPCWSTR IDS_SupportsMulticasting        = L"SupportsMulticasting";
LPCWSTR IDS_SupportsQualityofService    = L"SupportsQualityofService";
LPCWSTR IDS_ExecutableType  = L"ExecutableType";
LPCWSTR IDS_DeviceIsBusy = L"DeviceIsBusy";
LPCWSTR IDS_DeviceID    = L"DeviceID";
LPCWSTR IDS_AdapterType     = L"AdapterType";
LPCWSTR IDS_AdapterTypeID   = L"AdapterTypeID";
LPCWSTR IDS_Index           = L"Index";
LPCWSTR IDS_InterfaceIndex  = L"InterfaceIndex";
LPCWSTR IDS_IOPortAddress   = L"IOPortAddress";
LPCWSTR IDS_MACAddress      = L"MACAddress";
LPCWSTR IDS_Baud            = L"Baud";
LPCWSTR IDS_ByteSize        = L"ByteSize";
LPCWSTR IDS_DSRSensitivity  = L"DSRSensitivity";
LPCWSTR IDS_DTRControl      = L"DTRControl";
LPCWSTR IDS_OutTxCTSFlow    = L"OutTxCtsFlow";
LPCWSTR IDS_OutTxDSRFlow    = L"OutTxDsrFlow";
LPCWSTR IDS_Parity          = L"Parity";
LPCWSTR IDS_SIDType         = L"SIDType";
LPCWSTR IDS_SID             = L"SID";
LPCWSTR IDS_GroupComponent  = L"GroupComponent";
LPCWSTR IDS_PartComponent   = L"PartComponent";
LPCWSTR IDS_ParityEnabled   = L"ParityEnabled";
LPCWSTR IDS_StopBits        = L"StopBits";
LPCWSTR IDS_MaxClockSpeed   = L"MaxClockSpeed";
LPCWSTR IDS_CurrentClockSpeed   = L"CurrentClockSpeed";
LPCWSTR IDS_Family          = L"Family";
LPCWSTR IDS_Role            = L"Role";
LPCWSTR IDS_Architecture    = L"Architecture";
LPCWSTR IDS_Stepping            = L"Stepping";
LPCWSTR IDS_Revision        = L"Revision";
LPCWSTR IDS_L2CacheSize     = L"L2CacheSize";
LPCWSTR IDS_L2CacheSpeed    = L"L2CacheSpeed";
LPCWSTR IDS_UpgradeMethod   = L"UpgradeMethod";
LPCWSTR IDS_Layout                  = L"Layout";
LPCWSTR IDS_NumberOfFunctionKeys    = L"NumberOfFunctionKeys";
LPCWSTR IDS_ConnectionMode              = L"ConnectionMode";
LPCWSTR IDS_HardwareID                  = L"HardwareID";
LPCWSTR IDS_MaximumTransmissionSpeed    = L"MaximumTransmissionSpeed";
LPCWSTR IDS_Mode                        = L"Mode";
LPCWSTR IDS_TransmissionSpeed           = L"TransmissionSpeed";
LPCWSTR IDS_ButtonsSwapped          = L"ButtonsSwapped";
LPCWSTR IDS_ConnectMultiplePorts    = L"ConnectMultiplePorts";
LPCWSTR IDS_DataQueueSize           = L"DataQueueSize";
LPCWSTR IDS_DriverName              = L"DriverName";
LPCWSTR IDS_DeviceInterface         = L"DeviceInterface";
LPCWSTR IDS_HardwareType            = L"HardwareType";
LPCWSTR IDS_HorizontalMickeys       = L"HorizontalMickeys";
LPCWSTR IDS_MaximumPortsServiced    = L"MaximumPortsServiced";
LPCWSTR IDS_NumberOfButtons         = L"NumberOfButtons";
LPCWSTR IDS_PointerType             = L"PointerType";
LPCWSTR IDS_Resolution              = L"Resolution";
LPCWSTR IDS_Speed                   = L"Speed";
LPCWSTR IDS_Synch                   = L"Synch";
LPCWSTR IDS_VerticalMickeys         = L"VerticalMickeys";
LPCWSTR IDS_XThreshold              = L"XThreshold";
LPCWSTR IDS_YThreshold              = L"YThreshold";
LPCWSTR IDS_ZThreshold              = L"ZThreshold";
LPCWSTR IDS_AveragePagesPerMinute       = L"AveragePagesPerMinute";
LPCWSTR IDS_PrintProcessorParameters    = L"PrintProcessorParameters";
LPCWSTR IDS_SpoolEnabled                        = L"SpoolEnabled";
LPCWSTR IDS_Processor                   = L"Processor";
LPCWSTR IDS_ElapsedTime     = L"ElapsedTime";
LPCWSTR IDS_JobDestination  = L"JobDestination";
LPCWSTR IDS_Notify          = L"Notify";
LPCWSTR IDS_Owner           = L"Owner";
LPCWSTR IDS_Priority        = L"Priority";
LPCWSTR IDS_StartTime       = L"StartTime";
LPCWSTR IDS_TimeSubmitted   = L"TimeSubmitted";
LPCWSTR IDS_UntilTime       = L"UntilTime";
LPCWSTR IDS_MediaLoaded         = L"MediaLoaded";
LPCWSTR IDS_MediaType           = L"MediaType";
LPCWSTR IDS_MediaRemovable      = L"MediaRemovable";
LPCWSTR IDS_Compression             = L"Compression";
LPCWSTR IDS_DefaultBlockSize        = L"DefaultBlockSize";
LPCWSTR IDS_ECC                     = L"ECC";
LPCWSTR IDS_EndOfTapeWarningZoneSize      = L"EOTWarningZoneSize";
LPCWSTR IDS_FeaturesHigh            = L"FeaturesHigh";
LPCWSTR IDS_FeaturesLow             = L"FeaturesLow";
LPCWSTR IDS_MaximumBlockSize        = L"MaxBlockSize";
LPCWSTR IDS_MaximumPartitionCount   = L"MaxPartitionCount";
LPCWSTR IDS_MinimumBlockSize        = L"MinBlockSize";
LPCWSTR IDS_Padding                 = L"Padding";
LPCWSTR IDS_ReportSetMarks          = L"ReportSetMarks";
LPCWSTR IDS_BytesPerSector          = L"BytesPerSector";
LPCWSTR IDS_InterfaceType           = L"InterfaceType";
LPCWSTR IDS_Partitions              = L"Partitions";
LPCWSTR IDS_Signature               = L"Signature";
LPCWSTR IDS_TotalCylinders          = L"TotalCylinders";
LPCWSTR IDS_TotalSectors            = L"TotalSectors";
LPCWSTR IDS_TotalTracks             = L"TotalTracks";
LPCWSTR IDS_TracksPerCylinder       = L"TracksPerCylinder";
LPCWSTR IDS_SectorsPerTrack         = L"SectorsPerTrack";
LPCWSTR IDS_TotalBadSectors         = L"TotalBadSectors";
LPCWSTR IDS_LandingZoneCylinder     = L"LandingZoneCylinder";
LPCWSTR IDS_WritePrecompCylinder    = L"WritePrecompCylinder";
LPCWSTR IDS_TotalHeads              = L"TotalHeads";
LPCWSTR IDS_BootDirectory        = L"BootDirectory";
LPCWSTR IDS_ConfigurationPath    = L"ConfigurationPath";
LPCWSTR IDS_LastDrive            = L"LastDrive";
LPCWSTR IDS_ScratchDirectory     = L"ScratchDirectory";
LPCWSTR IDS_TempDirectory        = L"TempDirectory";
LPCWSTR IDS_BorderWidth              = L"BorderWidth";
LPCWSTR IDS_CoolSwitch               = L"CoolSwitch";
LPCWSTR IDS_CursorBlinkRate          = L"CursorBlinkRate";
LPCWSTR IDS_DragFullWindows          = L"DragFullWindows";
LPCWSTR IDS_GridGranularity          = L"GridGranularity";
LPCWSTR IDS_IconSpacing              = L"IconSpacing";
LPCWSTR IDS_IconTitleFaceName        = L"IconTitleFaceName";
LPCWSTR IDS_IconTitleSize            = L"IconTitleSize";
LPCWSTR IDS_IconTitleWrap            = L"IconTitleWrap";
LPCWSTR IDS_IconFont                 = L"IconFont";
LPCWSTR IDS_Pattern                  = L"Pattern";
LPCWSTR IDS_ScreenSaverActive        = L"ScreenSaverActive";
LPCWSTR IDS_ScreenSaverExecutable    = L"ScreenSaverExecutable";
LPCWSTR IDS_ScreenSaverSecure        = L"ScreenSaverSecure";
LPCWSTR IDS_ScreenSaverTimeout       = L"ScreenSaverTimeout";
LPCWSTR IDS_Wallpaper                = L"Wallpaper";
LPCWSTR IDS_WallpaperTiled           = L"WallpaperTiled";
LPCWSTR IDS_AvailableVirtualMemory   = L"AvailableVirtualMemory";
LPCWSTR IDS_TotalPageFileSpace       = L"TotalPageFileSpace";
LPCWSTR IDS_TotalPhysicalMemory      = L"TotalPhysicalMemory";
LPCWSTR IDS_TotalVirtualMemory       = L"TotalVirtualMemory";
LPCWSTR IDS_GroupName = L"GroupName";
LPCWSTR IDS_AccountExpires       = L"AccountExpires";
LPCWSTR IDS_AuthorizationFlags   = L"AuthorizationFlags";
LPCWSTR IDS_BadPasswordCount     = L"BadPasswordCount";
LPCWSTR IDS_CodePage             = L"CodePage";
LPCWSTR IDS_Comment              = L"Comment";
LPCWSTR IDS_CountryCode          = L"CountryCode";
LPCWSTR IDS_Flags                = L"Flags";
LPCWSTR IDS_FullName             = L"FullName";
LPCWSTR IDS_HomeDirectory        = L"HomeDirectory";
LPCWSTR IDS_HomeDirectoryDrive   = L"HomeDirectoryDrive";
LPCWSTR IDS_LastLogoff           = L"LastLogoff";
LPCWSTR IDS_LastLogon            = L"LastLogon";
LPCWSTR IDS_LogonHours           = L"LogonHours";
LPCWSTR IDS_LogonServer          = L"LogonServer";
LPCWSTR IDS_MaximumStorage       = L"MaximumStorage";
LPCWSTR IDS_NumberOfLogons       = L"NumberOfLogons";
LPCWSTR IDS_Parms                = L"Parameters";
LPCWSTR IDS_Password             = L"Password";
LPCWSTR IDS_PasswordAge          = L"PasswordAge";
LPCWSTR IDS_PasswordExpired      = L"PasswordExpired";
LPCWSTR IDS_PrimaryGroupId       = L"PrimaryGroupId";
LPCWSTR IDS_Privileges           = L"Privileges";
LPCWSTR IDS_Profile              = L"Profile";
LPCWSTR IDS_ScriptPath           = L"ScriptPath";
LPCWSTR IDS_UnitsPerWeek         = L"UnitsPerWeek";
LPCWSTR IDS_UserComment          = L"UserComment";
LPCWSTR IDS_UserId               = L"UserId";
LPCWSTR IDS_UserType             = L"UserType";
LPCWSTR IDS_Workstations         = L"Workstations";
LPCWSTR IDS_DefaultIPGateway     = L"DefaultIPGateway";
LPCWSTR IDS_DHCPEnabled          = L"DHCPEnabled";
LPCWSTR IDS_DHCPLeaseExpires     = L"DHCPLeaseExpires";
LPCWSTR IDS_DHCPLeaseObtained    = L"DHCPLeaseObtained";
LPCWSTR IDS_DHCPServer           = L"DHCPServer";
LPCWSTR IDS_IOAddress            = L"IOAddress";
LPCWSTR IDS_IPAddress            = L"IPAddress";
LPCWSTR IDS_IPSubnet             = L"IPSubnet";
LPCWSTR IDS_IPXAddress           = L"IPXAddress";
LPCWSTR IDS_IRQ                  = L"IRQ";
LPCWSTR IDS_AbortReadOrWriteOnError = L"AbortReadOrWriteOnError";
LPCWSTR IDS_BaudRate                = L"BaudRate";
LPCWSTR IDS_BinaryModeEnabled       = L"BinaryModeEnabled";
LPCWSTR IDS_BitsPerByte             = L"BitsPerByte";
LPCWSTR IDS_ContinueTransmitOnXOff  = L"ContinueTransmitOnXOff";
LPCWSTR IDS_CTSOutflowControl       = L"CTSOutflowControl";
LPCWSTR IDS_DiscardNULLBytes        = L"DiscardNULLBytes";
LPCWSTR IDS_DSROutflowControl       = L"DSROutflowControl";
LPCWSTR IDS_DTRFlowControlType      = L"DTRFlowControlType";
LPCWSTR IDS_EndOfFileCharacter      = L"EOFCharacter";
LPCWSTR IDS_ContinueXMitOnXOff            = L"ContinueXMitOnXOff";
LPCWSTR IDS_AbortReadWriteOnError         = L"AbortReadWriteOnError";
LPCWSTR IDS_ErrorReplaceCharacter   = L"ErrorReplaceCharacter";
LPCWSTR IDS_ErrorReplacementEnabled = L"ErrorReplacementEnabled";
LPCWSTR IDS_EventCharacter          = L"EventCharacter";
LPCWSTR IDS_IsBusy                  = L"IsBusy";
LPCWSTR IDS_ParityCheckEnabled      = L"ParityCheckEnabled";
LPCWSTR IDS_RTSFlowControlType      = L"RTSFlowControlType";
LPCWSTR IDS_XOffCharacter           = L"XOffCharacter";
LPCWSTR IDS_XOffTransmitThreshold   = L"XOffTransmitThreshold";
LPCWSTR IDS_XOnCharacter            = L"XOnCharacter";
LPCWSTR IDS_XOnTransmitThreshold    = L"XOnTransmitThreshold";
LPCWSTR IDS_XOnXOffInflowControl    = L"XOnXOffInflowControl";
LPCWSTR IDS_XOnXOffOutflowControl   = L"XOnXOffOutflowControl";
LPCWSTR IDS_DaylightInEffect     = L"DaylightInEffect";
LPCWSTR IDS_Bias                 = L"Bias";
LPCWSTR IDS_StandardName         = L"StandardName";
LPCWSTR IDS_StandardYear         = L"StandardYear";
LPCWSTR IDS_StandardMonth        = L"StandardMonth";
LPCWSTR IDS_StandardDayOfWeek    = L"StandardDayOfWeek";
LPCWSTR IDS_StandardDay          = L"StandardDay";
LPCWSTR IDS_StandardHour         = L"StandardHour";
LPCWSTR IDS_StandardMinute       = L"StandardMinute";
LPCWSTR IDS_StandardSecond       = L"StandardSecond";
LPCWSTR IDS_StandardMillisecond  = L"StandardMillisecond";
LPCWSTR IDS_StandardBias         = L"StandardBias";
LPCWSTR IDS_DaylightName         = L"DaylightName";
LPCWSTR IDS_DaylightYear         = L"DaylightYear";
LPCWSTR IDS_DaylightMonth        = L"DaylightMonth";
LPCWSTR IDS_DaylightDayOfWeek    = L"DaylightDayOfWeek";
LPCWSTR IDS_DaylightDay          = L"DaylightDay";
LPCWSTR IDS_DaylightHour         = L"DaylightHour";
LPCWSTR IDS_DaylightMinute       = L"DaylightMinute";
LPCWSTR IDS_DaylightSecond       = L"DaylightSecond";
LPCWSTR IDS_DaylightMillisecond  = L"DaylightMillisecond";
LPCWSTR IDS_DaylightBias         = L"DaylightBias";
LPCWSTR IDS_ConnectionType   = L"ConnectionType";
LPCWSTR IDS_RemotePath       = L"RemotePath";
LPCWSTR IDS_LocalName        = L"LocalName";
LPCWSTR IDS_RemoteName       = L"RemoteName";
LPCWSTR IDS_ProviderName     = L"ProviderName";
LPCWSTR IDS_DisplayType      = L"DisplayType";
LPCWSTR IDS_ResourceType     = L"ResourceType";
LPCWSTR IDS_GroupOrder = L"GroupOrder";
LPCWSTR IDS_CommandLine      = L"CommandLine";
LPCWSTR IDS_Dependencies     = L"Dependencies";
LPCWSTR IDS_DisplayName      = L"DisplayName";
LPCWSTR IDS_ErrorControl     = L"ErrorControl";
LPCWSTR IDS_LoadOrderGroup   = L"LoadOrderGroup";
LPCWSTR IDS_PathName         = L"PathName";
LPCWSTR IDS_StartName        = L"StartName";
LPCWSTR IDS_StartType        = L"StartType";
LPCWSTR IDS_TagId            = L"TagId";
LPCWSTR IDS_AcceptStop       = L"AcceptStop";
LPCWSTR IDS_AcceptPause      = L"AcceptPause";
LPCWSTR IDS_AutomaticResetBootOption     = L"AutomaticResetBootOption";
LPCWSTR IDS_AutomaticResetCapability     = L"AutomaticResetCapability";
LPCWSTR IDS_AutomaticResetStatus         = L"AutomaticResetStatus";
LPCWSTR IDS_AutomaticResetTimerInterval  = L"AutomaticResetTimerInterval";
LPCWSTR IDS_AutomaticResetTimerReset     = L"AutomaticResetTimerReset";
LPCWSTR IDS_BootRomSupported             = L"BootROMSupported";
LPCWSTR IDS_BootupState                  = L"BootupState";
LPCWSTR IDS_ConditionalReboot            = L"ConditionalReboot";
LPCWSTR IDS_InfraredSupported            = L"InfraredSupported";
LPCWSTR IDS_LockKeyboardAndMouse         = L"LockKeyboardAndMouse";
LPCWSTR IDS_LockPCPowerOnAndResetButtons = L"LockPCPowerOnAndResetButtons";
LPCWSTR IDS_LockSystem                   = L"LockSystem";
LPCWSTR IDS_NetworkServerModeEnabled     = L"NetworkServerModeEnabled";
LPCWSTR IDS_PowerManagementSupported     = L"PowerManagementSupported";
LPCWSTR IDS_PowerManagementCapabilities  = L"PowerManagementCapabilities";
LPCWSTR IDS_PowerManagementEnabled               = L"PowerManagementEnabled";
LPCWSTR IDS_ResetBootOption              = L"ResetBootOption";
LPCWSTR IDS_ResetTimeout                 = L"ResetTimeout";
LPCWSTR IDS_SystemCreationClassName              = L"SystemCreationClassName";
LPCWSTR IDS_SystemName                                           = L"SystemName";
LPCWSTR IDS_SystemFilesNotModified       = L"SystemFilesNotModified";
LPCWSTR IDS_SystemRole                   = L"SystemRole";
LPCWSTR IDS_SystemType                   = L"SystemType";
LPCWSTR IDS_NumberOfProcessors           = L"NumberOfProcessors";
LPCWSTR IDS_UnconditionalReboot          = L"UnconditionalReboot";
LPCWSTR IDS_UserName                     = L"UserName";
LPCWSTR IDS_ExecutablePath               = L"ExecutablePath";
LPCWSTR IDS_Exited                       = L"Exited";
LPCWSTR IDS_MaximumWorkingSetSize        = L"MaximumWorkingSetSize";
LPCWSTR IDS_MinimumWorkingSetSize        = L"MinimumWorkingSetSize";
LPCWSTR IDS_PageFaults                   = L"PageFaults";
LPCWSTR IDS_PageFileUsage                = L"PageFileUsage";
LPCWSTR IDS_PeakPageFileUsage            = L"PeakPageFileUsage";
LPCWSTR IDS_PeakWorkingSetSize           = L"PeakWorkingSetSize";
LPCWSTR IDS_QuotaNonPagedPoolUsage       = L"QuotaNonPagedPoolUsage";
LPCWSTR IDS_QuotaPagedPoolUsage          = L"QuotaPagedPoolUsage";
LPCWSTR IDS_QuotaPeakNonPagedPoolUsage   = L"QuotaPeakNonPagedPoolUsage";
LPCWSTR IDS_QuotaPeakPagedPoolUsage      = L"QuotaPeakPagedPoolUsage";
LPCWSTR IDS_ThreadCount                  = L"ThreadCount";
LPCWSTR IDS_KernelModeTime                               = L"KernelModeTime";
LPCWSTR IDS_UserModeTime                                 = L"UserModeTime";
LPCWSTR IDS_WindowsVersion               = L"WindowsVersion";
LPCWSTR IDS_Characteristics  = L"Characteristics[]";
LPCWSTR IDS_EndingAddress    = L"EndingAddress";
LPCWSTR IDS_PrimaryBIOS      = L"PrimaryBIOS";
LPCWSTR IDS_ReleaseDate      = L"ReleaseDate";
LPCWSTR IDS_StartingAddress  = L"StartingAddress";
LPCWSTR IDS_Verify           = L"Verify";
LPCWSTR IDS_BootDevice           = L"BootDevice";
LPCWSTR IDS_CSDVersion           = L"CSDVersion";
LPCWSTR IDS_Primary              = L"Primary";
LPCWSTR IDS_SystemDirectory      = L"SystemDirectory";
LPCWSTR IDS_SystemStartOptions   = L"SystemStartOptions";
LPCWSTR IDS_WindowsDirectory     = L"WindowsDirectory";
LPCWSTR IDS_EnforcesACLs   = L"EnforcesACLs";
LPCWSTR IDS_DeviceType          = L"DeviceType";
LPCWSTR IDS_Length              = L"Length";
LPCWSTR IDS_ShareDisposition    = L"ShareDisposition";
LPCWSTR IDS_Start               = L"Start";
LPCWSTR IDS_DeviceDescriptorBlock    = L"DeviceDescriptorBlock";
LPCWSTR IDS_IdentiferNumber          = L"IdentiferNumber";
LPCWSTR IDS_PM_API                   = L"PM_API";
LPCWSTR IDS_ServiceTableSize         = L"ServiceTableSize";
LPCWSTR IDS_V86_API                  = L"V86_API";
LPCWSTR IDS_AccountDisabled              = L"AccountDisabled";
LPCWSTR IDS_AccountLockout               = L"AccountLockout";
LPCWSTR IDS_CannotChangePassword         = L"CannotChangePassword";
LPCWSTR IDS_ChangePasswordOnNextLogon    = L"ChangePasswordOnNextLogon";
LPCWSTR IDS_Domain                       = L"Domain";
LPCWSTR IDS_Organization                 = L"Organization";
LPCWSTR IDS_Phone                        = L"Phone";
LPCWSTR IDS_AddressRange     = L"AddressRange";
LPCWSTR IDS_MemoryType       = L"MemoryType";
LPCWSTR IDS_BurstMode    = L"BurstMode";
LPCWSTR IDS_DMAChannel   = L"DMAChannel";
LPCWSTR IDS_ChannelWidth = L"ChannelWidth";
LPCWSTR IDS_Port         = L"Port";
LPCWSTR IDS_AffinityMask     = L"AffinityMask";
LPCWSTR IDS_Availability     = L"Availability";
LPCWSTR IDS_InterruptType    = L"InterruptType";
LPCWSTR IDS_IRQNumber        = L"IRQNumber";
LPCWSTR IDS_Level            = L"Level";
LPCWSTR IDS_Shareable        = L"Shareable";
LPCWSTR IDS_TriggerType      = L"TriggerType";
LPCWSTR IDS_Vector           = L"Vector";
LPCWSTR IDS_Address = L"Address";
LPCWSTR IDS_ProductName = L"ProductName";
LPCWSTR IDS_Binary                   = L"Binary";
LPCWSTR IDS_MaximumBaudRate          = L"MaxBaudRate";
LPCWSTR IDS_MaximumInputBufferSize   = L"MaximumInputBufferSize";
LPCWSTR IDS_MaximumOutputBufferSize  = L"MaximumOutputBufferSize";
LPCWSTR IDS_ProviderType             = L"ProviderType";
LPCWSTR IDS_SettableBaudRate         = L"SettableBaudRate";
LPCWSTR IDS_SettableDataBits         = L"SettableDataBits";
LPCWSTR IDS_SettableFlowControl      = L"SettableFlowControl";
LPCWSTR IDS_SettableParity           = L"SettableParity";
LPCWSTR IDS_SettableParityCheck      = L"SettableParityCheck";
LPCWSTR IDS_SettableRLSD             = L"SettableRLSD";
LPCWSTR IDS_SettableStopBits         = L"SettableStopBits";
LPCWSTR IDS_Supports16BitMode        = L"Supports16BitMode";
LPCWSTR IDS_SupportsDTRDSR           = L"SupportsDTRDSR";
LPCWSTR IDS_SupportsIntervalTimeouts = L"SupportsIntTimeouts";
LPCWSTR IDS_SupportsParityCheck      = L"SupportsParityCheck";
LPCWSTR IDS_SupportsRLSD             = L"SupportsRLSD";
LPCWSTR IDS_SupportsRTSCTS           = L"SupportsRTSCTS";
LPCWSTR IDS_SupportsSettableXOnXOff  = L"SupportsXOnXOffSet";
LPCWSTR IDS_SupportsSpecialChars     = L"SupportsSpecialCharacters";
LPCWSTR IDS_SupportsElapsedTimeouts  = L"SupportsElapsedTimeouts";
LPCWSTR IDS_SupportsXOnXOff          = L"SupportsXOnXOff";
LPCWSTR IDS_Capabilities    = L"Capabilities";
LPCWSTR IDS_DmaSupport      = L"DmaSupport";
LPCWSTR IDS_DeviceMap           = L"DeviceMap";
LPCWSTR IDS_HardwareVersion     = L"HardwareVersion";
LPCWSTR IDS_InterruptNumber  = L"InterruptNumber";
LPCWSTR IDS_AttachedTo         = L"AttachedTo";
LPCWSTR IDS_BlindOff           = L"BlindOff";
LPCWSTR IDS_BlindOn            = L"BlindOn";
LPCWSTR IDS_CallSetupFailTimer = L"CallSetupFailTimer";
LPCWSTR IDS_CompatibilityFlags = L"CompatibilityFlags";
LPCWSTR IDS_CompressionOff     = L"CompressionOff";
LPCWSTR IDS_CompressionOn      = L"CompressionOn";
LPCWSTR IDS_ConfigurationDialog= L"ConfigurationDialog";
LPCWSTR IDS_DCB                = L"DCB";
LPCWSTR IDS_Default            = L"Default";
LPCTSTR IDT_Default            = _T("Default");
LPCWSTR IDS_DeviceLoader       = L"DeviceLoader";
LPCWSTR IDS_DialPrefix         = L"DialPrefix";
LPCWSTR IDS_DialSuffix         = L"DialSuffix";
LPCWSTR IDS_DriverDate         = L"DriverDate";
LPCWSTR IDS_ErrorControlForced = L"ErrorControlForced";
LPCWSTR IDS_ErrorControlOff    = L"ErrorControlOff";
LPCWSTR IDS_ErrorControlOn     = L"ErrorControlOn";
LPCWSTR IDS_FlowControlHard    = L"FlowControlHard";
LPCWSTR IDS_FlowControlSoft    = L"FlowControlSoft";
LPCWSTR IDS_FlowControlOff     = L"FlowControlOff";
LPCWSTR IDS_InactivityScale    = L"InactivityScale";
LPCWSTR IDS_InactivityTimeout  = L"InactivityTimeout";
LPCWSTR IDS_ModemInfPath       = L"ModemInfPath";
LPCWSTR IDS_ModemInfSection    = L"ModemInfSection";
LPCWSTR IDS_ModulationBell     = L"ModulationBell";
LPCWSTR IDS_ModulationCCITT    = L"ModulationCCITT";
LPCWSTR IDS_PortSubClass       = L"PortSubClass";
LPCWSTR IDS_Prefix             = L"Prefix";
LPCWSTR IDS_Properties         = L"Properties";
LPCWSTR IDS_Pulse              = L"Pulse";
LPCWSTR IDS_Reset              = L"Reset";
LPCWSTR IDS_Alias              = L"Alias";
LPCWSTR IDS_ResponsesKeyName   = L"ResponsesKeyName";
LPCWSTR IDS_SpeakerModeDial    = L"SpeakerModeDial";
LPCWSTR IDS_SpeakerModeOff     = L"SpeakerModeOff";
LPCWSTR IDS_SpeakerModeOn      = L"SpeakerModeOn";
LPCWSTR IDS_SpeakerModeSetup   = L"SpeakerModeSetup";
LPCWSTR IDS_SpeakerVolumeHigh  = L"SpeakerVolumeHigh";
LPCWSTR IDS_SpeakerVolumeLow   = L"SpeakerVolumeLow";
LPCWSTR IDS_SpeakerVolumeMed   = L"SpeakerVolumeMed";
LPCWSTR IDS_StringFormat       = L"StringFormat";
LPCWSTR IDS_Terminator         = L"Terminator";
LPCWSTR IDS_Tone               = L"Tone";
LPCWSTR IDS_VoiceSwitchFeature = L"VoiceSwitchFeature";
LPCWSTR IDS_PrimaryBusType   = L"PrimaryBusType";
LPCWSTR IDS_SecondaryBusType = L"SecondaryBusType";
LPCWSTR IDS_RevisionNumber   = L"RevisionNumber";
LPCWSTR IDS_EnableWheelDetection = L"EnableWheelDetection";
LPCWSTR IDS_InfFileName          = L"InfFileName";
LPCWSTR IDS_InfSection           = L"InfSection";
LPCWSTR IDS_SampleRate           = L"SampleRate";
LPCWSTR IDS_Attributes           = L"Attributes";
LPCWSTR IDS_DefaultPriority      = L"DefaultPriority";
LPCWSTR IDS_PortName             = L"PortName";
LPCWSTR IDS_PrintJobDataType     = L"PrintJobDataType";
LPCWSTR IDS_SeparatorFile        = L"SeparatorFile";
LPCWSTR IDS_ServerName           = L"ServerName";
LPCWSTR IDS_ShareName            = L"ShareName";
LPCWSTR IDS_DataType         = L"DataType";
LPCWSTR IDS_Document         = L"Document";
LPCWSTR IDS_HostPrintQueue   = L"HostPrintQueue";
LPCWSTR IDS_JobId            = L"JobId";
LPCWSTR IDS_PagesPrinted     = L"PagesPrinted";
LPCWSTR IDS_Parameters       = L"Parameters";
LPCWSTR IDS_PrintProcessor   = L"PrintProcessor";
LPCWSTR IDS_TotalPages       = L"TotalPages";
LPCWSTR IDS_Drive                    = L"Drive";
LPCWSTR IDS_FileSystemFlags          = L"FileSystemFlags";
LPCWSTR IDS_FileSystemFlagsEx        = L"FileSystemFlagsEx";
LPCWSTR IDS_Id                       = L"Id";
LPCWSTR IDS_MaximumComponentLength   = L"MaximumComponentLength";
LPCWSTR IDS_RevisionLevel            = L"RevisionLevel";
LPCWSTR IDS_SCSILun                  = L"SCSILun";
LPCWSTR IDS_SCSITargetId             = L"SCSITargetId";
LPCWSTR IDS_VolumeName               = L"VolumeName";
LPCWSTR IDS_VolumeSerialNumber       = L"VolumeSerialNumber";
LPCWSTR IDS_Disabled                 = L"Disabled";
LPCWSTR IDS_PasswordRequired         = L"PasswordRequired";
LPCWSTR IDS_PasswordChangeable       = L"PasswordChangeable";
LPCWSTR IDS_Lockout                  = L"Lockout";
LPCWSTR IDS_PasswordExpires          = L"PasswordExpires";
LPCWSTR IDS_AccountType              = L"AccountType";
LPCWSTR IDS_SCSIBus         = L"SCSIBus";
LPCWSTR IDS_SCSIPort        = L"SCSIPort";
LPCWSTR IDS_SCSILogicalUnit = L"SCSILogicalUnit";
LPCWSTR IDS_SCSITargetID    = L"SCSITargetID";
LPCWSTR IDS_FileSystem = L"FileSystem";
LPCWSTR IDS_BootPartition    = L"BootPartition";
LPCWSTR IDS_DiskIndex        = L"DiskIndex";
LPCWSTR IDS_Encrypted        = L"Encrypted";
LPCWSTR IDS_HiddenSectors    = L"HiddenSectors";
LPCWSTR IDS_RewritePartition = L"RewritePartition";
LPCWSTR IDS_StartingOffset   = L"StartingOffset";
LPCWSTR IDS_BitsPerPel       = L"BitsPerPel";
LPCWSTR IDS_DeviceName       = L"DeviceName";
LPCWSTR IDS_DisplayFlags     = L"DisplayFlags";
LPCWSTR IDS_DisplayFrequency = L"DisplayFrequency";
LPCWSTR IDS_DitherType       = L"DitherType";
LPCWSTR IDS_DriverVersion    = L"DriverVersion";
LPCWSTR IDS_ICMIntent        = L"ICMIntent";
LPCWSTR IDS_ICMMethod        = L"ICMMethod";
LPCWSTR IDS_LogPixels        = L"LogPixels";
LPCWSTR IDS_PelsHeight       = L"PelsHeight";
LPCWSTR IDS_PelsWidth        = L"PelsWidth";
LPCWSTR IDS_SpecificationVersion = L"SpecificationVersion";
LPCWSTR IDS_TTOption         = L"TTOption";
LPCWSTR IDS_BitsPerPixel                 = L"BitsPerPixel";
LPCWSTR IDS_ColorPlanes                  = L"ColorPlanes";
LPCWSTR IDS_DeviceEntriesInAColorTable   = L"DeviceEntriesInAColorTable";
LPCWSTR IDS_ColorTableEntries            = L"ColorTableEntries";
LPCWSTR IDS_DeviceSpecificPens           = L"DeviceSpecificPens";
LPCWSTR IDS_HorizontalResolution         = L"HorizontalResolution";
LPCWSTR IDS_RefreshRate                  = L"RefreshRate";
LPCWSTR IDS_ReservedSystemPaletteEntries = L"ReservedSystemPaletteEntries";
LPCWSTR IDS_SystemPaletteEntries         = L"SystemPaletteEntries";
LPCWSTR IDS_VerticalResolution           = L"VerticalResolution";
LPCWSTR IDS_VideoMode                    = L"VideoMode";
LPCWSTR IDS_ActualColorResolution        = L"ActualColorResolution";
LPCWSTR IDS_AdapterChipType              = L"AdapterChipType";
LPCWSTR IDS_AdapterCompatibility         = L"AdapterCompatibility";
LPCWSTR IDS_AdapterDACType               = L"AdapterDACType";
LPCWSTR IDS_AdapterDescription           = L"AdapterDescription";
LPCWSTR IDS_AdapterLocale                = L"AdapterLocale";
LPCWSTR IDS_AdapterRAM                   = L"AdapterRAM";
LPCWSTR IDS_InstalledDisplayDrivers      = L"InstalledDisplayDrivers";
LPCWSTR IDS_MonitorManufacturer          = L"MonitorManufacturer";
LPCWSTR IDS_MonitorType                  = L"MonitorType";
LPCWSTR IDS_PixelsPerXLogicalInch        = L"PixelsPerXLogicalInch";
LPCWSTR IDS_PixelsPerYLogicalInch        = L"PixelsPerYLogicalInch";
LPCWSTR IDS_ScanMode                     = L"ScanMode";
LPCWSTR IDS_ScreenHeight                 = L"ScreenHeight";
LPCWSTR IDS_ScreenWidth                  = L"ScreenWidth";
LPCWSTR IDS_Collate          = L"Collate";
LPCWSTR IDS_Color            = L"Color";
LPCWSTR IDS_Copies           = L"Copies";
LPCWSTR IDS_Duplex           = L"Duplex";
LPCWSTR IDS_FormName         = L"FormName";
LPCWSTR IDS_Orientation      = L"Orientation";
LPCWSTR IDS_PaperLength      = L"PaperLength";
LPCWSTR IDS_PaperSize        = L"PaperSize";
LPCWSTR IDS_PaperWidth       = L"PaperWidth";
LPCWSTR IDS_PrintQuality     = L"PrintQuality";
LPCWSTR IDS_Scale            = L"Scale";
LPCWSTR IDS_YResolution      = L"YResolution";
LPCWSTR IDS_VariableName     = L"VariableName";
LPCWSTR IDS_VariableValue    = L"VariableValue";
LPCWSTR IDS_MaximumSize                 = L"MaximumSize";
LPCWSTR IDS_InitialSize                 = L"InitialSize";
LPCWSTR IDS_AllocatedBaseSize   = L"AllocatedBaseSize";
LPCWSTR IDS_CurrentUsage                = L"CurrentUsage";
LPCWSTR IDS_AllowMaximum     = L"AllowMaximum";
LPCWSTR IDS_MaximumAllowed   = L"MaximumAllowed";
LPCWSTR IDS_Location            = L"Location";
LPCWSTR IDS_Unsupported         = L"Unsupported";
LPCWSTR IDS_SupportsDiskQuotas = L"SupportsDiskQuotas";
LPCWSTR IDS_QuotasIncomplete = L"QuotasIncomplete";
LPCWSTR IDS_QuotasRebuilding = L"QuotasRebuilding";
LPCWSTR IDS_QuotasDisabled = L"QuotasDisabled";
LPCWSTR IDS_VolumeDirty = L"VolumeDirty";
LPCWSTR IDS_SessionID = L"SessionID";
LPCWSTR IDS_PerformAutochk = L"PerformAutochk";
LPCWSTR IDS_AuthenticationPackage = L"AuthenticationPackage"; 
LPCWSTR IDS_LogonType = L"LogonType";             
LPCWSTR IDS_LogonTime = L"LogonTime"; 
LPCWSTR IDS_LocalAccount = L"LocalAccount";
            


LPCWSTR IDS_Antecedent  =       L"Antecedent";
LPCWSTR IDS_Dependent   =       L"Dependent";
LPCWSTR IDS_Adapter             =       L"Adapter";
LPCWSTR IDS_Protocol    =       L"Protocol";
LPCWSTR IDS_Service             =       L"Service";
LPCWSTR IDS_Element             =       L"Element";
LPCWSTR IDS_Setting             =       L"Setting";
LPCWSTR IDS_DriveType   =   L"DriveType";
LPCWSTR IDS_LogonId             =   L"LogonId" ;

LPCWSTR  IDS_GETLASTERROR   = L"GetLastError() reports %d (%X)";


LPCWSTR IDS_CimWin32Namespace   =       L"root\\cimv2";

LPCWSTR IDS_CfgMgrDeviceStatus_OK       =       L"OK";
LPCWSTR IDS_CfgMgrDeviceStatus_ERR      =       L"Error";

WCHAR szBusType[KNOWN_BUS_TYPES][20] = {

    { L"Internal"         },
    { L"Isa"              },
    { L"Eisa"             },
    { L"MicroChannel"     },
    { L"TurboChannel"     },
    { L"PCI"              },
    { L"VME"              },
    { L"Nu"               },
    { L"PCMCIA"           },
    { L"C"                },
    { L"MPI"              },
    { L"MPSA"             },
    { L"ProcessorInternal"},
    { L"InternalPower"    },
    { L"PNPISA"           },
    { L"PNP"              }/*,
    { "USB"              }*/  // USB busses are PNP busses
} ;

LPCWSTR IDS_CurrentTimeZone = L"CurrentTimeZone";
LPCWSTR IDS_NameFormat = L"NameFormat";
LPCWSTR IDS_Roles = L"Roles";
LPCWSTR IDS_DomainRole = L"DomainRole";
LPCWSTR IDS_PrimaryOwnerContact = L"PrimaryOwnerContact";
LPCWSTR IDS_SystemStartupDelay = L"SystemStartupDelay";
LPCWSTR IDS_SystemVariable = L"SystemVariable";

LPCWSTR IDS_PRINTER_STATUS_PAUSED                       = L"Paused";
LPCWSTR IDS_PRINTER_STATUS_PENDING_DELETION = L"Pending Deletion";
LPCWSTR IDS_PRINTER_STATUS_BUSY                         = L"Busy";
LPCWSTR IDS_PRINTER_STATUS_DOOR_OPEN            = L"Door Open";
LPCWSTR IDS_PRINTER_STATUS_ERROR                        = L"Error";
LPCWSTR IDS_PRINTER_STATUS_INITIALIZING         = L"Initializing";
LPCWSTR IDS_PRINTER_STATUS_IO_ACTIVE            = L"I/O Active";
LPCWSTR IDS_PRINTER_STATUS_MANUAL_FEED          = L"Manual Feed";
LPCWSTR IDS_PRINTER_STATUS_NO_TONER                     = L"No Toner";
LPCWSTR IDS_PRINTER_STATUS_NOT_AVAILABLE        = L"Not Available";
LPCWSTR IDS_PRINTER_STATUS_OFFLINE                      = L"Offline";
LPCWSTR IDS_PRINTER_STATUS_OUT_OF_MEMORY        = L"Out of Memory";
LPCWSTR IDS_PRINTER_STATUS_OUTPUT_BIN_FULL      = L"Output Bin Full";
LPCWSTR IDS_PRINTER_STATUS_PAGE_PUNT            = L"Page Punt";
LPCWSTR IDS_PRINTER_STATUS_PAPER_JAM            = L"Paper Jam";
LPCWSTR IDS_PRINTER_STATUS_PAPER_OUT            = L"Paper Out";
LPCWSTR IDS_PRINTER_STATUS_PAPER_PROBLEM        = L"Paper Problem";
LPCWSTR IDS_PRINTER_STATUS_PRINTING                     = L"Printing";
LPCWSTR IDS_PRINTER_STATUS_PROCESSING           = L"Processing";
LPCWSTR IDS_PRINTER_STATUS_TONER_LOW            = L"Toner Low";
LPCWSTR IDS_PRINTER_STATUS_UNAVAILABLE          = L"Unavailable";
LPCWSTR IDS_PRINTER_STATUS_USER_INTERVENTION = L"User Intervention";
LPCWSTR IDS_PRINTER_STATUS_WAITING                      = L"Waiting";
LPCWSTR IDS_PRINTER_STATUS_WARMING_UP           = L"Warming Up";
LPCWSTR IDS_DetectedErrorState              = L"DetectedErrorState";
LPCWSTR IDS_Ready = L"Ready";

LPCWSTR IDS_STATUS_OK                   = L"OK";
LPCWSTR IDS_STATUS_Degraded     = L"Degraded";
LPCWSTR IDS_STATUS_Error                = L"Error";
LPCWSTR IDS_STATUS_Unknown      = L"Unknown";
LPCWSTR IDS_PrinterStatus       = L"PrinterStatus";
LPCWSTR IDS_PaperSizeSupported  = L"PaperSizeSupported";
LPCWSTR IDS_Persistent  = L"Persistent Connection";
LPCWSTR IDS_Resource_Remembered = L"RESOURCE REMEMBERED";
LPCWSTR IDS_Current     = L"Current Connection";
LPCWSTR IDS_Resource_Connected = L"RESOURCE CONNECTED";

LPCWSTR IDS_LM_Workstation = L"LM_Workstation";
LPCWSTR IDS_LM_Server = L"LM_Server";
LPCWSTR IDS_SQLServer = L"SQLServer";
LPCWSTR IDS_Domain_Controller = L"Primary_Domain_Controller";
LPCWSTR IDS_Domain_Backup_Controller = L"Backup_Domain_Controller";
LPCWSTR IDS_Timesource = L"Timesource";
LPCWSTR IDS_AFP = L"Apple_File_Protocol";
LPCWSTR IDS_Novell = L"Novell";
LPCWSTR IDS_Domain_Member = L"Domain_Member";
LPCWSTR IDS_Local_List_Only = L"Local_List_Only";
LPCWSTR IDS_Print = L"Print";
LPCWSTR IDS_DialIn = L"DialIn";
LPCWSTR IDS_Xenix_Server = L"Xenix_Server";
LPCWSTR IDS_MFPN = L"MFPN";
LPCWSTR IDS_NT = L"NT";
LPCWSTR IDS_WFW = L"Windows_For_Workgroups";
LPCWSTR IDS_Server_NT = L"Server_NT";
LPCWSTR IDS_Potential_Browser = L"Potential_Browser";
LPCWSTR IDS_Backup_Browser = L"Backup_Browser";
LPCWSTR IDS_Master_Browser = L"Master_Browser";
LPCWSTR IDS_Domain_Master = L"Domain_Master";
LPCWSTR IDS_Domain_Enum = L"Domain_Enum";
LPCWSTR IDS_Windows_9x = L"Windows_9x";
LPCWSTR IDS_DFS = L"DFS";
LPCWSTR IDS_JobStatus = L"JobStatus";

LPCWSTR IDS_UPSName = L"Uninterruptible Power Supply";
LPCWSTR IDS_UPSBatteryName = L"Uninterruptible Power Supply Battery";
LPCWSTR IDS_BatteryName = L"Internal Battery";

LPCWSTR IDS_PNPDeviceID = L"PNPDeviceID";
LPCWSTR IDS_ClassGuid = L"ClassGuid";
LPCWSTR IDS_ConfigManagerErrorCode = L"ConfigManagerErrorCode";
LPCWSTR IDS_ConfigManagerUserConfig = L"ConfigManagerUserConfig";

LPCWSTR IDS_ProcessCreationClassName    = L"ProcessCreationClassName";
LPCWSTR IDS_ProcessHandle                               = L"ProcessHandle";
LPCWSTR IDS_ExecutionState                              = L"ExecutionState";
LPCWSTR IDS_PriorityBase                                = L"PriorityBase";
LPCWSTR IDS_StartAddress                                = L"StartAddress";
LPCWSTR IDS_ThreadState                                 = L"ThreadState";
LPCWSTR IDS_ThreadWaitReason                    = L"ThreadWaitReason";

LPCWSTR IDS_OSAutoDiscovered                    = L"OSAutoDiscovered";

// Security provider related strings:
LPCWSTR IDS_SecuredObject     = L"SecuredObject";
LPCWSTR IDS_Account = L"Account";
LPCWSTR IDS_AccountName = L"AccountName";
LPCWSTR IDS_ReferencedDomainName = L"ReferencedDomainName";
LPCWSTR IDS_AceType = L"AceType";
LPCWSTR IDS_AceFlags = L"AceFlags";
LPCWSTR IDS_AccessMask = L"AccessMask";
LPCWSTR IDS_OwnedObject = L"ownedObject";
LPCWSTR IDS_InheritedObjectGUID = L"GuidInheritedObjectType";
LPCWSTR IDS_ObjectTypeGUID      = L"GuidObjectType";
LPCWSTR IDS_Sid = L"Sid";
LPCWSTR IDS_Trustee = L"Trustee";
LPCWSTR IDS_ControlFlags = L"ControlFlags";
LPCWSTR IDS_Group = L"Group";
LPCWSTR IDS_DACL = L"DACL";
LPCWSTR IDS_SACL = L"SACL";
LPCWSTR IDS_SidLength = L"SidLength";
LPCWSTR IDS_SecuritySetting = L"SecuritySetting";
LPCWSTR IDS_BinaryRepresentation = L"BinaryRepresentation";
LPCWSTR IDS_Inheritance = L"Inheritance";
LPCWSTR IDS_SIDString = L"SIDString";
LPCWSTR IDS_OwnerPermissions = L"OwnerPermissions";
/////////////////////////////////////////////////////////////////////////////////////
//added for ComCatalog classes

LPCWSTR IDS_Category                                    = L"Category";
LPCWSTR IDS_Component                                   = L"Component";
LPCWSTR IDS_ComponentId                                 = L"ComponentId";
LPCWSTR IDS_CategoryId                                  = L"CategoryId";
LPCWSTR IDS_Insertable                                  = L"Insertable";
LPCWSTR IDS_JavaClass                                   = L"JavaClass";
LPCWSTR IDS_InprocServer32                              = L"InprocServer32";
LPCWSTR IDS_InprocServer                                = L"InprocServer";
LPCWSTR IDS_LocalServer32                               = L"LocalServer32";
LPCWSTR IDS_LocalServer                                 = L"LocalServer";
LPCWSTR IDS_ThreadingModel                              = L"ThreadingModel";
LPCWSTR IDS_InprocHandler32                             = L"InprocHandler32";
LPCWSTR IDS_InprocHandler                               = L"InprocHandler";
LPCWSTR IDS_TreatAsClsid                                = L"TreatAsClsid";
LPCWSTR IDS_AutoTreatAsClsid                    = L"AutoTreatAsClsid";
LPCWSTR IDS_ProgId                                              = L"ProgId";
LPCWSTR IDS_VersionIndependentProgId    = L"VersionIndependentProgId";
LPCWSTR IDS_TypeLibraryId                               = L"TypeLibraryId";
LPCWSTR IDS_AppID                                               = L"AppID";
LPCWSTR IDS_UseSurrogate                                = L"UseSurrogate";
LPCWSTR IDS_CustomSurrogate                             = L"CustomSurrogate";
LPCWSTR IDS_RemoteServerName                    = L"RemoteServerName";
LPCWSTR IDS_RunAsUser                                   = L"RunAsUser";
LPCWSTR IDS_AuthenticationLevel                 = L"AuthenticationLevel";
LPCWSTR IDS_LocalService                                = L"LocalService";
LPCWSTR IDS_EnableAtStorageActivation   = L"EnableAtStorageActivation";
LPCWSTR IDS_OldVersion                                  = L"OldVersion";
LPCWSTR IDS_NewVersion                                  = L"NewVersion";
LPCWSTR IDS_AutoConvertToClsid                  = L"AutoConvertToClsid";
LPCWSTR IDS_DefaultIcon                                 = L"DefaultIcon";
LPCWSTR IDS_ToolBoxBitmap32                             = L"ToolBoxBitmap32";
LPCWSTR IDS_ServiceParameters                   = L"ServiceParameters";
LPCWSTR IDS_ShortDisplayName                    = L"ShortDisplayName";
LPCWSTR IDS_LongDisplayName                             = L"LongDisplayName";
LPCWSTR IDS_Client                                              = L"Client";
LPCWSTR IDS_Application                                 = L"Application";

LPCWSTR IDS_Started                     = L"Started";
LPCWSTR IDS_ProcessId                   = L"ProcessId";
LPCWSTR IDS_ExitCode                    = L"ExitCode";
LPCWSTR IDS_ServiceSpecificExitCode     = L"ServiceSpecificExitCode";
LPCWSTR IDS_CheckPoint                  = L"CheckPoint";
LPCWSTR IDS_WaitHint                    = L"WaitHint";
LPCWSTR IDS_DesktopInteract             = L"DesktopInteract";
LPCWSTR IDS_StartMode                   = L"StartMode";

LPCWSTR IDS_BlockSize                   = L"BlockSize";
LPCWSTR IDS_NumberOfBlocks              = L"NumberOfBlocks";
LPCWSTR IDS_PrimaryPartition            = L"PrimaryPartition";

LPCWSTR IDS_Handedness                  = L"Handedness";
LPCWSTR IDS_DoubleSpeedThreshold        = L"DoubleSpeedThreshold";
LPCWSTR IDS_QuadSpeedThreshold          = L"QuadSpeedThreshold";
LPCWSTR IDS_PurposeDescription          = L"PurposeDescription";

LPCWSTR IDS_SameElement                 = L"SameElement";
LPCWSTR IDS_SystemElement               = L"SystemElement";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\session.cpp ===
//=============================================================================
// session.cpp -- implementation of session collection class.
//
//  Copyright (c) 1998-2002 Microsoft Corporation, All Rights Reserved
//=============================================================================



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#pragma warning (disable: 4786)


#include "precomp.h"
#include <map>
#include <vector>
#include <comdef.h>
#include "chstring.h"
#include "session.h"
#include <ProvExce.h>
#include <AssertBreak.h>
#include <wbemcli.h>
#include <ntsecapi.h>

#ifdef _WIN32_WINNT
#define SECURITY_WIN32
#else
#define SECURITY_WIN16
#endif

#include <sspi.h>

#include "ctoken.h"

#include <autoptr.h>
#include <ScopeGuard.h>

typedef SECURITY_STATUS (SEC_ENTRY *PFN_LSA_ENUMERATE_LOGON_SESSIONS)
(
    OUT PULONG  LogonSessionCount,
    OUT PLUID*  LogonSessionList
);


typedef SECURITY_STATUS (SEC_ENTRY *PFN_LSA_GET_LOGON_SESSION_DATA)
(
    IN   PLUID                           LogonId,
    OUT  PSECURITY_LOGON_SESSION_DATA*   ppLogonSessionData
);


typedef NTSTATUS (*PFN_LSA_FREE_RETURN_BUFFER)
(
    IN PVOID Buffer
);



//*****************************************************************************
// CUserSessionCollection functions
//*****************************************************************************

CUserSessionCollection::CUserSessionCollection()
{
    Refresh();
}


CUserSessionCollection::CUserSessionCollection(
    const CUserSessionCollection& sescol)
{
    m_usr2ses.clear();

    USER_SESSION_ITERATOR sourceIter;

    for(sourceIter = sescol.m_usr2ses.begin();
        sourceIter != sescol.m_usr2ses.end();
        sourceIter++)
    {
        m_usr2ses.insert(
            USER_SESSION_MAP::value_type(        
                sourceIter->first,
                sourceIter->second));
    }

}



DWORD CUserSessionCollection::Refresh()
{
    DWORD dwRet = ERROR_SUCCESS;

    // Empty out previous contents...
    m_usr2ses.clear();

    dwRet = CollectSessions();

    return dwRet;
}



DWORD CUserSessionCollection::CollectSessions()
{
    DWORD dwRet = ERROR_SUCCESS;
    std::vector<CProcess> vecProcesses;
    SmartCloseHandle hProcess;
    SmartCloseHandle hToken;
    TOKEN_STATISTICS tokstats;
    PTOKEN_USER ptokusr = NULL;
    DWORD dwRetSize = 0L;
    PSID psidUsr = NULL;
    CHString chstrUsr;
    LUID luidSes;


    // Enable the debug privilege...
    EnablePrivilegeOnCurrentThread(SE_DEBUG_NAME);

    // Get a list of all running processes...
    dwRet = GetProcessList(vecProcesses);

    if(dwRet == ERROR_SUCCESS)
    {
        // For each member of the process list...
        for(long m = 0L; 
            m < vecProcesses.size(); 
            m++)
        {
            // open the process...
            ::SetLastError(ERROR_SUCCESS);
            dwRet = ERROR_SUCCESS;

            hProcess = ::OpenProcess(
                PROCESS_QUERY_INFORMATION,
                FALSE,
                vecProcesses[m].GetPID());

            if(hProcess == NULL)
            {
                dwRet = ::GetLastError();
            }

            // get the process token...
            if(hProcess != NULL &&
                dwRet == ERROR_SUCCESS)
            {
                ::SetLastError(ERROR_SUCCESS);
                dwRet = ERROR_SUCCESS;

                if(!::OpenProcessToken(
                    hProcess,
                    TOKEN_QUERY,
                    &hToken))
                {
                    dwRet = ::GetLastError();
                }
            }

            // get the token statistics...
            if(hToken != NULL &&
                dwRet == ERROR_SUCCESS)
            {
                ::SetLastError(ERROR_SUCCESS);
                dwRet = ERROR_SUCCESS;
                if(!::GetTokenInformation(
                    hToken,
                    TokenStatistics,
                    &tokstats,
                    sizeof(TOKEN_STATISTICS),
                    &dwRetSize))
                {
                    dwRet = ::GetLastError();
                }
            }

			//
			// smart token user
			//
			wmilib::auto_buffer < BYTE > smartptokusr;

            // get the token user sid...
            if(dwRet == ERROR_SUCCESS)
            {
                // the token user struct varries
                // in size depending on the size
                // of the sid in the SID_AND_ATTRIBUTES
                // structure, so need to allocate
                // it dynamically.
                if(!::GetTokenInformation(
                    hToken,
                    TokenUser,
                    NULL,
                    0L,
                    &dwRetSize))
                {
                    dwRet = ::GetLastError();
                }
                if(dwRet == ERROR_INSUFFICIENT_BUFFER)
                {
                    smartptokusr.reset ( new BYTE [ dwRetSize ] ) ;
					ptokusr = (PTOKEN_USER) smartptokusr.get () ;
                    DWORD dwTmp = dwRetSize;

					if(!::GetTokenInformation(
                            hToken,
                            TokenUser,
                            ptokusr,
                            dwTmp,
                            &dwRetSize))
                    {
                        dwRet = ::GetLastError();
                    }
					else
					{
						dwRet = ERROR_SUCCESS ;
					}
                }
            }
        
            if(ptokusr != NULL)
            {
                if(dwRet == ERROR_SUCCESS)
                {
                    psidUsr = (ptokusr->User).Sid;

                    // from the token statistics, get 
                    // the TokenID LUID of the session...
                    luidSes.LowPart = tokstats.AuthenticationId.LowPart;
                    luidSes.HighPart = tokstats.AuthenticationId.HighPart; 

                    // try to find the session of the 
                    // process in the multimap...
                    USER_SESSION_ITERATOR usiter;
                    
                    if(FindSessionInternal(
                        luidSes,
                        usiter))
                    {
                        // try to find the process id in the 
                        // session's process vector...
                        CSession sesTmp(usiter->second);
                        CProcess* procTmp = NULL;
                        bool fFoundIt = false;

                        for(long z = 0L; 
                            z < sesTmp.m_vecProcesses.size() && !fFoundIt;
                            z++)
                        {
                            if((DWORD)(sesTmp.m_vecProcesses[z].GetPID()) == 
                                vecProcesses[m].GetPID())
                            {
                                fFoundIt = true;
                            }
                        }
                    
                        // If we didn't find the process in the
                        // session's list of processes, add it in...
                        if(!fFoundIt)
                        {
                            (usiter->second).m_vecProcesses.push_back(
                                CProcess(vecProcesses[m]));
                        }
                    }
                    else // no such session in the map, so add an entry
                    {
                        // Create new CSession(tokenid LUID), and 
                        // add process to the session's process vector...         
                        CSession sesNew(luidSes);
                        sesNew.m_vecProcesses.push_back(
                            vecProcesses[m]);

                        // add CUser(user sid) to map.first and the 
                        // CSession just created to map.second...
                        CUser cuTmp(psidUsr);
                        if(cuTmp.IsValid())
                        {
                            m_usr2ses.insert(
                                USER_SESSION_MAP::value_type(
                                    cuTmp,
                                    sesNew));
                        }
                        else
                        {
                            LogErrorMessage2(
                                L"Token of process %d contains an invalid sid", 
                                vecProcesses[m].GetPID());
                        }
                    }
                }
            }
        } // next process
    }

    // There may have been sessions not associated
    // with any processes.  To get these, we will
    // use LSA.
    CollectNoProcessesSessions();

    return dwRet;
}


void CUserSessionCollection::Copy(
    CUserSessionCollection& out) const
{
    out.m_usr2ses.clear();

    USER_SESSION_ITERATOR meIter;

    for(meIter = m_usr2ses.begin();
        meIter != m_usr2ses.end();
        meIter++)
    {
        out.m_usr2ses.insert(
            USER_SESSION_MAP::value_type(        
                meIter->first,
                meIter->second));
    }
}


// Support enumeration of users.  Returns
// a newly allocated copy of what was in
// the map (caller must free).
CUser* CUserSessionCollection::GetFirstUser(
    USER_SESSION_ITERATOR& pos)
{
    CUser* cusrRet = NULL;

    if(!m_usr2ses.empty())
    {
        pos = m_usr2ses.begin();
        cusrRet = new CUser(pos->first);
    }
    
    return cusrRet;
}

// Returns a newly allocated CUser*, which
// the caller must free.
CUser* CUserSessionCollection::GetNextUser(
    USER_SESSION_ITERATOR& pos)
{
    // Users are the non-unique part of 
    // the map, so we need to go through
    // the map until the next user entry
    // comes up.
    CUser* usrRet = NULL;

    while(pos != m_usr2ses.end())
    {
        CHString chstrSidCur;
        pos->first.GetSidString(chstrSidCur);
    
        pos++;

        if(pos != m_usr2ses.end())
        {
            CHString chstrSidNext;
            pos->first.GetSidString(chstrSidNext);

            // Return the first instance where
            // the next user is different from 
            // the current one.
            if(chstrSidNext.CompareNoCase(chstrSidCur) != 0)
            {
                usrRet = new CUser(pos->first);
                break;
            }
        }
    }

    return usrRet;        
}


// Support enumeration of sessions
// belonging to a particular user.
CSession* CUserSessionCollection::GetFirstSessionOfUser(
    CUser& usr,
    USER_SESSION_ITERATOR& pos)
{
    CSession* csesRet = NULL;

    if(!m_usr2ses.empty())
    {
        pos = m_usr2ses.find(usr);
        if(pos != m_usr2ses.end())
        {
            csesRet = new CSession(pos->second);
        }
    }
    return csesRet;
}


CSession* CUserSessionCollection::GetNextSessionOfUser(
    USER_SESSION_ITERATOR& pos)
{
    // Sessions are the unique part of 
    // the map, so we just need to get 
    // the next one as long as pos.first
    // matches usr...
    CSession* sesRet = NULL;

    if(pos != m_usr2ses.end())
    {
        CHString chstrUsr1;
        CHString chstrUsr2;
        
        (pos->first).GetSidString(chstrUsr1);

        pos++;
        
        if(pos != m_usr2ses.end())
        {
            (pos->first).GetSidString(chstrUsr2);
            if(chstrUsr1.CompareNoCase(chstrUsr2) == 0)
            {
                sesRet = new CSession(pos->second);
            }
        }
    }

    return sesRet;
}



// Support enumeration of all sessions.  Returns a 
// newly allocated CSession*, which the caller
// must free.
CSession* CUserSessionCollection::GetFirstSession(
    USER_SESSION_ITERATOR& pos)
{
    CSession* csesRet = NULL;

    if(!m_usr2ses.empty())
    {
        pos = m_usr2ses.begin();
        csesRet = new CSession(pos->second);
    }
    return csesRet;
}

// Returns a newly allocated CSession* that the
// caller must free.
CSession* CUserSessionCollection::GetNextSession(
    USER_SESSION_ITERATOR& pos)
{
    // Sessions are the unique part of 
    // the map, so we just need to get 
    // the next one...
    CSession* sesRet = NULL;

    if(pos != m_usr2ses.end())
    {
        pos++;
        if(pos != m_usr2ses.end())
        {
            sesRet = new CSession(pos->second);
        }
    }

    return sesRet;
}


// Support finding a particular session.
// This internal version hands back an iterator
// on our member map that points to the found
// instance if found (when the function returns
// true.  If the function returns
// false, the iterator points to the end of our
// map.
bool CUserSessionCollection::FindSessionInternal(
    LUID& luidSes,
    USER_SESSION_ITERATOR& usiOut)
{
    bool fFoundIt = false;

    for(usiOut = m_usr2ses.begin();
        usiOut != m_usr2ses.end();
        usiOut++)
    {
        LUID luidTmp = (usiOut->second).GetLUID();
        if(luidTmp.HighPart == luidSes.HighPart &&
           luidTmp.LowPart == luidSes.LowPart)
        {
            fFoundIt = true;
            break;
        }
    }

    return fFoundIt;
}


// Support finding a particular session - external
// callers can call this one, and are given a new
// CSession* they can play with.
CSession* CUserSessionCollection::FindSession(
    LUID& luidSes)
{
    CSession* psesRet = NULL;
    USER_SESSION_ITERATOR pos;
    
    if(FindSessionInternal(
        luidSes,
        pos))
    {
        psesRet = new CSession(pos->second);
    }

    return psesRet;
}

CSession* CUserSessionCollection::FindSession(
    __int64 i64luidSes)
{
    LUID luidSes = *((LUID*)(&i64luidSes));
    return FindSession(luidSes);
}


// Support enumeration of processes
// belonging to a particular user.  Returns
// newly allocated CProcess* which the caller
// must free.
CProcess* CUserSessionCollection::GetFirstProcessOfUser(
    CUser& usr,
    USER_SESSION_PROCESS_ITERATOR& pos)
{
    CProcess* cprocRet = NULL;
    CHString chstrUsrSidStr;
    CHString chstrTmp;

    if(!m_usr2ses.empty())
    {
        usr.GetSidString(chstrUsrSidStr);
        pos.usIter = m_usr2ses.find(usr);
        while(pos.usIter != m_usr2ses.end())
        {
            // Get the sid string of the user we
            // are at and see whether the strings
            // are the same (e.g., whether this is a
            // session associated with the specified
            // user)...
            (pos.usIter)->first.GetSidString(chstrTmp);
            if(chstrUsrSidStr.CompareNoCase(chstrTmp) == 0)
            {
                // Now check that the session of the user
                // we are on has processes...
                if(!(((pos.usIter)->second).m_vecProcesses.empty()))
                {
                    pos.procIter = 
                        ((pos.usIter)->second).m_vecProcesses.begin();
                    cprocRet = new CProcess(*(pos.procIter));
                }
                else
                {
                    // the session for this user has
                    // no processes, so go to the next 
                    // session...
                    (pos.usIter)++;
                }
            }
        }
    }

    return cprocRet;
}


// Returns a newly allocated CProcess* that the
// caller must free.
CProcess* CUserSessionCollection::GetNextProcessOfUser(
    USER_SESSION_PROCESS_ITERATOR& pos)
{
    CProcess* cprocRet = NULL;
    CHString chstrCurUsr;
    CHString chstrNxtSesUsr;

    if(pos.usIter != m_usr2ses.end())
    {
        (pos.usIter)->first.GetSidString(chstrCurUsr);

        while(pos.usIter != m_usr2ses.end())
        {
            // First try to get the next process
            // within the current session.  If we
            // were at the end of the list of processes
            // for the current session, go to the
            // next session...
            (pos.procIter)++;

            // Of course, if we have moved on
            // to a different user, then stop.
            (pos.usIter)->first.GetSidString(chstrNxtSesUsr);
            if(chstrCurUsr.CompareNoCase(chstrNxtSesUsr) == 0)
            {
                if(pos.procIter == 
                    ((pos.usIter)->second).m_vecProcesses.end())
                {
                    (pos.usIter)++;
                }
                else
                {    
                    cprocRet = new CProcess(*(pos.procIter));    
                }
            }
        }
    }

    return cprocRet;
}



// Support enumeration of all processes.  Returns
// newly allocated CProcess* which the caller
// must free.
CProcess* CUserSessionCollection::GetFirstProcess(
    USER_SESSION_PROCESS_ITERATOR& pos)
{
    CProcess* cprocRet = NULL;

    if(!m_usr2ses.empty())
    {
        pos.usIter = m_usr2ses.begin();
        while(pos.usIter != m_usr2ses.end())
        {
            if(!(((pos.usIter)->second).m_vecProcesses.empty()))
            {
                pos.procIter = 
                    ((pos.usIter)->second).m_vecProcesses.begin();
                cprocRet = new CProcess(*(pos.procIter));
            }
            else
            {
                (pos.usIter)++;
            }
        }
    }

    return cprocRet;
}


// Returns a newly allocated CProcess* that the
// caller must free.
CProcess* CUserSessionCollection::GetNextProcess(
    USER_SESSION_PROCESS_ITERATOR& pos)
{
    CProcess* cprocRet = NULL;

    while(pos.usIter != m_usr2ses.end())
    {
        // First try to get the next process
        // within the current session.  If we
        // were at the end of the list of processes
        // for the current session, go to the
        // next session...
        (pos.procIter)++;
        if(pos.procIter == 
            ((pos.usIter)->second).m_vecProcesses.end())
        {
            (pos.usIter)++;
        }
        else
        {    
            cprocRet = new CProcess(*(pos.procIter));    
        }
    }

    return cprocRet;
}


// This helper enumerates the current set of processes
// and ads each process id as a DWORD in the vector.
DWORD CUserSessionCollection::GetProcessList( std::vector<CProcess>& vecProcesses ) const
{
    DWORD dwRet = ERROR_SUCCESS;

    // First, load up ntdll...
    HMODULE hLib = NULL;
    PFN_NT_QUERY_SYSTEM_INFORMATION pfnNtQuerySystemInformation = NULL;

    hLib = LoadLibraryW(L"NTDLL.DLL");
    if(hLib != NULL)
    {
		//
		// auto FreeLibrary
		//
		ON_BLOCK_EXIT ( FreeLibrary, hLib ) ;

        // Get proc address of NtQuerySystemInformation...
        pfnNtQuerySystemInformation = (PFN_NT_QUERY_SYSTEM_INFORMATION)
                                GetProcAddress(
                                    hLib,
                                    "NtQuerySystemInformation");
        
        if(pfnNtQuerySystemInformation != NULL)
        {
            // Ready to rock.  Enable debug priv...
            EnablePrivilegeOnCurrentThread(SE_DEBUG_NAME);
            
            DWORD dwProcessInformationSize = 0;
	        SYSTEM_PROCESS_INFORMATION* ProcessInformation = NULL;

			//
			// smart ProcessInformation
			//
			wmilib::auto_buffer < BYTE > SmartProcessInformation;

			// Get the process information...

            BOOL fRetry = TRUE;
			while(fRetry)
			{
				dwRet = pfnNtQuerySystemInformation(
					SystemProcessInformation,
					ProcessInformation,
					dwProcessInformationSize,
					NULL);

				if(dwRet == STATUS_INFO_LENGTH_MISMATCH)
				{
					dwProcessInformationSize += 32768;

                    SmartProcessInformation.reset ( new BYTE [ dwProcessInformationSize ] );
					ProcessInformation = (SYSTEM_PROCESS_INFORMATION*)SmartProcessInformation.get () ;
				}
				else
				{
					fRetry = FALSE;
				}
			}

            // If we got the process information, process it...
            if(ProcessInformation != NULL &&
                dwRet == ERROR_SUCCESS)
            {
                SYSTEM_PROCESS_INFORMATION* CurrentInformation = NULL;
                DWORD dwNextOffset;
                CurrentInformation = ProcessInformation;
                bool fContinue = true;
                while(CurrentInformation != NULL &&
                        fContinue)
                {
                    {
                        CProcess cptmp(
                            HandleToUlong(CurrentInformation->UniqueProcessId),
                            (CurrentInformation->ImageName).Buffer);

                        vecProcesses.push_back(cptmp);
                    }

                    dwNextOffset = CurrentInformation->NextEntryOffset;
                    if(dwNextOffset)
                    {
                        CurrentInformation = (SYSTEM_PROCESS_INFORMATION*) 
                            (((BYTE*) CurrentInformation) + dwNextOffset);
                    }
                    else
                    {
                        fContinue = false;
                    }
                }
            }
        }
	}
    else
    {
        LogErrorMessage(L"Failed to load library ntdll.dll");
    }

    return dwRet;
}

// Implementation lifted from dllutils.cpp.
DWORD CUserSessionCollection::EnablePrivilegeOnCurrentThread(
    LPCTSTR szPriv) const
{
    SmartCloseHandle    hToken = NULL;
    TOKEN_PRIVILEGES    tkp;
    BOOL                bLookup = FALSE;
    DWORD               dwLastError = ERROR_SUCCESS;

    // Try to open the thread token.  
    if (::OpenThreadToken(
            GetCurrentThread(), 
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
            FALSE, 
            &hToken))
    {

        {
            bLookup = ::LookupPrivilegeValue(
                NULL, 
                szPriv, 
                &tkp.Privileges[0].Luid);
        }
        if (bLookup)
        {
            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // Clear the last error.
            SetLastError(0);

            // Turn it on
            ::AdjustTokenPrivileges(
                hToken, 
                FALSE, 
                &tkp, 
                0,
                (PTOKEN_PRIVILEGES) NULL, 
                0);

            dwLastError = GetLastError();
        }
    }
	else
	{
		dwLastError = ::GetLastError();
	}

    // We have to check GetLastError() because 
    // AdjustTokenPrivileges lies about
    // its success but GetLastError() doesn't.
    return dwLastError;
}



bool CUserSessionCollection::IsSessionMapped(
    LUID& luidSes)
{
    bool fRet = false;

    USER_SESSION_ITERATOR usiter;
    usiter = m_usr2ses.begin();
    for(usiter = m_usr2ses.begin(); 
        usiter != m_usr2ses.end() && !fRet;
        usiter++)
    {
        LUID luidTmp = (usiter->second).GetLUID();
        if(luidTmp.HighPart == luidSes.HighPart &&
           luidTmp.LowPart == luidSes.LowPart)
        {
            fRet = true;
        }
    }

    return fRet;                                                   
}


bool CUserSessionCollection::IsSessionMapped(
    __int64 i64luidSes)
{
    LUID luidSes = *((LUID*)(&i64luidSes));
    return IsSessionMapped(luidSes);
}


// Collects sessions that have no associated
// process.  Uses LSA to enumerate sessions,
// then checks to see if we have each session
// already.  If we don't, adds it to our map.

DWORD CUserSessionCollection::CollectNoProcessesSessions()
{
    DWORD dwRet = ERROR_SUCCESS;
    ULONG ulLogonSessionCount = 0L;
    PLUID pluidLogonSessions = NULL;
    HMODULE hLib = NULL;
    PFN_LSA_ENUMERATE_LOGON_SESSIONS pfnEnumLogonSessions = NULL;
    PFN_LSA_GET_LOGON_SESSION_DATA pfnGetLogonSessionData = NULL;
    PFN_LSA_FREE_RETURN_BUFFER pfnLsaFreeReturnBuffer = NULL;

    // Doing a load library here rather than using the
    // resource manager, as SECURITYAPI.CPP defines us
    // to point to SECURITY.DLL, not SECUR32.DLL for the
    // W2K case.  

    hLib = ::LoadLibraryW(L"SECUR32.DLL");
    if(hLib)
    {
		//
		// auto FreeLibrary
		//
		ON_BLOCK_EXIT ( FreeLibrary, hLib ) ;

        pfnEnumLogonSessions = 
            (PFN_LSA_ENUMERATE_LOGON_SESSIONS) ::GetProcAddress(
                hLib,
                "LsaEnumerateLogonSessions");

        pfnGetLogonSessionData = 
            (PFN_LSA_GET_LOGON_SESSION_DATA) ::GetProcAddress(
                hLib,
                "LsaGetLogonSessionData");

        pfnLsaFreeReturnBuffer = 
            (PFN_LSA_FREE_RETURN_BUFFER) ::GetProcAddress(
                hLib,
                "LsaFreeReturnBuffer");

        if(pfnEnumLogonSessions &&
            pfnGetLogonSessionData &&
            pfnLsaFreeReturnBuffer)
        {    
            dwRet = pfnEnumLogonSessions(
                &ulLogonSessionCount,
                &pluidLogonSessions);
    
            if(dwRet == ERROR_SUCCESS &&
                pluidLogonSessions)
            {
				//
				// auto destructor for logon session
				//
				ON_BLOCK_EXIT ( pfnLsaFreeReturnBuffer, pluidLogonSessions ) ;

                for(ULONG u = 0L;
                    u < ulLogonSessionCount && dwRet == ERROR_SUCCESS;
                    u++)
                {
                    PSECURITY_LOGON_SESSION_DATA pSessionData = NULL;
                    dwRet = pfnGetLogonSessionData(
                        &pluidLogonSessions[u], 
                        &pSessionData);

                    if(dwRet == ERROR_SUCCESS &&
                        pSessionData)
                    {
						//
						// smart session data
						//
						ON_BLOCK_EXIT ( pfnLsaFreeReturnBuffer, pSessionData ) ;

                        // See if we have the session already...
                        if(!IsSessionMapped(pSessionData->LogonId))
                        {
                            // and if not, add it to the map.
                            CSession sesNew(pSessionData->LogonId);
                            CUser cuTmp(pSessionData->Sid);
                            CHString chstrTmp;
                            
                            if(cuTmp.IsValid())
                            {
                                cuTmp.GetSidString(chstrTmp);
                
                                m_usr2ses.insert(
                                    USER_SESSION_MAP::value_type(
                                        cuTmp,
                                        sesNew));
                            }
                            else
                            {
                                LUID luidTmp = sesNew.GetLUID();
                                LogMessage3(
                                    L"GetLogonSessionData returned logon data for session "
                                    L"luid %d (highpart) %u (lowpart) containing an invalid SID", 
                                    luidTmp.HighPart,
                                    luidTmp.LowPart);
                            }
                        }

                        // While we are here, add in various
                        // session properties lsa has been kind
                        // enough to provide for us.
                        USER_SESSION_ITERATOR usiter;
                        usiter = m_usr2ses.begin();
                        bool fFound = false;
                        while(usiter != m_usr2ses.end() &&
                            !fFound)
                        {
                            LUID luidTmp = pSessionData->LogonId;
                            __int64 i64Tmp = *((__int64*)(&luidTmp));

                            if((usiter->second).GetLUIDint64() ==
                                i64Tmp)
                            {
                                fFound = true;
                            }
                            else
                            {
                                usiter++;
                            }
                        }
                        if(fFound)
                        {
                            WCHAR wstrTmp[_MAX_PATH] = { '\0' };
                            if((pSessionData->AuthenticationPackage).Length < (_MAX_PATH - 1))
                            {
                                wcsncpy(
                                    wstrTmp, 
                                    (pSessionData->AuthenticationPackage).Buffer, 
                                    (pSessionData->AuthenticationPackage).Length);

                                (usiter->second).m_chstrAuthPkg = wstrTmp;
                            }
                            
                            (usiter->second).m_ulLogonType = 
                                pSessionData->LogonType;

                            (usiter->second).i64LogonTime = 
                                *((__int64*)(&(pSessionData->LogonTime)));
                        }
                    }
                }                
            }
        }
    }
    else
    {
        LogErrorMessage(L"Failed to load library SECUR32.dll");
    }

	return dwRet; 
}


//*****************************************************************************
// CSession functions
//*****************************************************************************

CSession::CSession(
    const LUID& luidSessionID)
{
    m_luid.LowPart = luidSessionID.LowPart;
    m_luid.HighPart = luidSessionID.HighPart;
    m_ulLogonType = 0;
    i64LogonTime = 0;
}

CSession::CSession(
    const CSession& ses)
{
    m_luid.LowPart = ses.m_luid.LowPart;
    m_luid.HighPart = ses.m_luid.HighPart;
    m_chstrAuthPkg = ses.m_chstrAuthPkg;
    m_ulLogonType = ses.m_ulLogonType;
    i64LogonTime = ses.i64LogonTime;

    m_vecProcesses.clear();
    for(long lPos = 0; 
        lPos < ses.m_vecProcesses.size(); 
        lPos++)
    {
        m_vecProcesses.push_back(
            ses.m_vecProcesses[lPos]);

    }
}


LUID CSession::GetLUID() const
{
    return m_luid;   
}

__int64 CSession::GetLUIDint64() const
{
    __int64 i64LuidSes = *((__int64*)(&m_luid));
    return i64LuidSes;    
}

CHString CSession::GetAuthenticationPkg() const
{
    return m_chstrAuthPkg;
}


ULONG CSession::GetLogonType() const
{
    return m_ulLogonType;
}


__int64 CSession::GetLogonTime() const
{
    return i64LogonTime;
}




// Functions to support enumeration of
// processes associated with this session.
// Returns a newly allocated CProcess* that
// the caller must free.
CProcess* CSession::GetFirstProcess(
    PROCESS_ITERATOR& pos)
{
    CProcess* procRet = NULL;
    if(!m_vecProcesses.empty())
    {
        pos = m_vecProcesses.begin();
        procRet = new CProcess(*pos);
    }
    return procRet;
}


// Returns a newly allocated CProcess* that
// the caller must free.
CProcess* CSession::GetNextProcess(
    PROCESS_ITERATOR& pos)
{
    CProcess* procRet = NULL;

    if(pos >= m_vecProcesses.begin() &&
       pos < m_vecProcesses.end())
    {
        pos++;
        if(pos != m_vecProcesses.end())
        {
            procRet = new CProcess(*pos);
        }
    }

    return procRet;
}



void CSession::Copy(
    CSession& sesCopy) const
{
    sesCopy.m_luid.LowPart = m_luid.LowPart;
    sesCopy.m_luid.HighPart = m_luid.HighPart;
    sesCopy.m_chstrAuthPkg = m_chstrAuthPkg;
    sesCopy.m_ulLogonType = m_ulLogonType;
    sesCopy.i64LogonTime = i64LogonTime;

    sesCopy.m_vecProcesses.clear();
    for(long lPos = 0; 
        lPos < m_vecProcesses.size(); 
        lPos++)
    {
        sesCopy.m_vecProcesses.push_back(
            m_vecProcesses[lPos]);

    }
}


// This function impersonates the 
// explorer process in the session's
// process array, if it is present.
// (If it isn't, impersonates the
// first process in the process array.)
// Returns the handle of token of the  
// thread we started from for easy  
// reversion, orINVALID_HANDLE_VALUE if  
// we couldn't impersonate.  The caller  
// must close that handle.
HANDLE CSession::Impersonate()
{
    HANDLE hCurToken = INVALID_HANDLE_VALUE;

	// Find the explorer process...
    DWORD dwImpProcPID = GetImpProcPID();
    if(dwImpProcPID != -1L)
    {
		//
		// smart CloseHandle
		//
		ScopeGuard SmartCloseHandleFnc = MakeGuard ( CloseHandle, hCurToken ) ;

        bool fOK = false;

        if(::OpenThreadToken(
            ::GetCurrentThread(), 
            TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE , 
            TRUE, 
            &hCurToken))
        {
            SmartCloseHandle hProcess;
            hProcess = ::OpenProcess(
                PROCESS_QUERY_INFORMATION,
                FALSE,
                dwImpProcPID);

            if(hProcess)
            {
                // now open its token...
                SmartCloseHandle hExplorerToken;
                if(::OpenProcessToken(
                        hProcess,
                        TOKEN_READ | TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
                        &hExplorerToken))
                {
					CProcessToken cpt ( hExplorerToken );
					if ( cpt.IsValidToken () )
					{
						TOKEN_TYPE type;
						if ( cpt.GetTokenType ( type ) )
						{
							if ( TokenPrimary == type )
							{
								CToken ct;
								if ( ct.Duplicate ( cpt, FALSE ) )
								{
									// Set the thread token...
									if(::SetThreadToken(NULL, ct.GetTokenHandle ()))
									{
										fOK = true;                        
									}
								}
							}
							else
							{
								// Set the thread token...
								if(::SetThreadToken(NULL, cpt.GetTokenHandle ()))
								{
									fOK = true;                        
								}
							}
						}
					}
                }
            }
        }

		SmartCloseHandleFnc.Dismiss () ;
        if (!fOK)
        {
            if(hCurToken != INVALID_HANDLE_VALUE)
            {
                ::CloseHandle(hCurToken);
                hCurToken = INVALID_HANDLE_VALUE;
            }    
        }
    }

    return hCurToken;
}


DWORD CSession::GetImpProcPID()
{
    DWORD dwRet = -1L;

    if(!m_vecProcesses.empty())
    {
        bool fFoundExplorerExe = false;

        for(long m = 0;
            m < m_vecProcesses.size() && 
             !fFoundExplorerExe;)
        {
            if(m_vecProcesses[m].GetImageName().CompareNoCase(
                L"explorer.exe") == 0)
            {
                fFoundExplorerExe = true;
                break;
            }
            else
            {
                m++;
            }
        }

        if(!fFoundExplorerExe)
        {
            m = 0;
        }

        dwRet = m_vecProcesses[m].GetPID();
    }

    return dwRet;
}



bool CSession::IsSessionIDValid(
        LPCWSTR wstrSessionID)
{
    bool fRet = true;
    
    if(wstrSessionID != NULL &&
        *wstrSessionID != L'\0')
    {
        for(const WCHAR* pwc = wstrSessionID;
            *pwc != NULL && fRet;
            pwc++)
        {
            fRet = iswdigit(*pwc);
        } 
    }
    else
    {
        fRet = false;
    }
            
    return fRet;
}


//*****************************************************************************
// CProcess functions
//*****************************************************************************

CProcess::CProcess() 
  :  m_dwPID(0) 
{
}


CProcess::CProcess(
    DWORD dwPID,
    LPCWSTR wstrImageName)
  :  m_dwPID(dwPID)
{
    m_chstrImageName = wstrImageName;
}


CProcess::CProcess(
    const CProcess& process)
{
    m_dwPID = process.m_dwPID;
    m_chstrImageName = process.m_chstrImageName;
}

CProcess::~CProcess()
{
}


DWORD CProcess::GetPID() const
{
    return m_dwPID;
}

CHString CProcess::GetImageName() const
{
    return m_chstrImageName;
}


void CProcess::Copy(
        CProcess& out) const
{
    out.m_dwPID = m_dwPID;
    out.m_chstrImageName = m_chstrImageName;
}




//*****************************************************************************
// CUser functions
//*****************************************************************************


CUser::CUser(
    PSID pSid)
  :  m_sidUser(NULL),
     m_fValid(false)
{
    if(::IsValidSid(pSid))
    {
        DWORD dwSize = ::GetLengthSid(pSid);
        m_sidUser = NULL;
        m_sidUser = malloc(dwSize);
        if(m_sidUser == NULL)
        {
		    throw CHeap_Exception(
                CHeap_Exception::E_ALLOCATION_ERROR);
        }
        else
        {
	        ::CopySid(
                dwSize, 
                m_sidUser, 
                pSid);

            m_fValid = true;
        }
    }
}



CUser::CUser(
    const CUser& user)
{
    DWORD dwSize = ::GetLengthSid(user.m_sidUser);
    m_sidUser = malloc(dwSize);

    if(m_sidUser == NULL)
    {
		throw CHeap_Exception(
            CHeap_Exception::E_ALLOCATION_ERROR);
    }

	::CopySid(
        dwSize, 
        m_sidUser, 
        user.m_sidUser);

    m_fValid = user.m_fValid;

}



CUser::~CUser()
{
    if(m_sidUser) 
    {
        free(m_sidUser);
        m_sidUser = NULL;
    }
}


bool CUser::IsValid()
{
    return m_fValid;
}


void CUser::Copy(
    CUser& out) const
{
    if(out.m_sidUser) 
    {
        free(out.m_sidUser);
        out.m_sidUser = NULL;
    }

    DWORD dwSize = ::GetLengthSid(m_sidUser);
    out.m_sidUser = malloc(dwSize);

    if(out.m_sidUser == NULL)
    {
		throw CHeap_Exception(
            CHeap_Exception::E_ALLOCATION_ERROR);
    }

	::CopySid(
        dwSize, 
        out.m_sidUser, 
        m_sidUser);

    out.m_fValid = m_fValid;
}


// Implementation lifted from sid.cpp.
void CUser::GetSidString(CHString& str) const
{
    ASSERT_BREAK(m_fValid);

    if(m_fValid)
    {
        // Initialize m_strSid - human readable form of our SID
	    SID_IDENTIFIER_AUTHORITY *psia = NULL;
        psia = ::GetSidIdentifierAuthority( m_sidUser );

	    // We assume that only last byte is used (authorities between 0 and 15).
	    // Correct this if needed.
	    ASSERT_BREAK( psia->Value[0] == psia->Value[1] == 
                      psia->Value[2] == psia->Value[3] == 
                      psia->Value[4] == 0 );

	    DWORD dwTopAuthority = psia->Value[5];

	    str.Format( L"S-1-%u", dwTopAuthority );
	    CHString strSubAuthority;
	    int iSubAuthorityCount = *( GetSidSubAuthorityCount( m_sidUser ) );
	    for ( int i = 0; i < iSubAuthorityCount; i++ ) {

		    DWORD dwSubAuthority = *( GetSidSubAuthority( m_sidUser, i ) );
		    strSubAuthority.Format( L"%u", dwSubAuthority );
		    str += _T("-") + strSubAuthority;
	    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\sid.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*
 *	CSid.cpp - implementation file for CSid class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#include "precomp.h"
#include <assertbreak.h>

#include "Sid.h"
#include <comdef.h>
#include <accctrl.h>
#include "wbemnetapi32.h"
#include "SecUtils.h"

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::CSid
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSid::CSid( void )
:	m_pSid( NULL ),
	m_snuAccountType( SidTypeUnknown ),
	m_dwLastError( ERROR_SUCCESS )
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::CSid
//
//	Class constructor.
//
//	Inputs:
//				PSID		pSid - SID to validate and get account
//							info for.
//				LPCTSTR		pszComputerName - Remote computer to
//							execute on.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSid::CSid( PSID pSid, LPCTSTR pszComputerName )
:	m_pSid( NULL ),
	m_snuAccountType( SidTypeUnknown ),
	m_dwLastError( ERROR_SUCCESS )
{
    InitFromSid( pSid, pszComputerName );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::CSid
//
//	Initializes the object from a PSid, with an indicator as to whether
//  we should lookup and initialize the associated domain and account.
//
//	Inputs:
//				PSID		pSid - PSid to look up.
//				LPCTSTR		pszComputerName - Remote computer to
//							execute on.
//              bool        fLookup - indicates whether to determine
//                          the domain and account associated with
//                          the sid at this time.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if OK.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
CSid::CSid( PSID pSid, LPCTSTR pszComputerName, bool fLookup )
:	m_pSid( NULL ),
	m_snuAccountType( SidTypeUnknown ),
	m_dwLastError( ERROR_SUCCESS )
{
    InitFromSid(pSid, pszComputerName, fLookup);
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::CSid
//
//	Class constructor.
//
//	Inputs:
//				LPCTSTR		pszAccountName - Account name to validate
//							and obtain info for.
//				LPCTSTR		pszComputerName - Remote computer to
//							execute on.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSid::CSid( LPCTSTR pszAccountName, LPCTSTR pszComputerName )
:	m_pSid( NULL ),
	m_snuAccountType( SidTypeUnknown ),
	m_dwLastError( ERROR_SUCCESS )
{
    InitFromAccountName( pszAccountName, pszComputerName );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::CSid
//
//	Class constructor.
//
//	Inputs:
//				LPCTSTR		pszDomainName - Domain to combine with
//							account name.
//				LPCTSTR		pszName - Name to combine with domain.
//				LPCTSTR		pszComputerName - Remote computer to
//							execute on.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
//	This flavor of the constructor combines a domain and account
//	name in "DOMAIN\NAME" format and then initializes our data
//	from there.
//
///////////////////////////////////////////////////////////////////

CSid::CSid( LPCTSTR pszDomainName, LPCTSTR pszName, LPCTSTR pszComputerName )
:	m_pSid( NULL ),
	m_snuAccountType( SidTypeUnknown ),
	m_dwLastError( ERROR_SUCCESS )
{
    CHString	strName;

	if ( NULL == pszDomainName || *pszDomainName == '\0' )
	{
		strName = pszName;
	}
	else
	{
		strName = pszDomainName;
		strName += '\\';
		strName += pszName;
	}

	InitFromAccountName(TOBSTRT(strName), pszComputerName );
}

#ifndef UNICODE
///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::CSid
//
//	Class constructor - this is used for wide char support when
//                      UNICODE is not defined.
//
//	Inputs:
//				LPCWSTR		wstrDomainName - Domain to combine with
//							account name.
//				LPCWSTR		wstrName - Name to combine with domain.
//				LPCWSTR		wstrComputerName - Remote computer to
//							execute on.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
//	This flavor of the constructor combines a domain and account
//	name in "DOMAIN\NAME" format and then initializes our data
//	from there.  Again, this is used for wide char support when
//  UNICODE is not defined.
//
///////////////////////////////////////////////////////////////////

CSid::CSid(LPCWSTR wstrDomainName, LPCWSTR wstrName, LPCWSTR wstrComputerName)
:	m_pSid( NULL ),
	m_snuAccountType( SidTypeUnknown ),
	m_dwLastError( ERROR_SUCCESS )
{
    LONG lTempNameLen = 0L;
    if(wstrDomainName==NULL && wstrName!=NULL)
    {
        lTempNameLen = wcslen(wstrName)+2;
    }
    else if(wstrDomainName!=NULL && wstrName==NULL)
    {
        lTempNameLen = wcslen(wstrDomainName)+2;
    }
    else if(wstrDomainName!=NULL && wstrName!=NULL)
    {
        lTempNameLen = wcslen(wstrName)+wcslen(wstrDomainName)+2;
    }

	WCHAR* wstrTempName = NULL;
    try
    {
        wstrTempName = (WCHAR*) new WCHAR[lTempNameLen];
        if(wstrTempName == NULL)
        {
            m_dwLastError = ::GetLastError();
        }
        else
        {
            ZeroMemory(wstrTempName,lTempNameLen * sizeof(WCHAR));
	        if ( NULL == wstrDomainName || *wstrDomainName == '\0' )
	        {
		        wcscpy(wstrTempName,wstrName);
	        }
	        else
	        {
		        wcscpy(wstrTempName,wstrDomainName);
                wcscat(wstrTempName,L"\\");
                if(wstrName!=NULL)
                {
                    wcscat(wstrTempName,wstrName);
                }
	        }
	        InitFromAccountNameW(wstrTempName, wstrComputerName);
            delete wstrTempName;
        }
    }
    catch(...)
    {
        if(wstrTempName != NULL)
        {
            delete wstrTempName;
            wstrTempName = NULL;
        }
        throw;
    }
}
#endif


///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::CSid
//
//	Class copy constructor.
//
//	Inputs:
//				const CSid	r_Sid - CSid to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSid::CSid( const CSid &r_Sid )
:	m_pSid( NULL ),
	m_snuAccountType( SidTypeUnknown ),
	m_dwLastError( ERROR_SUCCESS )
{
    // Handle WINNT SID pointer first

	// pSid should be valid...
	ASSERT_BREAK( r_Sid.IsValid() );

	// Allocate a new SID and copy data into it.
	DWORD dwSize = ::GetLengthSid( r_Sid.m_pSid );
    m_pSid = malloc( dwSize );
    if (m_pSid != NULL)
    {
	    try
        {
	        BOOL bResult = ::CopySid( dwSize, m_pSid, r_Sid.m_pSid );
	        ASSERT_BREAK( bResult );

	        // Now copy all other members
	        m_snuAccountType	=	r_Sid.m_snuAccountType;
            m_dwLastError		=	r_Sid.m_dwLastError;
	        //m_strSid			=	r_Sid.m_strSid;
	        //m_strAccountName	=	r_Sid.m_strAccountName;
	        //m_strDomainName		=	r_Sid.m_strDomainName;

            m_bstrtSid			=	r_Sid.m_bstrtSid;
	        m_bstrtAccountName	=	r_Sid.m_bstrtAccountName;
	        m_bstrtDomainName	=	r_Sid.m_bstrtDomainName;
        }
        catch(...)
        {
            if(m_pSid != NULL)
            {
                free(m_pSid);
                m_pSid = NULL;
            }
            throw;
        }
    }
    else
    {
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::~CSid
//
//	Class destructor
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSid::~CSid( void )
{
	if ( m_pSid != NULL )
		free ( m_pSid );
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::operator=
//
//	Equals operator.
//
//	Inputs:
//				const CSid	r_Sid - CSid to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSid &	CSid::operator= ( const CSid &r_Sid )
{
	free( m_pSid );
	m_pSid = NULL;
	// Handle WINNT SID pointer first

	// pSid should be valid...
	ASSERT_BREAK( r_Sid.IsValid( ) );

	// if we do not
	if (r_Sid.IsValid( ))
	{
		// Allocate a new SID and copy data into it.
		DWORD dwSize = ::GetLengthSid( r_Sid.m_pSid );
		try
        {
            m_pSid = malloc( dwSize );
		    ASSERT_BREAK( m_pSid != NULL );
            if (m_pSid != NULL)
            {
		        BOOL bResult = ::CopySid( dwSize, m_pSid, r_Sid.m_pSid );
		        ASSERT_BREAK( bResult );
            }
            else
            {
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

        }
        catch(...)
        {
            if(m_pSid != NULL)
            {
                free(m_pSid);
                m_pSid = NULL;
            }
            throw;
        }
	}	// end if

	// Now copy all other members
	m_snuAccountType	=	r_Sid.m_snuAccountType;
    m_dwLastError		=	r_Sid.m_dwLastError;
	m_bstrtSid			=	r_Sid.m_bstrtSid;
	m_bstrtAccountName	=	r_Sid.m_bstrtAccountName;
	m_bstrtDomainName	=	r_Sid.m_bstrtDomainName;

	return ( *this );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::operator==
//
//	Is Equal To comparison operator.
//
//	Inputs:
//				const CSid	r_Sid - CSid to compare.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

BOOL CSid::operator== ( const CSid &r_Sid ) const
{
	BOOL	fReturn = FALSE;

	// Call Equal SID only if both sids are non-NULL
	if (IsValid()
		&&
        r_Sid.IsValid() )
	{
		fReturn = EqualSid( m_pSid, r_Sid.m_pSid );
	}
	else
	{
		fReturn = ( m_pSid == r_Sid.m_pSid );
	}

	return fReturn;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::GetDomainAccountName
//
//	Obtains account name in "DOMAIN\NAME" format.
//
//	Inputs:
//				const CSid	r_Sid - CSid to compare.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
//	If Domain Name is empty, the return value will be only NAME.
//
///////////////////////////////////////////////////////////////////

void CSid::GetDomainAccountName( CHString& strName ) const
{
	if ( m_bstrtDomainName.length() == 0 )
	{
		strName = (wchar_t*)m_bstrtAccountName;
	}
	else
	{
		strName = (wchar_t*)m_bstrtDomainName;
		strName += _T('\\');
		strName += (wchar_t*)m_bstrtAccountName;
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::StringFromSid
//
//	Static helper function to convert a PSID value into a human
//	readable string.
//
//	Inputs:
//				PSID		psid - SID to convert.
//
//	Outputs:
//				CHString&	str - Storage for converted PSID
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

void CSid::StringFromSid( PSID psid, CHString& str )
{
	// Initialize m_strSid - human readable form of our SID
	SID_IDENTIFIER_AUTHORITY *psia = NULL;
    psia = ::GetSidIdentifierAuthority( psid );

	// We assume that only last byte is used (authorities between 0 and 15).
	// Correct this if needed.
	ASSERT_BREAK( psia->Value[0] == psia->Value[1] == psia->Value[2] == psia->Value[3] == psia->Value[4] == 0 );
	DWORD dwTopAuthority = psia->Value[5];

	str.Format( L"S-1-%u", dwTopAuthority );
	CHString strSubAuthority;
	int iSubAuthorityCount = *( GetSidSubAuthorityCount( psid ) );
	for ( int i = 0; i < iSubAuthorityCount; i++ ) {

		DWORD dwSubAuthority = *( GetSidSubAuthority( psid, i ) );
		strSubAuthority.Format( L"%u", dwSubAuthority );
		str += _T("-") + strSubAuthority;
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::StringFromSid
//
//	Static helper function to convert a PSID value into a human
//	readable string.
//
//	Inputs:
//				PSID		psid - SID to convert.
//
//	Outputs:
//				CHString&	str - Storage for converted PSID
//
//	Returns:
//				None.
//
//	Comments: This version supports wide chars when UNICODE isn't
//            defined.
//
///////////////////////////////////////////////////////////////////

void CSid::StringFromSidW( PSID psid, WCHAR** wstr )
{
	if(wstr!=NULL)
    {
        // Initialize m_strSid - human readable form of our SID
	    SID_IDENTIFIER_AUTHORITY *psia = ::GetSidIdentifierAuthority( psid );

	    // We assume that only last byte is used (authorities between 0 and 15).
	    // Correct this if needed.
	    ASSERT_BREAK( psia->Value[0] == psia->Value[1] == psia->Value[2] == psia->Value[3] == psia->Value[4] == 0 );
	    DWORD dwTopAuthority = psia->Value[5];

        _bstr_t bstrtTempSid(L"S-1-");
        WCHAR wstrAuth[32];
        ZeroMemory(wstrAuth,sizeof(wstrAuth));
        _ultow(dwTopAuthority,wstrAuth,10);
        bstrtTempSid+=wstrAuth;
	    int iSubAuthorityCount = *( GetSidSubAuthorityCount( psid ) );
	    for ( int i = 0; i < iSubAuthorityCount; i++ )
        {

		    DWORD dwSubAuthority = *( GetSidSubAuthority( psid, i ) );
		    ZeroMemory(wstrAuth,sizeof(wstrAuth));
            _ultow(dwSubAuthority,wstrAuth,10);
            bstrtTempSid += L"-";
            bstrtTempSid += wstrAuth;
	    }
        // Now allocate the passed in wstr:
        WCHAR* wstrtemp = NULL;
        try
        {
            wstrtemp = (WCHAR*) new WCHAR[bstrtTempSid.length() + 1];
            if(wstrtemp!=NULL)
            {
                ZeroMemory(wstrtemp, bstrtTempSid.length() + 1);
                wcscpy(wstrtemp,(WCHAR*)bstrtTempSid);
            }
            *wstr = wstrtemp;
        }
        catch(...)
        {
            if(wstrtemp!=NULL)
            {
                delete wstrtemp;
                wstrtemp = NULL;
            }
            throw;
        }
    }
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::GetLength
//
//	Returns the length of the internal PSID value.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSid::GetLength( void ) const
{
	DWORD	dwLength = 0;

	if ( IsValid() )
	{
		dwLength = GetLengthSid( m_pSid );
	}

	return dwLength;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::InitFromAccountName
//
//	Initializes the object from an account name.
//
//	Inputs:
//				LPCTSTR		pszAccountName - Account name to validate
//							and obtain info for.
//				LPCTSTR		pszComputerName - Remote computer to
//							execute on.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if OK.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSid::InitFromAccountName( LPCTSTR pszAccountName, LPCTSTR pszComputerName )
{
	CHString strAccountName = pszAccountName;
	CHString strComputerName = pszComputerName;

	// Account name should not be empty...
	ASSERT_BREAK( !strAccountName.IsEmpty() );

	// We need to obtain a SID first
	DWORD dwSidSize = 0;
	DWORD dwDomainNameStrSize = 0;
	LPTSTR pszDomainName = NULL;
	BOOL bResult;
	{
		// This call should fail
		bResult = ::LookupAccountName( TOBSTRT(strComputerName),
												TOBSTRT(strAccountName),
												m_pSid,
												&dwSidSize,
												pszDomainName,
												&dwDomainNameStrSize,
												&m_snuAccountType );
		m_dwLastError = ::GetLastError();

	}

	ASSERT_BREAK( bResult == FALSE );
//	ASSERT_BREAK( ERROR_INSUFFICIENT_BUFFER == m_dwLastError );

	if ( ERROR_INSUFFICIENT_BUFFER == m_dwLastError )
	{
		// Allocate buffers
		m_pSid = NULL;
        pszDomainName = NULL;
        try
        {
            m_pSid = (PSID) malloc( dwSidSize );
		    pszDomainName = (LPTSTR) malloc( dwDomainNameStrSize * sizeof(TCHAR) );
            if ((m_pSid == NULL) || (pszDomainName == NULL))
            {
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

		    {
			    // Make the second call
			    bResult = ::LookupAccountName( TOBSTRT(strComputerName),
											    TOBSTRT(strAccountName),
											    m_pSid,
											    &dwSidSize,
											    pszDomainName,
											    &dwDomainNameStrSize,
											    &m_snuAccountType );
		    }

		    if ( bResult )
		    {

			    CHString chsSidTemp;
                StringFromSid( m_pSid, chsSidTemp );
                m_bstrtSid = chsSidTemp;

			    // Initialize account name and domain name

			    // If the account name begins with "Domain\", remove that piece.

			    CHString	strDomain(pszDomainName);

			    strDomain += _T('\\');

			    if ( 0 == strAccountName.Find( strDomain ) )
			    {
				    m_bstrtAccountName = strAccountName.Right( strAccountName.GetLength() - strDomain.GetLength() );
			    }
			    else
			    {
				    m_bstrtAccountName = strAccountName;
			    }

			    m_bstrtDomainName = pszDomainName;

			    m_dwLastError = ERROR_SUCCESS;	// We are good to go.
		    }
		    else
		    {
			    // Now what went wrong?
			    m_dwLastError = ::GetLastError();
		    }




		    ASSERT_BREAK( ERROR_SUCCESS == m_dwLastError );

		    // Free the sid buffer if we didn't get our data
		    if ( !IsOK() && NULL != m_pSid )
		    {
			    free ( m_pSid );
			    m_pSid = NULL;
		    }

		    if ( NULL != pszDomainName )
		    {
			    free ( pszDomainName );
		    }
        }
        catch(...)
        {
            if(m_pSid != NULL)
            {
                free(m_pSid);
                m_pSid = NULL;
            }
            if(pszDomainName != NULL)
            {
                free(pszDomainName);
                pszDomainName = NULL;
            }
            throw;
        }

	}	// IF ERROR_INSUFFICIENT_BUFFER

	return m_dwLastError;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::InitFromAccountNameW
//
//	Initializes the object from an account name.
//
//	Inputs:
//				LPCTSTR		pszAccountName - Account name to validate
//							and obtain info for.
//				LPCTSTR		pszComputerName - Remote computer to
//							execute on.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if OK.
//
//	Comments: This flavor is used for wide char support when
//  UNICODE is not defined.
//
///////////////////////////////////////////////////////////////////

DWORD CSid::InitFromAccountNameW(LPCWSTR wstrAccountName, LPCWSTR wstrComputerName )
{
	// Account name should not be empty...
	ASSERT_BREAK(wcslen(wstrAccountName)!=0);

	// We need to obtain a SID first
	DWORD dwSidSize = 0;
	DWORD dwDomainNameStrSize = 0;
	WCHAR* wstrDomainName = NULL;
	BOOL bResult;
	{
	    // This call should fail
	    bResult = ::LookupAccountNameW(wstrComputerName,
     							       wstrAccountName,
								       m_pSid,
								       &dwSidSize,
								       wstrDomainName,
								       &dwDomainNameStrSize,
								       &m_snuAccountType );
	}
    m_dwLastError = ::GetLastError();

	ASSERT_BREAK( bResult == FALSE );

	if (m_dwLastError == ERROR_INSUFFICIENT_BUFFER)
	{
		// Allocate buffers
        m_pSid = NULL;
        try
        {
		    m_pSid = (PSID) malloc( dwSidSize );
		    wstrDomainName = (WCHAR*) new WCHAR[dwDomainNameStrSize];
            if (( m_pSid == NULL ) || ( wstrDomainName == NULL ) )
            {
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

		    {
				// Make the second call
			    bResult = ::LookupAccountNameW(wstrComputerName,
										       wstrAccountName,
										       m_pSid,
										       &dwSidSize,
										       wstrDomainName,
										       &dwDomainNameStrSize,
										       &m_snuAccountType );
		    }
		    if(bResult)
		    {
			    WCHAR* pwch = NULL;
                WCHAR* pwchSid = NULL;
                try
                {
                    StringFromSidW( m_pSid, &pwchSid );
                    m_bstrtSid = (LPCWSTR)pwchSid;
                    if(pwchSid != NULL)
                    {
                        delete pwchSid;
                    }
                }
                catch(...)
                {
                    if(pwchSid != NULL)
                    {
                        delete pwchSid;
                    }
                    throw;
                }

			    // Initialize account name and domain name
			    // If the account name begins with "Domain\", remove that piece.

                _bstr_t bstrtDomain(wstrDomainName);
                bstrtDomain += L"\\";

			    if((pwch = wcsstr(wstrAccountName,bstrtDomain)) != NULL)
			    {
                    m_bstrtAccountName = wstrAccountName + bstrtDomain.length();
			    }
			    else
			    {
				    m_bstrtAccountName = wstrAccountName;
			    }
			    m_bstrtDomainName = wstrDomainName;
			    m_dwLastError = ERROR_SUCCESS;	// We are good to go.
		    }
		    else
		    {
			    // Now what went wrong?
			    m_dwLastError = ::GetLastError();
		    }


		    ASSERT_BREAK( ERROR_SUCCESS == m_dwLastError );

		    // Free the sid buffer if we didn't get our data
		    if ( !IsOK() && NULL != m_pSid )
		    {
			    free ( m_pSid );
			    m_pSid = NULL;
		    }

		    if ( NULL != wstrDomainName )
		    {
			    delete wstrDomainName;
		    }
        }
        catch(...)
        {
            if(m_pSid != NULL)
            {
                free(m_pSid);
                m_pSid = NULL;
            }
            if ( NULL != wstrDomainName )
		    {
			    delete wstrDomainName;
                wstrDomainName = NULL;
		    }
            throw;
        }


	}	// IF ERROR_INSUFFICIENT_BUFFER

	return m_dwLastError;
}



///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::InitFromSid
//
//	Initializes the object from a PSid
//
//	Inputs:
//				PSID		pSid - PSid to look up.
//				LPCTSTR		pszComputerName - Remote computer to
//							execute on.
//                bool        fLookup - indicates whether to determine
//                          the domain and account associated with
//                          the sid at this time.
//
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if OK.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
DWORD CSid::InitFromSid( PSID pSid, LPCTSTR pszComputerName, bool fLookup )
{
	// pSid should be valid...
	ASSERT_BREAK( (pSid != NULL) && ::IsValidSid( pSid ) );

	if ( (pSid != NULL) && ::IsValidSid( pSid ) )
	{
		// Allocate a new SID and copy data into it.
		DWORD dwSize = ::GetLengthSid( pSid );
        m_pSid = NULL;
        try
        {
		    m_pSid = malloc( dwSize );
            if (m_pSid == NULL)
            {
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

		    BOOL bResult = ::CopySid( dwSize, m_pSid, pSid );
		    ASSERT_BREAK( bResult );

            //StringFromSid( pSid, m_strSid );
            WCHAR* pwstrSid = NULL;
            try
            {
                StringFromSidW( pSid, &pwstrSid );
                m_bstrtSid = pwstrSid;
                delete pwstrSid;
            }
            catch(...)
            {
                if(pwstrSid != NULL)
                {
                    delete pwstrSid;
                    pwstrSid = NULL;
                }
                throw;
            }
            if(fLookup)
            {
		        // Initialize account name and domain name
		        LPTSTR pszAccountName = NULL;
		        LPTSTR pszDomainName = NULL;
		        DWORD dwAccountNameSize = 0;
		        DWORD dwDomainNameSize = 0;
		        try
                {
		            {
			            // This call should fail
			            bResult = ::LookupAccountSid( pszComputerName,
											            pSid,
											            pszAccountName,
											            &dwAccountNameSize,
											            pszDomainName,
											            &dwDomainNameSize,
											            &m_snuAccountType );
			            m_dwLastError = ::GetLastError();
		            }

		            // Why were we breaking on these when we are expecting them to
                    // always happend?
                    //ASSERT_BREAK( bResult == FALSE );
		            //ASSERT_BREAK( ERROR_INSUFFICIENT_BUFFER == m_dwLastError );

		            if ( ERROR_INSUFFICIENT_BUFFER == m_dwLastError )
		            {

			            // Allocate buffers
			            if ( dwAccountNameSize != 0 )
                        {
				            pszAccountName = (LPTSTR) malloc( dwAccountNameSize * sizeof(TCHAR));
                            if (pszAccountName == NULL)
                            {
            				    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                            }
                        }

			            if ( dwDomainNameSize != 0 )
                        {
				            pszDomainName = (LPTSTR) malloc( dwDomainNameSize * sizeof(TCHAR));
                            if (pszDomainName == NULL)
                            {
            				    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                            }
                        }

			            {
				            // Make second call
				            bResult = ::LookupAccountSid( pszComputerName,
												            pSid,
												            pszAccountName,
												            &dwAccountNameSize,
												            pszDomainName,
												            &dwDomainNameSize,
												            &m_snuAccountType );
			            }


			            if ( bResult == TRUE )
			            {
				            m_bstrtAccountName = pszAccountName;
				            m_bstrtDomainName = pszDomainName;

				            // We're OKAY
				            m_dwLastError = ERROR_SUCCESS;
			            }
			            else
			            {

				            // There are some accounts that do not have names, such as Logon Ids,
				            // for example S-1-5-X-Y. So this is still legal
				            m_bstrtAccountName = _T("Unknown Account");
				            m_bstrtDomainName = _T("Unknown Domain");

				            // Log the error
				            m_dwLastError = ::GetLastError();

			            }

			            ASSERT_BREAK( ERROR_SUCCESS == m_dwLastError );

			            if ( NULL != pszAccountName )
			            {
				            free ( pszAccountName );
                            pszAccountName = NULL;
			            }

			            if ( NULL != pszDomainName )
			            {
				            free ( pszDomainName );
                            pszDomainName = NULL;
			            }

		            }	// If ERROR_INSUFFICIENT_BUFFER
                } // try
                catch(...)
                {
                    if ( NULL != pszAccountName )
			        {
				        free ( pszAccountName );
                        pszAccountName = NULL;
			        }

			        if ( NULL != pszDomainName )
			        {
				        free ( pszDomainName );
                        pszDomainName = NULL;
			        }
                    throw;
                }
            }  // fLookup
        }  //try
        catch(...)
        {
            if(m_pSid != NULL)
            {
                free(m_pSid);
                m_pSid = NULL;
            }
            throw;
        }

	}	// IF IsValidSid
	else
	{
		m_dwLastError = ERROR_INVALID_PARAMETER;
	}

	return m_dwLastError;

}

#ifdef NTONLY
void CSid::DumpSid(LPCWSTR wstrFilename)
{
    CHString chstrTemp1((LPCWSTR)m_bstrtSid);
    CHString chstrTemp2;

    Output(L"SID contents follow...", wstrFilename);
    // Output the sid string:
    chstrTemp2.Format(L"SID string: %s", (LPCWSTR)chstrTemp1);
    Output(chstrTemp2, wstrFilename);

    // Output the name:
    if(m_bstrtAccountName.length() > 0)
    {
        chstrTemp2.Format(L"SID account name: %s", (LPCWSTR)m_bstrtAccountName);
        Output(chstrTemp2, wstrFilename);
    }
    else
    {
        chstrTemp2.Format(L"SID account name was not available");
        Output(chstrTemp2, wstrFilename);
    }

    // Output the domain:
    if(m_bstrtDomainName.length() > 0)
    {
        chstrTemp2.Format(L"SID domain name: %s", (LPCWSTR)m_bstrtDomainName);
        Output(chstrTemp2, wstrFilename);
    }
    else
    {
        chstrTemp2.Format(L"SID domain name was not available");
        Output(chstrTemp2, wstrFilename);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\sid.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*
 *	CSid.h - header file for CSid class
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CSID_H__
#define __CSID_H__

#include <comdef.h>

////////////////////////////////////////////////////////////////
//
//	Class:	CSid
//
//	This class is intended to provide a wrapper for basic
//	Windows NT SIDs (Security Identifiers).  There is a
//	possibility of a slight performance hit when instantiating
//	one of these as it uses LookupAccountName and LookupAccountSid
//	to initialize account information, and those calls can go
//	out over the network to get their data.
//
////////////////////////////////////////////////////////////////

class CSid
{
	// Constructors and destructor
	public:
		CSid();
		CSid( PSID pSid, LPCTSTR pszComputerName = NULL );
        CSid( PSID pSid, LPCTSTR pszComputerName, bool fLookup );
		CSid( LPCTSTR pszDomainName, LPCTSTR pszName, LPCTSTR pszComputerName );
#ifndef UNICODE
        CSid( LPCWSTR wstrDomainName, LPCWSTR wstrName, LPCWSTR wstrComputerName );
#endif
		CSid( LPCTSTR pszAccountName, LPCTSTR pszComputerName = NULL );
		CSid( const CSid &r_Sid );
		~CSid( void );

	// Public functions
	public:
		CSid &	operator= ( const CSid & );
		BOOL	operator== ( const CSid & ) const;

		void	  GetDomainAccountName( CHString& strName ) const;
		CHString  GetAccountName( void ) const;
        WCHAR*    GetAccountNameW( void ) const;
		CHString  GetDomainName( void ) const;
        WCHAR*    GetDomainNameW( void ) const;
		CHString  GetSidString( void ) const;
        WCHAR*    GetSidStringW( void ) const;
		SID_NAME_USE GetAccountType( void ) const;
		PSID	  GetPSid( void ) const;
		DWORD	  GetLength( void ) const;

		BOOL	  IsOK( void ) const;
		BOOL	  IsValid( void ) const;
		BOOL	  IsAccountTypeValid( void ) const;
		DWORD	  GetError( void ) const;

		static void StringFromSid( PSID psid, CHString& str );
        static void StringFromSidW( PSID psid, WCHAR** pwstr );

#ifdef NTONLY
        void DumpSid(LPCWSTR wstrFilename = NULL);
#endif

	// Private data members
	private:
		PSID			m_pSid;				// Pointer to standard Win32 SID
		SID_NAME_USE	m_snuAccountType;	// Type of SID
		//CHString		m_strSid;			// Wind32 SID in human readable form
        //WCHAR*          m_wstrSid;          // As above, for wchar support when UNICODE not defined
        //WCHAR*          m_wstrAccountName;  // ibid.
        //WCHAR*          m_wstrDomainName;   // ibid.
		//CHString		m_strAccountName;	// Name of the account
		//CHString		m_strDomainName;	// Domain name the account belongs to
        _bstr_t         m_bstrtSid;
        _bstr_t         m_bstrtAccountName;
        _bstr_t         m_bstrtDomainName;
		DWORD			m_dwLastError;		// Last Error in the Sid;

		DWORD InitFromAccountName( LPCTSTR pszAccountName, LPCTSTR pszComputerName );
        DWORD InitFromAccountNameW( LPCWSTR wstrAccountName, LPCWSTR wstrComputerName );
		DWORD InitFromSid( PSID pSid, LPCTSTR pszComputerName, bool fLookup = true );
};

inline BOOL CSid::IsOK( void ) const
{
	return ( ERROR_SUCCESS == m_dwLastError );
}

inline DWORD CSid::GetError( void ) const
{
	return m_dwLastError;
}

// Lets us know if the Sid is Valid

inline BOOL CSid::IsValid( void ) const
{
	// If m_pSid is NULL, this will return FALSE.
   // dw: However, doing it this way causes a first chance exception, so...
   if (m_pSid != NULL)
	   return ::IsValidSid( m_pSid );
   return FALSE;
}

inline BOOL CSid::IsAccountTypeValid( void ) const
{
	// SID may be valid, and Lookup succeeded, but it may be of a type that isn't
	// necessarily a user/group/alias.

	return ( m_snuAccountType >= SidTypeUser && m_snuAccountType < SidTypeDeletedAccount );
}

inline SID_NAME_USE CSid::GetAccountType( void ) const
{
	return m_snuAccountType;
}

inline CHString CSid::GetAccountName( void ) const
{
	return ( CHString((LPCWSTR)m_bstrtAccountName) );
}

inline WCHAR* CSid::GetAccountNameW( void ) const
{
	return ( m_bstrtAccountName );
}

inline CHString CSid::GetDomainName( void ) const
{
	return ( CHString((LPCWSTR)m_bstrtDomainName) );
}

inline WCHAR* CSid::GetDomainNameW( void ) const
{
	return ( m_bstrtDomainName );
}

inline CHString CSid::GetSidString( void ) const
{
	return ( CHString((LPCWSTR)m_bstrtSid) );
}

inline WCHAR* CSid::GetSidStringW( void ) const
{
	return ( m_bstrtSid );
}

inline PSID CSid::GetPSid( void ) const
{
	return ( m_pSid );
}


#endif // __CSID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\session.h ===
//=============================================================================
// session.h -- definition of session collection class.
//
//  Copyright (c) 1998-2002 Microsoft Corporation, All Rights Reserved
//=============================================================================

#include "ctoken.h"

typedef NTSTATUS (NTAPI *PFN_NT_QUERY_SYSTEM_INFORMATION)
(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
);

class CProcess;
class CSession;
class CUser;
class CUserComp;
class CUserSessionCollection;


class CUser
{
public:
	CUser() : m_sidUser(NULL) {}

    CUser(
        PSID psidUser);

    CUser(
        const CUser& user);

 	virtual ~CUser();

    bool IsValid();

    PSID GetPSID() const
    {
        return m_sidUser;
    }

    void GetSidString(
        CHString& str) const;

	

private:
    void Copy(
        CUser& out) const;

    PSID m_sidUser;
    bool m_fValid;
};


// Comparison class required for multimap
// costructor involving non-standard key
// type (i.e., a CUser) in the map.
class CUserComp
{
public:
    CUserComp() {}
    virtual ~CUserComp() {}

    bool operator()(
        const CUser& userFirst,
        const CUser& userSecond) const
    {
        bool fRet;
        CHString chstr1, chstr2;

        userFirst.GetSidString(chstr1);
        userSecond.GetSidString(chstr2);
         
        long lcmp = chstr1.CompareNoCase(chstr2);  
        (lcmp < 0) ? fRet = true : fRet = false;

        return fRet;
    }
};



class CProcess
{
public:
    // Constructors and destructors
    CProcess();

    CProcess(
        DWORD dwPID,
        LPCWSTR wstrImageName);

    CProcess(
        const CProcess& process);

    virtual ~CProcess();

    // Accessor functions
    DWORD GetPID() const;
    CHString GetImageName() const;
    
private:
    DWORD m_dwPID;
    CHString m_chstrImageName;

    void Copy(
        CProcess& process) const;
};


// vector and iterator for getting a session's processes... 
typedef std::vector<CProcess> PROCESS_VECTOR;
typedef PROCESS_VECTOR::iterator PROCESS_ITERATOR;


class CSession
{
public:
	// Constructors and destructors
    CSession() {}

	CSession(
        const LUID& luidSessionID);

    CSession(
        const CSession& ses);

	virtual ~CSession() {}
	

    // Accessor functions
	LUID GetLUID() const;
    __int64 GetLUIDint64() const;
    CHString GetAuthenticationPkg() const;
    ULONG GetLogonType() const;
    __int64 GetLogonTime() const;


    // Enumerate list of processes
    CProcess* GetFirstProcess(
        PROCESS_ITERATOR& pos);

	CProcess* GetNextProcess(
        PROCESS_ITERATOR& pos);

    // Allow easy impersonation of
    // the session's first process
    HANDLE Impersonate();
    DWORD GetImpProcPID();

    friend CUserSessionCollection;

    // Checks a string representation
    // of a session id for validity
    bool IsSessionIDValid(
        LPCWSTR wstrSessionID);

private:
    void Copy(
        CSession& sesCopy) const;

    CHString m_chstrAuthPkg;
    ULONG m_ulLogonType;
    __int64 i64LogonTime;
    LUID m_luid;
    PROCESS_VECTOR m_vecProcesses;
};



// map and iterator for relating users and sessions...
typedef std::multimap<CUser, CSession, CUserComp> USER_SESSION_MAP;
typedef USER_SESSION_MAP::iterator USER_SESSION_ITERATOR;

// Custom iterator used in enumerating processes from 
// CUserSessionCollection.
struct USER_SESSION_PROCESS_ITERATOR
{
    friend CUserSessionCollection;
private:
    USER_SESSION_ITERATOR usIter;
    PROCESS_ITERATOR procIter;
};


class CUserSessionCollection
{
public:
	// Constructors and destructors
    CUserSessionCollection();

    CUserSessionCollection(
        const CUserSessionCollection& sescol);

	virtual ~CUserSessionCollection() {}


    // Method to refresh map
    DWORD Refresh();

    // Methods to check whether a particular
    // session is in the map
    bool IsSessionMapped(
        LUID& luidSes);

    bool CUserSessionCollection::IsSessionMapped(
        __int64 i64luidSes);

    // Support enumeration of users
    CUser* GetFirstUser(
        USER_SESSION_ITERATOR& pos);

	CUser* GetNextUser(
        USER_SESSION_ITERATOR& pos);


    // Support enumeration of sessions
    // belonging to a particular user.
    CSession* GetFirstSessionOfUser(
        CUser& usr,
        USER_SESSION_ITERATOR& pos);

	CSession* GetNextSessionOfUser(
        USER_SESSION_ITERATOR& pos);


    // Support enumeration of all sessions
    CSession* GetFirstSession(
        USER_SESSION_ITERATOR& pos);

	CSession* GetNextSession(
        USER_SESSION_ITERATOR& pos);

    // Support finding a particular session
    CSession* FindSession(
        LUID& luidSes);

    CSession* FindSession(
        __int64 i64luidSes);


    // Support enumeration of processes
    // belonging to a particular user
    CProcess* GetFirstProcessOfUser(
        CUser& usr,
        USER_SESSION_PROCESS_ITERATOR& pos);

	CProcess* GetNextProcessOfUser(
        USER_SESSION_PROCESS_ITERATOR& pos);


    // Support enumeration of all processes
    CProcess* GetFirstProcess(
        USER_SESSION_PROCESS_ITERATOR& pos);

	CProcess* GetNextProcess(
        USER_SESSION_PROCESS_ITERATOR& pos);



private:
    DWORD CollectSessions();
    DWORD CollectNoProcessesSessions();

    void Copy(
        CUserSessionCollection& out) const;

    DWORD GetProcessList(
        std::vector<CProcess>& vecProcesses) const;

    DWORD EnablePrivilegeOnCurrentThread(
        LPCTSTR szPriv) const;

    bool FindSessionInternal(
        LUID& luidSes,
        USER_SESSION_ITERATOR& usiOut);

    USER_SESSION_MAP m_usr2ses;
};

// This version is a smart handle
// for use with thread tokens we
// are impersonating.  On destruction,
// it reverts to the handle it
// encapsulates.
class SmartRevertTokenHANDLE
{
private:
	HANDLE m_h;

public:
	SmartRevertTokenHANDLE() 
      : m_h(INVALID_HANDLE_VALUE) {}

	SmartRevertTokenHANDLE(
        HANDLE h) 
      : m_h(h) {}

    ~SmartRevertTokenHANDLE()
    {
		if ( FALSE == Revert () )
		{
			throw CFramework_Exception(L"SetThreadToken failed", GetLastError());
		}
    }

	HANDLE operator =(HANDLE h) 
    {
		if ( FALSE == Revert () )
		{
			throw CFramework_Exception(L"SetThreadToken failed", GetLastError());
		}

        m_h = h; 
        return h;
    }

	operator HANDLE() const 
    {
        return m_h;
    }

	HANDLE* operator &() 
    {
		if ( FALSE == Revert () )
		{
			throw CFramework_Exception(L"SetThreadToken failed", GetLastError());
		}

		m_h = INVALID_HANDLE_VALUE; 
        return &m_h;
    }

	private :

	BOOL Revert ()
	{
		BOOL bRet = FALSE ;

        if ( m_h && INVALID_HANDLE_VALUE != m_h )
        {
			CThreadToken cpt ( m_h );
			if ( cpt.IsValidToken () )
			{
	            HANDLE hCurThread = ::GetCurrentThread();

				TOKEN_TYPE type;
				if ( cpt.GetTokenType ( type ) )
				{
					if ( TokenPrimary == type )
					{
						CToken ct;
						if ( ct.Duplicate ( cpt, FALSE ) )
						{
							bRet = ::SetThreadToken ( &hCurThread, ct.GetTokenHandle () );
						}
					}
					else
					{
						bRet = ::SetThreadToken ( &hCurThread, cpt.GetTokenHandle () ) ;
					}

					if (!bRet)
					{
						LogMessage2( L"Failed to SetThreadToken in SmartRevertTokenHANDLE with error %d", ::GetLastError() );
					}
				}
			}

            CloseHandle(m_h);
        }
		else
		{
			//
			// smart revert was created from invalid handle
			// there is nothing we should do here !
			//

			bRet = TRUE ;
		}

		return bRet ;
	}
};



// Helper for automatic cleanup of
// pointers returned from the various
// enumeration functions.
template<class T>
class SmartDelete
{
private:
	T* m_ptr;

public:
	SmartDelete() 
      : m_ptr(NULL) {}

	SmartDelete(
        T* ptr) 
      : m_ptr(hptr) {}

    virtual ~SmartDelete()
    {
        if(m_ptr != NULL) 
        {
            delete m_ptr;
            m_ptr = NULL;
        }
    }

	T* operator =(T* ptrRight) 
    {
        if(m_ptr != NULL) 
        {
            delete m_ptr;
            m_ptr = NULL;
        } 
        m_ptr = ptrRight; 
        return ptrRight;
    }

	operator T*() const 
    {
        return m_ptr;
    }

	T* operator &() 
    {
        if(m_ptr != NULL) 
        {
            delete m_ptr;
            m_ptr = NULL;
        } 
        m_ptr = NULL; 
        return m_ptr;
    }

    T* operator->() const
    {
        return m_ptr;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\strings.h ===
//=================================================================
//
// Strings.h
//
//  Copyright (c) 1995-2002 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _STRINGS_H_INC_
#define _STRINGS_H_INC_

// general messages and strings
//=============================
/*
#define ERR_PLATFORM_NOT_SUPPORTED  "Platform not supported"
#define ERR_INVALID_PROCESSOR_ARCHITECTURE  "Invalid processor architecture"
#define ERR_GET_COMPUTER_NAME "Error 0x%lX in getting computer name"
#define ERR_GET_USER_NAME "Error <0x%lX> in getting user name"
#define ERR_GET_MOUSE_INFO "Error <0x%lX> in retrieving Mouse information"
*/

#define ERR_OPEN_REGISTRY L"Error opening registry with subkey <%s>"

/*
#define ERR_INSUFFICIENT_BUFFER "Insufficient buffer"
#define ERR_SYSTEM_PARAMETERS_INFO "Error <0x%lX> in getting system parameters info"
#define ERR_INVALID_SSF_TEXT_EFFECT "Invalid Soundsentry Feature - Text effect"
#define ERR_INVALID_GRAPHICS_EFFECT "Invalid Soundsentry Feature - graphics effect"
#define ERR_INVALID_WINDOWS_EFFECT "Invalid Soundsentry Feature - Windows effect"
#define ERR_INVALID_SHARE_DISPOSITION "Invalid share disposition value"
#define ERR_INVALID_MEMORY_TYPE "Invalid memory type"
#define ERR_INVALID_INTERRUPT_TYPE "Invalid interrupt type"

#define ERR_UNKNOWN_AC_POWER_STATUS "Unknown AC power status"
#define ERR_UNKNOWN_BATTERY_STATUS "Unknown battery charge status"
#define ERR_INVALID_BATTERY_STATUS "Invalid battery charge status"
#define ERR_UNKNOWN_BATTERY_LIFE_PERCENT "Unknown percentage of full battery charge remaining"
#define ERR_INVALID_BATTERY_LIFE_PERCENT "Invalid percentage of full battery charge remaining"
#define ERR_INVALID_BATTERY_LIFE_TIME "Battery life remaining unknown/invalid"
#define ERR_INVALID_BATTERY_FULL_LIFE_TIME "Battery life when at full charge unknown/invalid"

#define ERR_SERVICE_CONTROLLER_OPEN "Error in opening service controller"
#define ERR_UPS_SERVICE_OPEN    "Error in opening UPS service"
#define ERR_QUERY_UPS_SERVICE_STATUS "Error in querying UPS service status"
#define ERR_UPS_SERVICE_NOT_RUNNING "UPS service not running"
#define ERR_INVALID_RECHARGE_RATE "Invalid Battery recharge rate"
#define ERR_INVALID_MESSAGE_INTERVAL "Invalid power failure message delay value"
#define ERR_INVALID_FIRST_MESSAGE_DELAY "Invalid first power failure message delay value"

#define ERR_WNET_GET_CONNECTION     "Error <0x%lX> in getting network connection information"
#define ERR_NETWORK_SPECIFIC        "Error <0x%lX> - A network specific error"

#define ERR_WNETOPENENUM    "Error <0x%lx> with WNetOpenEnum"
#define ERR_WNETENUMRESOURCE    "Error <0x%lx> with WNetEnumResource"
#define ERR_WNETCLOSEENUM    "Error <0x%lx> with WNetCloseEnum"

#define ERR_REGISTRY_OPEN   "Error in opening <%s> under <%s> in registry"
#define ERR_REGISTRY_ENUM_VALUE   "Error <0x%X> in enumerating values under <%s> in registry"
*/

#define ERR_REGISTRY_ENUM_VALUE_FOR_KEY L"Error enumerating values under <%s> in registry for key <%s>"

/*
#define ERR_REGISTRY_ENUM_KEY     "Error <0x%X> in enumerating keys under <%s> in registry"

#define ERR_INVALID_SERVICE_STATE "Invalid Service state"
#define ERR_GET_SERVICE_CONFIG_STATUS "Error in getting config status of service"
#define ERR_INVALID_SERVICE_TYPE "Invalid Service type"
#define ERR_INVALID_START_TYPE "Invalid Start type"
#define ERR_INVALID_ERROR_CONTROL "Invalid Error Control"
#define ERR_NUMBER_OF_SERVICES_MISMATCH "System and computed number of services mismatch"

#define ERR_GET_SYSTEM_DIRECTORY "Error <0x%lX> in calling GetSystemDirectory."
#define ERR_GET_WINDOWS_DIRECTORY "Error <0x%lX> in calling GetWindowsDirectory."
#define ERR_GET_VERSIONEX "Error in calling GetVersionEx."
#define  ERR_GET_SYSTEM_INFO    "Error in calling GetSystemInfo."

#define  ERR_UNKNOWN_POWER_PC_TYPE    "Unknown/Invalid Power PC processor type"
#define  ERR_UNKNOWN_MIPS_TYPE    "Unknown/Invalid MIPS processor type"
#define  ERR_UNKNOWN_ALPHA_TYPE    "Unknown/Invalid DEC Alpha processor type"
#define  ERR_UNKNOWN_INTEL_TYPE    "Unknown/Invalid Intel processor type"

// Boolean values
//===============

#define TRUE_STR    "True"
#define FALSE_STR   "False"

// Soundsentry feature - text mode visual signal
//==============================================

#define SSF_TEXT_EFFECT_BORDER "Flash the screen border"
#define SSF_TEXT_EFFECT_CHARS  "Flash characters in the corner of screen"
#define SSF_TEXT_EFFECT_DISPLAY "Flash the entire display"
#define SSF_TEXT_EFFECT_NONE "No visual signal"

// Soundsentry feature - graphics mode visual signal
//==================================================

#define SSF_GRAPHICS_EFFECT_DISPLAY SSF_TEXT_EFFECT_DISPLAY
#define SSF_GRAPHICS_EFFECT_NONE SSF_TEXT_EFFECT_NONE 

// Soundsentry feature - Windows effect
//=====================================

#define SSF_WINDOWS_EFFECT_DISPLAY SSF_TEXT_EFFECT_DISPLAY
#define SSF_WINDOWS_EFFECT_NONE    SSF_TEXT_EFFECT_NONE
#define SSF_WINDOWS_EFFECT_WINDOW  "Flash the active window"
#define SSF_WINDOWS_EFFECT_TITLE  "Flash the title bar of the active window"
#define SSF_WINDOWS_EFFECT_CUSTOM  "Custom flashing"

*/

// SerialKeys feature - port state values
//=======================================

#define IGNORE_IP_PORT_STATE L"Port input ignored"
#define WATCH_IP_PORT_STATE  L"Port input watched for serial keys activation sequences"
#define COMPLETE_IP_PORT_STATE L"Complete port input treated as serial keys commands"

// system type strings
//====================

#define SYS_TYPE_X86_PC                       L"X86-based PC"
#define SYS_TYPE_MAC                          L"Macintosh"
#define SYS_TYPE_ALPHA                        L"ALPHA-based PC"
#define SYS_TYPE_MIPS                         L"MIPS-based PC"
#define SYS_TYPE_PPC                          L"Power PC"

// system role strings
//====================

#define SYS_ROLE_WORKSTATION                  L"Workstation"
#define SYS_ROLE_SERVER                       L"Server"

// AC power status strings
//========================

#define AC_POWER_STATUS_ONLINE                 L"AC power On line"
#define AC_POWER_STATUS_OFFLINE                 L"AC power Off line"

// Battery charge status strings
//==============================

#define BATTERY_STATUS_HIGH                 L"High"
#define BATTERY_STATUS_LOW                  L"Low"
#define BATTERY_STATUS_CRITICAL             L"Critical"
#define BATTERY_STATUS_CHARGING             L"Charging"
#define BATTERY_STATUS_NO_BATTERY           L"No system battery"

// the following are system defined values for UPS options
// they should not be changed
//========================================================

#define UPS_INSTALLED                   0x1
#define UPS_POWER_FAIL_SIGNAL           0x2
#define UPS_LOW_BATTERY_SIGNAL          0x4
#define UPS_CAN_TURN_OFF                0x8
#define UPS_POSITIVE_POWER_FAIL_SIGNAL  0x10
#define UPS_POSITIVE_LOW_BATTERY_SIGNAL 0x20
#define UPS_POSITIVE_SHUT_OFF_SIGNAL    0x40
#define UPS_COMMAND_FILE                0x80

#define POSITIVE_UPS_INTERFACE_VOLTAGE L"Positive interface voltage"
#define NEGATIVE_UPS_INTERFACE_VOLTAGE L"Negative interface voltage"
#define NO_LOW_BATTERY_SIGNAL          L"No low battery signal"
#define NO_POWER_FAIL_SIGNAL           L"No power fail signal"
#define UPS_CANNOT_TURN_OFF            L"cannot do remote turn off"

// The following are  related * Net connection propertyset
//========================================================

#define NET_RESOURCE_TYPE_DISK  L"Disk"
#define NET_RESOURCE_TYPE_PRINT L"Print"

#define NET_DISPLAY_TYPE_DOMAIN L"Domain"
#define NET_DISPLAY_TYPE_GENERIC L"Generic"
#define NET_DISPLAY_TYPE_SERVER L"Server"
#define NET_DISPLAY_TYPE_SHARE L"Share"

// service propertyset related strings
//=====================================

// Service state
//==============

#define RUNNING_STR                         L"Running"
#define STOPPED_STR                         L"Stopped"
#define STARTED_STR                                                                                                     L"Started"

// Service Type
//=============

#define KERNEL_DRIVER_STR                   L"Kernel Driver"
#define FILE_SYSTEM_DRIVER_STR              L"File System Driver"
#define ADAPTER_STR                         L"Adapter"
#define WIN32_OWN_PROCESS_STR               L"Own Process"
#define WIN32_SHARE_PROCESS_STR             L"Shared Process"
#define RECOGNIZER_DRIVER_STR               L"Recognizer driver"
#define INTERACTIVE_PROCESS_STR             L"Interactive process"

// Start Type
//===========

#define BOOT_START_STR                      L"Boot"
#define SYSTEM_START_STR                    L"System"
#define AUTO_START_STR                      L"Automatic"
#define DEMAND_START_STR                    L"Demand"
#define DISABLED_STR                        L"Disabled"

// Error control type
//===================

#define ERROR_IGNORE_STR                    L"Ignore"
#define ERROR_NORMAL_STR                    L"Normal"
#define ERROR_SEVERE_STR                    L"Severe"
#define ERROR_CRITICAL_STR                  L"Critical"

// Processor property set related defines
//=======================================

#define PROCESSOR_FAMILY_INTEL  L"Intel"
#define PROCESSOR_FAMILY_MIPS  L"Mips"
#define PROCESSOR_FAMILY_ALPHA  L"Alpha"
#define PROCESSOR_FAMILY_POWER_PC  L"Power PC"

#define PROCESSOR_TYPE_80386        L"80386"
#define PROCESSOR_TYPE_80486        L"80486"
#define PROCESSOR_TYPE_80486SX      L"80486SX"
#define PROCESSOR_TYPE_80486DX      L"80486DX"
#define PROCESSOR_TYPE_PENTIUM      L"Pentium"
#define PROCESSOR_TYPE_R2000        L"MIPS R2000"
#define PROCESSOR_TYPE_R3000        L"MIPS R3000"
#define PROCESSOR_TYPE_R6000        L"MIPS R6000"
#define PROCESSOR_TYPE_R4000        L"MIPS R4000"
#define PROCESSOR_TYPE_R6000A       L"MIPS R6000A"
#define PROCESSOR_TYPE_21064        L"DEC Alpha 21064"
#define PROCESSOR_TYPE_21066        L"DEC Alpha 21066"
#define PROCESSOR_TYPE_21164        L"DEC Alpha 21164"
#define PROCESSOR_TYPE_601          L"Power PC 601"
#define PROCESSOR_TYPE_603          L"Power PC 603"
#define PROCESSOR_TYPE_603_PLUS     L"Power PC 603+"
#define PROCESSOR_TYPE_604          L"Power PC 604"
#define PROCESSOR_TYPE_604_PLUS     L"Power PC 604+"

#define PROCESSOR_ROLE_CPU          L"CPU"

#define PROCESSOR_MODEL_STRING         L"Model"
#define PROCESSOR_STEPPING_STRING      L"Stepping"
#define PROCESSOR_REVISION_STRING      L"Revision"
#define PROCESSOR_PASS_STRING          L"Pass"

#define OS_NT_ADV_SRVR                                  L"Microsoft Windows NT Advanced Server"
#define OS_NT_SRV                                               L"Microsoft Windows NT Server"
#define OS_NT_WKS                                               L"Microsoft Windows NT Workstation"
#define OS_NT                                                   L"Microsoft Windows NT"
#define OS_95                                                   L"Microsoft Windows 95"

#define MICROSOFT_COMPANY                               L"Microsoft"

#define KNOWN_BUS_TYPE_SIZE  256
#define KNOWN_BUS_TYPES     0x10
#define UNKNOWN_BUS_TYPE    0xFF


//
///////////////////////////////////////////
//
//      LOGGING STRINGS
//
///////////////////////////////////////////
extern LPCWSTR IDS_LogImpersonationFailed;
extern LPCWSTR IDS_LogImpersonationRevertFailed;
extern LPCWSTR IDS_LogOutOfMemory;

//
///////////////////////////////////////////
//
//      SHARE DISPOSITIONS
//
///////////////////////////////////////////
extern LPCWSTR IDS_SDDeviceExclusive;
extern LPCWSTR IDS_SDDriverExclusive;
extern LPCWSTR IDS_SDShared;
extern LPCWSTR IDS_SDUndetermined;

//
///////////////////////////////////////////
//
//      MEMORY TYPES
//
///////////////////////////////////////////
extern LPCWSTR IDS_MTReadWrite;
extern LPCWSTR IDS_MTReadOnly;
extern LPCWSTR IDS_MTWriteOnly;
extern LPCWSTR IDS_MTPrefetchable;

//
///////////////////////////////////////////
//
//      MEDIA TYPES
//
///////////////////////////////////////////
extern LPCWSTR IDS_MDT_RandomAccess;
extern LPCWSTR IDS_MDT_SupportsWriting;
extern LPCWSTR IDS_MDT_Removable;
extern LPCWSTR IDS_MDT_CD;

// Processor Architectures
extern LPCWSTR IDS_ProcessorX86;
extern LPCWSTR IDS_ProcessorX86Nec98;
extern LPCWSTR IDS_ProcessorMIPS;
extern LPCWSTR IDS_ProcessorALPHA;
extern LPCWSTR IDS_ProcessorPowerPC;
extern LPCWSTR IDS_ProcessorIA64;
extern LPCWSTR IDS_ProcessorAMD64;
extern LPCWSTR IDS_ProcessorUnknown;

//
///////////////////////////////////////////
//
//      COMMON STRINGS
//
///////////////////////////////////////////
extern LPCWSTR IDS_Unknown;
extern LPCWSTR IDS_OK;
extern LPCWSTR IDS_WINNT_SHELLNAME_EXPLORER;
extern LPCWSTR IDS_Degraded; 
extern LPCWSTR IDS_Error;    
//
///////////////////////////////////////////
//
//      Win32_BIOS
//
///////////////////////////////////////////
extern LPCWSTR IDS_RegBiosSystem;
extern LPCWSTR IDS_RegSystemBiosDate;
extern LPCWSTR IDS_RegSystemBiosVersion;
extern LPCWSTR IDS_RegEnumRootBios;
extern LPCWSTR IDS_RegBIOSName;
extern LPCWSTR IDS_RegBIOSDate;
extern LPCWSTR IDS_RegBIOSVersion;
extern LPCWSTR IDS_BIOS_NAME_VALUE;

//
///////////////////////////////////////////
//
//      Win32_BootConfiguration
//
///////////////////////////////////////////
extern LPCWSTR IDS_BOOT_CONFIG_NAME;
extern LPCWSTR IDS_RegSetupLog;
extern LPCWSTR IDS_Paths;
extern LPCWSTR IDS_TargetDirectory;
extern LPCWSTR IDS_EnvBootDirectory;
extern LPCWSTR IDS_Temp;
extern LPCWSTR IDS_Environment;

//
///////////////////////////////////////////
//
//      Win32_Bus
//
///////////////////////////////////////////
extern LPCWSTR IDS_Win32_Bus;
extern LPCWSTR IDS_Bus;
extern LPCWSTR IDS_BusType;
extern LPCWSTR IDS_BusNum;
extern LPCWSTR IDS_BUS_DEVICEID_TAG;
extern LPCWSTR IDS_WIN98_USB_REGISTRY_KEY;
extern LPCWSTR IDS_NT5_USB_REGISTRY_KEY;
extern LPCWSTR IDS_USB_Bus_Tag;

//
///////////////////////////////////////////
//
//      Win32_CDRom
//
///////////////////////////////////////////
extern LPCWSTR IDS_RegSCSICDDevice;
extern LPCWSTR IDS_RegIdentifier;
extern LPCWSTR IDS_RegEnumSCSI;
extern LPCWSTR IDS_RegCurrentDriveLetterKey;
extern LPCWSTR IDS_RegProductIDKey;
extern LPCWSTR IDS_RegClassKey;
extern LPCWSTR IDS_RegHardwareIDKey;
extern LPCWSTR IDS_RegRevisionLevelKey;
extern LPCWSTR IDS_RegSCSITargetIDKey;
extern LPCTSTR IDT_REG_KEY_CD_CACHE;
extern LPCTSTR IDT_REG_VAL_CD_CACHE;
extern LPCWSTR IDS_DriveIntegrity;
extern LPCWSTR IDS_TransferRate;


//
///////////////////////////////////////////
//
//      Win32_ComputerSystem
//
///////////////////////////////////////////
extern LPCWSTR IDS_Win32ComputerSystem;
extern LPCWSTR IDS_DefaultSystemName;
extern LPCWSTR IDS_RegInfrared;
extern LPCWSTR IDS_Workstation;
extern LPCWSTR IDS_PrimaryOwnerName;
extern LPCWSTR IDS_SystemStartupSetting;
extern LPCWSTR IDS_SystemStartupOptions;
extern LPCWSTR IDS_OEMLogoBitmap;
extern LPCWSTR IDS_BootupStateNormal;       
extern LPCWSTR IDS_BootupStateFailSafe;
extern LPCWSTR IDS_BootupStateFailSafeWithNetBoot;
extern LPCWSTR IDS_LogNoAPMForNT5;
extern LPCWSTR IDS_RegCrashControl;
extern LPCWSTR IDS_RegAutoRebootKey;
extern LPCWSTR IDS_RegCurrentNTVersion;
extern LPCWSTR IDS_RegCurrent95Version;
extern LPCWSTR IDS_RegRegisteredOwnerKey;
extern LPCWSTR IDS_RegProductOptions;
extern LPCWSTR IDS_RegProductTypeKey;
extern LPCWSTR IDS_RegNetworkLogon;
extern LPCWSTR IDS_RegPrimaryProvider;
extern LPCWSTR IDS_RegNetworkProvider;
extern LPCWSTR IDS_RegAuthenticatingAgent;
extern LPCWSTR IDS_MicrosoftNetwork;
extern LPCWSTR IDS_LanmanNT;
extern LPCWSTR IDS_ServerNT;
extern LPCWSTR IDS_Server;
extern LPCWSTR IDS_RegCurrentNTVersionSetup;
extern LPCWSTR IDS_RegBootDirKey;
extern LPCWSTR IDS_BootIni;
extern LPCWSTR IDS_CBootIni;
extern LPCTSTR IDT_BootLoader;
extern LPCTSTR IDT_Timeout;
extern LPCTSTR IDT_OperatingSystems;
extern LPCTSTR IDT_OemLogoBmp;
extern LPCTSTR IDT_Line;
extern LPCTSTR IDT_SupportInformation;
extern LPCTSTR IDT_General;
extern LPCTSTR IDT_OEMInfoIni;
extern LPCWSTR IDS_RegCSEnumRootKey;
extern LPCWSTR IDS_RegPowerManagementKey;
extern LPCWSTR IDS_ATDescription;
extern LPCWSTR IDS_RegIdentifierKey;
extern LPCWSTR IDS_EnableDaylightSavingsTime;
extern LPCWSTR IDS_LargeSystemCache;

//
///////////////////////////////////////////
//
//      Win32_Desktop
//
///////////////////////////////////////////
extern LPCWSTR IDS_RegNTProfileList;
extern LPCWSTR IDS_RegControlPanelDesktop;
extern LPCWSTR IDS_RegControlPanelAppearance;
extern LPCWSTR IDS_RegControlPanelDesktop95;
extern LPCWSTR IDS_RegScreenSaveActive;
extern LPCWSTR IDS_RegSCRNSAVEEXE;
extern LPCWSTR IDS_RegScreenSaverIsSecure;
extern LPCWSTR IDS_RegScreenSaveTimeOut;
extern LPCWSTR IDS_RegTileWallpaper;
extern LPCWSTR IDS_RegWindowMetricsKey;
extern LPCWSTR IDS_RegScreenSaveUsePassword;

//
///////////////////////////////////////////
//
//      Win32_DeviceMemory
//
///////////////////////////////////////////
extern LPCWSTR IDS_RegAddressRange;
extern LPCWSTR IDS_RegStartingAddress;

//
///////////////////////////////////////////
//
//      Win32_Directory
//
///////////////////////////////////////////


//
///////////////////////////////////////////
//
//Win32_DiskPartition
//
///////////////////////////////////////////
extern LPCWSTR IDS_Bootable;
extern LPCWSTR IDS_PhysicalDrive;
extern LPCWSTR IDS_PartitionDescUnused;
extern LPCWSTR IDS_PartitionDesc12bitFAT;
extern LPCWSTR IDS_PartitionDescXenixOne;
extern LPCWSTR IDS_PartitionDescXenixTwo;
extern LPCWSTR IDS_PartitionDesc16bitFAT;
extern LPCWSTR IDS_PartitionDescExtPartition;
extern LPCWSTR IDS_PartitionDescDOSV4Huge;
extern LPCWSTR IDS_PartitionDescInstallable;
extern LPCWSTR IDS_PartitionDescPowerPCRef;
extern LPCWSTR IDS_PartitionDescUnix;
extern LPCWSTR IDS_PartitionDescNTFT;
extern LPCWSTR IDS_PartitionDescWin95Ext;
extern LPCWSTR IDS_PartitionDescExt13;
extern LPCWSTR IDS_PartitionDescUnknown;
extern LPCWSTR IDS_PartitionDescGPTUnused;
extern LPCWSTR IDS_PartitionDescGPTSystem;
extern LPCWSTR IDS_PartitionDescGPTMSFTReserved;
extern LPCWSTR IDS_PartitionDescGPTBasicData;
extern LPCWSTR IDS_PartitionDescGPTLDMMetaData;
extern LPCWSTR IDS_PartitionDescGPTLDMData;
extern LPCWSTR IDS_PartitionDescGPTUnknown;


//
///////////////////////////////////////////
//
//      Win32_DisplayControlConfiguration
//
///////////////////////////////////////////
extern LPCWSTR IDS_AdapterConfiguredIncorrect;

//
///////////////////////////////////////////
//
//      Win32_Environment
//
///////////////////////////////////////////
extern LPCWSTR IDS_SystemUser;
extern LPCWSTR IDS_DefaultUser;
extern LPCWSTR IDS_RegEnvironmentNT;
extern LPCWSTR IDS_RegEnvironmentKey;
extern LPCWSTR IDS_LogInvalidEnvFlags;
extern LPCWSTR IDS_LogUserSystemMismatch;
extern LPCWSTR IDS_LogInvalidEnvDelFlags;


//
///////////////////////////////////////////
//
//      Win32_Keyboard
//
///////////////////////////////////////////
extern LPCWSTR IDS_PCXT;
extern LPCWSTR IDS_ICO;
extern LPCWSTR IDS_PCAT;
extern LPCWSTR IDS_ENHANCED101102;
extern LPCWSTR IDS_NOKIA1050;
extern LPCWSTR IDS_NOKIA9140;
extern LPCWSTR IDS_Japanese;
extern LPCWSTR IDS_UnknownKeyboard;


//
///////////////////////////////////////////
//
//      Win32_LogicalDisk
//
///////////////////////////////////////////
extern LPCWSTR IDS_SupportsFileBasedCompression;


//
///////////////////////////////////////////
//
//      CIM_LogicalFile
//
///////////////////////////////////////////
extern LPCWSTR IDS_Filename;
extern LPCWSTR IDS_Filesize;
extern LPCWSTR IDS_Directory;
extern LPCWSTR IDS_EightDotThreeFileName;
extern LPCWSTR IDS_Archive;
extern LPCWSTR IDS_Hidden;
extern LPCWSTR IDS_System;
extern LPCWSTR IDS_LocalDisk;
extern LPCWSTR IDS_FileFolder;
extern LPCWSTR IDS_FileTypeKeyNT4;
extern LPCWSTR IDS_File;
extern LPCWSTR IDS_CompressionMethod;
extern LPCWSTR IDS_EncryptionMethod;


//
///////////////////////////////////////////
//
//      CIM_LogicalDevice_CIMDataFile   
//
///////////////////////////////////////////
extern LPCWSTR IDS___Path;
extern LPCWSTR IDS___Class;
extern LPCWSTR IDS___Relpath;
extern LPCWSTR IDS_NT_CurCtlSetEnum;
extern LPCWSTR IDS_NT_CurCtlSetSvcs;
extern LPCWSTR IDS_ImagePath;
extern LPCWSTR IDS_98_CurCtlSetSvcCls;
extern LPCWSTR IDS_DevLoader;
extern LPCWSTR IDS_98_Vmm32Files;
extern LPCWSTR IDS_CIMDataFile;
extern LPCWSTR IDS_DriversSubdir;
extern LPCWSTR IDS_Extension_sys;
extern LPCWSTR IDS_DeviceVxDs;
extern LPCWSTR IDS_Enum;
extern LPCWSTR IDS_Count;
extern LPCWSTR IDS_Purpose;


//
///////////////////////////////////////////
//
//      Win32_ShortcutFile   
//
///////////////////////////////////////////
extern LPCWSTR IDS_Target;


//
///////////////////////////////////////////
//
//      Win32_Win32LogicalProgramGroup
//
///////////////////////////////////////////
extern LPCWSTR IDS_BASE_REG_KEY;

//
///////////////////////////////////////////
//
//      Win32_Win32ProgramGroup_CIMDataFile   
//
///////////////////////////////////////////
extern LPCWSTR IDS_Start_MenuWhackPrograms;
extern LPCWSTR IDS_Default_User;
extern LPCWSTR IDS_All_Users;
extern LPCWSTR IDS_Profiles;
extern LPCWSTR IDS_Start_Menu;


//
///////////////////////////////////////////
//
//  Win32_SerialPort
extern LPCWSTR IDS_NT4_PortKey;
extern LPCWSTR IDS_WIN9XCurCtlSet_Svcs_Class;
//
///////////////////////////////////////////


extern WCHAR szBusType[KNOWN_BUS_TYPES][20];
extern LPCWSTR IDS_Caption      ;
extern LPCWSTR IDS_Bus;
extern LPCWSTR IDS_BusNum;
extern LPCWSTR IDS_BusType;
extern LPCWSTR IDS_CreationClassName    ;
extern LPCWSTR IDS_CSCreationClassName  ;
extern LPCWSTR IDS_CSName       ;
extern LPCWSTR IDS_Handle       ;
extern LPCWSTR IDS_OSCreationClassName;
extern LPCWSTR IDS_WorkingSetSize;
extern LPCWSTR IDS_OSName;
extern LPCWSTR IDS_Description  ;
extern LPCWSTR IDS_DeviceID;
extern LPCWSTR IDS_HotSwappable ;
extern LPCWSTR IDS_XOnXMitThreshold     ;
extern LPCWSTR IDS_MaxTransmissionSpeed ;
extern LPCWSTR IDS_MaxTransmissionSpeedToPhone ;
extern LPCWSTR IDS_AnswerMode;
extern LPCWSTR IDS_Control;
extern LPCWSTR IDS_LINEANSWERMODENODE;
extern LPCWSTR IDS_LINEANSWERMODEDROP;
extern LPCWSTR IDS_LINEANSWERMODEHOLD;
extern LPCWSTR IDS_XOffXMitThreshold    ;
extern LPCWSTR IDS_Unsupported;
extern LPCWSTR IDS_ContinueXMitOnXOff;
extern LPCWSTR IDS_AbortReadWriteOnError;
extern LPCWSTR IDS_Installed    ;
extern LPCWSTR IDS_Name  ;
extern LPCWSTR IDS_DNSName  ;
extern LPCWSTR IDS_Manufacturer     ;
extern LPCTSTR IDT_Model            ;
extern LPCWSTR IDS_PowerState       ;
extern LPCWSTR IDS_SerialNumber     ;
extern LPCWSTR IDS_SKU              ;
extern LPCWSTR IDS_Tag              ;
extern LPCWSTR IDS_Version          ;
extern LPCWSTR IDS_InUse            ;
extern LPCWSTR IDS_PrimaryOwner     ;
extern LPCWSTR IDS_BasePriority     ;
extern LPCWSTR IDS_ProcessID        ;
extern LPCWSTR IDS_JobCountSinceLastReset ;
extern LPCWSTR IDS_BuildNumber          ;
extern LPCWSTR IDS_FSCreationClassName;
extern LPCWSTR IDS_FSName;
extern LPCWSTR IDS_CreationDate;
extern LPCWSTR IDS_InstallDate;
extern LPCWSTR IDS_BuildType            ;
extern LPCWSTR IDS_CodeSet              ;
extern LPCWSTR IDS_Installable          ;
extern LPCWSTR IDS_InstallationDate     ;
extern LPCWSTR IDS_InUseCount           ;
extern LPCWSTR IDS_Locale               ;
extern LPCWSTR IDS_CasePreserved    ;
extern LPCWSTR IDS_CaseSensitive    ;
extern LPCWSTR IDS_Unicode          ;
extern LPCWSTR IDS_Archived         ;
extern LPCWSTR IDS_Compressed       ;
extern LPCWSTR IDS_Created          ;
extern LPCWSTR IDS_Extension        ;
extern LPCWSTR IDS_FileType         ;
extern LPCWSTR IDS_LastAccessed     ;
extern LPCWSTR IDS_LastModified     ;
extern LPCWSTR IDS_Open             ;
extern LPCWSTR IDS_Path             ;
extern LPCWSTR IDS_Readable         ;
extern LPCWSTR IDS_Size             ;
extern LPCWSTR IDS_Writeable        ;
extern LPCWSTR IDS_ServiceType  ;
extern LPCWSTR IDS_State        ;
extern LPCWSTR IDS_ServiceName      ;
extern LPCWSTR IDS_Status           ;
extern LPCWSTR IDS_StatusInfo ;
extern LPCWSTR IDS_MaxNumberControlled ;
extern LPCWSTR IDS_TimeOfLastReset;
extern LPCWSTR IDS_ProtocolSupported;
extern LPCWSTR IDS_BatteryChargeStatus          ;
extern LPCWSTR IDS_BatteryInstalled             ;
extern LPCWSTR IDS_BatteryLifeLeft              ;
extern LPCWSTR IDS_BatteryLifetime              ;
extern LPCWSTR IDS_CanTurnOffRemotely           ;
extern LPCWSTR IDS_CommandFile                  ;
extern LPCWSTR IDS_FirstMessageDelay            ;
extern LPCWSTR IDS_LowBatterySignal             ;
extern LPCWSTR IDS_MessageInterval              ;
extern LPCWSTR IDS_RemainingCapacityStatus      ;
extern LPCWSTR IDS_EstimatedChargeRemaining     ;
extern LPCWSTR IDS_EstimatedRunTime             ;
extern LPCWSTR IDS_PowerFailSignal              ;
extern LPCWSTR IDS_RechargeRate                 ;
extern LPCWSTR IDS_Type                         ;
extern LPCWSTR IDS_UPSPort                      ;
extern LPCWSTR IDS_VoltageCapability            ;
extern LPCWSTR IDS_FreeSpace  ;
extern LPCWSTR IDS_PeakUsage  ;
extern LPCWSTR IDS_LastBootupTime   ;
extern LPCWSTR IDS_SupportContact   ;
extern LPCWSTR IDS_SystemTime       ;
extern LPCWSTR IDS_ConnectionlessService        ;
extern LPCWSTR IDS_GuaranteesDelivery           ;
extern LPCWSTR IDS_GuaranteesSequencing         ;
extern LPCWSTR IDS_MaximumAddressSize           ;
extern LPCWSTR IDS_MaximumMessageSize           ;
extern LPCWSTR IDS_MessageOriented              ;
extern LPCWSTR IDS_MinimumAddressSize           ;
extern LPCWSTR IDS_PseudoStreamOriented         ;
extern LPCWSTR IDS_SupportsBroadcasting         ;
extern LPCWSTR IDS_SupportsConnectData          ;
extern LPCWSTR IDS_SupportsDisconnectData       ;
extern LPCWSTR IDS_SupportsEncryption           ;
extern LPCWSTR IDS_SupportsExpeditedData        ;
extern LPCWSTR IDS_SupportsFragmentation        ;
extern LPCWSTR IDS_SupportsGracefulClosing      ;
extern LPCWSTR IDS_SupportsGuaranteedBandwidth  ;
extern LPCWSTR IDS_SupportsMulticasting         ;
extern LPCWSTR IDS_SupportsQualityofService             ;
extern LPCWSTR IDS_ExecutableType   ;
extern LPCWSTR IDS_DeviceIsBusy  ;
extern LPCWSTR IDS_AdapterType      ;
extern LPCWSTR IDS_AdapterTypeID    ;
extern LPCWSTR IDS_Index            ;
extern LPCWSTR IDS_InterfaceIndex   ;
extern LPCWSTR IDS_IOPortAddress    ;
extern LPCWSTR IDS_MACAddress       ;
extern LPCWSTR IDS_Baud             ;
extern LPCWSTR IDS_ByteSize         ;
extern LPCWSTR IDS_DSRSensitivity   ;
extern LPCWSTR IDS_DTRControl       ;
extern LPCWSTR IDS_OutTxCTSFlow     ;
extern LPCWSTR IDS_OutTxDSRFlow     ;
extern LPCWSTR IDS_Parity           ;
extern LPCWSTR IDS_ParityEnabled    ;
extern LPCWSTR IDS_StopBits         ;
extern LPCWSTR IDS_MaxClockSpeed    ;
extern LPCWSTR IDS_CurrentClockSpeed;
extern LPCWSTR IDS_Family           ;
extern LPCWSTR IDS_Role             ;
extern LPCWSTR IDS_Architecture    ;
extern LPCWSTR IDS_Stepping    ;
extern LPCWSTR IDS_Level           ;
extern LPCWSTR IDS_Revision        ;
extern LPCWSTR IDS_L2CacheSize     ;
extern LPCWSTR IDS_L2CacheSpeed    ;
extern LPCWSTR IDS_UpgradeMethod    ;
extern LPCWSTR IDS_Layout                   ;
extern LPCWSTR IDS_NumberOfFunctionKeys     ;
extern LPCWSTR IDS_ConnectionMode               ;
extern LPCWSTR IDS_HardwareID                   ;
extern LPCWSTR IDS_MaximumTransmissionSpeed     ;
extern LPCWSTR IDS_Mode                         ;
extern LPCWSTR IDS_TransmissionSpeed            ;
extern LPCWSTR IDS_ButtonsSwapped           ;
extern LPCWSTR IDS_ConnectMultiplePorts     ;
extern LPCWSTR IDS_DataQueueSize            ;
extern LPCWSTR IDS_DriverName               ;
extern LPCWSTR IDS_DeviceInterface          ;
extern LPCWSTR IDS_HardwareType             ;
extern LPCWSTR IDS_HorizontalMickeys        ;
extern LPCWSTR IDS_MaximumPortsServiced     ;
extern LPCWSTR IDS_NumberOfButtons          ;
extern LPCWSTR IDS_PointerType              ;
extern LPCWSTR IDS_Resolution               ;
extern LPCWSTR IDS_Speed                    ;
extern LPCWSTR IDS_Synch                    ;
extern LPCWSTR IDS_VerticalMickeys          ;
extern LPCWSTR IDS_XThreshold               ;
extern LPCWSTR IDS_YThreshold               ;
extern LPCWSTR IDS_ZThreshold               ;
extern LPCWSTR IDS_AveragePagesPerMinute        ;
extern LPCWSTR IDS_Comment                      ;
extern LPCWSTR IDS_PrintProcessorParameters     ;
extern LPCWSTR IDS_SpoolEnabled     ;
extern LPCWSTR IDS_Processor                    ;
extern LPCWSTR IDS_ElapsedTime      ;
extern LPCWSTR IDS_JobDestination   ;
extern LPCWSTR IDS_Notify           ;
extern LPCWSTR IDS_Owner            ;
extern LPCWSTR IDS_Priority         ;
extern LPCWSTR IDS_StartTime        ;
extern LPCWSTR IDS_TimeSubmitted    ;
extern LPCWSTR IDS_UntilTime        ;
extern LPCWSTR IDS_MediaLoaded          ;
extern LPCWSTR IDS_MediaType            ;
extern LPCWSTR IDS_MediaRemovable       ;
extern LPCWSTR IDS_Compression              ;
extern LPCWSTR IDS_DefaultBlockSize         ;
extern LPCWSTR IDS_ECC                      ;
extern LPCWSTR IDS_EndOfTapeWarningZoneSize       ;
extern LPCWSTR IDS_FeaturesHigh             ;
extern LPCWSTR IDS_FeaturesLow              ;
extern LPCWSTR IDS_MaximumBlockSize         ;
extern LPCWSTR IDS_MaximumPartitionCount    ;
extern LPCWSTR IDS_MinimumBlockSize         ;
extern LPCWSTR IDS_Padding                  ;
extern LPCWSTR IDS_ReportSetMarks           ;
extern LPCWSTR IDS_BytesPerSector           ;
extern LPCWSTR IDS_InterfaceType            ;
extern LPCWSTR IDS_Partitions               ;
extern LPCWSTR IDS_Signature                ;
extern LPCWSTR IDS_TotalCylinders           ;
extern LPCWSTR IDS_TotalSectors             ;
extern LPCWSTR IDS_TotalTracks              ;
extern LPCWSTR IDS_TracksPerCylinder        ;
extern LPCWSTR IDS_SectorsPerTrack          ;
extern LPCWSTR IDS_TotalBadSectors          ;
extern LPCWSTR IDS_LandingZoneCylinder      ;
extern LPCWSTR IDS_WritePrecompCylinder     ;
extern LPCWSTR IDS_TotalHeads               ;
extern LPCWSTR IDS_BootDirectory         ;
extern LPCWSTR IDS_ConfigurationPath     ;
extern LPCWSTR IDS_LastDrive             ;
extern LPCWSTR IDS_ScratchDirectory      ;
extern LPCWSTR IDS_TempDirectory         ;
extern LPCWSTR IDS_BorderWidth               ;
extern LPCWSTR IDS_CoolSwitch                ;
extern LPCWSTR IDS_CursorBlinkRate           ;
extern LPCWSTR IDS_DragFullWindows           ;
extern LPCWSTR IDS_GridGranularity           ;
extern LPCWSTR IDS_IconSpacing               ;
extern LPCWSTR IDS_IconFont                  ;
extern LPCWSTR IDS_IconTitleFaceName         ;
extern LPCWSTR IDS_IconTitleSize             ;
extern LPCWSTR IDS_IconTitleWrap             ;
extern LPCWSTR IDS_Pattern                   ;
extern LPCWSTR IDS_ScreenSaverActive         ;
extern LPCWSTR IDS_ScreenSaverExecutable     ;
extern LPCWSTR IDS_ScreenSaverSecure         ;
extern LPCWSTR IDS_ScreenSaverTimeout        ;
extern LPCWSTR IDS_Wallpaper                 ;
extern LPCWSTR IDS_WallpaperTiled            ;
extern LPCWSTR IDS_AvailableVirtualMemory    ;
extern LPCWSTR IDS_TotalPageFileSpace        ;
extern LPCWSTR IDS_TotalPhysicalMemory       ;
extern LPCWSTR IDS_TotalVirtualMemory        ;
extern LPCWSTR IDS_GroupName  ;
extern LPCWSTR IDS_AccountExpires        ;
extern LPCWSTR IDS_AuthorizationFlags    ;
extern LPCWSTR IDS_BadPasswordCount      ;
extern LPCWSTR IDS_CodePage              ;
extern LPCWSTR IDS_Comment               ;
extern LPCWSTR IDS_CountryCode           ;
extern LPCWSTR IDS_Flags                 ;
extern LPCWSTR IDS_FullName              ;
extern LPCWSTR IDS_HomeDirectory         ;
extern LPCWSTR IDS_HomeDirectoryDrive    ;
extern LPCWSTR IDS_LastLogoff            ;
extern LPCWSTR IDS_LastLogon             ;
extern LPCWSTR IDS_LogonHours            ;
extern LPCWSTR IDS_LogonServer           ;
extern LPCWSTR IDS_MaximumStorage        ;
extern LPCWSTR IDS_NumberOfLogons        ;
extern LPCWSTR IDS_Parms                 ;
extern LPCWSTR IDS_Password              ;
extern LPCWSTR IDS_PasswordAge           ;
extern LPCWSTR IDS_PasswordExpired       ;
extern LPCWSTR IDS_PrimaryGroupId        ;
extern LPCWSTR IDS_Privileges            ;
extern LPCWSTR IDS_Profile               ;
extern LPCWSTR IDS_ScriptPath            ;
extern LPCWSTR IDS_UnitsPerWeek          ;
extern LPCWSTR IDS_UserComment           ;
extern LPCWSTR IDS_UserId                ;
extern LPCWSTR IDS_UserType              ;
extern LPCWSTR IDS_Workstations          ;
extern LPCWSTR IDS_DefaultIPGateway      ;
extern LPCWSTR IDS_DHCPEnabled           ;
extern LPCWSTR IDS_DHCPLeaseExpires      ;
extern LPCWSTR IDS_DHCPLeaseObtained     ;
extern LPCWSTR IDS_DHCPServer            ;
extern LPCWSTR IDS_IOAddress             ;
extern LPCWSTR IDS_IPAddress             ;
extern LPCWSTR IDS_IPSubnet              ;
extern LPCWSTR IDS_IPXAddress            ;
extern LPCWSTR IDS_IRQ                   ;
extern LPCWSTR IDS_MACAddress            ;
extern LPCWSTR IDS_AbortReadOrWriteOnError  ;
extern LPCWSTR IDS_BaudRate                 ;
extern LPCWSTR IDS_BinaryModeEnabled        ;
extern LPCWSTR IDS_BitsPerByte              ;
extern LPCWSTR IDS_ContinueTransmitOnXOff   ;
extern LPCWSTR IDS_CTSOutflowControl        ;
extern LPCWSTR IDS_DiscardNULLBytes         ;
extern LPCWSTR IDS_DSROutflowControl        ;
extern LPCWSTR IDS_DSRSensitivity           ;
extern LPCWSTR IDS_DTRFlowControlType       ;
extern LPCWSTR IDS_EndOfFileCharacter       ;
extern LPCWSTR IDS_ErrorReplaceCharacter    ;
extern LPCWSTR IDS_ErrorReplacementEnabled  ;
extern LPCWSTR IDS_EventCharacter           ;
extern LPCWSTR IDS_IsBusy                   ;
extern LPCWSTR IDS_Parity                   ;
extern LPCWSTR IDS_ParityCheckEnabled       ;
extern LPCWSTR IDS_RTSFlowControlType       ;
extern LPCWSTR IDS_StopBits                 ;
extern LPCWSTR IDS_XOffCharacter            ;
extern LPCWSTR IDS_XOffTransmitThreshold    ;
extern LPCWSTR IDS_XOnCharacter             ;
extern LPCWSTR IDS_XOnTransmitThreshold     ;
extern LPCWSTR IDS_XOnXOffInflowControl     ;
extern LPCWSTR IDS_XOnXOffOutflowControl    ;
extern LPCWSTR IDS_DaylightInEffect      ;
extern LPCWSTR IDS_Bias                  ;
extern LPCWSTR IDS_StandardName          ;
extern LPCWSTR IDS_StandardYear          ;
extern LPCWSTR IDS_StandardMonth         ;
extern LPCWSTR IDS_StandardDayOfWeek     ;
extern LPCWSTR IDS_StandardDay           ;
extern LPCWSTR IDS_StandardHour          ;
extern LPCWSTR IDS_StandardMinute        ;
extern LPCWSTR IDS_StandardSecond        ;
extern LPCWSTR IDS_StandardMillisecond   ;
extern LPCWSTR IDS_StandardBias          ;
extern LPCWSTR IDS_DaylightName          ;
extern LPCWSTR IDS_DaylightYear          ;
extern LPCWSTR IDS_DaylightMonth         ;
extern LPCWSTR IDS_DaylightDayOfWeek     ;
extern LPCWSTR IDS_DaylightDay           ;
extern LPCWSTR IDS_DaylightHour          ;
extern LPCWSTR IDS_DaylightMinute        ;
extern LPCWSTR IDS_DaylightSecond        ;
extern LPCWSTR IDS_DaylightMillisecond   ;
extern LPCWSTR IDS_DaylightBias          ;
extern LPCWSTR IDS_ConnectionType    ;
extern LPCWSTR IDS_RemotePath        ;
extern LPCWSTR IDS_LocalName         ;
extern LPCWSTR IDS_RemoteName        ;
extern LPCWSTR IDS_ProviderName      ;
extern LPCWSTR IDS_DisplayType       ;
extern LPCWSTR IDS_ResourceType      ;
extern LPCWSTR IDS_GroupOrder  ;
extern LPCWSTR IDS_CommandLine       ;
extern LPCWSTR IDS_Dependencies      ;
extern LPCWSTR IDS_DisplayName       ;
extern LPCWSTR IDS_ErrorControl      ;
extern LPCWSTR IDS_LoadOrderGroup    ;
extern LPCWSTR IDS_PathName          ;
extern LPCWSTR IDS_StartName         ;
extern LPCWSTR IDS_StartType         ;
extern LPCWSTR IDS_TagId             ;
extern LPCWSTR IDS_AcceptStop        ;
extern LPCWSTR IDS_AcceptPause       ;
extern LPCWSTR IDS_AutomaticResetBootOption      ;
extern LPCWSTR IDS_AutomaticResetCapability      ;
extern LPCWSTR IDS_AutomaticResetStatus          ;
extern LPCWSTR IDS_AutomaticResetTimerInterval   ;
extern LPCWSTR IDS_AutomaticResetTimerReset      ;
extern LPCWSTR IDS_BootRomSupported              ;
extern LPCWSTR IDS_BootupState                   ;
extern LPCWSTR IDS_ConditionalReboot             ;
extern LPCWSTR IDS_InfraredSupported             ;
extern LPCWSTR IDS_InstallationDate              ;
extern LPCWSTR IDS_Locale                        ;
extern LPCWSTR IDS_LockKeyboardAndMouse          ;
extern LPCWSTR IDS_LockPCPowerOnAndResetButtons  ;
extern LPCWSTR IDS_LockSystem                    ;
extern LPCWSTR IDS_NetworkServerModeEnabled      ;
extern LPCWSTR IDS_PowerManagementSupported      ;
extern LPCWSTR IDS_PowerManagementCapabilities    ;
extern LPCWSTR IDS_PowerManagementEnabled             ;
extern LPCWSTR IDS_SystemCreationClassName                ;
extern LPCWSTR IDS_SystemName                                     ;
extern LPCWSTR IDS_ResetBootOption               ;
extern LPCWSTR IDS_ResetTimeout                  ;
extern LPCWSTR IDS_SystemFilesNotModified        ;
extern LPCWSTR IDS_SystemRole                    ;
extern LPCWSTR IDS_SystemType                    ;
extern LPCWSTR IDS_NumberOfProcessors            ;
extern LPCWSTR IDS_UnconditionalReboot           ;
extern LPCWSTR IDS_UserName                      ;
extern LPCWSTR IDS_Created                       ;
extern LPCWSTR IDS_ExecutablePath                ;
extern LPCWSTR IDS_Exited                        ;
extern LPCWSTR IDS_MaximumWorkingSetSize         ;
extern LPCWSTR IDS_MinimumWorkingSetSize         ;
extern LPCWSTR IDS_PageFaults                    ;
extern LPCWSTR IDS_PageFileUsage                 ;
extern LPCWSTR IDS_PeakPageFileUsage             ;
extern LPCWSTR IDS_PeakWorkingSetSize            ;
extern LPCWSTR IDS_QuotaNonPagedPoolUsage        ;
extern LPCWSTR IDS_QuotaPagedPoolUsage           ;
extern LPCWSTR IDS_QuotaPeakNonPagedPoolUsage    ;
extern LPCWSTR IDS_QuotaPeakPagedPoolUsage       ;
extern LPCWSTR IDS_ThreadCount                   ;
extern LPCWSTR IDS_KernelModeTime                ;
extern LPCWSTR IDS_UserModeTime                                  ;
extern LPCWSTR IDS_WindowsVersion                ;
extern LPCWSTR IDS_Characteristics   ;
extern LPCWSTR IDS_EndingAddress     ;
extern LPCWSTR IDS_PrimaryBIOS       ;
extern LPCWSTR IDS_ReleaseDate       ;
extern LPCWSTR IDS_SerialNumber      ;
extern LPCWSTR IDS_StartingAddress   ;
extern LPCWSTR IDS_Verify            ;
extern LPCWSTR IDS_BootDevice            ;
extern LPCWSTR IDS_CSDVersion            ;
extern LPCWSTR IDS_Primary               ;
extern LPCWSTR IDS_SystemDirectory       ;
extern LPCWSTR IDS_SystemStartOptions    ;
extern LPCWSTR IDS_WindowsDirectory      ;
extern LPCWSTR IDS_EnforcesACLs    ;
extern LPCWSTR IDS_DeviceType           ;
extern LPCWSTR IDS_Length               ;       
extern LPCWSTR IDS_ShareDisposition     ;
extern LPCWSTR IDS_Start                ;
extern LPCWSTR IDS_DeviceDescriptorBlock     ;
extern LPCWSTR IDS_IdentiferNumber           ;
extern LPCWSTR IDS_PM_API                    ;
extern LPCWSTR IDS_ServiceTableSize          ;
extern LPCWSTR IDS_V86_API                   ;
extern LPCWSTR IDS_AccountDisabled               ;
extern LPCWSTR IDS_AccountLockout                ;
extern LPCWSTR IDS_CannotChangePassword          ;
extern LPCWSTR IDS_ChangePasswordOnNextLogon     ;
extern LPCWSTR IDS_Domain                        ;
extern LPCWSTR IDS_Organization                  ;
extern LPCWSTR IDS_Phone                         ;
extern LPCWSTR IDS_AddressRange      ;
extern LPCWSTR IDS_MemoryType        ;
extern LPCWSTR IDS_Owner             ;
extern LPCWSTR IDS_BurstMode     ;
extern LPCWSTR IDS_DMAChannel    ;
extern LPCWSTR IDS_ChannelWidth  ;
extern LPCWSTR IDS_Port          ;
extern LPCWSTR IDS_AffinityMask      ;
extern LPCWSTR IDS_Availability      ;
extern LPCWSTR IDS_InterruptType     ;
extern LPCWSTR IDS_IRQNumber         ;
extern LPCWSTR IDS_Level             ;
extern LPCWSTR IDS_Shareable         ;
extern LPCWSTR IDS_TriggerType       ;
extern LPCWSTR IDS_Vector            ;
extern LPCWSTR IDS_Address  ;
extern LPCWSTR IDS_ProductName  ;
extern LPCWSTR IDS_Binary                    ;
extern LPCWSTR IDS_MaximumBaudRate           ;
extern LPCWSTR IDS_MaximumInputBufferSize    ;
extern LPCWSTR IDS_MaximumOutputBufferSize   ;
extern LPCWSTR IDS_ProviderType              ;
extern LPCWSTR IDS_SettableBaudRate          ;
extern LPCWSTR IDS_SettableDataBits          ;
extern LPCWSTR IDS_SettableFlowControl       ;
extern LPCWSTR IDS_SettableParity            ;
extern LPCWSTR IDS_SettableParityCheck       ;
extern LPCWSTR IDS_SettableRLSD              ;
extern LPCWSTR IDS_SettableStopBits          ;
extern LPCWSTR IDS_Supports16BitMode         ;
extern LPCWSTR IDS_SupportsDTRDSR            ;
extern LPCWSTR IDS_SupportsIntervalTimeouts  ;
extern LPCWSTR IDS_SupportsParityCheck       ;
extern LPCWSTR IDS_SupportsRLSD              ;
extern LPCWSTR IDS_SupportsRTSCTS            ;
extern LPCWSTR IDS_SupportsSettableXOnXOff   ;
extern LPCWSTR IDS_SupportsSpecialChars      ;
extern LPCWSTR IDS_SupportsElapsedTimeouts   ;
extern LPCWSTR IDS_SupportsXOnXOff           ;
extern LPCWSTR IDS_Capabilities     ;
extern LPCWSTR IDS_DmaSupport       ;
extern LPCWSTR IDS_DriverName        ;
extern LPCWSTR IDS_DeviceMap             ;
extern LPCWSTR IDS_HardwareVersion       ;
extern LPCWSTR IDS_InterruptNumber   ;
extern LPCWSTR IDS_AttachedTo         ;
extern LPCWSTR IDS_BlindOff           ;
extern LPCWSTR IDS_BlindOn            ;
extern LPCWSTR IDS_CallSetupFailTimer ;
extern LPCWSTR IDS_CompatibilityFlags ;
extern LPCWSTR IDS_CompressionOff     ;
extern LPCWSTR IDS_CompressionOn      ;
extern LPCWSTR IDS_ConfigurationDialog;
extern LPCWSTR IDS_DCB                ;
extern LPCWSTR IDS_Default            ;
extern LPCTSTR IDT_Default            ;
extern LPCWSTR IDS_DeviceLoader       ;
extern LPCWSTR IDS_DialPrefix         ;
extern LPCWSTR IDS_DialSuffix         ;
extern LPCWSTR IDS_DriverDate          ;
extern LPCWSTR IDS_ErrorControlForced ;
extern LPCWSTR IDS_ErrorControlOff    ;
extern LPCWSTR IDS_ErrorControlOn     ;
extern LPCWSTR IDS_FlowControlHard    ;
extern LPCWSTR IDS_FlowControlSoft    ;
extern LPCWSTR IDS_FlowControlOff     ;
extern LPCWSTR IDS_InactivityScale    ;
extern LPCWSTR IDS_InactivityTimeout  ;
extern LPCWSTR IDS_ModemInfPath       ;
extern LPCWSTR IDS_ModemInfSection    ;
extern LPCWSTR IDS_Model              ;
extern LPCWSTR IDS_ModulationBell     ;
extern LPCWSTR IDS_ModulationCCITT    ;
extern LPCWSTR IDS_PortSubClass       ;
extern LPCWSTR IDS_Prefix             ;
extern LPCWSTR IDS_Properties         ;
extern LPCWSTR IDS_Pulse              ;
extern LPCWSTR IDS_Reset              ;
extern LPCWSTR IDS_ResponsesKeyName   ;
extern LPCWSTR IDS_SpeakerModeDial    ;
extern LPCWSTR IDS_SpeakerModeOff     ;
extern LPCWSTR IDS_SpeakerModeOn      ;
extern LPCWSTR IDS_SpeakerModeSetup   ;
extern LPCWSTR IDS_SpeakerVolumeHigh  ;
extern LPCWSTR IDS_SpeakerVolumeLow   ;
extern LPCWSTR IDS_SpeakerVolumeMed   ;
extern LPCWSTR IDS_StringFormat       ;
extern LPCWSTR IDS_Terminator         ;
extern LPCWSTR IDS_Tone               ;
extern LPCWSTR IDS_VoiceSwitchFeature ;
extern LPCWSTR IDS_PrimaryBusType    ;
extern LPCWSTR IDS_SecondaryBusType  ;
extern LPCWSTR IDS_RevisionNumber    ;
extern LPCWSTR IDS_EnableWheelDetection  ;
extern LPCWSTR IDS_InfFileName           ;
extern LPCWSTR IDS_InfSection            ;
extern LPCWSTR IDS_SampleRate            ;
extern LPCWSTR IDS_Attributes            ;
extern LPCWSTR IDS_DefaultPriority      ;
extern LPCWSTR IDS_JobCount              ;
extern LPCWSTR IDS_PortName              ;
extern LPCWSTR IDS_PrintJobDataType      ;
extern LPCWSTR IDS_Priority             ;
extern LPCWSTR IDS_SeparatorFile         ;
extern LPCWSTR IDS_ServerName            ;
extern LPCWSTR IDS_ShareName             ;
extern LPCWSTR IDS_StartTime            ;
extern LPCWSTR IDS_UntilTime            ;
extern LPCWSTR IDS_Disabled             ;
extern LPCWSTR IDS_PasswordRequired     ;
extern LPCWSTR IDS_PasswordChangeable   ;
extern LPCWSTR IDS_Lockout              ;
extern LPCWSTR IDS_PasswordExpires      ;
extern LPCWSTR IDS_AccountType          ;
extern LPCWSTR IDS_SIDType              ;
extern LPCWSTR IDS_SID                  ;
extern LPCWSTR IDS_GroupComponent       ;
extern LPCWSTR IDS_PartComponent        ;
extern LPCWSTR IDS_DataType          ;
extern LPCWSTR IDS_Document         ;
extern LPCWSTR IDS_HostPrintQueue    ;
extern LPCWSTR IDS_JobId             ;
extern LPCWSTR IDS_PagesPrinted      ;
extern LPCWSTR IDS_Parameters        ;
extern LPCWSTR IDS_PrintProcessor    ;
extern LPCWSTR IDS_Size              ;
extern LPCWSTR IDS_TotalPages        ;
extern LPCWSTR IDS_Drive                    ;
extern LPCWSTR IDS_FileSystemFlags          ;
extern LPCWSTR IDS_FileSystemFlagsEx        ;
extern LPCWSTR IDS_Id                       ;
extern LPCWSTR IDS_MaximumComponentLength   ;
extern LPCWSTR IDS_RevisionLevel            ;
extern LPCWSTR IDS_SCSILun                  ;
extern LPCWSTR IDS_SCSITargetId             ;
extern LPCWSTR IDS_VolumeName               ;
extern LPCWSTR IDS_VolumeSerialNumber       ;
extern LPCWSTR IDS_SCSIBus          ;
extern LPCWSTR IDS_SCSIPort         ;
extern LPCWSTR IDS_SCSILogicalUnit  ; 
extern LPCWSTR IDS_SCSITargetID     ;
extern LPCWSTR IDS_FileSystem  ;
extern LPCWSTR IDS_BootPartition     ;
extern LPCWSTR IDS_Compressed        ;
extern LPCWSTR IDS_DiskIndex         ;
extern LPCWSTR IDS_Encrypted         ;
extern LPCWSTR IDS_HiddenSectors     ;
extern LPCWSTR IDS_RewritePartition  ;
extern LPCWSTR IDS_StartingOffset    ;
extern LPCWSTR IDS_BitsPerPel        ;
extern LPCWSTR IDS_DeviceName        ;
extern LPCWSTR IDS_DisplayFlags      ;
extern LPCWSTR IDS_DisplayFrequency  ;
extern LPCWSTR IDS_DitherType        ;
extern LPCWSTR IDS_DriverVersion     ;
extern LPCWSTR IDS_ICMIntent         ;
extern LPCWSTR IDS_ICMMethod         ;
extern LPCWSTR IDS_LogPixels         ;
extern LPCWSTR IDS_PelsHeight        ;
extern LPCWSTR IDS_PelsWidth         ;
extern LPCWSTR IDS_SpecificationVersion  ;
extern LPCWSTR IDS_TTOption          ;
extern LPCWSTR IDS_BitsPerPixel                  ;
extern LPCWSTR IDS_ColorPlanes                   ;
extern LPCWSTR IDS_DeviceEntriesInAColorTable    ;
extern LPCWSTR IDS_ColorTableEntries             ;
extern LPCWSTR IDS_DeviceSpecificPens            ;
extern LPCWSTR IDS_HorizontalResolution          ;
extern LPCWSTR IDS_RefreshRate                   ;
extern LPCWSTR IDS_ReservedSystemPaletteEntries  ;
extern LPCWSTR IDS_SystemPaletteEntries          ;
extern LPCWSTR IDS_VerticalResolution            ;
extern LPCWSTR IDS_VideoMode                     ;
extern LPCWSTR IDS_ActualColorResolution        ;
extern LPCWSTR IDS_AdapterChipType              ;
extern LPCWSTR IDS_AdapterCompatibility         ;
extern LPCWSTR IDS_AdapterDACType               ;
extern LPCWSTR IDS_AdapterDescription           ;
extern LPCWSTR IDS_AdapterLocale                ;
extern LPCWSTR IDS_AdapterRAM                   ;
extern LPCWSTR IDS_AdapterType                  ;
extern LPCWSTR IDS_InstalledDisplayDrivers      ;
extern LPCWSTR IDS_MonitorManufacturer          ;
extern LPCWSTR IDS_MonitorType                  ;
extern LPCWSTR IDS_PixelsPerXLogicalInch        ;
extern LPCWSTR IDS_PixelsPerYLogicalInch        ;
extern LPCWSTR IDS_ScanMode                     ;
extern LPCWSTR IDS_ScreenHeight                 ;
extern LPCWSTR IDS_ScreenWidth                  ;
extern LPCWSTR IDS_Collate           ;
extern LPCWSTR IDS_Color             ;
extern LPCWSTR IDS_Copies            ;
extern LPCWSTR IDS_Duplex            ;
extern LPCWSTR IDS_FormName          ;
extern LPCWSTR IDS_MediaType         ;
extern LPCWSTR IDS_Orientation       ;
extern LPCWSTR IDS_PaperLength       ;
extern LPCWSTR IDS_PaperSize         ;
extern LPCWSTR IDS_PaperWidth        ;
extern LPCWSTR IDS_PrintQuality      ;
extern LPCWSTR IDS_Scale             ;
extern LPCWSTR IDS_YResolution       ;
extern LPCWSTR IDS_VariableName      ;
extern LPCWSTR IDS_VariableValue     ;
extern LPCWSTR IDS_MaximumSize  ;
extern LPCWSTR IDS_InitialSize ;
extern LPCWSTR IDS_AllocatedBaseSize  ;
extern LPCWSTR IDS_CurrentUsage  ;
extern LPCWSTR IDS_AllowMaximum      ;
extern LPCWSTR IDS_MaximumAllowed    ;
extern LPCWSTR IDS_Location          ;
extern LPCWSTR IDS_DriveType         ;
extern LPCWSTR  IDS_Antecedent  ;
extern LPCWSTR  IDS_Dependent   ;
extern LPCWSTR  IDS_Adapter             ;
extern LPCWSTR  IDS_Protocol    ;
extern LPCWSTR  IDS_Service             ;
extern LPCWSTR  IDS_Element             ;
extern LPCWSTR  IDS_Setting             ;
extern LPCWSTR IDS_SupportsDiskQuotas;
extern LPCWSTR IDS_QuotasIncomplete;
extern LPCWSTR IDS_QuotasRebuilding;
extern LPCWSTR IDS_QuotasDisabled;
extern LPCWSTR IDS_VolumeDirty;
extern LPCWSTR IDS_SessionID;
extern LPCWSTR IDS_LocalAccount;

extern LPCWSTR IDS_CurrentTimeZone;
extern LPCWSTR IDS_NameFormat;
extern LPCWSTR IDS_Roles;
extern LPCWSTR IDS_DomainRole;
extern LPCWSTR IDS_PrimaryOwnerContact;
extern LPCWSTR IDS_SupportContactDescription;
extern LPCWSTR IDS_SystemStartupDelay;
extern LPCWSTR IDS_SystemVariable;

extern LPCWSTR  IDS_CimWin32Namespace           ;
extern LPCWSTR  IDS_GETLASTERROR;

extern LPCWSTR  IDS_CfgMgrDeviceStatus_OK       ;
extern LPCWSTR  IDS_CfgMgrDeviceStatus_ERR      ;

extern LPCWSTR  IDS_PRINTER_STATUS_PAUSED;
extern LPCWSTR  IDS_PRINTER_STATUS_PENDING_DELETION;
extern LPCWSTR  IDS_PRINTER_STATUS_BUSY;
extern LPCWSTR  IDS_PRINTER_STATUS_DOOR_OPEN;
extern LPCWSTR  IDS_PRINTER_STATUS_ERROR;
extern LPCWSTR  IDS_PRINTER_STATUS_INITIALIZING;
extern LPCWSTR  IDS_PRINTER_STATUS_IO_ACTIVE;
extern LPCWSTR  IDS_PRINTER_STATUS_MANUAL_FEED;
extern LPCWSTR  IDS_PRINTER_STATUS_NO_TONER;
extern LPCWSTR  IDS_PRINTER_STATUS_NOT_AVAILABLE;
extern LPCWSTR  IDS_PRINTER_STATUS_OFFLINE;
extern LPCWSTR  IDS_PRINTER_STATUS_OUT_OF_MEMORY;
extern LPCWSTR  IDS_PRINTER_STATUS_OUTPUT_BIN_FULL;
extern LPCWSTR  IDS_PRINTER_STATUS_PAGE_PUNT;
extern LPCWSTR  IDS_PRINTER_STATUS_PAPER_JAM;
extern LPCWSTR  IDS_PRINTER_STATUS_PAPER_OUT;
extern LPCWSTR  IDS_PRINTER_STATUS_PAPER_PROBLEM;
extern LPCWSTR  IDS_PRINTER_STATUS_PAUSED;
extern LPCWSTR  IDS_PRINTER_STATUS_PENDING_DELETION;
extern LPCWSTR  IDS_PRINTER_STATUS_PRINTING;
extern LPCWSTR  IDS_PRINTER_STATUS_PROCESSING;
extern LPCWSTR  IDS_PRINTER_STATUS_TONER_LOW;
extern LPCWSTR  IDS_PRINTER_STATUS_UNAVAILABLE;
extern LPCWSTR  IDS_PRINTER_STATUS_USER_INTERVENTION;
extern LPCWSTR  IDS_PRINTER_STATUS_WAITING;
extern LPCWSTR  IDS_PRINTER_STATUS_WARMING_UP; 

extern LPCWSTR  IDS_DetectedErrorState;
extern LPCWSTR  IDS_Ready;

extern LPCWSTR  IDS_STATUS_OK;
extern LPCWSTR  IDS_STATUS_Degraded;
extern LPCWSTR  IDS_STATUS_Error;
extern LPCWSTR  IDS_STATUS_Unknown;
extern LPCWSTR  IDS_PrinterStatus;

extern LPCWSTR  IDS_PaperSizeSupported;
extern LPCWSTR  IDS_Persistent;
extern LPCWSTR  IDS_Resource_Remembered;

extern LPCWSTR IDS_Device;
extern LPCWSTR  IDS_Current;
extern LPCWSTR  IDS_Resource_Connected;

extern LPCWSTR IDS_LM_Workstation;
extern LPCWSTR IDS_LM_Server;
extern LPCWSTR IDS_SQLServer;
extern LPCWSTR IDS_Domain_Controller;
extern LPCWSTR IDS_Domain_Backup_Controller;
extern LPCWSTR IDS_Timesource;
extern LPCWSTR IDS_AFP;
extern LPCWSTR IDS_Novell;
extern LPCWSTR IDS_Domain_Member;
extern LPCWSTR IDS_Local_List_Only;
extern LPCWSTR IDS_Print;
extern LPCWSTR IDS_DialIn;
extern LPCWSTR IDS_Xenix_Server;
extern LPCWSTR IDS_MFPN;
extern LPCWSTR IDS_NT;
extern LPCWSTR IDS_WFW;
extern LPCWSTR IDS_Server_NT;
extern LPCWSTR IDS_Potential_Browser;
extern LPCWSTR IDS_Backup_Browser;
extern LPCWSTR IDS_Master_Browser;
extern LPCWSTR IDS_Domain_Master;
extern LPCWSTR IDS_Domain_Enum;
extern LPCWSTR IDS_Windows_9x;
extern LPCWSTR IDS_DFS;
extern LPCWSTR IDS_Alias;
extern LPCWSTR IDS_JobStatus;

extern LPCWSTR IDS_UPSName;
extern LPCWSTR IDS_UPSBatteryName;
extern LPCWSTR IDS_BatteryName;

extern LPCWSTR IDS_PNPDeviceID;
extern LPCWSTR IDS_ClassGuid;
extern LPCWSTR IDS_ConfigManagerErrorCode;
extern LPCWSTR IDS_ConfigManagerUserConfig;

extern LPCWSTR IDS_ProcessCreationClassName;
extern LPCWSTR IDS_ProcessHandle;
extern LPCWSTR IDS_ExecutionState;
extern LPCWSTR IDS_PriorityBase;
extern LPCWSTR IDS_StartAddress;
extern LPCWSTR IDS_ThreadState;
extern LPCWSTR IDS_ThreadWaitReason;

extern LPCWSTR IDS_OSAutoDiscovered;
extern LPCWSTR IDS_LogonId;
extern LPCWSTR IDS_AuthenticationPackage;
extern LPCWSTR IDS_LogonType;
extern LPCWSTR IDS_LogonTime;


// Security provider related strings:
extern LPCWSTR IDS_SecuredObject;
extern LPCWSTR IDS_Account;
extern LPCWSTR IDS_AccountName;
extern LPCWSTR IDS_ReferencedDomainName;
extern LPCWSTR IDS_AceType;
extern LPCWSTR IDS_AceFlags;
extern LPCWSTR IDS_AccessMask;
extern LPCWSTR IDS_OwnedObject;
extern LPCWSTR IDS_InheritedObjectGUID;
extern LPCWSTR IDS_ObjectTypeGUID;
extern LPCWSTR IDS_Sid;
extern LPCWSTR IDS_Trustee;
extern LPCWSTR IDS_ControlFlags;
extern LPCWSTR IDS_Group;
extern LPCWSTR IDS_DACL;
extern LPCWSTR IDS_SACL;
extern LPCWSTR IDS_SidLength;
extern LPCWSTR IDS_SecuritySetting;
extern LPCWSTR IDS_BinaryRepresentation;
extern LPCWSTR IDS_Inheritance;
extern LPCWSTR IDS_SIDString;
extern LPCWSTR IDS_OwnerPermissions;
/////////////////////////////////////////////////////////////////////////////////////
//added for ComCatalog classes

extern LPCWSTR IDS_Category ;
extern LPCWSTR IDS_Component ;
extern LPCWSTR IDS_ComponentId ;
extern LPCWSTR IDS_CategoryId ;
extern LPCWSTR IDS_Insertable ;
extern LPCWSTR IDS_JavaClass ;
extern LPCWSTR IDS_InprocServer ;
extern LPCWSTR IDS_InprocServer32 ;
extern LPCWSTR IDS_LocalServer ;
extern LPCWSTR IDS_LocalServer32 ;
extern LPCWSTR IDS_ThreadingModel ;
extern LPCWSTR IDS_InprocHandler ;
extern LPCWSTR IDS_InprocHandler32 ;
extern LPCWSTR IDS_TreatAsClsid ;
extern LPCWSTR IDS_AutoTreatAsClsid ;
extern LPCWSTR IDS_ProgId ;
extern LPCWSTR IDS_VersionIndependentProgId ;
extern LPCWSTR IDS_TypeLibraryId ;
extern LPCWSTR IDS_AppID ;
extern LPCWSTR IDS_UseSurrogate ;
extern LPCWSTR IDS_CustomSurrogate ;
extern LPCWSTR IDS_RemoteServerName ;
extern LPCWSTR IDS_RunAsUser ;
extern LPCWSTR IDS_AuthenticationLevel ;
extern LPCWSTR IDS_LocalService ;
extern LPCWSTR IDS_EnableAtStorageActivation ;
extern LPCWSTR IDS_OldVersion ;
extern LPCWSTR IDS_NewVersion ;
extern LPCWSTR IDS_AutoConvertToClsid ;                 
extern LPCWSTR IDS_DefaultIcon ;
extern LPCWSTR IDS_ToolBoxBitmap32 ;
extern LPCWSTR IDS_ServiceParameters ;                  
extern LPCWSTR IDS_ShortDisplayName ;
extern LPCWSTR IDS_LongDisplayName ;
extern LPCWSTR IDS_Client ;
extern LPCWSTR IDS_Application ;

extern LPCWSTR IDS_Started;
extern LPCWSTR IDS_ProcessId;
extern LPCWSTR IDS_ExitCode;
extern LPCWSTR IDS_ServiceSpecificExitCode;
extern LPCWSTR IDS_CheckPoint;
extern LPCWSTR IDS_WaitHint;
extern LPCWSTR IDS_DesktopInteract;
extern LPCWSTR IDS_StartMode;
extern LPCWSTR IDS_State;

extern LPCWSTR IDS_BlockSize;
extern LPCWSTR IDS_NumberOfBlocks;
extern LPCWSTR IDS_PrimaryPartition;
extern LPCWSTR IDS_Handedness;
extern LPCWSTR IDS_DoubleSpeedThreshold;
extern LPCWSTR IDS_QuadSpeedThreshold;
extern LPCWSTR IDS_PurposeDescription;
extern LPCWSTR IDS_SameElement;
extern LPCWSTR IDS_SystemElement;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\timeddllresource.h ===
//=================================================================

//

// TimedDllResource.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __TIMEDDLLRESOURCE_H__
#define __TIMEDDLLRESOURCE_H__

class CTimedDllResource : public CResource
{
protected:

	BOOL OnFinalRelease() ;
	BOOL OnAcquire () ;

	void RuleEvaluated ( const CRule *a_RuleEvaluated ) ;

public:

	CTimedDllResource() : CResource () {}
	~CTimedDllResource() ;
} ;

#endif //__TIMEDDLLRESOURCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\timeddllresource.cpp ===
//=================================================================

//

// TimedDllResource.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include "ResourceManager.h"
#include "TimerQueue.h"
#include "TimedDllResource.h"
#include "TimeOutRule.h"
#include "ProvExce.h"

#define CACHED_DLL_TIMEOUT	300000
CTimedDllResource::~CTimedDllResource ()
{
	LogMessage ( L"Entering ~CTimedDllResource" ) ;
	if ( m_pRules )
	{
		m_pRules->Detach () ;
		m_pRules->Release () ;
		m_pRules = NULL ;
	}
	LogMessage ( L"Leaving ~CTimedDllResource" ) ;
}

BOOL CTimedDllResource :: OnFinalRelease()
{
	if ( m_pRules )
	{
		m_pRules->Detach () ;
		m_pRules->Release () ;
		m_pRules = NULL ;
		return TRUE ;
	}
	else
	{
/*
 * Add an unload rule
 */
		m_pRules = new CTimeOutRule ( CACHED_DLL_TIMEOUT, this, m_pResources ) ;

		if( !m_pRules )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

		m_pRules->AddRef () ;
/*
 * Up the reference count to wait for the callback to come
 */
		++m_lRef ;
		return FALSE ;
	}
}

BOOL CTimedDllResource :: OnAcquire ()
{
/*
 * somebody tried to acquire us, so we don't want the unload rule hanging around
 */

	if ( m_pRules )
	{
		m_pRules->Detach () ;
		m_pRules->Release () ;
		m_pRules = NULL ;
/*
 * decrement the ref count which we'd added to wait for the callback
 */
		--m_lRef ;
	}

	return TRUE ;
}

void CTimedDllResource :: RuleEvaluated ( const CRule *a_Rule )
{
	if ( m_pRules->CheckRule () )
	{
/*
 * Decrement the Refcount which we'd added to wait for the callback & check if we've to delete ourselves
 */
		Release () ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\timeoutrule.h ===
//=================================================================

//

// TimeOutRule.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================


class CTimeOutRule : public CRule , public CTimerEvent
{
protected:

	CResourceList *m_pResources ;
	BOOL m_bTimeOut ;
	virtual ULONG AddRef () ;
	virtual ULONG Release () ;
	void OnTimer () ;

public:

	CTimeOutRule ( DWORD dwTimeOut, CResource * pResource, CResourceList * pResources ) ;
	~CTimeOutRule  () ;
	
	void Detach () ;
	BOOL CheckRule () ;


//	void Enable () ;
//	void Disable () ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\svrapiapi.cpp ===
//=================================================================

//

// SvrApiApi.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>
#include "SvrApiApi.h"
#include "DllWrapperCreatorReg.h"



// {C77B8EE2-D02A-11d2-911F-0060081A46FD}
static const GUID g_guidSvrApiApi =
{ 0xc77b8ee2, 0xd02a, 0x11d2, { 0x91, 0x1f, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd } };


static const TCHAR g_tstrSvrApi[] = _T("SVRAPI.DLL");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CSvrApiApi, &g_guidSvrApiApi, g_tstrSvrApi> MyRegisteredSvrApiWrapper;


/******************************************************************************
 * Constructor
 ******************************************************************************/
CSvrApiApi::CSvrApiApi(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),

#ifdef NTONLY
	m_pfnNetShareEnumSticky(NULL),
	m_pfnNetShareDelSticky(NULL),
	m_pfnNetShareCheck(NULL),
#endif
	m_pfnNetShareEnum(NULL),
	m_pfnNetShareGetInfo(NULL),
	m_pfnNetServerGetInfo(NULL),
   	m_pfnNetShareSetInfo(NULL),
	m_pfnNetShareAdd(NULL),
	m_pfnNetShareDel(NULL)

{
}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CSvrApiApi::~CSvrApiApi()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CSvrApiApi::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
        m_pfnNetShareEnum = (PFN_SVRAPI_NET_SHARE_ENUM)
                                    GetProcAddress("NetShareEnum");
        m_pfnNetShareGetInfo = (PFN_SVRAPI_NET_SHARE_GET_INFO)
                                    GetProcAddress("NetShareGetInfo");
        m_pfnNetServerGetInfo = (PFN_SVRAPI_NET_SERVER_GET_INFO)
                                    GetProcAddress("NetServerGetInfo");
        m_pfnNetShareSetInfo = (PFN_SVRAPI_NET_SHARE_SET_INFO)
                                    GetProcAddress("NetShareSetInfo");
        m_pfnNetShareAdd = (PFN_SVRAPI_NET_SHARE_ADD)
                                    GetProcAddress("NetShareAdd");
        m_pfnNetShareDel = (PFN_SVRAPI_NET_SHARE_DEL)
                                    GetProcAddress("NetShareDel");
	#ifdef NTONLY
		m_pfnNetShareEnumSticky = (PFN_SVRAPI_NET_SHARE_ENUM_STICKY)
                                    GetProcAddress("NetShareEnumSticky");
		m_pfnNetShareDelSticky = (PFN_SVRAPI_NET_SHARE_DEL_STICKY)
                                    GetProcAddress("NetShareDelSticky");
        m_pfnNetShareCheck = (PFN_SVRAPI_NET_SHARE_CHECK)
                                    GetProcAddress("NetShareCheck");
	#endif

        // All these functions are considered required for all versions of
        // this dll.  Hence return false if didn't get one or more of them.
        if(

	#ifdef NTONLY
            m_pfnNetShareEnumSticky == NULL ||
			m_pfnNetShareDelSticky == NULL ||
			m_pfnNetShareCheck == NULL ||
	#endif
			m_pfnNetShareEnum == NULL ||
			m_pfnNetShareGetInfo == NULL ||
			m_pfnNetServerGetInfo == NULL ||

			m_pfnNetShareSetInfo == NULL ||
			m_pfnNetShareAdd == NULL ||
			m_pfnNetShareDel == NULL )
        {
            fRet = false;
        }
    }
    return fRet;
}




/******************************************************************************
 * Member functions wrapping SvrApi api functions. Add new functions here
 * as required.
 ******************************************************************************/
NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetShareEnum
(
    char FAR *a_servername,
    short a_level,
    char FAR *a_bufptr,
    unsigned short a_prefmaxlen,
    unsigned short FAR *a_entriesread,
    unsigned short FAR *a_totalentries
)
{
    return m_pfnNetShareEnum(a_servername, a_level, a_bufptr, a_prefmaxlen,
                             a_entriesread, a_totalentries);
}

NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetShareGetInfo
(
    char FAR *a_servername,
    char FAR *a_netname,
    short a_level,
    char FAR *a_bufptr,
    unsigned short a_buflen,
    unsigned short FAR *a_totalavail
)
{
    return m_pfnNetShareGetInfo(a_servername, a_netname, a_level,
                                a_bufptr, a_buflen, a_totalavail);
}

NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetServerGetInfo
(
    char FAR *a_servername,
    short a_level,
    char FAR *a_bufptr,
    unsigned short a_buflen,
    unsigned short FAR *a_totalavail
)
{
    return m_pfnNetServerGetInfo(a_servername, a_level, a_bufptr, a_buflen,
                                 a_totalavail);
}

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetShareEnumSticky
(
	LPTSTR      a_servername,
	DWORD       a_level,
	LPBYTE      *a_bufptr,
	DWORD       a_prefmaxlen,
	LPDWORD     a_entriesread,
	LPDWORD     a_totalentries,
	LPDWORD     a_resume_handle
)
{
    return m_pfnNetShareEnumSticky(a_servername, a_level, a_bufptr,
                                   a_prefmaxlen,a_entriesread,
                                   a_totalentries, a_resume_handle);
}
#endif

NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetShareSetInfo
(
	const char FAR *a_servername,
	const char FAR *a_netname,
	short			a_level,
	const char FAR *a_buf,
	unsigned short a_cbBuffer,
	short          a_sParmNum
)
{
    return m_pfnNetShareSetInfo(a_servername, a_netname, a_level,
                                a_buf, a_cbBuffer, a_sParmNum);
}

NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetShareAdd
(
	const char FAR *a_servername,
	short			a_level,
	const char FAR *a_buf,
	unsigned short	a_cbBuffer
)
{
    return m_pfnNetShareAdd(a_servername, a_level, a_buf , a_cbBuffer);
}

NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetShareDel
(
	LPTSTR  a_servername,
	LPTSTR  a_netname,
	DWORD   a_reserved
)
{
    return m_pfnNetShareDel(a_servername, a_netname, a_reserved);
}

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetShareDelSticky
(
	LPTSTR  a_servername,
	LPTSTR  a_netname,
	DWORD   a_reserved
)
{
    return m_pfnNetShareDelSticky(a_servername, a_netname, a_reserved);
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetShareCheck
(
	LPTSTR  a_servername,
	LPTSTR  a_device,
	LPDWORD a_type
)
{
    return m_pfnNetShareCheck(a_servername, a_device, a_type);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\timeoutrule.cpp ===
//=================================================================

//

// TimeOutRule.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include "ResourceManager.h"
#include "TimerQueue.h"
#include "TimeOutRule.h"

CTimeOutRule :: CTimeOutRule (

	DWORD dwTimeOut,
	CResource *pResource,
	CResourceList *pResources

) : CRule ( pResource ) ,
	CTimerEvent ( dwTimeOut , FALSE )
{
	m_pResources = pResources ;
	m_bTimeOut = FALSE ;

	this->Enable () ;
}

CTimeOutRule :: ~CTimeOutRule  ()
{
}

void CTimeOutRule :: Detach ()
{
	CRule :: Detach () ;
	Disable () ;
}

BOOL CTimeOutRule :: CheckRule ()
{
	if ( m_bTimeOut )
	{
		m_bTimeOut = FALSE ;
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

void CTimeOutRule :: OnTimer ()
{
	CRule::AddRef () ;

	try
	{
		if ( m_pResource )
		{
	/*
	 * check if the cache manager is being unloaded
	 */
			if ( ! m_pResources->m_bShutDown )
			{
	/*
	 * wait for a lock on res. list
	 */
				CResourceListAutoLock cs ( m_pResources ) ;
	/*
	 * check if the cache manager is being unloaded
	 */
				if ( ! m_pResources->m_bShutDown )
				{
					if ( m_pResource )
					{
						m_bTimeOut = TRUE ;
						m_pResource->RuleEvaluated ( this ) ;
					}
				}
			}
		}
	}
	catch( ... )
	{
		CRule::Release () ;
		throw ;
	}

	CRule::Release () ;
}

ULONG CTimeOutRule :: AddRef ()
{
	return CRule::AddRef () ;
}

ULONG CTimeOutRule :: Release ()
{
	return CRule::Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\svrapiapi.h ===
//=================================================================

//

// SvrApiApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_SVRAPIAPI_H_
#define	_SVRAPIAPI_H_


#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmserver.h>
#include <lmerr.h>
#include <ntsecapi.h>
#include <stack>
#include <comdef.h>
#include <dsrole.h> 
#include <dsgetdc.h>



/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "DllWrapperBase.h"

extern const GUID g_guidSvrApiApi;
extern const TCHAR g_tstrSvrApi[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SHARE_ENUM)
(
    char FAR *servername,
    short level,
    char FAR *bufptr,
    unsigned short prefmaxlen,
    unsigned short FAR *entriesread,
    unsigned short FAR *totalentries
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SHARE_GET_INFO)
(
    char FAR *servername,
    char FAR *netname,
    short level,
    char FAR *bufptr,
    unsigned short buflen,
    unsigned short FAR *totalavail
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SERVER_GET_INFO)
(
    char FAR *servername,
    short level,
    char FAR *bufptr,
    unsigned short buflen,
    unsigned short FAR *totalavail
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SHARE_ENUM_STICKY) 
(
	IN  LPTSTR      servername,
	IN  DWORD       level,
	OUT LPBYTE      *bufptr,
	IN  DWORD       prefmaxlen,
	OUT LPDWORD     entriesread,
	OUT LPDWORD     totalentries,
	IN OUT LPDWORD  resume_handle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SHARE_SET_INFO) 
(
	IN const char FAR *	servername,
	IN const char FAR *	netname,
	IN short			level,
	IN const char FAR*	buf,
	IN unsigned short   cbBuffer,
	IN short            sParmNum 
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SHARE_ADD) 
(
	IN  const char FAR *	servername,
	IN  short				level,
	IN  const char FAR *	buf,
	unsigned short			cbBuffer 
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SHARE_DEL) 
(
	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   reserved
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SHARE_DEL_STICKY) 
(
	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   reserved
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SHARE_CHECK) 
(
	IN  LPTSTR  servername,
	IN  LPTSTR  device,
	OUT LPDWORD type
);


/******************************************************************************
 * Wrapper class for Kernel32 load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CSvrApiApi : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to kernel32 functions.
    // Add new functions here as required.
	PFN_SVRAPI_NET_SHARE_ENUM        m_pfnNetShareEnum;
    PFN_SVRAPI_NET_SHARE_GET_INFO    m_pfnNetShareGetInfo;
    PFN_SVRAPI_NET_SERVER_GET_INFO   m_pfnNetServerGetInfo;
    
    PFN_SVRAPI_NET_SHARE_SET_INFO    m_pfnNetShareSetInfo;
    PFN_SVRAPI_NET_SHARE_ADD         m_pfnNetShareAdd;
    PFN_SVRAPI_NET_SHARE_DEL         m_pfnNetShareDel;

#ifdef NTONLY 
	PFN_SVRAPI_NET_SHARE_ENUM_STICKY m_pfnNetShareEnumSticky;
	PFN_SVRAPI_NET_SHARE_DEL_STICKY  m_pfnNetShareDelSticky;
    PFN_SVRAPI_NET_SHARE_CHECK       m_pfnNetShareCheck;
#endif



public:

    // Constructor and destructor:
    CSvrApiApi(LPCTSTR a_tstrWrappedDllName);
    ~CSvrApiApi();

    // Inherrited initialization function.
    virtual bool Init();

    // Member functions wrapping kernel32 functions.
    // Add new functions here as required:
    NET_API_STATUS NET_API_FUNCTION NetShareEnum
    (
        char FAR *a_servername,
        short a_level,
        char FAR *a_bufptr,
        unsigned short a_prefmaxlen,
        unsigned short FAR *a_entriesread,
        unsigned short FAR *a_totalentries
    );

    NET_API_STATUS NET_API_FUNCTION NetShareGetInfo
    (
        char FAR *a_servername,
        char FAR *a_netname,
        short a_level,
        char FAR *a_bufptr,
        unsigned short a_buflen,
        unsigned short FAR *a_totalavail
    );

    NET_API_STATUS NET_API_FUNCTION NetServerGetInfo
    (
        char FAR *a_servername,
        short a_level,
        char FAR *a_bufptr,
        unsigned short a_buflen,
        unsigned short FAR *a_totalavail
    );

 
    NET_API_STATUS NET_API_FUNCTION NetShareSetInfo 
    (
	    const char FAR *a_servername,
	    const char FAR *a_netname,
	    short			a_level,
	    const char FAR *a_buf,
	    unsigned short a_cbBuffer,
	    short          a_sParmNum 
    );

    NET_API_STATUS NET_API_FUNCTION NetShareAdd 
    (
	    const char FAR *a_servername,
	    short			a_level,
	    const char FAR *a_buf,
	    unsigned short	a_cbBuffer 
    );

    NET_API_STATUS NET_API_FUNCTION NetShareDel 
    (
	    LPTSTR  a_servername,
	    LPTSTR  a_netname,
	    DWORD   a_reserved
    );

#ifdef NTONLY 

   NET_API_STATUS NET_API_FUNCTION NetShareEnumSticky 
    (
	    LPTSTR      a_servername,
	    DWORD       a_level,
	    LPBYTE      *a_bufptr,
	    DWORD       a_prefmaxlen,
	    LPDWORD     a_entriesread,
	    LPDWORD     a_totalentries,
	    LPDWORD     a_resume_handle
    );


    NET_API_STATUS NET_API_FUNCTION NetShareDelSticky 
    (
	    LPTSTR  a_servername,
	    LPTSTR  a_netname,
	    DWORD   a_reserved
    );

    NET_API_STATUS NET_API_FUNCTION NetShareCheck 
    (
	    LPTSTR  a_servername,
	    LPTSTR  a_device,
	    LPDWORD a_type
    );
#endif

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\timerqueue.cpp ===
//=================================================================

//

// TimerQueue.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include <time.h>
#include "TimerQueue.h"
#include <cautolock.h>

CTimerEvent :: CTimerEvent (

	DWORD dwTimeOut,
	BOOL fRepeat

) : m_dwMilliseconds ( dwTimeOut ) ,
	m_bRepeating ( fRepeat )
{
	m_bEnabled = FALSE ;
/*	if ( a_Enable )
	{
		Enable ();
	}
*/
}

CTimerEvent :: CTimerEvent (

	const CTimerEvent &rTimerEvent

) : //m_bEnabled ( rTimerEvent.m_bEnabled ) ,
	m_dwMilliseconds ( rTimerEvent.m_dwMilliseconds ) ,
	m_bRepeating ( rTimerEvent.m_bRepeating )
{
//	if ( m_bEnabled )
//	{
//		Enable () ;
//	}
//	if ( m_Rule )
//		m_Rule->AddRef () ;
}

void CTimerEvent :: Enable ()
{
	// we might not be able to enable timer
	m_bEnabled = CTimerQueue :: s_TimerQueue.QueueTimer ( this ) ;
}

void CTimerEvent :: Disable ()
{
	// enabled is oposite of returned
	m_bEnabled = !( CTimerQueue :: s_TimerQueue.DeQueueTimer ( this ) );
}

BOOL CTimerEvent :: Enabled ()
{
	return m_bEnabled ;
}

BOOL CTimerEvent :: Repeating ()
{
	return m_bRepeating ;
}

DWORD CTimerEvent :: GetMilliSeconds ()
{
	return m_dwMilliseconds ;
}
/*
CRuleTimerEvent :: CRuleTimerEvent (

	CRule *a_Rule ,
	BOOL a_Enable ,
	DWORD dwTimeOut,
	BOOL fRepeat ,
	BOOL bMarkedForDequeue

) : CTimerEvent ( a_Enable , dwTimeOut , fRepeat, bMarkedForDequeue ) ,
	m_Rule ( a_Rule )
{
	if ( m_Rule )
	{
		m_Rule->AddRef () ;
	}
}

CRuleTimerEvent :: CRuleTimerEvent (

	const CRuleTimerEvent &rTimerEvent

) : CTimerEvent ( rTimerEvent ) ,
	m_Rule ( rTimerEvent.m_Rule )
{
	if ( m_Rule )
	{
		m_Rule->AddRef () ;
	}
}

CRuleTimerEvent :: ~CRuleTimerEvent ()
{
	if ( m_Rule )
	{
		m_Rule->Release () ;
	}
}
*/
// CTimerQueue construction creates the worker thread and a event handle
CTimerQueue::CTimerQueue() : m_hInitEvent(NULL)
{
	m_fShutDown = FALSE;
	m_bInit = FALSE;

	m_hScheduleEvent = NULL;
    // Scheduler thread
	m_hSchedulerHandle = NULL;

	// when this event has not created there is very very small possibility of
	// having crash when shutdown is in progress and we step into init function
	m_hInitEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
}

void CTimerQueue::Init()
{
	// every thread may try to get it initialized couple times
	DWORD dwTry = 0L;

	EnterCriticalSection ( &m_oCS );

	while ( !m_bInit && dwTry < 3 )
	{
		if (m_fShutDown)
		{
			LeaveCriticalSection ( &m_oCS );

			if ( m_hInitEvent )
			{
				WaitForSingleObjectEx ( m_hInitEvent, INFINITE, FALSE );
			}

			EnterCriticalSection ( &m_oCS );
		}
		else
		{
			try
			{
				if ( ! m_hScheduleEvent )
				{
					m_hScheduleEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
				}

				if ( m_hScheduleEvent )
				{
					if ( ! m_hSchedulerHandle )
					{
						// Scheduler thread
						LogMessage ( L"CreateThread for Scheduler called" );
						m_hSchedulerHandle = CreateThread(
										  NULL,						// pointer to security attributes
										  0L,						// initial thread stack size
										  dwThreadProc,				// pointer to thread function
										  this,						// argument for new thread
										  0L,						// creation flags
										  &m_dwThreadID);
					}

					if ( m_hSchedulerHandle )
					{
						m_bInit = TRUE;
					}
				}

				dwTry++;
			}
			catch(...)
			{
				// not much we can do in here

				if( m_hSchedulerHandle )
				{
					CloseHandle( m_hSchedulerHandle );
					m_hSchedulerHandle = NULL;
				}

				if( m_hScheduleEvent )
				{
					CloseHandle( m_hScheduleEvent );
					m_hScheduleEvent = NULL;
				}

				LeaveCriticalSection ( &m_oCS );
				throw;
			}
		}
	}

	LeaveCriticalSection ( &m_oCS );
}

//
CTimerQueue::~CTimerQueue()
{
	LogMessage ( L"Entering ~CTimerQueue" ) ;

	if (m_hInitEvent)
	{
		CloseHandle(m_hInitEvent);
		m_hInitEvent = NULL;
	}
	
	LogMessage ( L"Leaving ~CTimerQueue" ) ;
}

// worker thread pump
DWORD WINAPI CTimerQueue::dwThreadProc( LPVOID lpParameter )
{
	CTimerQueue* pThis = (CTimerQueue*)lpParameter;

	BOOL bTerminateShutdown = FALSE;

	try
	{
		while( !bTerminateShutdown )
		{
			DWORD dwWaitResult = WAIT_OBJECT_0;
			dwWaitResult = WaitForSingleObjectEx( pThis->m_hScheduleEvent, pThis->dwProcessSchedule(), 0L );

			switch ( dwWaitResult )
			{
				case WAIT_OBJECT_0:
				{
					if( pThis->ShutDown() )
					{
						bTerminateShutdown = TRUE;
						LogMessage ( L"Scheduler thread exiting" ) ;
					}
				}
				break;

				case WAIT_ABANDONED:
				{
					// we are probably not initialized properly
					bTerminateShutdown = TRUE;
				}
				break;
			}
		}
	}
	catch(...)
	{
	}

	return bTerminateShutdown;
}

// signals for a pump cycle, checking the updated queue
void CTimerQueue::vUpdateScheduler()
{
	SetEvent ( m_hScheduleEvent );
}

// Public function: Queues a timer entry for a scheduled callback
BOOL CTimerQueue::QueueTimer( CTimerEvent* pTimerEvent )
{
	BOOL fRc = FALSE;
/*
 * Init the scheduler thread if it's not there . The thread should not be created if we're
 * in the middle of shutdown as this may cause a deadlock if one resource caches another resource pointer.
 */
	CAutoLock cal(m_oCS);
	if ( !m_fShutDown )
	{
		if( !m_bInit )
		{
			Init() ;
		}
		if( m_bInit )
		{
			fRc = fScheduleEvent( pTimerEvent );
		}
	}
	
	return fRc;
}

// Public function: Dequeues a timer event
BOOL CTimerQueue::DeQueueTimer( CTimerEvent* pTimerEvent )
{
	BOOL fRemoved = FALSE;
	CTimerEvent* pTE = pTimerEvent;

	//scope of critsec locked
	{
		CAutoLock cal(m_oCS);
		Timer_Ptr_Queue::iterator pQueueElement;

		for( pQueueElement  = m_oTimerQueue.begin();
			 pQueueElement != m_oTimerQueue.end();
			 pQueueElement++)	{

			if(pTE == *pQueueElement)
			{
				m_oTimerQueue.erase( pQueueElement );
				pTE->Release ();
				fRemoved = TRUE;
				break ;
			}
		}
	}

	if( fRemoved )
	{
		vUpdateScheduler();
	}

	return fRemoved;
}

//
BOOL CTimerQueue::fScheduleEvent( CTimerEvent* pNewTE )
{
	// system clock offset
	pNewTE->int64Time = int64Clock() + pNewTE->GetMilliSeconds () ;

	// slot the event into the ordered list, scope for CS
	{
		CAutoLock cal(m_oCS);
		BOOL fInserted = FALSE;

		Timer_Ptr_Queue::iterator pQueueElement;

		for( pQueueElement  = m_oTimerQueue.begin();
			 pQueueElement != m_oTimerQueue.end();
			 pQueueElement++)	{

			if( pNewTE->int64Time < (*pQueueElement)->int64Time )
			{
				m_oTimerQueue.insert( pQueueElement, pNewTE );
				fInserted = TRUE;
				pNewTE->AddRef () ;
				break;
			}
		}
		if( !fInserted )
		{
			m_oTimerQueue.push_back( pNewTE );
			pNewTE->AddRef () ;
		}
	}

	vUpdateScheduler();

	return TRUE;
}

// This work is done on the Scheduler thread
DWORD CTimerQueue::dwProcessSchedule()
{
	CTimerEvent* pTE;
	LogMessage ( L"Entering CTimerQueue::dwProcessSchedule" ) ;

	while( pTE = pGetNextTimerEvent() )
	{
		// process the request
		LogMessage ( L"CTimerEvent::OnTimer called" ) ;
		pTE->OnTimer () ;
		LogMessage ( L"CTimerEvent::OnTimer returned" ) ;

		// reschedule a repeatable event
		if( pTE->Repeating() && pTE->Enabled() && fScheduleEvent( pTE ) )
		{
		}

		pTE->Release () ;
	}

	return dwNextTimerEvent();
}

// returns the time for the next scheduled event in milliseconds
DWORD CTimerQueue::dwNextTimerEvent()
{
	DWORD dwNextEvent = INFINITE;

	//scope of CS
	{
		CAutoLock cal(m_oCS);

		if( m_fShutDown )
		{
			return 0;
		}

		if( !m_oTimerQueue.empty() )
		{
			CTimerEvent* pTE = m_oTimerQueue.front();
			dwNextEvent = max((DWORD)(pTE->int64Time - int64Clock()), 0);
		}
	}

	LogMessage ( L"Leaving CTimerQueue::dwNextTimerEvent" ) ;
	return dwNextEvent;
}

// Returns the next scheduled and ready timer event (from an ordered list) or NULL
CTimerEvent* CTimerQueue::pGetNextTimerEvent()
{
	CAutoLock cal(m_oCS);

	if( m_fShutDown )
	{
		return NULL;
	}

	CTimerEvent* pTE = NULL;

	if( !m_oTimerQueue.empty() )
	{
		pTE = m_oTimerQueue.front();

		if( int64Clock() >= pTE->int64Time )
			m_oTimerQueue.pop_front();
		else
			pTE = NULL;
	}

	return pTE;
}

BOOL CTimerQueue::ShutDown()
{
	CAutoLock cal(m_oCS);
	BOOL retVal = m_fShutDown;
	return retVal;
}

//
void CTimerQueue::OnShutDown()
{
	LogMessage ( L"Entering CTimerQueue::OnShutDown" ) ;
	EnterCriticalSection(&m_oCS);

	if( m_bInit )
	{
		if ( m_hInitEvent )
		{
			ResetEvent ( m_hInitEvent );
		}

		m_fShutDown = TRUE;
		m_bInit = FALSE;

		// unguarded section ---
		// No TimerQueue global is modified in this frame block.
		//
		// To avoid a deadlock we unnest this CS from the
		// embedded CResourceList mutex accessed through
		// vEmptyList(). This avoids the situation where a
		// a normal resource request locks the list then locking
		// the TimerQueue to schedule a timed resource release.
		//
		LeaveCriticalSection(&m_oCS);
		{
			if ( m_hSchedulerHandle )
			{
				DWORD t_dwExitCode = 0 ;
				BOOL t_bRet = GetExitCodeThread (	m_hSchedulerHandle,	// handle to the thread
													&t_dwExitCode		// address to receive termination status
												);
				/*
				 * If the worker thread has not exited , we've to wait till it exits
				 */
				if ( t_bRet && t_dwExitCode == STILL_ACTIVE )
				{
/*
					//error logging starts here...delete this after finding the cause of shutdown crash
					CHString chsMsg ;
					chsMsg.Format ( L"Threadid=%x ThreadHandle = %x", GetCurrentThreadId (), GetCurrentThread () ) ;
					LogMessage ( CHString ( "TimerQueue Current Thread: " ) +chsMsg ) ;
					chsMsg.Format ( L"Threadid=%x ThreadHandle = %x", m_dwThreadID, m_hSchedulerHandle ) ;
					LogMessage ( CHString ( "TimerQueue Waiting on Thread: " ) +chsMsg ) ;
					//error logging stops here
*/
					vUpdateScheduler();

					// wait for the Scheduler thread handle itself
					WaitForSingleObjectEx( m_hSchedulerHandle, INFINITE, 0L );
				}

				vEmptyList() ;
			}
		}
		EnterCriticalSection(&m_oCS);

		if( m_hSchedulerHandle )
		{
			CloseHandle( m_hSchedulerHandle );
			m_hSchedulerHandle = NULL;
		}

		if( m_hScheduleEvent )
		{
			CloseHandle( m_hScheduleEvent );
			m_hScheduleEvent = NULL;
		}

		m_fShutDown = FALSE;

		if ( m_hInitEvent )
		{
			SetEvent(m_hInitEvent);
		}
	}

	LeaveCriticalSection(&m_oCS);
	LogMessage ( L"Leaving CTimerQueue::OnShutDown" ) ;
}

//
void CTimerQueue::vEmptyList()
{
	EnterCriticalSection(&m_oCS);
	BOOL t_fCS = TRUE ;

	{
		try
		{
			while(!m_oTimerQueue.empty())
			{
				CTimerEvent* pTE = m_oTimerQueue.front() ;
				m_oTimerQueue.pop_front();

				LeaveCriticalSection(&m_oCS);
				t_fCS = FALSE ;

				LogMessage ( L"CTimerQueue::vEmptyList--->CTimerEvent::OnTimer called" ) ;
				pTE->OnTimer () ;

				LogMessage ( L"CTimerQueue::vEmptyList--->CTimerEvent::OnTimer returned" ) ;
				pTE->Release();

				EnterCriticalSection(&m_oCS);
				t_fCS = TRUE ;
			}
		}
		catch( ... )
		{
			if( t_fCS )
			{
				LeaveCriticalSection(&m_oCS);
			}
			throw ;
		}
	}
	LeaveCriticalSection(&m_oCS);
}

__int64 CTimerQueue::int64Clock()
{
	FILETIME t_FileTime ;
	__int64 t_i64Tmp ;

	GetSystemTimeAsFileTime ( &t_FileTime ) ;
	t_i64Tmp = t_FileTime.dwHighDateTime ;
	t_i64Tmp = ( t_i64Tmp << 32 ) | t_FileTime.dwLowDateTime ;
/*
 * Convert the FILETIME ( in units of 100 ns ) into milliseconds
 */
	return t_i64Tmp / 10000 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\timerqueue.h ===
//=================================================================

//

// TimerQueue.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include <windows.h>
#include <deque>

class CTimerEvent
{
public:

	CTimerEvent () : m_bEnabled ( FALSE ) , m_dwMilliseconds ( 1000 ) , m_bRepeating ( FALSE ) {} ;

	CTimerEvent ( DWORD dwTimeOut, BOOL fRepeat ) ;
	CTimerEvent ( const CTimerEvent &rTimerEvent ) ;

	virtual ~CTimerEvent () {} ;	

	virtual void OnTimer () {} ;

	virtual ULONG AddRef () = 0 ; 
	virtual ULONG Release () = 0 ; 

	DWORD GetMilliSeconds () ;
	BOOL Repeating () ;
	BOOL Enabled () ;

	__int64		int64Time;						// Scheduled callback as an offset of the system clock. 
protected:

	BOOL		m_bEnabled ;
	DWORD	 	m_dwMilliseconds;				// Scheduled callback time in milliseconds
	BOOL		m_bRepeating;					// indicates a one shot or repeating callback 


	void Disable () ;
	void Enable () ;

};
/*
class CRuleTimerEvent : public CTimerEvent
{
protected:

	CRule *m_pRule ;			// argument for the timed callback

protected:

	CRuleTimerEvent ( CRule *a_Rule ) : m_Rule ( a_Rule ) { if ( m_Rule ) m_Rule->AddRef () } ;

	CRuleTimerEvent ( CRule *a_Rule , BOOL a_Enable , DWORD dwTimeOut, BOOL fRepeat ) ;
	CRuleTimerEvent ( const CRuleTimerEvent &rTimerEvent ) ;

public:

	~CRuleTimerEvent () {} ;	

	CRule *GetRule () ;
} ;
*/
class CTimerQueue
{
public:

	static CTimerQueue s_TimerQueue ;

public:

		CTimerQueue();
		~CTimerQueue();

		void OnShutDown();
		void Init();
		
		BOOL QueueTimer( CTimerEvent *pTimerEntry );
		BOOL DeQueueTimer( CTimerEvent *pTimerEntry );

protected:

	void	vUpdateScheduler();
	__int64 int64Clock(); // System clock in milliseconds
	
	// pure virtual
//	virtual DWORD OnTimer( const CTimerEntry *pTimerEntry ) = 0;

private:

	DWORD	m_dwThreadID; 
	HANDLE	m_hSchedulerHandle;
	HANDLE	m_hScheduleEvent;
	HANDLE	m_hInitEvent;
	BOOL	m_bInit;
	BOOL	m_fShutDown;

	CStaticCritSec m_oCS;
	
	typedef std::deque<CTimerEvent*>  Timer_Ptr_Queue;
	Timer_Ptr_Queue m_oTimerQueue;

private:

	static DWORD WINAPI dwThreadProc( LPVOID lpParameter );

	BOOL			fScheduleEvent( CTimerEvent* pTimerEvent );

	CTimerEvent*	pGetNextTimerEvent();
	DWORD			dwProcessSchedule();
	DWORD			dwNextTimerEvent();	
	
	void vEmptyList();
	BOOL ShutDown();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\tokenprivilege.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*
 *	CTokenPrivilege.h - header file for CTokenPrivilege class
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CTOKENPRIVILEGE_H__
#define __CTOKENPRIVILEGE_H__

////////////////////////////////////////////////////////////////
//
//	Class:	CTokenPrivilege
//
//	This class is intended to provide a wrapper for basic
//	Windows NT token privilege enabling/disabling.  In order
//	to perform certain operations on a Windows NT box, it is
//	often necessary to not only have certain privileges, but
//	to turn those privileges on and off as needed (as certain
//	privileges may be available but not enabled by default).
//	The class needs an access token to work correctly.  A
//	user can either pass us one, or we will try to obtain one.
//	First, we try to open a thread token (set by Impersonation),
//	and if that fails, then we attempt to get the process
//	level token.
//
////////////////////////////////////////////////////////////////


class CTokenPrivilege
{
	// Constructors and destructor
	public:
		CTokenPrivilege( LPCTSTR pszPrivilegeName, HANDLE hAccessToken = INVALID_HANDLE_VALUE, LPCTSTR pszSystemName = NULL );
		~CTokenPrivilege( void );

		void	GetPrivilegeName( CHString& strPrivilegeName );
		DWORD	GetPrivilegeDisplayName( CHString& strDisplayName, LPDWORD pdwLanguageId );
		DWORD	Enable( bool fEnable = TRUE );

	// Private data members
	private:
		CHString			m_strPrivilegeName;
		CHString			m_strSystemName;
		HANDLE			m_hAccessToken;
		bool			m_fClearToken;
		LUID			m_luid;

};

inline void CTokenPrivilege::GetPrivilegeName( CHString& strPrivilegeName )
{
	m_strPrivilegeName = strPrivilegeName;
}

#endif // __CTokenPrivilege_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\tokenprivilege.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*
 *	CTokenPrivilege.cpp - implementation file for CTokenPrivilege class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#include "precomp.h"
#include "TokenPrivilege.h"

///////////////////////////////////////////////////////////////////
//
//	Function:	CTokenPrivilege::CTokenPrivilege
//
//	Class constructor.
//
//	Inputs:
//				LPCTSTR		pszPrivilegeName - The name of the privilege
//							this instance will be responsible for.
//				HANDLE		hAccessToken - User supplied access token.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
//	If the user does NOT supply an access token, we try to open
//	a thread token, and if that fails, then the process token.
//
///////////////////////////////////////////////////////////////////

CTokenPrivilege::CTokenPrivilege( LPCTSTR pszPrivilegeName, HANDLE hAccessToken /*=INVALID_HANDLE_VALUE*/, LPCTSTR pszSystemName /*=NULL*/ )
:	m_strPrivilegeName( pszPrivilegeName ),
	m_strSystemName( pszSystemName ),
	m_hAccessToken( NULL ),
	m_fClearToken( FALSE )
{

	// If we weren't passed in a valid handle, open the current process token, acknowledging
	// that if we do so, we must also clear the token if we opened it.

	DWORD dwError = ERROR_SUCCESS;

	if ( INVALID_HANDLE_VALUE == hAccessToken )
	{
		// First try to get a thread token.  If this fails because there is no token,
		// then grab the process token.

		if ( OpenThreadToken( GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, FALSE, &m_hAccessToken ) )
		{
			m_fClearToken = TRUE;
		}
		else
		{
			if ( ( dwError = ::GetLastError() ) == ERROR_NO_TOKEN )
			{
				if ( OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &m_hAccessToken ) )
				{
					m_fClearToken = TRUE;
				}
			}
		}
	}
	else
	{
		m_hAccessToken = hAccessToken;
	}

	// Now, get the LUID for the privilege from the local system
	ZeroMemory( &m_luid, sizeof(m_luid) );

	{
		LookupPrivilegeValue( pszSystemName, pszPrivilegeName, &m_luid );
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CTokenPrivilege::~CTokenPrivilege
//
//	Class destructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
//	Cleans up our token only if we Opened it ourselves.
//
///////////////////////////////////////////////////////////////////

CTokenPrivilege::~CTokenPrivilege( void )
{
	if ( m_fClearToken )
	{
		CloseHandle( m_hAccessToken );
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CTokenPrivilege::GetPrivilegeDisplayName
//
//	Returns a Human readable name for the the token privilege the
//	class is handling.
//
//	Inputs:
//				None.
//
//	Outputs:
//				CHString&		strDisplayName - Display name.
//				LPDWORD			pdwLanguageId - Language Id of the
//								display name.
//
//	Returns:
//				DWORD			ERROR_SUCCESS if successful.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CTokenPrivilege::GetPrivilegeDisplayName( CHString& strDisplayName, LPDWORD pdwLanguageId )
{
	DWORD	dwError				=	ERROR_SUCCESS;
	DWORD	dwDisplayNameSize	=	0;

	// First, find out how big the buffer in strDisplayName needs to be
	LookupPrivilegeDisplayNameW(	( m_strSystemName.IsEmpty() ? NULL : (LPCWSTR) m_strSystemName ),
								m_strPrivilegeName,
								NULL,
								&dwDisplayNameSize,
								pdwLanguageId );

	{
		if ( !LookupPrivilegeDisplayNameW(	( m_strSystemName.IsEmpty() ? NULL : (LPCWSTR) m_strSystemName ),
											m_strPrivilegeName,
											strDisplayName.GetBuffer( dwDisplayNameSize + 1 ),
											&dwDisplayNameSize,
											pdwLanguageId ) )
		{
			dwError = ::GetLastError();
		}
	}

	strDisplayName.ReleaseBuffer();

	return dwError;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CTokenPrivilege::Enable
//
//	Attempts to enable/disable the privilege we are managing, in
//	our token data member.
//
//	Inputs:
//				BOOL			fEnable - Enable/Disable flag.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD			ERROR_SUCCESS if successful.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CTokenPrivilege::Enable( bool fEnable/*=TRUE*/ )
{
	DWORD				dwError = ERROR_SUCCESS;
	TOKEN_PRIVILEGES	tokenPrivileges;

	tokenPrivileges.PrivilegeCount = 1;
	tokenPrivileges.Privileges[0].Luid = m_luid;
	tokenPrivileges.Privileges[0].Attributes = ( fEnable ? SE_PRIVILEGE_ENABLED : 0 );

	{
		AdjustTokenPrivileges(m_hAccessToken, FALSE, &tokenPrivileges, 0, NULL, NULL);
        dwError = ::GetLastError();
	}

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\userenvapi.h ===
//=================================================================

//

// UserEnvApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_UserEnvAPI_H_
#define	_UserEnvAPI_H_

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "DllWrapperBase.h"

extern const GUID g_guidUserEnvApi;
extern const TCHAR g_tstrUserEnv[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/
typedef BOOL (WINAPI *PFN_UserEnv_GET_DISK_FREE_SPACE_EX)
(
	LPCTSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
);

typedef BOOL ( WINAPI *PFN_UserEnv_CREATEENVIRONMENTBLOCK )
(
	OUT LPVOID *lpEnvironment,
	IN HANDLE hToken,
	IN BOOL bInherit
);

typedef BOOL ( WINAPI *PFN_UserEnv_DESTROYENVIRONMENTBLOCK )
(
	IN LPVOID lpEnvironment
);

/******************************************************************************
 * Wrapper class for UserEnv load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class __declspec(uuid("3CA401C6-D477-11d2-B35E-00104BC97924")) CUserEnvApi : public CDllWrapperBase
{
private:

    // Member variables (function pointers) pointing to UserEnv functions.
    // Add new functions here as required.

	PFN_UserEnv_DESTROYENVIRONMENTBLOCK m_pfnDestroyEnvironmentBlock ;
	PFN_UserEnv_CREATEENVIRONMENTBLOCK m_pfnCreateEnvironmentBlock ;

public:

    // Constructor and destructor:
    CUserEnvApi ( LPCTSTR a_tstrWrappedDllName ) ;
    ~CUserEnvApi () ;

    // Inherrited initialization function.

    virtual bool Init();

    // Member functions wrapping UserEnv functions.
    // Add new functions here as required:

	BOOL CreateEnvironmentBlock (

		OUT LPVOID *lpEnvironment,
		IN HANDLE hToken,
		IN BOOL bInherit
	);

	BOOL DestroyEnvironmentBlock (

		IN LPVOID lpEnvironment
	);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\userhive.h ===
//============================================================

//

// UserHive.h - Class to load/unload specified user's profile

//              hive from registry

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 01/03/97     a-jmoon     created
//
//============================================================

#ifndef __USERHIVE_INC__
#define __USERHIVE_INC__

class CRegistry;

class CUserHive
{
    public:
    
        CUserHive() ;
       ~CUserHive() ;

        DWORD Load(LPCWSTR pszUserName, LPWSTR pszKeyName, size_t PATHSIZE) ;
        DWORD LoadProfile( LPCWSTR pszProfile, CHString& strUserName );
        DWORD Unload(LPCWSTR pszKeyName) ;
        DWORD UserAccountFromProfile( CRegistry& reg, CHString& strUserName );

    private:

        OSVERSIONINFO    OSInfo ;
        TOKEN_PRIVILEGES* m_pOriginalPriv ;
        HKEY m_hKey;
        DWORD m_dwSize;
		
#ifdef NTONLY
		DWORD LoadNT(LPCWSTR pszUserName, LPWSTR pszKeyName, size_t PATHSIZE);
        DWORD AcquirePrivilege() ;
        void  RestorePrivilege() ;
#endif
#ifdef WIN9XONLY
		DWORD Load95(LPCWSTR pszUserName, LPWSTR pszKeyName);
#endif

		// using threadbase - that way we don't have to jump through any hoops
		// to make sure that the global critical section is initialized properly
		// this is mostly to serialize access to the NT User.dat file.
		static CThreadBase m_criticalSection;
} ;

#endif // file inclusion
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\userhive.cpp ===
//============================================================

//

// UserHive.cpp - Class to load/unload specified user's profile

//                hive from registry

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 01/03/97     a-jmoon     created
//
//============================================================

#include "precomp.h"
#include <assertbreak.h>
#include <cregcls.h>
#include "sid.h"
#include "UserHive.h"
#include <cominit.h>
#include <strsafe.h>

#pragma warning(disable : 4995) // we introduced as including strsafe.h gives error for all unsafe string functions

CThreadBase CUserHive::m_criticalSection;

/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::CUserHive
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CUserHive::CUserHive()
{
    OSInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO) ;
    GetVersionEx(&OSInfo) ;
	m_pOriginalPriv = NULL;
    m_dwSize = NULL;
    m_hKey = NULL;
}

/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::~CUserHive
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CUserHive::~CUserHive()
{
#ifdef NTONLY
	if (m_pOriginalPriv)
		RestorePrivilege();
#endif

    // NOTE: The destructor does not unload the key.  Nor does doing a load unload
    // a previously loaded key;
    ASSERT_BREAK(m_hKey == NULL);

    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::AcquirePrivilege
 *
 *  DESCRIPTION : Acquires SeRestorePrivilege for calling thread
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
DWORD CUserHive::AcquirePrivilege()
{
	// are you calling in twice?  Shouldn't.
    // at worst, it would cause a leak, so I'm going with it anyway.
    ASSERT_BREAK(m_pOriginalPriv == NULL);

    BOOL bRetCode = FALSE;
    SmartCloseHandle hToken;
    TOKEN_PRIVILEGES TPriv ;
    LUID LUID ;

    // Validate the platform
    //======================

    // Try getting the thread token.  
    if (OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES |
        TOKEN_QUERY, FALSE, &hToken)) 
    {

        GetTokenInformation(hToken, TokenPrivileges, NULL, 0, &m_dwSize);
        if (m_dwSize > 0)
        {
            // This is cleaned in the destructor, so no try/catch required
            m_pOriginalPriv = (TOKEN_PRIVILEGES*) new BYTE[m_dwSize];
            if (m_pOriginalPriv == NULL)
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

        }

        if (m_pOriginalPriv && GetTokenInformation(hToken, TokenPrivileges, m_pOriginalPriv, m_dwSize, &m_dwSize))
        {
			bRetCode = LookupPrivilegeValue(NULL, SE_RESTORE_NAME, &LUID) ;
			if(bRetCode)
            {
				TPriv.PrivilegeCount = 1 ;
				TPriv.Privileges[0].Luid = LUID ;
				TPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED ;

				bRetCode = AdjustTokenPrivileges(hToken, FALSE, &TPriv, sizeof(TOKEN_PRIVILEGES), NULL, NULL) ;
		    }
			bRetCode = LookupPrivilegeValue(NULL, SE_BACKUP_NAME, &LUID) ;
			if(bRetCode)
            {
				TPriv.PrivilegeCount = 1 ;
				TPriv.Privileges[0].Luid = LUID ;
				TPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED ;

				bRetCode = AdjustTokenPrivileges(hToken, FALSE, &TPriv, sizeof(TOKEN_PRIVILEGES), NULL, NULL) ;
		    }
		}
    }

    if(!bRetCode)
    {
        return GetLastError() ;
    }

    return ERROR_SUCCESS ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::RestorePrivilege
 *
 *  DESCRIPTION : Restores original status of SeRestorePrivilege
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
void CUserHive::RestorePrivilege()
{
    ASSERT_BREAK(m_pOriginalPriv != NULL);

    if (m_pOriginalPriv != NULL)
    {
        SmartCloseHandle hToken;

        try
        {
            if (OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, TRUE, &hToken))
            {
                AdjustTokenPrivileges(hToken, FALSE, m_pOriginalPriv, m_dwSize, NULL, NULL);
            }
        }
        catch ( ... )
        {
            delete m_pOriginalPriv;
            m_pOriginalPriv = NULL;
            m_dwSize = 0;

            throw;
        }

        delete m_pOriginalPriv;
        m_pOriginalPriv = NULL;
        m_dwSize = 0;
    }
}
#endif

DWORD CUserHive::Load(LPCWSTR pszUserName, LPWSTR pszKeyName, size_t PATHSIZE)
{
    // NOTE: The destructor does not unload the key.  Nor does doing a load unload
    // a previously loaded key;
    ASSERT_BREAK(m_hKey == NULL);

#ifdef NTONLY
		return LoadNT(pszUserName, pszKeyName, PATHSIZE);
#endif
#ifdef WIN9XONLY
		return Load95(pszUserName, pszKeyName);
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::LoadNT
 *
 *  DESCRIPTION : Locates user's hive & loads into registry if not already
 *                present
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : pszKeyName receives the expanded SID of the user's
 *                registry key under HKEY_USERS
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Hive will remain in registry unless unloaded
 *
 *****************************************************************************/

#ifdef NTONLY
DWORD CUserHive::LoadNT(LPCTSTR pszUserName, LPTSTR pszKeyName, size_t PATHSIZE)
{
    DWORD i, dwSIDSize, dwRetCode, dwDomainNameSize,  dwSubAuthorities ;
    TCHAR szDomainName[_MAX_PATH], szSID[_MAX_PATH], szTemp[_MAX_PATH]  ;
    PSID pSID = NULL ;
    PSID_IDENTIFIER_AUTHORITY pSIA ;
    SID_NAME_USE AccountType ;
    CHString sTemp ;
    CRegistry Reg ;

    // Set the necessary privs
    //========================
    dwRetCode = AcquirePrivilege() ;
    if(dwRetCode != ERROR_SUCCESS)
    {
        return dwRetCode ;
    }

    // Look up the user's account info
    //================================
    dwSIDSize = 0L ;
    dwDomainNameSize = sizeof(szDomainName) ;

	BOOL bLookup = FALSE;
	{
		bLookup = LookupAccountName(NULL, pszUserName, pSID, &dwSIDSize, szDomainName, &dwDomainNameSize, &AccountType);
		ASSERT_BREAK ( bLookup == FALSE );

		if ( ERROR_INSUFFICIENT_BUFFER == ::GetLastError () )
		{
			pSID = (PSID) malloc( dwSIDSize );
			if ( NULL != pSID )
			{
				bLookup = LookupAccountName(NULL, pszUserName, pSID, &dwSIDSize, szDomainName, &dwDomainNameSize, &AccountType);
			}
			else
			{
				RestorePrivilege() ;
				return ERROR_NOT_ENOUGH_MEMORY ;
			}
		}
    }

	if(!bLookup)
    {
		if ( pSID )
		{
			free ( pSID ) ;
			pSID = NULL ;
		}

	    RestorePrivilege() ;
        return ERROR_BAD_USERNAME ;
    }

    // Translate the SID into text (a la PSS article Q131320)
    //=======================================================

    pSIA = GetSidIdentifierAuthority(pSID) ;
    dwSubAuthorities = *GetSidSubAuthorityCount(pSID) ;
    dwSIDSize = _stprintf(szSID, _T("S-%lu-"), (DWORD) SID_REVISION) ;

    if((pSIA->Value[0] != 0) || (pSIA->Value[1] != 0) )
    {
        dwSIDSize += _stprintf(szSID + _tcslen(szSID), _T("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                             (USHORT) pSIA->Value[0],
                             (USHORT) pSIA->Value[1],
                             (USHORT) pSIA->Value[2],
                             (USHORT) pSIA->Value[3],
                             (USHORT) pSIA->Value[4],
                             (USHORT) pSIA->Value[5]) ;
    }
    else
    {
        dwSIDSize += _stprintf(szSID + _tcslen(szSID), _T("%lu"),
                             (ULONG)(pSIA->Value[5]      ) +
                             (ULONG)(pSIA->Value[4] <<  8) +
                             (ULONG)(pSIA->Value[3] << 16) +
                             (ULONG)(pSIA->Value[2] << 24));
    }

    for(i = 0 ; i < dwSubAuthorities ; i++)
    {
        dwSIDSize += _stprintf(szSID + dwSIDSize, _T("-%lu"),
                             *GetSidSubAuthority(pSID, i)) ;
    }

	free ( pSID ) ;
	pSID = NULL ;

    // See if the key already exists
    //==============================
    dwRetCode = Reg.Open(HKEY_USERS, szSID, KEY_READ) ;

    // We need to keep a handle open.  See m_hKey below, so we'll let the destructor close this.
//    Reg.Close();

    if(dwRetCode != ERROR_SUCCESS)
    {
        // Try to locate user's registry hive
        //===================================

        _stprintf(szTemp, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\%s"), szSID) ;
        dwRetCode = Reg.Open(HKEY_LOCAL_MACHINE, szTemp, KEY_READ) ;
        if(dwRetCode == ERROR_SUCCESS)
        {

            dwRetCode = Reg.GetCurrentKeyValue(_T("ProfileImagePath"), sTemp) ;
            Reg.Close() ;
            if(dwRetCode == ERROR_SUCCESS)
            {

                // NT 4 doesn't include the file name in the registry
                //===================================================

                if(OSInfo.dwMajorVersion >= 4)
                {

                    sTemp += _T("\\NTUSER.DAT") ;
                }

                ExpandEnvironmentStrings(LPCTSTR(sTemp), szTemp, sizeof(szTemp) / sizeof(TCHAR)) ;

				// Try it three times, another process may have the file open
				bool bTryTryAgain = false;
				int  nTries = 0;
				do
				{
					// need to serialize access, using "write" because RegLoadKey wants exclusive access
					// even though it is a read operation
					m_criticalSection.BeginWrite();

                    try
                    {
	                    dwRetCode = (DWORD) RegLoadKey(HKEY_USERS, szSID, szTemp) ;
                    }
                    catch ( ... )
                    {
    					m_criticalSection.EndWrite();
                        throw;
                    }

					m_criticalSection.EndWrite();

					if ((dwRetCode == ERROR_SHARING_VIOLATION)
						&& (++nTries < 11))
					{
						Sleep(20 * nTries);
						bTryTryAgain = true;
					}
					else
                    {
						bTryTryAgain = false;
                    }

				} while (bTryTryAgain);
                // if we still can't get in, tell somebody.
                if (dwRetCode == ERROR_SHARING_VIOLATION)
    			    LogErrorMessage(_T("Sharing violation on NTUSER.DAT (Load)"));

			}
        }
    }

    if(dwRetCode == ERROR_SUCCESS)
    {
        HRESULT hr = StringCchCopy(pszKeyName, PATHSIZE, szSID) ;

        ASSERT_BREAK(SUCCEEDED(hr));

        LONG lRetVal;
        CHString sKey(szSID);

        sKey += _T("\\Software");
        lRetVal = RegOpenKeyEx(HKEY_USERS, sKey, 0, KEY_QUERY_VALUE, &m_hKey);

        ASSERT_BREAK(lRetVal == ERROR_SUCCESS);
    }

    // Restore original privilege level & end self-impersonation
    //==========================================================

    RestorePrivilege() ;

    return dwRetCode ;
}
#endif
/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::Load95
 *
 *  DESCRIPTION : Locates user's hive & loads into registry if not already
 *                present
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : pszKeyName receives the expanded SID of the user's
 *                registry key under HKEY_USERS
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Hive will remain in registry unless unloaded
 *
 *****************************************************************************/
#ifdef WIN9XONLY
DWORD CUserHive::Load95(LPCWSTR pszUserName, LPWSTR pszKeyName)
{
    DWORD dwRetCode;
    WCHAR wszTemp[_MAX_PATH];
    TCHAR szTemp[_MAX_PATH];
    CHString sTemp ;
    CRegistry Reg ;

	wcscpy(pszKeyName, pszUserName);

    // See if the key already exists
    //==============================
    dwRetCode = Reg.Open(HKEY_USERS, pszKeyName, KEY_READ) ;
    // We need to keep a handle open.  See m_hKey below, so we'll let the destructor close this.
//    Reg.Close() ;

    if(dwRetCode == ERROR_SUCCESS)
    {

        // We need to keep a handle open.  See m_hKey below, so we'll let the destructor close this.
//        Reg.Close() ;
    }
    else
    {
        // Try to locate user's registry hive
        //===================================
        swprintf(wszTemp, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ProfileList\\%s", pszUserName) ;
        dwRetCode = Reg.Open(HKEY_LOCAL_MACHINE, wszTemp, KEY_READ);
        if(dwRetCode == ERROR_SUCCESS) {

            dwRetCode = Reg.GetCurrentKeyValue(L"ProfileImagePath", sTemp) ;
            Reg.Close() ;
            if(dwRetCode == ERROR_SUCCESS)
			{
				sTemp += _T("\\USER.DAT") ;

                ExpandEnvironmentStrings(TOBSTRT(sTemp), szTemp, sizeof(szTemp) / sizeof(TCHAR)) ;

				// Try it three times, another process may have the file open
				bool bTryTryAgain = false;
				int  nTries = 0;
				do
				{
					// need to serialize access, using "write" because RegLoadKey wants exclusive access
					// even though it is a read operation
					m_criticalSection.BeginWrite();

                    try
                    {
	                    dwRetCode = (DWORD) RegLoadKey(HKEY_USERS, TOBSTRT(pszUserName), szTemp) ;
                    }
                    catch ( ... )
                    {
    					m_criticalSection.EndWrite();
                        throw;
                    }

					m_criticalSection.EndWrite();

					if ((dwRetCode == ERROR_SHARING_VIOLATION)
						&& (++nTries < 11))
					{
						LogErrorMessage(L"Sharing violation on USER.DAT (Load)");
						Sleep(15 * nTries);
						bTryTryAgain = true;
					}
					else
						bTryTryAgain = false;

				} while (bTryTryAgain);
			}
        }
    }

    if (dwRetCode == ERROR_SUCCESS)
    {
        LONG lRetVal;
        CHString sKey(pszUserName);

        sKey += L"\\Software";
        lRetVal = RegOpenKeyEx(HKEY_USERS, TOBSTRT(sKey), 0, KEY_QUERY_VALUE, &m_hKey);
        ASSERT_BREAK(lRetVal == ERROR_SUCCESS);
    }


    return dwRetCode ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::LoadProfile
 *
 *  DESCRIPTION : Locates user's hive & loads into registry if not already
 *                present
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none.
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Hive will remain in registry unless unloaded
 *				  NT Only.
 *
 *****************************************************************************/

DWORD CUserHive::LoadProfile( LPCWSTR pszSID, CHString& strUserName )
{
    // NOTE: The destructor does not unload the key.  Nor does doing a load unload
    // a previously loaded key;
    ASSERT_BREAK(m_hKey == NULL);

    DWORD dwRetCode = ERROR_SUCCESS;
    WCHAR szTemp[_MAX_PATH] ;
    CHString sTemp ;
    CRegistry Reg ;

    strUserName = L"";

    // Set the necessary privs
    //========================

#ifdef NTONLY
    dwRetCode = AcquirePrivilege() ;
#endif
    if(dwRetCode != ERROR_SUCCESS) 
    {
        return dwRetCode ;
    }

    // See if the key already exists
    //==============================

    dwRetCode = Reg.Open(HKEY_USERS, pszSID, KEY_READ) ;
    // We need to keep a handle open.  See m_hKey below, so we'll let the destructor close this.
//    Reg.Close() ;

	// If we got the profile, make sure we can get account information regarding
	// the SID.
    if(dwRetCode == ERROR_SUCCESS)
	{
        CRegistry Reg2 ;
        StringCbPrintf(szTemp, _MAX_PATH, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\%s", pszSID) ;
        dwRetCode = Reg2.Open(HKEY_LOCAL_MACHINE, szTemp, KEY_READ) ;
        if(dwRetCode == ERROR_SUCCESS)
		{

			// Load the user account information
			dwRetCode = UserAccountFromProfile( Reg2, strUserName );
            // We need to keep a handle open.  See m_hKey below, so we'll let the destructor close this.
			Reg2.Close() ;
		}

    }
    else
    {
        // Try to locate user's registry hive
        //===================================

        StringCbPrintf(szTemp,_MAX_PATH, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\%s", pszSID) ;
        dwRetCode = Reg.Open(HKEY_LOCAL_MACHINE, szTemp, KEY_READ) ;
        if(dwRetCode == ERROR_SUCCESS)
		{
			UserAccountFromProfile( Reg, strUserName );

			dwRetCode = Reg.GetCurrentKeyValue(L"ProfileImagePath", sTemp) ;
	        Reg.Close() ;
			if(dwRetCode == ERROR_SUCCESS)
            {

				// NT 4 doesn't include the file name in the registry
				//===================================================

				if(OSInfo.dwMajorVersion >= 4)
                {
					sTemp += _T("\\NTUSER.DAT") ;
				}

				TCHAR szTemp[MAX_PATH];

                ExpandEnvironmentStrings(TOBSTRT(sTemp), szTemp, sizeof(szTemp) / sizeof(TCHAR)) ;

				// Try it three times, another process may have the file open
				bool bTryTryAgain = false;
				int  nTries = 0;
				do
				{
					// need to serialize access, using "write" because RegLoadKey wants exclusive access
					// even though it is a read operation
					m_criticalSection.BeginWrite();

                    try
                    {
						dwRetCode = (DWORD) RegLoadKey(HKEY_USERS, TOBSTRT(pszSID), szTemp);
                    }
                    catch ( ... )
                    {
    					m_criticalSection.EndWrite();
                        throw;
                    }
					m_criticalSection.EndWrite();

					if ((dwRetCode == ERROR_SHARING_VIOLATION)
						&& (++nTries < 11))
					{
						LogErrorMessage(L"Sharing violation on NTUSER.DAT (LoadProfile)");
						Sleep(20 * nTries);
						bTryTryAgain = true;
					}
					else
                    {
						bTryTryAgain = false;
                    }

				} while (bTryTryAgain);
			}
        }
    }

    if(dwRetCode == ERROR_SUCCESS)
    {
        LONG lRetVal;
        CHString sKey(pszSID);

        sKey += _T("\\Software");
        lRetVal = RegOpenKeyEx(HKEY_USERS, TOBSTRT(sKey), 0, KEY_QUERY_VALUE, &m_hKey);
        ASSERT_BREAK(lRetVal == ERROR_SUCCESS);
    }

    // Restore original privilege level & end self-impersonation
    //==========================================================

#ifdef NTONLY
    RestorePrivilege() ;
#endif

    return dwRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::UserAccountFromProfile
 *
 *  DESCRIPTION : Pulls the PSID out of the registry object, and creates
 *					a DOMAIN\UserName value.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none.
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registry Object must be preloaded to the correct profile
 *					key.
 *
 *****************************************************************************/

DWORD CUserHive::UserAccountFromProfile( CRegistry& reg, CHString& strUserName )
{
	DWORD	dwReturn = ERROR_SUCCESS,
			dwSidSize = 0;

	if ( ( dwReturn = reg.GetCurrentBinaryKeyValue( L"Sid", NULL, &dwSidSize ) ) == ERROR_SUCCESS )
	{
		PSID	psid = new byte [ dwSidSize ];

		if ( NULL != psid )
		{
            try
            {

			    if ( ( dwReturn = reg.GetCurrentBinaryKeyValue( L"Sid", (LPBYTE) psid, &dwSidSize ) ) == ERROR_SUCCESS )
			    {
				    CSid	sid( psid );

				    // The sid account type must be valid and the lookup must have been
				    // successful.

				    if ( sid.IsOK() && sid.IsAccountTypeValid() )
				    {
					    sid.GetDomainAccountName( strUserName );
                    }
                    else
                    {
                        dwReturn = ERROR_NO_SUCH_USER;
                    }
			    }
            }
            catch ( ... )
            {
                delete [] psid;
                throw ;
            }

			delete [] psid;
		}
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
	}

	return dwReturn;
}

/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::Unload
 *
 *  DESCRIPTION : Unloads key from HKEY_USERS if present
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Windows error code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

DWORD CUserHive::Unload(LPCWSTR pszKeyName)
{
    DWORD dwRetCode = ERROR_SUCCESS;

    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

#ifdef NTONLY
		dwRetCode = AcquirePrivilege();
#endif

	if(dwRetCode == ERROR_SUCCESS)
    {

        m_criticalSection.BeginWrite();

        try
        {
		    dwRetCode = RegUnLoadKey(HKEY_USERS, TOBSTRT(pszKeyName)) ;
        }
        catch ( ... )
        {
    		m_criticalSection.EndWrite();
            throw;
        }

		m_criticalSection.EndWrite();

#ifdef NTONLY
			RestorePrivilege() ;
#endif

    }

    return dwRetCode ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\userenvapi.cpp ===
//=================================================================

//

// UserEnvAPI.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>
#include "UserEnvApi.h"
#include "DllWrapperCreatorReg.h"

// {C2BB0B38-8549-48a6-A58E-E704DFC19D80}
static const GUID g_guidUserEnvApi =
{ 0xc2bb0b38, 0x8549, 0x48a6, { 0xa5, 0x8e, 0xe7, 0x4, 0xdf, 0xc1, 0x9d, 0x80 } };

static const TCHAR g_tstrUserEnv[] = _T("userenv.dll");

/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CUserEnvApi, &g_guidUserEnvApi, g_tstrUserEnv> MyRegisteredUserEnvWrapper;

/******************************************************************************
 * Constructor
 ******************************************************************************/
CUserEnvApi :: CUserEnvApi (

	LPCTSTR a_tstrWrappedDllName

) : CDllWrapperBase(a_tstrWrappedDllName),
	m_pfnDestroyEnvironmentBlock(NULL),
	m_pfnCreateEnvironmentBlock(NULL)
{
}

/******************************************************************************
 * Destructor
 ******************************************************************************/
CUserEnvApi :: ~CUserEnvApi ()
{
}

/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CUserEnvApi :: Init ()
{
    bool fRet = LoadLibrary () ;
    if ( fRet )
    {
#ifdef NTONLY

		m_pfnDestroyEnvironmentBlock = ( PFN_UserEnv_DESTROYENVIRONMENTBLOCK ) GetProcAddress ( "DestroyEnvironmentBlock" ) ;
		m_pfnCreateEnvironmentBlock = ( PFN_UserEnv_CREATEENVIRONMENTBLOCK ) GetProcAddress ( "CreateEnvironmentBlock" ) ;

		if ( m_pfnDestroyEnvironmentBlock == NULL ||
			m_pfnCreateEnvironmentBlock == NULL )
		{
            fRet = false ;
            LogErrorMessage(L"Failed find entrypoint in userenvapi");
		}
#endif

        // Check that we have function pointers to functions that should be
        // present in all versions of this dll...
        // ( in this case, ALL these are functions that may or may not be
        //   present, so don't bother)
    }

    return fRet;
}

/******************************************************************************
 * Member functions wrapping UserEnv api functions. Add new functions here
 * as required.
 ******************************************************************************/

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.

BOOL CUserEnvApi :: CreateEnvironmentBlock (

	OUT LPVOID *lpEnvironment,
	IN HANDLE hToken,
	IN BOOL bInherit
)
{
	return m_pfnCreateEnvironmentBlock (

		lpEnvironment,
		hToken,
		bInherit

	) ;
}

BOOL CUserEnvApi :: DestroyEnvironmentBlock (

	IN LPVOID lpEnvironment
)
{
	return m_pfnDestroyEnvironmentBlock (

		lpEnvironment
	) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\wbemnetapi32.cpp ===
//============================================================
//
// WBEMNetAPI32.cpp - implementation of NetAPI32.DLL access class
//
//  Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//============================================================

#include "precomp.h"
#include <winerror.h>

#include "WBEMNETAPI32.h"

/*****************************************************************************
 *
 *  FUNCTION    : CNetAPI32::CNetAPI32
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CNetAPI32::CNetAPI32()
#ifdef NTONLY
:   m_pnetapi(NULL)
#endif
#ifdef WIN9XONLY
:   m_psvrapi(NULL)
#endif
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CNetAPI32::~CNetAPI32
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CNetAPI32::~CNetAPI32()
{
#ifdef NTONLY
    if(m_pnetapi != NULL)
    {
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNetApi32Api, m_pnetapi);
    }
#endif
#ifdef WIN9XONLY
    if(m_psvrapi != NULL)
    {
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidSvrApiApi, m_psvrapi);
    }
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CNetAPI32::Init
 *
 *  DESCRIPTION : Loads CSAPI.DLL, locates entry points
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : ERROR_SUCCESS or windows error code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

LONG CNetAPI32::Init()
{
    LONG lRetCode = ERROR_SUCCESS;

#ifdef WIN9XONLY
    m_psvrapi = (CSvrApiApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidSvrApiApi, NULL);
    if(m_psvrapi == NULL)
    {
        // Couldn't get one or more entry points
        //======================================
        lRetCode = ERROR_PROC_NOT_FOUND;
    }
#endif

#ifdef NTONLY
    m_pnetapi = (CNetApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidNetApi32Api, NULL);
    if(m_pnetapi == NULL)
    {
        // Couldn't get one or more entry points
        //======================================
        lRetCode = ERROR_PROC_NOT_FOUND;
    }
#endif

    return lRetCode;
}


/*****************************************************************************
 *
 *  SVRAPIAPI.DLL WRAPPERS
 *
 *****************************************************************************/

#ifdef WIN9XONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareEnum95(char FAR *servername,
                                                     short level,
                                                     char FAR *bufptr,
                                                     unsigned short prefmaxlen,
                                                     unsigned short FAR *entriesread,
                                                     unsigned short FAR *totalentries)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_psvrapi != NULL)
    {
        ns = m_psvrapi->NetShareEnum(servername, level, bufptr, prefmaxlen,
                                   entriesread, totalentries);
    }
    return ns;
}
#endif


#ifdef WIN9XONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareGetInfo95(char FAR *servername,
                                                        char FAR *netname,
                                                        short level,
                                                        char FAR *bufptr,
                                                        unsigned short buflen,
                                                        unsigned short FAR *totalavail)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_psvrapi != NULL)
    {
        ns = m_psvrapi->NetShareGetInfo(servername, netname, level,
                                      bufptr, buflen, totalavail);
    }
    return ns;
}
#endif

#ifdef WIN9XONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareAdd95 (

	IN  const char FAR *	servername,
	IN  short				level,
	IN  const char FAR *	buf,
	unsigned short			cbBuffer
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_psvrapi != NULL)
    {
        ns = m_psvrapi->NetShareAdd(servername, level, buf , cbBuffer);
    }
    return ns;
}
#endif

#ifdef WIN9XONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareSetInfo95 (

	IN const char FAR *	servername,
	IN const char FAR *	netname,
	IN short			level,
	IN const char FAR*	buf,
	IN unsigned short   cbBuffer,
	IN short            sParmNum
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_psvrapi != NULL)
    {
        ns = m_psvrapi->NetShareSetInfo(servername, netname, level,
                                      buf, cbBuffer, sParmNum);
    }
    return ns;
}
#endif

#ifdef WIN9XONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareDel95 (

	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   reserved
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_psvrapi != NULL)
    {
        ns = m_psvrapi->NetShareDel(servername, netname, reserved);
    }
    return ns;
}
#endif

#ifdef WIN9XONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetServerGetInfo95(char FAR *servername,
                                          short level,
                                          char FAR *bufptr,
                                          unsigned short buflen,
                                          unsigned short FAR *totalavail)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_psvrapi != NULL)
    {
        ns = m_psvrapi->NetServerGetInfo(servername, level, bufptr, buflen,
                                       totalavail);
    }
    return ns;
}
#endif


/*****************************************************************************
 *
 *  NETAPI32API.DLL WRAPPERS
 *
 *****************************************************************************/

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetGroupEnum(LPCWSTR servername,
                                                        DWORD level,
                                                        LPBYTE *bufptr,
                                                        DWORD prefmaxlen,
                                                        LPDWORD entriesread,
                                                        LPDWORD totalentries,
                                                        PDWORD_PTR resume_handle)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetGroupEnum(servername, level, bufptr, prefmaxlen,
                                   entriesread, totalentries, resume_handle);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetGroupGetInfo(LPCWSTR servername,
                                                           LPCWSTR groupname,
                                                           DWORD level,
                                                           LPBYTE *bufptr)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetGroupGetInfo(servername, groupname, level, bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetGroupSetInfo(

LPCWSTR servername,
LPCWSTR groupname,
DWORD level,
LPBYTE buf,
LPDWORD parm_err
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetGroupSetInfo( servername, groupname, level, buf, parm_err) ;
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetLocalGroupGetInfo(LPCWSTR servername,
                                                           LPCWSTR groupname,
                                                           DWORD level,
                                                           LPBYTE *bufptr)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetLocalGroupGetInfo(servername, groupname, level,
                                           bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetLocalGroupSetInfo(

LPCWSTR a_servername,
LPCWSTR a_groupname,
DWORD a_level,
LPBYTE a_buf,
LPDWORD a_parm_err
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetLocalGroupSetInfo(	a_servername,
												a_groupname,
												a_level,
												a_buf,
												a_parm_err);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetGroupGetUsers(LPCWSTR servername,
                                                            LPCWSTR groupname,
                                                            DWORD level,
                                                            LPBYTE *bufptr,
                                                            DWORD prefmaxlen,
                                                            LPDWORD entriesread,
                                                            LPDWORD totalentries,
                                                            PDWORD_PTR ResumeHandle)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetGroupGetUsers(servername, groupname, level, bufptr,
                                       prefmaxlen, entriesread, totalentries,
                                       ResumeHandle);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetLocalGroupGetMembers(LPCWSTR servername,
                                                            LPCWSTR groupname,
                                                            DWORD level,
                                                            LPBYTE *bufptr,
                                                            DWORD prefmaxlen,
                                                            LPDWORD entriesread,
                                                            LPDWORD totalentries,
                                                            PDWORD_PTR ResumeHandle)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetLocalGroupGetMembers(servername, groupname, level,
                                              bufptr, prefmaxlen, entriesread,
                                              totalentries, ResumeHandle);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetLocalGroupEnum(LPCWSTR servername,
                                                             DWORD level,
                                                             LPBYTE *bufptr,
                                                             DWORD prefmaxlen,
                                                             LPDWORD entriesread,
                                                             LPDWORD totalentries,
                                                             PDWORD_PTR resume_handle)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetLocalGroupEnum(servername, level, bufptr, prefmaxlen,
                                        entriesread, totalentries,
                                        resume_handle);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareEnum(LPTSTR servername,
                                                        DWORD level,
                                                        LPBYTE *bufptr,
                                                        DWORD prefmaxlen,
                                                        LPDWORD entriesread,
                                                        LPDWORD totalentries,
                                                        LPDWORD resume_handle)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetShareEnum(servername, level, bufptr, prefmaxlen,
                                   entriesread, totalentries, resume_handle);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareGetInfo(LPTSTR servername,
                                                           LPTSTR netname,
                                                           DWORD level,
                                                           LPBYTE *bufptr)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetShareGetInfo(servername, netname, level, bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareAdd (

	IN  LPTSTR  servername,
	IN  DWORD   level,
	IN  LPBYTE  buf,
	OUT LPDWORD parm_err
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetShareAdd(servername, level, buf , parm_err);
    }
    return ns;
}
#endif


#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareEnumSticky (

	IN  LPTSTR      servername,
	IN  DWORD       level,
	OUT LPBYTE      *bufptr,
	IN  DWORD       prefmaxlen,
	OUT LPDWORD     entriesread,
	OUT LPDWORD     totalentries,
	IN OUT LPDWORD  resume_handle
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetShareEnumSticky(servername, level, bufptr, prefmaxlen,
                                         entriesread, totalentries,
                                         resume_handle);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareSetInfo (

	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   level,
	IN  LPBYTE  buf,
	OUT LPDWORD parm_err
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetShareSetInfo(servername, netname,level,buf,parm_err);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareDel (

	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   reserved
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetShareDel(servername, netname, reserved);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareDelSticky (

	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   reserved
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetShareDelSticky(servername, netname, reserved);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareCheck (

	IN  LPTSTR  servername,
	IN  LPTSTR  device,
	OUT LPDWORD type
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetShareCheck(servername, device, type);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetUserEnum(LPCWSTR servername,
                                                       DWORD level,
                                                       DWORD filter,
                                                       LPBYTE *bufptr,
                                                       DWORD prefmaxlen,
                                                       LPDWORD entriesread,
                                                       LPDWORD totalentries,
                                                       LPDWORD resume_handle)
{
	NET_API_STATUS ns = NERR_NetworkError;
	if(m_pnetapi != NULL)
    {
        int i = 1;
	    // try with longer preferred lengths if it fails
	    // might only be germaine to NT 3.51, dunno but it works.
	    do
	    {
		    ns = m_pnetapi->NetUserEnum(servername, level, filter, bufptr,
                                      prefmaxlen * i, entriesread, totalentries,
                                      resume_handle);
		    i *= 2;
	    } while (ns == NERR_BufTooSmall && i <= 16);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetUserGetInfo(LPCWSTR servername,
                                                          LPCWSTR username,
                                                          DWORD level,
                                                          LPBYTE *bufptr)

{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetUserGetInfo(servername, username, level, bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetUserSetInfo(

LPCWSTR a_servername,
LPCWSTR a_username,
DWORD a_level,
LPBYTE a_buf,
LPDWORD a_parm_err
)
{
    NET_API_STATUS t_ns = NERR_NetworkError;
    if( m_pnetapi != NULL )
    {
        t_ns = m_pnetapi->NetUserSetInfo( a_servername, a_username, a_level, a_buf, a_parm_err ) ;
    }
    return t_ns ;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetApiBufferFree(void *bufptr)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetApiBufferFree(bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetQueryDisplayInformation(	LPWSTR ServerName,
																		DWORD Level,
																		DWORD Index,
																		DWORD EntriesRequested,
																		DWORD PreferredMaximumLength,
																		LPDWORD ReturnedEntryCount,
																		PVOID *SortedBuffer)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetQueryDisplayInformation(ServerName, Level, Index,
                                          EntriesRequested,
                                          PreferredMaximumLength,
                                          ReturnedEntryCount, SortedBuffer);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetServerSetInfo(LPTSTR servername,
										  DWORD level,
										  LPBYTE  bufptr,
										  LPDWORD ParmError)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetServerSetInfo(servername, level, bufptr, ParmError);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetServerGetInfo(LPTSTR servername,
                                          DWORD level,
                                          LPBYTE *bufptr)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetServerGetInfo(servername, level, bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::DSRoleGetPrimaryDomainInfo(LPCWSTR servername,
											  DSROLE_PRIMARY_DOMAIN_INFO_LEVEL level,
											  LPBYTE *bufptr)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        // Check if the machine is running an NT5 version of netapi32.dll...
        if(!m_pnetapi->DSRoleGetPrimaryDomainInformation(servername,
                                                                level, bufptr, &ns))
        {
            ns = NERR_InternalError;
        }
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetRenameMachineInDomain(LPCWSTR a_lpServer,
                                                LPCWSTR a_lpNewMachineName,
                                                LPCWSTR a_lpAccount,
                                                LPCWSTR a_lpPassword,
                                                DWORD a_fRenameOptions)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        // Check if the machine is running an NT5 version of netapi32.dll...
        if(!m_pnetapi->NetRenameMachineInDomain(a_lpServer, a_lpNewMachineName,
                                                a_lpAccount, a_lpPassword,
                                                a_fRenameOptions, &ns))
        {
            ns = NERR_InternalError;
        }
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION  CNetAPI32::NetUnjoinDomain(	LPCWSTR lpServer,
															LPCWSTR lpAccount,
															LPCWSTR lpPassword,
															DWORD   fUnjoinOptions)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        // Check if the machine is running an NT5 version of netapi32.dll...
        if(!m_pnetapi->NetUnjoinDomain(lpServer, lpAccount, lpPassword, fUnjoinOptions, &ns))
        {
            ns = NERR_InternalError;
        }
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION  CNetAPI32::NetJoinDomain( LPCWSTR lpServer,
														LPCWSTR lpDomain,
														LPCWSTR lpAccountOU,
														LPCWSTR lpAccount,
														LPCWSTR lpPassword,
														DWORD fJoinOptions)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        // Check if the machine is running an NT5 version of netapi32.dll...
        if(!m_pnetapi->NetJoinDomain(lpServer, lpDomain, lpAccountOU, lpAccount, lpPassword, fJoinOptions, &ns))
        {
            ns = NERR_InternalError;
        }
    }
    return ns;
}
#endif


#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::DSRoleFreeMemory(LPBYTE bufptr)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        // Check if the machine is running an NT5 version of netapi32.dll...
        if(!m_pnetapi->DSRoleFreeMemory(bufptr, &ns))
        {
            ns = NERR_InternalError;
        }
    }
    return ns;
}
#endif


#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetGetDCName(	LPCWSTR ServerName,
															LPCWSTR DomainName,
															LPBYTE* bufptr )
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetGetDCName(ServerName, DomainName, bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetWkstaGetInfo(	LPWSTR ServerName,
																DWORD level,
																LPBYTE *bufptr )
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetWkstaGetInfo(ServerName, level, bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetGetAnyDCName(	LPWSTR ServerName,
															LPWSTR DomainName,
															LPBYTE* bufptr )
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetGetAnyDCName(ServerName, DomainName, bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetServerEnum(	LPTSTR servername,
														DWORD level,
														LPBYTE *bufptr,
														DWORD prefmaxlen,
														LPDWORD entriesread,
														LPDWORD totalentries,
														DWORD servertype,
														LPTSTR domain,
														LPDWORD resume_handle )
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetServerEnum(servername, level, bufptr, prefmaxlen,
                                    entriesread, totalentries, servertype,
                                    domain, resume_handle);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetEnumerateTrustedDomains(	LPWSTR servername,
																		LPWSTR* domainNames )
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        // Check if the machine is running an NT5 version of netapi32.dll...
        if(!m_pnetapi->NetEnumerateTrustedDomains(servername, domainNames, &ns))
        {   // The function doesn't exist.
            ns = NERR_InternalError;
        }
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::DsGetDcName(	LPCTSTR ComputerName,
														LPCTSTR DomainName,
														GUID *DomainGuid,
														LPCTSTR SiteName,
														ULONG Flags,
														PDOMAIN_CONTROLLER_INFO *DomainControllerInfo )
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        // Check if the machine is running an NT5 version of netapi32.dll...
        if(!m_pnetapi->DsGetDCName(ComputerName, DomainName, DomainGuid,
								  SiteName, Flags, DomainControllerInfo, &ns))
        {   // The function does not exist.
            ns = NERR_InternalError;
        }
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetUserModalsGet(	LPWSTR servername,
																DWORD level,
																LPBYTE *bufptr )
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetUserModalsGet(servername, level, bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION	CNetAPI32::NetScheduleJobAdd (

	IN      LPCWSTR         Servername  OPTIONAL,
	IN      LPBYTE          Buffer,
	OUT     LPDWORD         JobId
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetScheduleJobAdd(Servername, Buffer, JobId);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION	CNetAPI32::NetScheduleJobDel (

	IN      LPCWSTR         Servername  OPTIONAL,
	IN      DWORD           MinJobId,
	IN      DWORD           MaxJobId
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetScheduleJobDel(Servername, MinJobId , MaxJobId);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION	CNetAPI32::NetScheduleJobEnum (

	IN      LPCWSTR         Servername              OPTIONAL,
	OUT     LPBYTE *        PointerToBuffer,
	IN      DWORD           PrefferedMaximumLength,
	OUT     LPDWORD         EntriesRead,
	OUT     LPDWORD         TotalEntries,
	IN OUT  LPDWORD         ResumeHandle
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetScheduleJobEnum(Servername, PointerToBuffer,
                                         PrefferedMaximumLength, EntriesRead,
                                         TotalEntries, ResumeHandle);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION	CNetAPI32::NetScheduleJobGetInfo (

	IN      LPCWSTR         Servername             OPTIONAL,
	IN      DWORD           JobId,
	OUT     LPBYTE *        PointerToBuffer
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetScheduleJobGetInfo(Servername, JobId , PointerToBuffer);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetUseGetInfo(
    IN LPCWSTR UncServerName OPTIONAL,
    IN LPCWSTR UseName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetUseGetInfo(UncServerName, UseName, Level, BufPtr);
    }
    return ns;
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32UserAccount::GetTrustedDomainsNT
//
//	Obtains Names of trusted domains and stuffs them in a user supplied
//	CHStringArray.
//
//	Inputs:
//
//	Outputs:	CHStringArray&	strarrayTrustedDomains;
//
//	Returns:	TRUE/FALSE		Success/Failure
//
//	Comments:
//
/////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
BOOL CNetAPI32::GetTrustedDomainsNT(CHStringArray& achsTrustList)
{
    LSA_HANDLE PolicyHandle  = INVALID_HANDLE_VALUE;
    NTSTATUS Status =0;

    NET_API_STATUS nas = NERR_Success; // assume success

    BOOL bSuccess = FALSE; // assume this function will fail

    CAdvApi32Api *t_padvapi = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL) ;
	if( t_padvapi == NULL)
	{
        return FALSE;
    }

    try
    {
        PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomain = NULL;
        //
        // open the policy on the specified machine
        //
        {
            Status = OpenPolicy(

				t_padvapi ,
				NULL,
                POLICY_VIEW_LOCAL_INFORMATION,
                &PolicyHandle
                );

            if(Status != STATUS_SUCCESS)
			{
                SetLastError( t_padvapi->LsaNtStatusToWinError(Status) );
                if ( t_padvapi )
				{
					CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidAdvApi32Api , t_padvapi ) ;
					t_padvapi = NULL ;
					return FALSE;
				}
            }

            //
            // obtain the AccountDomain, which is common to all three cases
            //
            Status = t_padvapi->LsaQueryInformationPolicy(
                PolicyHandle,
                PolicyAccountDomainInformation,
                (PVOID *)&AccountDomain
                );
        }

        if(Status == STATUS_SUCCESS)
        {

            try
            {
                //
                // Note: AccountDomain->DomainSid will contain binary Sid
                //
                achsTrustList.Add(CHString(AccountDomain->DomainName.Buffer));
            }
            catch ( ... )
            {
                t_padvapi->LsaFreeMemory(AccountDomain);
                throw ;
            }

            //
            // free memory allocated for account domain
            //
            t_padvapi->LsaFreeMemory(AccountDomain);

            //
            // find out if the target machine is a domain controller
            //

            if(!IsDomainController(NULL))
            {
				PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomain;
				CHString sPrimaryDomainName;

				//
				// get the primary domain
				//
				{
					Status = t_padvapi->LsaQueryInformationPolicy(
						PolicyHandle,
						PolicyPrimaryDomainInformation,
						(PVOID *)&PrimaryDomain
						);
				}

				if(Status == STATUS_SUCCESS)
				{

					//
					// if the primary domain Sid is NULL, we are a non-member, and
					// our work is done.
					//
					if(PrimaryDomain->Sid == NULL)
					{
						t_padvapi->LsaFreeMemory(PrimaryDomain);
						bSuccess = TRUE;

						t_padvapi->LsaClose(PolicyHandle);
						PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value
					}
					else
					{
						try
						{

							achsTrustList.Add(CHString(PrimaryDomain->Name.Buffer));

							//
							// build a copy of what we just added.  This is necessary in order
							// to lookup the domain controller for the specified domain.
							// the Domain name must be NULL terminated for NetGetDCName(),
							// and the LSA_UNICODE_STRING buffer is not necessarilly NULL
							// terminated.  Note that in a practical implementation, we
							// could just extract the element we added, since it ends up
							// NULL terminated.
							//

							sPrimaryDomainName = CHString(PrimaryDomain->Name.Buffer);

						}
						catch ( ... )
						{
							t_padvapi->LsaFreeMemory(PrimaryDomain);
							throw ;
						}

						t_padvapi->LsaFreeMemory(PrimaryDomain);

						//
						// get the primary domain controller computer name
						//
						LPWSTR DomainController = NULL;
						nas = NetGetDCName(
							NULL,
							sPrimaryDomainName,
							(LPBYTE *)&DomainController
							);

						if(nas == NERR_Success)
						{
							try
							{

								//
								// close the policy handle, because we don't need it anymore
								// for the workstation case, as we open a handle to a DC
								// policy below
								//
								{
									t_padvapi->LsaClose(PolicyHandle);
									PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value

									//
									// open the policy on the domain controller
									//
									Status = OpenPolicy(

										t_padvapi ,
										DomainController,
										POLICY_VIEW_LOCAL_INFORMATION,
										&PolicyHandle
										);
								}
							}
							catch ( ... )
							{
								NetApiBufferFree(DomainController);
								throw ;
							}

							//
							// free the domaincontroller buffer
							//
							NetApiBufferFree(DomainController);

							if(Status != STATUS_SUCCESS)
							{
								PolicyHandle = INVALID_HANDLE_VALUE;
							}
						}
						else
						{
							t_padvapi->LsaClose(PolicyHandle);
							PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value
						}
					}
				}
				else
				{
					t_padvapi->LsaClose(PolicyHandle);
					PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value
				}
			}

			//
			// build additional trusted domain(s) list and indicate if successful
			//
			if ((PolicyHandle != INVALID_HANDLE_VALUE) && (PolicyHandle != NULL))
			{
				bSuccess = EnumTrustedDomains(PolicyHandle, achsTrustList);
			}
		}

		 // close the policy handle
		 // policy handle is actually a pointer (per comments in the header)
		 // will check for NULL case
		 {
			 if ((PolicyHandle != INVALID_HANDLE_VALUE) && (PolicyHandle != NULL))
			 {
				 t_padvapi->LsaClose(PolicyHandle);
				 PolicyHandle = INVALID_HANDLE_VALUE ;
			 }
		 }

		 if(!bSuccess)
		 {
			 if(Status != STATUS_SUCCESS)
			 {
				 SetLastError( t_padvapi->LsaNtStatusToWinError(Status) );
			 }
			 else if(nas != NERR_Success)
			 {
				 SetLastError( nas );
			 }
		 }

		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidAdvApi32Api , t_padvapi ) ;
			t_padvapi = NULL ;
		}

		return bSuccess;
	 }
     catch ( ... )
     {
         if ((PolicyHandle != INVALID_HANDLE_VALUE) && (PolicyHandle != NULL))
         {
			 t_padvapi->LsaClose(PolicyHandle);
             PolicyHandle = INVALID_HANDLE_VALUE;
         }

		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidAdvApi32Api , t_padvapi ) ;
			t_padvapi = NULL ;
		}
		throw ;
     }
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32UserAccount::GetTrustedDomainsNT
//
//	Obtains Names of trusted domains and stuffs them in a user supplied
//	standard template library stack of _bstr_t's.
//
//	Inputs:		reference to stack of _bstr_t's
//
//	Outputs:	CHStringArray&	strarrayTrustedDomains;
//
//	Returns:	TRUE/FALSE		Success/Failure
//
//	Comments:
//
/////////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CNetAPI32::GetTrustedDomainsNT(std::vector<_bstr_t>& vectorTrustList)
{
    LSA_HANDLE PolicyHandle  = INVALID_HANDLE_VALUE;
    NTSTATUS Status =0;

    NET_API_STATUS nas = NERR_Success; // assume success

    BOOL bSuccess = FALSE; // assume this function will fail

    CAdvApi32Api *t_padvapi = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL) ;

	if( t_padvapi == NULL)
	{
        return FALSE;
    }

    try
    {
        PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomain = NULL;
        //
        // open the policy on the specified machine
        //
        {
            Status = OpenPolicy(

				t_padvapi,
				NULL,
                POLICY_VIEW_LOCAL_INFORMATION,
                &PolicyHandle
                );

            if(Status != STATUS_SUCCESS)
			{
                SetLastError( t_padvapi->LsaNtStatusToWinError(Status) );
				CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
				t_padvapi = NULL ;
                return FALSE;
            }

            //
            // obtain the AccountDomain, which is common to all three cases
            //
            Status = t_padvapi->LsaQueryInformationPolicy(
                PolicyHandle,
                PolicyAccountDomainInformation,
                (PVOID *)&AccountDomain
                );
        }

        if(Status == STATUS_SUCCESS)
        {

            try
            {
                //
                // Note: AccountDomain->DomainSid will contain binary Sid
                //
                _bstr_t t_bstrtTemp(AccountDomain->DomainName.Buffer);
                if(!AlreadyAddedToList(vectorTrustList, t_bstrtTemp))
                {
                    vectorTrustList.push_back(t_bstrtTemp);
                }
            }
            catch ( ... )
            {
                t_padvapi->LsaFreeMemory(AccountDomain);
                throw ;
            }

            //
            // free memory allocated for account domain
            //
            t_padvapi->LsaFreeMemory(AccountDomain);

            //
            // find out if the target machine is a domain controller
            //

            if(!IsDomainController(NULL))
            {
				PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomain;
				CHString sPrimaryDomainName;

				//
				// get the primary domain
				//
				{
					Status = t_padvapi->LsaQueryInformationPolicy(
						PolicyHandle,
						PolicyPrimaryDomainInformation,
						(PVOID *)&PrimaryDomain
						);
				}

				if(Status == STATUS_SUCCESS)
				{

					//
					// if the primary domain Sid is NULL, we are a non-member, and
					// our work is done.
					//
					if(PrimaryDomain->Sid == NULL)
					{
						t_padvapi->LsaFreeMemory(PrimaryDomain);
						bSuccess = TRUE;

						t_padvapi->LsaClose(PolicyHandle);
						PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value
					}
					else
					{
						try
						{

							_bstr_t t_bstrtTemp(PrimaryDomain->Name.Buffer) ;
							if(!AlreadyAddedToList(vectorTrustList, t_bstrtTemp))
							{
								vectorTrustList.push_back(t_bstrtTemp);
							}

							//
							// build a copy of what we just added.  This is necessary in order
							// to lookup the domain controller for the specified domain.
							// the Domain name must be NULL terminated for NetGetDCName(),
							// and the LSA_UNICODE_STRING buffer is not necessarilly NULL
							// terminated.  Note that in a practical implementation, we
							// could just extract the element we added, since it ends up
							// NULL terminated.
							//

							sPrimaryDomainName = PrimaryDomain->Name.Buffer;
						}
						catch ( ... )
						{
							t_padvapi->LsaFreeMemory(PrimaryDomain);
							throw ;
						}

						t_padvapi->LsaFreeMemory(PrimaryDomain);

						//
						// get the primary domain controller computer name
						//
						LPWSTR DomainController = NULL;
						nas = NetGetDCName(
							NULL,
							sPrimaryDomainName,
							(LPBYTE *)&DomainController
							);

						if(nas == NERR_Success)
						{
							try
							{

								//
								// close the policy handle, because we don't need it anymore
								// for the workstation case, as we open a handle to a DC
								// policy below
								//
								{
									t_padvapi->LsaClose(PolicyHandle);
									PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value

									//
									// open the policy on the domain controller
									//
									Status = OpenPolicy(

										t_padvapi ,
										DomainController,
										POLICY_VIEW_LOCAL_INFORMATION,
										&PolicyHandle
										);
								}
							}
							catch ( ... )
							{
								NetApiBufferFree(DomainController);
								throw ;
							}

							//
							// free the domaincontroller buffer
							//
							NetApiBufferFree(DomainController);

							if(Status != STATUS_SUCCESS)
							{
								PolicyHandle = INVALID_HANDLE_VALUE;
							}
						}
						else
						{
							t_padvapi->LsaClose(PolicyHandle);
							PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value
						}
					}
				}
				else
				{
					t_padvapi->LsaClose(PolicyHandle);
					PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value
				}
			}

			//
			// build additional trusted domain(s) list and indicate if successful
			//
			if ((PolicyHandle != INVALID_HANDLE_VALUE) && (PolicyHandle != NULL))
			{
				bSuccess = EnumTrustedDomains(PolicyHandle, vectorTrustList);
			}
		}

		 // close the policy handle
		 // policy handle is actually a pointer (per comments in the header)
		 // will check for NULL case
		 {
			 if ((PolicyHandle != INVALID_HANDLE_VALUE) && (PolicyHandle != NULL))
			 {
				 t_padvapi->LsaClose(PolicyHandle);
				PolicyHandle = INVALID_HANDLE_VALUE ;
			 }

		 }

		 if(!bSuccess)
		 {
			 if(Status != STATUS_SUCCESS)
			 {
				 SetLastError( t_padvapi->LsaNtStatusToWinError(Status) );
			 }
			 else if(nas != NERR_Success)
			 {
				 SetLastError( nas );
			 }
		 }

		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidAdvApi32Api , t_padvapi ) ;
			t_padvapi = NULL ;
		}

		return bSuccess;
     }
     catch ( ... )
     {

         if ((PolicyHandle != INVALID_HANDLE_VALUE) && (PolicyHandle != NULL))
         {
			 t_padvapi->LsaClose(PolicyHandle);
             PolicyHandle = INVALID_HANDLE_VALUE;
         }

		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidAdvApi32Api , t_padvapi ) ;
			t_padvapi = NULL ;
		}
		throw;
     }

}
#endif

///////////////////////////////////////////////////////

#ifdef NTONLY
BOOL CNetAPI32::EnumTrustedDomains(LSA_HANDLE PolicyHandle, CHStringArray &achsTrustList)
{
    LSA_ENUMERATION_HANDLE lsaEnumHandle=0; // start an enum
    PLSA_TRUST_INFORMATION TrustInfo = NULL ;
    ULONG ulReturned;               // number of items returned
    ULONG ulCounter;                // cunter for items returned
    NTSTATUS Status;

    CAdvApi32Api *t_padvapi = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL) ;
	if( t_padvapi == NULL)
    {
       return FALSE;
    }

    try
	{
		do
		{
			Status = t_padvapi->LsaEnumerateTrustedDomains(
							PolicyHandle,   // open policy handle
							&lsaEnumHandle, // enumeration tracker
							(PVOID *)&TrustInfo,     // buffer to receive data
							32000,          // recommended buffer size
							&ulReturned     // number of items returned
							);
			//
			// get out if an error occurred
			//
			if( (Status != STATUS_SUCCESS) &&
				(Status != STATUS_MORE_ENTRIES) &&
				(Status != STATUS_NO_MORE_ENTRIES)
				)
			{
				SetLastError( t_padvapi->LsaNtStatusToWinError(Status) );
				if ( t_padvapi )
				{
					CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
					t_padvapi = NULL ;
				}
				return FALSE;
			}

			//
			// Display results
			// Note: Sids are in TrustInfo[ulCounter].Sid
			//
			for(ulCounter = 0 ; ulCounter < ulReturned ; ulCounter++)
			{
			   achsTrustList.Add(CHString(TrustInfo[ulCounter].Name.Buffer));
			}

			//
			// free the buffer
			//
			if ( TrustInfo )
			{
				t_padvapi->LsaFreeMemory ( TrustInfo ) ;
				TrustInfo = NULL ;
			}

		} while (Status != STATUS_NO_MORE_ENTRIES);

		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
			t_padvapi = NULL ;
		}
		return TRUE;
	}
	catch ( ... )
	{
		if ( TrustInfo )
		{
			t_padvapi->LsaFreeMemory ( TrustInfo ) ;
			TrustInfo = NULL ;
		}
		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
		}
		throw ;
	}
}
#endif

///////////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CNetAPI32::EnumTrustedDomains(LSA_HANDLE PolicyHandle, std::vector<_bstr_t>& vectorTrustList)
{
    LSA_ENUMERATION_HANDLE lsaEnumHandle=0; // start an enum
    PLSA_TRUST_INFORMATION TrustInfo = NULL ;
    ULONG ulReturned;               // number of items returned
    ULONG ulCounter;                // counter for items returned
    NTSTATUS Status;

    CAdvApi32Api *t_padvapi = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL) ;
	if( t_padvapi == NULL )
    {
       return FALSE;
    }

	try
	{
		do {
			Status = t_padvapi->LsaEnumerateTrustedDomains(
							PolicyHandle,   // open policy handle
							&lsaEnumHandle, // enumeration tracker
							(PVOID *)&TrustInfo,     // buffer to receive data
							32000,          // recommended buffer size
							&ulReturned     // number of items returned
							);
			//
			// get out if an error occurred
			//
			if( (Status != STATUS_SUCCESS) &&
				(Status != STATUS_MORE_ENTRIES) &&
				(Status != STATUS_NO_MORE_ENTRIES)
				)
			{
				SetLastError( t_padvapi->LsaNtStatusToWinError(Status) );
				if ( t_padvapi )
				{
					CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
					t_padvapi = NULL ;
				}
				return FALSE;
			}

			//
			// Display results
			// Note: Sids are in TrustInfo[ulCounter].Sid
			//
			for(ulCounter = 0 ; ulCounter < ulReturned ; ulCounter++)
			{
				_bstr_t t_bstrtTemp(TrustInfo[ulCounter].Name.Buffer);
				if(!AlreadyAddedToList(vectorTrustList, t_bstrtTemp))
				{
					vectorTrustList.push_back(t_bstrtTemp);
				}
			}
			//
			// free the buffer
			//
			if ( TrustInfo )
			{
				t_padvapi->LsaFreeMemory(TrustInfo);
				TrustInfo = NULL ;
			}

		} while (Status != STATUS_NO_MORE_ENTRIES);

		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
			t_padvapi = NULL ;
		}

		return TRUE;
	}
	catch ( ... )
	{
		if ( TrustInfo )
		{
			t_padvapi->LsaFreeMemory ( TrustInfo ) ;
			TrustInfo = NULL ;
		}
		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
			t_padvapi = NULL ;
		}
		throw ;
	}
}
#endif
///////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
BOOL CNetAPI32::IsDomainController(LPTSTR Server)
{
    PSERVER_INFO_101 si101;
    BOOL bRet = FALSE;  // Gotta return something

    if (NetServerGetInfo(
        Server,
        101,    // info-level
        (LPBYTE *)&si101
        ) == NERR_Success) {

        if( (si101->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
            (si101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) ) {
            //
            // we are dealing with a DC
            //
            bRet = TRUE;
        } else {
            bRet = FALSE;
        }

        NetApiBufferFree(si101);
    }

    return bRet;
}
#endif

#ifdef NTONLY
void CNetAPI32::InitLsaString(PLSA_UNICODE_STRING LsaString, LPWSTR String )
{
    DWORD StringLength;

    if (String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;

        return;
    }

    StringLength = lstrlenW(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength = (USHORT) (StringLength + 1) * sizeof(WCHAR);
}
#endif

#ifdef NTONLY
NTSTATUS CNetAPI32::OpenPolicy( CAdvApi32Api * a_padvapi , LPWSTR ServerName, DWORD DesiredAccess, PLSA_HANDLE PolicyHandle)
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    if(ServerName != NULL)
	{
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString, ServerName);

        Server = &ServerString;
    }
	else
	{
        Server = NULL;
    }

    //
    // Attempt to open the policy
    //
    return a_padvapi->LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle
                );
}
#endif


bool CNetAPI32::AlreadyAddedToList(std::vector<_bstr_t> &vecbstrtList, _bstr_t &bstrtItem)
{
    _bstr_t t_bstrtTemp1;
    _bstr_t t_bstrtTemp2;

    for(LONG m = 0; m < vecbstrtList.size(); m++)
    {
        t_bstrtTemp1 = _tcsupr((LPTSTR)vecbstrtList[m]);
        t_bstrtTemp2 = _tcsupr((LPTSTR)bstrtItem);
        if(t_bstrtTemp1 == t_bstrtTemp2)
        {
            return TRUE;
        }
    }
    return FALSE;
}


#ifdef NTONLY
BOOL CNetAPI32::DsRolepGetPrimaryDomainInformationDownlevel
(
    DSROLE_MACHINE_ROLE &a_rMachineRole,
	DWORD &a_rdwWin32Err
)
{
    a_rdwWin32Err = ERROR_SUCCESS ;
	BOOL t_bRet = FALSE ;
    NTSTATUS t_Status ;
    LSA_HANDLE t_hPolicyHandle					= NULL ;
    PPOLICY_PRIMARY_DOMAIN_INFO t_pPDI			= NULL ;
    PPOLICY_LSA_SERVER_ROLE_INFO t_pServerRole	= NULL ;
    PPOLICY_ACCOUNT_DOMAIN_INFO t_pADI			= NULL ;
	NT_PRODUCT_TYPE t_ProductType ;

    a_rMachineRole = DsRole_RoleStandaloneServer ;

	CAdvApi32Api *t_padvapi = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL) ;
	if( t_padvapi == NULL)
    {
       return FALSE;
    }

	try
	{
		if ( !DsRolepGetProductTypeForServer ( t_ProductType , a_rdwWin32Err ) )
		{
			if ( a_rdwWin32Err == ERROR_SUCCESS )
			{
				a_rdwWin32Err = ERROR_UNKNOWN_PRODUCT ;
			}
			return t_bRet ;
		}

		{
			t_Status = OpenPolicy (

							t_padvapi ,
							NULL ,
							POLICY_VIEW_LOCAL_INFORMATION ,
							&t_hPolicyHandle
						);
		}

		if ( NT_SUCCESS( t_Status ) )
		{
			{
				t_Status = t_padvapi->LsaQueryInformationPolicy (

											t_hPolicyHandle ,
											PolicyPrimaryDomainInformation ,
											( PVOID * ) &t_pPDI
										) ;
			}

			if ( NT_SUCCESS ( t_Status ) )
			{
				switch ( t_ProductType )
				{
					case NtProductWinNt:
						{
							t_bRet = TRUE ;
							if ( t_pPDI->Sid == NULL )
							{
								a_rMachineRole = DsRole_RoleStandaloneWorkstation ;
							}
							else
							{
								a_rMachineRole = DsRole_RoleMemberWorkstation ;

							}
							break;
						}


					case NtProductServer:
						{
							t_bRet = TRUE ;
							if ( t_pPDI->Sid == NULL )
							{
								a_rMachineRole = DsRole_RoleStandaloneServer ;
							}
							else
							{
								a_rMachineRole = DsRole_RoleMemberServer ;
							}
							break;
						}

					case NtProductLanManNt:
						{
							{
								t_Status = t_padvapi->LsaQueryInformationPolicy (

															t_hPolicyHandle ,
															PolicyLsaServerRoleInformation ,
															( PVOID * )&t_pServerRole
														) ;
							}
							if ( NT_SUCCESS( t_Status ) )
							{
								if ( t_pServerRole->LsaServerRole == PolicyServerRolePrimary )
								{
									{
										//
										// If we think we're a primary domain controller, we'll need to
										// guard against the case where we're actually standalone during setup
										//
										t_Status = t_padvapi->LsaQueryInformationPolicy (

															t_hPolicyHandle,
															PolicyAccountDomainInformation ,
															( PVOID * )&t_pADI
													) ;
									}

									if ( NT_SUCCESS( t_Status ) )
									{
										t_bRet = TRUE ;
										if (	t_pPDI->Sid == NULL			||
												t_pADI->DomainSid == NULL	||
												! EqualSid ( t_pADI->DomainSid, t_pPDI->Sid )
											)
										{
											a_rMachineRole = DsRole_RoleStandaloneServer ;
										}
										else
										{
											a_rMachineRole = DsRole_RolePrimaryDomainController ;
										}
									}
								}
								else
								{
									t_bRet = TRUE ;
									a_rMachineRole = DsRole_RoleBackupDomainController;
								}
							}
							break;
						}

					default:
						{
							t_Status = STATUS_INVALID_PARAMETER;
							break;
						}
				}
			}

			if ( t_hPolicyHandle )
			{
				t_padvapi->LsaClose ( t_hPolicyHandle ) ;
				t_hPolicyHandle = NULL ;
			}

			if ( t_pPDI )
			{
				t_padvapi->LsaFreeMemory ( t_pPDI ) ;
				t_pPDI = NULL ;
			}

			if ( t_pADI != NULL )
			{
				t_padvapi->LsaFreeMemory( t_pADI ) ;
				t_pADI = NULL ;
			}

			if ( t_pServerRole != NULL )
			{
				t_padvapi->LsaFreeMemory( t_pServerRole ) ;
			}
		}

		a_rdwWin32Err = t_padvapi->LsaNtStatusToWinError( t_Status ) ;

		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
			t_padvapi = NULL ;
		}

		return t_bRet ;
	}

	catch ( ... )
	{
		if ( t_hPolicyHandle )
		{
			t_padvapi->LsaClose ( t_hPolicyHandle ) ;
			t_hPolicyHandle = NULL ;
		}

        if ( t_pPDI )
		{
			t_padvapi->LsaFreeMemory ( t_pPDI ) ;
			t_pPDI = NULL ;
		}

        if ( t_pADI != NULL )
		{
            t_padvapi->LsaFreeMemory( t_pADI ) ;
			t_pADI = NULL ;
        }

        if ( t_pServerRole != NULL )
		{
            t_padvapi->LsaFreeMemory( t_pServerRole ) ;
        }

		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
			t_padvapi = NULL ;
		}

		throw ;
	}
}


/*
 * This function will return true if it succeeds. If the return value is false & the Win32 error code in a_rdwWin32Err parameter
 * is ERROR_SUCCESS, that means we don't know what the product type is
 */
BOOL CNetAPI32::DsRolepGetProductTypeForServer
(
	NT_PRODUCT_TYPE &a_rProductType ,
	DWORD &a_rdwWin32Err
)
{
    HKEY t_hProductKey	= NULL ;
    PBYTE t_pBuffer		= NULL;
    ULONG t_lType, t_lSize = 0;
	BOOL t_bRet = FALSE ;

	try
	{
		a_rdwWin32Err = RegOpenKeyEx (

						HKEY_LOCAL_MACHINE,
						L"system\\currentcontrolset\\control\\productoptions",
						0,
						KEY_READ,
						&t_hProductKey
					) ;

		if ( a_rdwWin32Err == ERROR_SUCCESS )
		{
			a_rdwWin32Err = RegQueryValueEx (

							t_hProductKey,
							L"ProductType",
							0,
							&t_lType,
							0,
							&t_lSize
						) ;

			if ( a_rdwWin32Err == ERROR_SUCCESS )
			{
				t_pBuffer = new BYTE [t_lSize] ;

				if ( t_pBuffer )
				{
					a_rdwWin32Err = RegQueryValueEx(

										t_hProductKey,
										L"ProductType",
										0,
										&t_lType,
										t_pBuffer,
										&t_lSize
									) ;

					if ( a_rdwWin32Err == ERROR_SUCCESS )
					{
						t_bRet = TRUE ;
						if ( !_wcsicmp( ( PWSTR )t_pBuffer, L"LanmanNt" ) )
						{
							a_rProductType = NtProductLanManNt;
						}
						else if ( !_wcsicmp( ( PWSTR )t_pBuffer, L"ServerNt" ) )
						{
							a_rProductType = NtProductServer;
						}
						else if ( !_wcsicmp( ( PWSTR )t_pBuffer, L"WinNt" ) )
						{
							a_rProductType = NtProductWinNt;
						}
						else
						{
							t_bRet = FALSE ;
						}
					}

					delete [] t_pBuffer;
					t_pBuffer = NULL ;
				}
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}

			RegCloseKey ( t_hProductKey ) ;
			t_hProductKey = NULL ;
		}

		return t_bRet ;
	}

	catch ( ... )
	{
		if ( t_hProductKey )
		{
			RegCloseKey ( t_hProductKey ) ;
			t_hProductKey = NULL ;
		}

		if ( t_pBuffer )
		{
			delete [] t_pBuffer ;
			t_pBuffer = NULL ;
		}

		throw ;
	}
}
#endif


#ifdef NTONLY
DWORD CNetAPI32::GetDCName(
    LPCWSTR wstrDomain,
    CHString& chstrDCName)
{
    DWORD dwRet = ERROR_SUCCESS;

#if NTONLY < 5
    LPBYTE lpbBuff = NULL;

    dwRet = NetGetDCName(
        NULL, 
        wstrDomain, 
        &lpbBuff);

    if(dwRet == NO_ERROR)
    {
        try
        {
            chstrDCName = (LPCWSTR)lpbBuff;
        }
        catch(...)
        {
            NetApiBufferFree(lpbBuff);
            lpbBuff = NULL;
            throw;
        }

        NetApiBufferFree(lpbBuff);
        lpbBuff = NULL;
    }
    else
    {
        dwRet = NetGetAnyDCName(
            NULL,
            _bstr_t(wstrDomain),
            &lpbBuff);

        if(dwRet == NO_ERROR)
        {
            try
            {
                chstrDCName = (LPCWSTR)lpbBuff;
            }
            catch(...)
            {
                NetApiBufferFree(lpbBuff);
                lpbBuff = NULL;
                throw;
            }

            NetApiBufferFree(lpbBuff);
            lpbBuff = NULL;
        }
    }

#else
    PDOMAIN_CONTROLLER_INFO pDomInfo = NULL;
    
    dwRet = DsGetDcName(
        NULL, 
        wstrDomain, 
        NULL, 
        NULL, 
        /*DS_PDC_REQUIRED*/ 0, 
        &pDomInfo);

    if(dwRet != NO_ERROR)
    {
        dwRet = DsGetDcName(
            NULL, 
            wstrDomain, 
            NULL, 
            NULL, 
            /*DS_PDC_REQUIRED | */ DS_FORCE_REDISCOVERY, 
            &pDomInfo);
    }
    
    if(dwRet == NO_ERROR)
    {
        try
        {
            chstrDCName = pDomInfo->DomainControllerName;
        }
        catch(...)
        {
            NetApiBufferFree(pDomInfo);
            pDomInfo = NULL;
            throw;
        }

        NetApiBufferFree(pDomInfo);
        pDomInfo = NULL;
    }
    
#endif

    return dwRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\wbemnetapi32.h ===
//============================================================

//

// WBEMNetAPI32.h - NetAPI32.DLL access class definition

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 01/21/97     a-jmoon     created
//
//============================================================

#ifndef __WBEMNETAPI32__
#define __WBEMNETAPI32__

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmserver.h>
#include <lmerr.h>
#include <ntsecapi.h>
#include <stack>
#include <comdef.h>
#include <dsrole.h> // KMH 32414
#include <dsgetdc.h>

#include "netapi32api.h"
#include "svrapiapi.h"
#include "AdvApi32Api.h"


class CNetAPI32
{
    public :

        CNetAPI32() ;
       ~CNetAPI32() ;
        
        LONG Init() ;

#ifdef NTONLY
        // Use this version for all NT platforms.  It properly gets a DC rather than
        // requiring that the PDC be obtained.
        DWORD GetDCName(
            LPCWSTR wstrDomain,
            CHString& chstrDCName);
        
        // Determines if the specified server is a DC.  NULL means current machine
        BOOL IsDomainController(LPTSTR Server);

        // Returns an array of Trusted domains.  Includes the current domain.
        BOOL GetTrustedDomainsNT(CHStringArray& achsTrustList);
        // Overload, returns same, but as a stack of _bstr_t's
        BOOL GetTrustedDomainsNT(std::vector<_bstr_t>& vectorTrustList);

        NET_API_STATUS NET_API_FUNCTION NetGroupEnum(LPCWSTR servername, 
                                                     DWORD level, 
                                                     LPBYTE *bufptr,
                                                     DWORD prefmaxlen, 
                                                     LPDWORD entriesread,
                                                     LPDWORD totalentries, 
                                                     PDWORD_PTR resume_handle) ;

        NET_API_STATUS NET_API_FUNCTION NetLocalGroupEnum(LPCWSTR servername,
                                                          DWORD level,
                                                          LPBYTE *bufptr,
                                                          DWORD prefmaxlen,
                                                          LPDWORD entriesread,
                                                          LPDWORD totalentries,
                                                          PDWORD_PTR resumehandle) ;

        NET_API_STATUS NET_API_FUNCTION NetGroupGetInfo(LPCWSTR servername,
                                                        LPCWSTR groupname,
                                                        DWORD level,
                                                        LPBYTE *bufptr) ;

		NET_API_STATUS NET_API_FUNCTION NetGroupSetInfo(LPCWSTR servername,
                                                        LPCWSTR groupname,
                                                        DWORD level,
                                                        LPBYTE buf,
														LPDWORD parm_err) ;

        NET_API_STATUS NET_API_FUNCTION NetLocalGroupGetInfo(LPCWSTR servername,
                                                        LPCWSTR groupname,
                                                        DWORD level,
                                                        LPBYTE *bufptr) ;
	
		NET_API_STATUS NET_API_FUNCTION NetLocalGroupSetInfo(LPCWSTR servername,
                                                        LPCWSTR groupname,
                                                        DWORD level,
                                                        LPBYTE buf,
														LPDWORD a_parm_err ) ;

        NET_API_STATUS NET_API_FUNCTION NetGroupGetUsers(LPCWSTR servername,
                                                         LPCWSTR groupname,
                                                         DWORD level,
                                                         LPBYTE *bufptr,
                                                         DWORD prefmaxlen,
                                                         LPDWORD entriesread,
                                                         LPDWORD totalentries,
                                                         PDWORD_PTR ResumeHandle) ;
        
        NET_API_STATUS NET_API_FUNCTION NetLocalGroupGetMembers(LPCWSTR servername,
                                                         LPCWSTR groupname,
                                                         DWORD level,
                                                         LPBYTE *bufptr,
                                                         DWORD prefmaxlen,
                                                         LPDWORD entriesread,
                                                         LPDWORD totalentries,
                                                         PDWORD_PTR ResumeHandle) ;
        
        NET_API_STATUS NET_API_FUNCTION NetShareEnum(LPTSTR servername,
                                                     DWORD level,
                                                     LPBYTE *bufptr,
                                                     DWORD prefmaxlen,
                                                     LPDWORD entriesread,
                                                     LPDWORD totalentries,
                                                     LPDWORD resume_handle) ;

        NET_API_STATUS NET_API_FUNCTION NetShareGetInfo(LPTSTR servername,
                                                        LPTSTR netname,
                                                        DWORD level,
                                                        LPBYTE *bufptr) ;


		NET_API_STATUS NET_API_FUNCTION NetShareAdd (

			IN  LPTSTR  servername,
			IN  DWORD   level,
			IN  LPBYTE  buf,
			OUT LPDWORD parm_err
		);

		NET_API_STATUS NET_API_FUNCTION NetShareEnumSticky (

			IN  LPTSTR      servername,
			IN  DWORD       level,
			OUT LPBYTE      *bufptr,
			IN  DWORD       prefmaxlen,
			OUT LPDWORD     entriesread,
			OUT LPDWORD     totalentries,
			IN OUT LPDWORD  resume_handle
		);

		NET_API_STATUS NET_API_FUNCTION NetShareSetInfo (

			IN  LPTSTR  servername,
			IN  LPTSTR  netname,
			IN  DWORD   level,
			IN  LPBYTE  buf,
			OUT LPDWORD parm_err
		);

		NET_API_STATUS NET_API_FUNCTION NetShareDel (

			IN  LPTSTR  servername,
			IN  LPTSTR  netname,
			IN  DWORD   reserved
		);

		NET_API_STATUS NET_API_FUNCTION NetShareDelSticky (

			IN  LPTSTR  servername,
			IN  LPTSTR  netname,
			IN  DWORD   reserved
		);

		NET_API_STATUS NET_API_FUNCTION NetShareCheck (

			IN  LPTSTR  servername,
			IN  LPTSTR  device,
			OUT LPDWORD type
		);

		BOOL DsRolepGetPrimaryDomainInformationDownlevel (

			DSROLE_MACHINE_ROLE &a_rMachineRole,
			DWORD &a_rdwWin32Err
		) ;
#endif

#ifdef WIN9XONLY
        NET_API_STATUS NET_API_FUNCTION NetShareEnum95(char FAR *servername,
                                                     short level,
                                                     char FAR *bufptr,
                                                     unsigned short prefmaxlen,
                                                     unsigned short FAR *entriesread,
                                                     unsigned short FAR *totalentries);

        NET_API_STATUS NET_API_FUNCTION NetShareGetInfo95(char FAR *servername,
                                                        char FAR *netname,
                                                        short level,
                                                        char FAR *bufptr,
                                                        unsigned short buflen,
                                                        unsigned short FAR *totalavail) ;
		//svrapi.h
		NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareAdd95 (

			IN  const char FAR *	servername,
			IN  short				level,
			IN  const char FAR *	buf,
			unsigned short			cbBuffer 
		);

		NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareSetInfo95 (

			IN const char FAR *	servername,
			IN const char FAR *	netname,
			IN short			level,
			IN const char FAR*	buf,
			IN unsigned short   cbBuffer,
			IN short            sParmNum 
		) ;



		NET_API_STATUS NET_API_FUNCTION NetShareDel95 (

			IN  LPTSTR  servername,
			IN  LPTSTR  netname,
			IN  DWORD   reserved
		);

        NET_API_STATUS NET_API_FUNCTION NetServerGetInfo95(
            char FAR *servername,
            short level,
            char FAR *bufptr,
            unsigned short buflen,
            unsigned short FAR *totalavail);

#endif

#ifdef NTONLY
        NET_API_STATUS NET_API_FUNCTION NetUserEnum(LPCWSTR servername,
                                                    DWORD level,
                                                    DWORD filter,
                                                    LPBYTE *bufptr,
                                                    DWORD prefmaxlen,
                                                    LPDWORD entriesread,
                                                    LPDWORD totalentries,
                                                    LPDWORD resume_handle) ;

        NET_API_STATUS NET_API_FUNCTION NetUserGetInfo(LPCWSTR servername,
                                                       LPCWSTR username,
                                                       DWORD level,
                                                       LPBYTE *bufptr) ;

		NET_API_STATUS NET_API_FUNCTION NetUserSetInfo(  
														  
														LPCWSTR a_servername, 
														LPCWSTR a_username,   
														DWORD a_level,       
														LPBYTE a_buf,        
														LPDWORD a_parm_err
														) ;

        NET_API_STATUS NET_API_FUNCTION NetApiBufferFree(void *bufptr) ;

		NET_API_STATUS NET_API_FUNCTION NetQueryDisplayInformation(	LPWSTR ServerName,
																	DWORD Level,
																	DWORD Index,
																	DWORD EntriesRequested,
																	DWORD PreferredMaximumLength,
																	LPDWORD ReturnedEntryCount,
																	PVOID *SortedBuffer);

	    NET_API_STATUS NET_API_FUNCTION NetServerSetInfo(LPTSTR servername,
										      DWORD level,
										      LPBYTE  bufptr,
										      LPDWORD ParmError);

        NET_API_STATUS NET_API_FUNCTION NetServerGetInfo(LPTSTR servername,
                                            DWORD level,
                                            LPBYTE *bufptr);

        //KMH 32414
	    NET_API_STATUS NET_API_FUNCTION DSRoleGetPrimaryDomainInfo(LPCWSTR servername,
													      DSROLE_PRIMARY_DOMAIN_INFO_LEVEL level,
													      LPBYTE *bufptr);
	    NET_API_STATUS NET_API_FUNCTION DSRoleFreeMemory(LPBYTE bufptr);

		NET_API_STATUS NET_API_FUNCTION NetGetDCName(	LPCWSTR ServerName,
														LPCWSTR DomainName,
														LPBYTE* bufptr );

		// NT5 entry
		NET_API_STATUS NET_API_FUNCTION DsGetDcName(	LPCTSTR ComputerName, 
														LPCTSTR DomainName,
														GUID *DomainGuid, 
														LPCTSTR SiteName, 
														ULONG Flags,
														PDOMAIN_CONTROLLER_INFO *DomainControllerInfo );

        NET_API_STATUS NET_API_FUNCTION NetRenameMachineInDomain(   LPCWSTR a_lpServer,
                                                                    LPCWSTR a_lpNewMachineName,
                                                                    LPCWSTR a_lpAccount,
                                                                    LPCWSTR a_lpPassword,
                                                                    DWORD a_fRenameOptions);

		NET_API_STATUS NET_API_FUNCTION NetUnjoinDomain(	LPCWSTR lpServer,
															LPCWSTR lpAccount,
															LPCWSTR lpPassword,
															DWORD   fUnjoinOptions);

		NET_API_STATUS NET_API_FUNCTION NetJoinDomain( LPCWSTR lpServer,
														LPCWSTR lpDomain,
														LPCWSTR lpAccountOU,
														LPCWSTR lpAccount,
														LPCWSTR lpPassword,
														DWORD fJoinOptions);

		NET_API_STATUS NET_API_FUNCTION NetWkstaGetInfo(	LPWSTR ServerName,
															DWORD level,
															LPBYTE *bufptr );

		NET_API_STATUS NET_API_FUNCTION NetGetAnyDCName(LPWSTR ServerName,
														LPWSTR DomainName,
														LPBYTE* bufptr );

		NET_API_STATUS NET_API_FUNCTION NetServerEnum(	LPTSTR servername,
														DWORD level,
														LPBYTE *bufptr,
														DWORD prefmaxlen,
														LPDWORD entriesread,
														LPDWORD totalentries,
														DWORD servertype,
														LPTSTR domain,
														LPDWORD resume_handle );

		NET_API_STATUS NET_API_FUNCTION	NetEnumerateTrustedDomains(	LPWSTR servername,
																	LPWSTR* domainNames ) ;

		NET_API_STATUS NET_API_FUNCTION NetUserModalsGet(	LPWSTR servername,
															DWORD level,
															LPBYTE *bufptr );


		NET_API_STATUS NET_API_FUNCTION	NetScheduleJobAdd (

			IN      LPCWSTR         Servername  OPTIONAL,
			IN      LPBYTE          Buffer,
			OUT     LPDWORD         JobId
		);

		NET_API_STATUS NET_API_FUNCTION	NetScheduleJobDel (

			IN      LPCWSTR         Servername  OPTIONAL,
			IN      DWORD           MinJobId,
			IN      DWORD           MaxJobId
		);

		NET_API_STATUS NET_API_FUNCTION	NetScheduleJobEnum (

			IN      LPCWSTR         Servername              OPTIONAL,
			OUT     LPBYTE *        PointerToBuffer,
			IN      DWORD           PrefferedMaximumLength,
			OUT     LPDWORD         EntriesRead,
			OUT     LPDWORD         TotalEntries,
			IN OUT  LPDWORD         ResumeHandle
		);

		NET_API_STATUS NET_API_FUNCTION	NetScheduleJobGetInfo (

			IN      LPCWSTR         Servername              OPTIONAL,
			IN      DWORD           JobId,
			OUT     LPBYTE *        PointerToBuffer
		);

        NET_API_STATUS NET_API_FUNCTION NetUseGetInfo (

            IN LPCWSTR UncServerName OPTIONAL,
            IN LPCWSTR UseName,
            IN DWORD Level,
            OUT LPBYTE *BufPtr
        );
#endif

    private :
#ifdef NTONLY
        CNetApi32Api *m_pnetapi;
#endif
#ifdef WIN9XONLY
        CSvrApiApi   *m_psvrapi;
#endif

      NTSTATUS OpenPolicy( CAdvApi32Api * a_padvapi , LPWSTR ServerName, DWORD DesiredAccess, PLSA_HANDLE PolicyHandle);
      void InitLsaString(PLSA_UNICODE_STRING LsaString, LPWSTR String );
      BOOL EnumTrustedDomains(LSA_HANDLE PolicyHandle, CHStringArray &achsTrustList);
      // Overload of above to accept stl stack instead of a CHStringArray.
      BOOL EnumTrustedDomains(LSA_HANDLE PolicyHandle, std::vector<_bstr_t>& vectorTrustList);
      bool AlreadyAddedToList(std::vector<_bstr_t> &vecchsList, _bstr_t &bstrtItem);

#ifdef NTONLY
/*
 * This enumerated type taken from ntdef.h
 */
	  typedef enum _NT_PRODUCT_TYPE {
										NtProductWinNt = 1,
										NtProductLanManNt,
										NtProductServer
									} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;

		BOOL DsRolepGetProductTypeForServer (
			
			NT_PRODUCT_TYPE &a_rProductType ,
			DWORD &a_rdwWin32Err
		) ;
#endif

} ;

#endif // File inclusion
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\wbempsapi.cpp ===
//============================================================
//
// WBEMPSAPI.cpp - implementation of PSAPI.DLL access class
//
//  Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
// 01/21/97     a-jmoon     created
//
//============================================================

#include "precomp.h"
#include <winerror.h>
#include "WBEMPSAPI.h"
#include <strsafe.h>

#pragma warning(disable : 4995) 

#ifdef NTONLY

//
// resource management failures
//
extern BOOL bAddInstanceCreatorFailure ;

/**********************************************************************************************************
 * Register this class with the CResourceManager.
 **********************************************************************************************************/

// {A8CFDD23-C2D2-11d2-B352-00105A1F8569}
const GUID guidPSAPI =
{ 0xa8cfdd23, 0xc2d2, 0x11d2, { 0xb3, 0x52, 0x0, 0x10, 0x5a, 0x1f, 0x85, 0x69 } };


class CPSAPICreatorRegistration
{
public:
	CPSAPICreatorRegistration ()
	{
		try
		{
			BOOL bNonFailure = 
			CResourceManager::sm_TheResourceManager.AddInstanceCreator ( guidPSAPI, CPSAPICreator ) ;

			if ( FALSE == bNonFailure )
			{
				bAddInstanceCreatorFailure = TRUE ;
			}
		}
		catch ( CHeap_Exception& e_HE )
		{
			bAddInstanceCreatorFailure = TRUE ;
		}
	}
	~CPSAPICreatorRegistration	()
	{}

	static CResource * CPSAPICreator ( PVOID pData )
	{
		CPSAPI *t_pPsapi = new CPSAPI ;
		if ( !t_pPsapi )
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
		return t_pPsapi ;
	}
};

CPSAPICreatorRegistration MyCPSAPICreatorRegistration ;
/**********************************************************************************************************/


/*****************************************************************************
 *
 *  FUNCTION    : CPSAPI::CPSAPI
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CPSAPI::CPSAPI() : CTimedDllResource () {

    hLibHandle  = NULL ;
	Init () ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CPSAPI::~CPSAPI
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CPSAPI::~CPSAPI() {

    if(hLibHandle != NULL) {

        FreeLibrary(hLibHandle) ;
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : CPSAPI::Init
 *
 *  DESCRIPTION : Loads CSAPI.DLL, locates entry points
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : ERROR_SUCCESS or windows error code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

LONG CPSAPI::Init() {

    // Try to load CSAPI.DLL
    //======================

    if(hLibHandle == NULL) {

        hLibHandle = LoadLibrary(_T("PSAPI.DLL")) ;

        if(hLibHandle == NULL) {

			// this is possible to be neccessary in the future !!!
			// resource manager may start to care about error from load library
			//
			// let resource manager know load failed
			//
			m_bValid = FALSE;
			m_dwCreationError = ::GetLastError ();

            LogErrorMessage(L"Failed to load library psapi.dll");
        }
        else {

            // Find the entry points
            //======================
            pEnumProcesses           = (PSAPI_ENUM_PROCESSES)   GetProcAddress(hLibHandle, "EnumProcesses") ;
            pEnumDeviceDrivers       = (PSAPI_ENUM_DRIVERS)     GetProcAddress(hLibHandle, "EnumDeviceDrivers") ;
            pEnumProcessModules      = (PSAPI_ENUM_MODULES)     GetProcAddress(hLibHandle, "EnumProcessModules") ;
            pGetProcessMemoryInfo    = (PSAPI_GET_MEMORY_INFO)  GetProcAddress(hLibHandle, "GetProcessMemoryInfo") ;

#ifdef UNICODE
            pGetDeviceDriverBaseName = (PSAPI_GET_DRIVER_NAME)  GetProcAddress(hLibHandle, "GetDeviceDriverBaseNameW") ;
            pGetModuleBaseName       = (PSAPI_GET_MODULE_NAME)  GetProcAddress(hLibHandle, "GetModuleBaseNameW") ;
            pGetDeviceDriverFileName = (PSAPI_GET_DRIVER_EXE)   GetProcAddress(hLibHandle, "GetDeviceDriverFileNameW") ;
            pGetModuleFileNameEx     = (PSAPI_GET_MODULE_EXE)   GetProcAddress(hLibHandle, "GetModuleFileNameExW") ;
#else
            pGetDeviceDriverBaseName = (PSAPI_GET_DRIVER_NAME)  GetProcAddress(hLibHandle, "GetDeviceDriverBaseNameA") ;
            pGetModuleBaseName       = (PSAPI_GET_MODULE_NAME)  GetProcAddress(hLibHandle, "GetModuleBaseNameA") ;
            pGetDeviceDriverFileName = (PSAPI_GET_DRIVER_EXE)   GetProcAddress(hLibHandle, "GetDeviceDriverFileNameA") ;
            pGetModuleFileNameEx     = (PSAPI_GET_MODULE_EXE)   GetProcAddress(hLibHandle, "GetModuleFileNameExA") ;
#endif

            if(pEnumProcesses           == NULL ||
               pEnumDeviceDrivers       == NULL ||
               pEnumProcessModules      == NULL ||
               pGetDeviceDriverBaseName == NULL ||
               pGetModuleBaseName       == NULL ||
               pGetDeviceDriverFileName == NULL ||
               pGetModuleFileNameEx     == NULL ||
               pGetProcessMemoryInfo    == NULL) {

                // Couldn't get one or more entry points
                //======================================

                FreeLibrary(hLibHandle) ;
                hLibHandle = NULL ;

				// this is possible to be neccessary in the future !!!
				// resource manager may start to care about error from load library
				//
				// let resource manager know load failed
				//
				m_bValid = FALSE;
				m_dwCreationError = ERROR_PROC_NOT_FOUND;

				::SetLastError (ERROR_PROC_NOT_FOUND);

                LogErrorMessage(L"Failed find entrypoint in wbempsapi");
            }
        }
    }

    return m_dwCreationError ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CPSAPI::EnumProcesses
 *                CPSAPI::EnumDeviceDrivers
 *                CPSAPI::EnumProcessModules
 *                CPSAPI::GetDeviceDriverBaseName
 *                CPSAPI::GetModuleBaseName
 *                CPSAPI::GetDeviceDriverFileName
 *                CPSAPI::GetModuleFileNameEx
 *                CPSAPI::GetProcessMemoryInfo
 *
 *  DESCRIPTION : CSAPI function wrappers
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : CSAPI return codes
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CPSAPI::EnumProcesses(DWORD *pdwPIDList, DWORD dwListSize, DWORD *pdwByteCount) {

    if(hLibHandle == NULL) {

        return FALSE ;
    }

    return pEnumProcesses(pdwPIDList, dwListSize, pdwByteCount) ;
}

BOOL CPSAPI::EnumDeviceDrivers(LPVOID pImageBaseList, DWORD dwListSize, DWORD *pdwByteCount) {

    if(hLibHandle == NULL) {

        return FALSE ;
    }

    return pEnumDeviceDrivers(pImageBaseList, dwListSize, pdwByteCount) ;
}

BOOL CPSAPI::EnumProcessModules(HANDLE hProcess, HMODULE *ModuleList,
                                DWORD dwListSize, DWORD *pdwByteCount) {

    if(hLibHandle == NULL) {

        return FALSE ;
    }

    return pEnumProcessModules(hProcess, ModuleList, dwListSize, pdwByteCount) ;
}

DWORD CPSAPI::GetDeviceDriverBaseName(LPVOID pImageBase, LPTSTR pszName, DWORD dwNameSize) {

    if(hLibHandle == NULL) {

        return 0 ;
    }

    return pGetDeviceDriverBaseName(pImageBase, pszName, dwNameSize) ;
}

DWORD CPSAPI::GetModuleBaseName(HANDLE hProcess, HMODULE hModule,
                                LPTSTR pszName, DWORD dwNameSize) {

    if(hLibHandle == NULL) {

        return 0 ;
    }

    return pGetModuleBaseName(hProcess, hModule, pszName, dwNameSize) ;
}

DWORD CPSAPI::GetDeviceDriverFileName(LPVOID pImageBase, LPTSTR pszName, DWORD dwNameSize) {

    if(hLibHandle == NULL) {

        return 0 ;
    }

    return pGetDeviceDriverFileName(pImageBase, pszName, dwNameSize) ;
}

DWORD CPSAPI::GetModuleFileNameEx(HANDLE hProcess, HMODULE hModule,
                                  LPTSTR pszName, DWORD dwNameSize)
{
    if (hLibHandle == NULL)
        return 0;

    DWORD dwRet = pGetModuleFileNameEx(hProcess, hModule, pszName, dwNameSize);

    if (dwRet)
    {
        // GetModuleFileNameEx sometimes returns some funky things like:
        // \\??\\C:\\blah\\...
        // \\SystemRoot\\system32\\blah\\..
        CHString strFilename = pszName;

        // If it starts with "\\??\\" get rid of it.
        if (strFilename.Find(_T("\\??\\")) == 0)
            lstrcpy(pszName, strFilename.Mid(sizeof(_T("\\??\\"))/sizeof(TCHAR) - 1));
        else if (strFilename.Find(_T("\\SystemRoot\\")) == 0)
        {
            
            if(GetWindowsDirectory(pszName, dwNameSize)){

                // Leave off that last '\\' so we seperate c:\\winnt from the
                // rest of the path.
                StringCchCat(pszName, dwNameSize, strFilename.Mid(sizeof(_T("\\SystemRoot"))/sizeof(TCHAR) - 1));
            }
        }
    }

    return dwRet;
}

BOOL CPSAPI::GetProcessMemoryInfo(HANDLE hProcess,
                                  PROCESS_MEMORY_COUNTERS *pMemCtrs,
                                  DWORD dwByteCount) {

    if(hLibHandle == NULL) {

        return 0 ;
    }

    return pGetProcessMemoryInfo(hProcess, pMemCtrs, dwByteCount) ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\wbempsapi.h ===
//============================================================

//

// WBEMPSAPI.h - PSAPI.DLL access class definition

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 01/21/97     a-jmoon     created
//
//============================================================

#ifndef __WBEMPSAPI__
#define __WBEMPSAPI__

#ifdef NTONLY
#include <psapi.h>

/**********************************************************************************************************
 * #includes to Register this class with the CResourceManager. 
 **********************************************************************************************************/
#include "ResourceManager.h"
#include "TimedDllResource.h"
extern const GUID guidPSAPI ;


typedef BOOL  (WINAPI *PSAPI_ENUM_PROCESSES) (DWORD    *pdwPIDList,        // Pointer to DWORD array
                                              DWORD     dwListSize,        // Size of array
                                              DWORD    *pdwByteCount) ;    // Bytes needed/returned

typedef BOOL  (WINAPI *PSAPI_ENUM_DRIVERS)   (LPVOID    pImageBaseList,    // Pointer to void * array
                                              DWORD     dwListSize,        // Size of array
                                              DWORD    *pdwByteCount) ;    // Bytes needed/returned

typedef BOOL  (WINAPI *PSAPI_ENUM_MODULES)   (HANDLE    hProcess,          // Process to query
                                              HMODULE  *pModuleList,       // Array of HMODULEs
                                              DWORD     dwListSize,        // Size of array
                                              DWORD    *pdwByteCount) ;    // Bytes needed/returned

typedef DWORD (WINAPI *PSAPI_GET_DRIVER_NAME)(LPVOID    pImageBase,        // Address of driver to query
                                              LPTSTR     pszName,          // Pointer to name buffer
                                              DWORD     dwNameSize) ;      // Size of buffer

typedef DWORD (WINAPI *PSAPI_GET_MODULE_NAME)(HANDLE    hProcess,          // Process to query
                                              HMODULE   hModule,           // Module to query
                                              LPTSTR     pszName,          // Pointer to name buffer
                                              DWORD     dwNameSize) ;      // Size of buffer

typedef DWORD (WINAPI *PSAPI_GET_DRIVER_EXE) (LPVOID    pImageBase,        // Address of driver to query
                                              LPTSTR     pszName,          // Pointer to name buffer
                                              DWORD     dwNameSize) ;      // Size of buffer

typedef DWORD (WINAPI *PSAPI_GET_MODULE_EXE) (HANDLE    hProcess,          // Process to query
                                              HMODULE   hModule,           // Module to query
                                              LPTSTR     pszName,          // Pointer to name buffer
                                              DWORD     dwNameSize) ;      // Size of buffer

typedef BOOL  (WINAPI *PSAPI_GET_MEMORY_INFO)(HANDLE    hProcess,          // Process to query
                                              PROCESS_MEMORY_COUNTERS *pMemCtrs,    // Memory counter struct
                                              DWORD     dwByteCount) ;     // Size of buffer

class CPSAPI : public CTimedDllResource
{
    public :

        CPSAPI() ;
       ~CPSAPI() ;
        
        LONG Init() ;

        BOOL EnumProcesses(DWORD *pdwPIDList, DWORD dwListSize, DWORD *pdwByteCount) ;

        BOOL EnumDeviceDrivers(LPVOID pImageBaseList, DWORD dwListSize, DWORD *pdwByteCount) ;

        BOOL EnumProcessModules(HANDLE hProcess, HMODULE *ModuleList, DWORD dwListSize, DWORD *pdwByteCount) ;

        DWORD GetDeviceDriverBaseName(LPVOID pImageBase, LPTSTR pszName, DWORD dwNameSize) ;

        DWORD GetModuleBaseName(HANDLE hProcess, HMODULE hModule, LPTSTR pszName, DWORD dwNameSize) ;

        DWORD GetDeviceDriverFileName(LPVOID pImageBase, LPTSTR pszName, DWORD dwNameSize) ;

        DWORD GetModuleFileNameEx(HANDLE hProcess, HMODULE hModule, LPTSTR pszName, DWORD dwNameSize) ;

        BOOL  GetProcessMemoryInfo(HANDLE hProcess, PROCESS_MEMORY_COUNTERS *pMemCtrs, DWORD dwByteCount) ;

    private :

        HINSTANCE hLibHandle ;

        PSAPI_ENUM_PROCESSES    pEnumProcesses ;
        PSAPI_ENUM_DRIVERS      pEnumDeviceDrivers ;
        PSAPI_ENUM_MODULES      pEnumProcessModules ;
        PSAPI_GET_DRIVER_NAME   pGetDeviceDriverBaseName ;
        PSAPI_GET_MODULE_NAME   pGetModuleBaseName ;
        PSAPI_GET_DRIVER_EXE    pGetDeviceDriverFileName ;
        PSAPI_GET_MODULE_EXE    pGetModuleFileNameEx ;
        PSAPI_GET_MEMORY_INFO   pGetProcessMemoryInfo ;
} ;
#endif

#endif // File inclusion
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\winmmapi.cpp ===
//=================================================================

//

// WinmmApi.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <cominit.h>

#include <lmuse.h>
#include "DllWrapperBase.h"
#include <mmreg.h>
#include <mmsystem.h>
#include <msacm.h>
#include "WinmmApi.h"
#include "DllWrapperCreatorReg.h"

// {F54DB7BF-0FB4-11d3-910C-00105AA630BE}
static const GUID g_guidWinmmApi =
{ 0xf54db7bf, 0xfb4, 0x11d3, { 0x91, 0xc, 0x0, 0x10, 0x5a, 0xa6, 0x30, 0xbe } };

static const TCHAR g_tstrWinmm [] = _T("Winmm.Dll");

/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CWinmmApi, &g_guidWinmmApi, g_tstrWinmm> MyRegisteredWinmmWrapper;

/******************************************************************************
 * Constructor
 *****************************************************************************/
CWinmmApi::CWinmmApi(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
	m_pfnwaveOutGetNumDevs (NULL),
	m_pfnwaveOutGetDevCaps(NULL)
{
}

/******************************************************************************
 * Destructor
 *****************************************************************************/
CWinmmApi::~CWinmmApi()
{
}

/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 ******************************************************************************/
bool CWinmmApi::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
		m_pfnwaveOutGetNumDevs = ( PFN_Winmm_waveOutGetNumDevs ) GetProcAddress ( "waveOutGetNumDevs" ) ;

#ifdef UNICODE
		m_pfnwaveOutGetDevCaps = ( PFN_Winmm_waveOutGetDevCaps ) GetProcAddress ( "waveOutGetDevCapsW" ) ;
#else
		m_pfnwaveOutGetDevCaps = ( PFN_Winmm_waveOutGetDevCaps ) GetProcAddress ( "waveOutGetDevCapsA" ) ;
#endif
    }

    // We require these function for all versions of this dll.

	if ( m_pfnwaveOutGetNumDevs == NULL ||
		 m_pfnwaveOutGetDevCaps == NULL )
	{
        fRet = false;
        LogErrorMessage(L"Failed find entrypoint in winmmapi");
	}

    return fRet;
}

/******************************************************************************
 * Member functions wrapping Tapi api functions. Add new functions here
 * as required.
 *****************************************************************************/

UINT CWinmmApi :: WinMMwaveOutGetNumDevs (

	void
)
{
	return m_pfnwaveOutGetNumDevs () ;
}

#ifdef UNICODE
MMRESULT CWinmmApi :: WinmmwaveOutGetDevCaps (

	UINT_PTR uDeviceID,
	LPWAVEOUTCAPSW pwoc,
	UINT cbwoc
)
#else
MMRESULT CWinmmApi :: WinmmwaveOutGetDevCaps (

	UINT_PTR uDeviceID,
	LPWAVEOUTCAPSA pwoc,
	UINT cbwoc
)
#endif
{
	return m_pfnwaveOutGetDevCaps (

		uDeviceID,
		pwoc,
		cbwoc
	) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\winmmapi.h ===
//=================================================================

//

// WinmmApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_WinmmApi_H_
#define	_WinmmApi_H_

#include <mmsystem.h>

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidWinmmApi;
extern const TCHAR g_tstrWinmm[];

/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

typedef UINT (WINAPI *PFN_Winmm_waveOutGetNumDevs )
(
	void
) ;

#ifdef UNICODE
typedef MMRESULT (WINAPI *PFN_Winmm_waveOutGetDevCaps )
(
	UINT_PTR uDeviceID, 
	LPWAVEOUTCAPSW pwoc, 
	UINT cbwoc
);
#else
typedef MMRESULT (WINAPI *PFN_Winmm_waveOutGetDevCaps )
(
	UINT_PTR uDeviceID, 
	LPWAVEOUTCAPSA pwoc, 
	UINT cbwoc
);
#endif


/******************************************************************************
 * Wrapper class for Tapi load/unload, for registration with CResourceManager. 
 *****************************************************************************/
class CWinmmApi : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to Tapi functions.
    // Add new functions here as required.

	PFN_Winmm_waveOutGetNumDevs m_pfnwaveOutGetNumDevs ;
	PFN_Winmm_waveOutGetDevCaps m_pfnwaveOutGetDevCaps ;

public:

    // Constructor and destructor:
    CWinmmApi(LPCTSTR a_tstrWrappedDllName);
    ~CWinmmApi();

    // Initialization function to check function pointers.
    virtual bool Init();

    // Member functions wrapping Tapi functions.
    // Add new functions here as required:

	UINT WinMMwaveOutGetNumDevs (

		void
	) ;

#ifdef UNICODE
	MMRESULT WinmmwaveOutGetDevCaps (

		UINT_PTR uDeviceID, 
		LPWAVEOUTCAPSW pwoc, 
		UINT cbwoc
	);
#else
	MMRESULT WinmmwaveOutGetDevCaps (

		UINT_PTR uDeviceID, 
		LPWAVEOUTCAPSA pwoc, 
		UINT cbwoc
	);
#endif

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\winspoolapi.cpp ===
//=================================================================

//

// WinSpoolApi.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>

#include "DllWrapperBase.h"
#include "WinSpoolApi.h"
#include "DllWrapperCreatorReg.h"


// {77609C22-CDAA-11d2-911E-0060081A46FD}
static const GUID g_guidWinSpoolApi =
{ 0x3b8515f1, 0xefd, 0x11d3, { 0x91, 0xc, 0x0, 0x10, 0x5a, 0xa6, 0x30, 0xbe } };

static const TCHAR g_tstrWinSpool[] = _T("WinSpool.Drv");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CWinSpoolApi, &g_guidWinSpoolApi, g_tstrWinSpool> MyRegisteredWinSpoolWrapper;


/******************************************************************************
 * Constructor
 *****************************************************************************/
CWinSpoolApi::CWinSpoolApi(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnClosePrinter (NULL),
   m_pfnDeviceCapabilities (NULL),
   m_pfnDocumentProperties (NULL),
   m_pfnEnumJobs (NULL),
   m_pfnEnumPrinterDrivers (NULL),
   m_pfnEnumPrinters (NULL),
   m_pfnEnumPorts (NULL),
   m_pfnGetJob (NULL),
   m_pfnGetPrinter (NULL),
   m_pfnGetPrinterDriver (NULL),
   m_pfnSetPrinter (NULL),
   m_pfnOpenPrinter (NULL),
   m_pfnGetDefaultPrinter(NULL),
   m_hPrintMutex(NULL),
   m_pfnSetJob (NULL),
   m_pfnDeletePrinter (NULL),
   m_pfnSetDefaultPrinter(NULL)
#if NTONLY >= 5
   ,
   m_pfnXcvData(NULL),
   m_pfnAddPrinterConnection(NULL),
   m_pfnDeletePrinterConnection(NULL)
#endif
{
#ifdef WIN9XONLY
	m_hPrintMutex = ::CreateMutex( NULL, FALSE, PRINTER_NAMED_MUTEX ) ;
#endif
}


/******************************************************************************
 * Destructor
 *****************************************************************************/
CWinSpoolApi::~CWinSpoolApi()
{
#ifdef WIN9XONLY
	if( m_hPrintMutex )
	{
		ReleaseMutex( m_hPrintMutex ) ;
	}
#endif
}

/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 ******************************************************************************/
bool CWinSpoolApi::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
#ifdef UNICODE
		m_pfnClosePrinter       = ( PFN_WinSpool_ClosePrinter )       GetProcAddress ( "ClosePrinter" ) ;
		m_pfnDeviceCapabilities = ( PFN_WinSpool_DeviceCapabilities ) GetProcAddress ( "DeviceCapabilitiesW" ) ;
		m_pfnDocumentProperties = ( PFN_WinSpool_DocumentProperties ) GetProcAddress ( "DocumentPropertiesW" ) ;
		m_pfnEnumJobs           = ( PFN_WinSpool_EnumJobs )           GetProcAddress ( "EnumJobsW" ) ;
		m_pfnEnumPrinterDrivers = ( PFN_WinSpool_EnumPrinterDrivers ) GetProcAddress ( "EnumPrinterDriversW" ) ;
		m_pfnEnumPrinters       = ( PFN_WinSpool_EnumPrinters )       GetProcAddress ( "EnumPrintersW" ) ;
		m_pfnEnumPorts          = ( PFN_WinSpool_EnumPorts )          GetProcAddress ( "EnumPortsW" ) ;
		m_pfnGetJob             = ( PFN_WinSpool_GetJob )             GetProcAddress ( "GetJobW" ) ;
		m_pfnGetPrinter         = ( PFN_WinSpool_GetPrinter )         GetProcAddress ( "GetPrinterW" ) ;
		m_pfnGetPrinterDriver   = ( PFN_WinSpool_GetPrinterDriver )   GetProcAddress ( "GetPrinterDriverW" ) ;
		m_pfnSetPrinter         = ( PFN_WinSpool_SetPrinter )         GetProcAddress ( "SetPrinterW" ) ;
		m_pfnOpenPrinter        = ( PFN_WinSpool_OpenPrinter )        GetProcAddress ( "OpenPrinterW" ) ;
		m_pfnSetJob         	= ( PFN_WinSpool_SetJob )             GetProcAddress ( "SetJobW" );
		m_pfnDeletePrinter  	= ( PFN_WinSpool_DeletePrinter )      GetProcAddress ( "DeletePrinter" );

#if NTONLY == 5
		m_pfnGetDefaultPrinter  = ( PFN_WinSpool_GetDefaultPrinter )  GetProcAddress ( "GetDefaultPrinterW" ) ;
		m_pfnSetDefaultPrinter  = ( PFN_WinSpool_SetDefaultPrinter )  GetProcAddress ( "SetDefaultPrinterW" ) ;
                m_pfnXcvData            = ( PFN_WinSpool_XcvData )            GetProcAddress ( "XcvDataW" ) ;
                m_pfnAddPrinterConnection    = ( PFN_WinSpool_AddPrinterConnection)    GetProcAddress ( "AddPrinterConnectionW" );
                m_pfnDeletePrinterConnection = ( PFN_WinSpool_DeletePrinterConnection) GetProcAddress ( "DeletePrinterConnectionW" );
#endif

#else
		m_pfnClosePrinter       = ( PFN_WinSpool_ClosePrinter )       GetProcAddress ( "ClosePrinter" ) ;
		m_pfnDeviceCapabilities = ( PFN_WinSpool_DeviceCapabilities ) GetProcAddress ( "DeviceCapabilitiesA" ) ;
		m_pfnDocumentProperties = ( PFN_WinSpool_DocumentProperties ) GetProcAddress ( "DocumentPropertiesA" ) ;
		m_pfnEnumJobs           = ( PFN_WinSpool_EnumJobs )           GetProcAddress ( "EnumJobsA" ) ;
		m_pfnEnumPrinterDrivers = ( PFN_WinSpool_EnumPrinterDrivers ) GetProcAddress ( "EnumPrinterDriversA" ) ;
		m_pfnEnumPrinters       = ( PFN_WinSpool_EnumPrinters )       GetProcAddress ( "EnumPrintersA" ) ;
		m_pfnEnumPorts          = ( PFN_WinSpool_EnumPorts )          GetProcAddress ( "EnumPortsA" ) ;
		m_pfnGetJob             = ( PFN_WinSpool_GetJob )             GetProcAddress ( "GetJobA" ) ;
		m_pfnGetPrinter         = ( PFN_WinSpool_GetPrinter )         GetProcAddress ( "GetPrinterA" ) ;
		m_pfnGetPrinterDriver   = ( PFN_WinSpool_GetPrinterDriver )   GetProcAddress ( "GetPrinterDriverA" ) ;
		m_pfnSetPrinter         = ( PFN_WinSpool_SetPrinter )         GetProcAddress ( "SetPrinterA" ) ;
		m_pfnOpenPrinter        = ( PFN_WinSpool_OpenPrinter )        GetProcAddress ( "OpenPrinterA" ) ;
		m_pfnSetJob	            = ( PFN_WinSpool_SetJob )             GetProcAddress ( "SetJobA" );
		m_pfnDeletePrinter	    = ( PFN_WinSpool_DeletePrinter )      GetProcAddress ( "DeletePrinter" );
#endif
    }

    // We require these function for all versions of this dll.

#if NTONLY == 5

   if ( m_pfnClosePrinter == NULL ||
	    m_pfnDeviceCapabilities == NULL ||
	    m_pfnDocumentProperties == NULL ||
	    m_pfnEnumJobs == NULL ||
	    m_pfnEnumPrinterDrivers == NULL ||
	    m_pfnEnumPrinters == NULL ||
		m_pfnEnumPorts == NULL ||
	    m_pfnGetJob == NULL ||
	    m_pfnGetPrinter == NULL ||
		m_pfnGetPrinterDriver == NULL ||
		m_pfnSetPrinter == NULL ||
	    m_pfnOpenPrinter == NULL ||
		m_pfnGetDefaultPrinter == NULL ||
		m_pfnSetJob	== NULL ||
		m_pfnDeletePrinter == NULL ||
		m_pfnSetDefaultPrinter == NULL ||
        m_pfnXcvData == NULL ||
        m_pfnAddPrinterConnection == NULL||
        m_pfnDeletePrinterConnection == NULL )
	{
        fRet = false;
        LogErrorMessage(L"Failed find entrypoint in winspoolapi");
	}

#else
	if ( m_pfnClosePrinter == NULL ||
	    m_pfnDeviceCapabilities == NULL ||
	    m_pfnDocumentProperties == NULL ||
	    m_pfnEnumJobs == NULL ||
	    m_pfnEnumPrinterDrivers == NULL ||
	    m_pfnEnumPrinters == NULL ||
	    m_pfnEnumPorts == NULL ||
	    m_pfnGetJob == NULL ||
	    m_pfnGetPrinter == NULL ||
	    m_pfnGetPrinterDriver == NULL ||
		m_pfnSetPrinter == NULL ||
	    m_pfnOpenPrinter == NULL ||
		m_pfnSetJob == NULL ||
		m_pfnDeletePrinter == NULL )
	{
        fRet = false;
        LogErrorMessage(L"Failed find entrypoint in winspoolapi");
	}
#endif

    return fRet;
}

/******************************************************************************
 * Member functions wrapping WinSpool api functions. Add new functions here
 * as required.
 *****************************************************************************/

BOOL CWinSpoolApi :: ClosePrinter (

	IN HANDLE hPrinter
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnClosePrinter ( hPrinter ) ;
}

#ifdef UNICODE
int CWinSpoolApi :: DeviceCapabilities (

	IN LPCWSTR pDevice ,
	IN LPCWSTR pPort,
	IN WORD fwCapability ,
	OUT LPWSTR pOutput ,
	IN CONST DEVMODEW *pDevMode
)
#else
int CWinSpoolApi :: DeviceCapabilities	(

	IN LPCSTR pDevice ,
	IN LPCSTR pPort,
	IN WORD fwCapability ,
	OUT LPCSTR pOutput,
	IN CONST DEVMODEA *pDevMode
)
#endif
{
	LOCK_WINSPOOL_9X ;

	return m_pfnDeviceCapabilities (
		
		pDevice ,
		pPort,
		fwCapability ,
		pOutput,
		pDevMode
	) ;
}

#ifdef UNICODE
LONG CWinSpoolApi :: DocumentProperties (

	IN HWND      hWnd,
	IN HANDLE    hPrinter,
	IN LPWSTR   pDeviceName,
	OUT PDEVMODEW pDevModeOutput,
	IN PDEVMODEW pDevModeInput,
	IN DWORD     fMode
)
#else
LONG CWinSpoolApi :: DocumentProperties (

	IN HWND      hWnd,
	IN HANDLE    hPrinter,
	IN LPSTR   pDeviceName,
	OUT PDEVMODEA pDevModeOutput,
	IN PDEVMODEA pDevModeInput,
	IN DWORD     fMode
)
#endif
{
	LOCK_WINSPOOL_9X ;

	return 	m_pfnDocumentProperties (
		
		hWnd,
		hPrinter,
		pDeviceName,
		pDevModeOutput,
		pDevModeInput,
		fMode
	) ;
}

BOOL CWinSpoolApi :: EnumJobs (

	IN HANDLE  hPrinter,
	IN DWORD   FirstJob,
	IN DWORD   NoJobs,
	IN DWORD   Level,
	OUT LPBYTE  pJob,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded,
	OUT LPDWORD pcReturned
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnEnumJobs (
		
		hPrinter,
		FirstJob,
		NoJobs,
		Level,
		pJob,
		cbBuf,
		pcbNeeded,
		pcReturned
	) ;
}

#ifdef UNICODE
BOOL CWinSpoolApi :: EnumPrinterDrivers (

	IN LPWSTR   pName,
	IN LPWSTR   pEnvironment,
	IN DWORD   Level,
	OUT LPBYTE  pDriverInfo,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded,
	OUT LPDWORD pcReturned
)
#else
BOOL CWinSpoolApi :: EnumPrinterDrivers (

	IN LPSTR   pName,
	IN LPSTR   pEnvironment,
	IN DWORD   Level,
	OUT LPBYTE  pDriverInfo,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded,
	OUT LPDWORD pcReturned
)
#endif
{
	LOCK_WINSPOOL_9X ;

	return m_pfnEnumPrinterDrivers (
		
		pName,
		pEnvironment,
		Level,
		pDriverInfo,
		cbBuf,
		pcbNeeded,
		pcReturned
	) ;
}

#ifdef UNICODE
BOOL CWinSpoolApi :: EnumPrinters (

	IN DWORD   Flags,
	IN LPWSTR Name,
	IN DWORD   Level,
	OUT LPBYTE  pPrinterEnum,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded,
	OUT LPDWORD pcReturned
)
#else
BOOL CWinSpoolApi :: EnumPrinters (

	IN DWORD   Flags,
	IN LPSTR Name,
	IN DWORD   Level,
	OUT LPBYTE  pPrinterEnum,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded,
	OUT LPDWORD pcReturned
)
#endif
{
	LOCK_WINSPOOL_9X ;

	return m_pfnEnumPrinters (

		Flags,
		Name,
		Level,
		pPrinterEnum,
		cbBuf,
		pcbNeeded,
		pcReturned
	) ;
}

#ifdef UNICODE
BOOL CWinSpoolApi :: EnumPorts (

	IN LPWSTR Name,
	IN DWORD   Level,
	OUT LPBYTE  pPortEnum,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded,
	OUT LPDWORD pcReturned
)
#else
BOOL CWinSpoolApi :: EnumPorts (

	IN LPSTR Name,
	IN DWORD   Level,
	OUT LPBYTE  pPortEnum,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded,
	OUT LPDWORD pcReturned
)
#endif
{
	LOCK_WINSPOOL_9X ;

	return m_pfnEnumPorts (

		Name,
		Level,
		pPortEnum,
		cbBuf,
		pcbNeeded,
		pcReturned
	) ;
}

BOOL CWinSpoolApi :: GetJob (

	IN HANDLE   hPrinter,
	IN DWORD    JobId,
	IN DWORD    Level,
	OUT LPBYTE   pJob,
	IN DWORD    cbBuf,
	OUT LPDWORD  pcbNeeded
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnGetJob (

		hPrinter,
		JobId,
		Level,
		pJob,
		cbBuf,
		pcbNeeded
	) ;
}

BOOL CWinSpoolApi :: SetJob (

	IN HANDLE   hPrinter,
	IN DWORD    JobId,
	IN DWORD    Level,
	IN LPBYTE   pJob,
	IN DWORD    cbBuf
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnSetJob (

		hPrinter,
		JobId,
		Level,
		pJob,
		cbBuf
	) ;
}

BOOL CWinSpoolApi :: GetPrinter (

	IN HANDLE  hPrinter,
	IN DWORD   Level,
	OUT LPBYTE  pPrinter,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnGetPrinter(

		hPrinter,
		Level,
		pPrinter,
		cbBuf,
		pcbNeeded
	) ;
}

BOOL CWinSpoolApi :: GetPrinterDriver (

	IN HANDLE  hPrinter,
	IN LPTSTR  pEnvironment,
	IN DWORD   Level,
	OUT LPBYTE  pPrinter,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnGetPrinterDriver(

		hPrinter,
		pEnvironment,
		Level,
		pPrinter,
		cbBuf,
		pcbNeeded
	) ;
}

BOOL CWinSpoolApi :: SetPrinter (

	IN HANDLE  hPrinter,
	IN DWORD   Level,
	IN LPBYTE  pPrinter,
	IN DWORD   cbBuf
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnSetPrinter(

		hPrinter,
		Level,
		pPrinter,
		cbBuf
	) ;
}

BOOL CWinSpoolApi :: DeletePrinter (

	IN HANDLE  hPrinter
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnDeletePrinter(

		hPrinter
	) ;
}

#ifdef UNICODE
BOOL CWinSpoolApi :: OpenPrinter (

	IN LPWSTR pPrinterName,
	OUT LPHANDLE phPrinter,
	IN LPPRINTER_DEFAULTSW pDefault
)
#else
BOOL CWinSpoolApi :: OpenPrinter (

	IN LPSTR pPrinterName,
	OUT LPHANDLE phPrinter,
	IN LPPRINTER_DEFAULTSA pDefault
)
#endif
{
	LOCK_WINSPOOL_9X ;

	return m_pfnOpenPrinter(

		pPrinterName,
		phPrinter,
		pDefault
	) ;
}

BOOL CWinSpoolApi :: GetDefaultPrinter (

    IN LPTSTR   pszBuffer,
    IN LPDWORD  pcchBuffer
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnGetDefaultPrinter(

		pszBuffer,
		pcchBuffer
	) ;
}

BOOL CWinSpoolApi :: SetDefaultPrinter (

    IN LPTSTR   pszBuffer
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnSetDefaultPrinter(

		pszBuffer
	) ;
}

#if NTONLY >= 5
BOOL CWinSpoolApi :: XcvData (
    IN  HANDLE  hXcv,
    IN  PCWSTR  pszDataName,
    IN  PBYTE   pInputData,
    IN  DWORD   cbInputData,
    OUT PBYTE   pOutputData,
    IN  DWORD   cbOutputData,
    OUT PDWORD  pcbOutputNeeded,
    OUT PDWORD  pdwStatus
    )
{
    return m_pfnXcvData(hXcv,
                        pszDataName,
                        pInputData,
                        cbInputData,
                        pOutputData,
                        cbOutputData,
                        pcbOutputNeeded,
                        pdwStatus);
}

BOOL CWinSpoolApi :: AddPrinterConnection(
    IN LPWSTR   pszBuffer
    )
{
    return m_pfnAddPrinterConnection(pszBuffer);
}

BOOL CWinSpoolApi :: DeletePrinterConnection(
    IN LPWSTR   pszBuffer
    )
{
    return m_pfnDeletePrinterConnection(pszBuffer);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\winspoolapi.h ===
//=================================================================

//

// WinSpoolApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_WinSpoolAPI_H_
#define	_WinSpoolAPI_H_

#include <winspool.h>

// Define a mutex class to single thread Winspool APIs under 9x
#ifdef WIN9XONLY

	#include <winbase.h>

	#define PRINTER_NAMED_MUTEX _T("WMI_Win_PrintSpool_Named_Mutex")

	class CPrintMutex
	{
	private:	

		HANDLE m_hHandle ;

	public:
		CPrintMutex()
		{ 
			if( m_hHandle = ::OpenMutex(MUTEX_ALL_ACCESS, TRUE, PRINTER_NAMED_MUTEX) ) 
			{
				WaitForSingleObject(m_hHandle, INFINITE);
			}
		}	
		~CPrintMutex() 
		{ 
			if( m_hHandle )
			{
				::ReleaseMutex( m_hHandle ) ;
			}
		}
  	};

	#define LOCK_WINSPOOL_9X CPrintMutex t_oWinSpool_abcdefg
#else
	#define LOCK_WINSPOOL_9X
#endif



/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidWinSpoolApi;
extern const TCHAR g_tstrWinSpool[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

typedef BOOL (WINAPI *PFN_WinSpool_AddPrinterConnection)
(
	IN LPWSTR pName
);

typedef BOOL (WINAPI *PFN_WinSpool_DeletePrinterConnection)
(
	IN LPWSTR pName
);


typedef BOOL (WINAPI *PFN_WinSpool_ClosePrinter)
(
	IN HANDLE hPrinter
);

#ifdef UNICODE
typedef int ( WINAPI *PFN_WinSpool_DeviceCapabilities )
(
	IN LPCWSTR, 
	IN LPCWSTR, 
	IN WORD,
    OUT LPWSTR, 
	IN CONST DEVMODEW *
);
#else
typedef int ( WINAPI *PFN_WinSpool_DeviceCapabilities)
(
	IN LPCSTR, 
	IN LPCSTR, 
	IN WORD,
    OUT LPCSTR, 
	IN CONST DEVMODEA *
);
#endif

#ifdef UNICODE
typedef LONG ( WINAPI *PFN_WinSpool_DocumentProperties )
(
    IN HWND      hWnd,
    IN HANDLE    hPrinter,
    IN LPWSTR   pDeviceName,
    OUT PDEVMODEW pDevModeOutput,
    IN PDEVMODEW pDevModeInput,
    IN DWORD     fMode
);
#else
typedef LONG ( WINAPI *PFN_WinSpool_DocumentProperties )
(
    IN HWND      hWnd,
    IN HANDLE    hPrinter,
    IN LPSTR   pDeviceName,
    OUT PDEVMODEA pDevModeOutput,
    IN PDEVMODEA pDevModeInput,
    IN DWORD     fMode
);
#endif

typedef BOOL ( WINAPI *PFN_WinSpool_EnumJobs )
(
    IN HANDLE  hPrinter,
    IN DWORD   FirstJob,
    IN DWORD   NoJobs,
    IN DWORD   Level,
    OUT LPBYTE  pJob,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);

#ifdef UNICODE
typedef BOOL ( WINAPI *PFN_WinSpool_EnumPrinterDrivers )
(
    IN LPWSTR   pName,
    IN LPWSTR   pEnvironment,
    IN DWORD   Level,
    OUT LPBYTE  pDriverInfo,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);
#else
typedef BOOL ( WINAPI *PFN_WinSpool_EnumPrinterDrivers )
(
    IN LPSTR   pName,
    IN LPSTR   pEnvironment,
    IN DWORD   Level,
    OUT LPBYTE  pDriverInfo,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);
#endif

#ifdef UNICODE
typedef BOOL ( WINAPI *PFN_WinSpool_EnumPrinters )
(
    IN DWORD   Flags,
    IN LPWSTR Name,
    IN DWORD   Level,
    OUT LPBYTE  pPrinterEnum,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);
#else
typedef BOOL ( WINAPI *PFN_WinSpool_EnumPrinters )
(
    IN DWORD   Flags,
    IN LPSTR Name,
    IN DWORD   Level,
    OUT LPBYTE  pPrinterEnum,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);
#endif

#ifdef UNICODE
typedef BOOL ( WINAPI *PFN_WinSpool_EnumPorts )
(
    IN LPWSTR Name,
    IN DWORD   Level,
    OUT LPBYTE  pPortEnum,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);
#else
typedef BOOL ( WINAPI *PFN_WinSpool_EnumPorts )
(
    IN LPSTR Name,
    IN DWORD   Level,
    OUT LPBYTE  pPortEnum,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);
#endif

typedef BOOL ( WINAPI *PFN_WinSpool_GetJob )
(
   IN HANDLE   hPrinter,
   IN DWORD    JobId,
   IN DWORD    Level,
   OUT LPBYTE   pJob,
   IN DWORD    cbBuf,
   OUT LPDWORD  pcbNeeded
);

typedef BOOL ( WINAPI *PFN_WinSpool_SetJob )
(
   IN HANDLE   hPrinter,
   IN DWORD    JobId,
   IN DWORD    Level,
   IN LPBYTE   pJob,
   IN DWORD    cbBuf
);

typedef BOOL ( WINAPI *PFN_WinSpool_GetPrinter )
(
    IN HANDLE  hPrinter,
    IN DWORD   Level,
    OUT LPBYTE  pPrinter,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded
);

typedef BOOL ( WINAPI *PFN_WinSpool_GetPrinterDriver )
(
    IN HANDLE  hPrinter,
	IN LPTSTR  pEnvironment,
    IN DWORD   Level,
    OUT LPBYTE  pPrinter,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded
);

typedef BOOL ( WINAPI *PFN_WinSpool_SetPrinter )
(
    IN HANDLE  hPrinter,
    IN DWORD   Level,
    IN LPBYTE  pPrinter,
    IN DWORD   cbBuf
);

typedef BOOL ( WINAPI *PFN_WinSpool_DeletePrinter )
(
    IN HANDLE  hPrinter
);

#ifdef UNICODE
typedef BOOL ( WINAPI *PFN_WinSpool_OpenPrinter )
(
   IN LPWSTR    pPrinterName,
   OUT LPHANDLE phPrinter,
   IN LPPRINTER_DEFAULTSW pDefault
);
#else
typedef BOOL ( WINAPI *PFN_WinSpool_OpenPrinter )
(
   IN LPSTR		pPrinterName,
   OUT LPHANDLE phPrinter,
   IN LPPRINTER_DEFAULTSA pDefault
);
#endif

typedef BOOL ( WINAPI *PFN_WinSpool_GetDefaultPrinter )
(
    IN LPTSTR   pszBuffer,
    IN LPDWORD  pcchBuffer
) ;

typedef BOOL ( WINAPI *PFN_WinSpool_SetDefaultPrinter )
(
    IN LPTSTR   pszBuffer
) ;

#ifdef UNICODE
#if NTONLY == 5
typedef BOOL ( WINAPI *PFN_WinSpool_XcvData )
(  
    IN  HANDLE  hXcv,
    IN  PCWSTR  pszDataName,
    IN  PBYTE   pInputData,
    IN  DWORD   cbInputData,
    OUT PBYTE   pOutputData,
    IN  DWORD   cbOutputData,
    OUT PDWORD  pcbOutputNeeded,
    OUT PDWORD  pdwStatus
);
#endif
#endif

/******************************************************************************
 * Wrapper class for WinSpool load/unload, for registration with CResourceManager. 
 *****************************************************************************/
class CWinSpoolApi : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to WinSpool functions.
    // Add new functions here as required.

	PFN_WinSpool_ClosePrinter       m_pfnClosePrinter;
	PFN_WinSpool_DeviceCapabilities m_pfnDeviceCapabilities;
	PFN_WinSpool_DocumentProperties m_pfnDocumentProperties;
	PFN_WinSpool_EnumJobs           m_pfnEnumJobs;
	PFN_WinSpool_EnumPrinterDrivers m_pfnEnumPrinterDrivers;
	PFN_WinSpool_EnumPrinters       m_pfnEnumPrinters; 
	PFN_WinSpool_EnumPorts          m_pfnEnumPorts; 
	PFN_WinSpool_GetJob             m_pfnGetJob;
	PFN_WinSpool_GetPrinter         m_pfnGetPrinter;
	PFN_WinSpool_GetPrinterDriver   m_pfnGetPrinterDriver;
	PFN_WinSpool_SetPrinter         m_pfnSetPrinter;
	PFN_WinSpool_OpenPrinter        m_pfnOpenPrinter;
	PFN_WinSpool_GetDefaultPrinter  m_pfnGetDefaultPrinter;
	PFN_WinSpool_SetJob             m_pfnSetJob;
	PFN_WinSpool_DeletePrinter      m_pfnDeletePrinter;
    PFN_WinSpool_SetDefaultPrinter  m_pfnSetDefaultPrinter;
    
    #ifdef UNICODE
    #if NTONLY == 5
    PFN_WinSpool_XcvData                 m_pfnXcvData;
    #endif
    PFN_WinSpool_AddPrinterConnection    m_pfnAddPrinterConnection;
    PFN_WinSpool_DeletePrinterConnection m_pfnDeletePrinterConnection;
    #endif

	HANDLE m_hPrintMutex;

public:

    // Constructor and destructor:
    CWinSpoolApi(LPCTSTR a_tstrWrappedDllName);
    ~CWinSpoolApi();

    // Initialization function to check function pointers.
    virtual bool Init();

    // Member functions wrapping WinSpool functions.
    // Add new functions here as required:

	BOOL ClosePrinter (

		IN HANDLE hPrinter
	);

#ifdef UNICODE
	int DeviceCapabilities (

		IN LPCWSTR pDevice , 
		IN LPCWSTR pPort, 
		IN WORD fwCapability ,
		OUT LPWSTR pOutput , 
		IN CONST DEVMODEW *pDevMode
	);
#else
	int DeviceCapabilities	(

		IN LPCSTR pDevice , 
		IN LPCSTR pPort, 
		IN WORD fwCapability ,
		OUT LPCSTR pOutput, 
		IN CONST DEVMODEA *pDevMode
	);
#endif

#ifdef UNICODE
	LONG DocumentProperties (

		IN HWND      hWnd,
		IN HANDLE    hPrinter,
		IN LPWSTR   pDeviceName,
		OUT PDEVMODEW pDevModeOutput,
		IN PDEVMODEW pDevModeInput,
		IN DWORD     fMode
	);
#else
	LONG DocumentProperties (

		IN HWND      hWnd,
		IN HANDLE    hPrinter,
		IN LPSTR   pDeviceName,
		OUT PDEVMODEA pDevModeOutput,
		IN PDEVMODEA pDevModeInput,
		IN DWORD     fMode
	);
#endif

	BOOL EnumJobs (

		IN HANDLE  hPrinter,
		IN DWORD   FirstJob,
		IN DWORD   NoJobs,
		IN DWORD   Level,
		OUT LPBYTE  pJob,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded,
		OUT LPDWORD pcReturned
	);

#ifdef UNICODE
	BOOL EnumPrinterDrivers (

		IN LPWSTR   pName,
		IN LPWSTR   pEnvironment,
		IN DWORD   Level,
		OUT LPBYTE  pDriverInfo,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded,
		OUT LPDWORD pcReturned
	);
#else
	BOOL EnumPrinterDrivers (

		IN LPSTR   pName,
		IN LPSTR   pEnvironment,
		IN DWORD   Level,
		OUT LPBYTE  pDriverInfo,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded,
		OUT LPDWORD pcReturned
	);
#endif

#ifdef UNICODE
	BOOL EnumPrinters (

		IN DWORD   Flags,
		IN LPWSTR Name,
		IN DWORD   Level,
		OUT LPBYTE  pPrinterEnum,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded,
		OUT LPDWORD pcReturned
	);
#else
	BOOL EnumPrinters (

		IN DWORD   Flags,
		IN LPSTR Name,
		IN DWORD   Level,
		OUT LPBYTE  pPrinterEnum,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded,
		OUT LPDWORD pcReturned
	);
#endif

#ifdef UNICODE
	BOOL EnumPorts (

		IN LPWSTR   pName,
		IN DWORD   Level,
		OUT LPBYTE  pPortInfo,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded,
		OUT LPDWORD pcReturned
	);
#else
	BOOL EnumPorts (

		IN LPSTR   pName,
		IN DWORD   Level,
		OUT LPBYTE  pPortInfo,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded,
		OUT LPDWORD pcReturned
	);
#endif

	BOOL GetJob (

		IN HANDLE   hPrinter,
		IN DWORD    JobId,
		IN DWORD    Level,
		OUT LPBYTE   pJob,
		IN DWORD    cbBuf,
		OUT LPDWORD  pcbNeeded
	);

	BOOL SetJob (

		IN HANDLE   hPrinter,
		IN DWORD    JobId,
		IN DWORD    Level,
		IN LPBYTE   pJob,
		IN DWORD    cbBuf
	);


	BOOL GetPrinter (

		IN HANDLE  hPrinter,
		IN DWORD   Level,
		OUT LPBYTE  pPrinter,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded
	);

	BOOL GetPrinterDriver (

		IN HANDLE  hPrinter,
		IN LPTSTR  pEnvironment,
		IN DWORD   Level,
		OUT LPBYTE  pPrinter,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded
	);


	BOOL SetPrinter (

		IN HANDLE  hPrinter,
		IN DWORD   Level,
		IN LPBYTE  pPrinter,
		IN DWORD   cbBuf
	);

	BOOL DeletePrinter (

		IN HANDLE  hPrinter
	);

    BOOL XcvDataW(
        IN  HANDLE  hXcv,
        IN  PCWSTR  pszDataName,
        IN  PBYTE   pInputData,
        IN  DWORD   cbInputData,
        OUT PBYTE   pOutputData,
        IN  DWORD   cbOutputData,
        OUT PDWORD  pcbOutputNeeded,
        OUT PDWORD  pdwStatus
    );

#ifdef UNICODE
	BOOL OpenPrinter (

		IN LPWSTR pPrinterName,
		OUT LPHANDLE phPrinter,
		IN LPPRINTER_DEFAULTSW pDefault
	);
#else
	BOOL OpenPrinter (

		IN LPSTR pPrinterName,
		OUT LPHANDLE phPrinter,
		IN LPPRINTER_DEFAULTSA pDefault
	);
#endif

   BOOL GetDefaultPrinter (

	    IN LPTSTR   pszBuffer,
	    IN LPDWORD  pcchBuffer
    );

	BOOL SetDefaultPrinter (

	    IN LPTSTR   pszBuffer
    );

#if NTONLY >= 5

    BOOL AddPrinterConnection(

        IN LPTSTR pName

    );

    BOOL DeletePrinterConnection(

        IN LPTSTR pName

    );
#endif

};

class SmartClosePrinter
{
private:

	HANDLE m_h;

public:

	SmartClosePrinter () : m_h ( INVALID_HANDLE_VALUE ) {}
	SmartClosePrinter ( HANDLE h ) : m_h ( h ) {}

	~SmartClosePrinter()
	{
		if (m_h!=INVALID_HANDLE_VALUE) 
		{
			CWinSpoolApi *pWinSpoolApi = ( CWinSpoolApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidWinSpoolApi, NULL ) ;
			if ( pWinSpoolApi )
			{
				pWinSpoolApi->ClosePrinter(m_h);

				CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidWinSpoolApi , pWinSpoolApi ) ;
			}
		}
	}

	HANDLE operator =(HANDLE h) 
	{
		if (m_h!=INVALID_HANDLE_VALUE) 
		{
			CWinSpoolApi *pWinSpoolApi = ( CWinSpoolApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidWinSpoolApi, NULL ) ;
			if ( pWinSpoolApi )
			{
				pWinSpoolApi->ClosePrinter(m_h); 

				CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidWinSpoolApi , pWinSpoolApi ) ;
			}
		}

		m_h=h; 

		return h;
	}

	operator HANDLE() const {return m_h;}
	HANDLE* operator &()
	{
		if (m_h!=INVALID_HANDLE_VALUE) 
		{
			CWinSpoolApi *pWinSpoolApi = ( CWinSpoolApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidWinSpoolApi, NULL ) ;
			if ( pWinSpoolApi )
			{
				pWinSpoolApi->ClosePrinter(m_h); 

				CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidWinSpoolApi , pWinSpoolApi ) ;
			}
		}

		m_h = INVALID_HANDLE_VALUE; 

		return &m_h;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\wmiapi.cpp ===
//=================================================================

//

// WmiApi.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>
#include <assertbreak.h>
#include "WmiApi.h"
#include "DllWrapperCreatorReg.h"


// {DD3B4892-CD0F-11d2-911E-0060081A46FD}
static const GUID g_guidWmiApi =
{0xdd3b4892, 0xcd0f, 0x11d2, {0x91, 0x1e, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};

static const TCHAR g_tstrWmi[] = _T("WMI.DLL");



/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CWmiApi, &g_guidWmiApi, g_tstrWmi> MyRegisteredWmiWrapper;



/******************************************************************************
 * Constructor
 ******************************************************************************/
CWmiApi::CWmiApi(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnWmiQueryAllData(NULL),
   m_pfnWmiOpenBlock(NULL),
   m_pfnWmiCloseBlock(NULL),
   m_pfnWmiQuerySingleInstance(NULL),
   m_pfnWmiSetSingleItem(NULL),
   m_pfnWmiSetSingleInstance(NULL),
   m_pfnWmiExecuteMethod(NULL),
   m_pfnWmiNotificationRegistraton(NULL),
   m_pfnWmiFreeBuffer(NULL),
   m_pfnWmiEnumerateGuids(NULL),
   m_pfnWmiMofEnumerateResources(NULL),
   m_pfnWmiFileHandleToInstanceName(NULL),
   m_pfnWmiDevInstToInstanceName(NULL),
   m_pfnWmiQueryGuidInformation(NULL)
{
}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CWmiApi::~CWmiApi()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 ******************************************************************************/
bool CWmiApi::Init()
{
    bool fRet = LoadLibrary();

    if(fRet)
    {

#ifdef NTONLY

        m_pfnWmiQueryAllData = (PFN_WMI_QUERY_ALL_DATA)
                                            GetProcAddress("WmiQueryAllDataW");

        m_pfnWmiQuerySingleInstance = (PFN_WMI_QUERY_SINGLE_INSTANCE)
                                     GetProcAddress("WmiQuerySingleInstanceW");

        m_pfnWmiSetSingleItem = (PFN_WMI_SET_SINGLE_ITEM)
                                           GetProcAddress("WmiSetSingleItemW");

        m_pfnWmiSetSingleInstance = (PFN_WMI_SET_SINGLE_INSTANCE)
                                       GetProcAddress("WmiSetSingleInstanceW");

        m_pfnWmiExecuteMethod = (PFN_WMI_EXECUTE_METHOD)
                                           GetProcAddress("WmiExecuteMethodW");

        m_pfnWmiNotificationRegistraton = (PFN_WMI_NOTIFICATION_REGRISTRATION)
                                GetProcAddress("WmiNotificationRegistrationW");

        m_pfnWmiMofEnumerateResources = (PFN_WMI_MOF_ENUMERATE_RESOURCES)
                                   GetProcAddress("WmiMofEnumerateResourcesW");

        m_pfnWmiFileHandleToInstanceName = (PFN_WMI_FILE_HANDLE_TO_INSTANCE_NAME)
                                GetProcAddress("WmiFileHandleToInstanceNameW");

        m_pfnWmiDevInstToInstanceName = (PFN_WMI_DEV_INST_TO_INSTANCE_NAME)
                                   GetProcAddress("WmiDevInstToInstanceNameW");

        m_pfnWmiQueryGuidInformation = (PFN_WMI_QUERY_GUID_INFORMATION)
                                     GetProcAddress("WmiQueryGuidInformation");

        fRet = (m_pfnWmiQueryAllData != NULL) &&
               (m_pfnWmiQuerySingleInstance != NULL) &&
               (m_pfnWmiSetSingleItem != NULL) &&
               (m_pfnWmiSetSingleInstance != NULL) &&
               (m_pfnWmiExecuteMethod != NULL) &&
               (m_pfnWmiNotificationRegistraton != NULL) &&
               (m_pfnWmiMofEnumerateResources != NULL) &&
               (m_pfnWmiFileHandleToInstanceName != NULL) &&
               (m_pfnWmiDevInstToInstanceName != NULL) &&
               (m_pfnWmiQueryGuidInformation != NULL);


#endif

#ifdef WIN9XONLY

        m_pfnWmiQueryAllData = (PFN_WMI_QUERY_ALL_DATA)
                                            GetProcAddress("WmiQueryAllDataA");

        m_pfnWmiQuerySingleInstance = (PFN_WMI_QUERY_SINGLE_INSTANCE)
                                     GetProcAddress("WmiQuerySingleInstanceA");

        m_pfnWmiSetSingleItem = (PFN_WMI_SET_SINGLE_ITEM)
                                           GetProcAddress("WmiSetSingleItemA");

        m_pfnWmiSetSingleInstance = (PFN_WMI_SET_SINGLE_INSTANCE)
                                       GetProcAddress("WmiSetSingleInstanceA");

        m_pfnWmiExecuteMethod = (PFN_WMI_EXECUTE_METHOD)
                                           GetProcAddress("WmiExecuteMethodA");

        m_pfnWmiNotificationRegistraton = (PFN_WMI_NOTIFICATION_REGRISTRATION)
                                GetProcAddress("WmiNotificationRegistrationA");

        m_pfnWmiMofEnumerateResources = (PFN_WMI_MOF_ENUMERATE_RESOURCES)
                                   GetProcAddress("WmiMofEnumerateResourcesA");

        m_pfnWmiFileHandleToInstanceName = (PFN_WMI_FILE_HANDLE_TO_INSTANCE_NAME)
                                GetProcAddress("WmiFileHandleToInstanceNameA");

        fRet = (m_pfnWmiQueryAllData != NULL) &&
               (m_pfnWmiQuerySingleInstance != NULL) &&
               (m_pfnWmiSetSingleItem != NULL) &&
               (m_pfnWmiSetSingleInstance != NULL) &&
               (m_pfnWmiExecuteMethod != NULL) &&
               (m_pfnWmiNotificationRegistraton != NULL) &&
               (m_pfnWmiMofEnumerateResources != NULL) &&
               (m_pfnWmiFileHandleToInstanceName != NULL);

#endif

        m_pfnWmiOpenBlock = (PFN_WMI_OPEN_BLOCK)
                                                GetProcAddress("WmiOpenBlock");

        m_pfnWmiCloseBlock = (PFN_WMI_CLOSE_BLOCK)
                                               GetProcAddress("WmiCloseBlock");

        m_pfnWmiFreeBuffer = (PNF_WMI_FREE_BUFFER)
                                               GetProcAddress("WmiFreeBuffer");

        m_pfnWmiEnumerateGuids = (PFN_WMI_ENUMERATE_GUIDS)
                                           GetProcAddress("WmiEnumerateGuids");

        fRet = fRet &&
               (m_pfnWmiOpenBlock != NULL) &&
               (m_pfnWmiCloseBlock != NULL) &&
               (m_pfnWmiFreeBuffer != NULL) &&
               (m_pfnWmiEnumerateGuids != NULL);

        if (!fRet)
        {
            LogErrorMessage(L"Failed find entrypoint in wmiapi");
        }
    }

    return fRet;
}



/******************************************************************************
 * Member functions wrapping Wmi api functions. Add new functions here
 * as required.
 ******************************************************************************/
ULONG CWmiApi::WmiQueryAllData
(
    IN WMIHANDLE a_h,
    IN OUT ULONG* a_ul,
    OUT PVOID a_pv
)
{
    return m_pfnWmiQueryAllData(a_h, a_ul, a_pv);
}

ULONG CWmiApi::WmiOpenBlock
(
    IN GUID* a_pguid,
    IN ULONG a_ul,
    OUT WMIHANDLE a_wmih
)
{
    return m_pfnWmiOpenBlock(a_pguid, a_ul, a_wmih);
}

ULONG CWmiApi::WmiCloseBlock
(
    IN WMIHANDLE a_wmih
)
{
    return m_pfnWmiCloseBlock(a_wmih);
}

ULONG CWmiApi::WmiQuerySingleInstance
(
    IN WMIHANDLE a_wmihDataBlockHandle,
    IN LPCTSTR a_tstrInstanceName,
    IN OUT ULONG* a_ulBufferSize,
    OUT PVOID a_pvBuffer
)
{
    return m_pfnWmiQuerySingleInstance(a_wmihDataBlockHandle,
                                       a_tstrInstanceName,
                                       a_ulBufferSize,
                                       a_pvBuffer);
}

ULONG CWmiApi::WmiSetSingleItem
(
    IN WMIHANDLE a_wmihDataBlockHandle,
    IN LPCTSTR a_tstrInstanceName,
    IN ULONG a_ulDataItemId,
    IN ULONG a_ulReserved,
    IN ULONG a_ulValueBufferSize,
    IN PVOID a_pvValueBuffer
)
{
    return m_pfnWmiSetSingleItem(a_wmihDataBlockHandle,
                                 a_tstrInstanceName,
                                 a_ulDataItemId,
                                 a_ulReserved,
                                 a_ulValueBufferSize,
                                 a_pvValueBuffer);
}

ULONG CWmiApi::WmiSetSingleInstance
(
    IN WMIHANDLE a_wmihDataBlockHandle,
    IN LPCTSTR a_tstrInstanceName,
    IN ULONG a_ulReserved,
    IN ULONG a_ulValueBufferSize,
    IN PVOID a_pvValueBuffer
)
{
    return m_pfnWmiSetSingleInstance(a_wmihDataBlockHandle,
                                     a_tstrInstanceName,
                                     a_ulReserved,
                                     a_ulValueBufferSize,
                                     a_pvValueBuffer);
}

ULONG CWmiApi::WmiExecuteMethod
(
    IN WMIHANDLE a_wmihMethodDataBlockHandle,
    IN LPCTSTR a_tstrMethodInstanceName,
    IN ULONG a_ulMethodId,
    IN ULONG a_ulInputValueBufferSize,
    IN PVOID a_pvInputValueBuffer,
    IN OUT ULONG* a_ulOutputBufferSize,
    OUT PVOID a_pvOutputBuffer
)
{
    return m_pfnWmiExecuteMethod(a_wmihMethodDataBlockHandle,
                                 a_tstrMethodInstanceName,
                                 a_ulMethodId,
                                 a_ulInputValueBufferSize,
                                 a_pvInputValueBuffer,
                                 a_ulOutputBufferSize,
                                 a_pvOutputBuffer);
}

ULONG CWmiApi::WmiNotificationRegistration
(
    IN LPGUID a_pguidGuid,
    IN BOOLEAN a_blnEnable,
    IN PVOID a_pvDeliveryInfo,
    IN ULONG_PTR a_pulDeliveryContext,
    IN ULONG a_ulFlags
)
{
    return m_pfnWmiNotificationRegistraton(a_pguidGuid,
                                           a_blnEnable,
                                           a_pvDeliveryInfo,
                                           a_pulDeliveryContext,
                                           a_ulFlags);
}

ULONG CWmiApi::WmiMofEnumerateResources
(
    IN MOFHANDLE a_MofResourceHandle,
    OUT ULONG* a_pulMofResourceCount,
    OUT PMOFRESOURCEINFO* a_MofResourceInfo
)
{
    return m_pfnWmiMofEnumerateResources(a_MofResourceHandle,
                                         a_pulMofResourceCount,
                                         a_MofResourceInfo);
}

ULONG CWmiApi::WmiFileHandleToInstanceName
(
    IN WMIHANDLE a_wmihDataBlockHandle,
    IN HANDLE a_hFileHandle,
    IN OUT ULONG* a_pulNumberCharacters,
    OUT TCHAR* a_tcInstanceNames
)
{
    return m_pfnWmiFileHandleToInstanceName(a_wmihDataBlockHandle,
                                            a_hFileHandle,
                                            a_pulNumberCharacters,
                                            a_tcInstanceNames);
}

ULONG CWmiApi::WmiDevInstToInstanceName
(
    OUT TCHAR* a_ptcInstanceName,
    IN ULONG a_ulInstanceNameLength,
    IN TCHAR* a_tcDevInst,
    IN ULONG a_ulInstanceIndex
)
{
    ASSERT_BREAK(m_pfnWmiDevInstToInstanceName);

    if (m_pfnWmiDevInstToInstanceName)
        return m_pfnWmiDevInstToInstanceName(a_ptcInstanceName,
                                             a_ulInstanceNameLength,
                                             a_tcDevInst,
                                             a_ulInstanceIndex);

    return 0xffffffff;
}

void CWmiApi::WmiFreeBuffer
(
    IN PVOID a_pvBuffer
)
{
    m_pfnWmiFreeBuffer(a_pvBuffer);
}

ULONG CWmiApi::WmiEnumerateGuids
(
    OUT LPGUID a_lpguidGuidList,
    IN OUT ULONG* a_pulGuidCount
)
{
    return m_pfnWmiEnumerateGuids(a_lpguidGuidList,
                                  a_pulGuidCount);
}

ULONG CWmiApi::WmiQueryGuidInformation
(
    IN WMIHANDLE a_wmihGuidHandle,
    OUT PWMIGUIDINFORMATION a_GuidInfo
)
{
    ASSERT_BREAK(m_pfnWmiQueryGuidInformation);

    if (m_pfnWmiQueryGuidInformation)
        return m_pfnWmiQueryGuidInformation(a_wmihGuidHandle,
                                            a_GuidInfo);
    return 0xffffffff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\wmiapi.h ===
//=================================================================

//

// WmiApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_WMIAPI_H_
#define	_WMIAPI_H_

/**********************************************************************************************************
 * #includes to Register this class with the CResourceManager. 
 **********************************************************************************************************/
#include "DllWrapperBase.h"
#include "wmium.h"
#include "wbemcli.h"



/******************************************************************************
 * Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidWmiApi;
extern const TCHAR g_tstrWmi[];



/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

typedef ULONG (WINAPI* PFN_WMI_QUERY_ALL_DATA)
(
    IN WMIHANDLE, 
    IN OUT ULONG*, 
    OUT PVOID
);

typedef ULONG (WINAPI* PFN_WMI_QUERY_SINGLE_INSTANCE)
(
    IN WMIHANDLE DataBlockHandle,
    IN LPCTSTR InstanceName,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
);

typedef ULONG (WINAPI* PFN_WMI_SET_SINGLE_ITEM)
(
    IN WMIHANDLE DataBlockHandle,
    IN LPCTSTR InstanceName,
    IN ULONG DataItemId,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
);

typedef ULONG (WINAPI* PFN_WMI_SET_SINGLE_INSTANCE)
(
    IN WMIHANDLE DataBlockHandle,
    IN LPCTSTR InstanceName,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
);

typedef ULONG (WINAPI* PFN_WMI_EXECUTE_METHOD)
(
    IN WMIHANDLE MethodDataBlockHandle,
    IN LPCTSTR MethodInstanceName,
    IN ULONG MethodId,
    IN ULONG InputValueBufferSize,
    IN PVOID InputValueBuffer,
    IN OUT ULONG *OutputBufferSize,
    OUT PVOID OutputBuffer
);

typedef ULONG (WINAPI* PFN_WMI_NOTIFICATION_REGRISTRATION)
(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
);

typedef ULONG (WINAPI* PFN_WMI_MOF_ENUMERATE_RESOURCES)
(
    IN MOFHANDLE MofResourceHandle,
    OUT ULONG *MofResourceCount,
    OUT PMOFRESOURCEINFO *MofResourceInfo
);

typedef ULONG (WINAPI* PFN_WMI_FILE_HANDLE_TO_INSTANCE_NAME)
(
    IN WMIHANDLE DataBlockHandle,
    IN HANDLE FileHandle,
    IN OUT ULONG *NumberCharacters,
    OUT TCHAR *InstanceNames
);

typedef ULONG (WINAPI* PFN_WMI_DEV_INST_TO_INSTANCE_NAME)
(
    OUT TCHAR *InstanceName,
    IN ULONG InstanceNameLength,
    IN TCHAR *DevInst,
    IN ULONG InstanceIndex
);

typedef	ULONG (WINAPI* PFN_WMI_OPEN_BLOCK)
(
    IN GUID*, 
    IN ULONG, 
    OUT WMIHANDLE
);

typedef ULONG (WINAPI* PFN_WMI_CLOSE_BLOCK)
(
    IN WMIHANDLE
);

typedef void (WINAPI* PNF_WMI_FREE_BUFFER)
(
    IN PVOID Buffer
);

typedef ULONG (WINAPI* PFN_WMI_ENUMERATE_GUIDS)
(
    OUT LPGUID GuidList,
    IN OUT ULONG *GuidCount
);

typedef ULONG (WINAPI* PFN_WMI_QUERY_GUID_INFORMATION)
(
    IN WMIHANDLE GuidHandle, 
    OUT PWMIGUIDINFORMATION GuidInfo
);




/******************************************************************************
 * Wrapper class for Wmi load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CWmiApi : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to Wmi functions.
    // Add new functions here as required.
    PFN_WMI_QUERY_ALL_DATA m_pfnWmiQueryAllData;
    PFN_WMI_OPEN_BLOCK m_pfnWmiOpenBlock;
    PFN_WMI_CLOSE_BLOCK m_pfnWmiCloseBlock;
    PFN_WMI_QUERY_SINGLE_INSTANCE m_pfnWmiQuerySingleInstance;
    PFN_WMI_SET_SINGLE_ITEM m_pfnWmiSetSingleItem;
    PFN_WMI_SET_SINGLE_INSTANCE m_pfnWmiSetSingleInstance;
    PFN_WMI_EXECUTE_METHOD m_pfnWmiExecuteMethod;
    PFN_WMI_NOTIFICATION_REGRISTRATION m_pfnWmiNotificationRegistraton;
    PNF_WMI_FREE_BUFFER m_pfnWmiFreeBuffer;
    PFN_WMI_ENUMERATE_GUIDS m_pfnWmiEnumerateGuids;
    PFN_WMI_MOF_ENUMERATE_RESOURCES m_pfnWmiMofEnumerateResources;
    PFN_WMI_FILE_HANDLE_TO_INSTANCE_NAME m_pfnWmiFileHandleToInstanceName;
    PFN_WMI_DEV_INST_TO_INSTANCE_NAME m_pfnWmiDevInstToInstanceName;
    PFN_WMI_QUERY_GUID_INFORMATION m_pfnWmiQueryGuidInformation;


public:

    // Constructor and destructor:
    CWmiApi(LPCTSTR a_tstrWrappedDllName);
    ~CWmiApi();

    // Initialization function to check function pointers.
    virtual bool Init();

    // Member functions wrapping Wmi functions.
    // Add new functions here as required:
    ULONG WmiQueryAllData
    (
        IN WMIHANDLE, 
        IN OUT ULONG*, 
        OUT PVOID
    );

    ULONG WmiOpenBlock
    (
        IN GUID*, 
        IN ULONG, 
        OUT WMIHANDLE
    );

    ULONG WmiCloseBlock
    (
        IN WMIHANDLE
    );

    ULONG WmiQuerySingleInstance
    (
        IN WMIHANDLE,
        IN LPCTSTR,
        IN OUT ULONG*,
        OUT PVOID
    );

    ULONG WmiSetSingleItem
    (
        IN WMIHANDLE,
        IN LPCTSTR,
        IN ULONG,
        IN ULONG,
        IN ULONG,
        IN PVOID 
    );

    ULONG WmiSetSingleInstance
    (
        IN WMIHANDLE,
        IN LPCTSTR,
        IN ULONG,
        IN ULONG,
        IN PVOID 
    );

    ULONG WmiExecuteMethod
    (
        IN WMIHANDLE,
        IN LPCTSTR,
        IN ULONG,
        IN ULONG,
        IN PVOID,
        IN OUT ULONG*,
        OUT PVOID
    );

    ULONG WmiNotificationRegistration
    (
        IN LPGUID,
        IN BOOLEAN,
        IN PVOID,
        IN ULONG_PTR,
        IN ULONG
    );

    ULONG WmiMofEnumerateResources
    (
        IN MOFHANDLE,
        OUT ULONG*,
        OUT PMOFRESOURCEINFO*
    );

    ULONG WmiFileHandleToInstanceName
    (
        IN WMIHANDLE,
        IN HANDLE,
        IN OUT ULONG*,
        OUT TCHAR*
    );

    ULONG WmiDevInstToInstanceName
    (
        OUT TCHAR*,
        IN ULONG,
        IN TCHAR*,
        IN ULONG
    );

    void WmiFreeBuffer
    (
        IN PVOID
    );

    ULONG WmiEnumerateGuids
    (
        OUT LPGUID,
        IN OUT ULONG*
    );

    ULONG WmiQueryGuidInformation
    (
        IN WMIHANDLE, 
        OUT PWMIGUIDINFORMATION
    );
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\ws2_32api.cpp ===
//=================================================================

//

// Ws2_32Api.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>

#define INCL_WINSOCK_API_TYPEDEFS	1
#include <winsock2.h>

#include "DllWrapperBase.h"
#include "Ws2_32Api.h"
#include "DllWrapperCreatorReg.h"



// {643966A2-D19F-11d2-9120-0060081A46FD}
static const GUID g_guidWs2_32Api =
{0x643966a2, 0xd19f, 0x11d2, { 0x91, 0x20, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};


static const TCHAR g_tstrWs2_32[] = _T("WS2_32.DLL");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CWs2_32Api, &g_guidWs2_32Api, g_tstrWs2_32> MyRegisteredWs2_32Wrapper;


/******************************************************************************
 * Constructor
 ******************************************************************************/
CWs2_32Api::CWs2_32Api(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnWSAStartUp(NULL),
   m_pfnWSAEnumProtocols(NULL),
   m_pfnWSAIoctl(NULL),
   m_pfnWSASocket(NULL),
   m_pfnBind(NULL),
   m_pfnCloseSocket(NULL),
   m_pfnWSACleanup(NULL),
   m_pfnWSAGetLastError(NULL)
{
}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CWs2_32Api::~CWs2_32Api()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CWs2_32Api::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
        m_pfnWSAStartUp = (LPFN_WSASTARTUP) GetProcAddress("WSAStartup");

        m_pfnWSAIoctl = (LPFN_WSAIOCTL) GetProcAddress("WSAIoctl");

        m_pfnBind = (LPFN_BIND) GetProcAddress("bind");

        m_pfnCloseSocket = (LPFN_CLOSESOCKET) GetProcAddress("closesocket");

        m_pfnWSACleanup = (LPFN_WSACLEANUP) GetProcAddress("WSACleanup");

        m_pfnWSAGetLastError = (LPFN_WSAGETLASTERROR)
                                        GetProcAddress("WSAGetLastError");

#ifdef NTONLY

        m_pfnWSAEnumProtocols = (LPFN_WSAENUMPROTOCOLS)
                                      GetProcAddress("WSAEnumProtocolsW");

        m_pfnWSASocket = (LPFN_WSASOCKET) GetProcAddress("WSASocketW");
#endif

#ifdef WIN9XONLY

        m_pfnWSAEnumProtocols = (LPFN_WSAENUMPROTOCOLS) GetProcAddress(
                                                    "WSAEnumProtocolsA");

        m_pfnWSASocket = (LPFN_WSASOCKET) GetProcAddress("WSASocketA");

#endif


        // Check that we have function pointers to functions that should be
        // present in all versions of this dll...
        if(m_pfnWSAStartUp == NULL ||
           m_pfnWSAIoctl == NULL ||
           m_pfnBind == NULL ||
           m_pfnCloseSocket == NULL ||
           m_pfnWSACleanup == NULL ||
           m_pfnWSAGetLastError == NULL ||
           m_pfnWSAEnumProtocols == NULL ||
           m_pfnWSASocket == NULL)
        {
            fRet = false;
            LogErrorMessage(L"Failed find entrypoint in ws2_32api");
        }
		else
		{
			fRet = true;
		}
    }
    return fRet;
}




/******************************************************************************
 * Member functions wrapping Ws2_32 api functions. Add new functions here
 * as required.
 ******************************************************************************/
int CWs2_32Api::WSAStartUp
(
    WORD a_wVersionRequested,
    LPWSADATA a_lpWSAData
)
{
    return m_pfnWSAStartUp(a_wVersionRequested, a_lpWSAData);
}

int CWs2_32Api::WSAEnumProtocols
(
    LPINT a_lpiProtocols,
    LPWSAPROTOCOL_INFO a_lpProtocolBuffer,
    LPDWORD a_lpdwBufferLength
)
{
    return m_pfnWSAEnumProtocols(a_lpiProtocols, a_lpProtocolBuffer,
                                 a_lpdwBufferLength);
}

int CWs2_32Api::WSAIoctl
(
    SOCKET a_s,
    DWORD a_dwIoControlCode,
    LPVOID a_lpvInBuffer,
    DWORD a_cbInBuffer,
    LPVOID a_lpvOutBuffer,
    DWORD a_cbOutBuffer,
    LPDWORD a_lpcbBytesReturned,
    LPWSAOVERLAPPED a_lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE a_lpCompletionRoutine
)
{
    return m_pfnWSAIoctl(a_s,
                         a_dwIoControlCode,
                         a_lpvInBuffer,
                         a_cbInBuffer,
                         a_lpvOutBuffer,
                         a_cbOutBuffer,
                         a_lpcbBytesReturned,
                         a_lpOverlapped,
                         a_lpCompletionRoutine);
}

SOCKET CWs2_32Api::WSASocket
(
    int a_af,
    int a_type,
    int a_protocol,
    LPWSAPROTOCOL_INFO a_lpProtocolInfo,
    GROUP a_g,
    DWORD a_dwFlags
)
{
    return m_pfnWSASocket(a_af,
                          a_type,
                          a_protocol,
                          a_lpProtocolInfo,
                          a_g,
                          a_dwFlags);
}

int CWs2_32Api::Bind
(
    SOCKET a_s,
    const struct sockaddr FAR * a_name,
    int a_namelen
)
{
    return m_pfnBind(a_s, a_name, a_namelen);
}

int CWs2_32Api::CloseSocket
(
    SOCKET a_s
)
{
    return m_pfnCloseSocket(a_s);
}

int CWs2_32Api::WSACleanup()
{
    return m_pfnWSACleanup();
}

int CWs2_32Api::WSAGetLastError()
{
    return m_pfnWSAGetLastError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\ws2_32api.h ===
//=================================================================

//

// Ws2_32Api.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_WS2_32API_H_
#define	_WS2_32API_H_



/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidWs2_32Api;
extern const TCHAR g_tstrWs2_32[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/
// Included through #include<winsock2.h>


/******************************************************************************
 * Wrapper class for Ws2_32 load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CWs2_32Api : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to Ws2_32 functions.
    // Add new functions here as required.
    LPFN_WSASTARTUP			m_pfnWSAStartUp;
	LPFN_WSAENUMPROTOCOLS	m_pfnWSAEnumProtocols;
	LPFN_WSAIOCTL			m_pfnWSAIoctl;
	LPFN_WSASOCKET			m_pfnWSASocket;
	LPFN_BIND				m_pfnBind;
	LPFN_CLOSESOCKET		m_pfnCloseSocket;
	LPFN_WSACLEANUP			m_pfnWSACleanup;
	LPFN_WSAGETLASTERROR	m_pfnWSAGetLastError;

public:

    // Constructor and destructor:
    CWs2_32Api(LPCTSTR a_tstrWrappedDllName);
    ~CWs2_32Api();

    // Inherrited initialization function.
    virtual bool Init();

    // Member functions wrapping Ws2_32 functions.
    // Add new functions here as required:
    int WSAStartUp
    (
        WORD a_wVersionRequested,
        LPWSADATA a_lpWSAData
    );

    int WSAEnumProtocols
    (
        LPINT a_lpiProtocols,
        LPWSAPROTOCOL_INFO a_lpProtocolBuffer,
        LPDWORD a_lpdwBufferLength
    );

    int WSAIoctl
    (
        SOCKET a_s,
        DWORD a_dwIoControlCode,
        LPVOID a_lpvInBuffer,
        DWORD a_cbInBuffer,
        LPVOID a_lpvOutBuffer,
        DWORD a_cbOutBuffer,
        LPDWORD a_lpcbBytesReturned,
        LPWSAOVERLAPPED a_lpOverlapped,
        LPWSAOVERLAPPED_COMPLETION_ROUTINE a_lpCompletionRoutine
    );

    SOCKET WSASocket
    (
        int a_af,
        int a_type,
        int a_protocol,
        LPWSAPROTOCOL_INFO a_lpProtocolInfo,
        GROUP a_g,
        DWORD a_dwFlags
    );

    int Bind
    (
        SOCKET a_s,
        const struct sockaddr FAR * a_name,
        int a_namelen
    );

    int CloseSocket
    (
        SOCKET a_s
    );

    int WSACleanup();

    int WSAGetLastError();

};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\wmi_fileprivateprofile.cpp ===
/*****************************************************************************/
/*
/*  Copyright (c) 2001 Microsoft Corporation, All Rights Reserved            /
/*
/*****************************************************************************/

#include "precomp.h"
#include "WMI_FilePrivateProfile.h"

#define STOP_AT_SECTION 1
#define STOP_AT_KEYWORD 2
#define STOP_AT_NONSECTION 3

#define BYTE_ORDER_MARK           0xFEFF
#define REVERSE_BYTE_ORDER_MARK   0xFFFE

ULONG LockFileKey = 1;

DWORD
APIENTRY
WMI_FILE_GetPrivateProfileStringW(
                        LPCWSTR lpAppName,
                        LPCWSTR lpKeyName,
                        LPCWSTR lpDefault,
                        LPWSTR lpReturnedString,
                        DWORD nSize,
                        LPCWSTR lpFileName
                        )
{
    NTSTATUS Status;
    ULONG n;

    if (lpDefault == NULL) {
        lpDefault = L"";
    }

    n = nSize;
    Status = CWMI_FILE_IniFile::ReadWriteIniFile(FALSE,    // WriteOperation
                                      FALSE,    // SectionOperation
                                      lpFileName,
                                      lpAppName,
                                      lpKeyName,
                                      lpReturnedString,
                                      &n
                                    );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS( Status )) {
            SetLastError( NO_ERROR );
            n--;
        } else
            if (!lpAppName || !lpKeyName) {
            if (nSize >= 2) {
                n = nSize - 2;
                lpReturnedString[ n+1 ] = UNICODE_NULL;
            } else {
                n = 0;
            }
        } else {
            if (nSize >= 1) {
                n = nSize - 1;
            } else {
                n = 0;
            }
        }
    } else {
        n = wcslen( lpDefault );
        while (n > 0 && lpDefault[n-1] == L' ') {
            n -= 1;
        }

        if (n >= nSize) {
            n = nSize;
        }

        wcsncpy( lpReturnedString, lpDefault, n );
    }

    if (n < nSize) {
        lpReturnedString[ n ] = UNICODE_NULL;
    } else
        if (nSize > 0) {
        lpReturnedString[ nSize-1 ] = UNICODE_NULL;
    }

    return( n );
}


UINT
APIENTRY
WMI_FILE_GetPrivateProfileIntW(
                     LPCWSTR lpAppName,
                     LPCWSTR lpKeyName,
                     INT nDefault,
                     LPCWSTR lpFileName
                     )
{
    NTSTATUS Status;
    ULONG ReturnValue;
    WCHAR ValueBuffer[ 256 ];
    UNICODE_STRING Value;
    ANSI_STRING AnsiString;
    ULONG cb;

    ReturnValue = 0;
    cb = WMI_FILE_GetPrivateProfileStringW(lpAppName,
                                   lpKeyName,
                                   NULL,
                                   ValueBuffer,
                                   sizeof( ValueBuffer ) / sizeof( WCHAR ),
                                   lpFileName
                                 );
    if (cb == 0)
	{
        ReturnValue = nDefault;
    }
	else
	{
        Value.Buffer = ValueBuffer;
        Value.Length = (USHORT)(cb * sizeof( WCHAR ));
        Value.MaximumLength = (USHORT)((cb + 1) * sizeof( WCHAR ));
        Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                               &Value,
                                               TRUE
                                             );
        if (NT_SUCCESS( Status ))
		{
            Status = RtlCharToInteger( AnsiString.Buffer, 0, &ReturnValue );
            RtlFreeAnsiString( &AnsiString );
        }

        if (!NT_SUCCESS( Status ))
		{
            SetLastError( Status );
        }
		else
		{
            SetLastError( NO_ERROR );
        }
    }

    return ReturnValue;
}



BOOL
APIENTRY
WMI_FILE_WritePrivateProfileStringW(
                          LPCWSTR lpAppName,
                          LPCWSTR lpKeyName,
                          LPCWSTR lpString,
                          LPCWSTR lpFileName
                          )
{
    NTSTATUS Status;

    Status = CWMI_FILE_IniFile::ReadWriteIniFile(TRUE,     // WriteOperation
                                      FALSE,    // SectionOperation
                                      lpFileName,
                                      lpAppName,
                                      lpKeyName,
                                      (LPWSTR)(lpKeyName == NULL ? NULL : lpString),
                                      NULL
                                    );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            SetLastError( Status );
        }
        return( FALSE );
    }
}

DWORD
APIENTRY
WMI_FILE_GetPrivateProfileSectionW(
                         LPCWSTR lpAppName,
                         LPWSTR lpReturnedString,
                         DWORD nSize,
                         LPCWSTR lpFileName
                         )
{
    NTSTATUS Status;
    ULONG n;

    n = nSize;
    Status = CWMI_FILE_IniFile::ReadWriteIniFile(FALSE,    // WriteOperation
                                      TRUE,     // SectionOperation
                                      lpFileName,
                                      lpAppName,
                                      NULL,
                                      lpReturnedString,
                                      &n
                                    );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS( Status )) {
            SetLastError( NO_ERROR );
            n--;
        } else
            if (nSize >= 2) {
            n = nSize - 2;
            lpReturnedString[ n+1 ] = UNICODE_NULL;
        } else {
            n = 0;
        }
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            SetLastError( Status );
        }
        n = 0;
    }

    if (n < nSize) {
        lpReturnedString[ n ] = UNICODE_NULL;
    } else
        if (nSize > 0) {
        lpReturnedString[ nSize-1 ] = UNICODE_NULL;
    }

    return( n );
}


BOOL
APIENTRY
WMI_FILE_WritePrivateProfileSectionW(
                           LPCWSTR lpAppName,
                           LPCWSTR lpString,
                           LPCWSTR lpFileName
                           )
{
    NTSTATUS Status;

    Status = CWMI_FILE_IniFile::ReadWriteIniFile(TRUE,     // WriteOperation
                                      TRUE,     // SectionOperation
                                      lpFileName,
                                      lpAppName,
                                      NULL,
                                      (LPWSTR)lpString,
                                      NULL
                                    );
    if (NT_SUCCESS( Status ))
	{
        return( TRUE );
    }
	else
	{
        if (Status == STATUS_INVALID_IMAGE_FORMAT)
		{
            SetLastError( ERROR_INVALID_DATA );
        }
		else
		{
            SetLastError( Status );
        }

        return( FALSE );
    }
}



CWMI_FILE_IniFileObject::CWMI_FILE_IniFileObject()
{
    m_EnvironmentUpdateCount = 0;
    m_FileHandle = INVALID_HANDLE_VALUE;
    m_WriteAccess = FALSE;
    m_UnicodeFile = FALSE;
    m_LockedFile = FALSE;
    m_EndOfFile = 0;
    m_BaseAddress = NULL;
    m_CommitSize = 0;
    m_RegionSize = 0;
    m_UpdateOffset = 0;
    m_UpdateEndOffset = 0;
    m_DirectoryInformationLength = 0;
}

CWMI_FILE_IniFileObject::~CWMI_FILE_IniFileObject()
{
	if ((m_FileHandle != INVALID_HANDLE_VALUE) && (m_FileHandle != NULL))
	{
		NtClose(m_FileHandle);
		m_FileHandle = INVALID_HANDLE_VALUE;
	}
}


CWMI_FILE_IniFile::CWMI_FILE_IniFile()
{
    RtlInitAnsiString( &m_VariableName, NULL );
    RtlInitUnicodeString( &m_VariableNameU, NULL );
    RtlInitAnsiString( &m_ApplicationName, NULL );
    RtlInitUnicodeString( &m_ApplicationNameU, NULL );

    m_Operation = Enum_ReadKeyValueOp;
    m_IsWriteOperation = FALSE;
    m_FileName = NULL;
    m_IsMultiValueStrings = FALSE;

    m_ValueBuffer = NULL;
    m_ValueLength = 0;
    m_ValueBufferU = NULL;
    m_ValueLengthU = 0;
    m_ResultChars = 0;
    m_ResultMaxChars = 0;
    m_ResultBufferU = NULL;

    m_TextCurrent = NULL;
    m_TextStart = NULL;
    m_TextEnd = NULL;
}

CWMI_FILE_IniFile::~CWMI_FILE_IniFile()
{
    if (m_VariableName.Buffer)
	{
		delete [] m_VariableName.Buffer;
		m_VariableName.Buffer = NULL;
	}

    if (m_ApplicationName.Buffer)
	{
		delete [] m_ApplicationName.Buffer;
		m_ApplicationName.Buffer = NULL;
	}

    if (m_ValueBuffer)
	{
		delete [] m_ValueBuffer;
		m_ValueBuffer = NULL;
	}
}

NTSTATUS CWMI_FILE_IniFile::ReadWriteIniFile(
                       IN BOOL WriteOperation,
                       IN BOOL SectionOperation,
                       IN LPCWSTR FileName,
                       IN LPCWSTR ApplicationName,
                       IN LPCWSTR VariableName,
                       IN OUT LPWSTR VariableValue,
                       IN OUT PULONG VariableValueLength
                       )
{
    NTSTATUS Status			= STATUS_SUCCESS;
    BOOL MultiValueStrings	= FALSE;;
    INIFILE_OPERATION Operation;

    if (SectionOperation) {
        VariableName = NULL;
    }

    MultiValueStrings = FALSE;

    if (WriteOperation)
	{
        if (ApplicationName)
		{
            if (VariableName)
			{
                if (VariableValue)
				{
                    Operation = Enum_WriteKeyValueOp;
                }
				else
				{
                    Status = STATUS_INVALID_PARAMETER;
                }
            }
			else
			{
                if (VariableValue)
				{
                    Operation = Enum_WriteSectionOp;
                    MultiValueStrings = TRUE;
                }
				else
				{
                    Status = STATUS_INVALID_PARAMETER;
                }
            }
        }
		else
		{
			Status = STATUS_INVALID_PARAMETER;
        }
    }
	else
	{
        if (ApplicationName)
		{
            if (!ARGUMENT_PRESENT( VariableValue ))
			{
                Status = STATUS_INVALID_PARAMETER;
            }
			else
			{
                if (VariableName)
				{
					Operation = Enum_ReadKeyValueOp;
				}
				else
				{
					if (SectionOperation)
					{
						Operation = Enum_ReadSectionOp;
						MultiValueStrings = TRUE;
					}
					else
					{
						Operation = Enum_ReadKeyNamesOp;
						MultiValueStrings = TRUE;
					}
				}
			}
        }
		else
		{
            if ( ! ( SectionOperation || !ARGUMENT_PRESENT( VariableValue ) ) )
			{
				Operation = Enum_ReadSectionNamesOp;
				MultiValueStrings = TRUE;
			}
			else
			{
				Status = STATUS_INVALID_PARAMETER;
			}
		}
    }

	if (NT_SUCCESS( Status ))
	{
		CWMI_FILE_IniFile myIni;
		Status = myIni.CaptureIniFileParameters(Operation,
                                              WriteOperation,
                                              MultiValueStrings,
                                              FileName,
                                              ApplicationName,
                                              VariableName,
                                              VariableValue,
                                              VariableValueLength
                                            );
		if (NT_SUCCESS( Status ))
		{
			Status = myIni.ReadWriteIniFileOnDisk();

			if (NT_SUCCESS( Status ))
			{
				if (myIni.m_Operation == Enum_ReadSectionNamesOp ||
					myIni.m_Operation == Enum_ReadKeyNamesOp ||
					myIni.m_Operation == Enum_ReadSectionOp )
				{
					myIni.AppendNullToResultBuffer();
				}
			}

			if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW)
			{
				if (!myIni.m_IsWriteOperation)
				{
					if (ARGUMENT_PRESENT( VariableValueLength ))
					{
						*VariableValueLength = myIni.m_ResultChars;
					}
				}
			}
		}
	}

    return Status;
}

NTSTATUS CWMI_FILE_IniFile::CaptureIniFileParameters(
                               INIFILE_OPERATION a_Operation,
                               BOOL a_WriteOperation,
                               BOOL a_MultiValueStrings,
                               LPCWSTR a_FileName,
                               LPCWSTR a_ApplicationName,
                               LPCWSTR a_VariableName,
                               LPWSTR a_VariableValue,
                               PULONG a_ResultMaxChars
                               )
{
    NTSTATUS Status = STATUS_SUCCESS;

    m_Operation = a_Operation;
    m_IsWriteOperation = a_WriteOperation;
    m_IsMultiValueStrings = a_MultiValueStrings;

    if (a_FileName)
	{
        m_FileName = a_FileName;
    }

    if (a_ApplicationName)
	{
		RtlInitUnicodeString(&m_ApplicationNameU, a_ApplicationName);
    }

    if (a_VariableName)
	{
		RtlInitUnicodeString(&m_VariableNameU, a_VariableName);
    }

	ULONG uVariableValueLength = 0;

    if (a_VariableValue )
	{
        if (!a_ResultMaxChars)
		{
            if (!a_MultiValueStrings)
			{
                uVariableValueLength = wcslen( a_VariableValue );
            }
			else
			{
                LPWSTR p = a_VariableValue;

                while (*p)
				{
                    while (*p++)
					{
                    }
                }

                uVariableValueLength = (ULONG)(p - a_VariableValue);
            }
        }

        if (m_IsWriteOperation)
		{
                m_ValueBufferU = a_VariableValue;
                m_ValueLengthU = uVariableValueLength * sizeof( WCHAR );
                m_ValueBuffer = NULL;
                m_ValueLength = 0;
        }
		else
		{
            if (a_ResultMaxChars)
			{
                m_ResultMaxChars = *a_ResultMaxChars;
            }

            m_ResultChars = 0;
            m_ResultBufferU = a_VariableValue;
        }
    }

    return Status;
}

NTSTATUS CWMI_FILE_IniFile::OpenIniFileOnDisk()
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING FullFileName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset;
	LARGE_INTEGER Length;

    m_IniFile.m_WriteAccess = m_IsWriteOperation;
	RtlInitUnicodeString(&FullFileName, NULL);

	if (!RtlDosPathNameToNtPathName_U( m_FileName,
                                          &FullFileName,
                                          NULL,
                                          NULL
                                        )
           )
	{
		return STATUS_OBJECT_PATH_NOT_FOUND;
	}

	try
	{
		InitializeObjectAttributes( &ObjectAttributes,
									&FullFileName,
									OBJ_CASE_INSENSITIVE,
									NULL,
									NULL
								  );
		
		if (m_IniFile.m_WriteAccess)
		{
			Status = NtCreateFile( &m_IniFile.m_FileHandle,
								   SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
								   &ObjectAttributes,
								   &IoStatusBlock,
								   0,
								   FILE_ATTRIBUTE_NORMAL,
								   FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
								   FILE_OPEN_IF,
								   FILE_SYNCHRONOUS_IO_NONALERT |
								   FILE_NON_DIRECTORY_FILE,
								   NULL,
								   0
								 );
		}
		else
		{
			Status = NtOpenFile( &m_IniFile.m_FileHandle,
								 SYNCHRONIZE | GENERIC_READ,
								 &ObjectAttributes,
								 &IoStatusBlock,
								 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
								 FILE_SYNCHRONOUS_IO_NONALERT |
								 FILE_NON_DIRECTORY_FILE
							   );
		}
	}
	catch(...)
	{
		RtlFreeUnicodeString(&FullFileName);
		RtlInitUnicodeString(&FullFileName, NULL);
		throw;
	}

	RtlFreeUnicodeString( &FullFileName );
	RtlInitUnicodeString(&FullFileName, NULL);


    if (NT_SUCCESS( Status ))
	{
        ByteOffset.QuadPart = 0;
        Length.QuadPart = -1;
        Status = NtLockFile( m_IniFile.m_FileHandle,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             &ByteOffset,
                             &Length,
                             LockFileKey,
                             FALSE,
                             (BOOLEAN)m_IniFile.m_WriteAccess
                           );

        if (NT_SUCCESS( Status ))
		{
            m_IniFile.m_LockedFile = TRUE;
        }

        if (NT_SUCCESS( Status ))
		{
            Status = NtQueryInformationFile( m_IniFile.m_FileHandle,
                                             &IoStatusBlock,
                                             &m_IniFile.m_StandardInformation,
                                             sizeof( m_IniFile.m_StandardInformation ),
                                             FileStandardInformation
                                           );

            if (Status == STATUS_BUFFER_OVERFLOW)
			{
                Status = STATUS_SUCCESS;
            }
        }
    }

    if (!NT_SUCCESS( Status ))
	{
		if ((m_IniFile.m_FileHandle != INVALID_HANDLE_VALUE) && (m_IniFile.m_FileHandle != NULL))
		{
			if (m_IniFile.m_LockedFile)
			{
				m_IniFile.m_LockedFile = FALSE;
				ByteOffset.QuadPart = 0;
				Length.QuadPart = -1;
				NtUnlockFile( m_IniFile.m_FileHandle,
							  &IoStatusBlock,
							  &ByteOffset,
							  &Length,
							  LockFileKey
							);
			}

			NtClose( m_IniFile.m_FileHandle );
			m_IniFile.m_FileHandle = INVALID_HANDLE_VALUE;
		}

        return Status;
    }
	else
	{
		m_IniFile.m_EndOfFile = m_IniFile.m_StandardInformation.EndOfFile.LowPart;
		m_IniFile.m_CommitSize = m_IniFile.m_EndOfFile + (4 * (m_IniFile.m_UnicodeFile ? sizeof( WCHAR ) : 1));
		m_IniFile.m_RegionSize = m_IniFile.m_CommitSize + 0x100000; // Room for 256KB of growth
		Status = NtAllocateVirtualMemory( NtCurrentProcess(),
										  &m_IniFile.m_BaseAddress,
										  0,
										  &m_IniFile.m_RegionSize,
										  MEM_RESERVE,
										  PAGE_READWRITE
										);
		if (NT_SUCCESS( Status ))
		{
			Status = NtAllocateVirtualMemory( NtCurrentProcess(),
											  &m_IniFile.m_BaseAddress,
											  0,
											  &m_IniFile.m_CommitSize,
											  MEM_COMMIT,
											  PAGE_READWRITE
											);
			if (NT_SUCCESS( Status )) {
				Status = NtReadFile( m_IniFile.m_FileHandle,
									 NULL,
									 NULL,
									 NULL,
									 &IoStatusBlock,
									 m_IniFile.m_BaseAddress,
									 m_IniFile.m_EndOfFile,
									 NULL,
									 &LockFileKey
								   );
				if (NT_SUCCESS( Status ) && IoStatusBlock.Information != m_IniFile.m_EndOfFile) {
					Status = STATUS_END_OF_FILE;
				}
			}
		}
	}

    if (NT_SUCCESS( Status ))
	{
        // We would like to check the possibility of IS_TEXT_UNICODE_DBCS_LEADBYTE.
        INT iResult = ~0x0;
        m_IniFile.m_UpdateOffset = 0xFFFFFFFF;
        m_IniFile.m_UpdateEndOffset = 0;
        m_IniFile.m_UnicodeFile = RtlIsTextUnicode( m_IniFile.m_BaseAddress, m_IniFile.m_EndOfFile, (PULONG)&iResult );

        if (m_IniFile.m_UnicodeFile)
		{
            LPWSTR Src = (LPWSTR)((PCHAR)m_IniFile.m_BaseAddress + m_IniFile.m_EndOfFile);

            while (Src > (LPWSTR)m_IniFile.m_BaseAddress && Src[ -1 ] <= L' ')
			{
                if (Src[-1] == L'\r' || Src[-1] == L'\n')
				{
                    break;
                }

                m_IniFile.m_EndOfFile -= sizeof( WCHAR );
                Src -= 1;
            }

            Src = (LPWSTR)((PCHAR)m_IniFile.m_BaseAddress + m_IniFile.m_EndOfFile);

            if (Src > (LPWSTR)m_IniFile.m_BaseAddress)
			{
                if (Src[-1] != L'\n')
				{
                    *Src++ = L'\r';
                    *Src++ = L'\n';
                    m_IniFile.m_UpdateOffset = m_IniFile.m_EndOfFile;
                    m_IniFile.m_UpdateEndOffset = m_IniFile.m_UpdateOffset + 2 * sizeof( WCHAR );
                    m_IniFile.m_EndOfFile = m_IniFile.m_UpdateEndOffset;
                }
            }
        }
		else
		{
            LPBYTE Src = (PBYTE)((PCHAR)m_IniFile.m_BaseAddress + m_IniFile.m_EndOfFile);

            while (Src > (PBYTE)m_IniFile.m_BaseAddress && Src[ -1 ] <= ' ')
			{
                if (Src[-1] == '\r' || Src[-1] == '\n') {
                    break;
                }

                m_IniFile.m_EndOfFile -= 1;
                Src -= 1;
            }

            Src = (PBYTE)((PCHAR)m_IniFile.m_BaseAddress + m_IniFile.m_EndOfFile);

            if (Src > (PBYTE)m_IniFile.m_BaseAddress)
			{
                if (Src[-1] != '\n') {
                    *Src++ = '\r';
                    *Src++ = '\n';
                    m_IniFile.m_UpdateOffset = m_IniFile.m_EndOfFile;
                    m_IniFile.m_UpdateEndOffset = m_IniFile.m_UpdateOffset + 2;
                    m_IniFile.m_EndOfFile = m_IniFile.m_UpdateEndOffset;
                }
            }
        }
    }
	else
	{
		if ((m_IniFile.m_FileHandle != INVALID_HANDLE_VALUE) && (m_IniFile.m_FileHandle != NULL))
		{
			if (m_IniFile.m_LockedFile)
			{
				m_IniFile.m_LockedFile = FALSE;
				ByteOffset.QuadPart = 0;
				Length.QuadPart = -1;
				NtUnlockFile( m_IniFile.m_FileHandle,
							  &IoStatusBlock,
							  &ByteOffset,
							  &Length,
							  LockFileKey
							);
			}

			NtClose( m_IniFile.m_FileHandle );
			m_IniFile.m_FileHandle = INVALID_HANDLE_VALUE;
        }
    }

    return Status;
}


NTSTATUS CWMI_FILE_IniFile::ReadWriteIniFileOnDisk()
{
    NTSTATUS Status;
    ULONG PartialResultChars = 0;

    if (!m_IsWriteOperation) {
        PartialResultChars = m_ResultChars;
    }

    Status = OpenIniFileOnDisk();
    
	if (NT_SUCCESS( Status ))
	{
        try
		{
            m_TextEnd = (PCHAR)m_IniFile.m_BaseAddress + m_IniFile.m_EndOfFile;
            m_TextCurrent = m_IniFile.m_BaseAddress;
            if (m_IniFile.m_UnicodeFile &&
                ((*(PWCHAR)m_TextCurrent == BYTE_ORDER_MARK) ||
                 (*(PWCHAR)m_TextCurrent == REVERSE_BYTE_ORDER_MARK)))
            {
                // Skip past the BOM.
				PWCHAR foo = (PWCHAR)m_TextCurrent;
                foo++;
				m_TextCurrent = (PVOID)foo;
            }

			if ( m_Operation == Enum_ReadSectionNamesOp )
			{
				Status = ReadSectionNames();
			}
            else if (m_Operation == Enum_ReadKeyValueOp)
			{
                Status = ReadKeywordValue();
            }
            else if (m_Operation == Enum_ReadKeyNamesOp)
			{
                Status = ReadKeywordNames();
            }
			else if (m_Operation == Enum_ReadSectionOp)
			{
                Status = ReadSection();
            }
			else if (m_Operation == Enum_WriteKeyValueOp)
			{
                Status = WriteKeywordValue(NULL );
            }
			else if (m_Operation == Enum_WriteSectionOp)
			{
                Status = WriteSection();
            }
			else
			{
                Status = STATUS_INVALID_PARAMETER;
            }

            NTSTATUS CloseStatus;
            CloseStatus = CloseIniFileOnDisk();

            if (NT_SUCCESS( Status ))
			{
                Status = CloseStatus;
            }
        }
        catch (...)
		{
            NTSTATUS CloseStatus;
            CloseStatus = CloseIniFileOnDisk();

            if (NT_SUCCESS( Status ))
			{
                Status = CloseStatus;
            }
        }
    }

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND &&
        !m_IsWriteOperation &&
        PartialResultChars != 0
       )
	{
        Status = STATUS_SUCCESS;
    }

    return Status;
}

NTSTATUS CWMI_FILE_IniFile::CloseIniFileOnDisk()
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS CloseStatus = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG UpdateLength = 0;
    LARGE_INTEGER ByteOffset;
	LARGE_INTEGER Length;

    if ((m_IniFile.m_FileHandle != INVALID_HANDLE_VALUE) && (m_IniFile.m_FileHandle != NULL))
	{
        if (m_IniFile.m_BaseAddress != NULL)
		{
            if (m_IniFile.m_UpdateOffset != 0xFFFFFFFF && m_IniFile.m_WriteAccess)
			{
                ByteOffset.HighPart = 0;
                ByteOffset.LowPart = m_IniFile.m_UpdateOffset;
                UpdateLength = m_IniFile.m_UpdateEndOffset - m_IniFile.m_UpdateOffset;
                Status = NtWriteFile( m_IniFile.m_FileHandle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &IoStatusBlock,
                                      (PCHAR)(m_IniFile.m_BaseAddress) + m_IniFile.m_UpdateOffset,
                                      UpdateLength,
                                      &ByteOffset,
                                      &LockFileKey
                                    );

                if (NT_SUCCESS( Status ))
				{
                    if (IoStatusBlock.Information != UpdateLength)
					{
                        Status = STATUS_DISK_FULL;
                    }
					else
					{
                        Length.QuadPart = m_IniFile.m_EndOfFile;
                        Status = NtSetInformationFile( m_IniFile.m_FileHandle,
                                                       &IoStatusBlock,
                                                       &Length,
                                                       sizeof( Length ),
                                                       FileEndOfFileInformation
                                                     );
                    }
                }
            }

            NtFreeVirtualMemory( NtCurrentProcess(),
                                 &m_IniFile.m_BaseAddress,
                                 &m_IniFile.m_RegionSize,
                                 MEM_RELEASE
                               );
            m_IniFile.m_BaseAddress = NULL;
            m_IniFile.m_CommitSize = 0;
            m_IniFile.m_RegionSize = 0;
        }

        if (m_IniFile.m_LockedFile)
		{
			m_IniFile.m_LockedFile = FALSE;
            ByteOffset.QuadPart = 0;
            Length.QuadPart = -1;
            NtUnlockFile( m_IniFile.m_FileHandle,
                          &IoStatusBlock,
                          &ByteOffset,
                          &Length,
                          LockFileKey
                        );
        }

        CloseStatus = NtClose( m_IniFile.m_FileHandle );
		m_IniFile.m_FileHandle = INVALID_HANDLE_VALUE;

        if (NT_SUCCESS( Status ))
		{
            Status = CloseStatus;
        }
    }

    return Status;
}

NTSTATUS CWMI_FILE_IniFile::ReadSectionNames()
{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;
    while (NT_SUCCESS( Status ))
	{
        Status = AdvanceTextPointer( STOP_AT_SECTION );
        if (Status == STATUS_MORE_ENTRIES) {
            Status = AppendStringToResultBuffer(m_AnsiSectionName,
                                                m_UnicodeSectionName,
                                                TRUE
                                               );
        }
		else
		{
            if (Status == STATUS_NO_MORE_ENTRIES)
			{
                Status = STATUS_SUCCESS;
            }
            break;
        }
    }

    return Status;
}

NTSTATUS CWMI_FILE_IniFile::ReadKeywordNames()
{
    NTSTATUS Status;

    Status = FindSection();
    while (NT_SUCCESS( Status ))
	{
        Status = AdvanceTextPointer( STOP_AT_KEYWORD );
        if (Status == STATUS_MORE_ENTRIES)
		{
            Status = AppendStringToResultBuffer( m_AnsiKeywordName,
                                                 m_UnicodeKeywordName,
                                                 TRUE
                                               );
        }
		else
		{
            if (Status == STATUS_NO_MORE_ENTRIES)
			{
                Status = STATUS_SUCCESS;
            }
            break;
        }
    }

    return Status;
}

NTSTATUS CWMI_FILE_IniFile::ReadKeywordValue()
{
    NTSTATUS Status = FindSection();

    if (!NT_SUCCESS( Status ))
	{
        return Status;
    }

    Status = FindKeyword();

    if (!NT_SUCCESS( Status ))
	{
        return Status;
    }

    if (m_IniFile.m_UnicodeFile)
	{
        LPWSTR Src = (LPWSTR)m_UnicodeKeywordValue->Buffer;

        while (*Src <= L' ' && m_UnicodeKeywordValue->Length)
		{
            Src += 1;
            m_UnicodeKeywordValue->Buffer = Src;
            m_UnicodeKeywordValue->Length -= sizeof( WCHAR );
            m_UnicodeKeywordValue->MaximumLength -= sizeof( WCHAR );
        }

        if (m_UnicodeKeywordValue->Length >= (2 * sizeof( WCHAR )) &&
            (Src[ 0 ] == Src[ (m_UnicodeKeywordValue->Length - sizeof( WCHAR )) / sizeof( WCHAR ) ]) &&
            (Src[ 0 ] == L'"' || Src[ 0 ] == L'\'')
           ) {
            m_UnicodeKeywordValue->Buffer += 1;
            m_UnicodeKeywordValue->Length -= (2 * sizeof( WCHAR ));
            m_UnicodeKeywordValue->MaximumLength -= (2 * sizeof( WCHAR ));
        }
    }
	else
	{
        PBYTE Src;

        Src = (PBYTE)m_AnsiKeywordValue->Buffer;
        while (*Src <= ' ' && m_AnsiKeywordValue->Length) {
            Src += 1;
            m_AnsiKeywordValue->Buffer = (PCHAR)Src;
            m_AnsiKeywordValue->Length -= sizeof( UCHAR );
            m_AnsiKeywordValue->MaximumLength -= sizeof( UCHAR );
        }

        if (m_AnsiKeywordValue->Length >= (2 * sizeof( UCHAR )) &&
            (Src[ 0 ] == Src[ (m_AnsiKeywordValue->Length - sizeof( UCHAR )) / sizeof( UCHAR ) ]) &&
            (Src[ 0 ] == '"' || Src[ 0 ] == '\'')
           ) {
            m_AnsiKeywordValue->Buffer += 1;
            m_AnsiKeywordValue->Length -= (2 * sizeof( UCHAR ));
            m_AnsiKeywordValue->MaximumLength -= (2 * sizeof( UCHAR ));
        }
    }

    return AppendStringToResultBuffer(m_AnsiKeywordValue,
                                              m_UnicodeKeywordValue,
                                              TRUE
                                            );
}

NTSTATUS CWMI_FILE_IniFile::ReadSection()
{
    NTSTATUS Status;

    Status = FindSection();
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    while (TRUE) {
        Status = AdvanceTextPointer( STOP_AT_NONSECTION );
        if (Status == STATUS_MORE_ENTRIES) {
            if (m_AnsiKeywordName || m_UnicodeKeywordName) {
                Status = AppendStringToResultBuffer(m_AnsiKeywordName,
                                                    m_UnicodeKeywordName,
                                                    FALSE
                                                   );
                if (!NT_SUCCESS( Status )) {
                    return Status;
                }

                Status = AppendBufferToResultBuffer(NULL,
                                                            L"=",
                                                            1,
                                                            FALSE
                                                          );
                if (!NT_SUCCESS( Status )) {
                    return Status;
                }
            }

            if (m_IniFile.m_UnicodeFile) {
                LPWSTR Src;

                Src = (LPWSTR)m_UnicodeKeywordValue->Buffer;
                while (*Src <= L' ' && m_UnicodeKeywordValue->Length) {
                    Src += 1;
                    m_UnicodeKeywordValue->Buffer = Src;
                    m_UnicodeKeywordValue->Length -= sizeof( WCHAR );
                    m_UnicodeKeywordValue->MaximumLength -= sizeof( WCHAR );
                }
            } else {
                PBYTE Src;

                Src = (PBYTE)m_AnsiKeywordValue->Buffer;
                while (*Src <= ' ' && m_AnsiKeywordValue->Length) {
                    Src += 1;
                    m_AnsiKeywordValue->Buffer = (PCHAR)Src;
                    m_AnsiKeywordValue->Length -= sizeof( UCHAR );
                    m_AnsiKeywordValue->MaximumLength -= sizeof( UCHAR );
                }
            }

            Status = AppendStringToResultBuffer(m_AnsiKeywordValue,
                                                        m_UnicodeKeywordValue,
                                                        TRUE
                                                      );
            if (!NT_SUCCESS( Status )) {
                return Status;
            }
        } else {
            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }

            break;
        }
    }

    return Status;
}


NTSTATUS CWMI_FILE_IniFile::FindSection()
{
    NTSTATUS Status;
    PANSI_STRING AnsiSectionName;
    PUNICODE_STRING UnicodeSectionName;

    while (TRUE)
	{
        Status = AdvanceTextPointer(STOP_AT_SECTION );

        if (Status == STATUS_MORE_ENTRIES)
		{
            if (m_AnsiSectionName)
			{
                // Ansi ini file -- get the ansi parm
                if (!GetApplicationName(&AnsiSectionName, NULL ))
				{
                    return STATUS_INVALID_PARAMETER;
                }
            }
			else
			{
                // we just need the unicode section name...
                if (!GetApplicationName(NULL, &UnicodeSectionName ))
				{
                    return STATUS_INVALID_PARAMETER;
                }
			}

            if (m_AnsiSectionName == NULL)
			{
                if (RtlEqualUnicodeString( UnicodeSectionName,
                                           m_UnicodeSectionName,
                                           TRUE
                                         )
                   )
				{
                    Status = STATUS_SUCCESS;
                }
				else
				{
                    Status = STATUS_MORE_ENTRIES;
                }
            }
			else
			{
                if (RtlEqualString( AnsiSectionName, m_AnsiSectionName, TRUE ))
				{
                    Status = STATUS_SUCCESS;
                }
				else
				{
                    Status = STATUS_MORE_ENTRIES;
                }
            }

            if (Status != STATUS_MORE_ENTRIES)
			{
                return Status;
            }
        }
		else
		{
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }
}

NTSTATUS CWMI_FILE_IniFile::FindKeyword()
{
    NTSTATUS Status = STATUS_SUCCESS;
    PANSI_STRING AnsiKeywordName;
    PUNICODE_STRING UnicodeKeywordName;

    while (TRUE) {
        Status = AdvanceTextPointer(STOP_AT_KEYWORD);
        if (Status == STATUS_MORE_ENTRIES) {

            // Here's the deal.  We don't want to compare in Unicode
            // unless both the ini and the input parm are Unicode,
            // because we want to avoid the round-trip problem (we
            // lose data when we convert Unicode -> Ansi (on disk) ->
            // Unicode; since we don't get back the original Unicode
            // string, lookups of previously stored data fail -- bug
            // 426754).  So if both are Unicode, great! -- use Unicode.
            // Otherwise, use ansi for everything.

            if (m_AnsiKeywordName) {
                // Ansi ini file -- get the ansi parm
                if (!GetVariableName(&AnsiKeywordName, NULL )) {
                    return STATUS_INVALID_PARAMETER;
                }
            } else {
                //great, get the Unicode parm.
                if (!GetVariableName(NULL, &UnicodeKeywordName )) {
                    return STATUS_INVALID_PARAMETER;
                }
            }

            if (m_AnsiKeywordName == NULL) {
                if (RtlEqualUnicodeString( UnicodeKeywordName,
                                           m_UnicodeKeywordName,
                                           TRUE
                                         )
                   ) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_MORE_ENTRIES;
                }
            } else {
                if (RtlEqualString( AnsiKeywordName, m_AnsiKeywordName, TRUE )) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_MORE_ENTRIES;
                }
            }

            if (Status != STATUS_MORE_ENTRIES) {
                return Status;
            }
        } else {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }
}

NTSTATUS CWMI_FILE_IniFile::AdvanceTextPointer( IN ULONG StopAt )
{
    BOOL AllowNoEquals = FALSE;

    if (StopAt == STOP_AT_NONSECTION)
	{
        StopAt = STOP_AT_KEYWORD;
        AllowNoEquals = TRUE;
    }

    if (m_IniFile.m_UnicodeFile)
	{
        LPWSTR Name, EndOfName, Value, EndOfValue;

#undef INI_TEXT
#define INI_TEXT(quote) L##quote

        LPWSTR Src = (LPWSTR)m_TextCurrent;
        LPWSTR EndOfFile = (LPWSTR)m_TextEnd;

        while (Src < EndOfFile)
		{
            //
            // Find first non-blank character on a line.  Skip blank lines
            //
            while (Src < EndOfFile && *Src <= INI_TEXT(' '))
			{
                Src++;
            }

            if (Src >= EndOfFile)
			{
                m_TextCurrent = Src;
                break;
            }

            LPWSTR EndOfLine = Src;
            LPWSTR EqualSign = NULL;
            m_TextStart = Src;

            while (EndOfLine < EndOfFile)
			{
                if (EqualSign == NULL && *EndOfLine == INI_TEXT('='))
				{
                    EqualSign = ++EndOfLine;
                }
				else if (*EndOfLine == INI_TEXT('\r') || *EndOfLine == INI_TEXT('\n'))
				{
                    if (*EndOfLine == INI_TEXT('\r'))
					{
                        EndOfLine++;
                    }

                    if (*EndOfLine == INI_TEXT('\n'))
					{
                        EndOfLine++;
                    }

                    break;
                }
				else
				{
                    EndOfLine++;
                }
            }

            if (*Src != INI_TEXT(';'))
			{
                if (*Src == INI_TEXT('['))
				{
                    Name = Src + 1;
                    
					while (Name < EndOfLine && *Name <= INI_TEXT(' '))
					{
                        Name++;
                    }
                    
					EndOfName = Name;
                    
					while (EndOfName < EndOfLine && *EndOfName != INI_TEXT(']'))
					{
                        EndOfName++;
                    }

                    while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' '))
					{
                        EndOfName--;
                    }
                    
					m_SectionNameU.Buffer = Name;
                    m_SectionNameU.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                    m_SectionNameU.MaximumLength = m_SectionNameU.Length;
                    m_AnsiSectionName = NULL;
                    m_UnicodeSectionName = &m_SectionNameU;
                    
					if (StopAt == STOP_AT_SECTION)
					{
                        m_TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    }
					else if (StopAt == STOP_AT_KEYWORD)
					{
                        return STATUS_NO_MORE_ENTRIES;
                    }
                }
				else if (AllowNoEquals || (EqualSign != NULL) )
				{
                    if (EqualSign != NULL)
					{
                        Name = Src;
                        EndOfName = EqualSign - 1;
                    
						while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' '))
						{
                            EndOfName--;
                        }

                        m_KeywordNameU.Buffer = Name;
                        m_KeywordNameU.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                        m_KeywordNameU.MaximumLength = m_KeywordNameU.Length;
                        m_AnsiKeywordName = NULL;
                        m_UnicodeKeywordName = &m_KeywordNameU;

                        Value = EqualSign;
                    }
					else
					{
                        Value = Src;
                        m_AnsiKeywordName = NULL;
                        m_UnicodeKeywordName = NULL;
                    }

                    EndOfValue = EndOfLine;
                    
					while (EndOfValue > Value && EndOfValue[ -1 ] <= INI_TEXT(' '))
					{
                        EndOfValue--;
                    }
                    
					m_KeywordValueU.Buffer = Value;
                    m_KeywordValueU.Length = (USHORT)((PCHAR)EndOfValue - (PCHAR)Value);
                    m_KeywordValueU.MaximumLength = m_KeywordValueU.Length;
                    m_AnsiKeywordValue = NULL;
                    m_UnicodeKeywordValue = &m_KeywordValueU;
                    
					if (StopAt == STOP_AT_KEYWORD)
					{
                        m_TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    }
                }
            }

            Src = EndOfLine;
        }
    }
	else
	{
        PBYTE Src, EndOfLine, EqualSign, EndOfFile;
        PBYTE Name, EndOfName, Value, EndOfValue;

#undef INI_TEXT
#define INI_TEXT(quote) quote

        Src = (PBYTE)m_TextCurrent;
        EndOfFile = (PBYTE)m_TextEnd;
        while (Src < EndOfFile)
		{
            //
            // Find first non-blank character on a line.  Skip blank lines
            //

            while (Src < EndOfFile && *Src <= INI_TEXT(' '))
			{
                Src++;
            }

            if (Src >= EndOfFile)
			{
                m_TextCurrent = Src;
                break;
            }

            EndOfLine = Src;
            EqualSign = NULL;
            m_TextStart = Src;

            while (EndOfLine < EndOfFile)
			{
                if (EqualSign == NULL && *EndOfLine == INI_TEXT('='))
				{
                    EqualSign = ++EndOfLine;
                }
				else if (*EndOfLine == INI_TEXT('\r') || *EndOfLine == INI_TEXT('\n'))
				{
                    if (*EndOfLine == INI_TEXT('\r'))
					{
                        EndOfLine++;
                    }

                    if (*EndOfLine == INI_TEXT('\n')) {
                        EndOfLine++;
                    }

                    break;
                }
				else
				{
                    EndOfLine++;
                }
            }

            if (*Src != INI_TEXT(';'))
			{
                if (*Src == INI_TEXT('['))
				{
                    Name = Src + 1;
                
					while (Name < EndOfLine && *Name <= INI_TEXT(' '))
					{
                        Name++;
                    }
                    
					EndOfName = Name;
                    
					while (EndOfName < EndOfLine)
					{
                        if (*EndOfName == INI_TEXT(']'))
						{
                            break;
                        }
                        
						if (IsDBCSLeadByte(*EndOfName))
						{
                            EndOfName++;
                        }
                        
						EndOfName++;
                    }

                    while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' '))
					{
                        EndOfName--;
                    }
                
					m_SectionName.Buffer = (PCHAR)Name;
                    m_SectionName.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                    m_SectionName.MaximumLength = m_SectionName.Length;
                    m_AnsiSectionName = &m_SectionName;
                    m_UnicodeSectionName = NULL;
                    
					if (StopAt == STOP_AT_SECTION)
					{
                        m_TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    }
					else if (StopAt == STOP_AT_KEYWORD)
					{
                        return STATUS_NO_MORE_ENTRIES;
                    }
                }
				else if (AllowNoEquals || (EqualSign != NULL))
				{

                    if (EqualSign != NULL)
					{
                        Name = Src;
                        EndOfName = EqualSign - 1;

                        while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' '))
						{
                            EndOfName--;
                        }

                        m_KeywordName.Buffer = (PCHAR)Name;
                        m_KeywordName.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                        m_KeywordName.MaximumLength = m_KeywordName.Length;
                        m_AnsiKeywordName = &m_KeywordName;
                        m_UnicodeKeywordName = NULL;

                        Value = EqualSign;
                    }
					else
					{
                        Value = Src;
                        m_AnsiKeywordName = NULL;
                        m_UnicodeKeywordName = NULL;
                    }

                    EndOfValue = EndOfLine;
                    
					while (EndOfValue > Value && EndOfValue[ -1 ] <= INI_TEXT(' '))
					{
                        EndOfValue--;
                    }
                    
					m_KeywordValue.Buffer = (PCHAR)Value;
                    m_KeywordValue.Length = (USHORT)((PCHAR)EndOfValue - (PCHAR)Value);
                    m_KeywordValue.MaximumLength = m_KeywordValue.Length;
                    m_AnsiKeywordValue = &m_KeywordValue;
                    m_UnicodeKeywordValue = NULL;
                    
					if (StopAt == STOP_AT_KEYWORD)
					{
                        m_TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    }
                }
            }

            Src = EndOfLine;
        }
    }

    return STATUS_NO_MORE_ENTRIES;
}


BOOL CWMI_FILE_IniFile::GetApplicationName(
                         OUT PANSI_STRING *ApplicationName OPTIONAL,
                         OUT PUNICODE_STRING *ApplicationNameU OPTIONAL
                         )
{
    NTSTATUS Status;

    if (ApplicationName)
	{
        if (m_ApplicationName.Length == 0)
		{
			m_ApplicationName.Buffer = new char[(m_ApplicationNameU.Length * sizeof(WORD)) + 1]; //MBCS strings
			m_ApplicationName.MaximumLength = (m_ApplicationNameU.Length * sizeof(WORD)) + 1; 
            Status = RtlUnicodeStringToAnsiString( &m_ApplicationName, &m_ApplicationNameU, FALSE );
        
			if (!NT_SUCCESS( Status ))
			{
                return FALSE;
            }
        }

        *ApplicationName = &m_ApplicationName;
        return TRUE;
    }

    if (ApplicationNameU)
	{
        if (m_ApplicationNameU.Length == 0)
		{
            return FALSE;
        }

        *ApplicationNameU = &m_ApplicationNameU;
        return TRUE;
    }

    return FALSE;
}

BOOL CWMI_FILE_IniFile::GetVariableName(
                      OUT PANSI_STRING *VariableName OPTIONAL,
                      OUT PUNICODE_STRING *VariableNameU OPTIONAL
                      )
{
    NTSTATUS Status;

    if (ARGUMENT_PRESENT( VariableName ))
	{
        if (m_VariableName.Length == 0)
		{
			m_VariableName.Buffer = new char[(m_VariableNameU.Length * sizeof(WORD)) + 1]; //MBCS strings
			m_VariableName.MaximumLength = (m_VariableNameU.Length * sizeof(WORD)) + 1;
            Status = RtlUnicodeStringToAnsiString( &m_VariableName, &m_VariableNameU, FALSE );

            if (!NT_SUCCESS( Status ))
			{
                return FALSE;
            }
        }

        *VariableName = &m_VariableName;
        return TRUE;
    }

    if (ARGUMENT_PRESENT( VariableNameU ))
	{
        if (m_VariableNameU.Length == 0)
		{
		   return FALSE;
        }

        *VariableNameU = &m_VariableNameU;
        return TRUE;
    }

    return FALSE;
}

BOOL CWMI_FILE_IniFile::GetVariableValue(
                       OUT PBYTE *VariableValue OPTIONAL,
                       OUT LPWSTR *VariableValueU OPTIONAL,
                       OUT PULONG VariableValueLength
                       )
{
    NTSTATUS Status;
    ULONG Index;

    if (VariableValue)
	{
        if (m_ValueLength == 0)
		{
            if (m_ValueBufferU == NULL || m_ValueLengthU == 0)
			{
                *VariableValue = NULL;
                *VariableValueLength = sizeof ( UCHAR );
                return TRUE;
            }

			m_ValueBuffer = new char[m_ValueLengthU + 1]; //DBCS
            m_ValueLength = m_ValueLengthU;
            Status = RtlUnicodeToMultiByteN( (PCHAR)m_ValueBuffer,
                                             m_ValueLength,
                                             &Index,
                                             m_ValueBufferU,
                                             m_ValueLengthU
                                           );

            if (!NT_SUCCESS( Status ))
			{
                return FALSE;
            }

            // Set real converted size
            m_ValueLength = Index;
            m_ValueBuffer[ Index ] = '\0';       // Null terminate converted value
        }
		else
		{
            Index = m_ValueLength;
        }

        *VariableValue = (PBYTE)m_ValueBuffer;
        *VariableValueLength = Index + 1;
        return TRUE;
    }

    if (VariableValueU)
	{
        if (m_ValueLengthU == 0)
		{
            if (m_ValueBuffer == NULL || m_ValueLength == 0)
			{
                *VariableValueU = NULL;
                *VariableValueLength = sizeof ( WCHAR );
                return TRUE;
            }
            else
			{
                return FALSE;
            }
        }
		else
		{
            Index = m_ValueLengthU / sizeof( WCHAR );
        }

        *VariableValueU = m_ValueBufferU;
        *VariableValueLength = (Index + 1) * sizeof( WCHAR );
        return TRUE;
    }

    return FALSE;
}


NTSTATUS  CWMI_FILE_IniFile::AppendStringToResultBuffer(
                                 IN PANSI_STRING String OPTIONAL,
                                 IN PUNICODE_STRING StringU OPTIONAL,
                                 IN BOOL IncludeNull
                                 )
{
    if (String)
	{
        if (StringU)
		{
            return STATUS_INVALID_PARAMETER;
        }
		else
		{
            return AppendBufferToResultBuffer((PBYTE)String->Buffer,
                                                      NULL,
                                                      String->Length,
                                                      IncludeNull
                                                    );
        }
    }
	else if (StringU)
	{
        if (String)
		{
            return STATUS_INVALID_PARAMETER;
        }
		else
		{
            return AppendBufferToResultBuffer(NULL,
                                                      StringU->Buffer,
                                                      StringU->Length / sizeof( WCHAR ),
                                                      IncludeNull
                                                    );
        }
    }
	else
	{
        return STATUS_INVALID_PARAMETER;
    }
}

NTSTATUS CWMI_FILE_IniFile::AppendBufferToResultBuffer(
                                 IN PBYTE Buffer OPTIONAL,
                                 IN LPWSTR BufferU OPTIONAL,
                                 IN ULONG Chars,
                                 IN BOOL IncludeNull
                                 )
{
    NTSTATUS Status, OverflowStatus;
    ULONG Index;

    OverflowStatus = STATUS_SUCCESS;

    if (Buffer)
	{
        if (BufferU)
		{
            return STATUS_INVALID_PARAMETER;
        }
		else
		{
            ULONG CharsMbcs = Chars;
            //
            // In this point, Chars does not contains proper value for Unicode.
            // because. Chars was computed based on DBCS string length,
            // This is correct, sources string is DBCS, then
            // if the source is not DBCS. we just adjust it here.
            //
            Status = RtlMultiByteToUnicodeSize(&Chars,(PCSTR)Buffer,Chars);
            
			if (!NT_SUCCESS( Status ))
			{
                return Status;
            }

			Chars /= sizeof(WCHAR);

            if (m_ResultChars + Chars >= m_ResultMaxChars)
			{
                OverflowStatus = STATUS_BUFFER_OVERFLOW;
                Chars = m_ResultMaxChars - m_ResultChars;
            
				if (Chars) {
                    Chars -= 1;
                }
            }

            if (Chars)
			{
                Status = RtlMultiByteToUnicodeN( (PWSTR)(m_ResultBufferU + m_ResultChars),
                                                 Chars * sizeof( WCHAR ),
                                                 &Index,
                                                 (PCSTR)Buffer,
                                                 CharsMbcs
                                               );
                if (!NT_SUCCESS( Status ))
				{
                    return Status;
                }

                m_ResultChars += Chars;
            }
        }
    }
	else if (BufferU)
	{
        if (Buffer)
		{
            return STATUS_INVALID_PARAMETER;
        }
		else
		{
            ULONG CharsUnicode = Chars;

            if (m_ResultChars + Chars >= m_ResultMaxChars)
			{
                OverflowStatus = STATUS_BUFFER_OVERFLOW;
                Chars = m_ResultMaxChars - m_ResultChars;
                
				if (Chars)
				{
                    Chars -= 1;
                }
            }

            if (Chars)
			{
                memcpy( (LPVOID)(m_ResultBufferU + m_ResultChars), BufferU, Chars * sizeof( WCHAR ) );

                m_ResultChars += Chars;
            }
        }
    }

    if (IncludeNull)
	{
        if (m_ResultChars + 1 >= m_ResultMaxChars)
		{
            return STATUS_BUFFER_OVERFLOW;
        }

        m_ResultBufferU[ m_ResultChars ] = L'\0';
        m_ResultChars += 1;
    }

    return OverflowStatus;
}

NTSTATUS  CWMI_FILE_IniFile::WriteKeywordValue(
                        IN PUNICODE_STRING VariableName OPTIONAL
                        )
{
    NTSTATUS Status;
    BOOL InsertSectionName;
    BOOL InsertKeywordName;
    ULONG InsertAmount, n;
    PANSI_STRING AnsiSectionName;
    PANSI_STRING AnsiKeywordName;
    PUNICODE_STRING UnicodeSectionName;
    PUNICODE_STRING UnicodeKeywordName;
    PBYTE AnsiKeywordValue;
    LPWSTR UnicodeKeywordValue;
    ULONG ValueLength;
    ULONG DeleteLength;
    PVOID AddressInFile;

    InsertAmount = 0;
    Status = FindSection( );

    if (!NT_SUCCESS( Status ))
	{
        AddressInFile = m_TextEnd;
     
		if (m_IniFile.m_UnicodeFile)
		{
            if (!GetApplicationName(NULL, &UnicodeSectionName ))
			{
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( WCHAR );
            InsertAmount += UnicodeSectionName->Length;
        }
		else
		{
            if (!GetApplicationName(&AnsiSectionName, NULL ))
			{
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( UCHAR );
            InsertAmount += AnsiSectionName->Length;
        }

        InsertSectionName = TRUE;
    }
	else
	{
        InsertSectionName = FALSE;
        Status = FindKeyword( );
    }

    if (!NT_SUCCESS( Status ))
	{
        if (!InsertSectionName)
		{
            AddressInFile = m_TextCurrent;
        }

        if (m_IniFile.m_UnicodeFile)
		{
            if (!GetVariableName(NULL, &UnicodeKeywordName ))
			{
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of Keyword=\r\n
            //

            InsertAmount += (1 + 2) * sizeof( WCHAR );
            InsertAmount += UnicodeKeywordName->Length;
        }
		else
		{
            if (!GetVariableName(&AnsiKeywordName, NULL ))
			{
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of Keyword=\r\n
            //

            InsertAmount += (1 + 2) * sizeof( UCHAR );
            InsertAmount += AnsiKeywordName->Length;
        }

        InsertKeywordName = TRUE;
    }
	else
	{
        if (m_IniFile.m_UnicodeFile)
		{
                AddressInFile = m_UnicodeKeywordValue->Buffer;
        }
		else
		{
            AddressInFile = m_AnsiKeywordValue->Buffer;
        }
        InsertKeywordName = FALSE;
    }

    if (m_IniFile.m_UnicodeFile)
	{
        if (!GetVariableValue( NULL, &UnicodeKeywordValue, &ValueLength ))
		{
            return STATUS_INVALID_PARAMETER;
        }
        
		ValueLength -= sizeof( WCHAR );

        if (InsertAmount == 0)
		{
            return ModifyMappedFile(m_UnicodeKeywordValue->Buffer,
                                            m_UnicodeKeywordValue->Length,
                                            UnicodeKeywordValue,
                                            ValueLength
                                          );
        }

        //
        // Add in size of value
        //

        InsertAmount += ValueLength;
    }
	else
	{
        if (!GetVariableValue(&AnsiKeywordValue, NULL, &ValueLength ))
		{
            return STATUS_INVALID_PARAMETER;
        }
        
		ValueLength -= sizeof( UCHAR );

        if (InsertAmount == 0)
		{
            return ModifyMappedFile(m_AnsiKeywordValue->Buffer,
                                            m_AnsiKeywordValue->Length,
                                            AnsiKeywordValue,
                                            ValueLength
                                          );
        }

        //
        // Add in size of value
        //

        InsertAmount += ValueLength;
    }
	
	PVOID InsertBuffer = NULL;
    InsertBuffer = (PVOID) new BYTE[InsertAmount  + sizeof( L'\0' )];

	try
	{
		if (m_IniFile.m_UnicodeFile)
		{
			LPWSTR Src, Dst;

			Dst = (LPWSTR)InsertBuffer;
    
			if (InsertSectionName)
			{
				*Dst++ = L'[';
				Src = UnicodeSectionName->Buffer;
				n = UnicodeSectionName->Length / sizeof( WCHAR );
        
				while (n--)
				{
					*Dst++ = *Src++;
				}
            
				*Dst++ = L']';
				*Dst++ = L'\r';
				*Dst++ = L'\n';
			}

			if (InsertKeywordName)
			{
				Src = UnicodeKeywordName->Buffer;
				n = UnicodeKeywordName->Length / sizeof( WCHAR );
        
				while (n--)
				{
					*Dst++ = *Src++;
				}
            
				*Dst++ = L'=';
			}

			Src = UnicodeKeywordValue;
			n = ValueLength / sizeof( WCHAR );
        
			while (n--)
			{
				*Dst++ = *Src++;
			}

			if (InsertKeywordName)
			{
				*Dst++ = L'\r';
				*Dst++ = L'\n';
			}
		}
		else
		{
			PBYTE Src, Dst;

			Dst = (PBYTE)InsertBuffer;
        
			if (InsertSectionName)
			{
				*Dst++ = '[';
				Src = (PBYTE)AnsiSectionName->Buffer;
				n = AnsiSectionName->Length;
        
				while (n--)
				{
					*Dst++ = *Src++;
				}
            
				*Dst++ = ']';
				*Dst++ = '\r';
				*Dst++ = '\n';
			}

			if (InsertKeywordName)
			{
				Src = (PBYTE)AnsiKeywordName->Buffer;
				n = AnsiKeywordName->Length;
        
				while (n--)
				{
					*Dst++ = *Src++;
				}
            
				*Dst++ = '=';
			}

			Src = AnsiKeywordValue;
			n = ValueLength;

			while (n--)
			{
				*Dst++ = *Src++;
			}

			if (InsertKeywordName)
			{
				*Dst++ = '\r';
				*Dst++ = '\n';
			}
		}

		Status = ModifyMappedFile(AddressInFile,
										  0,
										  InsertBuffer,
										  InsertAmount
										);
		delete [] ((BYTE*) InsertBuffer);
		InsertBuffer = NULL;
	}
	catch(...)
	{
		if (InsertBuffer)
		{
			delete [] ((BYTE*) InsertBuffer);
			InsertBuffer = NULL;
		}

		throw;
	}

    return Status;
}

NTSTATUS CWMI_FILE_IniFile::ModifyMappedFile(
                       IN PVOID AddressInFile,
                       IN ULONG SizeToRemove,
                       IN PVOID InsertBuffer,
                       IN ULONG InsertAmount
                       )
{
    NTSTATUS Status;
    ULONG NewEndOfFile, UpdateOffset, UpdateLength;

    NewEndOfFile = m_IniFile.m_EndOfFile - SizeToRemove + InsertAmount;
    
	if (NewEndOfFile > m_IniFile.m_CommitSize)
	{
        if (NewEndOfFile > m_IniFile.m_RegionSize)
		{
            return STATUS_BUFFER_OVERFLOW;
        }

        m_IniFile.m_CommitSize = NewEndOfFile;
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &m_IniFile.m_BaseAddress,
                                          0,
                                          &m_IniFile.m_CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (!NT_SUCCESS( Status )) {
            return Status;
        }

        m_IniFile.m_EndOfFile = NewEndOfFile;
    }

    UpdateOffset = (ULONG)((PCHAR)AddressInFile - (PCHAR)(m_IniFile.m_BaseAddress)),
                   UpdateLength = (ULONG)((PCHAR)m_TextEnd - (PCHAR)AddressInFile) + InsertAmount - SizeToRemove;
    //
    // Are we deleting more than we are inserting?
    //
    if (SizeToRemove > InsertAmount)
	{
        //
        // Yes copy over insert string.
        //
        RtlMoveMemory( AddressInFile, InsertBuffer, InsertAmount );

        //
        // Delete remaining text after insertion string by moving it
        // up
        //

        RtlMoveMemory( (PCHAR)AddressInFile + InsertAmount,
                       (PCHAR)AddressInFile + SizeToRemove,
                       UpdateLength - InsertAmount
                     );
    }
	else if (InsertAmount > 0)
	{
        //
        // Are we deleting less than we are inserting?
        //
        if (SizeToRemove < InsertAmount)
		{
            //
            // Move text down to make room for insertion
            //

            RtlMoveMemory( (PCHAR)AddressInFile + InsertAmount - SizeToRemove,
                           (PCHAR)AddressInFile,
                           UpdateLength - InsertAmount + SizeToRemove
                         );
        }
		else
		{
            //
            // Deleting and inserting same amount, update just that text as
            // no shifting was done.
            //

            UpdateLength = InsertAmount;
        }

        //
        // Copy over insert string
        //

        RtlMoveMemory( AddressInFile, InsertBuffer, InsertAmount );
    }
	else
	{
        //
        // Nothing to change, as InsertAmount and SizeToRemove are zero
        //
        return STATUS_SUCCESS;
    }

    if (m_IniFile.m_EndOfFile != NewEndOfFile)
	{
        m_IniFile.m_EndOfFile = NewEndOfFile;
    }

    if (UpdateOffset < m_IniFile.m_UpdateOffset)
	{
        m_IniFile.m_UpdateOffset = UpdateOffset;
    }

    if ((UpdateOffset + UpdateLength) > m_IniFile.m_UpdateEndOffset)
	{
        m_IniFile.m_UpdateEndOffset = UpdateOffset + UpdateLength;
    }

    return STATUS_SUCCESS;
}

NTSTATUS CWMI_FILE_IniFile::WriteSection()
{
    NTSTATUS Status;
    BOOLEAN InsertSectionName;
    ULONG InsertAmount, n;
    PANSI_STRING AnsiSectionName;
    PUNICODE_STRING UnicodeSectionName;
    PBYTE AnsiKeywordValue, s;
    PWSTR UnicodeKeywordValue, w;
    ULONG ValueLength, SizeToRemove;
    PVOID AddressInFile;

    InsertAmount = 0;
    Status = FindSection();

    if (!NT_SUCCESS( Status ))
	{
        AddressInFile = m_TextEnd;
        if (m_IniFile.m_UnicodeFile)
		{
            if (!GetApplicationName(NULL, &UnicodeSectionName ))
			{
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( WCHAR );
            InsertAmount += UnicodeSectionName->Length;
        }
		else
		{
            if (!GetApplicationName(&AnsiSectionName, NULL ))
			{
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( UCHAR );
            InsertAmount += AnsiSectionName->Length;
        }

        InsertSectionName = TRUE;
        SizeToRemove = 0;
    }
	else
	{
		AddressInFile = m_TextCurrent;
        
		while (TRUE)
		{
            //
            // For delete operations need to iterate all lines in section,
            // not just those that have an = on them. Otherwise sections like
            // [foo]
            // a
            // b = c
            // d
            //
            // don't get deleted properly.
            //
            Status = AdvanceTextPointer(STOP_AT_KEYWORD);

            if (Status == STATUS_MORE_ENTRIES)
			{
            }
			else if (Status == STATUS_NO_MORE_ENTRIES)
			{
                SizeToRemove = (ULONG)((PCHAR)m_TextCurrent - (PCHAR)AddressInFile);
                break;
            }
			else
			{
                return Status;
            }
        }

        InsertSectionName = FALSE;
    }

    if (m_IniFile.m_UnicodeFile)
	{
        if (!GetVariableValue(NULL, &UnicodeKeywordValue, &ValueLength ))
		{
            return STATUS_INVALID_PARAMETER;
        }
        
		ValueLength -= sizeof( WCHAR );

        //
        // Add in size of value, + \r\n for each line
        //

        w = UnicodeKeywordValue;
        InsertAmount += ValueLength;
        
		while (w && *w)
		{
            while (*w++)
			{
            }
            
			InsertAmount += (2-1) * sizeof( WCHAR );    // Subtract out NULL byte already in ValueLength
        }
    }
	else
	{
        if (!GetVariableValue(&AnsiKeywordValue, NULL, &ValueLength ))
		{
            return STATUS_INVALID_PARAMETER;
        }
        
		ValueLength -= sizeof( UCHAR );

        //
        // Add in size of value, + \r\n for each line
        //

        s = AnsiKeywordValue;
        InsertAmount += ValueLength;
        
		while (s && *s)
		{
            while (*s++)
			{
            }
            InsertAmount += 2 - 1;      // Subtract out NULL byte already in ValueLength
        }
    }

	PVOID InsertBuffer = NULL;
    InsertBuffer = (PVOID) new BYTE[InsertAmount + sizeof( L'\0' )];

	try
	{
		if (m_IniFile.m_UnicodeFile)
		{
			PWSTR Src, Dst;

			Dst = (PWSTR)InsertBuffer;
        
			if (InsertSectionName)
			{
				*Dst++ = L'[';
				Src = UnicodeSectionName->Buffer;
				n = UnicodeSectionName->Length / sizeof( WCHAR );
            
				while (n--)
				{
					*Dst++ = *Src++;
				}
            
				*Dst++ = L']';
				*Dst++ = L'\r';
				*Dst++ = L'\n';
			}

			Src = UnicodeKeywordValue;
        
			while (*Src)
			{
				while (*Dst = *Src++)
				{
					Dst += 1;
				}

				*Dst++ = L'\r';
				*Dst++ = L'\n';
			}
		}
		else
		{
			PBYTE Src, Dst;

			Dst = (PBYTE)InsertBuffer;
			if (InsertSectionName) {
				*Dst++ = '[';
				Src = (PBYTE)AnsiSectionName->Buffer;
				n = AnsiSectionName->Length;
				while (n--) {
					*Dst++ = *Src++;
				}
				*Dst++ = ']';
				*Dst++ = '\r';
				*Dst++ = '\n';
			}

			Src = AnsiKeywordValue;
    
			while (*Src)
			{
				while (*Dst = *Src++)
				{
					Dst += 1;
				}

				*Dst++ = '\r';
				*Dst++ = '\n';
			}
		}

		Status = ModifyMappedFile(AddressInFile,
										  SizeToRemove,
										  InsertBuffer,
										  InsertAmount
										);
		delete [] ((BYTE*) InsertBuffer);
		InsertBuffer = NULL;
	}
	catch(...)
	{
		if (InsertBuffer)
		{
			delete [] ((BYTE*) InsertBuffer);
			InsertBuffer = NULL;
		}

		throw;
	}

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\wmi_fileprivateprofile.h ===
/*****************************************************************************/
/*
/*  Copyright (c) 2001 Microsoft Corporation, All Rights Reserved            /
/*
/*****************************************************************************/

#ifndef __WMI_FilePrivateProfile_H__
#define __WMI_FilePrivateProfile_H__

DWORD
APIENTRY
WMI_FILE_GetPrivateProfileStringW(
                        LPCWSTR lpAppName,
                        LPCWSTR lpKeyName,
                        LPCWSTR lpDefault,
                        LPWSTR lpReturnedString,
                        DWORD nSize,
                        LPCWSTR lpFileName
                        );

UINT
APIENTRY
WMI_FILE_GetPrivateProfileIntW(
                     LPCWSTR lpAppName,
                     LPCWSTR lpKeyName,
                     INT nDefault,
                     LPCWSTR lpFileName
                     );

BOOL
APIENTRY
WMI_FILE_WritePrivateProfileStringW(
                          LPCWSTR lpAppName,
                          LPCWSTR lpKeyName,
                          LPCWSTR lpString,
                          LPCWSTR lpFileName
                          );

DWORD
APIENTRY
WMI_FILE_GetPrivateProfileSectionW(
                         LPCWSTR lpAppName,
                         LPWSTR lpReturnedString,
                         DWORD nSize,
                         LPCWSTR lpFileName
                         );
BOOL
APIENTRY
WMI_FILE_WritePrivateProfileSectionW(
                           LPCWSTR lpAppName,
                           LPCWSTR lpString,
                           LPCWSTR lpFileName
                           );





class CWMI_FILE_IniFileObject
{
public:
    ULONG m_EnvironmentUpdateCount;
    HANDLE m_FileHandle;
    BOOL m_WriteAccess;
    BOOL m_UnicodeFile;
    BOOL m_LockedFile;
    ULONG m_EndOfFile;
    PVOID m_BaseAddress;
    SIZE_T m_CommitSize;
    SIZE_T m_RegionSize;
    ULONG m_UpdateOffset;
    ULONG m_UpdateEndOffset;
    ULONG m_DirectoryInformationLength;
    FILE_STANDARD_INFORMATION m_StandardInformation;

	CWMI_FILE_IniFileObject();
	~CWMI_FILE_IniFileObject();
};

class CWMI_FILE_IniFile
{
public:

	typedef enum _INIFILE_OPERATION {
    Enum_ReadKeyValueOp,
    Enum_WriteKeyValueOp,
	Enum_ReadKeyNamesOp,
	Enum_ReadSectionNamesOp,
    Enum_ReadSectionOp,
    Enum_WriteSectionOp
	} INIFILE_OPERATION;

    INIFILE_OPERATION m_Operation;
    BOOL m_IsWriteOperation;
    CWMI_FILE_IniFileObject m_IniFile;
    LPCWSTR m_FileName;
    ANSI_STRING m_ApplicationName;
    ANSI_STRING m_VariableName;
    UNICODE_STRING m_ApplicationNameU;
    UNICODE_STRING m_VariableNameU;
    BOOL m_IsMultiValueStrings;

    LPSTR m_ValueBuffer;
    ULONG m_ValueLength;
    LPWSTR m_ValueBufferU;
    ULONG m_ValueLengthU;
    ULONG m_ResultChars;
    ULONG m_ResultMaxChars;
    LPWSTR m_ResultBufferU;

    PVOID m_TextCurrent;
    PVOID m_TextStart;
    PVOID m_TextEnd;

    ANSI_STRING m_SectionName;
    ANSI_STRING m_KeywordName;
    ANSI_STRING m_KeywordValue;
    PANSI_STRING m_AnsiSectionName;
    PANSI_STRING m_AnsiKeywordName;
    PANSI_STRING m_AnsiKeywordValue;
    UNICODE_STRING m_SectionNameU;
    UNICODE_STRING m_KeywordNameU;
    UNICODE_STRING m_KeywordValueU;
    PUNICODE_STRING m_UnicodeSectionName;
    PUNICODE_STRING m_UnicodeKeywordName;
    PUNICODE_STRING m_UnicodeKeywordValue;


	CWMI_FILE_IniFile();
	~CWMI_FILE_IniFile();

	static NTSTATUS ReadWriteIniFile(
                       IN BOOL WriteOperation,
                       IN BOOL SectionOperation,
                       IN LPCWSTR FileName,
                       IN LPCWSTR ApplicationName,
                       IN LPCWSTR VariableName,
                       IN OUT LPWSTR VariableValue,
                       IN OUT PULONG VariableValueLength
                       );

	NTSTATUS CaptureIniFileParameters(
                               INIFILE_OPERATION a_Operation,
                               BOOL a_WriteOperation,
                               BOOL a_MultiValueStrings,
                               LPCWSTR a_FileName,
                               LPCWSTR a_ApplicationName,
                               LPCWSTR a_VariableName,
                               LPWSTR a_VariableValue,
                               PULONG a_ResultMaxChars
                               );

	NTSTATUS OpenIniFileOnDisk();

	NTSTATUS ReadWriteIniFileOnDisk();

	NTSTATUS CloseIniFileOnDisk();

	NTSTATUS ReadKeywordValue();

	NTSTATUS ReadKeywordNames();

	NTSTATUS ReadSection();

	NTSTATUS ReadSectionNames();

	NTSTATUS AdvanceTextPointer(
						IN ULONG StopAt
						);

	NTSTATUS FindSection();

	NTSTATUS FindKeyword();

	BOOL GetApplicationName(
                         OUT PANSI_STRING *ApplicationName OPTIONAL,
                         OUT PUNICODE_STRING *ApplicationNameU OPTIONAL
                         );

	BOOL GetVariableName(
                      OUT PANSI_STRING *VariableName OPTIONAL,
                      OUT PUNICODE_STRING *VariableNameU OPTIONAL
                      );

	BOOL GetVariableValue(
                       OUT PBYTE *VariableValue OPTIONAL,
                       OUT LPWSTR *VariableValueU OPTIONAL,
                       OUT PULONG VariableValueLength
                       );

	NTSTATUS  AppendStringToResultBuffer(
                                 IN PANSI_STRING String OPTIONAL,
                                 IN PUNICODE_STRING StringU OPTIONAL,
                                 IN BOOL IncludeNull
                                 );

	NTSTATUS AppendBufferToResultBuffer(
                                 IN PBYTE Buffer OPTIONAL,
                                 IN LPWSTR BufferU OPTIONAL,
                                 IN ULONG Chars,
                                 IN BOOL IncludeNull
								 );

	NTSTATUS  WriteKeywordValue(
                        IN PUNICODE_STRING VariableName OPTIONAL
                        );

	NTSTATUS ModifyMappedFile(
                       IN PVOID AddressInFile,
                       IN ULONG SizeToRemove,
                       IN PVOID InsertBuffer,
                       IN ULONG InsertAmount
                       );

	NTSTATUS WriteSection();

	NTSTATUS AppendNullToResultBuffer()
	{
		return AppendBufferToResultBuffer(NULL,
												  NULL,
												  0,
												  TRUE
												);
	}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\wsock32api.cpp ===
//=================================================================

//

// Wsock32API.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>
#include "Wsock32Api.h"
#include "DllWrapperCreatorReg.h"

// {D60E9C22-D127-11d2-911F-0060081A46FD}
static const GUID g_guidWsock32Api =
{0xd60e9c22, 0xd127, 0x11d2, {0x91, 0x1f, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};

static const TCHAR g_tstrWsock32[] = _T("WSOCK32.DLL");

/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CWsock32Api, &g_guidWsock32Api, g_tstrWsock32> MyRegisteredWsock32Wrapper;

/******************************************************************************
 * Constructor
 ******************************************************************************/
CWsock32Api::CWsock32Api(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnWsControl(NULL),
   m_pfnWsEnumProtocols(NULL),
   m_pfnWsCloseSocket(NULL),
   m_pfnWsStartup(NULL),
   m_pfnWsCleanup(NULL) ,
   m_pfnWsGetSockopt(NULL) ,
   m_pfnWsBind(NULL),
   m_pfnWsSocket(NULL),
   m_pfnWsWSAGetLastError(NULL),
   m_pfnWsInet_NtoA(NULL)
{
}

/******************************************************************************
 * Destructor
 ******************************************************************************/
CWsock32Api::~CWsock32Api()
{
}

/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CWsock32Api::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
#ifdef WIN9XONLY
        m_pfnWsControl = (PFN_WSOCK32_WSCONTROL) GetProcAddress("WsControl");
		m_pfnWsEnumProtocols = (PFN_WSOCK32_ENUMPROTOCOLS) GetProcAddress("EnumProtocolsA");
		m_pfnWsStartup = (PFN_WSOCK32_STARTUP) GetProcAddress("WSAStartup");
		m_pfnWsCleanup = (PFN_WSOCK32_CLEANUP) GetProcAddress("WSACleanup");
		m_pfnWsCloseSocket = (PFN_WSOCK32_CLOSESOCKET) GetProcAddress("closesocket");
		m_pfnWsGetSockopt = ( PFN_WSOCK32_GETSOCKOPT ) GetProcAddress("getsockopt");
		m_pfnWsBind = ( PFN_WSOCK32_BIND ) GetProcAddress("bind");
		m_pfnWsSocket = ( PFN_WSOCK32_SOCKET )GetProcAddress("socket");;
		m_pfnWsWSAGetLastError = ( PFN_WSOCK32_WSAGETLASTERROR )GetProcAddress("WSAGetLastError"); ;
		m_pfnWsInet_NtoA = ( PFN_WSOCK32_INET_NTOA )GetProcAddress("inet_ntoa"); ;

	    // Check that we have function pointers to functions that should be
        // present...

        if ( m_pfnWsControl == NULL ||
			 m_pfnWsEnumProtocols == NULL ||
			 m_pfnWsStartup == NULL ||
			 m_pfnWsCleanup == NULL ||
			 m_pfnWsCloseSocket == NULL ||
			 m_pfnWsGetSockopt == NULL ||
			 m_pfnWsBind == NULL ||
			 m_pfnWsSocket == NULL ||
			 m_pfnWsWSAGetLastError == NULL ||
			 m_pfnWsInet_NtoA == NULL )
        {
            fRet = false;
            LogErrorMessage(L"Failed find entrypoint in wsock32api");
        }
#else
		m_pfnWsEnumProtocols = (PFN_WSOCK32_ENUMPROTOCOLS) GetProcAddress("EnumProtocolsW");
		m_pfnWsStartup = (PFN_WSOCK32_STARTUP) GetProcAddress("WSAStartup");
		m_pfnWsCleanup = (PFN_WSOCK32_CLEANUP) GetProcAddress("WSACleanup");
		m_pfnWsCloseSocket = (PFN_WSOCK32_CLOSESOCKET) GetProcAddress("closesocket");
		m_pfnWsGetSockopt = ( PFN_WSOCK32_GETSOCKOPT ) GetProcAddress("getsockopt");
		m_pfnWsBind = ( PFN_WSOCK32_BIND ) GetProcAddress("bind");
		m_pfnWsSocket = ( PFN_WSOCK32_SOCKET )GetProcAddress("socket");;
		m_pfnWsWSAGetLastError = ( PFN_WSOCK32_WSAGETLASTERROR )GetProcAddress("WSAGetLastError"); ;
		m_pfnWsInet_NtoA = ( PFN_WSOCK32_INET_NTOA )GetProcAddress("inet_ntoa"); ;

        if ( m_pfnWsEnumProtocols == NULL ||
			 m_pfnWsStartup == NULL ||
			 m_pfnWsCleanup == NULL ||
			 m_pfnWsCloseSocket == NULL ||
	 		 m_pfnWsGetSockopt == NULL ||
			 m_pfnWsBind == NULL ||
			 m_pfnWsSocket == NULL ||
			 m_pfnWsWSAGetLastError == NULL ||
			 m_pfnWsInet_NtoA == NULL )
        {
            fRet = false;
            LogErrorMessage(L"Failed find entrypoint in wsock32api");
        }

#endif

    }
    return fRet;
}




/******************************************************************************
 * Member functions wrapping Wsock32 api functions. Add new functions here
 * as required.
 ******************************************************************************/
bool CWsock32Api::WsControl
(
    DWORD a_dw1,
    DWORD a_dw2,
    LPVOID a_lpv1,
    LPDWORD a_lpdw1,
    LPVOID a_lpv2,
    LPDWORD a_lpdw2,
    DWORD *a_pdwRetval
)
{
    bool t_fExists = false;
    if(m_pfnWsControl != NULL)
    {
        DWORD t_dwTemp = m_pfnWsControl(a_dw1, a_dw2, a_lpv1,
                                        a_lpdw1, a_lpv2, a_lpdw2);

        t_fExists = true;

        if(a_pdwRetval != NULL)
        {
            *a_pdwRetval = t_dwTemp;
        }
    }
    return t_fExists;
}

INT CWsock32Api::WsEnumProtocols (

	LPINT lpiProtocols,
	LPVOID lpProtocolBuffer,
	LPDWORD lpdwBufferLength
)
{
	return 	m_pfnWsEnumProtocols (

		lpiProtocols,
		lpProtocolBuffer,
		lpdwBufferLength
	) ;
}

INT CWsock32Api :: WsWSAStartup (

	IN WORD wVersionRequired,
	OUT LPWSADATA lpWSAData
)
{
	return m_pfnWsStartup (

		wVersionRequired ,
		lpWSAData
	) ;
}

INT CWsock32Api :: WsWSACleanup ()
{
	return m_pfnWsCleanup () ;
}

INT CWsock32Api :: Wsclosesocket ( SOCKET s )
{
	return m_pfnWsCloseSocket ( s ) ;
}

int CWsock32Api :: Wsbind (

	SOCKET s,
    const struct sockaddr FAR *addr,
    int namelen
)
{
	return m_pfnWsBind (

		s,
		addr,
		namelen
	) ;
}

int CWsock32Api :: Wsgetsockopt (

   SOCKET s,
   int level,
   int optname,
   char FAR * optval,
   int FAR *optlen
)
{
	return m_pfnWsGetSockopt (

		s,
		level,
		optname,
		optval,
		optlen
	) ;
}

SOCKET CWsock32Api :: Wssocket (

	int af,
	int type,
	int protocol
)
{
	return m_pfnWsSocket (

		af,
		type,
		protocol
	) ;
}

int CWsock32Api :: WsWSAGetLastError(void)
{
	return m_pfnWsWSAGetLastError () ;
}

char *CWsock32Api :: Wsinet_ntoa (

	struct in_addr in
)
{
	return m_pfnWsInet_NtoA (

		in
	) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\wsock32api.h ===
//=================================================================

//

// Wsock32Api.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_WSOCK32API_H_
#define	_WSOCK32API_H_

#include <winsock.h>
#include <tdiinfo.h>
#include <llinfo.h>
#include <tdistat.h>
#include <ipinfo.h>

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "DllWrapperBase.h"

extern const GUID g_guidWsock32Api;
extern const TCHAR g_tstrWsock32[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/
typedef DWORD (CALLBACK *PFN_WSOCK32_WSCONTROL)
( 
    DWORD, 
    DWORD, 
    LPVOID, 
    LPDWORD, 
    LPVOID, 
    LPDWORD 
);

typedef INT (APIENTRY *PFN_WSOCK32_ENUMPROTOCOLS) 
(
	LPINT lpiProtocols,
	LPVOID lpProtocolBuffer,
	LPDWORD lpdwBufferLength
) ;

typedef INT (APIENTRY *PFN_WSOCK32_STARTUP)
( 
	IN WORD wVersionRequired,
    OUT LPWSADATA lpWSAData
) ;

typedef INT (APIENTRY *PFN_WSOCK32_CLEANUP)
( 
) ;
 
typedef INT (APIENTRY *PFN_WSOCK32_CLOSESOCKET)
( 
	SOCKET s
) ;

typedef int ( PASCAL FAR *PFN_WSOCK32_GETSOCKOPT )
(
	SOCKET s,
	int level,
	int optname,
	char FAR * optval,
	int FAR *optlen
);

typedef int ( PASCAL FAR *PFN_WSOCK32_BIND ) 
(
	SOCKET s,
	const struct sockaddr FAR *addr,
	int namelen
);

typedef SOCKET ( PASCAL FAR *PFN_WSOCK32_SOCKET )
(
	int af,
	int type,
	int protocol
);

typedef int ( PASCAL FAR *PFN_WSOCK32_WSAGETLASTERROR ) (void);

typedef char * ( PASCAL FAR *PFN_WSOCK32_INET_NTOA )
(
	IN struct in_addr in
);

/******************************************************************************
 * Wrapper class for Wsock32 load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CWsock32Api : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to kernel32 functions.
    // Add new functions here as required.
    PFN_WSOCK32_WSCONTROL m_pfnWsControl;
	PFN_WSOCK32_ENUMPROTOCOLS m_pfnWsEnumProtocols;
	PFN_WSOCK32_STARTUP m_pfnWsStartup;
	PFN_WSOCK32_CLEANUP m_pfnWsCleanup;
	PFN_WSOCK32_CLOSESOCKET m_pfnWsCloseSocket;
	PFN_WSOCK32_GETSOCKOPT m_pfnWsGetSockopt ;
	PFN_WSOCK32_BIND m_pfnWsBind ;
	PFN_WSOCK32_SOCKET m_pfnWsSocket ;
	PFN_WSOCK32_WSAGETLASTERROR m_pfnWsWSAGetLastError ;
	PFN_WSOCK32_INET_NTOA m_pfnWsInet_NtoA ;

public:

    // Constructor and destructor:
    CWsock32Api(LPCTSTR a_tstrWrappedDllName);
    ~CWsock32Api();

    // Inherrited initialization function.
    virtual bool Init();

    // Member functions wrapping Wsock32 functions.
    // Add new functions here as required:
    bool WsControl
    (
        DWORD a_dw1, 
        DWORD a_dw2, 
        LPVOID a_lpv1, 
        LPDWORD a_lpdw1, 
        LPVOID a_lpv2, 
        LPDWORD a_lpdw2,
        DWORD *a_pdwRetval
    );

	INT WsEnumProtocols (

		LPINT lpiProtocols,
		LPVOID lpProtocolBuffer,
		LPDWORD lpdwBufferLength
	);

	INT WsWSAStartup ( 

		IN WORD wVersionRequired,
		OUT LPWSADATA lpWSAData
	) ;

	INT WsWSACleanup () ;
 
	INT Wsclosesocket ( SOCKET s ) ;

	int Wsbind (

		SOCKET s,
        const struct sockaddr FAR *addr,
        int namelen
	);

	int Wsgetsockopt (

       SOCKET s,
       int level,
       int optname,
       char FAR * optval,
       int FAR *optlen
	);

	SOCKET Wssocket (

      int af,
      int type,
      int protocol
	);

	int WsWSAGetLastError(void);

	char * Wsinet_ntoa (

		struct in_addr in
    ) ;

};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\dll\dfsjnpt.cpp ===
/******************************************************************

   DfsJnPt.CPP -- WMI provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
  
   Description: Win32 Dfs Provider
  
******************************************************************/

#include "precomp.h"
#include <computerAPI.h>

CDfsJnPt MyDfsTable ( 

    PROVIDER_NAME_DFSJNPT , 
    Namespace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::CDfsJnPt
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CDfsJnPt :: CDfsJnPt (

    LPCWSTR lpwszName, 
    LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
    m_ComputerName = GetLocalComputerName();
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::~CDfsJnPt
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CDfsJnPt :: ~CDfsJnPt ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CDfsJnPt::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CDfsJnPt :: EnumerateInstances (

    MethodContext *pMethodContext, 
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR ;
    DWORD dwPropertiesReq   = DFSJNPT_ALL_PROPS;

    hRes = EnumerateAllJnPts ( pMethodContext, dwPropertiesReq );

    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CDfsJnPt::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CDfsJnPt :: GetObject (

    CInstance *pInstance, 
    long lFlags ,
    CFrameworkQuery &Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    DWORD dwPropertiesReq = 0;
    CHString t_Key ;
    
    if  ( pInstance->GetCHString ( DFSNAME , t_Key ) == FALSE )
    {
        hRes = WBEM_E_INVALID_PARAMETER ;
    }

    if ( SUCCEEDED ( hRes ) )
    {
        if ( Query.AllPropertiesAreRequired() )
        {
            dwPropertiesReq = DFSJNPT_ALL_PROPS;
        }
        else
        {
            SetRequiredProperties ( Query, dwPropertiesReq );
        }

        hRes = FindAndSetDfsEntry ( t_Key, dwPropertiesReq, pInstance, eGet );
    }

    return hRes ;
}



/*****************************************************************************
*
*  FUNCTION    : CDfsJnPt::PutInstance
*
*  DESCRIPTION : Adding a Instance if it already doesnt exist, or modify it 
*                if it already exists, based on the kind of operation requested
*
*****************************************************************************/

HRESULT CDfsJnPt :: PutInstance  (

    const CInstance &Instance, 
    long lFlags
)
{
    HRESULT hRes = WBEM_E_FAILED ;

    CHString t_Key ;
    DWORD dwOperation;

    if ( Instance.GetCHString ( DFSNAME , t_Key ) )
    {
        hRes = WBEM_S_NO_ERROR;

        DWORD dwPossibleOperations = 0;

        dwPossibleOperations = (WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_CREATE_ONLY);

        switch ( lFlags & dwPossibleOperations )
        {
            case WBEM_FLAG_CREATE_OR_UPDATE:
            {
                dwOperation = eUpdate;
                break;
            }

            case WBEM_FLAG_UPDATE_ONLY:
            {
                dwOperation = eModify;
                break;
            }

            case WBEM_FLAG_CREATE_ONLY:
            {
                hRes = WBEM_E_INVALID_PARAMETER;
                break;
            }
        }
    }

    if ( SUCCEEDED ( hRes ) )
    {
        // This call is made with 2nd parameter 0, indicating that it should not load an instance 
        // with any parameter, it should simple search.
        hRes = FindAndSetDfsEntry ( t_Key, 0, NULL, eGet );

        if ( SUCCEEDED ( hRes ) || ( hRes == WBEM_E_NOT_FOUND ) )
        {
            switch ( dwOperation )
            {
                case eModify:
                {
                    if ( SUCCEEDED ( hRes ) )
                    {
                        hRes = UpdateDfsJnPt ( Instance, eModify );
                        break;
                    }
                }

                case eAdd:
                {
                    hRes = WBEM_E_INVALID_PARAMETER;
                    break;  // Create not currently supported
                }

                case eUpdate:
                {
                    if ( hRes == WBEM_E_NOT_FOUND )
                    {
                        hRes = WBEM_E_INVALID_PARAMETER; // Create not currently supported
                    }
                    else
                    {
                        hRes = UpdateDfsJnPt ( Instance, eModify );
                    }
                    break;
                }
            }
        }
    }

   return hRes ;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::CheckParameters
 *
 *  DESCRIPTION :   Performs the validity checks of the parameters to add/modify
 *                  the Dfs Jn Pts.
 *
 *****************************************************************************/
HRESULT CDfsJnPt :: CheckParameters ( 

    const CInstance &a_Instance ,
    int a_State 
)
{
    // Getall the Properties from the Instance to Verify
    bool t_Exists ;
    VARTYPE t_Type ;
    HRESULT hr = WBEM_S_NO_ERROR ;

    if ( a_State != WBEM_E_ALREADY_EXISTS ) 
    {
        // need to validate the dfsEntryPath, if it already exists, means it was already verified and was in DFS tree and 
        // hence need not verify
        if ( a_Instance.GetStatus ( DFSNAME , t_Exists , t_Type ) )
        {
            if ( t_Exists && ( t_Type == VT_BSTR ) )
            {
                CHString t_DfsEntryPath;

                if ( a_Instance.GetCHString ( DFSNAME , t_DfsEntryPath ) && ! t_DfsEntryPath.IsEmpty () )
                {
                }
                else
                {
                    // Zero Length string
                    hr = WBEM_E_INVALID_PARAMETER ;
                }
            }
            else
            {
                hr = WBEM_E_INVALID_PARAMETER ;
            }
        }   
    }

    if ( SUCCEEDED ( hr ) )
    {
        if ( a_Instance.GetStatus ( STATE , t_Exists , t_Type ) )
        {
            if ( t_Exists && ( t_Type == VT_I4 ) )
            {
                DWORD dwState;
                if ( a_Instance.GetDWORD ( STATE, dwState ) )
                {
                    if (( dwState != 0 ) && ( dwState != 1 ) && ( dwState != 2 ) && ( dwState != 3 ) )
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                    }
                }
            }
        }
    }

    if ( SUCCEEDED ( hr ) )
    {
        if ( a_Instance.GetStatus ( TIMEOUT , t_Exists , t_Type ) )
        {
            if ( t_Exists )
            { 
                if ( t_Type != VT_I4 )
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                }
            }
        }   
    }

    return hr;
}

/*****************************************************************************
*
*  FUNCTION    :    CDfsJnPt:: DeleteInstance
*
*  DESCRIPTION :    Deleting a Dfs Jn Pt if it exists
*
*****************************************************************************/

HRESULT CDfsJnPt :: DeleteInstance (

    const CInstance &Instance, 
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR ;
    CHString t_Key ;
    NET_API_STATUS t_Status = NERR_Success;

    if ( Instance.GetCHString ( DFSNAME , t_Key ) == FALSE )
    {
        hRes = WBEM_E_INVALID_PARAMETER;
    }

    if ( SUCCEEDED ( hRes ) )
    {
        hRes = FindAndSetDfsEntry ( t_Key, 0, NULL, eDelete );
    }

    return hRes ;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::EnumerateAllJnPts
 *
 *  DESCRIPTION :   Enumerates all the Junction points and calls the method to load 
 *                  Instance and then commit
 *
 ******************************************************************************/
HRESULT CDfsJnPt::EnumerateAllJnPts ( MethodContext *pMethodContext, DWORD dwPropertiesReq )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    PDFS_INFO_300 pData300 = NULL;

    DWORD er300 = 0;
	DWORD tr300 = 0;

    // Call the NetDfsEnum function, specifying level 300.
    DWORD res = NetDfsEnum( m_ComputerName.GetBuffer ( 0 ), 300, -1, (LPBYTE *) &pData300, &er300, &tr300 );

    // If no error occurred,
    if(res==NERR_Success)
    {
        if ( pData300 != NULL )
        {
            try
            {
                PDFS_INFO_300 p300 = pData300;
                CInstancePtr pInstance;

                for ( int i = 0; (i < er300) && SUCCEEDED( hRes ); i++, p300++ )
                {
					DWORD er4 = 0;
					DWORD tr4 = 0;
				    PDFS_INFO_4 pData4 = NULL;

					if (p300->DfsName != NULL)
					{
						if ( ( res = NetDfsEnum(p300->DfsName, 4, -1, (LPBYTE *) &pData4, &er4, &tr4) ) == NERR_Success)
						{
							if ( pData4 != NULL )
							{
								try
								{
									PDFS_INFO_4 p4 = pData4;

									for ( int j = 0; (j < er4) && SUCCEEDED ( hRes ); j++, p4++ )
									{
										pInstance.Attach(CreateNewInstance( pMethodContext ));
										
										hRes = LoadDfsJnPt ( dwPropertiesReq, pInstance, p4, p4 == pData4 );
										if ( SUCCEEDED ( hRes ) )
										{
											hRes = pInstance->Commit();
										}
									}
								}
								catch(...)
								{
									NetApiBufferFree(pData4);
									pData4 = NULL;

									throw;
								}

								NetApiBufferFree(pData4);
								pData4 = NULL;
							}
						}
						 // Check to see if there are ANY roots
						else if	(
									(res != ERROR_NO_MORE_ITEMS) &&
									(res != ERROR_NO_SUCH_DOMAIN) &&
									(res != ERROR_NOT_FOUND) && 
									(res != ERROR_ACCESS_DENIED)
								)
						{
							hRes = WBEM_E_FAILED;
						}
					}
                }
            }
            catch ( ... )
            {
                NetApiBufferFree(pData300);
				pData300 = NULL;

                throw;
            }

            NetApiBufferFree(pData300);
			pData300 = NULL;
        }
    }
    else if ( (res != ERROR_NO_MORE_ITEMS) && (res != ERROR_NO_SUCH_DOMAIN) && (res != ERROR_NOT_FOUND) ) // Check to see if there are ANY roots
    {
		if ( ERROR_ACCESS_DENIED == res )
		{
			hRes = WBEM_E_ACCESS_DENIED ;
		}
		else
		{
			hRes = WBEM_E_FAILED ;
		}
    }
    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::FindAndSetDfsEntry
 *
 *  DESCRIPTION :   Finds an entry matching the dfsEntryPath and loads the
 *                  Instance if found or acts based on the Operation passed
 *
 ******************************************************************************/
HRESULT CDfsJnPt::FindAndSetDfsEntry ( LPCWSTR a_Key, DWORD dwPropertiesReq, CInstance *pInstance, DWORD eOperation )
{
    HRESULT hRes = WBEM_E_NOT_FOUND;

    PDFS_INFO_300 pData300 = NULL;

    DWORD er300 = 0;
	DWORD tr300 = 0;

	DWORD res = NERR_Success;

    // Call the NetDfsEnum function, specifying level 300.
    if( ( res = NetDfsEnum( m_ComputerName.GetBuffer ( 0 ), 300, -1, (LPBYTE *) &pData300, &er300, &tr300 ) ) == NERR_Success )
    {
        if ( pData300 != NULL )
        {
			try
			{
				BOOL bContinue = TRUE;
                PDFS_INFO_300 p300 = pData300;

                for ( int i = 0; (i < er300) && bContinue; i++, p300++ )
                {
					if ( p300->DfsName != NULL )
					{
						PDFS_INFO_4 pData4 = NULL;

						DWORD er4=0;
						DWORD tr4=0;

						if ( ( res = NetDfsEnum(p300->DfsName, 4, -1, (LPBYTE *) &pData4, &er4, &tr4) ) == NERR_Success )
						{
							if ( pData4 != NULL )
							{
								try
								{
									BOOL bFound = FALSE;
									PDFS_INFO_4 p4 = pData4;

									for ( int j = 0; (j < er4) && bContinue; j++, bContinue && (j < er4) ? p4++ : p4 )
									{
										if ( _wcsicmp ( a_Key, p4->EntryPath ) == 0 )
										{
											bFound = TRUE;
											bContinue = FALSE;
										}
									}

									if ( bFound )
									{
										switch ( eOperation )
										{
											case eGet :
											{
												hRes = LoadDfsJnPt ( dwPropertiesReq, pInstance, p4, p4 == pData4 );
												break;
											}

											case eDelete:
											{
												hRes = DeleteDfsJnPt ( p4 );
												break;
											}
										}
									}
								}
								catch(...)
								{
									NetApiBufferFree(pData4);
									pData4 = NULL;

									throw;
								}

								NetApiBufferFree(pData4);
								pData4 = NULL;
							}
						}
						 // Check to see if there are ANY roots
						else if	(
									(res != ERROR_NO_MORE_ITEMS) &&
									(res != ERROR_NO_SUCH_DOMAIN) &&
									(res != ERROR_NOT_FOUND) && 
									(res != ERROR_ACCESS_DENIED)
								)
						{
							hRes = WBEM_E_FAILED;
							bContinue = FALSE;
						}
					}
				}
            }
            catch ( ... )
            {
                NetApiBufferFree(pData300);
				pData300 = NULL;

                throw;
            }

            NetApiBufferFree(pData300);
			pData300 = NULL;
        }
    }
    else if ( (res != ERROR_NO_MORE_ITEMS) && (res != ERROR_NO_SUCH_DOMAIN) && (res != ERROR_NOT_FOUND) ) // Check to see if there are ANY roots
    {
		if ( ERROR_ACCESS_DENIED == res )
		{
			hRes = WBEM_E_ACCESS_DENIED ;
		}
		else
		{
			hRes = WBEM_E_FAILED ;
		}
    }

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::LoadDfsJnPt
 *
 *  DESCRIPTION :   Loads a Dfs Junction point entry into the instance 
 *
 ******************************************************************************/

HRESULT CDfsJnPt::LoadDfsJnPt ( DWORD dwPropertiesReq, CInstance *pInstance, PDFS_INFO_4 pJnPtBuf, bool bRoot )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

	if (NULL != pInstance)
	{
		if  ( dwPropertiesReq & DFSJNPT_PROP_DfsEntryPath )  
		{
			if ( pInstance->SetWCHARSplat ( DFSNAME, pJnPtBuf->EntryPath ) == FALSE )
			{
				hRes = WBEM_E_FAILED;
			}
		}

		if ( pInstance->Setbool ( L"Root", bRoot ) == FALSE )
		{
			hRes = WBEM_E_FAILED;
		}

		if ( dwPropertiesReq & DFSJNPT_PROP_State ) 
		{
			// need to check the state and then valuemap
				DWORD dwState = 0;
				switch ( pJnPtBuf->State )
				{
					case DFS_VOLUME_STATE_OK :
					{
						dwState = 0;
						break;
					}

					case DFS_VOLUME_STATE_INCONSISTENT : 
					{
						dwState = 1;
						break;
					}

					case DFS_VOLUME_STATE_ONLINE : 
					{
						dwState = 2;
						break;
					}

					case DFS_VOLUME_STATE_OFFLINE :
					{
						dwState = 3;
						break;
					}
				}

			if ( pInstance->SetDWORD ( STATE, dwState ) == FALSE )
			{
				hRes = WBEM_E_FAILED;
			}
		}

		if  ( dwPropertiesReq & DFSJNPT_PROP_Comment )
		{
			if ( pInstance->SetWCHARSplat ( COMMENT, pJnPtBuf->Comment ) == FALSE )
			{
				hRes = WBEM_E_FAILED;
			}
		}

		if  ( dwPropertiesReq & DFSJNPT_PROP_Caption )
		{
			if ( pInstance->SetWCHARSplat ( CAPTION, pJnPtBuf->Comment ) == FALSE )
			{
				hRes = WBEM_E_FAILED;
			}
		}

		if  ( dwPropertiesReq & DFSJNPT_PROP_Timeout ) 
		{
			if ( pInstance->SetDWORD ( TIMEOUT, pJnPtBuf->Timeout ) == FALSE )
			{
				hRes = WBEM_E_FAILED;
			}
		}
	}
	else
	{
		if (0 != dwPropertiesReq)
		{
			hRes = WBEM_E_FAILED;
		}
	}

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::DeleteDfsJnPt
 *
 *  DESCRIPTION :   Deletes a Junction Pt if it exists
 *
 ******************************************************************************/
HRESULT CDfsJnPt::DeleteDfsJnPt ( PDFS_INFO_4 pDfsJnPt )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    NET_API_STATUS t_Status = NERR_Success;

    if ( IsDfsRoot ( pDfsJnPt->EntryPath ) )
    {
		if ((wcslen(pDfsJnPt->EntryPath) > 4) &&
			(pDfsJnPt->EntryPath[0] == pDfsJnPt->EntryPath[1]) &&
			(pDfsJnPt->EntryPath[0] == L'\\'))
		{
			wchar_t *pSlash = wcschr(&(pDfsJnPt->EntryPath[2]), L'\\');

			if (pSlash > &(pDfsJnPt->EntryPath[2]))
			{
				wchar_t *pServer = new wchar_t[pSlash - &(pDfsJnPt->EntryPath[2]) + 1];
				BOOL bRemove = FALSE;

				try
				{
					wcsncpy(pServer, &(pDfsJnPt->EntryPath[2]), pSlash - &(pDfsJnPt->EntryPath[2]));
					pServer[pSlash - &(pDfsJnPt->EntryPath[2])] = L'\0';

					if (0 == m_ComputerName.CompareNoCase(pServer))
					{
						bRemove = TRUE;
					}
					else
					{
						DWORD dwDnsName = 256;
						DWORD dwDnsNameSize = 256;
						wchar_t *pDnsName = new wchar_t[dwDnsName];

						try
						{
							while (!ProviderGetComputerNameEx(ComputerNamePhysicalDnsHostname, pDnsName, &dwDnsName))
							{
								if (GetLastError() != ERROR_MORE_DATA)
								{
									delete [] pDnsName;
									pDnsName = NULL;
									break;
								}
								else
								{
									delete [] pDnsName;
									pDnsName = NULL;
									dwDnsName = dwDnsNameSize * 2;
									dwDnsNameSize = dwDnsName;
									pDnsName = new wchar_t[dwDnsName];
								}
							}
						}
						catch (...)
						{
							if (pDnsName)
							{
								delete [] pDnsName;
								pDnsName = NULL;
							}

							throw;
						}

						if (pDnsName)
						{
							if (_wcsicmp(pDnsName, pServer) == 0)
							{
								bRemove = TRUE;
							}

							delete [] pDnsName;
							pDnsName = NULL;
						}
					}
				}
				catch(...)
				{
					if (pServer)
					{
						delete [] pServer;
					}

					throw;
				}

				if (bRemove)
				{
					t_Status = NetDfsRemoveStdRoot ( pDfsJnPt->Storage->ServerName, 
													pDfsJnPt->Storage->ShareName,
													0
													);
					if ( t_Status != NERR_Success )
					{
						hRes = WBEM_E_FAILED;
					}
				}
				else
				{
					//can't delete roots not on this machine
					hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
				}

				delete [] pServer;
			}
			else
			{
				hRes = WBEM_E_FAILED;
			}
		}
		else
		{
			hRes = WBEM_E_FAILED;
		}
    }
    else
    {
        // Apparently there is no way to explicitly remove a link.  However, if
        // you remove all the replicas, the link gets deleted automatically.
        for ( int StorageNo = 0; StorageNo < pDfsJnPt->NumberOfStorages; StorageNo++ )
        {       
            t_Status = NetDfsRemove ( 
                
                        pDfsJnPt->EntryPath,
                        pDfsJnPt->Storage[StorageNo].ServerName,
                        pDfsJnPt->Storage[StorageNo].ShareName
                  );

            if ( t_Status != NERR_Success ) 
            {
                hRes = WBEM_E_FAILED;
                break;
            }
        }
    }

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::UpdateDfsJnPt
 *
 *  DESCRIPTION :   Adds / Modifies the Dfs Jn Pt
 *
 ******************************************************************************/
HRESULT CDfsJnPt::UpdateDfsJnPt ( const CInstance &Instance, DWORD dwOperation )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    NET_API_STATUS t_Status = NERR_Success;
        
    if ( SUCCEEDED ( hRes ) )
    {
        NET_API_STATUS t_Status = NERR_Success;
        CHString t_EntryPath;

        Instance.GetCHString ( DFSNAME, t_EntryPath );
        
        if ( dwOperation == eAdd )
        {
            hRes = WBEM_E_INVALID_PARAMETER;
        }
        else
        if ( dwOperation == eModify )
        {
            CHString t_Comment;

            if (( t_Status == NERR_Success ) && (Instance.GetCHString ( COMMENT, t_Comment )))
				{
					DFS_INFO_100 t_dfsCommentData;
        
					t_dfsCommentData.Comment = t_Comment.GetBuffer( 0 );

					t_Status = NetDfsSetInfo ( t_EntryPath.GetBuffer ( 0 ),
										  NULL,
										  NULL,
										  100,
										  (LPBYTE) &t_dfsCommentData
						  );
				}

            if ( t_Status == NERR_Success )
            {
                DFS_INFO_102 t_dfsTimeoutData;

                if (Instance.GetDWORD ( TIMEOUT, t_dfsTimeoutData.Timeout))
                {
                    t_Status = NetDfsSetInfo ( t_EntryPath.GetBuffer ( 0 ),
                                              NULL,
                                              NULL,
                                              102,
                                              (LPBYTE) &t_dfsTimeoutData
                              );
                }
            }
        }

        if ((SUCCEEDED(hRes)) && ( t_Status != NERR_Success ))
        {
            hRes = WBEM_E_FAILED ;
        }
    }
    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::AddDfsJnPt
 *
 *  DESCRIPTION :   Adds the New Dfs Jn Pt 
 *
 ******************************************************************************/
NET_API_STATUS CDfsJnPt :: AddDfsJnPt ( 

    LPWSTR a_DfsEntry,
    LPWSTR a_ServerName,
    LPWSTR a_ShareName,
    LPWSTR a_Comment
)
{
    NET_API_STATUS t_Status = NERR_Success;
	wchar_t *t_slash = NULL;

	//simple analysis on the parameters...
	if ((a_ServerName == NULL) ||
		(a_ShareName == NULL) ||
		(a_ServerName[0] == L'\0') ||
		(a_ShareName[0] == L'\0') ||
		(a_DfsEntry == NULL) ||
		(wcslen(a_DfsEntry) < 5) ||
		(wcsncmp(a_DfsEntry, L"\\\\", 2) != 0))
	{
		t_Status = ERROR_INVALID_PARAMETER;
	}
	else
	{
		t_slash = wcschr((const wchar_t*)(&(a_DfsEntry[2])), L'\\');

		if ((t_slash == NULL) || (t_slash == &(a_DfsEntry[2])))
		{
			t_Status = ERROR_INVALID_PARAMETER;
		}
		else
		{
			//let's find the next slash if there is one...
			t_slash++;

			if ((*t_slash == L'\0') || (*t_slash == L'\\'))
			{
				t_Status = ERROR_INVALID_PARAMETER;
			}
			else
			{
				//if t_slash is null we have a root
				t_slash = wcschr(t_slash, L'\\');
			}
		}
	}

	if (t_Status == NERR_Success)
	{
		if ( t_slash )
		{
			// this is a a junction point other than the root
			t_Status = NetDfsAdd ( a_DfsEntry,
							  a_ServerName,
							  a_ShareName,
							  a_Comment,
							  DFS_ADD_VOLUME
				  );
		}
		else
		{
			// it is  DFSRoot
			DWORD dwErr = GetFileAttributes ( a_DfsEntry );

			if ( dwErr != 0xffffffff )
			{
				t_Status = NetDfsAddStdRoot ( a_ServerName,
							   a_ShareName,
							   a_Comment,
							   0
				  );
			}
			else
			{
				t_Status = GetLastError();
			}
		}
	}

    return t_Status;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::SetRequiredProperties
 *
 *  DESCRIPTION :   Sets the bitmap for the required properties
 *
 ******************************************************************************/
void CDfsJnPt::SetRequiredProperties ( CFrameworkQuery &Query, DWORD &dwPropertiesReq )
{
    dwPropertiesReq = 0;

    if ( Query.IsPropertyRequired  ( DFSNAME ) )
    {
        dwPropertiesReq |= DFSJNPT_PROP_DfsEntryPath;
    }

    if ( Query.IsPropertyRequired  ( STATE ) )
    {
        dwPropertiesReq |= DFSJNPT_PROP_State;
    }

    if ( Query.IsPropertyRequired  ( COMMENT ) )
    {
        dwPropertiesReq |= DFSJNPT_PROP_Comment;
    }

    if ( Query.IsPropertyRequired  ( TIMEOUT ) )
    {
        dwPropertiesReq |= DFSJNPT_PROP_Timeout;
    }
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::DfsRoot
 *
 *  DESCRIPTION :   Checks if the Dfs Jn Pt is a root.
 *
 ******************************************************************************/
BOOL CDfsJnPt::IsDfsRoot ( LPCWSTR lpKey )
{
    BOOL bRetVal = TRUE;
    int i = 0;

    if ( lpKey [ i ] == L'\\' )
    {
        i++;
    }

    if ( lpKey [ i ] == L'\\' )
    {
        i++;
    }

    while ( lpKey [ i ] != L'\\' )
    {
        i++;
    }

    i++;
    while ( lpKey [ i ] != L'\0' )
    {
        if ( lpKey [ i ] == L'\\' )
        {
            bRetVal = FALSE;
            break;
        }
        i++;
    }

    return bRetVal;
}

/*****************************************************************************
 *
 *  FUNCTION    : CDfsJnPt::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CDfsJnPt::ExecMethod (

	const CInstance& a_Instance,
	const BSTR a_MethodName ,
	CInstance *a_InParams ,
	CInstance *a_OutParams ,
	long a_Flags
)
{
    HRESULT hr = WBEM_E_INVALID_METHOD;

    if (_wcsicmp(a_MethodName, L"Create") == 0)
    {
        CHString sDfsEntry, sServerName, sShareName, sDescription;

        if (a_InParams->GetCHString(DFSENTRYPATH, sDfsEntry) && sDfsEntry.GetLength() &&
            a_InParams->GetCHString(SERVERNAME, sServerName) && sServerName.GetLength() &&
            a_InParams->GetCHString(SHARENAME, sShareName) && sShareName.GetLength())
        {
			// At the point, the *wmi* method call has succeeded.  All that
			// remains is to determine the *class's* return code
			hr = WBEM_S_NO_ERROR;

            a_InParams->GetCHString(COMMENT, sDescription);

            NET_API_STATUS status = AddDfsJnPt ( 

                sDfsEntry.GetBuffer(0),
                sServerName.GetBuffer(0),
                sShareName.GetBuffer(0),
                sDescription.GetLength() > 0 ? sDescription.GetBuffer(0) : NULL
				);

            a_OutParams->SetDWORD(L"ReturnValue", status);            
        }
        else
        {
            hr = WBEM_E_INVALID_METHOD_PARAMETERS;
        }
   }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\dll\dfsreplica.cpp ===
/******************************************************************

   DfsReplica.CPP -- WMI provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

   DESCRIPTION DFS Provider
  
******************************************************************/

#include "precomp.h"
#include <computerAPI.h>

CDfsReplica MyCDFSReplicaSet ( 

    PROVIDER_NAME_DFSREPLICA , 
    Namespace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsReplica::CDfsReplica
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CDfsReplica :: CDfsReplica (

    LPCWSTR lpwszName, 
    LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{   
    m_ComputerName = GetLocalComputerName();
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsReplica::~CDfsReplica
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CDfsReplica :: ~CDfsReplica ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CDfsReplica::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CDfsReplica :: EnumerateInstances (

    MethodContext *pMethodContext, 
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR ;
    DWORD dwPropertiesReq = DFSREPLICA_ALL_PROPS;

    hRes = EnumerateAllReplicas ( pMethodContext, dwPropertiesReq );

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CDfsReplica::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CDfsReplica :: GetObject (

    CInstance *pInstance, 
    long lFlags,
    CFrameworkQuery& Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    DWORD dwPropertiesReq = 0;
    CHString t_Link ;
    CHString t_Server;
    CHString t_Share;

    hRes = GetKeys(pInstance, t_Link, t_Server, t_Share);

    if ( SUCCEEDED ( hRes ) )
    {
        if ( Query.AllPropertiesAreRequired() )
        {
            dwPropertiesReq = DFSREPLICA_ALL_PROPS;
        }
        else
        {
            if ( Query.IsPropertyRequired  ( LINKNAME ) )
            {
                dwPropertiesReq |= DFSREPLICA_PROP_LinkName;
            }

            if ( Query.IsPropertyRequired  ( SERVERNAME ) )
            {
                dwPropertiesReq |= DFSREPLICA_PROP_ServerName;
            }

            if ( Query.IsPropertyRequired  ( SHARENAME ) )
            {
                dwPropertiesReq |= DFSREPLICA_PROP_ShareName;
            }

            if ( Query.IsPropertyRequired  ( STATE ) )
            {
                dwPropertiesReq |= DFSREPLICA_PROP_State;
            }
        }

        bool bRoot = false;

        hRes = FindAndSetDfsReplica ( t_Link, t_Server, t_Share, dwPropertiesReq, pInstance, eGet, bRoot );
    }

    return hRes ;
}


/*****************************************************************************
*
*  FUNCTION    : CDfsReplica::PutInstance
*
*  DESCRIPTION :    PutInstance should be used in provider classes that can 
*                   write instance information back to the hardware or 
*                   software.  For example: Win32_Environment will allow a 
*                   PutInstance to create or update an environment variable.  
*                   However, a class like MotherboardDevice will not allow 
*                   editing of the number of slots, since it is difficult for 
*                   a provider to affect that number.
*
*****************************************************************************/

HRESULT CDfsReplica :: PutInstance  (

    const CInstance &Instance, 
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    DWORD dwPropertiesReq = 0;
    CHString t_Link ;
    CHString t_Server;
    CHString t_Share;
    bool bRoot = false;

    // Get the Compound Key
    hRes = GetKeys(&Instance, t_Link, t_Server, t_Share);

    if ( SUCCEEDED ( hRes ) )
    {
        hRes = FindAndSetDfsReplica ( t_Link, t_Server, t_Share, dwPropertiesReq, NULL, eAdd, bRoot );
    }

    bool bFound;
    
    if (SUCCEEDED(hRes))
    {
        bFound = true;
    }
    else if (hRes == WBEM_E_NOT_FOUND)
    {
        bFound = false;
        hRes = WBEM_S_NO_ERROR;
    }

    if (SUCCEEDED(hRes))
    {
        DWORD dwOperationsReq = (WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY);

        switch ( lFlags & dwOperationsReq )
        {
            case WBEM_FLAG_CREATE_OR_UPDATE:
            {
                if (bFound)
                {
					hRes = WBEM_E_INVALID_PARAMETER;
                }
                else
                {
                    if (NetDfsAdd ( 
                                    t_Link.GetBuffer ( 0 ),
                                    t_Server.GetBuffer ( 0 ),
                                    t_Share.GetBuffer ( 0 ),
                                    L"",
                                    0
                                ) == NERR_Success)
                    {
                        hRes = WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        hRes = WBEM_E_FAILED;
                    }
                }

                break;
            }

            case WBEM_FLAG_CREATE_ONLY:
            {
                if (!bFound)
                {
                    if (NetDfsAdd ( 
                                    t_Link.GetBuffer ( 0 ),
                                    t_Server.GetBuffer ( 0 ),
                                    t_Share.GetBuffer ( 0 ),
                                    L"",
                                    0
                                ) == NERR_Success)
                    {
                        hRes = WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        hRes = WBEM_E_FAILED;
                    }
                }
                else
                {
                    hRes = WBEM_E_ALREADY_EXISTS;
                }

                break;
            }

			default:
            {
                hRes = WBEM_E_INVALID_PARAMETER;
            }
        }
    }

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CDfsReplica::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.  For most hardware devices, 
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*****************************************************************************/

HRESULT CDfsReplica :: DeleteInstance (

    const CInstance &Instance, 
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    DWORD dwPropertiesReq = 0;
    CHString t_Link ;
    CHString t_Server;
    CHString t_Share;
    bool bRoot = false;

    // Get the Compound Key
    hRes = GetKeys(&Instance, t_Link, t_Server, t_Share);

    if ( SUCCEEDED ( hRes ) )
    {
        hRes = FindAndSetDfsReplica ( t_Link, t_Server, t_Share, dwPropertiesReq, NULL, eDelete, bRoot );
    }

    if ( SUCCEEDED ( hRes ) )
    {
        NET_API_STATUS t_Status = NERR_Success;

        if (!bRoot)
        {
            t_Status = NetDfsRemove(
                    t_Link.GetBuffer(0),
                    t_Server.GetBuffer(0),
                    t_Share.GetBuffer(0)
                );

			if ( t_Status != NERR_Success )
			{
				hRes = WBEM_E_FAILED;
			}
        }
        else
        {
			wchar_t *pEntryPath = t_Link.GetBuffer(0);

			if ((wcslen(pEntryPath) > 4) &&
				(pEntryPath[0] == pEntryPath[1]) &&
				(pEntryPath[0] == L'\\'))
			{
				wchar_t *pSlash = wcschr(&(pEntryPath[2]), L'\\');

				if (pSlash > &(pEntryPath[2]))
				{
					wchar_t *pServer = new wchar_t[pSlash - &(pEntryPath[2]) + 1];
					BOOL bRemove = FALSE;

					try
					{
						wcsncpy(pServer, &(pEntryPath[2]), pSlash - &(pEntryPath[2]));
						pServer[pSlash - &(pEntryPath[2])] = L'\0';

						if (0 == m_ComputerName.CompareNoCase(pServer))
						{
							bRemove = TRUE;
						}
						else
						{
							DWORD dwDnsName = 256;
							DWORD dwDnsNameSize = 256;
							wchar_t *pDnsName = new wchar_t[dwDnsName];

							try
							{
								while (!ProviderGetComputerNameEx(ComputerNamePhysicalDnsHostname, pDnsName, &dwDnsName))
								{
									if (GetLastError() != ERROR_MORE_DATA)
									{
										delete [] pDnsName;
										pDnsName = NULL;
										break;
									}
									else
									{
										delete [] pDnsName;
										pDnsName = NULL;
										dwDnsName = dwDnsNameSize * 2;
										dwDnsNameSize = dwDnsName;
										pDnsName = new wchar_t[dwDnsName];
									}
								}
							}
							catch (...)
							{
								if (pDnsName)
								{
									delete [] pDnsName;
									pDnsName = NULL;
								}

								throw;
							}

							if (pDnsName)
							{
								if (_wcsicmp(pDnsName, pServer) == 0)
								{
									bRemove = TRUE;
								}

								delete [] pDnsName;
								pDnsName = NULL;
							}
						}
					}
					catch(...)
					{
						if (pServer)
						{
							delete [] pServer;
						}

						throw;
					}

					if (bRemove)
					{
						t_Status = NetDfsRemoveStdRoot(
								t_Server.GetBuffer(0),
								t_Share.GetBuffer(0),
								0
							);

						if ( t_Status != NERR_Success )
						{
							hRes = WBEM_E_FAILED;
						}
					}
					else
					{
						//can't delete roots not on this machine
						hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
					}

					delete [] pServer;
				}
				else
				{
					hRes = WBEM_E_FAILED;
				}
			}
			else
			{
				hRes = WBEM_E_FAILED;
			}
        }
    }

    return hRes ;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsReplica::EnumerateAllReplicas
 *
 *  DESCRIPTION :   Enumerates all the Dfs Replicas of all junction points
 *
 ******************************************************************************/
HRESULT CDfsReplica::EnumerateAllReplicas ( MethodContext *pMethodContext, DWORD dwPropertiesReq )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    BOOL bLoadReplicaFailure = FALSE;

    PDFS_STORAGE_INFO pRepBuf;

    PDFS_INFO_300 pData300 = NULL;

    DWORD er300 = 0;
	DWORD tr300 = 0;

    // Call the NetDfsEnum function, specifying level 300.
    DWORD res = NetDfsEnum( m_ComputerName.GetBuffer ( 0 ), 300, -1, (LPBYTE *) &pData300, &er300, &tr300 );

    // If no error occurred,
    if(res==NERR_Success)
    {
        if ( pData300 != NULL )
        {
            try
            {
                PDFS_INFO_300 p300 = pData300;
                CInstancePtr pInstance;

                for ( int i = 0; (i < er300) && SUCCEEDED( hRes ); i++, p300++ )
                {
					DWORD er4 = 0;
					DWORD tr4 = 0;
				    PDFS_INFO_4 pData4 = NULL;

					if (p300->DfsName != NULL)
					{
						if ( ( res = NetDfsEnum(p300->DfsName, 4, -1, (LPBYTE *) &pData4, &er4, &tr4) ) == NERR_Success)
						{
							if ( pData4 != NULL )
							{
								try
								{
									PDFS_INFO_4 p4 = pData4;

									for ( int ii = 0; (ii < er4) && SUCCEEDED ( hRes ); ii++, p4++ )
									{
										// Walk all the replicas on each link
										pRepBuf = p4->Storage;
										for ( int j = 0; j <  p4->NumberOfStorages; j++, pRepBuf++ )
										{
											pInstance.Attach(CreateNewInstance( pMethodContext ));

											hRes = LoadDfsReplica ( dwPropertiesReq, pInstance, p4->EntryPath, pRepBuf );
											if ( SUCCEEDED ( hRes ) )
											{
												hRes = pInstance->Commit();
											}
											else
											{
												bLoadReplicaFailure = TRUE;
											}
										}
									}
								}
								catch(...)
								{
									NetApiBufferFree(pData4);
									pData4 = NULL;

									throw;
								}

								NetApiBufferFree(pData4);
								pData4 = NULL;
							}
						}
						 // Check to see if there are ANY roots
						else if	(
									(res != ERROR_NO_MORE_ITEMS) &&
									(res != ERROR_NO_SUCH_DOMAIN) &&
									(res != ERROR_NOT_FOUND) && 
									(res != ERROR_ACCESS_DENIED)
								)
						{
							hRes = WBEM_E_FAILED;
						}
					}
				}
            }
            catch ( ... )
            {
                NetApiBufferFree(pData300);
				pData300 = NULL;

                throw;
            }

            NetApiBufferFree(pData300);
			pData300 = NULL;
		}
    }
    else
    {
        if ( (res != ERROR_NO_MORE_ITEMS) && (res != ERROR_NO_SUCH_DOMAIN) && (res != ERROR_NOT_FOUND) ) // Check to see if there are ANY roots
        {
			if ( ERROR_ACCESS_DENIED == res )
			{
				hRes = WBEM_E_ACCESS_DENIED ;
			}
			else
			{
				hRes = WBEM_E_FAILED ;
			}
        }
        // No replicas
        else if (res == ERROR_NO_MORE_ITEMS)
        {
            hRes = WBEM_S_NO_ERROR;
        }
    }

    if ( bLoadReplicaFailure )
    {
        hRes = WBEM_E_PROVIDER_FAILURE;
    }

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsReplica::FindAndSetDfsReplica
 *
 *  DESCRIPTION :   Finds an entry matching the dfsEntryPath and loads the
 *                  Instance if found or acts based on the Operation passed
 *
 ******************************************************************************/
HRESULT CDfsReplica::FindAndSetDfsReplica ( LPCWSTR a_EntryPath, LPCWSTR a_ServerName, LPCWSTR a_ShareName, 
                                             DWORD dwPropertiesReq, CInstance *pInstance, DWORD eOperation, bool &bRoot )
{
    PDFS_STORAGE_INFO pRepBuf;

    HRESULT hRes = WBEM_E_NOT_FOUND;

    PDFS_INFO_300 pData300 = NULL;

    DWORD er300 = 0;
	DWORD tr300 = 0;

	DWORD res = NERR_Success;

    // Call the NetDfsEnum function, specifying level 300.
    if( ( res = NetDfsEnum( m_ComputerName.GetBuffer ( 0 ), 300, -1, (LPBYTE *) &pData300, &er300, &tr300 ) ) == NERR_Success )
    {
        if ( pData300 != NULL )
        {
			try
			{
				BOOL bContinue = TRUE;
                PDFS_INFO_300 p300 = pData300;

                for ( int i = 0; (i < er300) && bContinue; i++, p300++ )
                {
					if ( p300->DfsName != NULL )
					{
						PDFS_INFO_4 pData4 = NULL;

						DWORD er4=0;
						DWORD tr4=0;

						if ( ( res = NetDfsEnum(p300->DfsName, 4, -1, (LPBYTE *) &pData4, &er4, &tr4) ) == NERR_Success )
						{
							if ( pData4 != NULL )
							{
								try
								{
									BOOL bFound = FALSE;
									PDFS_INFO_4 p4 = pData4;

									for ( int jj = 0; (jj < er4) && bContinue; jj++, bContinue && (jj < er4) ? p4++ : p4 )
									{
										if ( _wcsicmp ( a_EntryPath, p4->EntryPath ) == 0 )
										{
											bFound = TRUE;
											bContinue = FALSE;
										}
									}

									if ( bFound )
									{
										bFound = FALSE;
										bContinue = TRUE;

										pRepBuf = p4->Storage;

										for ( int j = 0; j < p4->NumberOfStorages && bContinue; j++, bContinue && (j < p4->NumberOfStorages) ? pRepBuf++ : pRepBuf )
										{
											if ( ( _wcsicmp(a_ServerName, pRepBuf->ServerName ) == 0 ) && 
												( _wcsicmp(a_ShareName, pRepBuf->ShareName ) == 0 ) )
											{
												bFound = TRUE;
												bRoot = (pData4 == p4);
												bContinue = FALSE;
											}
										}

										if ( bFound )
										{
											switch ( eOperation )
											{
												case eGet :     
												{
													hRes = LoadDfsReplica ( dwPropertiesReq, pInstance, p4->EntryPath, pRepBuf );
													break;
												}

												case eDelete:   
												{
													hRes = WBEM_S_NO_ERROR;
													break;
												}

												case eAdd:      
												{
													hRes = WBEM_S_NO_ERROR;
													break;
												}
											} 
										}
										else
										{
											// we didn't find replica 
											bContinue = FALSE;
										}
									}
								}
								catch(...)
								{
									NetApiBufferFree(pData4);
									pData4 = NULL;

									throw;
								}

								NetApiBufferFree(pData4);
								pData4 = NULL;
							}
						}
						 // Check to see if there are ANY roots
						else if	(
									(res != ERROR_NO_MORE_ITEMS) &&
									(res != ERROR_NO_SUCH_DOMAIN) &&
									(res != ERROR_NOT_FOUND) && 
									(res != ERROR_ACCESS_DENIED)
								)
						{
							hRes = WBEM_E_FAILED;
							bContinue = FALSE;
						}
					}
				}
            }
            catch ( ... )
            {
                NetApiBufferFree(pData300);
				pData300 = NULL;

                throw;
            }

            NetApiBufferFree(pData300);
			pData300 = NULL;
        }
    }
    else if ( (res != ERROR_NO_MORE_ITEMS) && (res != ERROR_NO_SUCH_DOMAIN) && (res != ERROR_NOT_FOUND) ) // Check to see if there are ANY roots
    {
		if ( ERROR_ACCESS_DENIED == res )
		{
			hRes = WBEM_E_ACCESS_DENIED ;
		}
		else
		{
			hRes = WBEM_E_FAILED ;
		}
    }

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsReplica::LoadDfsReplica
 *
 *  DESCRIPTION :   Loads a Dfs Replica into the instance 
 *
 ******************************************************************************/

HRESULT CDfsReplica::LoadDfsReplica ( DWORD dwPropertiesReq, CInstance *pInstance, LPWSTR  lpLinkName, PDFS_STORAGE_INFO pRepBuf )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if  ( dwPropertiesReq & DFSREPLICA_PROP_LinkName )
    {
        if ( pInstance->SetCHString ( LINKNAME, lpLinkName ) == FALSE )
        {
            hRes = WBEM_E_FAILED;
        }
    }

    if  ( dwPropertiesReq & DFSREPLICA_PROP_ServerName )
    {
        if ( pInstance->SetCHString ( SERVERNAME, pRepBuf->ServerName ) == FALSE )
        {
            hRes = WBEM_E_FAILED;
        }
    }

    if  ( dwPropertiesReq & DFSREPLICA_PROP_ShareName )
    {
        if ( pInstance->SetCHString ( SHARENAME, pRepBuf->ShareName ) == FALSE )
        {
            hRes = WBEM_E_FAILED;
        }
    }

    if  ( dwPropertiesReq & DFSREPLICA_PROP_State )
    {
        // need to check the state and then valuemap
        DWORD dwState = 0xffff;
        switch ( pRepBuf->State )
        {
            case DFS_STORAGE_STATE_OFFLINE : 
            {
                dwState = 0;
                break;
            }

            case DFS_STORAGE_STATE_ONLINE : 
            {
                dwState = 1;
                break;
            }

            case DFS_STORAGE_STATE_ACTIVE : 
            {
                dwState = 2;
                break;
            }
        }

        if ( !pInstance->SetDWORD ( STATE, dwState ) )
        {
            hRes = WBEM_E_FAILED;
        }
    }       
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDfsReplica::GetKeys
*
*  DESCRIPTION :    Get the multi part key
*
*****************************************************************************/

HRESULT CDfsReplica::GetKeys(const CInstance *pInstance, CHString &sLink, CHString &sServer, CHString &sShare)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // Get the Compound Key
    if ( !pInstance->GetCHString ( LINKNAME , sLink ) ||
         !pInstance->GetCHString ( SERVERNAME , sServer ) ||
         !pInstance->GetCHString ( SHARENAME , sShare ) )
    {
        hRes = WBEM_E_FAILED;
    }

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\dll\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

//

//  Module: WMI Framework Instance provider

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <dllunreg.h>
#include <DllCommon.h>
#include <brodcast.h>

HMODULE ghModule;

// {7F72CC7A-74A0-45b4-909C-14FB8186DD7E}
DEFINE_GUID(CLSID_CIPDFSTABLE,
0x7f72cc7a, 0x74a0, 0x45b4, 0x90, 0x9c, 0x14, 0xfb, 0x81, 0x86, 0xdd, 0x7e);

#define PROVIDER_NAME L"WMIPDFS"

//Count number of objects and number of locks.
long g_cLock = 0;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;
    
    try
    {
        if ( CLSID_CIPDFSTABLE == rclsid )
        {
            hr = CommonGetClassObject(riid, ppv, PROVIDER_NAME, g_cLock);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    catch ( ... )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
    SCODE sc = S_FALSE;

    try
    {
        sc = CommonCanUnloadNow(PROVIDER_NAME, g_cLock);
    }
    catch ( ... )
    {
        // sc should already be set correctly
    }

    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = RegisterServer( _T("WBEM IP DFS Provider"), CLSID_CIPDFSTABLE ) ;
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = UnregisterServer( CLSID_CIPDFSTABLE ) ;
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status;
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are
//          initialized and terminated, or upon calls to the LoadLibrary
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain( HINSTANCE hInstDLL,  // handle to DLL module
                       DWORD fdwReason,     // reason for calling function
                       LPVOID lpReserved )  // reserved
{
    BOOL bRet = TRUE;
    try
    {
		LogMessage2( L"%s  -> DllMain", PROVIDER_NAME);

		// Perform actions based on the reason for calling.
		switch( fdwReason )
		{
			case DLL_PROCESS_ATTACH:
			{
				bRet = CommonProcessAttach(PROVIDER_NAME, g_cLock, hInstDLL);
			}
			break;

			case DLL_THREAD_ATTACH:
			{
			 // Do thread-specific initialization.
			}
			break;

			case DLL_THREAD_DETACH:
			{
			 // Do thread-specific cleanup.
			}
			break;

			case DLL_PROCESS_DETACH:
			{
					// Perform any necessary cleanup.
					LogMessage( L"DLL_PROCESS_DETACH" );
			}
			break;
		}
    }
    catch ( ... )
    {
		bRet = FALSE;
    }

    return bRet ;  // Status of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DFS.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\dll\usebinding.cpp ===
//=================================================================

//

// usebinding.cpp -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <binding.h>

CBinding MyDFSJnptReplica(
    PROVIDER_NAME_DFSJNPTREPLICA,
    Namespace,
    PROVIDER_NAME_DFSJNPT,
    PROVIDER_NAME_DFSREPLICA,
    L"Dependent",
    L"Antecedent",
    L"Name",
    L"LinkName");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\dll\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <initguid.h>
#include <fwcommon.h>
#include <smartptr.h>
#include <objpath.h>

// for dfs structures
#include <lm.h>
#include <lmdfs.h>

#include "Dfscommon.h"
#include "DFSJnPtReplicaAsso.h"
#include "DfsReplica.h"
#include "DfsJnPt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\inc\dfscommon.h ===
/******************************************************************



   DFSCommon.H -- common defines for DFS classse



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

*******************************************************************/

#ifndef _DFS_COMMON_H
#define _DFS_COMMON_H

// Namespace
#define Namespace							L"root\\cimv2"

// Provider names
#define PROVIDER_NAME_DFSJNPT				L"Win32_DfsNode"
#define PROVIDER_NAME_DFSREPLICA			L"Win32_DfsTarget"
#define PROVIDER_NAME_DFSJNPTREPLICA		L"Win32_DfsNodeTarget"

// Definef for the DFS Type
#define DFS_TYPE_STANDALONE		0
#define DFS_TYPE_FTDFS			1


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\inc\dfsjnpt.h ===
/******************************************************************



   DFSJnPt.H -- WMI provider class definition



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

   Description: Class definition of DFS Junction Point/Links provider
			    Class
   
*******************************************************************/

#ifndef  _CDFSJNPT_H_
#define  _CDFSJNPT_H_

// Bitmaps for the properties
#define DFSJNPT_ALL_PROPS					0xFFFFFFFF
#define DFSJNPT_PROP_DfsEntryPath			0x00000001
//#define DFSJNPT_PROP_NoOfStorages			0x00000002
//#define DFSJNPT_PROP_ServerName				0x00000004
//#define DFSJNPT_PROP_ShareName				0x00000008
#define DFSJNPT_PROP_State					0x00000010
#define DFSJNPT_PROP_Comment				0x00000020
#define DFSJNPT_PROP_Timeout				0x00000040
#define DFSJNPT_PROP_Caption				0x00000080

// #defines for the property names	
#define DFSNAME         					L"Name"
#define DFSENTRYPATH						L"DFSENTRYPATH"
#define SERVERNAME							L"SERVERNAME"
#define SHARENAME							L"SHARENAME"
#define STATE								L"STATE"
#define COMMENT								L"Description"
#define TIMEOUT								L"TIMEOUT"
#define LINKNAME							L"LinkName"
#define CAPTION								L"Caption"

class CDfsJnPt : public Provider 
{
private:

	HRESULT EnumerateAllJnPts ( MethodContext *pMethodContext, DWORD dwPropertiesReq );
	HRESULT FindAndSetDfsEntry ( LPCWSTR a_Key, DWORD dwPropertiesReq, CInstance *pInstance, DWORD eOperation  );
	HRESULT DeleteDfsJnPt ( PDFS_INFO_4 pJnPtBuf );
	HRESULT UpdateDfsJnPt ( const CInstance &Instance, DWORD dwOperation );
	NET_API_STATUS AddDfsJnPt ( LPWSTR a_DfsEntry, LPWSTR a_ServerName, LPWSTR a_ShareName, LPWSTR a_Comment );
	HRESULT LoadDfsJnPt ( DWORD dwPropertiesReq, CInstance *pInstance, PDFS_INFO_4 pJnPtBuf, bool bRoot );
	void SetRequiredProperties ( CFrameworkQuery &Query, DWORD &dwPropertiesReq );

	HRESULT CheckParameters ( const CInstance &a_Instance ,int iStatus ) ;
	BOOL IsDfsRoot ( LPCWSTR lpKey );

protected:

    HRESULT EnumerateInstances ( MethodContext *pMethodContext, long lFlags = 0L ) ;
    HRESULT GetObject ( CInstance *pInstance, long lFlags, CFrameworkQuery &Query ) ;

    HRESULT PutInstance ( const CInstance& Instance, long lFlags = 0L ) ;
    HRESULT DeleteInstance ( const CInstance& Instance, long lFlags = 0L) ;

    HRESULT ExecMethod (

	    const CInstance& a_Instance,
	    const BSTR a_MethodName ,
	    CInstance *a_InParams ,
	    CInstance *a_OutParams ,
	    long a_Flags
    );

public:

    CDfsJnPt ( LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace ) ;
    virtual ~CDfsJnPt () ;

private:

	CHString m_ComputerName;
	enum { eGet, eDelete, eModify, eAdd, eUpdate };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\dll\diskquota.cpp ===
/******************************************************************

   DskQuota.CPP -- WMI provider class implementation



   Description:  Disk Quota Provider



  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

******************************************************************/

#include "precomp.h"
// #include for DiskQuota Provider Class
#include "DiskQuota.h"
#include "dllutils.h"

CDiskQuota MyCDiskQuota (

    IDS_DiskQuotaClass ,
    NameSpace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CDiskQuota::CDiskQuota
 *
 *  DESCRIPTION :   Constructor
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/

CDiskQuota :: CDiskQuota (

    LPCWSTR lpwszName,
    LPCWSTR lpwszNameSpace
) : Provider ( lpwszName , lpwszNameSpace )
{
    m_ComputerName = GetLocalComputerName();
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDiskQuota::~CDiskQuota
 *
 *  DESCRIPTION :   Destructor
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CDiskQuota :: ~CDiskQuota ()
{
}

HRESULT FindUser(CHString& user, IDiskQuotaControlPtr& controler)
{
	IEnumDiskQuotaUsersPtr userEnum;
	HRESULT hr = controler->CreateEnumUsers(0,0,DISKQUOTA_USERNAME_RESOLVE_SYNC, &userEnum);
	if (FAILED(hr)) return hr;

    CHString logonName;
    LPWSTR logonNameBuffer = logonName.GetBuffer(MAX_PATH + 1);

	IDiskQuotaUserPtr userQuota;
	while((hr = userEnum->Next(1, &userQuota, 0)) == NOERROR)
		{
        if (SUCCEEDED(userQuota->GetName( 0, 0, logonNameBuffer, MAX_PATH, 0, 0))
        	&& logonName == user) return S_OK;
        userQuota.Release();
		};

	if (hr== S_FALSE) // Enumeration completed
		return WBEM_E_NOT_FOUND;
	else 
		return hr;
};

/*****************************************************************************
*
*  FUNCTION    :    CDiskQuota::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  COMMENTS    :    All instances of Disk Quota users on all Logical Disks that
*                   supports disk quota on a machine  with all the properties of
*                   DiskQuota users should be  returned here.
*
*****************************************************************************/
HRESULT CDiskQuota :: EnumerateInstances (

    MethodContext *pMethodContext,
    long lFlags
)
{
    DWORD dwPropertiesReq = DSKQUOTA_ALL_PROPS;
    HRESULT hRes = WBEM_S_NO_ERROR;

    hRes = EnumerateUsersOfAllVolumes ( pMethodContext, dwPropertiesReq );

    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CDiskQuota::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class.
*
*****************************************************************************/
HRESULT CDiskQuota :: GetObject (

    CInstance *pInstance,
    long lFlags ,
    CFrameworkQuery &Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_Key1;
    CHString t_Key2;

    // Obtain the keys.
    if  ( pInstance->GetCHString ( IDS_LogicalDiskObjectPath , t_Key1 ) == FALSE )
    {
        hRes = WBEM_E_FAILED ;
    }

    if (  SUCCEEDED ( hRes )  )
    {
        if  ( pInstance->GetCHString ( IDS_UserObjectPath , t_Key2 ) == FALSE )
        {
            hRes = WBEM_E_FAILED ;
        }
    }

    if ( SUCCEEDED ( hRes )  )
    {
        CHString t_DiskPropVolumePath;

        GetKeyValue ( t_DiskPropVolumePath,t_Key1  );

		if (t_DiskPropVolumePath.IsEmpty())
		{
			hRes = WBEM_E_NOT_FOUND;
		}
		else
		{
			// verify this logical drives actually exists
			WCHAR lpDriveStrings[(MAX_PATH * 2) + 1];
			DWORD dwDLength = GetLogicalDriveStrings ( (MAX_PATH * 2), lpDriveStrings );
			hRes = m_CommonRoutine.SearchLogicalDisk ( t_DiskPropVolumePath.GetAt ( 0 ), lpDriveStrings );
		}

        if ( SUCCEEDED ( hRes ) )
        {
            WCHAR w_VolumePathName [ MAX_PATH + 1 ];

            t_DiskPropVolumePath += L"\\";

            if ( GetVolumeNameForVolumeMountPoint(
                            t_DiskPropVolumePath,
                            w_VolumePathName,
                            MAX_PATH
                       ))
            {
                // Get the key values, which will be the object path.
                // Now from the Volume Object path, parse out the volumename
                // from the User object path extract out the user Id.
                // for the volume specified  check whether the given volume Supports Disk Quotas
                CHString t_VolumeName;
                hRes = m_CommonRoutine.VolumeSupportsDiskQuota ( w_VolumePathName,  t_VolumeName );
                if ( SUCCEEDED ( hRes ) )
                {
                    // Get IDIskQuotaCOntrol  for this interface pointer
                    IDiskQuotaControlPtr pIQuotaControl;

                    if (  SUCCEEDED ( CoCreateInstance(
                                        CLSID_DiskQuotaControl,
                                        NULL,
                                        CLSCTX_INPROC_SERVER,
                                        IID_IDiskQuotaControl,
                                        (void **)&pIQuotaControl ) ) )
                    {
                        // Initialise the pIQuotaControl with the given volume
                        hRes = m_CommonRoutine.InitializeInterfacePointer (  pIQuotaControl, w_VolumePathName );
                        if ( SUCCEEDED ( hRes ) )
                        {
                            IDiskQuotaUserPtr pIQuotaUser;
                            CHString t_UserLogName;

                            GetKeyValue ( t_UserLogName, t_Key2 );
                            HRESULT hrTemp = WBEM_E_NOT_FOUND;

							if (!t_UserLogName.IsEmpty())
							{
								hrTemp = pIQuotaControl->FindUserName(
															 t_UserLogName,
															 &pIQuotaUser);

								// Certain Win32_Account instances report
								// the Domain as computername instead of
								// builtin, so change domain to builtin and
								// try again.
								CHString chstrBuiltIn;

								if(FAILED(hrTemp) && GetLocalizedBuiltInString(chstrBuiltIn))
								{
									int iWhackPos = t_UserLogName.Find(L"\\");
									CHString chstrDomain = t_UserLogName.Left(iWhackPos);
									if(chstrDomain.CompareNoCase(GetLocalComputerName()) == 0)
									{
										CHString chstrUNameOnly = t_UserLogName.Mid(iWhackPos);
										CHString chstrDomWhackName = chstrBuiltIn;
										chstrDomWhackName += chstrUNameOnly;

										hrTemp = pIQuotaControl->FindUserName(
																	 chstrDomWhackName,
																	 &pIQuotaUser);
									}
								}

								// Certain Win32_Account instances report
								// the Domain as computername instead of
								// NT AUTHORITY, so change domain to NT AUTHORITY and
								// try again.
								if(FAILED(hrTemp))
								{
									int iWhackPos = t_UserLogName.Find(L"\\");
									CHString chstrDomain = t_UserLogName.Left(iWhackPos);
									if(chstrDomain.CompareNoCase(GetLocalComputerName()) == 0)
									{
										CHString chstrUNameOnly = t_UserLogName.Mid(iWhackPos);
										CHString chstrNT_AUTHORITY;
										CHString chstrDomWhackName;
										if(GetLocalizedNTAuthorityString(chstrNT_AUTHORITY))
										{
											chstrDomWhackName = chstrNT_AUTHORITY;
										} 
										else
										{
											chstrDomWhackName = L"NT AUTHORITY";
										}
										chstrDomWhackName += chstrUNameOnly;

										hrTemp = pIQuotaControl->FindUserName(
																	 chstrDomWhackName,
																	 &pIQuotaUser);
									}
								}
							}

                            if(SUCCEEDED(hrTemp))
                            {
                                // Put this Instance
                                DWORD dwPropertiesReq;
                                if ( Query.AllPropertiesAreRequired() )
                                {
                                    dwPropertiesReq = DSKQUOTA_ALL_PROPS;
                                }
                                else
                                {
                                    SetPropertiesReq ( &Query, dwPropertiesReq );
                                }

                                hRes = LoadDiskQuotaUserProperties ( pIQuotaUser, pInstance, dwPropertiesReq );
                            }
                            else
                            {
                                hRes = WBEM_E_NOT_FOUND;
                            }
                        }
                    }
                    else
                    {
                        hRes = WBEM_E_FAILED;
                    }
                }
            }
            else
            {
                hRes = WBEM_E_NOT_FOUND;
            }
        }
    }
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CDiskQuota::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of
*                   instances that satisfy the query, and a CFrameworkQuery
*                   which describes the query.  Create and populate all
*                   instances which satisfy the query.
*                   a) Queries involving Properties other than Win32_LogicalDisk
*                      are not optimized. Since that would involve enumerating
*                      every user on all volumes
*
*****************************************************************************/

HRESULT CDiskQuota :: ExecQuery (

    MethodContext *pMethodContext,
    CFrameworkQuery &Query,
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    DWORD dwPropertiesReq;
    CHStringArray t_Values;

    // Now a check for the attribute which if present in where clause the query optimization is supported
    // We need not care for the other attributes for which Optimization is not supported, winmgmt will take
    // care of those.
    hRes = Query.GetValuesForProp(
             IDS_LogicalDiskObjectPath,
             t_Values
           );

    if ( Query.AllPropertiesAreRequired() )
    {
        dwPropertiesReq = DSKQUOTA_ALL_PROPS;
    }
    else
    {
        SetPropertiesReq ( &Query, dwPropertiesReq );
    }

    if ( SUCCEEDED ( hRes ) )
    {
        if ( t_Values.GetSize() == 0 )
        {
            hRes = EnumerateUsersOfAllVolumes ( pMethodContext, dwPropertiesReq );
        }
        else
        {
            // Only Volume in QuotaVolume properties are needed to be enumerated
            int iSize = t_Values.GetSize ();
            // verify this logical drives actually exists
            WCHAR lpDriveStrings [(MAX_PATH * 2) + 1];

            DWORD dwDLength = GetLogicalDriveStrings ( (MAX_PATH * 2), lpDriveStrings );

            for ( int i = 0; i < iSize; i++ )
            {
                CHString t_VolumePath;
                //Here we need to parse the VolumeObject path and extract VolumePath from it.
                GetKeyValue ( t_VolumePath, t_Values.GetAt(i) );

                if (( t_VolumePath.GetLength() == 2 ) && ( t_VolumePath.GetAt ( 1 ) == _L(':') ) )
                {
                    HRESULT tmpHR = m_CommonRoutine.SearchLogicalDisk ( t_VolumePath.GetAt ( 0 ), lpDriveStrings );
                    if ( SUCCEEDED ( tmpHR ) )
                    {
                        t_VolumePath += L"\\";
                        hRes = EnumerateUsers ( pMethodContext, t_VolumePath,  dwPropertiesReq );
                    }
                }
            }
        }
    }
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::PutInstance
*
*  DESCRIPTION : If the instance is already existing, we only modify the instance
*                if it doesnt exist, we will add the instance based on the flags.
*
*****************************************************************************/

HRESULT CDiskQuota :: PutInstance  (

    const CInstance &Instance,
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_Key1;
    CHString t_Key2;
    BOOL bFound = TRUE;

    if  ( Instance.GetCHString ( IDS_LogicalDiskObjectPath , t_Key1 ) == FALSE )
    {
        hRes = WBEM_E_FAILED ;
    }

    if (  SUCCEEDED ( hRes )  )
    {
        if  ( Instance.GetCHString ( IDS_UserObjectPath , t_Key2 ) == FALSE )
        {
            hRes = WBEM_E_FAILED ;
        }
    }

    if (  SUCCEEDED ( hRes )  )
    {
        WCHAR t_VolumePathName[MAX_PATH + 1];
        CHString t_UserLogonName;
        CHString t_VolumePath;
		GetKeyValue ( t_VolumePath,t_Key1  );

		if (t_VolumePath.IsEmpty())
		{
			hRes = WBEM_E_NOT_FOUND ;
		}
		else
		{
			// verify this logical drives actually exists
			WCHAR lpDriveStrings [(MAX_PATH * 2) + 1];

			DWORD dwDLength = GetLogicalDriveStrings ( (MAX_PATH * 2), lpDriveStrings );

			hRes = m_CommonRoutine.SearchLogicalDisk ( t_VolumePath.GetAt ( 0 ), lpDriveStrings );
		}

        if ( SUCCEEDED ( hRes ) )
        {
            GetKeyValue ( t_UserLogonName, t_Key2 );

			if (t_UserLogonName.IsEmpty())
			{
				hRes = WBEM_E_NOT_FOUND;
			}
			else
			{
				t_VolumePath += L"\\";


				if ( GetVolumeNameForVolumeMountPoint(
								t_VolumePath,
								t_VolumePathName,
								MAX_PATH
							))
				{
					// Check if the user already exists
					hRes = m_CommonRoutine.VolumeSupportsDiskQuota ( t_VolumePathName,  t_VolumePath );
					if ( SUCCEEDED ( hRes ) )
					{
						// Get IDIskQuotaCOntrol  for this interface pointer
						IDiskQuotaControlPtr pIQuotaControl;
						if (  SUCCEEDED ( CoCreateInstance(
											CLSID_DiskQuotaControl,
											NULL,
											CLSCTX_INPROC_SERVER,
											IID_IDiskQuotaControl,
											(void **)&pIQuotaControl ) ) )
						{
							// Initialise the pIQuotaControl with the given volume
							hRes = m_CommonRoutine.InitializeInterfacePointer (  pIQuotaControl, t_VolumePathName );
							if ( SUCCEEDED ( hRes ) )
							{
								hRes = FindUser(t_UserLogonName,pIQuotaControl );

								// Certain Win32_Account instances report
								// the Domain as computername instead of
								// builtin, so change domain to builtin and
								// try again.
								CHString chstrBuiltIn;

								if( hRes == WBEM_E_NOT_FOUND && GetLocalizedBuiltInString(chstrBuiltIn))
								{
									int iWhackPos = t_UserLogonName.Find(L"\\");
									CHString chstrDomain = t_UserLogonName.Left(iWhackPos);
									if(chstrDomain.CompareNoCase(GetLocalComputerName()) == 0)
									{
										CHString chstrUNameOnly = t_UserLogonName.Mid(iWhackPos);
										CHString chstrDomWhackName = chstrBuiltIn;
										chstrDomWhackName += chstrUNameOnly;

										hRes = FindUser(chstrDomWhackName,pIQuotaControl);


										if(SUCCEEDED(hRes))
										{
											t_UserLogonName = chstrDomWhackName;
										}
										else if (hRes == WBEM_E_NOT_FOUND)
										{
											CHString chstrNT_AUTHORITY;
											CHString chstrDomWhackName;
											if(GetLocalizedNTAuthorityString(chstrNT_AUTHORITY))
											{
												chstrDomWhackName = chstrNT_AUTHORITY;
											} 
											else
											{
												chstrDomWhackName = L"NT AUTHORITY";
											}
											chstrDomWhackName += chstrUNameOnly;
											hRes = FindUser(chstrDomWhackName,pIQuotaControl);
											if(SUCCEEDED(hRes))
											{
												t_UserLogonName = chstrDomWhackName;
											}
										}
									}
								}
							}
						}
						else
						{
							hRes = WBEM_E_FAILED;
						}
					}
				}
				else
				{
					hRes = WBEM_E_NOT_FOUND;
				}
			}
        }

        if ( SUCCEEDED ( hRes ) || ( hRes == WBEM_E_NOT_FOUND ) )
        {

            BOOL bCreate = FALSE;
            BOOL bUpdate = FALSE;

            switch ( lFlags & 3 )
            {
                case WBEM_FLAG_CREATE_OR_UPDATE:
                {
                    if ( hRes == WBEM_E_NOT_FOUND )
					{
                        bCreate = TRUE;
						hRes = WBEM_S_NO_ERROR;
					}
                    else
                        bUpdate = TRUE;
                }
                break;

                case WBEM_FLAG_UPDATE_ONLY:
                {
                    bUpdate = TRUE;
                }
                break;

                case WBEM_FLAG_CREATE_ONLY:
                {
                    if ( hRes  ==  WBEM_E_NOT_FOUND )
                    {
                        bCreate = TRUE;
						hRes = WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        hRes = WBEM_E_ALREADY_EXISTS ;
                    }
                }
                break;

                default:
                    {
                        hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
                    }
            }

			if (SUCCEEDED(hRes))
			{
				if ( bCreate )
				{
					hRes = AddUserOnVolume ( Instance,
									t_VolumePathName,
									t_UserLogonName );
				}
				else
				if ( bUpdate )
				{
					hRes = UpdateUserQuotaProperties ( Instance,
										t_VolumePathName,
										t_UserLogonName);
				}
			}
        }
    }
    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CDiskQuota:: DeleteInstance
*
*  DESCRIPTION :    If the given instance of a user exists on the Volume,
*                   the user is deleted, meaning diskquota properties
*                   will no t be applicable to this user.
*
*****************************************************************************/
HRESULT CDiskQuota :: DeleteInstance (

    const CInstance &Instance,
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_Key1;
    CHString t_Key2;

    if  ( Instance.GetCHString ( IDS_LogicalDiskObjectPath , t_Key1 ) == FALSE )
    {
        hRes = WBEM_E_FAILED ;
    }

    if (  SUCCEEDED ( hRes ) )
    {
        if  ( Instance.GetCHString ( IDS_UserObjectPath , t_Key2 ) == FALSE )
        {
            hRes = WBEM_E_FAILED ;
        }
    }

    if (  SUCCEEDED ( hRes )  )
    {
        CHString t_VolumePath;

        GetKeyValue ( t_VolumePath,t_Key1  );

		if (t_VolumePath.IsEmpty())
		{
			hRes = WBEM_E_NOT_FOUND;
		}
		else
		{
			// verify this logical drives actually exists
			WCHAR lpDriveStrings [ (MAX_PATH * 2) + 1 ];

			DWORD dwDLength = GetLogicalDriveStrings ( (MAX_PATH * 2), lpDriveStrings );

			if ( ( t_VolumePath.GetLength()  == 2 ) && ( t_VolumePath.GetAt ( 1 ) == L':') )
			{
				hRes = m_CommonRoutine.SearchLogicalDisk ( t_VolumePath.GetAt ( 0 ), lpDriveStrings );
				if ( SUCCEEDED ( hRes ) )
				{
					t_VolumePath += L"\\";

					CHString t_UserLogonName;
					GetKeyValue ( t_UserLogonName, t_Key2 );

					if (t_UserLogonName.IsEmpty())
					{
						hRes = WBEM_E_NOT_FOUND;
					}
					else
					{
						WCHAR t_VolumePathName[MAX_PATH + 1];

						if ( GetVolumeNameForVolumeMountPoint(
										t_VolumePath,
										t_VolumePathName,
										MAX_PATH
									) )
						{
							// for the volume specified  check whether the given volume Supports Disk Quotas
							CHString t_TempVolumeName;
							hRes = m_CommonRoutine.VolumeSupportsDiskQuota ( t_VolumePathName, t_TempVolumeName );
							if ( SUCCEEDED ( hRes ) )
							{
								// Get IDIskQuotaCOntrol  for this interface pointer
								IDiskQuotaControlPtr pIQuotaControl;
								if (  SUCCEEDED ( CoCreateInstance(
													CLSID_DiskQuotaControl,
													NULL,
													CLSCTX_INPROC_SERVER,
													IID_IDiskQuotaControl,
													(void **)&pIQuotaControl ) ) )
								{
									// Initialise the pIQuotaControl with the given volume
									hRes = m_CommonRoutine.InitializeInterfacePointer (  pIQuotaControl, t_VolumePathName );
									if ( SUCCEEDED ( hRes ) )
									{
										IDiskQuotaUserPtr pIQuotaUser;
										hRes = pIQuotaControl->FindUserName(
																t_UserLogonName,
																&pIQuotaUser
															);

										// Certain Win32_Account instances report
										// the Domain as computername instead of
										// builtin, so change domain to builtin and
										// try again.
										CHString chstrBuiltIn;

										if(FAILED(hRes) && GetLocalizedBuiltInString(chstrBuiltIn))
										{
											int iWhackPos = t_UserLogonName.Find(L"\\");
											CHString chstrDomain = t_UserLogonName.Left(iWhackPos);
											if(chstrDomain.CompareNoCase(GetLocalComputerName()) == 0)
											{
												CHString chstrUNameOnly = t_UserLogonName.Mid(iWhackPos);
												CHString chstrDomWhackName = chstrBuiltIn;
												chstrDomWhackName += chstrUNameOnly;

												hRes = pIQuotaControl->FindUserName(
																			 chstrDomWhackName,
																			 &pIQuotaUser);
											}
										}

										// Get the user properties
										if (  SUCCEEDED ( hRes )  )
										{
											// Since the user is found delete the user.
											hRes = pIQuotaControl->DeleteUser ( pIQuotaUser );

											if (FAILED(hRes))
											{
												if (SCODE_CODE(hRes) == ERROR_ACCESS_DENIED)
												{
													hRes = WBEM_E_ACCESS_DENIED;
												}
												else
												{
													hRes = WBEM_E_FAILED;
												}
											}
										}
										else
										{
											hRes = WBEM_E_NOT_FOUND;
										}
									}
								}
								else
								{
									hRes = WBEM_E_FAILED;
								}
							}
						}
						else
						{
							hRes = WBEM_E_NOT_FOUND;
						}
					}
				}
			}
			else
			{
				hRes = WBEM_E_NOT_FOUND;
			}
		}
    }
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::EnumerateUsersOfAllVolumes
*
*  DESCRIPTION : In this method enumerating volumes and calling enumerate users
*                for that volume
*
*****************************************************************************/

HRESULT CDiskQuota :: EnumerateUsersOfAllVolumes (

    MethodContext *pMethodContext,
    DWORD a_PropertiesReq
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    WCHAR t_VolumeName[MAX_PATH + 1];
    SmartCloseVolumeHandle hVol;

    hVol =  FindFirstVolume(
                t_VolumeName,      // output buffer
                MAX_PATH    // size of output buffer
            );

    if ( hVol  != INVALID_HANDLE_VALUE )
    {
        BOOL bNextVol = TRUE;
        // verify this logical drives actually exists
        WCHAR lpDriveStrings[(MAX_PATH * 2) + 1];

        DWORD dwDLength = GetLogicalDriveStrings ( (MAX_PATH * 2), lpDriveStrings );

        CHString t_VolumePath;

        while ( bNextVol )
        {
            m_CommonRoutine.GetVolumeDrive ( t_VolumeName, lpDriveStrings, t_VolumePath );

            EnumerateUsers ( pMethodContext, t_VolumePath, a_PropertiesReq );

            bNextVol =  FindNextVolume(
                         hVol,             // volume search handle
                         t_VolumeName,     // output buffer
                         MAX_PATH      // size of output buffer
                    );

        }
    }
    else
    {
        hRes = WBEM_E_FAILED;
    }

    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::EnumerateUsers
*
*  DESCRIPTION : In this method Enumerating all the users of a given volume that
*                Supports DiskQuotas
*
*****************************************************************************/

HRESULT CDiskQuota :: EnumerateUsers (

    MethodContext *pMethodContext,
    LPCWSTR a_VolumeName,
    DWORD a_PropertiesReq
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // checking whether the given volume supports disk quotas, and getting the Volume name which is readable to the
    // user, i.e. not containing the GUID.
    CHString t_VolumeName;

    hRes = m_CommonRoutine.VolumeSupportsDiskQuota ( a_VolumeName, t_VolumeName );
    if ( SUCCEEDED ( hRes ) )
    {
        // Get the QuotaInterface Pointer
        IDiskQuotaControlPtr pIQuotaControl;

        if (  SUCCEEDED ( CoCreateInstance(
                            CLSID_DiskQuotaControl,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IDiskQuotaControl,
                            (void **)&pIQuotaControl ) ) )
        {
            // initializing the Interface pointer for a particular volume
            hRes = m_CommonRoutine.InitializeInterfacePointer (  pIQuotaControl, a_VolumeName );
            if ( SUCCEEDED ( hRes ) )
            {
                // need to update the cache, else we can get old names
                pIQuotaControl->InvalidateSidNameCache();

                IEnumDiskQuotaUsersPtr  pIEnumDiskQuotaUsers;

                if ( SUCCEEDED ( pIQuotaControl->CreateEnumUsers(
                                            NULL, //All the users will be enumerated
                                            0,    // Ignored for enumerating all users
                                            DISKQUOTA_USERNAME_RESOLVE_SYNC,
                                            &pIEnumDiskQuotaUsers
                                     ) ) )
                {
                    if ( pIEnumDiskQuotaUsers != NULL )
                    {
                        hRes = pIEnumDiskQuotaUsers->Reset();

                        if ( SUCCEEDED(hRes))
                        {
                            IDiskQuotaUserPtr pIQuotaUser;
                            DWORD dwNoOfUsers = 0;
                            HRESULT hRes = S_OK;

                            hRes = pIEnumDiskQuotaUsers->Next(
                                            1,
                                            &pIQuotaUser,
                                            &dwNoOfUsers
                                        );

                            CInstancePtr pInstance;

                            while (  SUCCEEDED ( hRes )  )
                            {
                                if ( dwNoOfUsers == 0 )
                                {
                                    break;
                                }

                                if ( pIQuotaUser != NULL )
                                {
                                    pInstance.Attach(CreateNewInstance ( pMethodContext ));

                                    hRes = LoadDiskQuotaUserProperties ( pIQuotaUser, pInstance, a_PropertiesReq );
                                    if ( SUCCEEDED ( hRes ) )
                                    {
                                        if(SUCCEEDED(SetKeys( pInstance, a_VolumeName[0], a_PropertiesReq, pIQuotaUser )))
                                        {
                                            hRes = pInstance->Commit ();
                                        }

                                        if (SUCCEEDED(hRes))
                                        {
                                            dwNoOfUsers = 0;
                                            hRes = pIEnumDiskQuotaUsers->Next(
                                                                1,
                                                                &pIQuotaUser,
                                                                &dwNoOfUsers
                                                            );
                                        }
                                    }
                                    else
                                    {
                                        break;
                                    }
                                }
                                else
                                {
                                    // No more Users
                                    break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    hRes = WBEM_E_FAILED;
                }
            }
        }
    }
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::LoadDiskQuotaUserProperties
*
*  DESCRIPTION : In this method Getting the User properties into a Given Structure
*
*****************************************************************************/

HRESULT CDiskQuota :: LoadDiskQuotaUserProperties (

    IDiskQuotaUser* pIQuotaUser,
    CInstance* pInstance,
    DWORD a_PropertiesReq
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if ( ( ( a_PropertiesReq & DSKQUOTA_PROP_Status ) == DSKQUOTA_PROP_Status  )
         || ( ( a_PropertiesReq & DSKQUOTA_PROP_WarningLimit ) == DSKQUOTA_PROP_WarningLimit  )
         || ( ( a_PropertiesReq & DSKQUOTA_PROP_Limit ) == DSKQUOTA_PROP_Limit  )
         || ( ( a_PropertiesReq & DSKQUOTA_PROP_DiskSpaceUsed ) == DSKQUOTA_PROP_DiskSpaceUsed  ) )
    {
        DISKQUOTA_USER_INFORMATION t_QuotaInformation;
        if ( SUCCEEDED ( pIQuotaUser->GetQuotaInformation ( &t_QuotaInformation, sizeof ( DISKQUOTA_USER_INFORMATION ) ) ) )
        {
            LONGLONG llLimit = -1;
            LONGLONG llWarningLimit = -1;
            UINT64 ullDiskSpaceUsed = 0;
            DWORD dwStatus;

            if (  t_QuotaInformation.QuotaLimit >= 0 )
            {
                llLimit = t_QuotaInformation.QuotaLimit;
            }

            if ( t_QuotaInformation.QuotaThreshold >= 0 )
            {
                llWarningLimit = t_QuotaInformation.QuotaThreshold;
            }

            ullDiskSpaceUsed = t_QuotaInformation.QuotaUsed;

            if ( t_QuotaInformation.QuotaThreshold > -1 )
            {
                // Since -1 means no Warning limit is set for the user, the deault is the complete Volume Space
                if ( t_QuotaInformation.QuotaUsed < t_QuotaInformation.QuotaThreshold )
                {
                    dwStatus =  0;
                }
            }
            else
            {
                dwStatus = 0;
            }

            if ( t_QuotaInformation.QuotaThreshold > -1 )
            {
                // Since -1 means no Warning limit is set for the user, the deault is the complete Volume Space
                if ( t_QuotaInformation.QuotaUsed >= t_QuotaInformation.QuotaThreshold )
                {
                    dwStatus = 1;
                }
            }

            if ( t_QuotaInformation.QuotaLimit > -1 )
            {
                if ( t_QuotaInformation.QuotaUsed >= t_QuotaInformation.QuotaLimit )
                {
                    dwStatus =  2;
                }
            }

            if (  ( a_PropertiesReq & DSKQUOTA_PROP_Status ) == DSKQUOTA_PROP_Status  )
            {
                if ( pInstance->SetDWORD ( IDS_QuotaStatus, dwStatus ) == FALSE )
                {
                    hRes = WBEM_E_FAILED;
                }
            }

            if ( ( a_PropertiesReq & DSKQUOTA_PROP_WarningLimit ) == DSKQUOTA_PROP_WarningLimit )
            {
                if ( pInstance->SetWBEMINT64 ( IDS_QuotaWarningLimit, (ULONGLONG)llWarningLimit ) == FALSE )
                {
                    hRes = WBEM_E_FAILED;
                }
            }

            if ( ( a_PropertiesReq & DSKQUOTA_PROP_Limit ) == DSKQUOTA_PROP_Limit  )
            {
                if ( pInstance->SetWBEMINT64 ( IDS_QuotaLimit, (ULONGLONG)llLimit ) == FALSE )
                {
                    hRes = WBEM_E_FAILED;
                }
            }

            if ( ( a_PropertiesReq & DSKQUOTA_PROP_DiskSpaceUsed ) == DSKQUOTA_PROP_DiskSpaceUsed  )
            {
                if ( pInstance->SetWBEMINT64 ( IDS_DiskSpaceUsed, ullDiskSpaceUsed ) == FALSE )
                {
                    hRes = WBEM_E_FAILED;
                }
            }
        }
        else
        {
            hRes = WBEM_E_FAILED;
        }
    }

    return hRes;
}
/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::SetKeys
*
*  DESCRIPTION : In this method Setting the User properties in a Given Instance
*
*****************************************************************************/
HRESULT CDiskQuota :: SetKeys(

    CInstance* pInstance,
    WCHAR w_Drive,
    DWORD a_PropertiesReq,
    IDiskQuotaUser* pIQuotaUser
)
{
    LPWSTR lpLogicalDiskObjectPath;
    LPWSTR lpUserObjectPath;
    HRESULT hRes = WBEM_S_NO_ERROR;

    if ( ( a_PropertiesReq & DSKQUOTA_PROP_LogicalDiskObjectPath )  == DSKQUOTA_PROP_LogicalDiskObjectPath )
    {
        LPWSTR lpLogicalDiskObjectPath;
        WCHAR t_DeviceId[3];

        t_DeviceId[0] = w_Drive;
        t_DeviceId[1] = L':';
        t_DeviceId[2] = L'\0';

        m_CommonRoutine.MakeObjectPath ( lpLogicalDiskObjectPath,  IDS_LogicalDiskClass, IDS_DeviceID, t_DeviceId );

        if ( lpLogicalDiskObjectPath != NULL )
        {
            try
            {
                if ( pInstance->SetWCHARSplat ( IDS_LogicalDiskObjectPath, lpLogicalDiskObjectPath ) == FALSE )
                {
                    hRes = WBEM_E_FAILED;
                }
            }
            catch ( ... )
            {
                delete [] lpLogicalDiskObjectPath;
                throw;
            }
            delete [] lpLogicalDiskObjectPath;
        }
    }

    if (SUCCEEDED(hRes) && (( a_PropertiesReq & DSKQUOTA_PROP_UserObjectPath )  == DSKQUOTA_PROP_UserObjectPath) )
    {

        // Obtaining the users logon Name
        CHString t_LogonName;

        WCHAR w_AccountContainer [ MAX_PATH + 1 ];
        WCHAR w_DisplayName [ MAX_PATH + 1 ];
        LPWSTR t_LogonNamePtr = t_LogonName.GetBuffer(MAX_PATH + 1);

        if ( SUCCEEDED ( pIQuotaUser->GetName (
                            w_AccountContainer,
                            MAX_PATH,
                            t_LogonNamePtr,
                            MAX_PATH,
                            w_DisplayName,
                            MAX_PATH
                            ) ) )
        {
            t_LogonName.ReleaseBuffer();

            // Have seen cases where GetName succeeds, but
            // the t_LogonName variable contains an empty string.
            if(t_LogonName.GetLength() > 0)
            {
                CHString t_DomainName;
                ExtractUserLogOnName ( t_LogonName, t_DomainName );

                // BUILTIN and NT AUTHORITY accounts are represented
                // by Win32_Account and its children with the domain
                // name being the name of the machine, instead of
                // either of these strings.  Hence the change below:
                CHString chstrNT_AUTHORITY;
                CHString chstrBuiltIn;
                if(!GetLocalizedNTAuthorityString(chstrNT_AUTHORITY) || !GetLocalizedBuiltInString(chstrBuiltIn))
                {
                    hRes = WBEM_E_FAILED;
                } 

                if(SUCCEEDED(hRes))
                {
                    if(t_DomainName.CompareNoCase(chstrBuiltIn) == 0 ||
                       t_DomainName.CompareNoCase(chstrNT_AUTHORITY) == 0)
                    {
                        t_DomainName = m_ComputerName;
                    }

                    m_CommonRoutine.MakeObjectPath ( lpUserObjectPath, IDS_AccountClass, IDS_Domain, t_DomainName );

					if ( lpUserObjectPath != NULL )
					{
						m_CommonRoutine.AddToObjectPath ( lpUserObjectPath, IDS_Name, t_LogonName );
					}

                    if ( lpUserObjectPath != NULL )
                    {
                        try
                        {
                            if ( pInstance->SetWCHARSplat ( IDS_UserObjectPath, lpUserObjectPath ) == FALSE )
                            {
                                hRes = WBEM_E_FAILED;
                            }
                        }
                        catch ( ... )
                        {
                            delete [] lpUserObjectPath;
                            throw;
                        }
                        delete [] lpUserObjectPath;
                    }
                }
            }
            else
            {
                hRes = WBEM_E_FAILED;
            }
        }
    }
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::AddUserOnVolume
*
*  DESCRIPTION : In this method Adding a user on a volume that supports disk quota
*
*****************************************************************************/
HRESULT CDiskQuota :: AddUserOnVolume (

    const CInstance &Instance,
    LPCWSTR a_VolumePathName,
    LPCWSTR a_UserLogonName
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // Get all the properties and check for their validity.
    // all the properties should be provided
    // if the properties like limit and warning limit are not supplied
    // then they should be taken as default values specified on that volume.
    // Also disk space used will not be defined, only the user logon name will be given that will include
    // the domain name so that the logon name would be uniquely defined.

    CHString t_Key1;
    CHString t_Key2;

    if  ( Instance.GetCHString ( IDS_LogicalDiskObjectPath , t_Key1 ) == FALSE )
    {
        hRes = WBEM_E_FAILED ;
    }

    if (  SUCCEEDED ( hRes ) )
    {
        if  ( Instance.GetCHString ( IDS_UserObjectPath , t_Key2 ) == FALSE )
        {
            hRes = WBEM_E_FAILED ;
        }
    }

    if (  SUCCEEDED ( hRes )  )
    {
        CHString t_VolumePath;
        GetKeyValue ( t_VolumePath,t_Key1  );

		if (!t_VolumePath.IsEmpty())
		{
			hRes = CheckParameters (
						Instance
				   );
		}
		else
		{
			hRes = WBEM_E_FAILED;
		}

        if (  SUCCEEDED ( hRes )  )
        {
            CHString t_VolumeName;
            // Get the key values, which will be the object path.
            // Now from the Volume Object path, parse out the volumename
            // from the User object path extract out the user Id.
            // for the volume specified  check whether the given volume Supports Disk Quota
            if ( SUCCEEDED(m_CommonRoutine.VolumeSupportsDiskQuota ( a_VolumePathName,  t_VolumeName ) ) )
            {
                // Get IDIskQuotaCOntrol  for this interface pointer
                IDiskQuotaControlPtr pIQuotaControl;
                if (  SUCCEEDED ( CoCreateInstance(
                                    CLSID_DiskQuotaControl,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IDiskQuotaControl,
                                    (void **)&pIQuotaControl ) ) )
                {
                    // Initialise the pIQuotaControl with the given volume
                    hRes = m_CommonRoutine.InitializeInterfacePointer (  pIQuotaControl, a_VolumePathName );
                    if ( SUCCEEDED ( hRes ) )
                    {
                        IDiskQuotaUserPtr pIQuotaUser = NULL;
                        hRes = pIQuotaControl->AddUserName(
                                    a_UserLogonName ,
                                    DISKQUOTA_USERNAME_RESOLVE_SYNC,
                                    &pIQuotaUser
                                );

                        if (  SUCCEEDED ( hRes )  )
                        {
                            LONGLONG llLimit;
                            Instance.GetWBEMINT64 ( IDS_QuotaLimit, llLimit );
                            hRes = pIQuotaUser->SetQuotaLimit ( llLimit, TRUE);

                            if (SUCCEEDED(hRes))
                            {
                                // Set the User Warning Limit
                                Instance.GetWBEMINT64 ( IDS_QuotaWarningLimit, llLimit );
                                hRes = pIQuotaUser->SetQuotaThreshold ( llLimit, TRUE );
                            }
                        }
                        else
                            if ( hRes == S_FALSE )
                            {
                                hRes = WBEM_E_ALREADY_EXISTS ;
                            }
                            else
                            {
                                hRes = WBEM_E_INVALID_PARAMETER;
                            }
                    }
                }
				else
				{
					hRes = WBEM_E_FAILED;
				}
            }
            else
            {
                hRes = WBEM_E_FAILED;
            }
        }
        else
        {
            hRes = WBEM_E_FAILED;
        }

    }
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::UpdateUserQuotaProperties
*
*  DESCRIPTION : In this method modifying a disk quota properties of a given user
*                on a given volume that supports disk quota
*
*****************************************************************************/
HRESULT CDiskQuota :: UpdateUserQuotaProperties (
    const CInstance &Instance,
    LPCWSTR a_VolumePathName,
    LPCWSTR a_UserLogonName
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_Key1;
    CHString t_Key2;

    if  ( Instance.GetCHString ( IDS_LogicalDiskObjectPath , t_Key1 ) == FALSE )
    {
        hRes = WBEM_E_FAILED ;
    }

    if (  SUCCEEDED ( hRes )  )
    {
        if  ( Instance.GetCHString ( IDS_UserObjectPath , t_Key2 ) == FALSE )
        {
            hRes = WBEM_E_FAILED ;
        }
    }

    if ( SUCCEEDED ( hRes )  )
    {
        CHString t_VolumePath;
        GetKeyValue ( t_VolumePath ,t_Key1  );

		if (!t_VolumePath.IsEmpty())
		{
			hRes = CheckParameters (

                    Instance
               );
		}
		else
		{
			hRes = WBEM_E_FAILED ;
		}

        if ( SUCCEEDED ( hRes ) )
        {
            CHString t_VolumeName;
            if ( SUCCEEDED(m_CommonRoutine.VolumeSupportsDiskQuota ( a_VolumePathName,  t_VolumeName )) )
            {
                // Get IDIskQuotaCOntrol  for this interface pointer
                IDiskQuotaControlPtr pIQuotaControl;
                if (  SUCCEEDED ( CoCreateInstance(
                                    CLSID_DiskQuotaControl,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IDiskQuotaControl,
                                    (void **)&pIQuotaControl ) ) )
                {
                    // Initialise the pIQuotaControl with the given volume
                    hRes = m_CommonRoutine.InitializeInterfacePointer (  pIQuotaControl, a_VolumePathName );
                    if ( SUCCEEDED ( hRes ) )
                    {
                        IDiskQuotaUserPtr pIQuotaUser;
                        hRes = pIQuotaControl->FindUserName(
                                    a_UserLogonName ,
                                    &pIQuotaUser
                                );
                        if (  SUCCEEDED ( hRes )  )
                        {
                            LONGLONG llLimit;

                            if (Instance.GetWBEMINT64 ( IDS_QuotaLimit, llLimit ))
                            {
                                hRes = pIQuotaUser->SetQuotaLimit ( llLimit, TRUE);
                            }

                            // Set the User Warning Limit
                            if (SUCCEEDED(hRes) && Instance.GetWBEMINT64 ( IDS_QuotaWarningLimit, llLimit ))
                            {
                                hRes = pIQuotaUser->SetQuotaThreshold ( llLimit, TRUE );
                            }
                        }
                        else
                        {
                            hRes = WBEM_E_NOT_FOUND;
                        }
                    }
                }
                else
                {
                    hRes = WBEM_E_FAILED;
                }
            }
            else
            {
                hRes = WBEM_E_FAILED;
            }
        }
    }
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::CheckParameters
*
*  DESCRIPTION : In this method verifying the validity of the parameters
*                which are supplied in PutInstance by the user.
*
*****************************************************************************/
HRESULT CDiskQuota :: CheckParameters (

    const CInstance &a_Instance
)
{
    // Get all the Properties from the Instance to Verify
    HRESULT hRes = WBEM_S_NO_ERROR ;
    bool t_Exists ;
    VARTYPE t_Type ;

    if ( a_Instance.GetStatus ( IDS_QuotaLimit , t_Exists , t_Type ) )
    {
        if ( t_Exists && ( t_Type == VT_BSTR ) )
        {
            LONGLONG llLimit;
            if ( a_Instance.GetWBEMINT64 ( IDS_QuotaLimit , llLimit ) == FALSE )
            {
                hRes = WBEM_E_INVALID_PARAMETER ;
            }
        }
        else
        if ( t_Exists == false )
        {
                hRes = WBEM_E_INVALID_PARAMETER ;
        }
    }

    if ( a_Instance.GetStatus ( IDS_QuotaWarningLimit , t_Exists , t_Type ) )
    {
        if ( t_Exists && ( t_Type == VT_BSTR ) )
        {
            LONGLONG llLimit;
            if ( a_Instance.GetWBEMINT64 ( IDS_QuotaWarningLimit , llLimit ) == FALSE )
            {
                hRes = WBEM_E_INVALID_PARAMETER ;
            }
        }
        else
        if (  t_Exists == false )
        {
            hRes = WBEM_E_INVALID_PARAMETER ;
        }
    }
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::SetPropertiesReq
*
*  DESCRIPTION : In this method setting the properties required requested
*                by the user.
*
*****************************************************************************/
void CDiskQuota :: SetPropertiesReq (

    CFrameworkQuery *Query,
    DWORD &a_PropertiesReq
)
{
    a_PropertiesReq = 0;
    // being key this property needs to be delivered
    if ( Query->IsPropertyRequired ( IDS_LogicalDiskObjectPath ) )
    {
        a_PropertiesReq |= DSKQUOTA_PROP_LogicalDiskObjectPath;
    }

    if ( Query->IsPropertyRequired ( IDS_UserObjectPath ) )
    {
        a_PropertiesReq |= DSKQUOTA_PROP_UserObjectPath;
    }

    if ( Query->IsPropertyRequired ( IDS_QuotaStatus ) )
    {
        a_PropertiesReq |= DSKQUOTA_PROP_Status;
    }

    if ( Query->IsPropertyRequired ( IDS_QuotaWarningLimit ) )
    {
        a_PropertiesReq |= DSKQUOTA_PROP_WarningLimit;
    }

    if ( Query->IsPropertyRequired ( IDS_QuotaLimit ) )
    {
        a_PropertiesReq |= DSKQUOTA_PROP_Limit;
    }

    if ( Query->IsPropertyRequired ( IDS_DiskSpaceUsed ) )
    {
        a_PropertiesReq |= DSKQUOTA_PROP_DiskSpaceUsed;
    }
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::ExtractUserLogOnName
*
*  DESCRIPTION : Here the user logon name is in the form
*                ComputerName\userlogonname or Domainname\Userlogonname
*                or eg like
*                   builtin\adminitrator, where buildin is treated as a
*                   domain name by the Win32_UserAccount class. Hence
*                   we need to seperate the userlogon name and a domain name,
*                   so that the keys will match the Win32_UserAccount class.
*                OR...
*                the name may be of the form:  User@domain.something.com
*
*****************************************************************************/
void CDiskQuota :: ExtractUserLogOnName ( CHString &a_UserLogonName, CHString &a_DomainName )
{
    // Need the string "NT AUTHORITY".  However, on non-english
    // builds, this is something else.  Hence, get if from the
    // sid.
    PSID pSidNTAuthority = NULL;
	SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    CHString cstrAuthorityDomain;
	if (AllocateAndInitializeSid (&sia ,1,SECURITY_LOCAL_SYSTEM_RID,0,0,0,0,0,0,0,&pSidNTAuthority))
	{
		try
        {
            CHString cstrName;
            GetDomainAndNameFromSid(pSidNTAuthority, cstrAuthorityDomain, cstrName);
        }
        catch(...)
        {
            FreeSid(pSidNTAuthority);
            throw;
        }
		FreeSid(pSidNTAuthority);
    }
    
    int iPos = a_UserLogonName.Find( L'\\');

    // found backwhack: name is of the form domain\user
    if ( iPos != -1 )
    {
        a_DomainName = a_UserLogonName.Left ( iPos );

        // Win32_SystemAccount domain names are always the computer
        // name, never BUILTIN.  The string BUILTIN is not localized.
		CHString chstrBuiltIn;

        if (GetLocalizedBuiltInString(chstrBuiltIn) &&
			(a_DomainName.CompareNoCase(chstrBuiltIn) == 0))
        {
            a_DomainName = m_ComputerName;
        }

        if(a_DomainName.CompareNoCase(cstrAuthorityDomain) == 0)
        {
            a_DomainName = m_ComputerName;
        }

        a_UserLogonName = a_UserLogonName.Right ( a_UserLogonName.GetLength() - (iPos + 1) );
    }
    else
    {
        iPos = a_UserLogonName.Find( L'@');

        // found 'at' - name is of the form user@domain.somesuch.com
        if (iPos != -1)
        {
            // start by slicing off everything after the @
            a_DomainName = a_UserLogonName.Right(a_UserLogonName.GetLength() - (iPos + 1));
            
            // keep the user name portion before we step on iPos
            a_UserLogonName = a_UserLogonName.Left ( iPos );
            
            // now cut out everything after the first dot
            iPos = a_DomainName.Find(L'.');
            if (iPos != -1)
                a_DomainName = a_DomainName.Left(iPos);
        }
        else
            // else we have a local account
            a_DomainName = m_ComputerName;
    }
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::GetKeyValue
*
*  DESCRIPTION : From the object path we extract the key value
*
*****************************************************************************/
void CDiskQuota::GetKeyValue (

    CHString &a_VolumePath,
    LPCWSTR a_ObjectPath
)
{
    ParsedObjectPath *t_ObjPath;
    CObjectPathParser t_PathParser;
	a_VolumePath.Empty();

    if ( ( t_PathParser.Parse( a_ObjectPath, &t_ObjPath ) ) == CObjectPathParser::NoError )
    {
        try
        {
			if (t_ObjPath->m_dwNumKeys == 1)
			{
				if((V_VT(&t_ObjPath->m_paKeys [ 0 ]->m_vValue) == VT_BSTR) &&
					(t_ObjPath->m_paKeys [ 0 ]->m_vValue.bstrVal != NULL)
				)
				{
					a_VolumePath = t_ObjPath->m_paKeys [ 0 ]->m_vValue.bstrVal;
				}
			}
			else if (t_ObjPath->m_dwNumKeys == 2)
			{
				if ((V_VT(&t_ObjPath->m_paKeys [ 0 ]->m_vValue) == VT_BSTR) &&
					(V_VT(&t_ObjPath->m_paKeys [ 1 ]->m_vValue) == VT_BSTR) &&
					(t_ObjPath->m_paKeys [ 0 ]->m_vValue.bstrVal != NULL) &&
					(t_ObjPath->m_paKeys [ 1 ]->m_vValue.bstrVal != NULL)
				)
				{
					a_VolumePath.Format ( L"%s%s%s", t_ObjPath->m_paKeys [ 0 ]->m_vValue.bstrVal,
										L"\\", t_ObjPath->m_paKeys [ 1 ]->m_vValue.bstrVal );
				}

			}
        }
        catch ( ... )
        {
            t_PathParser.Free( t_ObjPath );
            throw;
        }
        t_PathParser.Free( t_ObjPath );
    }
}

BOOL CDiskQuota::GetDomainAndNameFromSid(
    PSID pSid,
    CHString& chstrDomain,
    CHString& chstrName)
{
    BOOL fRet = FALSE;
    
    // Initialize account name and domain name
	LPTSTR pszAccountName = NULL;
	LPTSTR pszDomainName = NULL;
	DWORD dwAccountNameSize = 0;
	DWORD dwDomainNameSize = 0;
    SID_NAME_USE snuAccountType;
	try
    {
		// This call should fail
		fRet = ::LookupAccountSid(NULL,
			pSid,
			pszAccountName,
			&dwAccountNameSize,
			pszDomainName,
			&dwDomainNameSize,
			&snuAccountType );

		if(fRet && (ERROR_INSUFFICIENT_BUFFER == ::GetLastError()))
		{
			// Allocate buffers
			if ( dwAccountNameSize != 0 )
            {
				pszAccountName = (LPTSTR) malloc( dwAccountNameSize * sizeof(TCHAR));
                if (pszAccountName == NULL)
                {
            		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }

			if ( dwDomainNameSize != 0 )
            {
				pszDomainName = (LPTSTR) malloc( dwDomainNameSize * sizeof(TCHAR));
                if (pszDomainName == NULL)
                {
            		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }

			// Make second call
			fRet = ::LookupAccountSid(
                NULL,
				pSid,
				pszAccountName,
				&dwAccountNameSize,
				pszDomainName,
				&dwDomainNameSize,
				&snuAccountType );

			if ( fRet == TRUE )
			{
				chstrName = pszAccountName;
				chstrDomain = pszDomainName;
			}

			if ( NULL != pszAccountName )
			{
				free ( pszAccountName );
                pszAccountName = NULL;
			}

			if ( NULL != pszDomainName )
			{
				free ( pszDomainName );
                pszDomainName = NULL;
			}

		}	// If ERROR_INSUFFICIENT_BUFFER
    } // try
    catch(...)
    {
        if ( NULL != pszAccountName )
		{
			free ( pszAccountName );
            pszAccountName = NULL;
		}

		if ( NULL != pszDomainName )
		{
			free ( pszDomainName );
            pszDomainName = NULL;
		}
        throw;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\inc\dfsreplica.h ===
/******************************************************************



   DFSReplica.H -- WMI provider class definition



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

   Description: Win32 Dfs Replica Provider
   
*******************************************************************/


#ifndef _CDFSREPLICA_H_
#define _CDFSREPLICA_H_

#define DFSREPLICA_ALL_PROPS				0xFFFFFFFF
#define DFSREPLICA_PROP_LinkName			0x00000001
#define DFSREPLICA_PROP_ServerName			0x00000002
#define DFSREPLICA_PROP_ShareName			0x00000004
#define DFSREPLICA_PROP_State				0x00000008

class CDfsReplica : public Provider 
{
private:

		HRESULT EnumerateAllReplicas ( MethodContext *pMethodContext, DWORD dwPropertiesReq );
		HRESULT LoadDfsReplica ( DWORD dwPropertiesReq, CInstance *pInstance, LPWSTR  lpLinkName, PDFS_STORAGE_INFO pRepBuf );
		HRESULT FindAndSetDfsReplica ( LPCWSTR a_EntryPath, LPCWSTR a_ServerName, LPCWSTR a_ShareName, 
						   DWORD dwPropertiesReq, CInstance *pInstance, DWORD eOperation, bool &bRoot );

        HRESULT GetKeys(const CInstance *pInstance, CHString &sKey1, CHString &sKey2, CHString &sKey3);

protected:

        HRESULT EnumerateInstances ( MethodContext *pMethodContext, long lFlags = 0L ) ;
        HRESULT GetObject ( CInstance *pInstance, long lFlags, CFrameworkQuery& Query ) ;
 
        HRESULT PutInstance ( const CInstance& Instance, long lFlags = 0L ) ;
        HRESULT DeleteInstance ( const CInstance& Instance, long lFlags = 0L ) ;

public:

        CDfsReplica ( LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace );
        virtual ~CDfsReplica () ;

private:

		CHString m_ComputerName;
		enum { eGet,eDelete,eAdd };

        enum DFS_REPLICA_STATE	{	DFS_REPLICA_STATE_UNASSIGNED = 0,
							DFS_REPLICA_STATE_ONLINE,
							DFS_REPLICA_STATE_OFFLINE,
							DFS_REPLICA_STATE_UNREACHABLE
						};
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\dll\precomp.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

#include <fwcommon.h>
#include <initguid.h>
#include <smartptr.h>
#include "DskQuotaCommon.h"
#include <dskquota.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\dll\usebinding.cpp ===
//=================================================================

//

// usebinding.cpp -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <binding.h>
#include <dskquotacommon.h>

CBinding MyVolumeQuotaSetting(
    IDS_VolumeQuotaSetting,
    NameSpace,
    IDS_DiskVolumeClass,
    IDS_LogicalDiskClass,
    IDS_Setting,
    IDS_LogicalDisk,
    IDS_Caption,
    IDS_DeviceID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\dll\quotasettings.cpp ===
/******************************************************************

   QuotaSettings.CPP -- WMI provider class implementation



   Description: Quota Settings class implementation. Quota settings

				are available only on those volumes that support 

				Disk Quotas. It is supported only on Win2k.

   

  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
  
******************************************************************/
#include "precomp.h"
#include "QuotaSettings.h"

CQuotaSettings MyQuotaSettings ( 

	IDS_DiskVolumeClass , 
	NameSpace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CQuotaSettings::CQuotaSettings
 *
 *  DESCRIPTION :   Constructor
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/
CQuotaSettings :: CQuotaSettings (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CQuotaSettings::~CQuotaSettings
 *
 *  DESCRIPTION :   Destructor
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CQuotaSettings :: ~CQuotaSettings ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/
HRESULT CQuotaSettings :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{
	HRESULT hRes =  WBEM_S_NO_ERROR;
	DWORD dwPropertiesReq;

	dwPropertiesReq = QUOTASETTINGS_ALL_PROPS;

	// This method enumerates all volumes on the 
	hRes = EnumerateAllVolumes ( pMethodContext, dwPropertiesReq );

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/
HRESULT CQuotaSettings :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_Key ; // VolumePath;

    if  ( pInstance->GetCHString ( IDS_VolumePath , t_Key ) == FALSE )
	{
		hRes = WBEM_E_FAILED ;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		// verify this logical drives actually exists
		CHString t_DriveStrings1;
		CHString t_DriveStrings2;
		
		LPWSTR lpDriveStrings = t_DriveStrings1.GetBuffer ( MAX_PATH + 1 );

		DWORD dwDLength = GetLogicalDriveStrings ( MAX_PATH, lpDriveStrings );

		if ( dwDLength > MAX_PATH )
		{
			lpDriveStrings = t_DriveStrings2.GetBuffer ( dwDLength + 1 );
			dwDLength = GetLogicalDriveStrings ( dwDLength, lpDriveStrings );
		}	

		hRes = m_CommonRoutine.SearchLogicalDisk ( t_Key.GetAt ( 0 ) , lpDriveStrings );
		if ( hRes == WBEM_E_NOT_FOUND)
		{
			// 
			// I need to assume that VolumePath property already contains
			// volume path rather than logical disk drive
			//

			CHString t_VolumeName;

			hRes = m_CommonRoutine.VolumeSupportsDiskQuota ( t_Key,  t_VolumeName );
			if ( SUCCEEDED ( hRes ) )
			{
				DWORD dwPropertiesReq;

				if ( Query.AllPropertiesAreRequired() )
				{
					dwPropertiesReq = QUOTASETTINGS_ALL_PROPS;
				}
				else
				{
					SetRequiredProperties ( &Query, dwPropertiesReq );
				}
				// put the instance with the requested properties only as in Query.
				// Get the Properties of the requested volume
				hRes = LoadDiskQuotaVolumeProperties ( t_Key, L"", dwPropertiesReq, pInstance );
			}
		}
		else
		{
			if ( SUCCEEDED ( hRes ) )
			{
				WCHAR t_VolumePathName[MAX_PATH + 1];

				if ( GetVolumeNameForVolumeMountPoint(
								t_Key,
								t_VolumePathName,
								MAX_PATH
							) )
				{
					CHString t_VolumeName;

					hRes = m_CommonRoutine.VolumeSupportsDiskQuota ( t_VolumePathName,  t_VolumeName );
					{
						DWORD dwPropertiesReq;

						if ( Query.AllPropertiesAreRequired() )
						{
							dwPropertiesReq = QUOTASETTINGS_ALL_PROPS;
						}
						else
						{
							SetRequiredProperties ( &Query, dwPropertiesReq );
						}
						// put the instance with the requested properties only as in Query.
						// Get the Properties of the requested volume
						hRes = LoadDiskQuotaVolumeProperties ( t_VolumePathName, t_Key, dwPropertiesReq, pInstance );
					}
				}
			}
		}
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings::ExecQuery
*
*  DESCRIPTION :    Optimization of Queries involving only the key attribute 
*				    is supported.
*
*****************************************************************************/
HRESULT CQuotaSettings :: ExecQuery ( 

	MethodContext *pMethodContext, 
	CFrameworkQuery &Query, 
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD dwPropertiesReq;
	CHStringArray t_Values;

	hRes = Query.GetValuesForProp(
			 IDS_VolumePath,
			 t_Values
		   );

	if ( t_Values.GetSize() == 0 )
    {
	    hRes = Query.GetValuesForProp(
			     IDS_Caption,
			     t_Values
		       );

        if (SUCCEEDED(hRes))
        {
            DWORD dwSize = t_Values.GetSize();
            for (DWORD x = 0; x < dwSize; x++)
            {
                t_Values[x] += L'\\';
            }
        }
    }

	if ( Query.AllPropertiesAreRequired() )
	{
		dwPropertiesReq = QUOTASETTINGS_ALL_PROPS;
	}
	else
	{
		SetRequiredProperties ( &Query, dwPropertiesReq );
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( t_Values.GetSize() == 0 )
		{
			// This method is called when there is no where clause just to filter 
			// the required properties
			hRes = EnumerateAllVolumes ( pMethodContext, dwPropertiesReq );
		}
		else
		{
			// Only Volume in VolumePath properties are needed to be enumerated
			WCHAR t_VolumePathName[MAX_PATH + 1];
            CHString t_VolumeName;

			int iSize = t_Values.GetSize ();

			for ( int i = 0; i < iSize; i++ )
			{
				if ( GetVolumeNameForVolumeMountPoint(
								t_Values[i],
								t_VolumePathName,
								MAX_PATH ) )
				{
					hRes = m_CommonRoutine.VolumeSupportsDiskQuota ( t_VolumePathName,  t_VolumeName );
					if ( SUCCEEDED ( hRes ) )
					{
						// Get and Set the Properties of the requested volume
						hRes = PutVolumeDetails ( t_VolumePathName, 
														   pMethodContext, 
														   dwPropertiesReq );
					}		
				}
			}
		}
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CQuotaSettings::PutInstance
*
*  DESCRIPTION :    PutInstance should be used in provider classes that can 
*                   write instance information back to the hardware or 
*                   software.  For example: Win32_Environment will allow a 
*                   PutInstance to create or update an environment variable.  
*                   However, a class like MotherboardDevice will not allow 
*                   editing of the number of slots, since it is difficult for 
*                   a provider to affect that number.
*
*****************************************************************************/

HRESULT CQuotaSettings :: PutInstance  (

	const CInstance &Instance, 
	long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR ;
	CHString t_Key;
	
	if ( Instance.GetCHString ( IDS_VolumePath , t_Key ) == FALSE )
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		WCHAR t_VolumePathName[MAX_PATH + 1];

		if ( GetVolumeNameForVolumeMountPoint(
						t_Key,
						t_VolumePathName,
						MAX_PATH ) )
		{
			// Only changing certain properties of volumes is allowed and not adding a new DIskQuota Volume.
			// Hence creating a new instance is not supported, but changing instance properties is supported.
			switch ( lFlags & 3)
			{
				case WBEM_FLAG_CREATE_OR_UPDATE:
				case WBEM_FLAG_UPDATE_ONLY:
				{
					hRes = CheckParameters ( Instance);
					if ( SUCCEEDED ( hRes ) )
					{
                        CHString t_VolumePathName2;
						hRes = m_CommonRoutine.VolumeSupportsDiskQuota ( t_Key,  t_VolumePathName2 );
						if ( SUCCEEDED ( hRes ) )
						{
							// Get the QuotaInterface Pointer
							IDiskQuotaControlPtr pIQuotaControl = NULL;

							if (  SUCCEEDED ( CoCreateInstance(
												CLSID_DiskQuotaControl,
												NULL,
												CLSCTX_INPROC_SERVER,
												IID_IDiskQuotaControl,
												(void **)&pIQuotaControl ) ) )
							{
								hRes = m_CommonRoutine.InitializeInterfacePointer (  pIQuotaControl, t_Key );
								if ( SUCCEEDED ( hRes ) )
								{
									hRes = SetDiskQuotaVolumeProperties ( Instance,  pIQuotaControl );
								}
							}
							else
							{
								hRes = WBEM_E_FAILED;
							}
						}
					}

					break ;
				}
				default:
				{
					hRes = WBEM_E_PROVIDER_NOT_CAPABLE ;
				}
				break ;
			}
		}
		else
		{
			hRes = WBEM_E_NOT_FOUND;
		}
	}
    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings:: EnumerateAllVolumes
*
*  DESCRIPTION :    This method Enumerates all the volumes by making use of Disk
*                   Quotas Interfaces, gets all the required properties and deliveres
*                   the instances to WMI, which will be postfiltered by WMI
*                   
*****************************************************************************/
HRESULT CQuotaSettings :: EnumerateAllVolumes (

	MethodContext *pMethodContext,
	DWORD &a_PropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	BOOL bNextVol = TRUE;
	WCHAR t_VolumeName[MAX_PATH + 1];
	
	// Initializing and getting the first volume on the computer
	SmartCloseVolumeHandle hVol;

	hVol =  FindFirstVolume(
				t_VolumeName,
				MAX_PATH    // size of output buffer
			);

	if ( hVol  != INVALID_HANDLE_VALUE )
	{
		while ( bNextVol )
		{
			hRes = PutVolumeDetails ( t_VolumeName, pMethodContext, a_PropertiesReq );
			// Continue for next volume, even if the retval for this volume is false;
			bNextVol =  FindNextVolume(
						 hVol,										// volume search handle
						 t_VolumeName,   // output buffer
						 MAX_PATH									// size of output buffer
					);
			if ( bNextVol == FALSE )
				break;
		}
	}
	else
		hRes = WBEM_E_FAILED;

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings:: LoadDiskQuotaVolumeProperties
*
*  DESCRIPTION :    This method checks if the volume enumerated supports Disk Quotas
*                   If the Volume Supposrts DIskQuotas, it fills up all the properties
*                   of the volume and returns otherwise it just returns FALSE
*                   indicating properties of this volume were not filled. and hence
*					intsnace should not be delivered to WMI
*
*****************************************************************************/
HRESULT CQuotaSettings :: LoadDiskQuotaVolumeProperties ( 
													 
	LPCWSTR a_VolumeName, 
    LPCWSTR a_Caption,
	DWORD dwPropertiesReq,
	CInstancePtr pInstance
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD dwLogFlags;
	DWORD dwQuotaState;
	CHString t_Temp;

	// checks to see if the volume supports Disk Quotas
	hRes =  m_CommonRoutine.VolumeSupportsDiskQuota ( a_VolumeName,  t_Temp );
	if ( SUCCEEDED ( hRes ) )
	{
		if ( ( dwPropertiesReq & QUOTASETTINGS_PROP_Caption ) )
		{
            t_Temp = a_Caption;
            pInstance->SetCHString(IDS_Caption, t_Temp.Left(2));
        }

		IDiskQuotaControlPtr pIQuotaControl;

		if (  SUCCEEDED ( CoCreateInstance(
							CLSID_DiskQuotaControl,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_IDiskQuotaControl,
							(void **)&pIQuotaControl ) ) )
		{
			// Initializing the QuotaCOntrol Interface pointer for this Volume
			hRes = m_CommonRoutine.InitializeInterfacePointer (  pIQuotaControl, a_VolumeName );
			if ( SUCCEEDED ( hRes ) )
			{
				// Get all the Volume Properties
				LONGLONG lQuotaLimit = 0;
				if ( ( dwPropertiesReq & QUOTASETTINGS_PROP_DefaultLimit ) )
				{
					if ( SUCCEEDED ( pIQuotaControl->GetDefaultQuotaLimit( &lQuotaLimit ) ) )
					{
						if ( pInstance->SetWBEMINT64 ( IDS_QuotasDefaultLimit, (ULONGLONG)lQuotaLimit ) == FALSE )
						{
							hRes = WBEM_E_FAILED;
						}
					}
					else
					{
						hRes = WBEM_E_FAILED;
					}
				}

				if ( ( dwPropertiesReq & QUOTASETTINGS_PROP_DefaultWarningLimit )  )
				{
					if ( SUCCEEDED ( pIQuotaControl->GetDefaultQuotaThreshold ( &lQuotaLimit ) ) )
					{
						if ( pInstance->SetWBEMINT64 ( IDS_QuotasDefaultWarningLimit, (ULONGLONG)lQuotaLimit ) == FALSE )
						{
							hRes = WBEM_E_FAILED;
						}
					}
					else
					{
						hRes = WBEM_E_FAILED;
					}
				}

				if ( ( ( dwPropertiesReq & QUOTASETTINGS_PROP_QuotaExceededNotification ) ) 
						|| ( ( dwPropertiesReq & QUOTASETTINGS_PROP_WarningExceededNotification ) ) )
						
				{
					if ( SUCCEEDED ( pIQuotaControl->GetQuotaLogFlags( &dwLogFlags ) ) )
					{
						if ( ( dwPropertiesReq & QUOTASETTINGS_PROP_QuotaExceededNotification ) )
						{
							if ( pInstance->Setbool ( IDS_QuotaExceededNotification, DISKQUOTA_IS_LOGGED_USER_LIMIT ( dwLogFlags ) ) == FALSE )
							{
								hRes = WBEM_E_FAILED;
							}
						}

						if ( ( dwPropertiesReq & QUOTASETTINGS_PROP_WarningExceededNotification ) )
						{
							if ( pInstance->Setbool ( IDS_QuotasWarningExceededNotification, DISKQUOTA_IS_LOGGED_USER_THRESHOLD ( dwLogFlags) ) == FALSE )
							{
								hRes = WBEM_E_FAILED;
							}
						}				
					}
					else
					{
						hRes = WBEM_E_FAILED;
					}
				}

				if  ( ( dwPropertiesReq & QUOTASETTINGS_PROP_State ) ) 
				{
					if ( SUCCEEDED (pIQuotaControl->GetQuotaState( &dwQuotaState ) ) )
					{
						DWORD State = 0;

						if  ( DISKQUOTA_IS_DISABLED ( dwQuotaState ) )
							State = 0;
						else
						if  ( DISKQUOTA_IS_ENFORCED ( dwQuotaState)  )
							State = 2;
						else
						if  ( DISKQUOTA_IS_TRACKED ( dwQuotaState)  )
							State = 1;

						pInstance->SetDWORD ( IDS_QuotaState, State );
						
					}
					else
					{
						hRes = WBEM_E_FAILED;
					}
				}
			}
		}
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings:: SetDiskQuotaVolumeProperties
*
*  DESCRIPTION :    This method Sets the DskQuota Volume Properties
*
*****************************************************************************/
HRESULT CQuotaSettings :: SetDiskQuotaVolumeProperties ( 
													  
	const CInstance &Instance,
	IDiskQuotaControlPtr pIQuotaControl
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD dwLogFlags = 0;
	DWORD dwQuotaState = 0;
	bool bExceededNotn = false;
	bool bWarningNotn = false;
	DWORD dwState = 0;
	UINT64 ullDefaultLimit = 0;
	UINT64 ullWarningLimit = 0;
	bool bSetState = false;

	if (Instance.Getbool ( IDS_QuotaExceededNotification, bExceededNotn ))
	{
		if ( bExceededNotn )
			DISKQUOTA_SET_LOG_USER_LIMIT ( dwLogFlags, TRUE );
		else
			DISKQUOTA_SET_LOG_USER_LIMIT ( dwLogFlags, FALSE );

		bSetState = true;
	}

	if (Instance.Getbool ( IDS_QuotasWarningExceededNotification, bWarningNotn ))
	{
		if ( bWarningNotn )
			DISKQUOTA_SET_LOG_USER_THRESHOLD ( dwLogFlags, TRUE );
		else
			DISKQUOTA_SET_LOG_USER_THRESHOLD ( dwLogFlags, FALSE );

		bSetState = true;
	}

	if (bSetState)
	{
		if ( FAILED ( pIQuotaControl->SetQuotaLogFlags ( dwLogFlags ) ) )
		{
			hRes = WBEM_E_FAILED;
		}
	}

	if (Instance.GetWBEMINT64 ( IDS_QuotasDefaultLimit, ullDefaultLimit ))
	{
		if ( FAILED ( pIQuotaControl->SetDefaultQuotaLimit ( ullDefaultLimit ) ) )
		{
			hRes = WBEM_E_FAILED;
		}
	}

	if (Instance.GetWBEMINT64 ( IDS_QuotasDefaultWarningLimit, ullWarningLimit ))
	{
		if ( FAILED ( pIQuotaControl->SetDefaultQuotaThreshold ( ullWarningLimit ) ) )
		{
			hRes = WBEM_E_FAILED;
		}
	}

	if (Instance.GetDWORD ( IDS_QuotaState, dwState ))
	{
		if ( dwState == 0 )
			DISKQUOTA_SET_DISABLED ( dwQuotaState );
		
		if ( dwState == 1 )
			DISKQUOTA_SET_TRACKED ( dwQuotaState );

		if ( dwState == 2 )
			DISKQUOTA_SET_ENFORCED ( dwQuotaState );

		if ( FAILED ( pIQuotaControl->SetQuotaState( dwQuotaState ) ) )
		{
			hRes = WBEM_E_FAILED;
		}
	}

	return hRes;
}


/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings:: CheckParameters
*
*  DESCRIPTION :    Checks for the validity of the input parameters while 
*					Updating an instance
*
*****************************************************************************/
HRESULT CQuotaSettings :: CheckParameters ( 

	const CInstance &a_Instance
)
{
	// Getall the Properties from the Instance to Verify
	HRESULT hRes = WBEM_S_NO_ERROR ;
	bool t_Exists ;
	VARTYPE t_Type ;

	if ( a_Instance.GetStatus ( IDS_QuotaState, t_Exists , t_Type ) )
	{
		DWORD t_State;
		if ( t_Exists && ( t_Type == VT_I4 ) )
		{
			if ( a_Instance.GetDWORD ( IDS_QuotaState , t_State ) )
			{
				if ( ( t_State != 1 )  && ( t_State != 0 ) && ( t_State != 2 ))
				{
					hRes = WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
				hRes = WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( a_Instance.GetStatus ( IDS_QuotaExceededNotification, t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BOOL ) )
		{
			bool bQuotaState;

			if ( a_Instance.Getbool ( IDS_QuotaExceededNotification , bQuotaState ) == false )
			{
				hRes = WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( a_Instance.GetStatus ( IDS_QuotasWarningExceededNotification, t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BOOL ) )
		{
			bool bQuotaState;

			if ( a_Instance.Getbool ( IDS_QuotasWarningExceededNotification , bQuotaState ) == false )
			{
				hRes = WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( a_Instance.GetStatus ( IDS_QuotasDefaultLimit, t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			LONGLONG lDefaultLimit;
			if ( a_Instance.GetWBEMINT64 ( IDS_QuotasDefaultLimit , lDefaultLimit ) == FALSE )
			{
				hRes = WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( a_Instance.GetStatus ( IDS_QuotasDefaultWarningLimit, t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			LONGLONG lDefaultWarningLimit;

			if ( a_Instance.GetWBEMINT64 ( IDS_QuotasDefaultWarningLimit , lDefaultWarningLimit ) == FALSE  )
			{
				hRes = WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}
	return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings:: SetRequiredProperties
*
*  DESCRIPTION :    This method sets the required properties for the instances 
*					requested by the user
*
*****************************************************************************/
void CQuotaSettings :: SetRequiredProperties ( 
	
	CFrameworkQuery *Query,
	DWORD &a_PropertiesReq
)
{
	a_PropertiesReq = 0;

	if ( Query->IsPropertyRequired ( IDS_VolumePath ) )
		a_PropertiesReq |= QUOTASETTINGS_PROP_VolumePath;

	if ( Query->IsPropertyRequired ( IDS_QuotasDefaultLimit ) )
		a_PropertiesReq |= QUOTASETTINGS_PROP_DefaultLimit;

	if ( Query->IsPropertyRequired ( IDS_Caption ) )
		a_PropertiesReq |= QUOTASETTINGS_PROP_Caption;

	if ( Query->IsPropertyRequired ( IDS_QuotasDefaultWarningLimit ) )
		a_PropertiesReq |= QUOTASETTINGS_PROP_DefaultWarningLimit;

	if ( Query->IsPropertyRequired ( IDS_QuotaExceededNotification ) )
		a_PropertiesReq |= QUOTASETTINGS_PROP_QuotaExceededNotification;

	if ( Query->IsPropertyRequired ( IDS_QuotasWarningExceededNotification ) )
		a_PropertiesReq |= QUOTASETTINGS_PROP_WarningExceededNotification;

	if ( Query->IsPropertyRequired ( IDS_QuotaState ) )
		a_PropertiesReq |= QUOTASETTINGS_PROP_State;

}

/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings:: PutVolumeDetails
*
*  DESCRIPTION :    Putting the volume properties
*
*****************************************************************************/
HRESULT CQuotaSettings :: PutVolumeDetails ( 
										 
	LPCWSTR a_VolumeName, 
	MethodContext *pMethodContext, 
	DWORD a_PropertiesReq 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	CHString t_DriveName ;
	// verify this logical drives actually exists
	CHString t_DriveStrings1;
	CHString t_DriveStrings2;

	LPWSTR lpDriveStrings = t_DriveStrings1.GetBuffer ( MAX_PATH + 1 );
	DWORD dwDLength = GetLogicalDriveStrings ( MAX_PATH, lpDriveStrings );
	if ( dwDLength > MAX_PATH )
	{
		lpDriveStrings = t_DriveStrings2.GetBuffer ( dwDLength + 1 );
		dwDLength = GetLogicalDriveStrings ( dwDLength, lpDriveStrings );
	}

	CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;

	m_CommonRoutine.GetVolumeDrive ( a_VolumeName, lpDriveStrings, t_DriveName );

	hRes = LoadDiskQuotaVolumeProperties ( a_VolumeName,  t_DriveName, a_PropertiesReq, pInstance );
	if ( SUCCEEDED ( hRes ) )
	{

		if ( ( a_PropertiesReq & QUOTASETTINGS_PROP_VolumePath ) )
		{
			if ( t_DriveName.IsEmpty() )
			{
				if ( pInstance->SetCHString ( IDS_VolumePath, a_VolumeName ) == FALSE )
				{
					hRes = WBEM_E_FAILED;
				}
			}
			else
			{
				if ( pInstance->SetCHString ( IDS_VolumePath, t_DriveName ) == FALSE )
				{
					hRes = WBEM_E_FAILED;
				}
			}
		}	
			
		if ( FAILED ( pInstance->Commit() ) )
		{
			hRes = WBEM_E_FAILED;
		}		
	}
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\dll\dskquotacommon.cpp ===
/******************************************************************

   DskCommonRoutines.CPP -- 



   Description: Common routines that are used by all the three 

				classes of Disk Quota Provider

   

  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
  
******************************************************************/
#include "precomp.h"
#include "DskQuotaCommon.h"

/*****************************************************************************
*
*  FUNCTION    :    DskCommonRoutines:: GetVolume
*
*  DESCRIPTION :    This method Parses the key and gets the Volume from
*					the Object Path. The input of this method could be 
*					Logical Disk key which is on the form "D:" or could 
*					receive volume Path which is in the form "D:\"
*                   
*****************************************************************************/
HRESULT DskCommonRoutines::GetVolume ( 
									   
	LPCWSTR a_Key, 
	WCHAR &a_Drive
)
{
	HRESULT hRes = WBEM_E_INVALID_PARAMETER;
	CObjectPathParser t_PathParser;
	ParsedObjectPath  *t_ObjPath = NULL;

    if ( t_PathParser.Parse( a_Key, &t_ObjPath )  == t_PathParser.NoError )
	{
		try
		{
			CHString t_KeyString = t_ObjPath->GetKeyString();	
			// checking for the validity of the path
			if ( ( t_KeyString.GetLength() == 3 )  || (t_KeyString.GetLength() == 2 ) )
			{
				if ( (( t_KeyString.GetAt(0) >= L'A') && ( t_KeyString.GetAt(0) <= L'Z')) || (( t_KeyString.GetAt(0) >= L'a') && ( t_KeyString.GetAt(0) <= L'z') ) )	
				{
					if ( t_KeyString.GetAt(1)  == L':' ) 
					{
						if ( t_KeyString.GetLength() == 3 )
						{
							if ( t_KeyString.GetAt(2)  == L'\\' )
							{
								hRes = WBEM_S_NO_ERROR;
							}
						}
						else
						{
							hRes = WBEM_S_NO_ERROR;
						}
						a_Drive = t_KeyString.GetAt(0);
					}
				}
			}
		}
		catch ( ... )
		{
			t_PathParser.Free ( t_ObjPath );
			throw;
		}
		t_PathParser.Free ( t_ObjPath );
	}						
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    DskCommonRoutines:: SearchLogicalDisk
*
*  DESCRIPTION :    This method Searches whether a given Logical disks exists
*					in the logicaldisks strings of the system
*                   
*****************************************************************************/
HRESULT DskCommonRoutines::SearchLogicalDisk ( 
											  
	WCHAR a_Drive, 
	LPCWSTR a_DriveStrings 
)
{
	int iLen = 0;
	LPCWSTR lpTempDriveString = a_DriveStrings;
	HRESULT hRes = WBEM_S_NO_ERROR;
    a_Drive = (WCHAR)toupper(a_Drive);

	while ( true )
	{
		iLen = lstrlen ( lpTempDriveString );
		if ( iLen == 0 )
		{
			hRes = WBEM_E_NOT_FOUND;
			break;
		}

		if ( lpTempDriveString [ 0 ] == a_Drive )
			break;

		lpTempDriveString = &lpTempDriveString [ iLen + 1 ]; 		
	}
	
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    DskCommonRoutines:: GetVolumeDrive
*
*  DESCRIPTION :    Gets the Volume Drive from the Given Path
*                   
*****************************************************************************/
void DskCommonRoutines::GetVolumeDrive ( 
				
	LPCWSTR a_VolumePath, 
	LPCWSTR a_DriveStrings,
	CHString &a_DriveName
)
{
	int iLen = 0;
    WCHAR w_Drive[ 4 ];
	LPCWSTR lpTempDriveString = a_DriveStrings;
	WCHAR t_TempVolumeName [ MAX_PATH + 1 ];

	while ( true )
	{
		iLen = lstrlen ( lpTempDriveString );
		if ( iLen == 0 )
			break;

		lstrcpy ( w_Drive, lpTempDriveString );

		BOOL bVol = GetVolumeNameForVolumeMountPoint(
						w_Drive,
						t_TempVolumeName,
						MAX_PATH
					);

		if ( lstrcmp ( t_TempVolumeName, a_VolumePath ) == 0 )
		{
			a_DriveName = w_Drive;
			break;
		}
		
		lpTempDriveString = &lpTempDriveString [ iLen + 1 ]; 	
	}
}

/*****************************************************************************
*
*  FUNCTION    :    DskCommonRoutines:: InitializeInterfacePointer
*
*  DESCRIPTION :    This method Initializes the DiskQuotaInterface pointer for a 
*					given volume
*                   
*****************************************************************************/

HRESULT DskCommonRoutines::InitializeInterfacePointer ( 

	IDiskQuotaControl* pIQuotaControl, 
	LPCWSTR a_VolumeName 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	BOOL bRetVal = TRUE;

	WCHAR w_VolumePathName [ MAX_PATH + 1 ];

	bRetVal = GetVolumePathName(
							a_VolumeName,           // file path
							w_VolumePathName,     // volume mount point
							MAX_PATH		  // Size of the Buffer
					 );
	if ( bRetVal )
	{
		if ( FAILED ( pIQuotaControl->Initialize (  w_VolumePathName, TRUE ) ) )
		{
			hRes = WBEM_E_FAILED;
		}
	}
	return hRes;
}


/*****************************************************************************
*
*  FUNCTION    :    DskCommonRoutines:: VolumeSupportsDiskQuota
*
*  DESCRIPTION :    This method checks if the volume supports Disk Quotas, 
*
*****************************************************************************/
HRESULT DskCommonRoutines::VolumeSupportsDiskQuota ( 
												 
	LPCWSTR a_VolumeName,  
	CHString &a_QuotaVolumeName 
)
{
	// Get the name of the Volume Name Property
	LPWSTR  t_VolumeNameBuffer = a_QuotaVolumeName.GetBuffer(MAX_PATH + 1);
	DWORD dwMaximumComponentLength = 0;
	DWORD dwFileSystemFlags = 0;
	HRESULT hRes = WBEM_S_NO_ERROR;

	BOOL bRetVal =  GetVolumeInformation(
						 a_VolumeName,				// root directory
						 t_VolumeNameBuffer,        // volume name buffer
						 MAX_PATH,            // length of name buffer
						 NULL,					// volume serial number
						 &dwMaximumComponentLength, // maximum file name length
						 &dwFileSystemFlags,        // file system options
						 NULL,					// file system name buffer
						 0					 // length of file system name buffer
					);

	if ( ( bRetVal ) && ( ( dwFileSystemFlags & FILE_VOLUME_QUOTAS) == FILE_VOLUME_QUOTAS ))
	{
		a_QuotaVolumeName = t_VolumeNameBuffer;
	}
	else
	{
		hRes = WBEM_E_NOT_FOUND;
	}

    a_QuotaVolumeName.ReleaseBuffer();

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    DskCommonRoutines:: MakeObjectPath
*
*  DESCRIPTION :    This method Adds a keyvalue for a given key property
*					into the Object Path and gives the Object Path
*                   
*****************************************************************************/
void DskCommonRoutines::MakeObjectPath (
										   
	 LPWSTR &a_ObjPathString,  
	 LPWSTR a_ClassName, 
	 LPCWSTR a_AttributeName, 
	 LPCWSTR  a_AttributeVal 
)
{
	ParsedObjectPath t_ObjPath;
	variant_t t_Path(a_AttributeVal);

	t_ObjPath.SetClassName ( a_ClassName );
	t_ObjPath.AddKeyRef ( a_AttributeName, &t_Path );

	CObjectPathParser t_PathParser;

	if ( t_PathParser.Unparse( &t_ObjPath, &a_ObjPathString  ) != t_PathParser.NoError )
	{
		a_ObjPathString = NULL;
	}
}

/*****************************************************************************
*
*  FUNCTION    :    DskCommonRoutines:: AddToObjectPath
*
*  DESCRIPTION :    This method Adds a keyvalue for a given key property
*					into the existing Object Path.
*                   
*****************************************************************************/
void DskCommonRoutines::AddToObjectPath ( 

	 LPWSTR &a_ObjPathString,  
	 LPCWSTR a_AttributeName, 
	 LPCWSTR  a_AttributeVal 
)
{
	CObjectPathParser t_PathParser;
	ParsedObjectPath *t_ObjPath;

    if (  t_PathParser.Parse( a_ObjPathString, &t_ObjPath ) ==  t_PathParser.NoError )
	{
		try
		{

			variant_t t_Path(a_AttributeVal);
			t_ObjPath->AddKeyRef ( a_AttributeName, &t_Path );
			LPWSTR t_ObjPathString = NULL;
			delete [] a_ObjPathString;
			a_ObjPathString = NULL;

			if ( t_PathParser.Unparse( t_ObjPath, &t_ObjPathString ) != t_PathParser.NoError )
			{
				a_ObjPathString = NULL;
			}
			else
			{
				a_ObjPathString = t_ObjPathString;
			}
		}
		catch ( ... )
		{
			t_PathParser.Free (t_ObjPath);
			throw;
		}
		t_PathParser.Free (t_ObjPath);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\dll\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

//

//  Module: WMI Framework Instance provider

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <dllunreg.h>
#include <DllCommon.h>
#include <brodcast.h>

#include "FactoryRouter.h"
#include "ResourceManager.h"
#include "timerqueue.h"


HMODULE ghModule ;

// {4AF3F4A4-06C8-4b79-A523-633CC65CE297}
DEFINE_GUID(CLSID_DISKQUOTAVOLUME,
0x4af3f4a4, 0x6c8, 0x4b79, 0xa5, 0x23, 0x63, 0x3c, 0xc6, 0x5c, 0xe2, 0x97);

#define PROVIDER_NAME L"WMIPDSKQ"

// Globals from using ciwin32 library
CFactoryRouterData     g_FactoryRouterData;
CTimerQueue CTimerQueue :: s_TimerQueue ;
CResourceManager CResourceManager::sm_TheResourceManager ;


//Count number of objects and number of locks.
long g_cLock = 0 ;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;
    
    try
    {
        if ( CLSID_DISKQUOTAVOLUME == rclsid )
        {
            hr = CommonGetClassObject(riid, ppv, PROVIDER_NAME, g_cLock);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    catch ( ... )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
    SCODE sc = S_FALSE;

    try
    {
        sc = CommonCanUnloadNow(PROVIDER_NAME, g_cLock);
    }
    catch ( ... )
    {
        // sc should already be set correctly
    }

    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = RegisterServer( _T("WBEM Disk Quota Volume Provider"), CLSID_DISKQUOTAVOLUME ) ;
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status ;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = UnregisterServer( CLSID_DISKQUOTAVOLUME ) ;
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status;
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are
//          initialized and terminated, or upon calls to the LoadLibrary
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain( HINSTANCE hInstDLL,  // handle to DLL module
                       DWORD fdwReason,     // reason for calling function
                       LPVOID lpReserved )  // reserved
{
    BOOL bRet = TRUE;

    try
    {
		LogMessage2( L"%s  -> DllMain", PROVIDER_NAME);

		// Perform actions based on the reason for calling.
		switch( fdwReason )
		{
			case DLL_PROCESS_ATTACH:
			{
				bRet = CommonProcessAttach(PROVIDER_NAME, g_cLock, hInstDLL);
			}
			break;

			case DLL_THREAD_ATTACH:
			{
			 // Do thread-specific initialization.
			}
			break;

			case DLL_THREAD_DETACH:
			{
			 // Do thread-specific cleanup.
			}
			break;

			case DLL_PROCESS_DETACH:
			{
					// Perform any necessary cleanup.
					LogMessage( L"DLL_PROCESS_DETACH" );
			}
			break;
		}
    }
    catch ( ... )
    {
		bRet = FALSE;
    }

    return bRet ;  // Status of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\inc\dfsjnptreplicaasso.h ===
/******************************************************************



   DssJnPtReplica.H -- WMI provider class definition



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

*******************************************************************/

#ifndef _CDFSJNPTREPLICA_H_
#define _CDFSJNPTREPLICA_H_

#define DFSLINKNAME							L"Dependent"
#define REPLICANAME							L"Antecedent"

class CDfsJnPtReplica : public Provider 
{
private:
	HRESULT EnumerateAllDfsJnPtReplicas ( MethodContext *pMethodContext );
	HRESULT FindDfsJnPtReplica ( LPWSTR lpEntryPath, LPWSTR lpServerName, LPWSTR lpShareName );
	void MakeObjectPath ( LPWSTR lpReplicaName, LPWSTR lpServerName, LPWSTR lpShareName, LPWSTR &lpJnPtReplicaObject );

protected:

    HRESULT EnumerateInstances ( MethodContext *pMethodContext, long lFlags = 0L ) ;
    HRESULT GetObject ( CInstance *pInstance, long lFlags, CFrameworkQuery &Query ) ;

public:

    CDfsJnPtReplica ( LPCWSTR lpwszClassName,  LPCWSTR lpwszNameSpace ) ;
    virtual ~CDfsJnPtReplica () ;

private:

	CHString m_ComputerName;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\inc\quotasettings.h ===
/******************************************************************

   QuotaSettings.H -- WMI provider class definition



   Description: Quota Settings Provider for the volumes that Supports

                Disk Quotas,  class Definition

 

  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
  
******************************************************************/

#ifndef  _CQUOTASETTINGS_H_
#define  _CQUOTASETTINGS_H_

// Defining bit values for the property, which will be used for defining the bitmap of properties required.
#define QUOTASETTINGS_ALL_PROPS								0xFFFFFFFF
#define QUOTASETTINGS_PROP_VolumePath						0x00000001
#define QUOTASETTINGS_PROP_State							0x00000002
#define QUOTASETTINGS_PROP_DefaultLimit						0x00000004
#define QUOTASETTINGS_PROP_DefaultWarningLimit				0x00000008
#define QUOTASETTINGS_PROP_QuotaExceededNotification		0x00000010
#define QUOTASETTINGS_PROP_WarningExceededNotification		0x00000020
#define QUOTASETTINGS_PROP_Caption                  		0x00000040

class CQuotaSettings : public Provider 
{
private:

	HRESULT EnumerateAllVolumes ( 

		MethodContext *pMethodContext,
		DWORD &PropertiesReq
	);

	HRESULT LoadDiskQuotaVolumeProperties ( 
		
		LPCWSTR a_VolumeName, 
        LPCWSTR a_Caption,
		DWORD dwPropertiesReq,
		CInstancePtr pInstance
	);
	
	HRESULT SetDiskQuotaVolumeProperties ( 
		
		const CInstance &Instance,
		IDiskQuotaControlPtr pIQuotaControl
	);

	HRESULT CheckParameters ( 

		const CInstance &a_Instance
	);

	void SetRequiredProperties ( 
		
		CFrameworkQuery *Query,
		DWORD &dwPropertiesReq
	);

	HRESULT PutVolumeDetails ( 
		
		LPCWSTR a_VolumeName, 
		MethodContext *pMethodContext, 
		DWORD dwPropertiesReq 
	);

protected:

        // Reading Functions
        //============================
        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
			CFrameworkQuery &Query
		) ;

        HRESULT ExecQuery ( 

			MethodContext *pMethodContext, 
			CFrameworkQuery& Query, 
			long lFlags = 0
		) ;

        // Writing Functions
        //============================
        HRESULT PutInstance (

			const CInstance& Instance, 
			long lFlags = 0L
		) ;
public:

        // Constructor/destructor
        //=======================
        CQuotaSettings (

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CQuotaSettings () ;

private:
	DskCommonRoutines   m_CommonRoutine;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\inc\volumequotasetting.h ===
/******************************************************************

   VolumeQuotaSettings.CPP -- WMI provider class Definition



   Description: 

   

  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
  
******************************************************************/


#ifndef  _CVOLUME_QUOTA_SETTINGS_H
#define  _CVOLUME_QUOTA_SETTINGS_H

#include "precomp.h"
#include  "DskQuotaCommon.h"

class CVolumeQuotaSetting : public Provider 
{
private:
	HRESULT EnumerateAllVolumeQuotas ( 
				
		MethodContext *pMethodContext
	);

	HRESULT PutNewInstance ( 
										  
		LPWSTR lpDeviceId, 
		LPWSTR lpVolumePath,
		MethodContext *pMethodContext
	);
	
protected:
        // Reading Functions
        //============================
        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
			CFrameworkQuery &Query
		) ;

        HRESULT ExecQuery ( 

			MethodContext *pMethodContext, 
			CFrameworkQuery& Query, 
			long lFlags = 0
		) ;
public:
        // Constructor/destructor
        //=======================
        CVolumeQuotaSetting(

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;
        virtual ~CVolumeQuotaSetting () ;

private:
		DskCommonRoutines   m_CommonRoutine;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\autochksetting.cpp ===
/******************************************************************

   AutoChkSetting.CPP -- WMI provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

******************************************************************/

#include "Precomp.h"
#include "AutoChkSetting.h"

// Provider classes 
#define PROVIDER_NAME_AUTOCHKSETTING	L"Win32_AutoChkSetting"

//Properties names
#define SettingID						L"SettingID"
#define UserInputDelay						L"UserInputDelay"

#define OSName							L"Name"

#define TIME_OUT_VALUE           L"AutoChkTimeOut"
#define SESSION_MANAGER_KEY      L"Session Manager"

CAutoChkSetting MyAutoDiskSettings ( 

	PROVIDER_NAME_AUTOCHKSETTING, 
	IDS_CimWin32Namespace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CAutoChkSetting::CAutoChkSetting
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CAutoChkSetting :: CAutoChkSetting (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{	
}

/*****************************************************************************
 *
 *  FUNCTION    :   CAutoChkSetting::~CAutoChkSetting
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CAutoChkSetting :: ~CAutoChkSetting ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CAutoChkSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CAutoChkSetting :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{
#ifdef NTONLY
	HRESULT hRes = WBEM_E_PROVIDER_FAILURE;
	CHString t_OSName;
	DWORD dwUserInputDelay;

    hRes = GetOSNameKey(t_OSName, pMethodContext);

    if (SUCCEEDED(hRes))
    {
	    if ( QueryTimeOutValue ( &dwUserInputDelay ) )
	    {
		    CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
	    
		    if ( pInstance->SetCHString ( SettingID, t_OSName ) )
		    {
			    if ( pInstance->SetDWORD ( UserInputDelay, dwUserInputDelay ) )
			    {
				    hRes = pInstance->Commit ();
			    }	
		    }
	    }
    }

	return hRes;
#else
	return WBEM_E_NOT_SUPPORTED;
#endif

}

/*****************************************************************************
*
*  FUNCTION    :    CAutoChkSetting::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CAutoChkSetting :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
#ifdef NTONLY
    HRESULT hRes = WBEM_S_NO_ERROR;
	CHString t_OSName;
	CHString t_Key;
	// Get the Key Value

	MethodContext *pMethodContext = pInstance->GetMethodContext();

 	if ( pInstance->GetCHString ( SettingID, t_Key ) )
	{
        hRes = GetOSNameKey(t_OSName, pMethodContext);

        if (SUCCEEDED(hRes))
        {
		    // Check if this Key Value exists  matches with the OS
		    if ( _wcsicmp ( t_Key, t_OSName ) == 0 )
		    {	
			    DWORD dwUserInputDelay;
			    if ( QueryTimeOutValue ( &dwUserInputDelay ) )
			    {
				    if ( pInstance->SetDWORD ( UserInputDelay, dwUserInputDelay ) == FALSE )
				    {
					    hRes = WBEM_E_FAILED;
				    }
			    }
			    else
			    {
				    hRes = WBEM_E_NOT_FOUND;
			    }
		    }
		    else
		    {
			    hRes = WBEM_E_NOT_FOUND;
		    }
        }
	}
	else
	{
		hRes = WBEM_E_FAILED;
	}

	return hRes;
#else
	return WBEM_E_NOT_SUPPORTED;
#endif

}


/*****************************************************************************
*
*  FUNCTION    : CAutoChkSetting::PutInstance
*
*  DESCRIPTION : Sets the UserInput delay ( Modifies ) 
*
*****************************************************************************/

HRESULT CAutoChkSetting :: PutInstance  (

	const CInstance &Instance, 
	long lFlags
)
{
#ifdef NTONLY
    HRESULT hRes = WBEM_S_NO_ERROR ;
	// We cannot add a new instance, however we can change the UserInputDelay Property here.
	CHString t_OSName;
	CHString t_Key;
	// Get the Key Value
	MethodContext *pMethodContext = Instance.GetMethodContext();

 	if ( Instance.GetCHString ( SettingID, t_Key ) )
	{
		// This is a Single Instance	
        hRes = GetOSNameKey(t_OSName, pMethodContext);

        if (SUCCEEDED(hRes))
        {
		    // Check if this Key Value exists matches the OS 
		    if ( _wcsicmp ( t_Key, t_OSName ) == 0 )
		    {
			    switch ( lFlags & 3)
			    {
				    case WBEM_FLAG_CREATE_OR_UPDATE:
				    case WBEM_FLAG_UPDATE_ONLY:
				    {
					    // Verify the validity of parameters
					    bool t_Exists ;
					    VARTYPE t_Type ;
					    DWORD dwUserInputDelay;

					    if ( Instance.GetStatus ( UserInputDelay , t_Exists , t_Type ) && (t_Type != VT_NULL) )
					    {
						    if ( t_Exists && ( t_Type == VT_I4 ) )
						    {
							    if ( Instance.GetDWORD ( UserInputDelay , dwUserInputDelay ) )
							    {
								    // Set this user inputDelay
								    if ( ! SetTimeOutValue ( dwUserInputDelay ) )
								    {
									    hRes = WBEM_E_FAILED;
								    }
							    }
							    else
							    {
								    hRes = WBEM_E_PROVIDER_FAILURE;
							    }
						    }
						    else
						    {
							    hRes = WBEM_E_FAILED;
						    }
					    }
    				    break;
				    }
				    default:
				    {
					    hRes = WBEM_E_PROVIDER_NOT_CAPABLE ;
    				    break ;
				    }
			    }
		    }
		    else
            {
			    hRes = WBEM_E_NOT_FOUND;
            }
        }
	}
	
    return hRes ;
#else
	return WBEM_E_NOT_SUPPORTED;
#endif

}

/*****************************************************************************
*
*  FUNCTION    :    CAutoChkSetting::QueryTimeOutValue
*
*  DESCRIPTION :    This function reads the AutoChkTimeOut value of the Session
*					Manager key.
*
*****************************************************************************/
#ifdef NTONLY
BOOLEAN CAutoChkSetting ::QueryTimeOutValue(

    OUT PULONG  a_ulTimeOut
)
{

   RTL_QUERY_REGISTRY_TABLE    QueryTable[2];
   NTSTATUS                    t_Status;

    // Set up the query table:
    //
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = TIME_OUT_VALUE;
    QueryTable[0].EntryContext = a_ulTimeOut;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = 0;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;
    QueryTable[1].EntryContext = NULL;
    QueryTable[1].DefaultType = REG_NONE;
    QueryTable[1].DefaultData = NULL;
    QueryTable[1].DefaultLength = 0;

    t_Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                     SESSION_MANAGER_KEY,
                                     QueryTable,
                                     NULL,
                                     NULL );

    if (t_Status == 0xC0000034) // Key not found
    {
        *a_ulTimeOut = 10;
        t_Status = 0;
    }

    return( NT_SUCCESS( t_Status ) );

}

/*****************************************************************************
*
*  FUNCTION    :    CAutoChkSetting::EnumerateInstances
*
*  DESCRIPTION :    This function sets the AutoChkTimeOut value of the Session
*					Manager key.
*
*****************************************************************************/

BOOLEAN CAutoChkSetting :: SetTimeOutValue (

    IN  ULONG  a_ulTimeOut
)
{
    NTSTATUS                    t_Status;

    t_Status = RtlWriteRegistryValue( RTL_REGISTRY_CONTROL,
                                    SESSION_MANAGER_KEY,
                                    TIME_OUT_VALUE,
                                    REG_DWORD,
                                    &a_ulTimeOut,
                                    sizeof(a_ulTimeOut) );

    return( NT_SUCCESS( t_Status ) );


}
#endif

/*****************************************************************************
*
*  FUNCTION    :    CAutoChkSetting::GetOSNameKey
*
*  DESCRIPTION :    Getting an OSName using the Existing Win32_Operating System 
*					Class
*
*****************************************************************************/
HRESULT CAutoChkSetting::GetOSNameKey ( CHString &a_OSName, MethodContext *pMethodContext )
{
#ifdef NTONLY
	HRESULT hRes = WBEM_S_NO_ERROR;

	TRefPointerCollection<CInstance>	serviceList;

	hRes = CWbemProviderGlue::GetInstancesByQuery(L"Select Name From Win32_OperatingSystem", &serviceList, pMethodContext, GetNamespace());

	if ( SUCCEEDED ( hRes ) )
	{
		REFPTRCOLLECTION_POSITION	pos;
		CInstancePtr				pService;

		if ( serviceList.BeginEnum( pos ) )
		{
			pService.Attach(serviceList.GetNext( pos ));
			pService->GetCHString ( OSName, a_OSName );
			serviceList.EndEnum();
		}	
		// IF BeginEnum
	}	// IF GetAllDerived

    return hRes;
#else
	return WBEM_E_NOT_SUPPORTED;
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\1394.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  1394.h
//
//  Purpose: 1394 Controller property set provider
//
//***************************************************************************

// Property set identification
//============================

#define	PROPSET_NAME_1394CONTROLLER	L"Win32_1394Controller"

#define SPECIAL_PROPS_ALL_REQUIRED          0xFFFFFFFF
#define SPECIAL_PROPS_NONE_REQUIRED         0x00000000
#define SPECIAL_PROPS_STATUS				0x00000004
#define SPECIAL_PROPS_DEVICEID				0x00000008
#define SPECIAL_PROPS_CREATIONNAME			0x00000010
#define SPECIAL_PROPS_SYSTEMNAME			0x00000020
#define SPECIAL_PROPS_DESCRIPTION			0x00000040
#define SPECIAL_PROPS_CAPTION				0x00000080
#define SPECIAL_PROPS_NAME					0x00000100
#define SPECIAL_PROPS_MANUFACTURER			0x00000200
#define SPECIAL_PROPS_PROTOCOLSSUPPORTED	0x00000400
#define SPECIAL_PROPS_PNPDEVICEID			0x00400000
#define SPECIAL_PROPS_CONFIGMERRORCODE		0x00800000
#define SPECIAL_PROPS_CONFIGMUSERCONFIG		0x01000000
#define SPECIAL_PROPS_CREATIONCLASSNAME		0x02000000


#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER )

#define SPECIAL_CONFIGMANAGER		( SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_DEVICEID | \
									SPECIAL_PROPS_CREATIONNAME | \
									SPECIAL_PROPS_SYSTEMNAME | \
									SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME | \
									SPECIAL_PROPS_MANUFACTURER | \
									SPECIAL_PROPS_PROTOCOLSSUPPORTED | \
									SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_CREATIONCLASSNAME )

#define SPECIAL_CONFIGPROPERTIES 	( SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_STATUS )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_CAP_NAME			( SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

class CWin32_1394Controller : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32_1394Controller ( const CHString &a_Name , LPCWSTR a_Namespace ) ;

       ~CWin32_1394Controller() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject ( CInstance *a_Instance , long lFlags , CFrameworkQuery &a_Query ) ;
		HRESULT ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags ) ;
        virtual HRESULT EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags = 0L ) ;

    private:

        // Utility function(s)
        //====================

		HRESULT Enumerate ( 

			MethodContext *a_MethodContext , 
			long a_Flags , 
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED
		) ;

        HRESULT LoadPropertyValues ( 

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED 
		) ;

        BOOL Is1394Controller ( CConfigMgrDevice *a_Device ) ;

        DWORD GetBitMask ( CFrameworkQuery &a_Query );
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\dll\volumequotasetting.cpp ===
/******************************************************************

   VolumeQuotaSettings.CPP -- WMI provider class implementation



   Description: Implementation of the methods of an association class 

				Between QuotaSettings and LogicalDisk

   

  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
  
******************************************************************/
#include "precomp.h"
#include "VolumeQuotaSetting.h"

CVolumeQuotaSetting MyCVolumeQuotaSetting ( 

	IDS_VolumeQuotaSetting , 
	NameSpace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CVolumeQuotaSetting::CVolumeQuotaSetting
 *
 *  DESCRIPTION :   Constructor
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/

CVolumeQuotaSetting :: CVolumeQuotaSetting (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CVolumeQuotaSetting::~CVolumeQuotaSetting
 *
 *  DESCRIPTION :   Destructor
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

CVolumeQuotaSetting :: ~CVolumeQuotaSetting ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CVolumeQuotaSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/
HRESULT CVolumeQuotaSetting :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	hRes = EnumerateAllVolumeQuotas ( pMethodContext );

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CVolumeQuotaSetting::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/
HRESULT CVolumeQuotaSetting :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	// Not doing anything here, since the two properties which are in the object

	CHString t_Key1;
	CHString t_Key2;

 	if ( pInstance->GetCHString ( IDS_Setting, t_Key1 ) == FALSE )
		hRes = WBEM_E_FAILED;

	if ( SUCCEEDED ( hRes ) )
	{
		if ( pInstance->GetCHString ( IDS_LogicalDisk, t_Key2 ) == FALSE )
		{
			hRes = WBEM_E_FAILED;
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		// If the Drive is not as Logical Disks then GetVolume Method will return False;
		WCHAR w_Drive1;
		WCHAR w_Drive2;

		hRes = m_CommonRoutine.GetVolume ( t_Key1, w_Drive1 );
		if (SUCCEEDED ( hRes ) )
		{
			hRes = m_CommonRoutine.GetVolume ( t_Key2, w_Drive2 );
			if (SUCCEEDED ( hRes ) )
			{
				if ( w_Drive1 == w_Drive2 )
				{
					// verify this logical drives actually exists
					CHString t_DriveStrings1;
					CHString t_DriveStrings2;
					
					LPWSTR lpDriveStrings = t_DriveStrings1.GetBuffer ( MAX_PATH + 1 );

					DWORD dwDLength = GetLogicalDriveStrings ( MAX_PATH, lpDriveStrings );

					if ( dwDLength > MAX_PATH )
					{
						lpDriveStrings = t_DriveStrings2.GetBuffer ( dwDLength + 1 );
						dwDLength = GetLogicalDriveStrings ( dwDLength, lpDriveStrings );
					}

					hRes = m_CommonRoutine.SearchLogicalDisk ( w_Drive1, lpDriveStrings );
				}
				else
				{
					hRes = WBEM_E_INVALID_PARAMETER;
				}
			}
		}			
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CVolumeQuotaSetting::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  You may return more 
*                   instances or more properties than are requested and WinMgmt 
*                   will post filter out any that do not apply.
*
*****************************************************************************/

HRESULT CVolumeQuotaSetting :: ExecQuery ( 

	MethodContext *pMethodContext, 
	CFrameworkQuery &Query, 
	long lFlags
)
{
	// Queries involving only one Keyvalue  VolumeObjectPath is implemented. Query involving the UserObjectPath is not
	// implemented. Since for this we will have to  have to enumerate all the volumes until a user is found.

	HRESULT hRes = WBEM_S_NO_ERROR;
	CHStringArray t_Values;

	// Now a check for the LogicalDIsk attribute which if present in where clause the query optimization is supported

	hRes = Query.GetValuesForProp(
			 IDS_Setting,
			 t_Values
		   );

	if ( SUCCEEDED ( hRes ) )
	{
		if ( t_Values.GetSize() == 0 )
		{
			hRes = Query.GetValuesForProp(
					 IDS_LogicalDisk,
					 t_Values
				   );

			if ( SUCCEEDED ( hRes ) )
			{
				if ( t_Values.GetSize() == 0 )
				{
					//Let Winmgmt handle this, since anyway all the volumes will be enumerated.
					hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
				}
			}
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		int iSize = t_Values.GetSize ();

		// In this loop picking up one by one the VolumePath, getting the properties of those volumepath
		for ( int i = 0; i < iSize; i++ )
		{
			WCHAR w_Drive;

			hRes = m_CommonRoutine.GetVolume ( t_Values.GetAt(i), w_Drive );

			if ( SUCCEEDED ( hRes ) )
			{
				CHString t_VolumePath;
				CHString t_DeviceId;
				// In this loop I need to parse the object path 

				t_VolumePath.Format ( L"%c%s", w_Drive, L":\\" );

				// Forming a Logical Disk Key Value
				t_DeviceId.Format( L"%c%c", w_Drive, _L(':') );

				hRes = PutNewInstance ( t_DeviceId.GetBuffer ( t_DeviceId.GetLength() + 1) , 
								 t_VolumePath.GetBuffer( t_VolumePath.GetLength() + 1), 
								 pMethodContext );

				if ( FAILED (hRes) )
				{
					break;
				}
			}
			// otherwise continue with thenext drive
		}
	}
	return hRes;
}


/*****************************************************************************
*
*  FUNCTION    :    CVolumeQuotaSetting::EnumerateAllVolumeQuotas
*
*  DESCRIPTION :    Enumerates all the volumes that supports disk Quotas
*
*****************************************************************************/

HRESULT CVolumeQuotaSetting::EnumerateAllVolumeQuotas ( 
			
	MethodContext *pMethodContext
) 
{
	HRESULT hRes = WBEM_S_NO_ERROR;
		// verify this logical drives actually exists
	CHString t_DriveStrings1;
	CHString t_DriveStrings2;
	
	LPWSTR lpDriveStrings = t_DriveStrings1.GetBuffer ( MAX_PATH + 1 );

	DWORD dwDLength = GetLogicalDriveStrings ( MAX_PATH, lpDriveStrings );

	if ( dwDLength > MAX_PATH )
	{
		lpDriveStrings = t_DriveStrings2.GetBuffer ( dwDLength + 1 );
		dwDLength = GetLogicalDriveStrings ( dwDLength, lpDriveStrings );
	}

	// Here for every drive, getting a volumePath for Win32_DiskVolume Class and DeviceId for Logical Disk Class
	LPWSTR lpTempDriveStrings;
	CHString t_VolumePath;
	CHString t_DeviceId;

	lpTempDriveStrings = lpDriveStrings;

	int iLen = lstrlen ( lpTempDriveStrings );

	while ( iLen > 0 )
	{
		t_VolumePath = lpTempDriveStrings;
		t_DeviceId = lpTempDriveStrings;

		lpTempDriveStrings = &lpTempDriveStrings [ iLen + 1];

		t_DeviceId.SetAt ( t_DeviceId.GetLength() - 1,L'\0' );
		iLen = lstrlen ( lpTempDriveStrings );

		hRes = PutNewInstance ( t_DeviceId.GetBuffer ( t_DeviceId.GetLength() + 1), 
						 t_VolumePath.GetBuffer ( t_VolumePath.GetLength() + 1), 
						 pMethodContext);

		if ( FAILED ( hRes ) )
			break;
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CVolumeQuotaSetting::PutNewInstance
*
*  DESCRIPTION :    Sets the properties into a new instance
*
*****************************************************************************/

HRESULT CVolumeQuotaSetting::PutNewInstance ( 
										  
	LPWSTR a_DeviceId,
	LPWSTR a_VolumePath,
	MethodContext *pMethodContext
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	LPWSTR lpTempVolumePath;
	LPWSTR lpTempDeviceID;

	m_CommonRoutine.MakeObjectPath ( lpTempVolumePath, IDS_DiskVolumeClass, IDS_VolumePath, a_VolumePath );
	m_CommonRoutine.MakeObjectPath ( lpTempDeviceID, IDS_LogicalDiskClass, IDS_DeviceID, a_DeviceId );	

	if ( ( lpTempVolumePath != NULL ) && ( lpTempDeviceID != NULL ) )
	{
		try
		{
			CInstancePtr pInstance = CreateNewInstance ( pMethodContext ) ;

			if ( pInstance->SetCHString ( IDS_LogicalDisk, lpTempDeviceID ) )
			{
				if ( pInstance->SetCHString ( IDS_Setting, lpTempVolumePath ) )
				{
					hRes = pInstance->Commit ();
				}
				else
				{
				   hRes = WBEM_E_FAILED;
				}
			}
			else
			{
				hRes = WBEM_E_FAILED;
			}
		}
		catch ( ... )
		{
			delete [] lpTempVolumePath;
			lpTempVolumePath = NULL;
			delete [] lpTempDeviceID;
			lpTempDeviceID = NULL;
			throw;
		}
		
		if ( lpTempVolumePath != NULL )
		{
			delete [] lpTempVolumePath;
		}

		if ( lpTempDeviceID != NULL )
		{
			delete [] lpTempDeviceID;
		}
	}
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\1394.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  1394.cpp
//
//  Purpose: 1394 Controller property set provider
//
//***************************************************************************

#include "precomp.h"
#include <cregcls.h>

#include "1394.h"

// Property set declaration
//=========================

#define CONFIG_MANAGER_CLASS_1394 L"1394"

CWin32_1394Controller s_1394Controller ( PROPSET_NAME_1394CONTROLLER, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_1394Controller::CWin32_1394Controller
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32_1394Controller :: CWin32_1394Controller (

	const CHString &a_Name ,
	LPCWSTR a_Namespace

) : Provider( a_Name, a_Namespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_1394Controller::~CWin32_1394Controller
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32_1394Controller :: ~CWin32_1394Controller ()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_1394Controller::GetObject
//
//  Inputs:     CInstance*      a_Instance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_1394Controller :: GetObject ( CInstance *a_Instance , long a_Flags, CFrameworkQuery &a_Query )
{
    HRESULT t_Result = WBEM_E_NOT_FOUND ;

    // Let's see if config manager recognizes this device at all

    CHString t_DeviceID;
    a_Instance->GetCHString ( IDS_DeviceID , t_DeviceID ) ;

    CConfigManager t_ConfigurationManager ;
    CConfigMgrDevicePtr t_Device;

    if ( t_ConfigurationManager.LocateDevice ( t_DeviceID , t_Device ) )
    {
        // Ok, it knows about it.  Is it a InfraRed device?

		if ( Is1394Controller ( t_Device ) )
		{
			// Yup, it must be one of ours.

			CHString t_Key ;
			a_Instance->GetCHString ( IDS_DeviceID , t_Key ) ;

            DWORD t_SpecifiedProperties = GetBitMask(a_Query);

			t_Result = LoadPropertyValues ( a_Instance , t_Device , t_Key , t_SpecifiedProperties ) ;
		}
    }

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_1394Controller::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_1394Controller :: EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags )
{
	HRESULT t_Result ;
	t_Result = Enumerate ( a_MethodContext , a_Flags ) ;
	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_1394Controller :: ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    DWORD t_SpecifiedProperties = GetBitMask(a_Query);

	//if ( t_SpecifiedProperties )  //removed since would result in no query being executed if no special properties were selected.
	{
		t_Result = Enumerate ( a_MethodContext , a_Flags , t_SpecifiedProperties ) ;
	}

    return t_Result ;
}

HRESULT CWin32_1394Controller :: Enumerate ( MethodContext *a_MethodContext , long a_Flags , DWORD a_SpecifiedProperties )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    CConfigManager t_ConfigurationManager ;
    CDeviceCollection t_DeviceList ;

    // While it might be more performant to use FilterByGuid, it appears that at least some
    // 95 boxes will report InfraRed info if we do it this way.

    if ( t_ConfigurationManager.GetDeviceListFilterByClass ( t_DeviceList , CONFIG_MANAGER_CLASS_1394 ) )
    {
        REFPTR_POSITION t_Position ;

        if ( t_DeviceList.BeginEnum( t_Position ) )
        {
			try
			{
				CConfigMgrDevicePtr t_Device;

				t_Result = WBEM_S_NO_ERROR ;

				// Walk the list
                for (t_Device.Attach( t_DeviceList.GetNext ( t_Position ) );
                     SUCCEEDED( t_Result ) && (t_Device != NULL);
                     t_Device.Attach( t_DeviceList.GetNext ( t_Position ) ))
				{
					// Now to find out if this is the infrared controller

					if ( Is1394Controller ( t_Device ) )
					{
						CHString t_Key ;
						if ( t_Device->GetDeviceID ( t_Key ) )
						{
							CInstancePtr t_Instance (CreateNewInstance ( a_MethodContext ), false) ;
							if ( ( t_Result = LoadPropertyValues ( t_Instance , t_Device , t_Key , a_SpecifiedProperties ) ) == WBEM_S_NO_ERROR )
							{
								t_Result = t_Instance->Commit (  ) ;
							}
						}
					}

					// GetNext() AddRefs

				}

			}
			catch ( ... )
			{
				t_DeviceList.EndEnum () ;
                throw;
			}

			// Always call EndEnum().  For all Beginnings, there must be an End

			t_DeviceList.EndEnum () ;
        }
    }

    return t_Result;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_1394Controller::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* a_Instance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_1394Controller :: LoadPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	DWORD a_SpecifiedProperties
)
{
    HRESULT t_Result = WBEM_S_NO_ERROR;

/*
 *	 Set PNPDeviceID, ConfigManagerErrorCode, ConfigManagerUserConfig
 */

	if ( a_SpecifiedProperties & SPECIAL_CONFIGPROPERTIES )
	{
		SetConfigMgrProperties ( a_Device, a_Instance ) ;

/*
 * Set the status based on the config manager error code
 */

		if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
		{
            CHString t_sStatus;
			if ( a_Device->GetStatus ( t_sStatus ) )
			{
				a_Instance->SetCHString ( IDS_Status , t_sStatus ) ;
			}
		}
	}
/*
 *	Use the PNPDeviceID for the DeviceID (key)
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DEVICEID )
	{
		CHString t_Key ;

		if ( a_Device->GetDeviceID ( t_Key ) )
		{
			a_Instance->SetCHString ( IDS_DeviceID , t_Key ) ;
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONNAME )
	{
		a_Instance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_SYSTEMNAME )
	{
	    a_Instance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONCLASSNAME )
	{
		SetCreationClassName ( a_Instance ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_DESC_CAP_NAME )
	{
		CHString t_Description ;
		if ( a_Device->GetDeviceDesc ( t_Description ) )
		{
			if ( a_SpecifiedProperties & SPECIAL_PROPS_DESCRIPTION )
			{
				a_Instance->SetCHString ( IDS_Description , t_Description ) ;
			}
		}

/*
 *	Use the friendly name for caption and name
 */

		if ( a_SpecifiedProperties & SPECIAL_CAP_NAME )
		{
			CHString t_FriendlyName ;
			if ( a_Device->GetFriendlyName ( t_FriendlyName ) )
			{
				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_FriendlyName ) ;
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_FriendlyName ) ;
				}
			}
			else
			{
		/*
		 *	If we can't get the name, settle for the description
		 */

				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_Description );
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_Description );
				}
			}
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MANUFACTURER )
	{
		CHString t_Manufacturer ;

		if ( a_Device->GetMfg ( t_Manufacturer ) )
		{
			a_Instance->SetCHString ( IDS_Manufacturer, t_Manufacturer ) ;
		}
	}

/*
 *	Fixed value from enumerated list
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_PROTOCOLSSUPPORTED )
	{
	    a_Instance->SetWBEMINT16 ( IDS_ProtocolSupported , 12 ) ;
	}

    return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_1394Controller::Is1394Controller
 *
 *  DESCRIPTION : Checks to make sure pDevice is a controller, and not some
 *                other type of InfraRed device.
 *
 *  INPUTS      : CConfigMgrDevice* pDevice - The device to check.  It is
 *                assumed that the caller has ensured that the device is a
 *                valid InfraRed class device.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32_1394Controller :: Is1394Controller ( CConfigMgrDevice *a_Device )
{
    BOOL t_Status = a_Device->IsClass(CONFIG_MANAGER_CLASS_1394) ;

    return t_Status ;
}

DWORD CWin32_1394Controller :: GetBitMask ( CFrameworkQuery &a_Query )
{
    DWORD t_SpecifiedProperties = SPECIAL_PROPS_NONE_REQUIRED ;

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_DeviceID ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DEVICEID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemCreationClassName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SYSTEMNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Description ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DESCRIPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Caption ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Name ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_NAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Manufacturer ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MANUFACTURER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_ProtocolSupported ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_PROTOCOLSSUPPORTED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_CreationClassName ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONCLASSNAME ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_PNPDeviceID ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_PNPDEVICEID ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerErrorCode ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMERRORCODE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerUserConfig ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMUSERCONFIG ;
    }

    return t_SpecifiedProperties;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\inc\diskquota.h ===
/******************************************************************



   DskQuota.H -- WMI provider class definition



   Description: Header for Quotasettings class 



  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

*******************************************************************/

// Property set identification
//============================


#ifndef  _CDISKQUOTA_H_
#define  _CDISKQUOTA_H_
#include "precomp.h"
#include  "DskQuotaCommon.h"

// Defining bit values for the property, which will be used for defining the bitmap of properties required.
#define DSKQUOTA_ALL_PROPS							0xFFFFFFFF
#define DSKQUOTA_PROP_LogicalDiskObjectPath			0x00000001
#define DSKQUOTA_PROP_UserObjectPath				0x00000002
#define DSKQUOTA_PROP_Status						0x00000004
#define DSKQUOTA_PROP_WarningLimit					0x00000008
#define DSKQUOTA_PROP_Limit							0x00000010
#define DSKQUOTA_PROP_DiskSpaceUsed					0x00000020

class CDiskQuota : public Provider 
{
private:

		HRESULT EnumerateUsersOfAllVolumes ( 
			
			MethodContext *pMethodContext,
			DWORD dwPropertiesReq
		);

		HRESULT EnumerateUsers ( 
			
			MethodContext *pMethodContext, 
			LPCWSTR a_VolumeName,
			DWORD dwPropertiesReq
		);

		HRESULT LoadDiskQuotaUserProperties ( 
			
			IDiskQuotaUser* pIQuotaUser, 
			CInstance *pInstance,
			DWORD dwPropertiesReq
		);

		HRESULT SetKeys ( 
			
			CInstance *pInstance, 
			WCHAR w_Drive,
			DWORD dwPropertiesReq,
			IDiskQuotaUser* pIQuotaUser
		);

		HRESULT AddUserOnVolume ( 

			const CInstance &Instance, 
			LPCWSTR a_VolumePathName, 
			LPCWSTR a_UserLogonName 
		);

		HRESULT  UpdateUserQuotaProperties ( 
			
			const CInstance &Instance, 			
			LPCWSTR a_VolumePathName, 
			LPCWSTR a_UserLogonName 
		);

		HRESULT CheckParameters ( 

			const CInstance &a_Instance
		);

		void SetPropertiesReq ( 
												  
			CFrameworkQuery *Query, 
			DWORD &dwPropertiesReq
		);

		void ExtractUserLogOnName ( 
			
			CHString &a_UserLogonName,
			CHString &a_DomainName
		);

		void GetKeyValue ( 
			
			CHString &a_VolumePath, 
			LPCWSTR a_VolumeObjectPath
		);

        BOOL GetDomainAndNameFromSid(
            PSID pSid,
            CHString& chstrDomain,
            CHString& chstrName);

protected:

        // Reading Functions
        //============================

        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
			CFrameworkQuery &Query
		) ;

        HRESULT ExecQuery ( 

			MethodContext *pMethodContext, 
			CFrameworkQuery& Query, 
			long lFlags = 0
		) ;

        // Writing Functions
        //============================

        HRESULT PutInstance (

			const CInstance& Instance, 
			long lFlags = 0L
		) ;

        HRESULT DeleteInstance (

			const CInstance& Instance, 
			long lFlags = 0L
		) ;

public:

        // Constructor/destructor
        //=======================

        CDiskQuota(

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CDiskQuota () ;
private:

	CHString			m_ComputerName;
	DskCommonRoutines   m_CommonRoutine;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\inc\dskquotacommon.h ===
/******************************************************************

   DskCommonRoutines.CPP -- 



   Description: Common Headers and Smart pointers

   

  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
  
******************************************************************/

#ifndef  _CDSKQUOTACOMMON_H_
#define  _CDSKQUOTACOMMON_H_

#include "precomp.h"
_COM_SMARTPTR_TYPEDEF(IEnumDiskQuotaUsers, IID_IEnumDiskQuotaUsers);
_COM_SMARTPTR_TYPEDEF(IDiskQuotaUser, IID_IDiskQuotaUser );
_COM_SMARTPTR_TYPEDEF(IDiskQuotaControl, IID_IDiskQuotaControl );



// Provider Namespace
#define	NameSpace								L"root\\cimv2"

// Provider Classes
#define IDS_DiskVolumeClass						L"Win32_QuotaSetting"
#define IDS_LogicalDiskClass					L"Win32_LogicalDisk"
#define IDS_DiskQuotaClass						L"Win32_DiskQuota"
#define IDS_AccountClass						L"Win32_Account"
#define IDS_LogicalDiskClass					L"Win32_LogicalDisk"
#define IDS_VolumeQuotaSetting					L"Win32_VolumeQuotaSetting"


// #defines required for setting the properties in Instances.
#define IDS_VolumePath							L"VolumePath"
#define IDS_Caption                             L"Caption"
#define IDS_DeviceID							L"DeviceID"
#define IDS_LogicalDiskObjectPath				L"QuotaVolume"
#define IDS_UserObjectPath						L"User"
#define IDS_QuotaStatus							L"Status"
#define IDS_QuotaWarningLimit					L"WarningLimit"
#define IDS_QuotaLimit							L"Limit"
#define IDS_DiskSpaceUsed						L"DiskSpaceUsed"

#define IDS_QuotasDefaultLimit                  L"DefaultLimit"
#define IDS_QuotasDefaultWarningLimit           L"DefaultWarningLimit"
#define IDS_QuotasWarningExceededNotification   L"WarningExceededNotification"
#define IDS_QuotaExceededNotification           L"ExceededNotification"
#define IDS_QuotaState                          L"State"

#define IDS_Domain								L"Domain"
#define IDS_Name								L"Name"
#define IDS_Setting								L"Setting"
#define IDS_LogicalDisk							L"Element"

// Smart pointer for closing volume handles
class SmartCloseVolumeHandle
{
private:
	HANDLE m_h;

public:
	SmartCloseVolumeHandle():m_h(INVALID_HANDLE_VALUE){}
	SmartCloseVolumeHandle(HANDLE h):m_h(h){}
   	~SmartCloseVolumeHandle(){if (m_h!=INVALID_HANDLE_VALUE) FindVolumeClose(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) FindVolumeClose(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) FindVolumeClose(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};

// Common routines required for Disk Quota Provider
struct DskCommonRoutines
{
	public:

		HRESULT InitializeInterfacePointer ( IDiskQuotaControl* pIQuotaControl, LPCWSTR a_VolumeName );
		HRESULT VolumeSupportsDiskQuota ( LPCWSTR a_VolumeName,  CHString &a_QuotaVolumeName );
		void GetVolumeDrive ( LPCWSTR a_VolumePath, LPCWSTR a_DriveStrings, CHString &a_DriveName );
		HRESULT GetVolume ( LPCWSTR t_Key1, WCHAR &w_Drive1 );
		HRESULT SearchLogicalDisk ( WCHAR a_Drive, LPCWSTR lpDriveStrings );
		void MakeObjectPath ( LPWSTR& lpObjPath, LPWSTR lpClassName, LPCWSTR lpAttributeName, LPCWSTR lpAttributeVal );
		void AddToObjectPath ( LPWSTR  &a_ObjPathString, LPCWSTR a_AttributeName, LPCWSTR  a_AttributeVal );
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\bios.h ===
//=================================================================

//

// BIOS.h -- BIOS property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:   08/01/96    a-jmoon         Created
//              10/23/97	a-sanjes        Ported to new project
//
//=================================================================

// Property set identification
//============================

#define	PROPSET_NAME_BIOS	L"Win32_BIOS"

class CWin32BIOS : public Provider
{
public:

    // Constructor/destructor
    CWin32BIOS(LPCWSTR strName, LPCWSTR pszNamespace);
    ~CWin32BIOS();

    // Functions provide properties with current values
    virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
    virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L);

    // Utility function(s)
    HRESULT LoadPropertyValues(CInstance *pInstance);
    void SetBiosDate(CInstance *pInstance, CHString &strDate);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\autochksetting.h ===
/******************************************************************



   AutoChkSetting.H -- WMI provider class definition



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

*******************************************************************/

#ifndef  _CAUTOCHKSETTING_H_
#define  _CAUTOCHKSETTING_H_

class CAutoChkSetting : public Provider 
{
private:
#ifdef NTONLY
		BOOLEAN QueryTimeOutValue(

			OUT PULONG  pulTimeOut
		);

		BOOLEAN SetTimeOutValue (

			IN  ULONG  ulTimeOut
		);
#endif

		HRESULT GetOSNameKey ( 

			CHString &a_OSName, 
            MethodContext *pContext
		);

protected:

        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
			CFrameworkQuery &Query
		) ;

        HRESULT PutInstance (

			const CInstance& Instance, 
			long lFlags = 0L
		) ;

public:
        
		CAutoChkSetting (

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CAutoChkSetting () ;
private:
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\bootconfig.h ===
//=================================================================

//

// BootConfig.h -- Win32 boot configuration property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_BOOTCONFIG L"Win32_BootConfiguration"
//#define  PROPSET_UUID_BOOTCONFIG "{B745D28E-09C5-11d1-A29F-00C04FC2A120}"

class BootConfig:public Provider {

    public:

        // Constructor/destructor
        //=======================

        BootConfig(const CHString& name, LPCWSTR pszNameSpace) ;
       ~BootConfig() ;

        // Functions provide properties with current values
        //=================================================
	virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
	virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);



        HRESULT LoadPropertyValues(CInstance* pInstance) ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\bios.cpp ===
//=================================================================

//

// BIOS.CPP --BIOS property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:   08/01/96    a-jmoon         Created
//              10/23/97	a-sanjes        Ported to new project
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "bios.h"

#include "smbios.h"
#include "smbstruc.h"

void FormatWBEMDate(WBEMTime &wbemdate, LPTSTR datestr);

BOOL ValidDate(int iMonth, int iDay)
{
	BOOL bRet = FALSE;

	if ((iMonth > 0) && (iMonth < 13) && (iDay > 0))
	{
		int iDays[] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

		if (iDay <= iDays [iMonth - 1])
		{
			bRet = TRUE;
		}
	}

	return bRet;
}

// Property set declaration
//=========================

CWin32BIOS	biosSet(PROPSET_NAME_BIOS, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32BIOS::CWin32BIOS
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32BIOS::CWin32BIOS(
	LPCWSTR szName,
	LPCWSTR szNamespace) :
    Provider(szName, szNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32BIOS::~CWin32BIOS
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32BIOS::~CWin32BIOS()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32BIOS::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32BIOS::GetObject(
	CInstance *pInstance,
	long lFlags)
{

    // Get the previous __RELPATH

	CHString strPathBefore;
    GetLocalInstancePath(pInstance, strPathBefore);

    HRESULT hr = LoadPropertyValues(pInstance);
	if (SUCCEEDED(hr))
	{
        // If we were able to get the BIOS properties but the new __RELPATH doesn't
        // match the old __RELPATH, return WBEM_E_NOT_FOUND.

		CHString strPathAfter;
		if (!GetLocalInstancePath(pInstance, strPathAfter) ||
            strPathAfter.CompareNoCase(strPathBefore) != 0)
		{
			hr = WBEM_E_NOT_FOUND;
		}
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32BIOS::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32BIOS::EnumerateInstances(
	MethodContext *pMethodContext,
	long lFlags)
{
	HRESULT	hr = S_OK;

	CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
	if ((hr = LoadPropertyValues(pInstance)) == WBEM_S_NO_ERROR)
	{
		hr = pInstance->Commit();
	}

	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32BIOS::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance*	pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT		error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32BIOS::SetBiosDate(CInstance *pInstance, CHString &strDate)
{
    int iSlash1 = strDate.Find('/'),
	    iSlash2 = strDate.ReverseFind('/');

    if (iSlash1 != -1 && iSlash2 != -1 && iSlash1 != iSlash2)
	{
	    int iMonth,
            iDay,
            iYear;

		iMonth  = _wtoi(strDate.Left(iSlash1));
		iYear = _wtoi(strDate.Mid(iSlash2 + 1));
        
        // Up until the year 2080 we will treat the two
        // digit year as 19xx if it was >= 80, and 20xx
        // if it was < 80.  After 2080, we will always
        // treat the year as being 20xx.
        SYSTEMTIME st;
        GetLocalTime(&st);

        WORD wYearToday = st.wYear;

        // If the bios gave us a four digit year, we
        // don't need to make any special adjustments.
        if(iYear < 1000)
        {
            if(wYearToday < 2080)
            {
                if (iYear >= 80 && iYear < 100)
                {
                    iYear += 1900;
                }
                else
                {
                    if(iYear < 100)
                    {
                        iYear += 2000;
                    }
                    else
                    {
                        iYear += 1900;
                    }
                }
            }
            else
            {
                iYear += 2000;
            }
        }

        iDay = _wtoi(strDate.Mid(iSlash1 + 1, iSlash2 - iSlash1 - 1));

		if (ValidDate(iMonth, iDay))
		{
			// Convert to the DMTF format and send it in
			WCHAR szDate[100];

			swprintf(
				szDate,
				L"%d%02d%02d******.******+***",
				iYear,
				iMonth,
				iDay);

			pInstance->SetCharSplat(IDS_ReleaseDate, szDate);
		}
	}
}

HRESULT CWin32BIOS::LoadPropertyValues(CInstance *pInstance)
{
	// Assign dummy name in case we can't get the real one
	//====================================================

	pInstance->SetCHString(IDS_Name, IDS_BIOS_NAME_VALUE);

#ifdef _IA64_
	BOOL bUsedDefault = FALSE;
#endif

	// Fill in 'of-course' properties
	//===============================
	// okay - I'm making a wild assumption here.  I'm assuming that
	// if the BIOS is broken, then we won't be here!

	pInstance->SetCharSplat(IDS_Status, IDS_CfgMgrDeviceStatus_OK);

#ifdef NTONLY

	CRegistry reg;

	DWORD dwErr = reg.Open( HKEY_LOCAL_MACHINE, IDS_RegBiosSystem,  KEY_READ);
	if (dwErr == ERROR_SUCCESS)
	{
		CHString sDate;

		dwErr = reg.GetCurrentKeyValue( IDS_RegSystemBiosDate,sDate);
		if (dwErr != ERROR_SUCCESS)
		{
            // hardcode and go on
			// return WinErrorToWBEMhResult(dwErr);
            sDate = ""; 
		}

		SetBiosDate(pInstance, sDate);

		// Need to retrieve a REG_MULTI_SZ -- can't use registry class
		//============================================================

		HKEY hKey = reg.GethKey();

		WCHAR szTemp[MAX_PATH * 2];
		DWORD dwType = 0;
		DWORD dwSize = sizeof(szTemp);

		// Clear this in case it doesn't have a double '\0' at the end
        // (which is the case on some Alphas).
        memset(szTemp, 0, sizeof(szTemp));

        dwErr =  RegQueryValueEx(hKey,	IDS_RegSystemBiosVersion,	NULL,	&dwType,(LPBYTE) szTemp,&dwSize);

		// If the call succeeded and there was data in the value, use it.
        if (dwErr == ERROR_SUCCESS && *szTemp)
		{
			//this only uses the first element of the array
			pInstance->SetCHString(IDS_Version, szTemp);

			//now use them all...
			wchar_t* szTemptmp = szTemp;
            int x = 0;

            while (*szTemptmp != L'\0')
            {
				x++;
                szTemptmp += wcslen(szTemptmp) + 1;
            }

			if (0 != x)
			{
				SAFEARRAYBOUND rgsabound[1];
				SAFEARRAY* psa = NULL;
				BSTR* pBstr = NULL;
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = x;
				psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);

				try
				{
					if (NULL != psa)
					{
						if (SUCCEEDED(SafeArrayAccessData(psa, (void **)&pBstr)))
						{
							try
							{
								szTemptmp = szTemp;

								for (LONG i = 0; i < x; i++)
								{
									pBstr[i] = SysAllocString(szTemptmp);
									szTemptmp += wcslen(szTemptmp) + 1;
								}
							}
							catch(...)
							{
								SafeArrayUnaccessData(psa);
								throw;
							}

							SafeArrayUnaccessData(psa);
							pInstance->SetStringArray(L"BIOSVersion", *psa);
						}
					}
				}
				catch(...)
				{
					SafeArrayDestroy(psa);
					throw;
				}

				SafeArrayDestroy(psa);
			}

			TCHAR *c = _tcschr(szTemp, 0); // L10N OK
			if (c != NULL && *(++c))
			{
				pInstance->SetCHString(IDS_Name, c);
			}
		}
		else
		{
			// Version is part of the key and cannot be null

            // If we don't have a version in the registry, use the date.  Compaq
            // does this on purpose(the date is the version).  This seems better
            // anyway than setting Version to "".
            sDate = IDS_Unknown; 

            pInstance->SetCHString(IDS_Version, sDate);

#ifdef _IA64_
			bUsedDefault = TRUE;
#endif
		}

	}
	else
	{
		return WinErrorToWBEMhResult(dwErr);
	}

#endif

	// set descr & caption to same as name

	CHString sTemp;

	if (pInstance->GetCHString(IDS_Name, sTemp))
	{
		pInstance->SetCHString(IDS_Caption, sTemp);
		pInstance->SetCHString(L"SoftwareElementID", sTemp);
		pInstance->SetCHString(IDS_Description, sTemp);
	}

    pInstance->SetWBEMINT16(L"SoftwareElementState", 3);

    // 0 is unknown, since we don't know what OS the BIOS was targeted for.
    pInstance->SetWBEMINT16(L"TargetOperatingSystem", 0);

    pInstance->Setbool(L"PrimaryBIOS", true);

    CSMBios smbios;
    if (smbios.Init())
    {
        CHString strSerial;

		DWORD dwVersion = smbios.GetVersion();

		pInstance->Setbool(L"SMBIOSPresent", true);
		pInstance->SetDWORD(L"SMBIOSMajorVersion", HIWORD(dwVersion));
		pInstance->SetDWORD(L"SMBIOSMinorVersion", LOWORD(dwVersion));

        PSTLIST	pstl = smbios.GetStructList(1);
        if (pstl)
        {
            PSYSTEMINFO psi = (PSYSTEMINFO) pstl->pshf;

            smbios.GetStringAtOffset(
				(PSHF) psi,
				strSerial.GetBuffer(256),
                psi->Serial_Number);

            strSerial.ReleaseBuffer();
            if (!strSerial.IsEmpty())
			{
                pInstance->SetCHString(L"SerialNumber", strSerial);
			}
        }

		// Get BIOS characteristics from BIOS info structure.

        pstl = smbios.GetStructList(0);
		if (pstl)
		{
			PBIOSINFO pbi = (PBIOSINFO) pstl->pshf;
            WCHAR     szTemp[256];

			if (smbios.GetStringAtOffset((PSHF) pbi, szTemp, pbi->Vendor))
			{
				pInstance->SetCHString(L"Manufacturer", szTemp);
			}

			//use SMBIOS release date in preference...
			if(!smbios.GetStringAtOffset((PSHF) pbi, sTemp.GetBuffer(256), pbi->BIOS_Release_Date))
			{
				sTemp.ReleaseBuffer();
				sTemp.Empty();
			}
			else
			{
				sTemp.ReleaseBuffer();

				if(!sTemp.IsEmpty())
				{
					SetBiosDate(pInstance, sTemp);
				}
			}

			if (smbios.GetStringAtOffset((PSHF) pbi, szTemp, pbi->BIOS_Version))
			{
			 	pInstance->SetCHString(L"SMBIOSBIOSVersion", szTemp);

#ifdef _IA64_
				//behavior change, IA64 only!
				if (bUsedDefault)
				{
					pInstance->SetCHString(IDS_Version, szTemp);
				}
#endif
			}

            // find out how many items to initialize safe array for...

			SAFEARRAYBOUND sab;
			sab.lLbound = 0;
			sab.cElements = 0;

			// get the first 32 bits
            DWORD biosbits = 0;
            memcpy( &biosbits, pbi->BIOS_Characteristics, sizeof(DWORD));

			DWORD extbytes = 0;

			// gather the # of extention bytes
			if (smbios.GetVersion() > 0x00020000 && pbi->Length >= sizeof(BIOSINFO))
			{
				extbytes = pbi->Length - 0x12;
			}

			// figure out how many array items are needed
			while(biosbits)
			{
				if (biosbits & 0x00000001)
				{
					sab.cElements++;
				}
				biosbits >>= 1;
			}

			// check for stuff in the extension byte/s
			for (DWORD i = 0; i < extbytes; i++)
			{
				biosbits = (DWORD) pbi->BIOS_Characteristics_Ext[i];
				while(biosbits)
				{
					if (biosbits & 0x00000001)
					{
						sab.cElements++;
					}

					biosbits >>= 1;
				}
			}

			// create array and set the characteristics values
            variant_t v;

			v.parray = SafeArrayCreate(VT_I4, 1, &sab);;
			if (v.parray)
			{
                // This is done here so the v destructor won't destruct
                // unless there is something to destruct
    			v.vt = VT_ARRAY | VT_I4;

		        memcpy( &biosbits, pbi->BIOS_Characteristics, sizeof(DWORD));

				long index = 0;

				for (i = 0; i < 32 && biosbits; i++)
				{
					if (biosbits & 0x00000001)
					{
						HRESULT t_Result = SafeArrayPutElement(v.parray, & index, & i);
						if (t_Result == E_OUTOFMEMORY)
						{
							throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
						}

						index++;
					}
					biosbits >>= 1;
				}

				DWORD baseval = 32;
				DWORD setval = 0;

				// tack on the extended characteristics
				for (i = 0; i < extbytes; i++)
				{
					biosbits = (DWORD) pbi->BIOS_Characteristics_Ext[i];

					DWORD j;

					for (j = 0; j < 8 && biosbits; j++)
					{
						if (biosbits & 0x00000001)
						{
							setval = j + baseval;
							HRESULT t_Result = SafeArrayPutElement(v.parray, &index, &setval);
							if (t_Result == E_OUTOFMEMORY)
							{
								throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
							}

							index++;
						}

						biosbits >>= 1;
					}

					baseval += 8;
				}

				if (sab.cElements > 0)
				{
					pInstance->SetVariant(L"BiosCharacteristics", v);
				}

			}
			else
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}

        pstl = smbios.GetStructList(13);
		if (pstl)
		{
			PBIOSLANGINFO pbli = (PBIOSLANGINFO) pstl->pshf;
            pInstance->SetDWORD(L"InstallableLanguages", pbli->Installable_Languages);

			WCHAR szTemp[MAX_PATH];
			smbios.GetStringAtOffset((PSHF) pbli, szTemp, pbli->Current_Language);

			pInstance->SetCHString(L"CurrentLanguage", szTemp);

	 		SAFEARRAYBOUND sab;
			sab.lLbound = 0;
			sab.cElements = pbli->Installable_Languages;

			SAFEARRAY *psa = SafeArrayCreate(VT_BSTR, 1, &sab);
			if (psa)
			{
				for (DWORD i = 0; i < pbli->Installable_Languages; i++)
				{
					int len = smbios.GetStringAtOffset((PSHF) pbli, szTemp, i + 1);
					SafeArrayPutElement(psa,(long *) & i,(BSTR) _bstr_t(szTemp));
				}

				pInstance->SetStringArray(L"ListOfLanguages", *psa);

				SafeArrayDestroy(psa);
			}
			else
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}
    }
	else	// indicate that no SMBIOS is found
	{
		pInstance->Setbool(L"SMBIOSPresent", false);
	}

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\bootconfig.cpp ===
//=================================================================

//

// BootConfig.CPP --BootConfig property set provider (Windows NT only)

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/24/95	 a-hhance		ported to new framework
//
//=================================================================

#include "precomp.h"
#include "BootConfig.h"
#include "resource.h"
#include "os.h"
#include "WMI_FilePrivateProfile.h"
// Property set declaration
//=========================

BootConfig MyBootConfigSet(PROPSET_NAME_BOOTCONFIG, IDS_CimWin32Namespace) ;

/*****************************************************************************
 *
 *  FUNCTION    : BootConfig::BootConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

BootConfig :: BootConfig (

	const CHString &name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : BootConfig::~BootConfig
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

BootConfig::~BootConfig()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : BootConfig::
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT BootConfig :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

	CHString name;
	pInstance->GetCHString(IDS_Name, name);

	if ( name.CompareNoCase ( IDS_BOOT_CONFIG_NAME ) == 0 )
	{
		hr =  LoadPropertyValues(pInstance) ;
	}

	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : BootConfig::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each installed client
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT BootConfig :: EnumerateInstances (

	MethodContext *pMethodContext ,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_FAILED;

	CInstancePtr pInstance (CreateNewInstance ( pMethodContext ), false) ;
	hr = LoadPropertyValues ( pInstance ) ;
	if ( SUCCEEDED ( hr ) )
	{
		hr = pInstance->Commit (  ) ;
	}

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : BootConfig::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT BootConfig::LoadPropertyValues (

	CInstance *pInstance
)
{
	pInstance->SetCHString ( IDS_Name , IDS_BOOT_CONFIG_NAME ) ;

	TCHAR szBootDir[_MAX_PATH +1] ;
	lstrcpy ( szBootDir , _T("Unknown") ) ;

#ifdef NTONLY

	WCHAR szTemp[_MAX_PATH + 1] = L"";

	if ( GetWindowsDirectory ( szTemp , (sizeof ( szTemp ) / sizeof(TCHAR)) - 1 ) )
	{
		wcscat ( szTemp , IDS_RegSetupLog ) ;

		WMI_FILE_GetPrivateProfileStringW (

			IDS_Paths ,
			IDS_TargetDirectory ,
			IDS_Unknown ,
			szBootDir ,
			(sizeof ( szBootDir )/sizeof(WCHAR)) - 1,
			szTemp
		) ;

		WCHAR t_szSystemPartition[_MAX_PATH +1] ;
	    if ( WMI_FILE_GetPrivateProfileStringW (

			IDS_Paths ,
			L"SystemPartition",
			L"",
			t_szSystemPartition,
			sizeof(t_szSystemPartition)/sizeof(WCHAR)-1,
			szTemp
		) != 0 )
		{
			pInstance->SetCharSplat ( L"Description" , ( PWCHAR ) _bstr_t ( t_szSystemPartition ) ) ;
			pInstance->SetCharSplat ( L"Caption" , ( PWCHAR ) _bstr_t ( t_szSystemPartition ) ) ;
		}
	}
#endif

	pInstance->SetCharSplat ( IDS_BootDirectory , szBootDir ) ;

	// Configuration Path
	pInstance->SetCharSplat ( IDS_ConfigurationPath , szBootDir ) ;

/*
 *  Walk all the logical drives
 */
	TCHAR t_strDrive[3] ;
	DWORD t_dwDrives = GetLogicalDrives () ;
	for ( int t_x = 26; ( t_x >= 0 ); t_x-- )
    {
        // If the bit is set, the drive letter is active
        if ( t_dwDrives & ( 1<<t_x ) )
        {
			t_strDrive[0] = t_x + _T('A') ;
            t_strDrive[1] = _T(':') ;
            t_strDrive[2] = _T('\0') ;

			DWORD t_dwDriveType = GetDriveType ( t_strDrive ) ;
/*
 * Check if it's a valid drive
 */
			if ( t_dwDriveType == DRIVE_REMOTE	||
				 t_dwDriveType == DRIVE_FIXED		||
				 t_dwDriveType == DRIVE_REMOVABLE ||
				 t_dwDriveType == DRIVE_CDROM		||
				 t_dwDriveType == DRIVE_RAMDISK
				)
			{
				pInstance->SetCharSplat ( IDS_LastDrive , t_strDrive ) ;
				break ;
			}
		}
	}


#ifdef NTONLY



	CRegistry RegInfo;

	DWORD dwRet = RegInfo.OpenCurrentUser(

		IDS_Environment,
		KEY_READ
	) ;

	if ( dwRet == ERROR_SUCCESS )
	{
		try
		{
			CHString tempDir;

			dwRet = RegInfo.GetCurrentKeyValue (

				IDS_Temp,
				tempDir
			) ;

			if ( dwRet == ERROR_SUCCESS )
			{
				TCHAR szTempDir[_MAX_PATH +1] = _T("");

				if ( ExpandEnvironmentStrings ( (LPCTSTR) tempDir , szTempDir, _MAX_PATH ) )
				{
					pInstance->SetCharSplat ( IDS_ScratchDirectory , szTempDir ) ;
					pInstance->SetCharSplat ( IDS_TempDirectory , szTempDir ) ;
				}
			}

		}
		catch ( ... )
		{
			RegInfo.Close () ;

			throw ;
		}
		RegInfo.Close();
	}


#endif

	return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\battery.cpp ===
//=================================================================

//

// Battery.cpp

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "resource.h"
#include <batclass.h>
#include <setupapi.h>
#include "Battery.h"

// Property set declaration
//=========================


CBattery MyBattery(PROPSET_NAME_BATTERY, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CBattery::CBattery
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CBattery :: CBattery (

	const CHString &name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CBattery::~CBattery
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CBattery::~CBattery()
{
}


/*****************************************************************************
 *
 *  FUNCTION    : CBattery::GetObject
 *
 *  DESCRIPTION : Assigns values to properties in our set
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CBattery :: GetObject (

	CInstance* pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hRetCode = WBEM_E_NOT_FOUND;
    CHString sDeviceID;

    pInstance->GetCHString(IDS_DeviceID, sDeviceID);

#ifdef NTONLY
	hRetCode = GetNTBattery(NULL, sDeviceID, pInstance );

#endif

    return hRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CBattery::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of power supplies (1 if successful)
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CBattery::EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
   HRESULT hRetCode = WBEM_S_NO_ERROR;

#ifdef NTONLY

   CHString sTmp;
   hRetCode = GetNTBattery(pMethodContext, sTmp, NULL );

#endif

   return hRetCode;
}

/*****************************************************************************
 *
  *  DESCRIPTION :
 *
 *  INPUTS      : CInstance* pInstance
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if successful
 *
 *  COMMENTS    : This is specific to NT
 *
 *****************************************************************************/

#ifdef NTONLY
#define ID_Other	  1 	
#define ID_Unknown    2 
#define ID_Running    3
#define ID_Critical   5  
#define ID_Charging   6
#define ID_Degraded   10
//////////////////////////////////////////////////////////////////////////////////////////////
#define SPSAC_ONLINE        1
//
//  Values for SYSTEM_POWER_STATUS.BatteryFlag
//
#define SPSBF_NOBATTERY     128
#define OTHER_BATTERY        1
#define UNKNOWN_BATTERY      2
#define LEAD_ACID            3
#define NICKEL_CADMIUM       4
#define NICKEL_METAL_HYDRIDE 5
#define LITHIUM_ION          6
#define ZINC_AIR             7
#define LITHIUM_POLYMER      8
#define IDS_BatteryStatus L"BatteryStatus"
#define IDS_STATUS_Service L"Service"
#define IDS_STATUS_PredFail L"Failure"
const GUID GUID_DEVICE_BATTERY = { 0x72631e54L, 0x78A4, 0x11d0, { 0xbc, 0xf7, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a } };

//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::GetBatteryStatusInfo(CInstance * pInstance, HANDLE & hBattery, BATTERY_QUERY_INFORMATION & bqi)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	//==========================================================
    //  And then query the battery status.
	//==========================================================
    BATTERY_WAIT_STATUS bws;
    BATTERY_STATUS bs;
    ZeroMemory(&bws, sizeof(bws));
    bws.BatteryTag = bqi.BatteryTag;
	DWORD dwOut;
    if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_STATUS, &bws, sizeof(bws), &bs,  sizeof(bs),  &dwOut, NULL)) 
	{
		//==========================================================
		// Design Voltage
		//==========================================================
		pInstance->SetDWORD ( L"DesignVoltage",bs.Voltage) ;

		//==========================================================
		//Availability, Status and BatteryStatus
		//==========================================================
        if (bs.PowerState & BATTERY_POWER_ON_LINE) 
		{
			//==========================================================
			//  BATTERY_POWER_ON_LINE Indicates that the system has 
			//  access to AC power, so no batteries are being discharged. 
			//==========================================================
			pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK ) ;
			pInstance->SetWBEMINT16(IDS_BatteryStatus, ID_Unknown );
			pInstance->SetWBEMINT16(IDS_Availability,ID_Unknown);
		}
		else if( bs.PowerState & BATTERY_DISCHARGING )
		{
			//==========================================================
			//  BATTERY_DISCHARGING Indicates that the battery is 
			//  currently discharging. 
			//==========================================================
			pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK );
			pInstance->SetWBEMINT16(IDS_BatteryStatus, ID_Other);
			pInstance->SetWBEMINT16(IDS_Availability,ID_Running);
		}
		else if( bs.PowerState & BATTERY_CHARGING )
		{
			//==========================================================
			//  BATTERY_CHARGING Indicates that the battery is currently
			//  charging. 
			//==========================================================
			pInstance->SetCharSplat(IDS_Status, IDS_STATUS_Service );
			pInstance->SetWBEMINT16(IDS_BatteryStatus, ID_Charging );
			pInstance->SetWBEMINT16(IDS_Availability,ID_Other);
		}
		else if( bs.PowerState & BATTERY_CRITICAL )
		{
			//==========================================================
			//  BATTERY_CRITICAL Indicates that battery failure is
			// imminent. 
   			//==========================================================
			pInstance->SetCharSplat(IDS_Status, IDS_STATUS_PredFail );
			pInstance->SetWBEMINT16(IDS_BatteryStatus, ID_Critical );
			pInstance->SetWBEMINT16(IDS_Availability,ID_Degraded);
		}
	}
   	//==========================================================
	//  Need a valid way to determine this
   	//==========================================================
	// pInstance->SetWBEMINT16 ( L"EstimatedChargeRemaining" , Info.BatteryLifePercent ) ;
	return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::SetPowerManagementCapabilities(CInstance * pInst, ULONG Capabilities)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	//set the PowerManagementCapabilities to not supported...don't really match here yet
	variant_t      vCaps;
    SAFEARRAYBOUND rgsabound;
	long           ix;
    int iPowerCapabilities = 1; // not supported

    ix = 0;
	rgsabound.cElements = 1;
	rgsabound.lLbound   = 0;

	V_ARRAY(&vCaps) = SafeArrayCreate(VT_I2, 1, &rgsabound);
    V_VT(&vCaps) = VT_I2 | VT_ARRAY;

	if (V_ARRAY(&vCaps))
	{
        if (S_OK == SafeArrayPutElement(V_ARRAY(&vCaps), &ix, &iPowerCapabilities))
		{
			pInst->SetVariant(IDS_PowerManagementCapabilities, vCaps);
		}
	}
    return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::SetChemistry(CInstance * pInstance, UCHAR * Type)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    //=========================================================
    //  These are the battery types            What we need to
    //  returned by our query                  Convert it to
    // ------------------------------          ---------------
    //  PbAc Lead Acid                              LEAD_ACID
    //  LION Lithium Ion                            LITHIUM_ION
    //  NiCd Nickel Cadmium                         NICKEL_CADMIUM
    //  NiMH Nickel Metal Hydride                   NICKEL_METAL_HYDRIDE
    //  NiZn Nickel Zinc                            OTHER   
    //  RAM Rechargeable Alkaline-Manganese         OTHER
    //  else Unknown                                UNKNOWN
    //=========================================================
    WBEMINT16 Chemistry = UNKNOWN_BATTERY;

    if( memcmp( "PbAc", Type, 4 ) == 0 )
    {
        Chemistry = LEAD_ACID;
    }
    else if( memcmp( "LION", Type, 4) == 0 )
    {
        Chemistry = LITHIUM_ION;
    }
    else if( memcmp( "NiCd", Type, 4) == 0 )
    {
        Chemistry = NICKEL_CADMIUM;
    }
    else if( memcmp( "NiMH",Type, 4) == 0 )
    {
        Chemistry = NICKEL_METAL_HYDRIDE;
    }
    else if( memcmp( "NiZn", Type, 4) == 0 )
    {
        Chemistry = OTHER_BATTERY;
    }
    else if(memcmp( "RAM", Type, 4) == 0 )
    {
        Chemistry = OTHER_BATTERY;
    }

    pInstance->SetWBEMINT16( L"Chemistry", Chemistry );

    return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::GetBatteryInformation(CInstance * pInstance, BATTERY_INFORMATION & bi )
{
	HRESULT hr = WBEM_S_NO_ERROR;
	//============================================
	// Property:  
	//		DeviceID
	//		Name
	//============================================
//	pInstance->SetDWORD ( L"FullChargeCapacity", bi.FullChargeCapacity ) ;

	//============================================
	// Property:  Powermanagementcapabilities
	//============================================
    hr = SetPowerManagementCapabilities(pInstance, bi.Capabilities);
    if ( WBEM_S_NO_ERROR == hr )
    {
		//============================================
		// Property:  Chemistry
		//============================================
		hr = SetChemistry( pInstance, bi.Chemistry );
	}
	return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::GetBatteryKey( HANDLE & hBattery, CHString & chsKey, BATTERY_QUERY_INFORMATION & bqi)
{
	HRESULT hr = WBEM_E_FAILED;
   //================================================
	//  With the tag, you can query the battery info.
	//  Get the Unique Id
	//================================================
	WCHAR bi[MAX_PATH*2] = { L'\0' };
	DWORD dwOut = MAX_PATH*2;
	bqi.InformationLevel = BatteryUniqueID;
	if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_INFORMATION, &bqi, sizeof(bqi), &bi,  sizeof(bi), &dwOut, NULL)) 
	{
		//====================================
		//  Device ID
		//====================================
		chsKey = bi;
		hr = WBEM_S_NO_ERROR;
	}
	return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::GetQueryBatteryInformation(CInstance * pInstance, HANDLE & hBattery, BATTERY_QUERY_INFORMATION & bqi)
{
	HRESULT hr = WBEM_E_FAILED;
    //================================================
    //  Get the Name of the battery
    //================================================
    WCHAR bi[MAX_PATH*2];
	DWORD dwOut;
    bqi.InformationLevel = BatteryDeviceName;
    if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_INFORMATION, &bqi, sizeof(bqi),  &bi,  sizeof(bi), &dwOut, NULL)) 
    {
		pInstance->SetCHString( IDS_Name, bi ) ;
		hr = WBEM_S_NO_ERROR;
    }
	//================================================
	//  Get the Estimated Run Time
	//================================================
	bqi.InformationLevel = BatteryEstimatedTime;
	ULONG dwBi = 0;
	if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_INFORMATION, &bqi, sizeof(bqi),  &dwBi,  sizeof(ULONG), &dwOut, NULL)) 
	{
		//====================================
		//  EstimatedRunTime
		//====================================
		pInstance->SetDWORD ( L"EstimatedRunTime", (dwBi/60) ) ;
		hr = WBEM_S_NO_ERROR;
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::GetHardCodedInfo(CInstance * pInstance)
{
	HRESULT hr = WBEM_S_NO_ERROR;

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_BatteryName);

	pInstance->SetCHString ( IDS_Caption , sTemp2 ) ;
	pInstance->SetCHString ( IDS_Description , sTemp2 ) ;
	pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () );
	SetCreationClassName   ( pInstance ) ;
	pInstance->SetCharSplat( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;

    //=========================================================================
    // PowerManagementSupported
    //=========================================================================
	pInstance->Setbool(IDS_PowerManagementSupported, FALSE);
	return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::GetBatteryProperties(CInstance * pInstance, BATTERY_INFORMATION & bi, BATTERY_QUERY_INFORMATION & bqi, HANDLE & hBattery )
{
	HRESULT hr = WBEM_S_NO_ERROR;

	//=========================================================================
	//  Set the following properties:
	//		Caption
	//		Description
	//		SystemName
	//		CreationClassName
	//		SystemCreationClassName
	//		PowerManagementSupported
	//=========================================================================
	hr = GetHardCodedInfo( pInstance );
	if( WBEM_S_NO_ERROR == hr )
	{

		//============================================
		// Property: 
		//		FullChargeCapacity
		//      Powermanagementcapabilities
		//      Chemistry
		//============================================
		hr = GetBatteryInformation(pInstance, bi);
		if ( WBEM_S_NO_ERROR == hr )
		{
			//============================================
			// Property: 
			//		BatteryEstimatedTime/60
			//		DeviceID
			//		Name
			//============================================
			hr = GetQueryBatteryInformation(pInstance, hBattery, bqi );
			if ( WBEM_S_NO_ERROR == hr )
			{
				//============================================
				// Property:  
				//		Status
				//		BatteryStatus
				//		Availability
				//============================================
				hr = GetBatteryStatusInfo( pInstance, hBattery, bqi );
			}
		}
	}
	return hr;                                         
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::GetNTBattery(MethodContext * pMethodContext, CHString & chsObject, CInstance * pInstance)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	BOOL fContinue = TRUE;
	BOOL fResetHr = TRUE;

    //=========================================================================
    //  Enumerate the batteries and ask each one for info.
    //=========================================================================

    HDEVINFO hdev = SetupDiGetClassDevs((LPGUID)&GUID_DEVICE_BATTERY, 0, 0, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);

    if (hdev != INVALID_HANDLE_VALUE) 
    {
        SP_DEVICE_INTERFACE_DATA did;
        did.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        //======================================================================
        // Enumerate the battery
        //======================================================================
		int nWhich = 0;
		while( fContinue )
		{
            if (SetupDiEnumDeviceInterfaces(hdev, 0, &GUID_DEVICE_BATTERY, nWhich++, &did)) 
            {
                DWORD cbRequired = 0;
                //==============================================================
                //
                //  Ask for the required size then allocate it then fill it.
                //
                //==============================================================
                if (SetupDiGetDeviceInterfaceDetail(hdev, &did, 0, 0, &cbRequired, 0) || GetLastError() == ERROR_INSUFFICIENT_BUFFER) 
                {
                    
					PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)LocalAlloc(LPTR, cbRequired);					
                    if (pdidd) 
                    {

                        pdidd->cbSize = sizeof(*pdidd);
                        if (SetupDiGetDeviceInterfaceDetail(hdev, &did, pdidd, cbRequired, &cbRequired, 0)) 
                        {
                            //===================================================
                            //  Finally enumerated a battery.  
                            //  Ask it for information.
                            //===================================================
                            HANDLE hBattery = CreateFile(pdidd->DevicePath,  GENERIC_READ | GENERIC_WRITE,
														 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                         NULL, OPEN_EXISTING,  FILE_ATTRIBUTE_NORMAL, NULL);
                            if (hBattery != INVALID_HANDLE_VALUE) 
                            {
                                //===================================================
                                //  Now you have to ask the battery for its tag.
                                //===================================================
                                BATTERY_QUERY_INFORMATION bqi;
								memset( &bqi, NULL, sizeof(BATTERY_QUERY_INFORMATION));
                                DWORD dwWait = 0;
                                DWORD dwOut = 0;
                                bqi.BatteryTag = 0;

                                if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_TAG, &dwWait, sizeof(DWORD),
                                                    &bqi.BatteryTag, sizeof(ULONG),&dwOut, NULL) && bqi.BatteryTag) 
                                {

                                    //================================================
                                    //  With the tag, you can query the battery info.
                                    //================================================
                                    BATTERY_INFORMATION bi;
									memset( &bi, NULL, sizeof(BATTERY_INFORMATION));
                                    bqi.InformationLevel = BatteryInformation;
                                    bqi.AtRate = 0;
                                    if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_INFORMATION, &bqi, sizeof(bqi),
                                                        &bi,  sizeof(bi), &dwOut, NULL)) 
                                    {
                                        //============================================
                                        // Only system batteries count
                                        //============================================
                                        if (bi.Capabilities & BATTERY_SYSTEM_BATTERY)  
										{
											//================================================
											//  Get the Name of the battery - this is the key
											//================================================
											CHString chsKey;
											hr = GetBatteryKey( hBattery, chsKey, bqi );
											if( WBEM_S_NO_ERROR == hr )
											{
												//============================================
												//  if we are working with a specific object 
												//  here, then get its info and bail out, if
												//  it is the one we want, otherwise continue
												//  to find it
												//============================================
												if( !chsObject.IsEmpty() )
												{
													if( chsObject.CompareNoCase(chsKey) == 0 )
													{
														fContinue = FALSE;
													}
													else
													{
														continue;
													}
													hr = GetBatteryProperties(pInstance, bi, bqi, hBattery);
													if( hr == WBEM_S_NO_ERROR )
													{
														hr = pInstance->Commit ();
														fResetHr = FALSE;
													}
													break;
												}
												else
												{
												    CInstancePtr pInstance;
													pInstance.Attach(CreateNewInstance(pMethodContext));

													//====================================
													//  We are working with enumeration
													//  Get a new instance and set the key
													//====================================
													pInstance->SetCHString( IDS_DeviceID,chsKey) ;
													hr = GetBatteryProperties(pInstance, bi, bqi, hBattery);
													if( hr == WBEM_S_NO_ERROR )
													{
														hr = pInstance->Commit ();
														fResetHr = TRUE;
													}
												}
											}
                                        }
                                    }
                                } 
                                CloseHandle(hBattery);
                            } 
						} 
						LocalFree(pdidd);
                    }
                }
            } 
			else 
			{
                // Enumeration failed - perhaps we're out of items
                if (GetLastError() == ERROR_NO_MORE_ITEMS)
				{
					if( fResetHr )
					{
						hr = WBEM_S_NO_ERROR;
					}
				}
				fContinue = FALSE;
            }
        }
        SetupDiDestroyDeviceInfoList(hdev);
    }
    return hr;
}


#endif

//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::GetBattery ( CInstance *pInstance )
{
	HRESULT hr;

	SYSTEM_POWER_STATUS Info ;

	BOOL bRetCode = GetSystemPowerStatus(&Info) ;
	if ( ( bRetCode ) && ( ( Info.BatteryFlag & 128 ) == 0 ) )
	{
		pInstance->SetCharSplat(IDS_Status,  Info.ACLineStatus == 0 ? IDS_STATUS_OK :Info.ACLineStatus == 1 ? IDS_STATUS_OK : IDS_STATUS_Unknown		);
		pInstance->SetWBEMINT16(IDS_Availability, 3);

		DWORD dwStatus;

		// The cim status values don't map exactly to the win32 api's.

		if ( Info.BatteryFlag == 255 )
		{
			dwStatus = 2;
		}
		else if ((Info.BatteryFlag & (0x8 | 0x1)) == (0x8 | 0x1))
		{
			dwStatus = 7;
		}
		else if ((Info.BatteryFlag & (0x8 | 0x2)) == (0x8 | 0x2))
		{
			dwStatus = 8;
		}
		else if ((Info.BatteryFlag & (0x8 | 0x4)) == (0x8 | 0x4))
		{
			dwStatus = 9;
		}
		else if (Info.BatteryFlag & 1)
		{
			dwStatus = 3;
		}
		else if (Info.BatteryFlag & 2)
		{
			dwStatus = 4;
		}
		else if (Info.BatteryFlag & 4)
		{
			dwStatus = 5;
		}
		else if (Info.BatteryFlag & 8)
		{
			dwStatus = 6;
		}
		else
		{
			dwStatus = 2;
		}

		pInstance->SetWBEMINT16 ( L"BatteryStatus", dwStatus ) ;
		if (Info.BatteryLifeTime != 0xFFFFFFFF)		//0xFFFFFFFF means that actual value is unknown
		{
			pInstance->SetDWORD ( L"EstimatedRunTime", (Info.BatteryLifeTime/60) ) ;	//EstimatedRunTime is in minutes but Info.BatteryLifeTime is in seconds, so converted into minutes
		}
		pInstance->SetWBEMINT16 ( L"EstimatedChargeRemaining" , Info.BatteryLifePercent ) ;

        CHString sTemp2;
        LoadStringW(sTemp2, IDR_BatteryName);

		pInstance->SetCHString ( IDS_Name ,sTemp2 ) ;
		pInstance->SetCharSplat ( IDS_DeviceID , IDS_BatteryName ) ;
		pInstance->SetCHString ( IDS_Caption , sTemp2 ) ;
		pInstance->SetCHString ( IDS_Description , sTemp2 ) ;
		pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () );
		SetCreationClassName ( pInstance ) ;
		pInstance->SetCharSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;

		hr = WBEM_S_NO_ERROR ;

	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\battery.h ===
//=================================================================

//

// Battery.h

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

// Property set identification
//=============================

#define PROPSET_NAME_BATTERY L"Win32_Battery"

class CBattery:public Provider 
{
    public:

        // Constructor/destructor
        //=======================

        CBattery(const CHString& name, LPCWSTR pszNamespace) ;
       ~CBattery() ;

        // Functions provide properties with current values
        //=================================================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);

        // Utility function(s)
        //====================
#ifdef NTONLY
		HRESULT GetNTBattery(MethodContext * pMethodContext, CHString & chsKey, CInstance * pInst);
		HRESULT GetBatteryProperties(CInstance * pInstance, BATTERY_INFORMATION & bi, BATTERY_QUERY_INFORMATION & bqi, HANDLE & hBattery );
		HRESULT GetHardCodedInfo(CInstance * pInst);
		HRESULT GetQueryBatteryInformation(CInstance * pInst, HANDLE & hBattery, BATTERY_QUERY_INFORMATION & bqi);
		HRESULT GetBatteryKey( HANDLE & hBattery, CHString & chsKey, BATTERY_QUERY_INFORMATION & bqi);
		HRESULT SetChemistry(CInstance * pInst, UCHAR * Type);
		HRESULT SetPowerManagementCapabilities(CInstance * pInst, ULONG Capabilities);
		HRESULT GetBatteryStatusInfo(CInstance * pInst, HANDLE & hBattery, BATTERY_QUERY_INFORMATION & bqi);
		HRESULT GetBatteryInformation(CInstance * pInstance, BATTERY_INFORMATION & bi );
#endif
        HRESULT GetBattery(CInstance *pInstance);

	private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\bus.h ===
//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

//                            

//                         All Rights Reserved

//

// This software is furnished under a license and may be used and copied

// only in accordance with the terms of such license and with the inclusion

// of the above copyright notice.  This software or any other copies thereof

// may not be provided or otherwise  made available to any other person.  No

// title to and ownership of the software is hereby transferred.





//=================================================================

//

// bus.h -- Bus property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/11/98    a-kevhu         Created
//
//=================================================================
#ifndef _BUS_H_
#define _BUS_H_

class CWin32Bus;
class CBusList;


class CBusInfo
{
public:
    CHString chstrBusDeviceID,
             chstrBusPNPDeviceID;
};

class CBusList
{
public:

    CBusList()
    {
        GenerateBusList();
    }
        
    ~CBusList()
    {
    }

    BOOL FoundPCMCIABus();
    BOOL AlreadyAddedToList(LPCWSTR szItem);
    LONG GetListSize() { return m_vecpchstrList.size(); }

    BOOL GetListMemberDeviceID(LONG lPos, CHString& chstrMember)
    {
        if (lPos >= 0L && lPos < m_vecpchstrList.size())
        {
            chstrMember = m_vecpchstrList[lPos].chstrBusDeviceID;
            return TRUE;
        }

        return FALSE;
    }

    BOOL GetListMemberPNPDeviceID(LONG lPos, CHString& chstrMember)
    {
        if (lPos >= 0L && lPos < m_vecpchstrList.size() &&
            !m_vecpchstrList[lPos].chstrBusPNPDeviceID.IsEmpty())
        {
            chstrMember = m_vecpchstrList[lPos].chstrBusPNPDeviceID;
            
            return TRUE;
        }

        return FALSE;
    }

    LONG GetIndexInListFromDeviceID(LPCWSTR szDeviceID)
    {
        LONG lRet = -1L;
        
        for (LONG m = 0L; m < m_vecpchstrList.size(); m++)
        {
            if (m_vecpchstrList[m].chstrBusDeviceID.CompareNoCase(szDeviceID) == 0L)
            {
               lRet = m;
               break;
            }
        }

        return lRet;
    }

protected:

    void GenerateBusList(); 
    void AddBusToList(LPCWSTR szDeviceID, LPCWSTR szPNPID);

    std::vector<CBusInfo> m_vecpchstrList;
};



class CWin32Bus : public Provider 
{
public:
    // Constructor/destructor
    CWin32Bus(LPCWSTR name, LPCWSTR pszNamespace);
    ~CWin32Bus() ;

    // Functions provide properties with current values
    virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
    virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0);

private:
    // Utility function(s)
    HRESULT SetCommonInstance(CInstance* pInstance, BOOL fEnum);
    BOOL GetBusTypeNumFromStr(LPCWSTR szType, DWORD* pdwTypeNum);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\bus.cpp ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// bus.h -- Bus property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/11/98    a-kevhu         Created
//
//============================================================================


#include "precomp.h"
#include <cregcls.h>
#include <comdef.h>
#include <vector>
#include <assertbreak.h>
#include "bus.h"
#include "resource.h"

// Property set declaration
CWin32Bus MyBusSet(IDS_Win32_Bus, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Bus::CWin32Bus
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32Bus::CWin32Bus(
	LPCWSTR setName,
	LPCWSTR pszNamespace) :
    Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Bus::~CWin32Bus
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32Bus::~CWin32Bus()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Bus::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Bus::GetObject(

	CInstance *pInstance,
    long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHString chsDeviceID;
	pInstance->GetCHString(IDS_DeviceID, chsDeviceID);
	chsDeviceID.MakeUpper();

    CBusList cbl;
    if (cbl.AlreadyAddedToList(chsDeviceID))
    {
        // It is a bus that really does exist, so...
        // Get instance data that is not platform specific.
        hr = SetCommonInstance(pInstance, FALSE);
        if (SUCCEEDED(hr))
        {
            // Set instance specific info:
            LONG lPos = cbl.GetIndexInListFromDeviceID(chsDeviceID);

            if (lPos != -1)
            {
	            CHString chstrTmp;

                // Set the PNPDeviceID if we have one:

                if (cbl.GetListMemberPNPDeviceID(lPos, chstrTmp))
                {
                    pInstance->SetCHString(IDS_PNPDeviceID, chstrTmp);
                }
            }
        }
	}
	else
	{
		if ( ERROR_ACCESS_DENIED == ::GetLastError() )
		{
			hr = WBEM_E_ACCESS_DENIED;
		}
		else
		{
			hr = WBEM_E_NOT_FOUND;
		}
	}

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Bus::EnumerateInstances
 *
 *  DESCRIPTION : Supplies all instances of CWin32Bus
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Bus::EnumerateInstances(

	MethodContext *pMethodContext,
    long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_S_NO_ERROR;
    std::vector<CHString*> vecchsBusList;

    // Make a list of buses:
    CBusList cbl;
    LONG     lSize = cbl.GetListSize();

    // Set all the data for each bus
    for (LONG m = 0L;(m < lSize && SUCCEEDED(hr)); m ++)
    {
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
		CHString     chstrTmp;

        // Set bus data
		if (cbl.GetListMemberDeviceID(m, chstrTmp))
		{
			pInstance->SetCHString(IDS_DeviceID, chstrTmp);

            // Set the PNPDeviceID if we have one:
			if (cbl.GetListMemberPNPDeviceID(m, chstrTmp))
			{
				pInstance->SetCHString(IDS_PNPDeviceID, chstrTmp);
			}

			hr = SetCommonInstance(pInstance, TRUE);
			if (SUCCEEDED(hr))
			{
				hr = pInstance->Commit();
			}
        }
    }

    // Machine must have at least one bus, or something is seriously wrong
    if (lSize == 0)
    {
		if ( ERROR_ACCESS_DENIED == ::GetLastError() )
		{
			hr = WBEM_E_ACCESS_DENIED;
		}
		else
		{
			hr = WBEM_E_FAILED;
		}
    }

	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Bus::GetCommonInstance
 *
 *  DESCRIPTION : Assigns instance values common to all platforms
 *
 *  INPUTS      : pInstance, pointer to instance of interest
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Bus::SetCommonInstance(

	CInstance *pInstance,
	BOOL fEnum
)
{
    // Only do so if it really exists, however!
    CHString chsTemp;

    pInstance->GetCHString(IDS_DeviceID, chsTemp);
	chsTemp.MakeUpper();

    if (!fEnum) // redundant to check the following if this is an enum
    {
        CBusList cbl;

        if (!cbl.AlreadyAddedToList(chsTemp))
        {
            return WBEM_E_NOT_FOUND;
        }
    }

    // Set properties inherited from CIM_LogicalDevice
    CHString sTemp2;
    LoadStringW(sTemp2, IDR_Bus);

    pInstance->SetCHString(IDS_Caption, sTemp2);
    SetCreationClassName(pInstance);  // Method of Provider class
    pInstance->SetCHString(IDS_Description, sTemp2);
    pInstance->SetCHString(IDS_Name, sTemp2);
    pInstance->SetCharSplat(
		IDS_SystemCreationClassName,
        IDS_Win32ComputerSystem);

    pInstance->SetCHString(IDS_SystemName, GetLocalComputerName());

    // Set properties of this class(not derived from CIM_LogicalDevice)
    if (chsTemp.Find(IDS_BUS_DEVICEID_TAG) != -1)
    {
        CHString chsNum =
                    chsTemp.Right(chsTemp.GetLength() - chsTemp.Find(IDS_BUS_DEVICEID_TAG) -
                        (sizeof(IDS_BUS_DEVICEID_TAG) / sizeof(TCHAR) - 1));
		DWORD    dwNum = _wtol(chsNum);

        pInstance->SetDWORD(IDS_BusNum, dwNum);

        CHString chsType = chsTemp.Left(chsTemp.Find(L"_"));

	    DWORD dwBusTypeNum;

        if (!GetBusTypeNumFromStr(chsType, &dwBusTypeNum))
        {
            return WBEM_E_NOT_FOUND;
        }

        pInstance->SetDWORD(IDS_BusType, dwBusTypeNum);
    }

    return WBEM_S_NO_ERROR;
}

/*****************************************************************************
 *
 *  FUNCTION    : CBusList::GenerateBusList
 *
 *  DESCRIPTION : helper to generate a list of busses.
 *
 *  INPUTS      : pInstance, pointer to instance of interest
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

// This was added because some old 9x machines only have one of the last two
// buses.
static LPWSTR GetBusTypeFromString(LPCWSTR szDescription)
{
    if (!_wcsicmp(szDescription, L"PCI BUS"))
        return szBusType[5];
    else if (!_wcsicmp(szDescription, L"EISA BUS"))
        return szBusType[2];
    else if (!_wcsicmp(szDescription, L"ISA PLUG AND PLAY BUS"))
        return szBusType[1];
    else
        return NULL;
}


void CBusList::AddBusToList(LPCWSTR szDeviceID, LPCWSTR szPNPID)
{
    ASSERT_BREAK(szDeviceID != NULL);

    // Then check if the bus is in our list yet,
    if (!AlreadyAddedToList(szDeviceID))
    {
        CBusInfo bus;

        bus.chstrBusDeviceID = szDeviceID;

        if (szPNPID)
            bus.chstrBusPNPDeviceID = szPNPID;

        // and add it if not.
        m_vecpchstrList.push_back(bus);
    }
}

void CBusList::GenerateBusList()
{
	CConfigManager cfgmgr;
	CDeviceCollection devlist;

    if (cfgmgr.GetDeviceList(devlist))
    {
        REFPTR_POSITION pos;

        if (devlist.BeginEnum(pos))
        {
            CConfigMgrDevicePtr pDevice;

            for (pDevice.Attach(devlist.GetNext(pos));
                pDevice != NULL;
                pDevice.Attach(devlist.GetNext(pos)))
            {
                // First check to see whether this was a PCI bus connected to
				// another bus.
				// Look at the name of pDevice.  If the name is found via
                // GetBusTypeFromString set pDevice's DeviceID with
                // pcbi->chstrBusPNPDeviceID.  Set the DeviceID for win32_bus
                // as PCI_BUS_n, where n is the last number of the
                // config manager device id.

				CHString chstrName;

                if (pDevice->GetDeviceDesc(chstrName))
				{
				    LPWSTR szBusName = GetBusTypeFromString(chstrName);

                    if (szBusName)
					{
						CHString strPNPID;

						if (pDevice->GetDeviceID(strPNPID))
						{
							LONG m = strPNPID.ReverseFind('\\');

							if (m != -1 && m != strPNPID.GetLength() - 1) // in case the last char was a '/'
							{
								CHString chstrBusNum = strPNPID.Mid(m + 1),
                                         strDeviceID;

    							strDeviceID.Format(
									L"%s%s%s",
									szBusName,
									IDS_BUS_DEVICEID_TAG,
									(LPCWSTR) chstrBusNum);

								AddBusToList(strDeviceID, strPNPID);
                            }
						}
					}
                }

				// Then continue generating the rest of the bus list by looking
				// at devices hanging off of busses:

				INTERFACE_TYPE itBusType;  //chwres.h

				// Initialize variables

				DWORD dwBusNumber = 0xFFFFFFFF;

				// For each device, need its bus info.

				if (pDevice->GetBusInfo(& itBusType, & dwBusNumber))
				{
					if (dwBusNumber == 0xFFFFFFFF || itBusType < 0 ||
                        itBusType >= KNOWN_BUS_TYPES)
					{
						// We didn't get the bus number, or it was
						// out of range.
						continue;
					}

					// Make what will be the DeviceID:

					CHString chsBusType;

					if (StringFromInterfaceType(itBusType, chsBusType))
					{
					    CHString strDeviceID;

                        strDeviceID.Format(
							L"%s%s%d",
							(LPCWSTR) chsBusType,
							IDS_BUS_DEVICEID_TAG,
							dwBusNumber);

						AddBusToList(strDeviceID, NULL);
					}
				}

                devlist.EndEnum();
            }
        }
    }

#ifdef NTONLY
    // Have seen some machines with PCMCIA busses that don't get picked up
    // via the method above(using ConfigMgr) on NT4 and NT5.  Therefore, we
    // need to examine the registry.  However, it a PCMCIA bus has been
    // added to the list at this point, don't bother with this hacked approach.

	if (!FoundPCMCIABus())
	{
	    CRegistry reg;

		// If the key below exists, we assume a PCMCIA bus exist.

		DWORD dwErr = reg.Open(
        		HKEY_LOCAL_MACHINE,
				L"HARDWARE\\DESCRIPTION\\System\\PCMCIA PCCARDS",
				KEY_READ);

		if (dwErr == ERROR_SUCCESS)
		{
			// A PCMCIA bus exists.
			// Make what will be the DeviceID(hardwired in this case):
            CHString strDeviceID;

		    strDeviceID.Format(
				L"%s%s%d",
				L"PCMCIA",
				IDS_BUS_DEVICEID_TAG,
				0);

    		AddBusToList(strDeviceID, NULL);
        }
    }
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Bus::GetBusTypeNumFromStr
 *
 *  DESCRIPTION : Assigns instance values common to all platforms
 *
 *  INPUTS      : pInstance, pointer to instance of interest
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32Bus::GetBusTypeNumFromStr(
	LPCWSTR szType,
	DWORD *pdwTypeNum)
{
	// March through list of possibilities and return appropriate value:

	for (DWORD m = 0; m < KNOWN_BUS_TYPES; m++)
	{
        if (!_wcsicmp(szType, szBusType[m]))
		{
			*pdwTypeNum = m;
			return TRUE;
		}
	}

    return FALSE;
}


/*****************************************************************************
 *
 *  FUNCTION    : CWin32Bus::AlreadyAddedToList
 *
 *  DESCRIPTION : Internal helper to check if item was added to list
 *
 *  INPUTS      : pInstance, pointer to instance of interest
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CBusList::AlreadyAddedToList(LPCWSTR szItem)
{
    for (LONG m = 0; m < m_vecpchstrList.size(); m ++)
    {
        if (!_wcsicmp(m_vecpchstrList[m].chstrBusDeviceID, szItem))
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Bus::FoundPCMCIABus
 *
 *  DESCRIPTION : Internal helper to see if we have a PCMCIA bus
 *
 *  INPUTS      : pInstance, pointer to instance of interest
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CBusList::FoundPCMCIABus()
{
    // Need to look through our list of busses and see if any start with
    // the text PCMCIA.  If so, return true.
    for (LONG m = 0; m < m_vecpchstrList.size(); m ++)
    {
        if (wcsstr(m_vecpchstrList[m].chstrBusDeviceID, L"PCMCIA"))
        {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\cadapters.cpp ===
//=================================================================

//

// CAdapters.CPP -- adapter configuration retrieval

//

//  Copyright (c) 1998-2002 Microsoft Corporation, All Rights Reserved
//
//
// Revisions:	09/15/98	        Created
//
//				03/03/99    		Added graceful exit on SEH and memory failures,
//											syntactic clean up

//=================================================================
#include "precomp.h"

#ifndef MAX_INTERFACE_NAME_LEN
#define MAX_INTERFACE_NAME_LEN  256
#endif

#include <iphlpapi.h>
#include <winsock.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <devioctl.h>
#include "wsock32api.h"

#include "ntddtcp.h"
#include "CAdapters.h"
#include <..\..\framework\provexpt\include\provexpt.h>

#define INV_INADDR_LOOPBACK 0x0100007f

/*******************************************************************
    NAME:       CAdapters

    SYNOPSIS:   construction and cleanup for this class

	ENTRY:

    HISTORY:
                  03-sep-1998     Created
********************************************************************/
CAdapters::CAdapters() 
{
	GetAdapterInstances() ;
}

//
CAdapters::~CAdapters()
{
	_ADAPTER_INFO *t_pchsDel;

	for( int t_iar = 0; t_iar < GetSize(); t_iar++ )
	{
		if( t_pchsDel = (_ADAPTER_INFO*) GetAt( t_iar ) )
		{
			delete t_pchsDel ;
		}
	}
}


/*******************************************************************
    NAME:       GetAdapterInstances

    SYNOPSIS:   retrives information on adapters present in the system

    HISTORY:
                  03-sep-1998     Created
                  01-Aug-2002     Modifed to use GetAdapterInfo
********************************************************************/
void CAdapters::GetAdapterInstances()
{
	_ADAPTER_INFO *t_pAdapterInfo  = NULL ;

    ULONG OutBufLen=0;
    PIP_ADAPTER_INFO pAdapterInfo=NULL;

    if (GetAdaptersInfo(pAdapterInfo, &OutBufLen) == ERROR_BUFFER_OVERFLOW)
	{
		pAdapterInfo=(PIP_ADAPTER_INFO)new (BYTE[OutBufLen]);
    }
    else if (0 == OutBufLen ) 
    {
        return;
    }

    if( !pAdapterInfo )
    {
        throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR );
    }

    std::auto_ptr <IP_ADAPTER_INFO> _1(pAdapterInfo);

    if (GetAdaptersInfo(pAdapterInfo, &OutBufLen) != ERROR_SUCCESS)
    {
        return;
    }

    PIP_ADAPTER_INFO lAdapterInfo = pAdapterInfo;

	while( lAdapterInfo )
	{
        std::auto_ptr <_ADAPTER_INFO> AutoAdapter(new _ADAPTER_INFO);
        t_pAdapterInfo = AutoAdapter.get();

        // Add the IP bound adapters to our list
        if( !t_pAdapterInfo )
        {
            throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
        }

        if( !GetTCPAdapter((_ADAPTER_INFO*)t_pAdapterInfo , lAdapterInfo ))
        {
            break;
        }

        Add( t_pAdapterInfo );
        AutoAdapter.release();

        lAdapterInfo = lAdapterInfo->Next;
	}

	return ;
}

BOOL CAdapters::GetTCPAdapter(_ADAPTER_INFO *a_pAdapterInfo, PIP_ADAPTER_INFO lAdapterInfo )
{
    BOOL	t_fRes      = FALSE ;
    DWORD   dwMetric    = 0xFFFFFFFFL;

	a_pAdapterInfo->Description   = CHString(lAdapterInfo->Description);
    a_pAdapterInfo->Interface     = CHString(lAdapterInfo->AdapterName);
    a_pAdapterInfo->AddressLength = lAdapterInfo->AddressLength;

    if(a_pAdapterInfo->AddressLength)
    {
        memcpy( &a_pAdapterInfo->Address, &lAdapterInfo->Address, a_pAdapterInfo->AddressLength ) ;
    }

    a_pAdapterInfo->Index = (UINT)lAdapterInfo->Index ;
	a_pAdapterInfo->Type = (UINT)lAdapterInfo->Type ;

    #if NTONLY >= 5

    PBYTE   pbBuff                  = NULL;
    DWORD dwErrGetIPForwardTable    = -1L;
    DWORD dwRoutTableBufSize        = 0L;
    PMIB_IPFORWARDTABLE pmibft      = NULL;

    dwErrGetIPForwardTable = ::GetIpForwardTable(
        NULL,
        &dwRoutTableBufSize,
        TRUE);

    if(dwErrGetIPForwardTable == ERROR_INSUFFICIENT_BUFFER)
    {
        pbBuff = new BYTE[dwRoutTableBufSize];
        pmibft = (PMIB_IPFORWARDTABLE) pbBuff;

        dwErrGetIPForwardTable = ::GetIpForwardTable(
            pmibft,
            &dwRoutTableBufSize,
            TRUE);
    }

    std::auto_ptr <BYTE> _1(pbBuff);

    #endif

    PIP_ADDR_STRING pIpAddresses = &(lAdapterInfo->IpAddressList);

    if(pIpAddresses)
    {
        a_pAdapterInfo->IPEnabled = TRUE;
    }

    while(pIpAddresses)
    {

        #if NTONLY >= 5
        {
            if(dwErrGetIPForwardTable == ERROR_SUCCESS)
            {
                GetRouteCostMetric(
                    IpStringToDword(pIpAddresses->IpAddress.String),
                    pmibft, 
                    &dwMetric);
            }
        }
        #endif                            

        _IP_INFO *t_pIPInfo = pAddIPInfo(	IpStringToDword(pIpAddresses->IpAddress.String),
											IpStringToDword(pIpAddresses->IpMask.String),
											pIpAddresses->Context,
                                            dwMetric ) ;
		if( !t_pIPInfo )
		{
			return t_fRes;
		}

		// add to the IP array for this adapter
		a_pAdapterInfo->aIPInfo.Add( t_pIPInfo ) ;

        pIpAddresses = pIpAddresses->Next;
    }

    #if NTONLY >= 5
    if(dwErrGetIPForwardTable == ERROR_SUCCESS)
    {    
        for(int x = 0; x < pmibft->dwNumEntries; x++)
        {
            if(pmibft->table[x].dwForwardMask == INADDR_ANY)
			{
				if(lAdapterInfo->Index == (UINT) pmibft->table[x].dwForwardIfIndex)
				{
					if(MIB_IPROUTE_TYPE_INVALID !=
                        pmibft->table[x].dwForwardType)
                    {
                        _IP_INFO *pGateway = pAddIPInfo(
                            pmibft->table[x].dwForwardNextHop,
							INADDR_ANY,
							0,
							pmibft->table[x].dwForwardMetric1);

						if(!pGateway)
						{
							return t_fRes;
						}
                        else
                        {
                            // add to the gateway array
							a_pAdapterInfo->aGatewayInfo.Add(pGateway);
                        }					            
                    }
				}
			}    
        }    
    }
    #endif

    GetIPXMACAddress(a_pAdapterInfo, lAdapterInfo->Address);

    return TRUE;
}

/*******************************************************************
    NAME:       pAddIPInfo

    SYNOPSIS:   Allocates a _IP_INFO class, and populates it with the input parameters

	ENTRY:      DWORD dwIPAddr	:
				DWORD dwIPMask	:
				DWORD dwContext	:

	EXIT    _IP_INFO* - the created IPInfo class

    RETURNS Success - pointer to allocated class
            Failure - NULL

    HISTORY:
                  14-sep-1998     Created
********************************************************************/
_IP_INFO* CAdapters::pAddIPInfo( DWORD a_dwIPAddr, DWORD a_dwIPMask, DWORD a_dwContext, DWORD a_dwCostMetric )
{
	_IP_INFO *t_pIPInfo = new _IP_INFO;

	if( !t_pIPInfo )
	{
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	// IP address
	t_pIPInfo->dwIPAddress = a_dwIPAddr;
	t_pIPInfo->chsIPAddress.Format( L"%d.%d.%d.%d",
		t_pIPInfo->bIPAddress[ 0 ], t_pIPInfo->bIPAddress[ 1 ],
		t_pIPInfo->bIPAddress[ 2 ], t_pIPInfo->bIPAddress[ 3 ] );

	// IP mask
	t_pIPInfo->dwIPMask = a_dwIPMask;
	t_pIPInfo->chsIPMask.Format( L"%d.%d.%d.%d",
		t_pIPInfo->bIPMask[ 0 ], t_pIPInfo->bIPMask[ 1 ],
		t_pIPInfo->bIPMask[ 2 ], t_pIPInfo->bIPMask[ 3 ] );

	// hold on to the context ID
	t_pIPInfo->dwContext = a_dwContext;

	// hold on to the context ID
	t_pIPInfo->dwCostMetric = a_dwCostMetric;

	return t_pIPInfo ;
}

/*******************************************************************
    NAME:       GetIPXMACAddress

    SYNOPSIS:   Retrieves the mac address for an adapter via the IPX sockets interface

    ENTRY:      DWORD dwIndex	:
				_ADAPTER_INFO* a_pAdapterInfo	:

    HISTORY:
                  03-sep-1998     Created
********************************************************************/
BOOL CAdapters::GetIPXMACAddress( _ADAPTER_INFO *a_pAdapterInfo, BYTE a_bMACAddress[ 6 ] )
{
	BOOL t_fRet = FALSE ;

	CWsock32Api *t_pwsock32api = (CWsock32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidWsock32Api, NULL);
	if ( t_pwsock32api )
	{
		CHString		t_chsAddress ;
		CHString		t_chsNum ;
		WSADATA			t_wsaData ;
		int				t_res,
						t_cbOpt,
						t_cbAddr = sizeof( SOCKADDR_IPX  ) ;
		SOCKADDR_IPX	t_Addr ;

		// guarded resource
		SOCKET			t_s = INVALID_SOCKET ;

		if( !t_pwsock32api->WsWSAStartup( 0x0101, &t_wsaData ) )
		{
			try
			{
				// Create IPX socket.
				t_s = t_pwsock32api->Wssocket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX  ) ;

				if( INVALID_SOCKET != t_s )
				{
					// Socket must be bound prior to calling IPX_MAX_ADAPTER_NUM.
					memset( &t_Addr, 0, sizeof( t_Addr ) ) ;
					t_Addr.sa_family = AF_IPX ;

					t_res = t_pwsock32api->Wsbind( t_s, (SOCKADDR*) &t_Addr, t_cbAddr ) ;

					int t_cIndex = 0 ;

					do
					{
						IPX_ADDRESS_DATA  t_IpxData ;

						memset( &t_IpxData, 0, sizeof( t_IpxData ) ) ;

						// Specify which adapter to check.
						t_IpxData.adapternum = t_cIndex ;
						t_cbOpt = sizeof( t_IpxData  ) ;

						// Get information for the current adapter.
						t_res = t_pwsock32api->Wsgetsockopt( t_s,
											NSPROTO_IPX,
											IPX_ADDRESS,
											(char*) &t_IpxData,
											&t_cbOpt ) ;

						// end of adapter array
						if ( t_res != 0 || t_IpxData.adapternum != t_cIndex )
						{
							break;
						}

						// is this the right adapter?
						bool t_fRightAdapter = true ;

						for( int t_j = 0; t_j < 6; t_j++ )
						{
							if( a_bMACAddress[ t_j ] != t_IpxData.nodenum[ t_j ] )
							{
								t_fRightAdapter = false ;
							}
						}

						if( t_fRightAdapter )
						{
							// IpxData contains the address for the current adapter.
							int t_i;
							for ( t_i = 0; t_i < 4; t_i++ )
							{
								t_chsNum.Format( L"%02X", t_IpxData.netnum[ t_i ] ) ;
								t_chsAddress += t_chsNum ;
							}
							t_chsAddress += _T(":" ) ;

							for ( t_i = 0; t_i < 5; t_i++ )
							{
								t_chsNum.Format( L"%02X", t_IpxData.nodenum[ t_i ] ) ;
								t_chsAddress += t_chsNum ;
							}

							t_chsNum.Format( L"%02X", t_IpxData.nodenum[ t_i ] ) ;
							t_chsAddress += t_chsNum ;

							a_pAdapterInfo->IPXAddress = t_chsAddress;
                            a_pAdapterInfo->IPXEnabled = TRUE;

							t_fRet = true ;

							break;
						}
					}
					while( ++t_cIndex  ) ;

				}

			}
			catch( ... )
			{
				if( INVALID_SOCKET != t_s )
				{
					t_pwsock32api->Wsclosesocket( t_s ) ;
				}
				t_pwsock32api->WsWSACleanup() ;

				CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWsock32Api, t_pwsock32api);

				throw ;
			}

			if ( t_s != INVALID_SOCKET )
			{
				t_pwsock32api->Wsclosesocket( t_s ) ;
				t_s = INVALID_SOCKET ;
			}

			t_pwsock32api->WsWSACleanup() ;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWsock32Api, t_pwsock32api);
	}
	return t_fRet ;
}

#if NTONLY >= 5
void CAdapters::GetRouteCostMetric(
    DWORD dwIPAddr, 
    PMIB_IPFORWARDTABLE pmibft, 
    PDWORD pdwMetric)
{
    DWORD dwMin = 0xFFFFFFFF;

    for(int x = 0; x < pmibft->dwNumEntries; x++)
    {
		if(dwIPAddr == (UINT) pmibft->table[x].dwForwardDest)
        {
            if(pmibft->table[x].dwForwardNextHop == INV_INADDR_LOOPBACK)
			{  
				if(MIB_IPROUTE_TYPE_INVALID !=
                    pmibft->table[x].dwForwardType)
                {
					if(pmibft->table[x].dwForwardMetric1 <
                        dwMin)
                    {
                        dwMin = pmibft->table[x].dwForwardMetric1;
                    }
                }
            }
        }
    }

    *pdwMetric = dwMin;    
}
#endif

/*******************************************************************
    NAME:       _ADAPTER_INFO

    SYNOPSIS:   cleanup for this class

	ENTRY:

    HISTORY:
                  15-sep-1998     Created
********************************************************************/
_ADAPTER_INFO::_ADAPTER_INFO()
{
	AddressLength	= 0;
	memset( &Address, 0, MAX_ADAPTER_ADDRESS_LENGTH ) ;
	Index			= 0 ;
	Type			= 0 ;
	IPEnabled		= FALSE ;
	IPXEnabled	= FALSE ;
	Marked		= FALSE ;
}

_ADAPTER_INFO::~_ADAPTER_INFO()
{
	_IP_INFO *t_pchsDel ;

	for( int t_iar = 0; t_iar < aIPInfo.GetSize(); t_iar++ )
		if( ( t_pchsDel = (_IP_INFO*)aIPInfo.GetAt( t_iar ) ) )
			delete t_pchsDel ;

	for( t_iar = 0; t_iar < aGatewayInfo.GetSize(); t_iar++ )
	{
		if( ( t_pchsDel = (_IP_INFO*)aGatewayInfo.GetAt( t_iar ) ) )
		{
			delete t_pchsDel ;
		}
	}
}

/*******************************************************************
    NAME:       vMark, fIsMarked

    SYNOPSIS:   marks or reports on an instance of the adapter for tracking purposes

    HISTORY:
                  30-sep-1998     Created
********************************************************************/
void _ADAPTER_INFO::Mark()
{ Marked = TRUE; }

BOOL _ADAPTER_INFO::IsMarked()
{ return Marked; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\bservice.cpp ===
//=================================================================
//
// Service.CPP --Service property set provider (Windows NT only)
//
//  Copyright (c) 1996-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//
//=================================================================

#include "precomp.h"

#include "bservice.h"
#include "computersystem.h"

#include <computerAPI.h>

#define IMP_DOMAIN NULL
#define IMP_USER NULL
#define IMP_PASSWORD NULL

Win32_BaseService BaseService (PROPSET_NAME_BASESERVICE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : Win32_BaseService::Win32_BaseService
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Win32_BaseService::Win32_BaseService (

	const CHString &name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_BaseService::~Win32_BaseService
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/

Win32_BaseService::~Win32_BaseService()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Process ::DeleteInstance
 *
 *  DESCRIPTION : Deletes an instance of a class
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_BaseService:: DeleteInstance (

	const CInstance &a_Instance,
	long a_Flags /*= 0L*/
)
{
#ifdef NTONLY
	HRESULT t_Result = S_OK ;

	CHString t_Name ;
	if ( a_Instance.GetCHString ( IDS_Name, t_Name ) && ! t_Name.IsEmpty () )
	{
		SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
		if ( t_ServiceControlManager )
		{
			SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_Name , DELETE ) ;
			if ( t_Service )
			{
				BOOL t_ReturnCode = DeleteService ( t_Service ) ;

				if ( !t_ReturnCode )
				{
					t_Result = GetServiceResultCode () ;
				}
			}
			else
			{
				t_Result = GetServiceResultCode() ;
			}
		}
		else
		{
			t_Result = GetServiceResultCode () ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : Process::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_BaseService::ExecMethod (

	const CInstance& a_Instance,
	const BSTR a_MethodName,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long a_Flags /*= 0L*/
)
{
#ifdef NTONLY
	if ( ! a_OutParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

   // Do we recognize the method?

	if ( _wcsicmp ( a_MethodName , METHOD_NAME_START ) == 0 )
	{
		return ExecStart ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_STOP ) == 0 )
	{
		return ExecStop ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_PAUSE ) == 0 )
	{
		return ExecPause ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_RESUME ) == 0 )
	{
		return ExecResume ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_INTERROGATE ) == 0 )
	{
		return ExecInterrogate ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_USERCONTROLSERVICE ) == 0)
	{
		return ExecUserControlService ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_CREATE ) == 0)
	{
		return ExecCreate ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_CHANGE ) == 0)
	{
		return ExecChange ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_CHANGESTARTMODE ) == 0)
	{
		return ExecChangeStartMode ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_DELETE ) == 0)
	{
		return ExecDelete ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else
	{
		return WBEM_E_INVALID_METHOD;
	}
#endif
}


#ifdef NTONLY
HRESULT Win32_BaseService :: GetServiceStatus (

	const CInstance& a_Instance,
	CHString &a_Name ,
	DWORD &a_State ,
	bool &a_AcceptPause ,
	bool &a_AcceptStop
)
{
	HRESULT t_Result = S_OK ;

	CHString t_Path ;
	CHString t_Prop ( L"__RELPATH" ) ;

	if ( a_Instance.GetCHString ( t_Prop ,  t_Path ) )
	{
		CHString strNamespace ( IDS_CimWin32Namespace ) ;

		DWORD t_BuffSize = MAX_COMPUTERNAME_LENGTH + 1 ;
		TCHAR t_ComputerName [ MAX_COMPUTERNAME_LENGTH + 1 ] ;

		ProviderGetComputerName ( t_ComputerName , &t_BuffSize ) ;

		CHString ComputerName ( t_ComputerName ) ;
		CHString t_AbsPath = L"\\\\" + ComputerName + L"\\" + strNamespace + L":" + t_Path ;

		CInstancePtr t_ObjectInstance;
		if ( SUCCEEDED ( CWbemProviderGlue :: GetInstanceByPath ( ( LPCTSTR ) t_AbsPath, &t_ObjectInstance, a_Instance.GetMethodContext() ) ) )
		{
			CHString t_State ;
			t_ObjectInstance->GetCHString ( IDS_Name, a_Name ) ;
			t_ObjectInstance->GetCHString ( PROPERTY_NAME_STATE , t_State ) ;
			t_ObjectInstance->Getbool ( PROPERTY_NAME_ACCEPTPAUSE , a_AcceptPause ) ;
			t_ObjectInstance->Getbool ( PROPERTY_NAME_ACCEPTSTOP , a_AcceptStop ) ;
            t_ObjectInstance.Release();

			if ( t_State.CompareNoCase (PROPERTY_VALUE_STATE_STOPPED) == 0 )
			{
				a_State = SERVICE_STOPPED ;
            }
			else if ( t_State.CompareNoCase (PROPERTY_VALUE_STATE_STARTPENDING) == 0 )
			{
				a_State = SERVICE_START_PENDING ;
			}
			else if ( t_State.CompareNoCase (PROPERTY_VALUE_STATE_STOPPENDING) == 0 )
			{
				a_State = SERVICE_STOP_PENDING ;
			}
			else if ( t_State.CompareNoCase (PROPERTY_VALUE_STATE_RUNNING) == 0 )
			{
				a_State = SERVICE_RUNNING ;
			}
			else if ( t_State.CompareNoCase (PROPERTY_VALUE_STATE_CONTINUEPENDING) == 0 )
			{
				a_State = SERVICE_CONTINUE_PENDING ;
			}
			else if ( t_State.CompareNoCase (PROPERTY_VALUE_STATE_PAUSEPENDING) == 0 )
			{
		        a_State = SERVICE_PAUSE_PENDING ;
			}
			else if ( t_State.CompareNoCase (PROPERTY_VALUE_STATE_PAUSED) == 0 )
			{
				a_State = SERVICE_PAUSED ;
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_FAILURE ;
		}
	}
	else
	{
		t_Result = WBEM_E_FAILED ;
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: GetServiceResultCode ()
{
	HRESULT t_Result ;
	DWORD t_Error = GetLastError() ;
	switch ( t_Error )
	{
		case ERROR_INVALID_NAME:
		case ERROR_SERVICE_DOES_NOT_EXIST:
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
		break;

		case ERROR_ACCESS_DENIED:
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
		break ;

		case ERROR_SERVICE_MARKED_FOR_DELETE:
		{
			t_Result = WBEM_S_PENDING ;
		}
		break ;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
DWORD Win32_BaseService :: GetServiceErrorCode ()
{
	DWORD t_Status ;
	DWORD t_Error = GetLastError() ;
	switch ( t_Error )
	{
		case ERROR_INVALID_HANDLE:
		{
			t_Status = STATUS_UNKNOWN_FAILURE ;
		}
		break ;

		case ERROR_PATH_NOT_FOUND:
		{
			t_Status = STATUS_PATH_NOT_FOUND ;
		}
		break ;

		case ERROR_SERVICE_ALREADY_RUNNING:
		{
			t_Status = STATUS_SERVICE_ALREADY_RUNNING ;
		}
		break ;

		case ERROR_SERVICE_DATABASE_LOCKED:
		{
			t_Status = STATUS_SERVICE_DATABASE_LOCKED ;
		}
		break ;

		case ERROR_SERVICE_DEPENDENCY_DELETED:
		{
			t_Status = STATUS_SERVICE_DEPENDENCY_DELETED ;
		}
		break ;

		case ERROR_SERVICE_DEPENDENCY_FAIL:
		{
			t_Status = STATUS_SERVICE_DEPENDENCY_FAIL ;
		}
		break ;

		case ERROR_SERVICE_DISABLED:
		{
			t_Status = STATUS_SERVICE_DISABLED ;
		}
		break ;

		case ERROR_SERVICE_LOGON_FAILED:
		{
			t_Status = STATUS_SERVICE_LOGON_FAILED ;
		}
		break ;

		case ERROR_SERVICE_MARKED_FOR_DELETE:
		{
			t_Status = STATUS_SERVICE_MARKED_FOR_DELETE ;
		}
		break ;

		case ERROR_SERVICE_NO_THREAD:
		{
			t_Status = STATUS_SERVICE_NO_THREAD ;
		}
		break ;

		case ERROR_SERVICE_REQUEST_TIMEOUT:
		{
			t_Status = STATUS_SERVICE_REQUEST_TIMEOUT ;
		}
		break ;

		case ERROR_ACCESS_DENIED:
		{
			t_Status = STATUS_ACCESS_DENIED ;
		}
		break ;

		case ERROR_DEPENDENT_SERVICES_RUNNING:
		{
			t_Status = STATUS_DEPENDENT_SERVICES_RUNNING ;
		}
		break ;

		case ERROR_INVALID_SERVICE_CONTROL:
		{
			t_Status = STATUS_INVALID_SERVICE_CONTROL ;
		}
		break ;

		case ERROR_SERVICE_CANNOT_ACCEPT_CTRL:
		{
			t_Status = STATUS_SERVICE_CANNOT_ACCEPT_CTRL ;
		}
		break ;

		case ERROR_SERVICE_NOT_ACTIVE:
		{
			t_Status = STATUS_SERVICE_NOT_ACTIVE ;
		}
		break ;

		case ERROR_CIRCULAR_DEPENDENCY:
		{
			t_Status = STATUS_CIRCULAR_DEPENDENCY ;
		}
		break ;

		case ERROR_DUP_NAME:
		{
			t_Status = STATUS_DUP_NAME ;
		}
		break ;

		case ERROR_INVALID_NAME:
		{
			t_Status = STATUS_INVALID_NAME ;
		}
		break ;

		case ERROR_INVALID_PARAMETER:
		{
			t_Status = STATUS_INVALID_PARAMETER ;
		}
		break;

		case ERROR_INVALID_SERVICE_ACCOUNT:
		{
			t_Status = STATUS_INVALID_SERVICE_ACCOUNT ;
		}
		break ;

		case ERROR_SERVICE_EXISTS:
		{
			t_Status = STATUS_SERVICE_EXISTS ;
		}
		break ;

		default:
		{
			t_Status = STATUS_UNKNOWN_FAILURE ;
		}
		break ;
	}

	return t_Status ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecStart (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	DWORD t_State ;
	CHString t_Name ;
	bool t_AcceptPause ;
	bool t_AcceptStop ;

	t_Result = GetServiceStatus (

		a_Instance ,
		t_Name ,
		t_State ,
		t_AcceptPause ,
		t_AcceptStop
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		switch ( t_State )
		{
			case SERVICE_STOPPED:
			{
				SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
				if ( t_ServiceControlManager )
				{
					SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_Name , SERVICE_START ) ;
					if ( t_Service )
					{
						DWORD t_ReturnCode = StartService ( t_Service , 0 , NULL ) ;
						if ( t_ReturnCode )
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE, STATUS_SUCCESS ) ;
						}
						else
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
						}
					}
					else
					{
						if ( a_OutParams )
							a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
					}
				}
				else
				{
					t_Result = GetServiceErrorCode () ;
				}
			}
			break ;

			default:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_ALREADY_RUNNING ) ;
			}
		}
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecStop (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	DWORD t_State ;
	CHString t_Name ;
	bool t_AcceptPause ;
	bool t_AcceptStop ;

	t_Result = GetServiceStatus (

		a_Instance ,
		t_Name ,
		t_State ,
		t_AcceptPause ,
		t_AcceptStop
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_AcceptStop )
		{
			switch ( t_State )
			{
				case 0xFFFFFFFF:
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_UNKNOWN_FAILURE ) ;
				}
				break ;

				case SERVICE_STOP_PENDING:
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_SERVICE_CONTROL ) ;
				}
				break ;

				case SERVICE_STOPPED:
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_NOT_ACTIVE ) ;
				}
				break ;

				default:
				{
					SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
					if ( t_ServiceControlManager )
					{
						SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_Name , SERVICE_STOP ) ;
						if ( t_Service )
						{
							SERVICE_STATUS t_ServiceStatus ;
							DWORD t_ReturnCode = ControlService ( t_Service , SERVICE_CONTROL_STOP , & t_ServiceStatus ) ;
							if ( t_ReturnCode )
							{
								if ( a_OutParams )
									a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SUCCESS ) ;
							}
							else
							{
								if ( a_OutParams )
									a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
							}
						}
						else
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
						}

					}
					else
					{
						t_Result = GetServiceErrorCode () ;
					}
				}
				break ;
			}
		}
		else
		{
			if ( a_OutParams )
				a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_CANNOT_ACCEPT_CTRL ) ;
		}
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecPause (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	DWORD t_State ;
	CHString t_Name ;
	bool t_AcceptPause ;
	bool t_AcceptStop ;

	t_Result = GetServiceStatus (

		a_Instance ,
		t_Name ,
		t_State ,
		t_AcceptPause ,
		t_AcceptStop
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_AcceptPause )
		{
			switch ( t_State )
			{
				case 0xFFFFFFFF:
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_UNKNOWN_FAILURE ) ;
				}
				break ;

				case SERVICE_START_PENDING:
				case SERVICE_STOP_PENDING:
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_SERVICE_CONTROL ) ;
				}
				break ;

				case SERVICE_PAUSED:
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_ALREADY_PAUSED ) ;
				}
				break ;

				case SERVICE_STOPPED:
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_NOT_ACTIVE ) ;
				}
				break ;

				default:
				{
					SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
					if ( t_ServiceControlManager )
					{
						SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_Name , SERVICE_PAUSE_CONTINUE ) ;
						if ( t_Service )
						{
							SERVICE_STATUS t_ServiceStatus ;
							DWORD t_ReturnCode = ControlService ( t_Service , SERVICE_CONTROL_PAUSE , & t_ServiceStatus ) ;
							if ( t_ReturnCode )
							{
								if ( a_OutParams )
									a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SUCCESS ) ;
							}
							else
							{
								if ( a_OutParams )
									a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
							}
						}
						else
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
						}
					}
					else
					{
						t_Result = GetServiceErrorCode () ;
					}
				}
				break ;
			}
		}
		else
		{
			if ( a_OutParams )
				a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_CANNOT_ACCEPT_CTRL ) ;
		}
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecResume (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	DWORD t_State ;
	CHString  t_Name ;
	bool t_AcceptPause ;
	bool t_AcceptStop ;

	t_Result = GetServiceStatus (

		a_Instance ,
		t_Name ,
		t_State ,
		t_AcceptPause ,
		t_AcceptStop
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		switch ( t_State )
		{
			case 0xFFFFFFFF:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_UNKNOWN_FAILURE ) ;
			}
			break ;

			case SERVICE_START_PENDING:
			case SERVICE_STOP_PENDING:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_SERVICE_CONTROL ) ;
			}
			break ;

			case SERVICE_STOPPED:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_NOT_ACTIVE ) ;
			}
			break ;

			case SERVICE_RUNNING:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_ALREADY_RUNNING ) ;
			}
			break ;

			default:
			{
				SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
				if ( t_ServiceControlManager )
				{
					SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_Name , SERVICE_PAUSE_CONTINUE ) ;
					if ( t_Service )
					{
						SERVICE_STATUS t_ServiceStatus ;
						DWORD t_ReturnCode = ControlService ( t_Service , SERVICE_CONTROL_CONTINUE , & t_ServiceStatus ) ;
						if ( t_ReturnCode )
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SUCCESS ) ;
						}
						else
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
						}
					}
					else
					{
						if ( a_OutParams )
							a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
					}
				}
				else
				{
					t_Result = GetServiceErrorCode () ;
				}
			}
			break ;
		}
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecInterrogate (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	DWORD t_State ;
	CHString  t_Name ;
	bool t_AcceptPause ;
	bool t_AcceptStop ;

	t_Result = GetServiceStatus (

		a_Instance ,
		t_Name ,
		t_State ,
		t_AcceptPause ,
		t_AcceptStop
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		switch ( t_State )
		{
			case 0xFFFFFFFF:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_UNKNOWN_FAILURE ) ;
			}
			break ;

			case SERVICE_START_PENDING:
			case SERVICE_STOP_PENDING:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_SERVICE_CONTROL ) ;
			}
			break ;

			case SERVICE_STOPPED:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_NOT_ACTIVE ) ;
			}
			break ;

			default:
			{
				SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
				if ( t_ServiceControlManager )
				{
					SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_Name , SERVICE_INTERROGATE ) ;
					if ( t_Service )
					{
						SERVICE_STATUS t_ServiceStatus ;
						DWORD t_ReturnCode = ControlService ( t_Service , SERVICE_CONTROL_INTERROGATE , & t_ServiceStatus ) ;
						if ( t_ReturnCode )
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SUCCESS ) ;
						}
						else
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
						}
					}
					else
					{
						if ( a_OutParams )
							a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
					}
				}
				else
				{
					t_Result = GetServiceErrorCode () ;
				}
			}
			break ;
		}
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecUserControlService (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	DWORD t_State ;
	CHString t_Name ;
	bool t_AcceptPause ;
	bool t_AcceptStop ;

	t_Result = GetServiceStatus (

		a_Instance ,
		t_Name ,
		t_State ,
		t_AcceptPause ,
		t_AcceptStop
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		switch ( t_State )
		{
			case 0xFFFFFFFF:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_UNKNOWN_FAILURE ) ;
			}
			break ;

			case SERVICE_START_PENDING:
			case SERVICE_STOP_PENDING:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_SERVICE_CONTROL ) ;
			}
			break ;

			case SERVICE_STOPPED:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_NOT_ACTIVE ) ;
			}
			break ;

			default:
			{
				bool t_Exists ;
				VARTYPE t_Type ;

				UCHAR t_Control = 0 ;

				if ( a_InParams )
				{
					if ( a_InParams->GetStatus ( METHOD_ARG_NAME_NAME , t_Exists , t_Type ) )
					{
						if ( t_Exists && ( t_Type == VT_UI1 ) )
						{
							if ( ! a_InParams->GetByte ( METHOD_ARG_NAME_CONTROLCODE , t_Control ) )
							{
								return WBEM_E_INVALID_PARAMETER ;
							}
						}
						else
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_PARAMETER  ) ;

							return S_OK ;
						}
					}
					else
					{
						return WBEM_E_INVALID_PARAMETER ;
					}
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER ;
				}

				SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
				if ( t_ServiceControlManager )
				{
					SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_Name , SERVICE_USER_DEFINED_CONTROL ) ;
					if ( t_Service )
					{
						SERVICE_STATUS t_ServiceStatus ;
						DWORD t_ReturnCode = ControlService ( t_Service , t_Control , & t_ServiceStatus ) ;
						if ( t_ReturnCode )
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SUCCESS ) ;
						}
						else
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
						}
                    }
					else
					{
						if ( a_OutParams )
							a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
					}
				}
				else
				{
					t_Result = GetServiceErrorCode () ;
				}
			}
			break ;
		}
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecDelete (

	const CInstance& a_Instance ,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	CHString t_Name ;
	if ( a_Instance.GetCHString ( IDS_Name, t_Name ) && ! t_Name.IsEmpty () )
	{
		SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
		if ( t_ServiceControlManager )
		{
			SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_Name , DELETE ) ;
			if ( t_Service )
			{
				BOOL t_ReturnCode = DeleteService ( t_Service ) ;
				if ( t_ReturnCode )
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SUCCESS ) ;
				}
				else
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
				}
			}
			else
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
			}
		}
		else
		{
			t_Result = GetServiceErrorCode () ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
DWORD Win32_BaseService :: CheckParameters (

	const CInstance& a_Instance ,
	CInstance *a_InParams ,
	CInstance *a_OutParams ,
	DWORD &a_Status ,
	BOOL a_Create
)
{
	HRESULT t_Result = S_OK ;

	a_Status = STATUS_SUCCESS ;

	bool t_Exists ;
	VARTYPE t_Type ;

	CHString t_ServiceName ;

	if ( a_Create )
	{
		if ( a_InParams->GetStatus ( METHOD_ARG_NAME_NAME , t_Exists , t_Type ) )
		{
			if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
			{
				if ( t_Type == VT_BSTR )
				{
					if ( a_InParams->GetCHString ( METHOD_ARG_NAME_NAME , t_ServiceName ) && ! t_ServiceName.IsEmpty () )
					{
					}
					else
					{
// Zero Length string

						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
				}
				else //  t_Type == VT_NULL
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return WBEM_E_PROVIDER_FAILURE ;
		}
	}
	else
	{
		DWORD t_State ;
		bool t_AcceptPause ;
		bool t_AcceptStop ;

		t_Result = GetServiceStatus (

			a_Instance ,
			t_ServiceName ,
			t_State ,
			t_AcceptPause ,
			t_AcceptStop
		) ;

		if ( FAILED ( t_Result ) )
		{
			a_Status = STATUS_UNKNOWN_FAILURE ;
			return t_Result ;
		}
	}

	bool t_DisplayNameSpecified = false ;
	CHString t_DisplayName ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_DISPLAYNAME , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				if ( a_Create )
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
				else
				{
					t_DisplayNameSpecified = false ;
				}
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_DISPLAYNAME , t_DisplayName ) && ! t_DisplayName.IsEmpty () )
				{
					t_DisplayNameSpecified = true ;
				}
				else
				{
// Zero Length string

					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_PathNameSpecified = false ;
	CHString t_PathName ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_PATHNAME , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				if ( a_Create )
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_PATHNAME , t_PathName ) && ! t_PathName.IsEmpty () )
				{
					t_PathNameSpecified = true ;
				}
				else
				{
// Zero Length string

					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_ServiceTypeSpecified = true ;

	DWORD t_ServiceType = SERVICE_WIN32_OWN_PROCESS ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_SERVICETYPE , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_UI1 || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				if ( a_Create )
				{
				}
				else
				{
					t_ServiceTypeSpecified = false ;
				}
			}
			else
			{
				BYTE t_TempSerType ;
				if ( a_InParams->GetByte ( METHOD_ARG_NAME_SERVICETYPE, t_TempSerType ) )
				{
					switch ( t_TempSerType )
					{
						case PROPERTY_VALUE_SERVICE_TYPE_KERNAL_DRIVER:
						{
							t_ServiceType = SERVICE_KERNEL_DRIVER ;
						}
						break ;

						case PROPERTY_VALUE_SERVICE_TYPE_FILE_SYSTEM_DRIVER:
						{
							t_ServiceType = SERVICE_FILE_SYSTEM_DRIVER ;
						}
						break ;

						case PROPERTY_VALUE_SERVICE_TYPE_RECOGNIZER_DRIVER:
						{
							t_ServiceType = SERVICE_RECOGNIZER_DRIVER ;
						}
						break ;

						case PROPERTY_VALUE_SERVICE_TYPE_ADAPTER:
						{
							t_ServiceType = SERVICE_ADAPTER;
						}
						break ;

						case PROPERTY_VALUE_SERVICE_TYPE_OWN_PROCESS:
						{
							t_ServiceType = SERVICE_WIN32_OWN_PROCESS ;
						}
						break ;

						case PROPERTY_VALUE_SERVICE_TYPE_SHARE_PROCESS:
						{
							t_ServiceType = SERVICE_WIN32_SHARE_PROCESS ;
						}
						break ;

						default:
						{
							a_Status = STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
						break ;
					}
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_ServiceErrorControlSpecified = true ;
	UCHAR t_ErrorControl ;
	DWORD t_ServiceErrorControl = SERVICE_ERROR_IGNORE ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_ERRORCONTROL , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_UI1 || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				if ( a_Create )
				{
				}
				else
				{
					t_ServiceErrorControlSpecified = false ;
				}
			}
			else
			{
				if ( a_InParams->GetByte ( METHOD_ARG_NAME_ERRORCONTROL , t_ErrorControl ) )
				{
					switch ( t_ErrorControl )
					{
						case PROPERTY_VALUE_ERROR_CONTROL_IGNORE:
						{
							t_ServiceErrorControl = SERVICE_ERROR_IGNORE ;
						}
						break ;

						case PROPERTY_VALUE_ERROR_CONTROL_NORMAL:
						{
							t_ServiceErrorControl = SERVICE_ERROR_NORMAL ;
						}
						break ;

						case PROPERTY_VALUE_ERROR_CONTROL_SEVERE:
						{
							t_ServiceErrorControl = SERVICE_ERROR_SEVERE ;
						}
						break ;

						case PROPERTY_VALUE_ERROR_CONTROL_CRITICAL:
						{
							t_ServiceErrorControl = SERVICE_ERROR_CRITICAL;
						}
						break ;

						default:
						{
							a_Status = STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
						break ;
					}
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_ServiceStartModeSpecified = true ;
	CHString t_StartMode ;
	DWORD t_ServiceStartMode = SERVICE_AUTO_START ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_STARTMODE , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				if ( a_Create )
				{
				}
				else
				{
					t_ServiceStartModeSpecified = false ;
				}
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_STARTMODE , t_StartMode ) )
				{
					if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_BOOT ) == 0 )
					{
						t_ServiceStartMode = SERVICE_BOOT_START ;
					}
					else if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_SYSTEM ) == 0 )
					{
						t_ServiceStartMode = SERVICE_SYSTEM_START ;
					}
					else if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_AUTOMATIC ) == 0 )
					{
						t_ServiceStartMode = SERVICE_AUTO_START ;
					}
					else if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_MANUAL ) == 0 )
					{
						t_ServiceStartMode = SERVICE_DEMAND_START ;
					}
					else if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_DISABLE ) == 0 )
					{
						t_ServiceStartMode = SERVICE_DISABLED ;
					}
					else
					{
						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_StartNameSpecified = false ;
	CHString t_StartName ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_STARTNAME , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				if ( a_Create )
				{
				}
				else
				{
					t_StartNameSpecified = false ;
				}
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_STARTNAME , t_StartName ) && ! t_StartName.IsEmpty () )
				{
					t_StartNameSpecified = true ;
				}
				else
				{
					if ( a_Create )
					{
						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
					else
					{
						t_StartNameSpecified = true ;
					}
				}
			}

			#if NTONLY < 5
			if ( t_StartNameSpecified )
			{
				switch ( t_ServiceType )
				{
					case SERVICE_WIN32_SHARE_PROCESS:
					{
						if ( t_StartName.CompareNoCase ( PROPERTY_VALUE_STARTNAME_LOCAL_SYSTEM ) != 0 )
						{
							a_Status = STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
			#endif
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_StartPasswordSpecified = false ;
	CHString t_StartPassword ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_STARTPASSWORD , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_STARTPASSWORD , t_StartPassword ) )
				{
					t_StartPasswordSpecified = true ;
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_DesktopInteract = false ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_DESKTOPINTERACT , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BOOL || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				if ( ! t_ServiceTypeSpecified )
				{
					if ( a_Create )
					{
						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
					else
					{
						t_ServiceTypeSpecified = true ;

						SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , SC_MANAGER_CREATE_SERVICE | SC_MANAGER_LOCK ) ;
						if ( t_ServiceControlManager )
						{
							SC_LOCK t_Lock = LockServiceDatabase ( t_ServiceControlManager ) ;
							if ( t_Lock )
							{
								try
								{
									SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_ServiceName , SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG ) ;
									if ( t_Service )
									{
										DWORD t_SizeNeeded = 0 ;
										QUERY_SERVICE_CONFIG *t_ServiceConfig = NULL ;
										BOOL t_Status = QueryServiceConfig ( t_Service , NULL , 0 ,  & t_SizeNeeded ) ;
										if ( ! t_Status )
										{
											if ( GetLastError () == ERROR_INSUFFICIENT_BUFFER )
											{
												t_ServiceConfig = ( QUERY_SERVICE_CONFIG * ) new char [ t_SizeNeeded ] ;
												if ( t_ServiceConfig )
												{
													try
													{
														t_Status = QueryServiceConfig ( t_Service , t_ServiceConfig , t_SizeNeeded ,  & t_SizeNeeded ) ;
														if ( t_Status )
														{
														}
													}
													catch ( ... )
													{
														delete [] t_ServiceConfig ;

														throw ;
													}
												}
												else
												{
													throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
												}
											}
										}

										if ( t_Status )
										{
											t_ServiceType = t_ServiceConfig->dwServiceType ;
										}
										else
										{
											a_Status = GetServiceErrorCode () ;
										}

										delete [] ( UCHAR * ) t_ServiceConfig ;

									}
									else
									{
										a_Status = GetServiceErrorCode () ;
									}

								}
								catch ( ... )
								{
									UnlockServiceDatabase ( t_Lock ) ;

									throw ;
								}

								UnlockServiceDatabase ( t_Lock ) ;
							}
							else
							{
								a_Status = GetServiceErrorCode () ;
							}

							if ( a_Status != STATUS_SUCCESS )
							{
								return t_Result ;
							}
						}
						else
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
						}
					}
				}

				if ( a_InParams->Getbool ( METHOD_ARG_NAME_DESKTOPINTERACT , t_DesktopInteract ) )
				{
					DWORD t_PlainServiceType = t_ServiceType & ( ~ SERVICE_INTERACTIVE_PROCESS );
					switch ( t_PlainServiceType )
					{
						case SERVICE_WIN32_OWN_PROCESS:
						case SERVICE_WIN32_SHARE_PROCESS:
						{
							if ( t_DesktopInteract )
							{
								t_ServiceType = t_ServiceType | SERVICE_INTERACTIVE_PROCESS ;
							}
							else
							{
								t_ServiceType = t_PlainServiceType ;
							}
						}
						break ;

						default:
						{
							a_Status = STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
						break ;
					}
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_LoadOrderGroupSpecified = false ;
	CHString t_LoadOrderGroup ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_LOADORDERGROUP , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_LOADORDERGROUP , t_LoadOrderGroup ) && ! t_LoadOrderGroup.IsEmpty () )
				{
					t_LoadOrderGroupSpecified = true ;
				}
				else
				{
					if ( a_Create )
					{
						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
					else
					{
						t_LoadOrderGroupSpecified = true ;
					}
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	LONG t_LoadOrderBufferLength = 0 ;
	SAFEARRAY *t_LoadOrderGroupDependancies = NULL ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_LOADORDERGROUPDEPENDENCIES , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == ( VT_BSTR | VT_ARRAY ) || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				if ( a_InParams->GetStringArray ( METHOD_ARG_NAME_LOADORDERGROUPDEPENDENCIES , t_LoadOrderGroupDependancies ) )
				{
					if ( t_LoadOrderGroupDependancies )
					{
						try
						{
							if ( SafeArrayGetDim ( t_LoadOrderGroupDependancies ) == 1 )
							{
								LONG t_Dimension = 1 ;
								LONG t_LowerBound ;
								SafeArrayGetLBound ( t_LoadOrderGroupDependancies , t_Dimension , & t_LowerBound ) ;
								LONG t_UpperBound ;
								SafeArrayGetUBound ( t_LoadOrderGroupDependancies , t_Dimension , & t_UpperBound ) ;

								t_LoadOrderBufferLength = 0 ;

								for ( LONG t_Index = t_LowerBound ; t_Index <= t_UpperBound ; t_Index ++ )
								{
									BSTR t_Element ;
									HRESULT t_Status = SafeArrayGetElement ( t_LoadOrderGroupDependancies , &t_Index , & t_Element ) ;
									if ( t_Status == S_OK )
									{
										try {

											CHString t_String ( t_Element ) ;

											t_LoadOrderBufferLength += _tcslen ( t_String ) + 2 ;

										}
										catch ( ... )
										{
											SysFreeString ( t_Element ) ;

											throw ;
										}

										SysFreeString ( t_Element ) ;
									}
									else
									{
										throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
									}
								}
							}
							else
							{
								a_Status = STATUS_INVALID_PARAMETER ;
								return t_Result ;
							}
						}
						catch ( ... )
						{
							SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;

							throw ;
						}
					}
					else
					{
						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}


	LONG t_ServiceBufferLength = 0 ;
	SAFEARRAY *t_ServiceDependancies = NULL ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_SERVICEDEPENDENCIES , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == ( VT_BSTR | VT_ARRAY ) || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				if ( a_InParams->GetStringArray ( METHOD_ARG_NAME_SERVICEDEPENDENCIES , t_ServiceDependancies ) )
				{
					if ( t_ServiceDependancies )
					{
						try
						{
							if ( SafeArrayGetDim ( t_ServiceDependancies ) == 1 )
							{
								LONG t_Dimension = 1 ;
								LONG t_LowerBound ;
								SafeArrayGetLBound ( t_ServiceDependancies , t_Dimension , & t_LowerBound ) ;
								LONG t_UpperBound ;
								SafeArrayGetUBound ( t_ServiceDependancies , t_Dimension , & t_UpperBound ) ;

								t_ServiceBufferLength = 0 ;

								for ( LONG t_Index = t_LowerBound ; t_Index <= t_UpperBound ; t_Index ++ )
								{
									BSTR t_Element ;
									HRESULT t_Status = SafeArrayGetElement ( t_ServiceDependancies , &t_Index , & t_Element ) ;
									if ( t_Status == S_OK )
									{
										try
										{
											CHString t_String ( t_Element ) ;
											t_ServiceBufferLength += _tcslen ( t_String ) + 1 ;

										}
										catch ( ... )
										{
											SysFreeString ( t_Element ) ;

											throw ;
										}
										SysFreeString ( t_Element ) ;
									}
									else
									{
										throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
									}
								}
							}
							else
							{
								SafeArrayDestroy ( t_ServiceDependancies ) ;
								if ( t_LoadOrderGroupDependancies )
								{
									SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;
								}

								a_Status = STATUS_INVALID_PARAMETER ;
								return t_Result ;
							}
						}
						catch ( ... )
						{
							SafeArrayDestroy ( t_ServiceDependancies ) ;

							if ( t_LoadOrderGroupDependancies )
							{
								SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;
							}

							throw ;
						}
					}
					else
					{
						if ( t_LoadOrderGroupDependancies )
						{
							SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;
						}

						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
				}
				else
				{
					if ( t_LoadOrderGroupDependancies )
					{
						SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;
					}

					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			if ( t_LoadOrderGroupDependancies )
			{
				SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;
			}

			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		if ( t_LoadOrderGroupDependancies )
		{
			SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;
		}

		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	TCHAR *t_DependancyList = NULL ;

	try
	{
		LONG t_TotalLength = t_LoadOrderBufferLength + t_ServiceBufferLength ;
		if ( t_TotalLength )
		{
			t_DependancyList = new TCHAR [ t_TotalLength + 1 ] ;
			if ( t_DependancyList )
			{
				try
				{
					LONG t_BufferLength = 0 ;
					if ( t_LoadOrderBufferLength )
					{
						LONG t_Dimension = 1 ;
						LONG t_LowerBound ;
						SafeArrayGetLBound ( t_LoadOrderGroupDependancies , t_Dimension , & t_LowerBound ) ;
						LONG t_UpperBound ;
						SafeArrayGetUBound ( t_LoadOrderGroupDependancies , t_Dimension , & t_UpperBound ) ;

						for ( LONG t_Index = t_LowerBound ; t_Index <= t_UpperBound ; t_Index ++ )
						{
							BSTR t_Element ;
							HRESULT t_Status = SafeArrayGetElement ( t_LoadOrderGroupDependancies , &t_Index , & t_Element ) ;
							if ( t_Status == S_OK )
							{
								try
								{
									t_DependancyList [ t_BufferLength ] = SC_GROUP_IDENTIFIER ;

									CHString t_String ( t_Element ) ;
									_tcscpy ( & t_DependancyList [ t_BufferLength + 1 ] , t_String ) ;

									t_BufferLength += _tcslen ( t_String ) + 2 ;
								}
								catch ( ... )
								{
									SysFreeString ( t_Element ) ;

									throw ;
								}

								SysFreeString ( t_Element ) ;
							}
							else
							{
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							}
						}
					}

					if ( t_ServiceBufferLength )
					{
						LONG t_Dimension = 1 ;
						LONG t_LowerBound ;
						SafeArrayGetLBound ( t_ServiceDependancies , t_Dimension , & t_LowerBound ) ;
						LONG t_UpperBound ;
						SafeArrayGetUBound ( t_ServiceDependancies , t_Dimension , & t_UpperBound ) ;

						for ( LONG t_Index = t_LowerBound ; t_Index <= t_UpperBound ; t_Index ++ )
						{
							BSTR t_Element ;

							HRESULT t_Status = SafeArrayGetElement ( t_ServiceDependancies , &t_Index , & t_Element ) ;
							if ( t_Status == S_OK )
							{
								try
								{
									CHString t_String ( t_Element ) ;
									_tcscpy ( & t_DependancyList [ t_BufferLength ] , t_String ) ;

									t_BufferLength += _tcslen ( t_String ) + 1 ;
								}
								catch ( ... )
								{
									SysFreeString ( t_Element ) ;

									throw ;
								}

								SysFreeString ( t_Element ) ;
							}
							else
							{
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							}
						}
					}

					t_DependancyList [ t_TotalLength ] = 0 ;
				}
				catch ( ... )
				{
					delete [] t_DependancyList ;

					throw ;
				}
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

	}
	catch ( ... )
	{
		if ( t_LoadOrderGroupDependancies )
			SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;

		if ( t_ServiceDependancies )
			SafeArrayDestroy ( t_ServiceDependancies ) ;

		throw ;
	}

	if ( t_LoadOrderGroupDependancies )
		SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;

	if ( t_ServiceDependancies )
		SafeArrayDestroy ( t_ServiceDependancies ) ;


	SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , SC_MANAGER_CREATE_SERVICE | SC_MANAGER_LOCK ) ;
	if ( t_ServiceControlManager )
	{
		SC_LOCK t_Lock = LockServiceDatabase ( t_ServiceControlManager ) ;
		if ( t_Lock )
		{
			try
			{
				if ( a_Create )
				{
					DWORD t_TagId = 0 ;

					LPCTSTR t_SN = (LPCTSTR) t_ServiceName ;
					LPCTSTR t_DN = (LPCTSTR) t_DisplayName ;
					LPCTSTR t_PN = (LPCTSTR) t_PathName ;
					LPCTSTR t_LO = t_LoadOrderGroupSpecified ? (LPCTSTR) t_LoadOrderGroup : NULL ;
					LPCTSTR t_STN = t_StartNameSpecified ? (LPCTSTR) t_StartName : NULL ;
					LPCTSTR t_SP = t_StartPasswordSpecified ? (LPCTSTR) t_StartPassword : NULL ;

					SmartCloseServiceHandle t_Service = CreateService (

						t_ServiceControlManager ,
						t_SN ,
						t_DN ,
						SERVICE_ALL_ACCESS ,
						t_ServiceType,
						t_ServiceStartMode ,
						t_ServiceErrorControl ,
						t_PN ,
						t_LO ,
						( t_ServiceType & SERVICE_BOOT_START || t_ServiceType & SERVICE_SYSTEM_START ) ? &t_TagId : NULL ,
						t_DependancyList ,
						t_STN ,
						t_SP
					) ;

					if ( t_Service )
					{
						a_Status = STATUS_SUCCESS ;
					}
					else
					{
						a_Status = GetServiceErrorCode () ;
					}
				}
				else
				{
					SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_ServiceName , SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG ) ;
					if ( t_Service )
					{
						DWORD t_SizeNeeded = 0 ;
						QUERY_SERVICE_CONFIG *t_ServiceConfig = NULL ;
						BOOL t_Status = QueryServiceConfig ( t_Service , NULL , 0 ,  & t_SizeNeeded ) ;
						if ( ! t_Status )
						{
							if ( GetLastError () == ERROR_INSUFFICIENT_BUFFER )
							{
								t_ServiceConfig = ( QUERY_SERVICE_CONFIG * ) new char [ t_SizeNeeded ] ;
								t_Status = QueryServiceConfig ( t_Service , t_ServiceConfig , t_SizeNeeded ,  & t_SizeNeeded ) ;
								if ( t_Status )
								{
								}
							}
						}

						if ( t_Status )
						{
							LPCTSTR t_DN = t_DisplayNameSpecified ? (LPCTSTR) t_DisplayName : NULL ;
							LPCTSTR t_PN = t_PathNameSpecified ? (LPCTSTR) t_PathName : NULL ;
							LPCTSTR t_LO = t_LoadOrderGroupSpecified ? (LPCTSTR) t_LoadOrderGroup : NULL ;
							LPCTSTR t_STN = t_StartNameSpecified ? (LPCTSTR) t_StartName : NULL ;
							LPCTSTR t_SP = t_StartPasswordSpecified ? (LPCTSTR) t_StartPassword : NULL ;

							DWORD t_TagId = 0 ;
							t_Status = ChangeServiceConfig (

								t_Service ,
								t_ServiceTypeSpecified ? t_ServiceType : t_ServiceConfig->dwServiceType ,
								t_ServiceStartModeSpecified ? t_ServiceStartMode : t_ServiceConfig->dwStartType ,
								t_ServiceErrorControlSpecified ? t_ServiceErrorControl : t_ServiceConfig->dwErrorControl ,
								t_PN ,
								t_LO ,
								NULL ,
								t_DependancyList ,
								t_STN ,
								t_SP ,
								t_DN
							) ;

							if ( t_Status )
							{
								a_Status = STATUS_SUCCESS ;
							}
							else
							{
								a_Status = GetServiceErrorCode () ;
							}
						}
						else
						{
							a_Status = GetServiceErrorCode () ;
						}

					}
					else
					{
						a_Status = GetServiceErrorCode () ;
					}
				}

			}
			catch ( ... )
			{
				UnlockServiceDatabase ( t_Lock ) ;

				throw ;
			}

			UnlockServiceDatabase ( t_Lock ) ;
		}
		else
		{
			a_Status = GetServiceErrorCode () ;
		}
	}
	else
	{
		a_Status = GetServiceErrorCode () ;
	}

	delete [] t_DependancyList ;

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecCreate (

	const CInstance& a_Class ,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	CHString t_Name ;

	if ( a_InParams && a_OutParams )
	{
		DWORD t_Status = STATUS_SUCCESS ;

		t_Result = CheckParameters ( a_Class , a_InParams , a_OutParams , t_Status , TRUE ) ;
		if ( a_OutParams )
			a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_Status ) ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecChange (

	const CInstance& a_Instance ,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	CHString t_Name ;

	if ( a_InParams && a_OutParams )
	{
		DWORD t_Status = STATUS_SUCCESS ;

		t_Result = CheckParameters ( a_Instance , a_InParams , a_OutParams , t_Status , FALSE ) ;
		if ( a_OutParams )
			a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_Status ) ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecChangeStartMode (

	const CInstance& a_Instance ,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	CHString t_Name ;

	if ( a_InParams && a_OutParams )
	{
		CHString t_ServiceName ;

		DWORD t_State ;
		bool t_AcceptPause ;
		bool t_AcceptStop ;

		HRESULT t_Result = GetServiceStatus (

			a_Instance ,
			t_ServiceName ,
			t_State ,
			t_AcceptPause ,
			t_AcceptStop
		) ;

		if ( FAILED ( t_Result ) )
		{
			return WBEM_E_PROVIDER_FAILURE ;
		}


		CHString t_StartMode ;
		DWORD t_ServiceStartMode ;

		bool t_Exists ;
		VARTYPE t_Type ;

		if ( a_InParams->GetStatus ( METHOD_ARG_NAME_STARTMODE , t_Exists , t_Type ) )
		{
			if ( t_Exists && ( t_Type == VT_BSTR ) )
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_STARTMODE , t_StartMode ) && ! t_StartMode.IsEmpty () )
				{
					if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_BOOT ) == 0 )
					{
						t_ServiceStartMode = SERVICE_BOOT_START ;
					}
					else if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_SYSTEM ) == 0 )
					{
						t_ServiceStartMode = SERVICE_SYSTEM_START ;
					}
					else if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_AUTOMATIC ) == 0 )
					{
						t_ServiceStartMode = SERVICE_AUTO_START ;
					}
					else if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_MANUAL ) == 0 )
					{
						t_ServiceStartMode = SERVICE_DEMAND_START ;
					}
					else if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_DISABLE ) == 0 )
					{
						t_ServiceStartMode = SERVICE_DISABLED ;
					}
					else
					{
						if ( a_OutParams )
							a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_PARAMETER ) ;
						return t_Result ;
					}
				}
				else
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_PARAMETER ) ;
					return t_Result ;
				}
			}
			else
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_PARAMETER ) ;
				return t_Result ;
			}
		}
		else
		{
			if ( a_OutParams )
				a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_PARAMETER ) ;
			return WBEM_E_PROVIDER_FAILURE ;
		}

		SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , SC_MANAGER_CREATE_SERVICE | SC_MANAGER_LOCK ) ;
		if ( t_ServiceControlManager )
		{
			SC_LOCK t_Lock = LockServiceDatabase ( t_ServiceControlManager ) ;
			if ( t_Lock )
			{
				try
				{
					SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_ServiceName , SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG ) ;
					if ( t_Service )
					{
						DWORD t_SizeNeeded = 0 ;
						QUERY_SERVICE_CONFIG *t_ServiceConfig = NULL ;
						try
						{
							BOOL t_Status = QueryServiceConfig ( t_Service , NULL , 0 ,  & t_SizeNeeded ) ;
							if ( ! t_Status )
							{
								if ( GetLastError () == ERROR_INSUFFICIENT_BUFFER )
								{
									t_ServiceConfig = ( QUERY_SERVICE_CONFIG * ) new char [ t_SizeNeeded ] ;
									if ( t_ServiceConfig )
									{
										t_Status = QueryServiceConfig ( t_Service , t_ServiceConfig , t_SizeNeeded ,  & t_SizeNeeded ) ;
										if ( t_Status )
										{
										}
									}
									else
									{
										throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
									}
								}
							}

							if ( t_Status )
							{
								BOOL t_Status = ChangeServiceConfig (

									t_Service ,
									t_ServiceConfig->dwServiceType ,
									t_ServiceStartMode ,
									t_ServiceConfig->dwErrorControl ,
									NULL ,
									NULL ,
									NULL ,
									NULL ,
									NULL ,
									NULL ,
									t_ServiceConfig->lpDisplayName
								) ;

								if ( t_Status )
								{
									if ( a_OutParams )
										a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SUCCESS ) ;
								}
								else
								{
									if ( a_OutParams )
										a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
								}
							}
							else
							{
								if ( a_OutParams )
									a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
							}

						}
						catch ( ... )
						{
							delete [] t_ServiceConfig ;

							throw ;
						}

						delete [] t_ServiceConfig ;
					}
					else
					{
						if ( a_OutParams )
							a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
					}
				}
				catch ( ... )
				{
					UnlockServiceDatabase ( t_Lock ) ;

					throw ;
				}

				UnlockServiceDatabase ( t_Lock ) ;
			}
			else
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
			}
		}
		else
		{
			if ( a_OutParams )
				a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\cdrom.cpp ===
//=================================================================
//
// w2k\CDROM.cpp -- CDROM property set provider
//
//  Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include <devioctl.h>
#include <ntddscsi.h>
#include <ntddstor.h>

#include <ntddcdrm.h>
#include <ntddmmc.h>

#include <imapipub.h>

#include "kernel32api.h"

#include "..\cdrom.h"

#include "..\MSINFO_cdrom.h"
#include <comdef.h>


//#include <sdkioctl.h>
// Property set declaration
//=========================

#define CONFIG_MANAGER_CLASS_CDROM L"CDROM"
#define CONFIG_MANAGER_CLASS_GUID_CDROM L"{4d36e965-e325-11ce-bfc1-08002be10318}"

CWin32CDROM s_Cdrom ( PROPSET_NAME_CDROM , IDS_CimWin32Namespace );

const WCHAR *IDS_MfrAssignedRevisionLevel = L"MfrAssignedRevisionLevel";

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::CWin32CDROM
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32CDROM :: CWin32CDROM (

	LPCWSTR a_pszName,
	LPCWSTR a_pszNamespace

) : Provider ( a_pszName, a_pszNamespace )
{
    // Identify the platform right away
    //=================================

	InitializeCriticalSection ( & m_CriticalSection ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::~CWin32CDROM
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32CDROM :: ~CWin32CDROM()
{
	DeleteCriticalSection ( & m_CriticalSection ) ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32CDROM::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32CDROM :: GetObject ( CInstance *a_Instance, long a_Flags, CFrameworkQuery &a_Query)
{
    HRESULT t_Result = WBEM_E_NOT_FOUND ;

    CConfigManager t_ConfigManager ;

/*
 * Let's see if config manager recognizes this device at all
 */

    CHString t_Key ;
    a_Instance->GetCHString ( IDS_DeviceID , t_Key ) ;

    CConfigMgrDevicePtr t_Device;
    if ( t_ConfigManager.LocateDevice ( t_Key , t_Device ) )
    {
/*
 * Ok, it knows about it.  Is it a CDROM device?
 */
		CHString t_DeviceClass ;
		if ( t_Device->GetClassGUID ( t_DeviceClass ) && t_DeviceClass.CompareNoCase ( CONFIG_MANAGER_CLASS_GUID_CDROM ) == 0 )
		{
			TCHAR *t_DosDeviceNameList = NULL ;
			if ( QueryDosDeviceNames ( t_DosDeviceNameList ) )
			{
				try
				{
					CHString t_DeviceId ;
					if ( t_Device->GetPhysicalDeviceObjectName ( t_DeviceId ) )
					{
						DWORD t_SpecifiedProperties = GetBitMask(a_Query);
						t_Result = LoadPropertyValues ( a_Instance, t_Device , t_DeviceId , t_DosDeviceNameList , t_SpecifiedProperties ) ;
					}
				}
				catch ( ... )
				{
					delete [] t_DosDeviceNameList ;
					throw;
				}

				delete [] t_DosDeviceNameList ;
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}
		}
    }

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32CDROM::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32CDROM :: EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags )
{
	HRESULT t_Result = Enumerate ( a_MethodContext , a_Flags ) ;
	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32CDROM :: ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    DWORD t_SpecifiedProperties = GetBitMask(a_Query);

	//if ( t_SpecifiedProperties )  //removed since would result in no query being executed if no special properties were selected.
	{
		t_Result = Enumerate ( a_MethodContext , a_Flags , t_SpecifiedProperties ) ;
	}

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32CDROM::Enumerate
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32CDROM :: Enumerate ( MethodContext *a_MethodContext , long a_Flags , DWORD a_SpecifiedProperties )
{
    HRESULT t_Result = WBEM_E_FAILED ;

	TCHAR *t_DosDeviceNameList = NULL ;
	if ( QueryDosDeviceNames ( t_DosDeviceNameList ) )
	{
		try
		{
			CConfigManager t_ConfigManager ;
			CDeviceCollection t_DeviceList ;

		/*
		*	While it might be more performant to use FilterByGuid, it appears that at least some
		*	95 boxes will report InfraRed info if we do it this way.
		*/

			if ( t_ConfigManager.GetDeviceListFilterByClass ( t_DeviceList, CONFIG_MANAGER_CLASS_CDROM ) )
			{
				REFPTR_POSITION t_Position ;

				if ( t_DeviceList.BeginEnum ( t_Position ) )
				{
					CConfigMgrDevicePtr t_Device;

					t_Result = WBEM_S_NO_ERROR ;

					// Walk the list

					for (t_Device.Attach(t_DeviceList.GetNext ( t_Position ));
						 SUCCEEDED(t_Result) && (t_Device != NULL);
						 t_Device.Attach(t_DeviceList.GetNext ( t_Position )))
					{
						CInstancePtr t_Instance (CreateNewInstance ( a_MethodContext ), false) ;
						CHString t_DeviceId ;
						if ( t_Device->GetPhysicalDeviceObjectName ( t_DeviceId ) )
						{
							t_Result = LoadPropertyValues ( t_Instance , t_Device , t_DeviceId , t_DosDeviceNameList , a_SpecifiedProperties ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
									t_Result = t_Instance->Commit (  ) ;
							}
						}
						else
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}
					}

					// Always call EndEnum().  For all Beginnings, there must be an End

					t_DeviceList.EndEnum();
				}
			}
		}
		catch ( ... )
		{
			delete [] t_DosDeviceNameList ;

			throw ;
		}

		delete [] t_DosDeviceNameList ;
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

    return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32CDROM :: LoadPropertyValues (

	CInstance *a_Instance,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	const TCHAR *a_DosDeviceNameList ,
	DWORD a_SpecifiedProperties
)
{
	HRESULT t_Result = LoadConfigManagerPropertyValues ( a_Instance , a_Device , a_DeviceName , a_SpecifiedProperties ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_SpecifiedProperties & SPECIAL_MEDIA )
		{
			CHString t_DosDeviceName ;
			t_Result = GetDeviceInformation ( a_Instance , a_Device , a_DeviceName , t_DosDeviceName , a_DosDeviceNameList , a_SpecifiedProperties ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = LoadMediaPropertyValues ( a_Instance , a_Device , a_DeviceName , t_DosDeviceName , a_DosDeviceNameList, a_SpecifiedProperties ) ;
			}
			else
			{
				t_Result = ( t_Result == WBEM_E_NOT_FOUND ) ? S_OK : t_Result ;
			}
		}
	}

	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32CDROM :: LoadConfigManagerPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	DWORD a_SpecifiedProperties
)
{
    HRESULT t_Result = WBEM_S_NO_ERROR;

	a_Instance->SetWBEMINT16(IDS_Availability, 3 ) ;

/*
 *	 Set PNPDeviceID, ConfigManagerErrorCode, ConfigManagerUserConfig
 */

	if ( a_SpecifiedProperties & SPECIAL_CONFIGPROPERTIES )
	{
		SetConfigMgrProperties ( a_Device, a_Instance ) ;

/*
 * Set the status based on the config manager error code
 */

		if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
		{
            CHString t_sStatus;
			if ( a_Device->GetStatus ( t_sStatus ) )
			{
				a_Instance->SetCHString ( IDS_Status , t_sStatus ) ;
			}
		}
	}
/*
 *	Use the PNPDeviceID for the DeviceID (key)
 */

//	if ( a_SpecifiedProperties & SPECIAL_PROPS_DEVICEID ) // Always populate the key
	{
		CHString t_Key ;

		if ( a_Device->GetDeviceID ( t_Key ) )
		{
			a_Instance->SetCHString ( IDS_DeviceID , t_Key ) ;
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONNAME )
	{
		a_Instance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_SYSTEMNAME )
	{
	    a_Instance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONCLASSNAME )
	{
		SetCreationClassName ( a_Instance ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_DESC_CAP_NAME )
	{
		CHString t_Description ;
		if ( a_Device->GetDeviceDesc ( t_Description ) )
		{
			if ( a_SpecifiedProperties & SPECIAL_PROPS_DESCRIPTION )
			{
				a_Instance->SetCHString ( IDS_Description , t_Description ) ;
			}
		}

/*
 *	Use the friendly name for caption and name
 */

		if ( a_SpecifiedProperties & SPECIAL_CAP_NAME )
		{
			CHString t_FriendlyName ;
			if ( a_Device->GetFriendlyName ( t_FriendlyName ) )
			{
				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_FriendlyName ) ;
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_FriendlyName ) ;
				}
			}
			else
			{
		/*
		 *	If we can't get the name, settle for the description
		 */

				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_Description );
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_Description );
				}
			}
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MANUFACTURER )
	{
		CHString t_Manufacturer ;

		if ( a_Device->GetMfg ( t_Manufacturer ) )
		{
			a_Instance->SetCHString ( IDS_Manufacturer, t_Manufacturer ) ;
		}
	}

/*
 *	Fixed value from enumerated list
 */

//	if ( a_SpecifiedProperties & SPECIAL_PROPS_PROTOCOLSSUPPORTED )
//	{
//	    a_Instance->SetWBEMINT16 ( _T("ProtocolSupported") , 16 ) ;
//	}

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32CDROM :: GetDeviceInformation
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32CDROM :: GetDeviceInformation (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	CHString a_DeviceName ,
	CHString &a_DosDeviceName ,
	const TCHAR *a_DosDeviceNameList ,
	DWORD a_SpecifiedProperties
)
{
	HRESULT t_Result = S_OK ;

	BOOL t_CreatedSymbolicLink = FALSE ;
	CHString t_SymbolicLinkName ;

    try
    {

	    BOOL t_Status = FindDosDeviceName ( a_DosDeviceNameList , a_DeviceName , t_SymbolicLinkName, TRUE ) ;
	    if ( ! t_Status )
	    {
		    t_SymbolicLinkName = CHString ( _TEXT("WMI_CDROMDEVICE_SYBOLICLINK") ) ;
		    EnterCriticalSection ( & m_CriticalSection ) ;
		    t_Status = DefineDosDevice ( DDD_RAW_TARGET_PATH , t_SymbolicLinkName , a_DeviceName ) ;
		    LeaveCriticalSection ( & m_CriticalSection ) ;
		    if ( t_Status )
		    {
			    t_CreatedSymbolicLink = TRUE ;
		    }
		    else
		    {
			    t_Result = WBEM_E_PROVIDER_FAILURE ;

			    DWORD t_LastError = GetLastError () ;
		    }
	    }

	    if ( t_Status )
	    {
		    CHString t_Device = CHString ( "\\\\.\\" ) + t_SymbolicLinkName ;

		    SmartCloseHandle t_Handle = CreateFile (

			    t_Device,
			    FILE_ANY_ACCESS ,
			    FILE_SHARE_READ|FILE_SHARE_WRITE,
			    NULL,
			    OPEN_EXISTING,
			    0,
			    NULL
		    );

		    if ( t_Handle != INVALID_HANDLE_VALUE )
		    {
			    STORAGE_DEVICE_NUMBER t_DeviceNumber;
			    DWORD t_BytesReturned;
			    ULONG t_Return = 0;

			    t_Status = DeviceIoControl (

				    t_Handle ,
				    IOCTL_STORAGE_GET_DEVICE_NUMBER ,
				    NULL ,
				    0 ,
				    & t_DeviceNumber ,
				    sizeof ( STORAGE_DEVICE_NUMBER ) ,
				    & t_BytesReturned ,
				    NULL
			    ) ;

			    if ( t_Status )
			    {
				    TCHAR t_DeviceLabel [ sizeof ( TCHAR ) * 17 + sizeof ( _TEXT("\\Device\\CDROM") ) ] ;
				    _stprintf ( t_DeviceLabel , _TEXT("\\Device\\CDROM%d") , t_DeviceNumber.DeviceNumber ) ;

				    t_Status = FindDosDeviceName ( a_DosDeviceNameList , t_DeviceLabel, a_DosDeviceName, TRUE ) ;
				    if ( ! t_Status )
				    {
					    t_Result = WBEM_E_NOT_FOUND ;
				    }
			    }
			    else
			    {
				    t_Result = WBEM_E_PROVIDER_FAILURE ;

				    DWORD t_Error = GetLastError () ;
			    }


	    /*
	     * Get SCSI information (IDE drives are still
	     * controlled by subset of SCSI miniport)
	     */

			    if ( a_SpecifiedProperties & SPECIAL_SCSIINFO )
			    {
				    SCSI_ADDRESS t_SCSIAddress ;
				    DWORD t_Length ;

				    t_Status = DeviceIoControl (

					    t_Handle ,
					    IOCTL_SCSI_GET_ADDRESS ,
					    NULL ,
					    0 ,
					    &t_SCSIAddress ,
					    sizeof ( SCSI_ADDRESS ) ,
					    &t_Length ,
					    NULL
				    ) ;

				    if ( t_Status )
				    {
					    if ( a_SpecifiedProperties & SPECIAL_PROPS_SCSITARGETID )
					    {
						    a_Instance->SetDWORD ( IDS_SCSITargetId , DWORD ( t_SCSIAddress.TargetId ) ) ;
					    }

					    if ( a_SpecifiedProperties & SPECIAL_PROPS_SCSIBUS )
					    {
						    a_Instance->SetWBEMINT16 ( IDS_SCSIBus , DWORD ( t_SCSIAddress.PathId ) ) ;
					    }

					    if ( a_SpecifiedProperties & SPECIAL_PROPS_SCSILUN )
					    {
						    a_Instance->SetWBEMINT16 ( IDS_SCSILogicalUnit , DWORD ( t_SCSIAddress.Lun ) ) ;
					    }

					    if ( a_SpecifiedProperties & SPECIAL_PROPS_SCSIPORT )
					    {
						    a_Instance->SetWBEMINT16 ( IDS_SCSIPort , DWORD ( t_SCSIAddress.PortNumber ) ) ;
					    }
				    }
			    }
#if NTONLY >= 5
				// Get Revision Number
				STORAGE_DEVICE_DESCRIPTOR t_StorageDevice;
				STORAGE_PROPERTY_QUERY	t_QueryPropQuery;
				

				t_QueryPropQuery.PropertyId = ( STORAGE_PROPERTY_ID ) 0;
				t_QueryPropQuery.QueryType = ( STORAGE_QUERY_TYPE ) 0;

		//		t_StorageDevice.Size = sizeof(STORAGE_DEVICE_DESCRIPTOR);
				DWORD dwLength;
				t_Status = DeviceIoControl (

					t_Handle,
					IOCTL_STORAGE_QUERY_PROPERTY,
					&t_QueryPropQuery,
					sizeof ( STORAGE_PROPERTY_QUERY ),
					&t_StorageDevice,
					sizeof(STORAGE_DEVICE_DESCRIPTOR),
					&dwLength,
					NULL
				) ;

				if ( t_Status )
				{
					if ( t_StorageDevice.ProductRevisionOffset != 0 )
					{
						LPWSTR lpBaseAddres = ( LPWSTR ) &t_StorageDevice;
						LPWSTR lpRevisionAddress =  lpBaseAddres + t_StorageDevice.ProductRevisionOffset;
						CHString t_Revision ( lpRevisionAddress );
						a_Instance->SetCHString ( IDS_MfrAssignedRevisionLevel, t_Revision );
					}
				}
				else
				{
					DWORD dwError = GetLastError();
				}
		
#endif
		    }
		    else
		    {
			    t_Result = WBEM_E_PROVIDER_FAILURE ;

			    DWORD t_Error = GetLastError () ;
		    }
	    }
    }
    catch ( ... )
    {

	    if ( t_CreatedSymbolicLink )
	    {
		    EnterCriticalSection ( & m_CriticalSection ) ;
		    BOOL t_Status = DefineDosDevice ( DDD_EXACT_MATCH_ON_REMOVE | DDD_REMOVE_DEFINITION , t_SymbolicLinkName , t_SymbolicLinkName ) ;
		    LeaveCriticalSection ( & m_CriticalSection ) ;
			DWORD t_LastError = GetLastError () ;
	    }

        throw;
    }

	if ( t_CreatedSymbolicLink )
	{
		EnterCriticalSection ( & m_CriticalSection ) ;
		BOOL t_Status = DefineDosDevice ( DDD_EXACT_MATCH_ON_REMOVE | DDD_REMOVE_DEFINITION , t_SymbolicLinkName , t_SymbolicLinkName ) ;
		LeaveCriticalSection ( & m_CriticalSection ) ;
		if ( ! t_Status )
		{
			t_Result = WBEM_E_PROVIDER_FAILURE ;

			DWORD t_LastError = GetLastError () ;
		}
	}

	return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32CDROM :: LoadMediaPropertyValues
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32CDROM::LoadMediaPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	const CHString &a_DosDeviceName ,
	const TCHAR* &a_DosDeviceNameList ,
	DWORD a_SpecifiedProperties
)
{

	HRESULT t_Result = S_OK ;

/*
 *
 */
    // Set common drive properties
    //=============================

	CHString t_DeviceLabel = CHString ( a_DosDeviceName ) ;

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DRIVE )
	{
	    a_Instance->SetCharSplat ( IDS_Drive, t_DeviceLabel ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_ID )
    {
		a_Instance->SetCharSplat ( IDS_Id, t_DeviceLabel ) ;
    }

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPABILITY )
	{
		// Create a safearray for the Capabilities information

		BOOL bSupportWrite = FALSE;
		bSupportWrite = SupportWrite ( a_DeviceName, a_DosDeviceNameList );

		SAFEARRAYBOUND t_ArrayBounds ;

		if ( bSupportWrite )
		{
			t_ArrayBounds.cElements = 3;
		}
		else
		{
			t_ArrayBounds.cElements = 2;
		}

		t_ArrayBounds.lLbound = 0;

		variant_t t_CapabilityValue ;

		if ( V_ARRAY ( & t_CapabilityValue ) = SafeArrayCreate ( VT_I2 , 1 , & t_ArrayBounds ) )
		{
			V_VT ( & t_CapabilityValue ) = VT_I2 | VT_ARRAY ;

			long t_Capability = 3 ;
			long t_Index = 0;
			SafeArrayPutElement ( V_ARRAY(&t_CapabilityValue) , & t_Index , & t_Capability) ;

			t_Index = 1;

			if ( bSupportWrite )
			{
				t_Capability = 4 ;
				SafeArrayPutElement ( V_ARRAY(&t_CapabilityValue) , & t_Index , & t_Capability ) ;

				t_Index = 2;
			}

			t_Capability = 7 ;
			SafeArrayPutElement ( V_ARRAY(&t_CapabilityValue) , & t_Index , & t_Capability ) ;

			a_Instance->SetVariant ( IDS_Capabilities , t_CapabilityValue ) ;
		}
	}

/*
 * Media type
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MEDIATYPE )
	{
	    a_Instance->SetCharSplat ( IDS_MediaType , IDS_MDT_CD ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_VOLUMEINFORMATION )
	{

/*
 * Set the DriveIntegrity and TransferRate properties:
 */

//		CHString t_VolumeDevice = CHString ( "\\\\.\\" ) + a_DosDeviceName + CHString ( "\\" ) ;
		CHString t_VolumeDevice = a_DosDeviceName;

		if ( a_SpecifiedProperties & SPECIAL_PROPS_TEST_TRANSFERRATE )
		{
			DOUBLE t_TransferRate = ProfileDrive ( t_VolumeDevice ) ;
			if ( t_TransferRate != -1 )
			{
				a_Instance->SetDOUBLE ( IDS_TransferRate , t_TransferRate ) ;
			}
		}

		if ( a_SpecifiedProperties & SPECIAL_PROPS_TEST_INTEGRITY )
		{
            CHString t_IntegrityFile;
			BOOL t_DriveIntegrity = TestDriveIntegrity ( t_VolumeDevice, t_IntegrityFile ) ;

            // If we didn't find an appropriate file, we didn't run the test
            if (!t_IntegrityFile.IsEmpty())
            {
			    a_Instance->Setbool ( IDS_DriveIntegrity,  t_DriveIntegrity ) ;
            }
		}

/*
 *	Volume information
 */

		TCHAR t_FileSystemName [ _MAX_PATH ] = _T("Unknown file system");

		TCHAR t_VolumeName [ _MAX_PATH ] ;
		DWORD t_VolumeSerialNumber ;
		DWORD t_MaxComponentLength ;
		DWORD t_FileSystemFlags ;

		BOOL t_SizeFound = FALSE ;

		BOOL t_Status =	GetVolumeInformation (

			t_VolumeDevice ,
			t_VolumeName ,
			sizeof ( t_VolumeName ) / sizeof(TCHAR) ,
			& t_VolumeSerialNumber ,
			& t_MaxComponentLength ,
			& t_FileSystemFlags ,
			t_FileSystemName ,
			sizeof ( t_FileSystemName ) / sizeof(TCHAR)
		) ;

		if ( t_Status )
		{
/*
 * There's a disk in -- set disk-related props
 */
			if ( a_SpecifiedProperties & SPECIAL_PROPS_MEDIALOADED )
			{
				a_Instance->Setbool ( IDS_MediaLoaded , true ) ;
			}

//			if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
//			{
//				a_Instance->SetCharSplat ( IDS_Status , IDS_OK ) ;
//			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_VOLUMENAME )
			{
				a_Instance->SetCharSplat ( IDS_VolumeName , t_VolumeName ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_MAXCOMPONENTLENGTH )
			{
				a_Instance->SetDWORD ( IDS_MaximumComponentLength , t_MaxComponentLength ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_FILESYSTEMFLAGS )
			{
				a_Instance->SetDWORD ( IDS_FileSystemFlags , t_FileSystemFlags ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_FILESYSTEMFLAGSEX )
			{
				a_Instance->SetDWORD ( IDS_FileSystemFlagsEx , t_FileSystemFlags ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_SERIALNUMBER )
			{
				TCHAR t_SerialNumber [ 9 ] ;

				_stprintf ( t_SerialNumber , _T("%x"), t_VolumeSerialNumber ) ;
				_tcsupr ( t_SerialNumber ) ;

				a_Instance->SetCharSplat ( IDS_VolumeSerialNumber , t_SerialNumber ) ;
			}

/*
 *	See if GetDiskFreeSpaceEx() is supported
 */

			if ( a_SpecifiedProperties & SPECIAL_VOLUMESPACE )
			{
				CHString t_DiskDevice = CHString ( _TEXT ("\\\\?\\") ) + a_DosDeviceName + CHString ( _TEXT("\\") ) ;

				ULARGE_INTEGER t_AvailableQuotaBytes ;
				ULARGE_INTEGER t_TotalBytes ;
				ULARGE_INTEGER t_AvailableBytes ;

				TCHAR t_TotalBytesString [ _MAX_PATH ];

                CKernel32Api* t_pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
                if(t_pKernel32 != NULL)
                {
                    // See if the function is available...
                    if(t_pKernel32->GetDiskFreeSpaceEx(t_DiskDevice, &t_AvailableQuotaBytes, &t_TotalBytes, &t_AvailableBytes, &t_Status))
                    {   // The function exists.
					    if ( t_Status ) // The call result was TRUE.
					    {
						    _stprintf ( t_TotalBytesString , _T("%I64d"), t_TotalBytes.QuadPart ) ;
						    a_Instance->SetCHString ( IDS_Size , t_TotalBytesString ) ;
						    t_SizeFound = TRUE ;
					    }
                    }
                    CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, t_pKernel32);
                    t_pKernel32 = NULL;
                }

		/*
		 *	If we couldn't get extended info -- use old API
		 *  (known to be inaccurate on Win95 for >2G drives)
		 */
				if ( ! t_SizeFound )
				{
					DWORD t_SectorsPerCluster ;
					DWORD t_BytesPerSector ;
					DWORD t_FreeClusters ;
					DWORD t_TotalClusters ;

					t_Status = GetDiskFreeSpace (

						t_DiskDevice ,
						& t_SectorsPerCluster,
						& t_BytesPerSector,
						& t_FreeClusters,
						& t_TotalClusters
					) ;

					if ( t_Status )
					{
						t_TotalBytes.QuadPart = (DWORDLONG) t_BytesPerSector * (DWORDLONG) t_SectorsPerCluster * (DWORDLONG) t_TotalClusters ;
						_stprintf( t_TotalBytesString , _T("%I64d"), t_TotalBytes.QuadPart ) ;
						a_Instance->SetCHString ( IDS_Size , t_TotalBytesString ) ;
					}
					else
					{
						DWORD t_LastError = GetLastError () ;
					}

				}
			}
		}
		else
		{
			DWORD t_LastError = GetLastError () ;

//			if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
//			{
//				a_Instance->SetCharSplat ( IDS_Status , IDS_STATUS_Unknown ) ;
//			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_MEDIALOADED )
			{
				a_Instance->Setbool ( IDS_MediaLoaded , false ) ;
			}
		}
	}


	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::ProfileDrive
 *
 *  DESCRIPTION : Determins how fast a drive can be read, in Kilobytes/second.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : KBPS/sec read
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

DOUBLE CWin32CDROM :: ProfileDrive ( CHString &a_VolumeName )
{
    CCdTest t_Cd ;
    DOUBLE t_TransferRate = -1;

    // Need to find a file of adequate size for use in profiling:

    CHString t_TransferFile = GetTransferFile ( a_VolumeName ) ;

    if ( ! t_TransferFile.IsEmpty () )
    {
	    if ( t_Cd.ProfileDrive ( t_TransferFile ) )
        {
            t_TransferRate = t_Cd.GetTransferRate();
        }
    }

    return t_TransferRate ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::TestDriveIntegrity
 *
 *  DESCRIPTION : Confirms that data can be read from the drive reliably
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : nichts
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32CDROM::TestDriveIntegrity ( CHString &a_VolumeName, CHString &a_IntegrityFile)
{
    CCdTest t_Cd ;

    a_IntegrityFile = GetIntegrityFile ( a_VolumeName ) ;
    if ( ! a_IntegrityFile.IsEmpty () )
    {
        return ( t_Cd.TestDriveIntegrity ( a_IntegrityFile ) ) ;
    }

    return FALSE;
}

DWORD CWin32CDROM::GetBitMask(CFrameworkQuery &a_Query)
{
    DWORD t_SpecifiedProperties = SPECIAL_PROPS_NONE_REQUIRED ;

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_DeviceID ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DEVICEID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemCreationClassName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SYSTEMNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Description ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DESCRIPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Caption ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Name ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_NAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Manufacturer ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MANUFACTURER ;
	}

    if ( a_Query.IsPropertyRequired ( _T("ProtocolSupported") ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_PROTOCOLSSUPPORTED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SCSITargetId ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SCSITARGETID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SCSIBus ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SCSIBUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SCSILogicalUnit ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SCSILUN ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SCSIPort ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SCSIPORT ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SCSITargetId ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SCSITARGETID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Drive ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DRIVE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Id ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_ID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Capabilities ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPABILITY ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_MediaType ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MEDIATYPE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_MediaLoaded ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MEDIALOADED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_VolumeName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_VOLUMENAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_MaximumComponentLength ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MAXCOMPONENTLENGTH ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_FileSystemFlags ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_FILESYSTEMFLAGS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_FileSystemFlagsEx ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_FILESYSTEMFLAGSEX ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_VolumeSerialNumber ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SERIALNUMBER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Size ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SIZE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_TransferRate ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_TEST_TRANSFERRATE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_DriveIntegrity ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_TEST_INTEGRITY ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_CreationClassName ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONCLASSNAME ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_PNPDeviceID ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_PNPDEVICEID ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerErrorCode ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMERRORCODE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerUserConfig ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMUSERCONFIG ;
    }

    return t_SpecifiedProperties;
}

BOOL CWin32CDROM::SupportWrite ( const CHString& a_DeviceName, const TCHAR* &a_DosDeviceNameList )
{
	BOOL bResult = FALSE;

	BOOL t_CreatedSymbolicLink = FALSE ;
	CHString t_SymbolicLinkName ;

	BOOL t_Status = FALSE;

    try
    {
	    t_Status = FindDosDeviceName ( a_DosDeviceNameList , a_DeviceName , t_SymbolicLinkName, TRUE ) ;
	    if ( ! t_Status )
	    {
		    t_SymbolicLinkName = CHString ( _TEXT("WMI_CDROMDEVICE_SYBOLICLINK") ) ;
		    EnterCriticalSection ( & m_CriticalSection ) ;
		    t_Status = DefineDosDevice ( DDD_RAW_TARGET_PATH , t_SymbolicLinkName , a_DeviceName ) ;
		    LeaveCriticalSection ( & m_CriticalSection ) ;
		    if ( t_Status )
		    {
			    t_CreatedSymbolicLink = TRUE ;
		    }
	    }

	    if ( t_Status )
	    {
		    CHString t_Device = CHString ( "\\\\.\\" ) + t_SymbolicLinkName ;

		    SmartCloseHandle t_Handle = CreateFile (

			    t_Device,
			    GENERIC_READ | GENERIC_WRITE,
			    FILE_SHARE_READ|FILE_SHARE_WRITE,
			    NULL,
			    OPEN_EXISTING,
			    FILE_FLAG_OVERLAPPED,
			    NULL
		    );

		    if ( t_Handle != INVALID_HANDLE_VALUE )
		    {
				DWORD t_BytesReturned = 0L;

				// let's try new way first
				GET_CONFIGURATION_IOCTL_INPUT IoctlInput;
				PGET_CONFIGURATION_HEADER     GetConfig; 

				if ( ( GetConfig = reinterpret_cast < PGET_CONFIGURATION_HEADER > ( new BYTE [ sizeof ( GET_CONFIGURATION_HEADER ) ] ) ) != NULL )
				{
					RtlZeroMemory ( &IoctlInput, sizeof ( GET_CONFIGURATION_IOCTL_INPUT ) );
					RtlZeroMemory ( GetConfig, sizeof ( GET_CONFIGURATION_HEADER ) );

					//
					//This will ask for all the profiles.
					//
					IoctlInput.Feature = FeatureProfileList;

					//
					//This tells the drive to report one and only one of the profiles back.
					//
					IoctlInput.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_ONE;

					//
					//REAL CALL
					//
					t_Status = DeviceIoControl (

						t_Handle ,
						IOCTL_CDROM_GET_CONFIGURATION ,
						&IoctlInput ,
						sizeof ( GET_CONFIGURATION_IOCTL_INPUT ) ,
						GetConfig ,
						sizeof ( GET_CONFIGURATION_HEADER ) ,
						& t_BytesReturned ,
						NULL
					) ;

					if ( t_Status )
					{
						DWORD dwBufferSize = 0;
						dwBufferSize =	GetConfig->DataLength[0] << 24 |
										GetConfig->DataLength[1] << 16 |
										GetConfig->DataLength[2] << 8  |
										GetConfig->DataLength[3] << 0  ;

						delete [] GetConfig;
						GetConfig = NULL;

						if ( ( GetConfig = reinterpret_cast < PGET_CONFIGURATION_HEADER > ( new BYTE [ dwBufferSize ] ) ) != NULL )
						{
							t_Status = DeviceIoControl (

								t_Handle ,
								IOCTL_CDROM_GET_CONFIGURATION ,
								&IoctlInput ,
								sizeof ( GET_CONFIGURATION_IOCTL_INPUT ) ,
								GetConfig ,
								dwBufferSize ,
								& t_BytesReturned ,
								NULL
							) ;

							if ( t_Status )
							{
								DWORD dwSize = 0L;
								PFEATURE_HEADER Features = reinterpret_cast < PFEATURE_HEADER > ( GetConfig->Data );

								//where can the last structure start and still be in the buffer?
								BYTE * pLastFeature = ((BYTE*)GetConfig) + t_BytesReturned - sizeof(FEATURE_HEADER);

								while (((BYTE*)Features <= pLastFeature) && !bResult )
								{
									UCHAR ucFeatureCode [2];
									memcpy ( &ucFeatureCode, &Features->FeatureCode, 2 * sizeof ( UCHAR ) );

									if ( ucFeatureCode == FeatureRandomWritable ||
										 ucFeatureCode == FeatureIncrementalStreamingWritable ||
										 ucFeatureCode == FeatureSectorErasable ||
										 ucFeatureCode == FeatureWriteOnce ||
										 ucFeatureCode == FeatureRestrictedOverwrite ||
										 ucFeatureCode == FeatureCdrwCAVWrite ||
										 // ucFeatureCode == FeatureDvdPlusRW || ( there is no description of that feature out there )
										 ucFeatureCode == FeatureDvdRecordableWrite )
									{
										bResult = TRUE;
									}

									if ( !bResult )
									{
										dwSize = sizeof ( FEATURE_HEADER ) + Features->AdditionalLength;
										Features = reinterpret_cast < PFEATURE_HEADER > ( reinterpret_cast < BYTE* > ( Features ) + dwSize );
									}
								}
							}

							delete [] GetConfig;
							GetConfig = NULL;
						}
					}
				}

				// will imapi way work at least ?
				if ( !bResult )
				{
					IMAPIDRV_INFO   imapiDrvInfo;
					IMAPIDRV_INIT   imapiInit;

					RtlZeroMemory ( &imapiInit, sizeof ( IMAPIDRV_INIT ) );
					RtlZeroMemory ( &imapiDrvInfo, sizeof ( IMAPIDRV_INFO ) );

					t_Status = DeviceIoControl (

						t_Handle ,
						IOCTL_IMAPIDRV_INIT ,
						&imapiInit ,
						sizeof ( IMAPIDRV_INIT ) ,
						&imapiInit ,
						sizeof ( IMAPIDRV_INIT ) ,
						& t_BytesReturned ,
						NULL
					) ;

					if ( t_Status )
					{
						t_Status = DeviceIoControl (

							t_Handle ,
							IOCTL_IMAPIDRV_INFO ,
							&imapiDrvInfo ,
							sizeof ( IMAPIDRV_INFO ) ,
							&imapiDrvInfo ,
							sizeof ( IMAPIDRV_INFO ) ,
							& t_BytesReturned ,
							NULL
						) ;

						if ( t_Status )
						{
							DWORD dwRecorderType = 0L;
							dwRecorderType = imapiDrvInfo.DeviceData.idwRecorderType;

//							// defines for idwRecorderType
//							#define RECORDER_TYPE_CDR     0x00000001
//							#define RECORDER_TYPE_CDRW    0x00000010

							if ( dwRecorderType )
							{
								bResult = TRUE;
							}
						}
						else
						{
//							if ( ::GetLastError () == ERROR_ACCESS_DENIED )
//							{
//								// could assume we are fine?
//								// we made it thru IOCTL_IMAPIDRV_INIT
//								bResult = TRUE;
//							}
						}
					}
				}
		    }
	    }
    }
    catch ( ... )
    {

	    if ( t_CreatedSymbolicLink )
	    {
		    EnterCriticalSection ( & m_CriticalSection ) ;
		    t_Status = DefineDosDevice ( DDD_EXACT_MATCH_ON_REMOVE | DDD_REMOVE_DEFINITION , t_SymbolicLinkName , t_SymbolicLinkName ) ;
		    LeaveCriticalSection ( & m_CriticalSection ) ;
			DWORD t_LastError = GetLastError () ;
	    }

        throw;
    }

	if ( t_CreatedSymbolicLink )
	{
		EnterCriticalSection ( & m_CriticalSection ) ;
		t_Status = DefineDosDevice ( DDD_EXACT_MATCH_ON_REMOVE | DDD_REMOVE_DEFINITION , t_SymbolicLinkName , t_SymbolicLinkName ) ;
		LeaveCriticalSection ( & m_CriticalSection ) ;
	}

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\cadapters.h ===
//=================================================================

//

// CAdapters.CPP -- Win9x adapter configuration retrieval

//

//  Copyright (c) 1998-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    09/15/98	        Created
//
//				03/03/99    		Added graceful exit on SEH and memory failures,
//											syntactic clean up		 
//
//=================================================================
#ifndef _CADAPTERS_H_
#define _CADAPTERS_H_


#include <tdiinfo.h>
#include <llinfo.h>
#include <tdistat.h>
#include <ipinfo.h>
#include "NTDriverIO.h"
#include <ipifcons.h>



// wsock32 wsControl 
//#define WSOCK_DLL		_T("wsock32.dll")
//#define WSCONTROL		"WsControl"
//typedef DWORD (CALLBACK* LPWSCONTROL)( DWORD, DWORD, LPVOID, LPDWORD, LPVOID, LPDWORD );
#define WSCNTL_TCPIP_QUERY_INFO 0


// IS_INTERESTING_ADAPTER - TRUE if the type of this adapter (IFEntry) is NOT
// loopback. Loopback (corresponding to local host) is the only one we filter
// out right now
#define IS_INTERESTING_ADAPTER(p)   (!((p)->if_type == MIB_IF_TYPE_LOOPBACK))

// from: index1/nt/private/inc/ipinfo.h 
// This version is specific to NT and is defined locally to
// to differentiate this structure from Win9x.
// If we move to dual binary we should #ifdef *ire_context
// for NT and rename IPRouteEntryNT to IPRouteEntry.  
//  
typedef struct IPRouteEntryNT { 
	ulong           ire_dest;
	ulong           ire_index; 
	ulong           ire_metric1;
	ulong           ire_metric2; 
	ulong           ire_metric3;
	ulong           ire_metric4; 
	ulong           ire_nexthop;
	ulong           ire_type;   
	ulong           ire_proto;
	ulong           ire_age;  
	ulong           ire_mask;
	ulong           ire_metric5;  
	void            *ire_context;
} IPRouteEntryNT;


class _IP_INFO
{
public:
	CHString chsIPAddress;
	CHString chsIPMask;
	union {
		DWORD dwIPAddress;
		BYTE bIPAddress[4];
	};
	union {
		DWORD dwIPMask;
		BYTE bIPMask[4];
	};
	DWORD	 dwContext;
	DWORD	 dwCostMetric;
};

//#define MAX_ADAPTER_DESCRIPTION_LENGTH  128 
//#define MAX_ADAPTER_ADDRESS_LENGTH      8   

class _ADAPTER_INFO
{
public:
    CHString    Interface;
	CHString	Description;
	CHString	IPXAddress;
	CHPtrArray	aIPInfo;		// _IP_INFO array
	CHPtrArray	aGatewayInfo;	// _IP_INFO array
	UINT		AddressLength;
	BYTE		Address[MAX_ADAPTER_ADDRESS_LENGTH];
	UINT		Index;
	UINT		Type;
	BOOL		IPEnabled;
	BOOL		IPXEnabled;
	BOOL		Marked;

	_ADAPTER_INFO();
	~_ADAPTER_INFO();

	void Mark();
	BOOL IsMarked();
};

// _ADAPTER_INFO array class
class CAdapters : public CHPtrArray
{
private:
	
	void GetAdapterInstances();
	BOOL GetIPXMACAddress( _ADAPTER_INFO *a_pAdapterInfo, BYTE a_bMACAddress[ 6 ] );
	BOOL GetTCPAdapter(_ADAPTER_INFO* pAdapterInfo, PIP_ADAPTER_INFO lAdapterInfo);
	_IP_INFO* pAddIPInfo( DWORD dwIPAddr, DWORD dwIPMask, DWORD dwContext, DWORD a_dwCostMetric = 0 );

    //
    // The following function is based on IP V4 based. I future should be 
    // rewritten for IP V6 based.
    //

    DWORD IpStringToDword(const PCHAR IpString)
    {
        DWORD Address = 0;
        char strtemp[4];
        int i = 0, j=0,count=0;
        while(IpString[i] && j < 4 && i < 16)
        {
            if(IpString[i] == '.'){
                strtemp[j] = '\0';
                Address = Address  | atol(strtemp) << 8*count++;
                j = -1;
            } else {
                strtemp[j] = IpString[i];
            }
            i++;j++;
        }
        if( j < 4 ){
            strtemp[j] = '\0';
            Address = Address | atol(strtemp) << 8*count;
        }
        return Address;
    }

#if NTONLY >= 5
    void GetRouteCostMetric(
        DWORD dwIPAddr, 
        PMIB_IPFORWARDTABLE pmibft, 
        PDWORD pdwMetric);
#endif

public:
	        
	//=================================================
	// Constructor/destructor
	//=================================================
	CAdapters();
	~CAdapters();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\bservice.h ===
//=================================================================

//

// Service.h -- Service property set provider (Windows NT only)

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_BASESERVICE		L"Win32_BaseService"
#define PROPERTY_NAME_STATE				L"State"
#define PROPERTY_NAME_ACCEPTSTOP		L"AcceptStop"
#define PROPERTY_NAME_ACCEPTPAUSE		L"AcceptPause"

#define PROPERTY_VALUE_STATE_STOPPED			L"Stopped"
#define PROPERTY_VALUE_STATE_STARTPENDING		L"Start Pending"
#define PROPERTY_VALUE_STATE_STOPPENDING		L"Stop Pending"
#define PROPERTY_VALUE_STATE_RUNNING			L"Running"
#define PROPERTY_VALUE_STATE_CONTINUEPENDING	L"Continue Pending"
#define PROPERTY_VALUE_STATE_PAUSEPENDING		L"Pause Pending"
#define PROPERTY_VALUE_STATE_PAUSED				L"Paused"

#define METHOD_NAME_START				L"StartService"
#define METHOD_NAME_STOP				L"StopService"
#define METHOD_NAME_PAUSE				L"PauseService"
#define METHOD_NAME_RESUME				L"ResumeService"
#define METHOD_NAME_USERCONTROLSERVICE	L"UserControlService"
#define METHOD_NAME_INTERROGATE			L"InterrogateService"
#define METHOD_NAME_CREATE				L"Create"
#define METHOD_NAME_CHANGESTARTMODE		L"ChangeStartMode"
#define METHOD_NAME_DELETE				L"Delete"
#define METHOD_NAME_CHANGE				L"Change"
#define METHOD_ARG_NAME_CONTROLCODE		L"ControlCode"

#define METHOD_NAME_INDEX_START					0
#define METHOD_NAME_INDEX_STOP					1
#define METHOD_NAME_INDEX_PAUSE					2
#define METHOD_NAME_INDEX_RESUME				3
#define METHOD_NAME_INDEX_USERCONTROLSERVICE	4
#define METHOD_NAME_INDEX_INTERROGATE			5
#define METHOD_ARG_NAME_CONTROLCODE		L"ControlCode"
#define METHOD_ARG_NAME_RETURNVALUE		L"ReturnValue"


#define METHOD_ARG_CLASS_WIN32_BASESERVICE				L"Win32_BaseService"
#define METHOD_ARG_CLASS_WIN32_LOADORDERGROUP			L"Win32_LoadOrderGroup"

#define METHOD_ARG_NAME_LOADORDERGROUPDEPENDENCIES	L"LoadOrderGroupDependencies"
#define METHOD_ARG_NAME_SERVICEDEPENDENCIES			L"ServiceDependencies"

#define METHOD_ARG_NAME_DESKTOPINTERACT			L"DesktopInteract"
#define METHOD_ARG_NAME_NAME					L"Name"
#define METHOD_ARG_NAME_DISPLAYNAME				L"DisplayName"
#define METHOD_ARG_NAME_ERRORCONTROL			L"ErrorControl"
#define METHOD_ARG_NAME_PATHNAME				L"PathName"
#define METHOD_ARG_NAME_SERVICETYPE				L"ServiceType"
#define METHOD_ARG_NAME_STARTMODE				L"StartMode"
#define METHOD_ARG_NAME_STARTNAME				L"StartName"
#define METHOD_ARG_NAME_STARTPASSWORD			L"StartPassword"
#define METHOD_ARG_NAME_LOADORDERGROUP			L"LoadOrderGroup"

#define PROPERTY_VALUE_STARTNAME_LOCAL_SYSTEM		L"LocalSystem"

#define PROPERTY_VALUE_START_TYPE_BOOT				L"Boot"
#define PROPERTY_VALUE_START_TYPE_SYSTEM			L"System"
#define PROPERTY_VALUE_START_TYPE_AUTOMATIC			L"Automatic"
#define PROPERTY_VALUE_START_TYPE_MANUAL			L"Manual"
#define PROPERTY_VALUE_START_TYPE_DISABLE			L"Disabled"

#define PROPERTY_VALUE_SERVICE_TYPE_KERNAL_DRIVER		1
#define PROPERTY_VALUE_SERVICE_TYPE_FILE_SYSTEM_DRIVER	2
#define PROPERTY_VALUE_SERVICE_TYPE_ADAPTER				4
#define PROPERTY_VALUE_SERVICE_TYPE_RECOGNIZER_DRIVER	8
#define PROPERTY_VALUE_SERVICE_TYPE_OWN_PROCESS			16
#define PROPERTY_VALUE_SERVICE_TYPE_SHARE_PROCESS		32

#define PROPERTY_VALUE_ERROR_CONTROL_IGNORE		0
#define PROPERTY_VALUE_ERROR_CONTROL_NORMAL		1
#define PROPERTY_VALUE_ERROR_CONTROL_SEVERE		2
#define PROPERTY_VALUE_ERROR_CONTROL_CRITICAL	3

// Common
#undef STATUS_SUCCESS
#define STATUS_SUCCESS							0
#undef STATUS_NOT_SUPPORTED					
#define STATUS_NOT_SUPPORTED					1

// Control
#undef STATUS_ACCESS_DENIED				
#define STATUS_ACCESS_DENIED					2
#define STATUS_DEPENDENT_SERVICES_RUNNING		3
#define STATUS_INVALID_SERVICE_CONTROL			4
#define STATUS_SERVICE_CANNOT_ACCEPT_CTRL		5
#define STATUS_SERVICE_NOT_ACTIVE				6
#define STATUS_SERVICE_REQUEST_TIMEOUT			7
#define STATUS_UNKNOWN_FAILURE					8

// Start
#define STATUS_PATH_NOT_FOUND					9
#define STATUS_SERVICE_ALREADY_RUNNING			10
#define STATUS_SERVICE_DATABASE_LOCKED			11
#define STATUS_SERVICE_DEPENDENCY_DELETED		12
#define STATUS_SERVICE_DEPENDENCY_FAIL			13
#define STATUS_SERVICE_DISABLED					14
#define STATUS_SERVICE_LOGON_FAILED				15
#define STATUS_SERVICE_MARKED_FOR_DELETE		16
#define STATUS_SERVICE_NO_THREAD				17
#define STATUS_SERVICE_ALREADY_PAUSED			24

// Create
#define STATUS_CIRCULAR_DEPENDENCY				18
#define STATUS_DUP_NAME							19
#define STATUS_INVALID_NAME						20
#undef STATUS_INVALID_PARAMETER			
#define STATUS_INVALID_PARAMETER				21
#define STATUS_INVALID_SERVICE_ACCOUNT			22
#define STATUS_SERVICE_EXISTS					23

// Get/set function protos
//========================

///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
//                                                                                   //
//                           PROPERTY SET DEFINITION                                 //
//                                                                                   //
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////

class Win32_BaseService :public Provider
{
public:

        // Constructor/destructor
        //=======================

        Win32_BaseService (

			const CHString &a_Name,
			LPCWSTR a_Namespace
		) ;

       ~Win32_BaseService () ;

        // Functions provide properties with current values
        //=================================================

        HRESULT GetObject(CInstance *pInstance, long lFlags = 0L) { return WBEM_E_NOT_AVAILABLE ; }

        HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L) { return WBEM_E_NOT_AVAILABLE ; }

		HRESULT ExecMethod (

			const CInstance &a_Instance,
			const BSTR a_MethodName,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags = 0L
		) ;

		HRESULT DeleteInstance (

			const CInstance& a_Instance,
			long a_Flags = 0L
		) ;

    protected:

        // Utility
        //========

        // Utility function(s)
        //====================

#ifdef NTONLY
		HRESULT GetServiceStatus (

			const CInstance& a_Instance,
			CHString &a_Name ,
			DWORD &a_State ,
			bool &a_AcceptPause ,
			bool &a_AcceptStop
		) ;

		DWORD GetServiceErrorCode () ;
		HRESULT GetServiceResultCode () ;

		DWORD CheckParameters (

			const CInstance& a_Instance,
			CInstance *a_InParams ,
			CInstance *a_OutParams ,
			DWORD &a_Status ,
			BOOL a_Create
		) ;

		HRESULT ExecStart (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecStop (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecPause (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecResume (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecInterrogate (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecUserControlService (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecCreate (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecChange (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecDelete (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecChangeStartMode (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;
#endif

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\cdrom.h ===
//=================================================================

//

// Cdrom.h -- Cdrom property set provider

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:  
//
//=================================================================
#ifndef _CDROM_H
#define _CDROM_H

// Property set identification
//============================
#if NTONLY >= 5
#else
	typedef BOOL (WINAPI *KERNEL32_DISK_FREESPACEEX) (LPCTSTR lpDirectoryName,
													  PULARGE_INTEGER lpFreeBytesAvailableToCaller,
													  PULARGE_INTEGER lpTotalNumberOfBytes,
													  PULARGE_INTEGER lpTotalNumberOfFreeBytes) ;

    typedef std::map<CHString, CHString> STRING2STRING;

#endif	

#define PROPSET_NAME_CDROM				L"Win32_CDROMDrive"

#define METHOD_NAME_PROFILEDRIVE		L"ProfileDrive"
#define METHOD_NAME_TESTDRIVEINTEGRITY	L"TestDriveIntegrity"

#define SPECIAL_PROPS_ALL_REQUIRED          0xFFFFFFFF
#define SPECIAL_PROPS_NONE_REQUIRED         0x00000000
#define SPECIAL_PROPS_TEST_INTEGRITY        0x00000001
#define SPECIAL_PROPS_TEST_TRANSFERRATE     0x00000002
#define SPECIAL_PROPS_STATUS				0x00000004
#define SPECIAL_PROPS_DEVICEID				0x00000008
#define SPECIAL_PROPS_CREATIONNAME			0x00000010
#define SPECIAL_PROPS_SYSTEMNAME			0x00000020
#define SPECIAL_PROPS_DESCRIPTION			0x00000040
#define SPECIAL_PROPS_CAPTION				0x00000080
#define SPECIAL_PROPS_NAME					0x00000100
#define SPECIAL_PROPS_MANUFACTURER			0x00000200
#define SPECIAL_PROPS_PROTOCOLSSUPPORTED	0x00000400
#define SPECIAL_PROPS_SCSITARGETID			0x00000800
#define SPECIAL_PROPS_DRIVE					0x00001000
#define SPECIAL_PROPS_ID					0x00002000
#define SPECIAL_PROPS_CAPABILITY			0x00004000
#define SPECIAL_PROPS_MEDIATYPE				0x00008000
#define SPECIAL_PROPS_VOLUMENAME			0x00010000
#define SPECIAL_PROPS_MAXCOMPONENTLENGTH	0x00020000
#define SPECIAL_PROPS_FILESYSTEMFLAGS		0x00040000
#define SPECIAL_PROPS_SERIALNUMBER			0x00080000
#define SPECIAL_PROPS_SIZE					0x00100000
#define SPECIAL_PROPS_MEDIALOADED			0x00200000
#define SPECIAL_PROPS_PNPDEVICEID			0x00400000
#define SPECIAL_PROPS_CONFIGMERRORCODE		0x00800000
#define SPECIAL_PROPS_CONFIGMUSERCONFIG		0x01000000
#define SPECIAL_PROPS_CREATIONCLASSNAME		0x02000000
#define SPECIAL_PROPS_SCSILUN				0x04000000
#define SPECIAL_PROPS_SCSIBUS				0x08000000
#define SPECIAL_PROPS_SCSIPORT				0x10000000
#define SPECIAL_PROPS_FILESYSTEMFLAGSEX		0x20000000
#define SPECIAL_PROPS_MFRREVISIONLEVEL		0x40000000

#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER | \
									SPECIAL_MEDIA )

#define SPECIAL_CONFIGMANAGER		( SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_DEVICEID | \
									SPECIAL_PROPS_CREATIONNAME | \
									SPECIAL_PROPS_SYSTEMNAME | \
									SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME | \
									SPECIAL_PROPS_MANUFACTURER | \
									SPECIAL_PROPS_PROTOCOLSSUPPORTED | \
									SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_CREATIONCLASSNAME )

#define SPECIAL_CONFIGPROPERTIES 	( SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_STATUS )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_CAP_NAME			( SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_MEDIA				( SPECIAL_PROPS_TEST_INTEGRITY | \
									SPECIAL_PROPS_TEST_TRANSFERRATE | \
									SPECIAL_SCSIINFO | \
									SPECIAL_PROPS_DRIVE | \
									SPECIAL_PROPS_ID | \
									SPECIAL_PROPS_CAPABILITY | \
									SPECIAL_PROPS_MEDIATYPE | \
									SPECIAL_PROPS_VOLUMENAME | \
									SPECIAL_PROPS_MAXCOMPONENTLENGTH | \
									SPECIAL_PROPS_FILESYSTEMFLAGS | \
                                    SPECIAL_PROPS_FILESYSTEMFLAGSEX |  \
									SPECIAL_PROPS_SERIALNUMBER | \
									SPECIAL_PROPS_SIZE | \
									SPECIAL_PROPS_MEDIALOADED )

#define SPECIAL_SCSIINFO			( SPECIAL_PROPS_SCSITARGETID | \
									SPECIAL_PROPS_SCSIBUS | \
									SPECIAL_PROPS_SCSILUN | \
									SPECIAL_PROPS_SCSIPORT )

#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER | \
									SPECIAL_MEDIA )

#define SPECIAL_VOLUMEINFORMATION	( SPECIAL_PROPS_TEST_INTEGRITY | \
									SPECIAL_PROPS_TEST_TRANSFERRATE | \
									SPECIAL_PROPS_MEDIATYPE | \
									SPECIAL_PROPS_VOLUMENAME | \
									SPECIAL_PROPS_MAXCOMPONENTLENGTH | \
									SPECIAL_PROPS_FILESYSTEMFLAGS | \
                                    SPECIAL_PROPS_FILESYSTEMFLAGSEX | \
									SPECIAL_PROPS_SERIALNUMBER | \
									SPECIAL_PROPS_SIZE | \
									SPECIAL_PROPS_MEDIALOADED )
	

#define SPECIAL_VOLUMESPACE			( SPECIAL_PROPS_SIZE )
	
class CWin32CDROM : public Provider
{

	private:

        // Utility function(s)
        //====================
	protected:
		
		// ExecMethod methods
		//===================
		DOUBLE ProfileDrive ( CHString &a_VolumeName ) ;
		BOOL TestDriveIntegrity ( CHString &a_VolumeName, CHString &a_IntegrityFile ) ;

	#if NTONLY >= 5	
		CRITICAL_SECTION m_CriticalSection ;


        // Utility function(s)
        //====================

		HRESULT Enumerate ( 

			MethodContext *a_MethodContext , 
			long a_Flags , 
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED
		) ;

		HRESULT LoadPropertyValues ( 

			CInstance *a_Instance, 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			const TCHAR *a_DosDeviceNameList ,
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED 
		) ;

		HRESULT LoadConfigManagerPropertyValues ( 

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			DWORD a_SpecifiedPropertied
		) ;

		HRESULT GetDeviceInformation ( 

			CInstance *a_Instance ,
			CConfigMgrDevice *a_Device , 
			CHString a_DeviceName , 
			CHString &a_DosDeviceName ,
			const TCHAR *a_DosDeviceNameList ,
			DWORD a_SpecifiedPropertied
		) ;

		HRESULT LoadMediaPropertyValues (	

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			const CHString &a_DosDeviceName ,
			const TCHAR* &a_DosDeviceNameList ,
			DWORD a_SpecifiedPropertied 
		) ;

        DWORD CWin32CDROM::GetBitMask(CFrameworkQuery &a_Query);

		BOOL SupportWrite ( const CHString& a_Device, const TCHAR* &a_DosDeviceNameList );

	#endif

	public:

        // Constructor/destructor
        //=======================

        CWin32CDROM ( LPCWSTR a_pszName, LPCWSTR a_pszNamespace ) ;
       ~CWin32CDROM () ;

        // Functions provide properties with current values
        //=================================================

        HRESULT GetObject ( 

			CInstance *a_Instance, 
			long a_Flags,
            CFrameworkQuery &a_Query
		) ;

        HRESULT EnumerateInstances ( 

			MethodContext *a_MethodContext, 
			long a_Flags = 0L 
		) ;

        HRESULT ExecQuery ( 

			MethodContext *a_MethodContext, 
			CFrameworkQuery &a_Query, 
			long a_Flags = 0L
		) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\cnetconn.h ===
//=================================================================

//

// cnetconn.h -- Persistent network connection property set provider

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//			  a-peterc 5/25/99 Reworked...	
//
//=================================================================
#ifndef __CNETCONN_H__
#define __CNETCONN_H__

#define NETCONN_FIRST  0
#define NETCONN_NEXT   1
#define NETCONN_CLOSE  2

#include <deque>

class CConnection
{
public:
	enum eConnectionScope{ e_Connected, e_Remembered, e_IPC } ;

	DWORD		dwScope ;
    DWORD		dwType ;
    DWORD		dwDisplayType ;
    DWORD		dwUsage ;
    CHString	chsLocalName ;
    CHString	chsRemoteName ;
    CHString	chsComment ;
    CHString	chsProvider ;

	eConnectionScope	eScope ;
	CHString			strKeyName ;
	CHString			strUserName ;
	DWORD				dwStatus ;
};

class CNetConnection
{
private:

	CMprApi *m_MprApi ;

	typedef std::deque<CConnection*>  Connection_Ptr_List ;
	Connection_Ptr_List				m_oConnectionList; 
	Connection_Ptr_List::iterator	m_ConnectionIter ;

	BOOL			AddConnectionToList( 

						NETRESOURCE *a_pNetResource,
						CConnection::eConnectionScope a_eScope,
                        short shStatus
						) ;

	BOOL			FillInConnection( 

						NETRESOURCE *a_pNetResource, 
						CConnection *a_pConnection,
						CConnection::eConnectionScope a_eScope
						) ;

	void			ClearConnectionList() ;
	
	DWORD			GetStatus( LPNETRESOURCE a_pNetResource ) ;
	void			GetUser( LPNETRESOURCE a_pNetResource, CConnection *a_pConnection ) ;

	void			CreateNameKey (
					
						LPNETRESOURCE a_lpNetResource, 
						CHString &a_strName
						) ;

public:

					CNetConnection() ;
					~CNetConnection() ;

	BOOL			GetConnection( 
						
						CHString &a_rstrFind, 
						CConnection &a_rConnection
						) ; 
	
	BOOL			LoadConnections() ;
	void			BeginConnectionEnum() ;
	BOOL			GetNextConnection( CConnection **a_pConnection ) ;


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\cimdatafile.h ===
//=================================================================
//
// CIMDataFile.h -- CIMDataFile property set provider
//
//  Copyright (c) 1998-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/16/98    a-kevhu         Created
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_CIMDATAFILE L"CIM_DataFile"


class CCIMDataFile;

class CCIMDataFile : public CImplement_LogicalFile
{

    public:

        // Constructor/destructor
        //=======================

        CCIMDataFile(const CHString& name, LPCWSTR pszNamespace);
       ~CCIMDataFile() ;

    protected:

        // Overridable function inherrited from CImplement_LogicalFile
#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName);
#endif

        // Overridable function inherrited from CProvider
        virtual void GetExtendedProperties(CInstance* pInstance, long lFlags = 0L);
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\cimlogicaldevice_cimdatafile.cpp ===
//=================================================================

//

// CIMLogicalDevice_CIMDataFile.cpp -- cim_logicaldevice to CIM_DataFile

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/20/98    a-kevhu         Created
//
// Comment: Relationship between logical device and datafile
//
//=================================================================

#include "precomp.h"
#include <vector>
#include <cregcls.h>
#include <comdef.h>
#include "PNPEntity.h"
#include "LPVParams.h"
#include <io.h>

#ifdef TEST
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#endif

#include "CIMLogicalDevice_CIMDataFile.h"

// Property set declaration
//=========================

CCIMDeviceCIMDF MyDevBus(PROPSET_NAME_DEVICEDATAFILE, IDS_CimWin32Namespace);

//#define TEST
#ifdef TEST
LONG g_lDepth = 0L;
#endif





VOID OutputDebugInfo(CHString chstr)
{
#ifdef TEST
    FILE* fp;
    fp = fopen("d:\\temp\\cld-cdf.txt", "at");
    for(LONG n = 0L; n < g_lDepth; n++) fputs("    ",fp);
    fputs(chstr,fp);
    fputs("\n",fp);
    fclose(fp);
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::CCIMDeviceCIMDF
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CCIMDeviceCIMDF::CCIMDeviceCIMDF(LPCWSTR setName, LPCWSTR pszNamespace)
    : CWin32PNPEntity(setName, pszNamespace),
      Provider(setName, pszNamespace) // required since we inherit virtually
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::~CCIMDeviceCIMDF
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CCIMDeviceCIMDF::~CCIMDeviceCIMDF()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CCIMDeviceCIMDF::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CHString chstrDevice;
    CHString chstrDataFile;
    HRESULT hr = WBEM_E_NOT_FOUND;
    std::vector<CHString*> vecpchsDriverFileList;
    CHString chstrPNPDeviceID;
    CHString chstrFilePathName;
    BOOL fFoundDriverFiles = FALSE;


#ifdef NTONLY
    std::vector<CNT5DevDrvMap*> vecpNT5DDM;
#endif

    // Get the two paths
    pInstance->GetCHString(IDS_Antecedent, chstrDevice);
    pInstance->GetCHString(IDS_Dependent, chstrDataFile);

    // See if the datafile instance exists (object name is valid and file actually exists).
    if(ObjNameValid(chstrDataFile,L"CIM_DataFile",L"Name",chstrFilePathName) && (_taccess(TOBSTRT(chstrFilePathName),0) != -1))
    {
        // Datafile exists.  Now check if device instance exists (object name valid and device actually exists)
        CConfigMgrDevicePtr pDevice(NULL);
        if(ObjNameValid(chstrDevice, L"Win32_PnPEntity", L"DeviceID", chstrPNPDeviceID) &&
           (DeviceExists(chstrPNPDeviceID, pDevice)))
        {
            // So both ends exist.  Now need to Make sure the the device is really associated with the file.
            // First, get a file list for the device:
#ifdef NTONLY
            // If NT5, generate device/driver file mappings once
            //GenerateNT5DeviceDriverMappings(vecpNT5DDM);
            CHString chstrDevSvcName;
            if(pDevice->GetService(chstrDevSvcName))
            {
                GenerateNT5ServiceDriverMap(chstrDevSvcName, vecpNT5DDM);

                try
                {
                    fFoundDriverFiles = GenerateDriverFileListNT5(vecpchsDriverFileList,
                                                                  chstrPNPDeviceID,
                                                                  vecpNT5DDM,
                                                                  FALSE);
                }
                catch ( ... )
                {
#ifdef NTONLY
                    CleanPNT5DevDrvMapVector(vecpNT5DDM);
#endif
                    throw;
                }

            }
#endif
        }

        try
        {
            // Second, see if the file is a member of the list:
            if(fFoundDriverFiles)
            {
                if(AlreadyAddedToList(vecpchsDriverFileList,chstrFilePathName))
                {
                    pInstance->SetWBEMINT16(IDS_Purpose, Driver);
					SetPurposeDescription(pInstance, chstrFilePathName);  // whether they need it or not since this is GetObject

                    // this means the file is associated with the device
                    hr = WBEM_S_NO_ERROR;
                }
            }
        }
        catch ( ... )
        {
            // Free pointers in the vector:
            CleanPCHSTRVector(vecpchsDriverFileList);
#ifdef NTONLY
            CleanPNT5DevDrvMapVector(vecpNT5DDM);
#endif
            throw ;
        }
    }
    // Free pointers in the vector:
    CleanPCHSTRVector(vecpchsDriverFileList);

#ifdef NTONLY
    CleanPNT5DevDrvMapVector(vecpNT5DDM);
#endif

    return hr;
}



// Enumeration for this class can utilize the base class's Enumeration routine.


/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::ExecQuery
 *
 *  DESCRIPTION :
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *  RETURNS     :
 *
 *  COMMENTS    : Only optimizes based on specified antecedents, not dependents.
 *
 *****************************************************************************/
HRESULT CCIMDeviceCIMDF::ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long Flags)
{
    // Get the name(s) of the specified dependents, if any.  If none, we will
    // enumerate.
    HRESULT hr = WBEM_S_NO_ERROR;
    std::vector<_bstr_t> vecAnt;
    pQuery.GetValuesForProp(IDS_Antecedent, vecAnt);
    DWORD dwNumAnt = vecAnt.size();

    if(dwNumAnt > 0)
    {
        // We have one or more dependents (devices) specified.  Confirm that
        // each is a valid, existing instance, then load prop values.
        for(int i = 0; i < dwNumAnt; i++)
        {
            CHString chstrPNPDeviceID;
            CConfigMgrDevicePtr pDevice(NULL);

            if(ObjNameValid((LPCWSTR) (LPWSTR) vecAnt[i], L"Win32_PnPEntity", L"DeviceID", chstrPNPDeviceID) &&
               (DeviceExists(chstrPNPDeviceID, pDevice)))
            {
                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                if(SUCCEEDED(hr = LoadPropertyValues(&CLPVParams(pInstance , pDevice, -1L))))
				{
                    hr = pInstance->Commit();
				}
            }
        }
    }
    else
    {
        // We don't optimize on the specified query, so do an enum via the base
        hr = EnumerateInstances(pMethodContext, Flags);
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::LoadPropertyValues
 *
 *  DESCRIPTION :
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CCIMDeviceCIMDF::LoadPropertyValues(void* pvData)
{
    CHString chstrPNPDeviceID;
    CHString chstrDevicePath;
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL fFoundDriverFiles = FALSE;
    BOOL bRecurse = TRUE;
    std::vector<CHString*> vecpchsDriverFileList;

    CLPVParams* pParams = (CLPVParams*)pvData;
    CInstance* pInstance = (CInstance*)(pParams->m_pInstance);  // This instance released by caller
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)(pParams->m_pDevice);
    DWORD dwReqProps = (DWORD)(pParams->m_dwReqProps);

    if(pDevice == NULL || pInstance == NULL) return hr;

    MethodContext* pMethodContext = pInstance->GetMethodContext();
    if(pMethodContext == NULL) return hr;

    // Don't even bother if on nt 3.51
#ifdef NTONLY
    std::vector<CNT5DevDrvMap*> vecpNT5DDM;

    if(GetPlatformMajorVersion() <= 3)   // i.e., we're on NT3 something or less
    {
        return hr;
    }

    // If NT5, generate device/driver file mappings once
    if(IsWinNT5())
    {
        // Call the version that gets a map just for that device's service
        CHString chstrDevSvcName;
        if(pDevice->GetService(chstrDevSvcName))
        {
            GenerateNT5ServiceDriverMap(chstrDevSvcName, vecpNT5DDM);
        }
        else
        {
            return hr;
        }
    }
#endif

     // The first step is to build up a list of driver files the device
     // and all of its children use.  How this is done is platform specific.

    pDevice->GetDeviceID(chstrPNPDeviceID);
    CHString chstrPNPDeviceIDAdj;
    EscapeBackslashes(chstrPNPDeviceID, chstrPNPDeviceIDAdj);
    chstrDevicePath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                           (LPCWSTR)GetLocalComputerName(),
                           IDS_CimWin32Namespace,
                           PROPSET_NAME_PNPEntity,
                           IDS_DeviceID,
                           (LPCWSTR)chstrPNPDeviceIDAdj);

#ifdef NTONLY
    if(IsWinNT4())
    {
        fFoundDriverFiles = GenerateDriverFileListNT4(vecpchsDriverFileList,
                                                      chstrPNPDeviceID,
                                                      FALSE);

        // For each device (antecedent) we need to create an association
        // between it and its driver files (presuming we found some).
        if(fFoundDriverFiles)
        {
            hr = CreateAssociations(pMethodContext, vecpchsDriverFileList, chstrDevicePath, dwReqProps);
        }

        // Free pointers in the vector:
        CleanPCHSTRVector(vecpchsDriverFileList); // empty vector out for use next go round
        fFoundDriverFiles = FALSE;  // reset flag for next loop
    }
    else if(IsWinNT5())
    {
        fFoundDriverFiles = GenerateDriverFileListNT5(vecpchsDriverFileList,
                                                      chstrPNPDeviceID,
                                                      vecpNT5DDM,
                                                      FALSE);

        // For each device (antecedent) we need to create an association
        // between it and its driver files (presuming we found some).
        if(fFoundDriverFiles)
        {
            hr = CreateAssociations(pMethodContext, vecpchsDriverFileList, chstrDevicePath, dwReqProps);
        }

        // Free pointers in the vector:
        CleanPCHSTRVector(vecpchsDriverFileList); // empty vector out for use next go round
        fFoundDriverFiles = FALSE;  // reset flag for next loop
    }
#endif
#ifdef NTONLY
    CleanPNT5DevDrvMapVector(vecpNT5DDM);
#endif
    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::CreateAssociations
 *
 *  DESCRIPTION : Creates a list of drivers used by a particular device
 *
 *  INPUTS      : pMethodContext;
 *                vecpchsDriverFileList, a list of files to try to associate
 *                   to the device;
 *                chstrDevicePath, the __PATH of the device
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CCIMDeviceCIMDF::CreateAssociations(MethodContext* pMethodContext,
                               std::vector<CHString*>& vecpchsDriverFileList,
                               CHString& chstrDevicePath,
                               DWORD dwReqProps)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    for(LONG m = 0L; (m < vecpchsDriverFileList.size()) && (SUCCEEDED(hr)); m++)
    {
        // create the __PATH of the file instance:
        // Since the file pathname will be part of the wbem __PATH property,
        // it must contain double backslashes rather than single ones.
        // Hence the call to the following function.
        CHString chstrTweekedPathName;
        WBEMizePathName(*vecpchsDriverFileList[m],chstrTweekedPathName);
        CHString chstrDriverPath;
        chstrDriverPath = _T("\\\\") + GetLocalComputerName() + _T("\\") +
                          IDS_CimWin32Namespace + _T(":") + IDS_CIMDataFile +
                          _T(".") + IDS_Name + _T("=\"") +
                          chstrTweekedPathName + _T("\"");

        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        if(pInstance != NULL)
        {
            // Need to find an instance of the file
            pInstance->SetCHString(IDS_Antecedent, chstrDevicePath);
            pInstance->SetCHString(IDS_Dependent, chstrDriverPath);
            pInstance->SetWBEMINT16(IDS_Purpose, Driver);
			if(dwReqProps & PNP_PROP_PurposeDescription)
            {
                SetPurposeDescription(pInstance, *vecpchsDriverFileList[m]);
            }
            hr = pInstance->Commit();
        }
    }

    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::GenerateDriverFileList
 *
 *  DESCRIPTION : Creates a list of drivers used by a particular device
 *
 *  INPUTS      : vecpchsDriverFileList, an stl array of CHString pointers
 *                (or, in the NT5 case, a pointer to such an array);
 *                chstrPNPDeviceID, a CHString containing the PNPDeviceID
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : void
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
BOOL CCIMDeviceCIMDF::GenerateDriverFileListNT4(
                             std::vector<CHString*>& vecpchsDriverFileList,
                             CHString& chstrPNPDeviceID,
                             BOOL fGetAssociatedDevicesDrivers)
{
    CConfigManager	cfgManager;
//    CDeviceCollection	deviceList;
    CConfigMgrDevicePtr pDevice(NULL);

    // Find the device
    if(cfgManager.LocateDevice(chstrPNPDeviceID, pDevice))
    {
        // The first order of business is to get the driver files associated
        // with this device.  Later we'll add to the list by getting driver
        // files its children use (presuming they are not already in the list).

        // In NT4, the registry key HKLM\\System\\CurrentControlSet\\Enum
        // contains subkeys that are the PNPDeviceID's returned from the query
        // (passed into this function as chstrPNPDeviceID).

        // Those subkeys have an entry "Service", the value of which is the name
        // of a subkey under HKLM\\System\\CurrentControlSet\\Services.  That
        // subkey may have an entry called ImagePath, which contains the name
        // of the driver file in the <SystemRoot>\\System32\\Drivers subdirectory.
        // If ImagePath is missing, the name of the subkey itself matches the
        // filename (minus any path and extension) of the driver file (which will
        // have a .sys extension and be in the <SystemRoot>\\System32\\Drivers
        // subdirectory).

        CRegistry reg;
        CHString chstrSubKey = IDS_NT_CurCtlSetEnum + chstrPNPDeviceID;
        if(reg.Open(HKEY_LOCAL_MACHINE,chstrSubKey,KEY_READ) == ERROR_SUCCESS)
        {
            CHString chstrServiceValue;
            // Get the "Service" entry's value:
            if(reg.GetCurrentKeyValue(IDS_Service, chstrServiceValue) == ERROR_SUCCESS)
            {
                reg.Close();
                chstrSubKey = IDS_NT_CurCtlSetSvcs + chstrServiceValue;
                if(reg.Open(HKEY_LOCAL_MACHINE,chstrSubKey,KEY_READ) == ERROR_SUCCESS)
                {
                    CHString chstrImagePathValue;
                    TCHAR tstrSystemDir[_MAX_PATH+1];
                    ZeroMemory(tstrSystemDir,sizeof(tstrSystemDir));
                    GetSystemDirectory(tstrSystemDir,_MAX_PATH);
                    CHString chstrPathName = tstrSystemDir;
                    // Now need to check for an ImagePath entry:
                    if(reg.GetCurrentKeyValue(IDS_ImagePath, chstrImagePathValue) == ERROR_SUCCESS)
                    {
                        if(chstrImagePathValue.GetLength() > 0)
                        {
                            // This value contains some of the path, plus the driver
                            // filename and extension.  We only want the latter two
                            // components.
                            int lLastBackSlash = -1;
                            lLastBackSlash = chstrImagePathValue.ReverseFind(_T('\\'));
                            if(lLastBackSlash != -1)
                            {
                                chstrImagePathValue = chstrImagePathValue.Right(
                                                       chstrImagePathValue.GetLength()
                                                       - lLastBackSlash - 1);
                            }
                        }
                    }
                    else // In this case, the key itself is the name of the driver
                    {    // Assume a .sys extension.
                        chstrImagePathValue = chstrServiceValue + IDS_Extension_sys;
                    }
                    // Now build the full pathname:
                    chstrPathName = chstrPathName + _T("\\") + IDS_DriversSubdir
                                      + _T("\\") + chstrImagePathValue;

                    // Now that we finally have a driver file, need to add it to
                    // the list of driver files we are building.  However, don't
                    // add it if it is already in the list:
                    if(!AlreadyAddedToList(vecpchsDriverFileList, chstrPathName))
                    {
                        CHString* pchstrTemp = NULL;
                        pchstrTemp = (CHString*) new CHString();
                        if(pchstrTemp != NULL)
                        {
                            try
                            {
                                *pchstrTemp = chstrPathName;
                                vecpchsDriverFileList.push_back(pchstrTemp);
                            }
                            catch ( ... )
                            {
                                delete pchstrTemp;
                                throw ;
                            }
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }

                        // Note: the pointer allocated here gets freed up in
                        // the call to CleanPCHSTRVector made by the function
                        // that called this one.
                    }
                }
            }
        }
    }


    if(fGetAssociatedDevicesDrivers && pDevice != NULL)
    {
        // OkelyDokeleyDoodeley! We did that one just fine, now the second order of
        // business is to do all the kids! And their kids! And so on!
        CConfigMgrDevicePtr pDeviceChild(NULL);

        if(pDevice->GetChild(pDeviceChild))
        {
            // Do this child first:
            // Need its PNPDeviceID (known to CnfgMgr as its DeviceID)
            CHString chstrChildPNPDeviceID;
            if(pDeviceChild->GetDeviceID(chstrChildPNPDeviceID))
            {
                GenerateDriverFileListNT4(vecpchsDriverFileList,
                                          chstrChildPNPDeviceID,
                                          fGetAssociatedDevicesDrivers);

                // Now call its brothers and sisters until none left (GetSibling
                // call will return FALSE):
                CConfigMgrDevicePtr pDeviceSibling(NULL);
                if(pDeviceChild->GetSibling(pDeviceSibling))
                {
                    CConfigMgrDevicePtr pDeviceSiblingNext(NULL);
                    CHString chstrSiblingPNPDeviceID;
                    BOOL fContinue = TRUE;
                    while(fContinue)
                    {
                        // Do the sibling now:
                        // Need its PNPDeviceID (known to CnfgMgr as its DeviceID)
                        if(pDeviceSibling->GetDeviceID(chstrSiblingPNPDeviceID))
                        {
                            GenerateDriverFileListNT4(vecpchsDriverFileList,
                                                      chstrSiblingPNPDeviceID,
                                                      fGetAssociatedDevicesDrivers);
                        }
                        fContinue = pDeviceSibling->GetSibling(pDeviceSiblingNext);

                        // Reassign pointers
                        pDeviceSibling.Attach(pDeviceSiblingNext);
                    }
                }
            }
        }
    }

    return( (vecpchsDriverFileList.size() > 0) ? TRUE : FALSE );
}
#endif




#ifdef NTONLY
BOOL CCIMDeviceCIMDF::GenerateDriverFileListNT5(
                             std::vector<CHString*>& vecpchsDriverFileList,
                             CHString& chstrPNPDeviceID,
                             std::vector<CNT5DevDrvMap*>& vecpNT5DDM,
                             BOOL fGetAssociatedDevicesDrivers)
{
    // Due to the marvelous fact that we have a table of devices
    // and their associated drivers already (if this is running
    // on NT5) courtesy of the function GenerateNT5DeviceDriverMappings,
    // run upon this class's construction, the work here is minimal.

    // We just need to get the drivers for the given PNPDeviceID and
    // return them in a vector.

    CConfigManager	cfgManager;
//    CDeviceCollection	deviceList;
    CConfigMgrDevicePtr pDevice(NULL);

    // Find the device
    if(cfgManager.LocateDevice(chstrPNPDeviceID, pDevice))
    {
        // Go through the table looking for the PNPDeviceID:
        for(LONG k = 0L; k < vecpNT5DDM.size(); k++)
        {
            if((vecpNT5DDM[k]->m_chstrDevicePNPID).CompareNoCase(chstrPNPDeviceID) == 0)
            {
                // Add each of the device's driver files to the outgoing vector
                for(LONG m = 0L; m < (vecpNT5DDM[k]->m_vecpchstrDrivers).size(); m++)
                {
                    if(!AlreadyAddedToList(vecpchsDriverFileList,
                                           *(vecpNT5DDM[k]->m_vecpchstrDrivers[m])))
                    {
                        CHString* pchstrTemp = NULL;
                        pchstrTemp = (CHString*) new CHString();
                        if(pchstrTemp != NULL)
                        {
                            try
                            {
                                *pchstrTemp = *(vecpNT5DDM[k]->m_vecpchstrDrivers[m]);
                                vecpchsDriverFileList.push_back(pchstrTemp);
                            }
                            catch ( ... )
                            {
                                delete pchstrTemp;
                                throw ;
                            }
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                    }
                }
                break; // each device is in the table only once, so no need to continue
            }
        }
    }

    if(fGetAssociatedDevicesDrivers && pDevice != NULL)
    {
        // OkelyDokeleyDoodeley! We did that one just fine, now the second order of
        // business is to do all the kids! And their kids! And so on!
        CConfigMgrDevicePtr pDeviceChild(NULL);

        if(pDevice->GetChild(pDeviceChild))
        {
            // Do this child first:
            // Need its PNPDeviceID (known to CnfgMgr as its DeviceID)
            CHString chstrChildPNPDeviceID;
            if(pDeviceChild->GetDeviceID(chstrChildPNPDeviceID))
            {
                GenerateDriverFileListNT5(vecpchsDriverFileList,
                                          chstrChildPNPDeviceID,
                                          vecpNT5DDM,
                                          fGetAssociatedDevicesDrivers);

                // Now call its brothers and sisters until none left (GetSibling
                // call will return FALSE):
                CConfigMgrDevicePtr pDeviceSibling(NULL);
                if(pDeviceChild->GetSibling(pDeviceSibling))
                {
                    CConfigMgrDevicePtr pDeviceSiblingNext(NULL);
                    CHString chstrSiblingPNPDeviceID;
                    BOOL fContinue = TRUE;
                    while(fContinue)
                    {
                        // Do the sibling now:
                        // Need its PNPDeviceID (known to CnfgMgr as its DeviceID)
                        if(pDeviceSibling->GetDeviceID(chstrSiblingPNPDeviceID))
                        {
                            GenerateDriverFileListNT5(vecpchsDriverFileList,
                                                      chstrSiblingPNPDeviceID,
                                                      vecpNT5DDM,
                                                      fGetAssociatedDevicesDrivers);
                        }

                        fContinue = pDeviceSibling->GetSibling(pDeviceSiblingNext);

                        pDeviceSibling.Attach(pDeviceSiblingNext);
                    }
                }
            }
        }
    }

    return( (vecpchsDriverFileList.size() > 0) ? TRUE : FALSE );
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::GenerateNT5DeviceDriverMappings
 *
 *  DESCRIPTION : Runs through the nt5 registry keys under
 *                HKLM\\SYSTEM\\CurrentControlSet\\Services and assembles
 *                a table of devices and their associated drivers.
 *
 *  INPUTS      : CHString vector (the list), CHString to see if in list
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
VOID CCIMDeviceCIMDF::GenerateNT5DeviceDriverMappings(std::vector<CNT5DevDrvMap*>& vecpNT5DDM)
{
    // The information concerning devices and their associated drivers on NT5
    // can be found under the registry key
    // HKLM\\SYSTEM\\CurrentControlSet\\Services.  Subkeys under this key
    // include such items as Serial.  The data for the value ImagePath (in this
    // case, System32\\Drivers\\serial.sys) contains the location of the driver
    // for a device.  Which devices that is the driver for are found in the
    // Enum subkey under the aformentioned subkey (Serial in this case).  The
    // Enum subkey contains the value Count, the data for which is the number
    // of values (with a numeric based naming scheme starting at zero) also
    // found under this subkey that contain the PNPDeviceIDs of devices
    // associated with this driver.  For instance, the Enum key under Serial
    // might contain the Count value containing the data 2.  This means that
    // there are also values under this subkey called 0 and 1.  The value for
    // the data of 0 is, for example, Root\\*PNP0501\\PnPBIOS_0; the value for
    // the data of 1 is, for example, Root\\*PNP0501\\PnPBIOS_1.

    // Open up the key HKLM\\SYSTEM\\CurrentControlSet\\Services
    CRegistry reg;
    if(reg.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
                                IDS_NT_CurCtlSetSvcs,
                                KEY_READ) == ERROR_SUCCESS)
    {
        for(;;)
        {
            CHString chstrSubKey;
            // Get the name of a subkey (a device, such as Serial)
            if(reg.GetCurrentSubKeyName(chstrSubKey) != ERROR_NO_MORE_ITEMS)
            {
                CRegistry regDevice;
                // Construct a new key name to open
                CHString chstrDeviceKey = IDS_NT_CurCtlSetSvcs + chstrSubKey;
                // Open the key
                if(regDevice.Open(HKEY_LOCAL_MACHINE, chstrDeviceKey, KEY_READ)
                                       == ERROR_SUCCESS)
                {
                    // Get the name of the driver file, in ImagePath
                    CHString chstrImagePathValue;
                    TCHAR tstrSystemDir[_MAX_PATH+1];
                    ZeroMemory(tstrSystemDir,sizeof(tstrSystemDir));
                    GetSystemDirectory(tstrSystemDir,_MAX_PATH);
                    CHString chstrDriverPathName = tstrSystemDir;
                    // Now need to check for an ImagePath entry:
                    if(regDevice.GetCurrentKeyValue(IDS_ImagePath, chstrImagePathValue)
                                       == ERROR_SUCCESS)
                    {
                        if(chstrImagePathValue.GetLength() > 0)
                        {
                            // This value contains some of the path, plus the driver
                            // filename and extension.  We only want the latter two
                            // components.
                            int lLastBackSlash = -1;
                            lLastBackSlash = chstrImagePathValue.ReverseFind(_T('\\'));
                            if(lLastBackSlash != -1)
                            {
                                chstrImagePathValue = chstrImagePathValue.Right(
                                                      chstrImagePathValue.GetLength()
                                                      - lLastBackSlash - 1);
                            }

                            // Now build the full pathname:
                            chstrDriverPathName = chstrDriverPathName + _T("\\") +
                                       IDS_DriversSubdir + _T("\\") + chstrImagePathValue;

                            // OK, now we have the driver file ready for later use.
                            // Now we need to see how many devices are listed under
                            // the enum key, which we have to open first.
                            CRegistry regEnum;
                            // Construct a new key name to open
                            CHString chstrEnumKey = chstrDeviceKey + _T("\\") + IDS_Enum;
                            if(regEnum.Open(HKEY_LOCAL_MACHINE, chstrEnumKey, KEY_READ)
                                       == ERROR_SUCCESS)
                            {
                                // Open the Count value:
                                DWORD dwCount;
                                if(regEnum.GetCurrentKeyValue(IDS_Count, dwCount)
                                       == ERROR_SUCCESS)
                                {
                                    // Now we know how many values there are, the
                                    // names of which are, imagine this, "0", "1",
                                    // etc.  For each one of them, we need to get
                                    // its value data, which is a PNPDeviceID of
                                    // a device using the driver whose name is now
                                    // stored in the variable chstrDriverPathName.
                                    CHString chstrPNPDeviceID;
                                    for(LONG n = 0L; n < dwCount; n++)
                                    {
                                        CHString chstrTemp;
                                        chstrTemp.Format(_T("%d"),n);
                                        if(regEnum.GetCurrentKeyValue(chstrTemp,
                                                                      chstrPNPDeviceID)
                                               == ERROR_SUCCESS)
                                        {
                                            // If this device is not already in our
                                            // table of devices, add it.
                                            if(!AlreadyInDeviceTable(chstrPNPDeviceID, vecpNT5DDM))
                                            {
                                                CNT5DevDrvMap* pNT5DDM = NULL;
                                                pNT5DDM = (CNT5DevDrvMap*) new CNT5DevDrvMap;
                                                if(pNT5DDM != NULL)
                                                {
                                                    try
                                                    {
                                                        chstrPNPDeviceID.MakeUpper();
                                                        pNT5DDM->m_chstrDevicePNPID = chstrPNPDeviceID;
                                                        vecpNT5DDM.push_back(pNT5DDM);
                                                    }
                                                    catch ( ... )
                                                    {
                                                        delete pNT5DDM;
                                                        throw ;
                                                    }
                                                }
                                                else
                                                {
                                                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                                }
                                            }
                                            // Now that we know the device is in the
                                            // table, associate this driver with it
                                            // (AddDriver only adds it if the driver
                                            // is not already in the list of drivers.)
                                            AddDriver(chstrPNPDeviceID, chstrDriverPathName, vecpNT5DDM);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                break;
            }
            // Move to the next subkey:
            if(reg.NextSubKey() != ERROR_SUCCESS)
            {
                break;
            }
        }
    }
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::GenerateNT5DeviceDriverMap
 *
 *  DESCRIPTION : This flavor of GenerateNT5DeviceDriverMappings generates a
 *                "table" with only one device in it.
 *
 *  INPUTS      : CHString vector (the list), CHString to see if in list
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
VOID CCIMDeviceCIMDF::GenerateNT5ServiceDriverMap(const CHString& chstrDevSvcName,
                                                  std::vector<CNT5DevDrvMap*>& vecpNT5DDM)
{
    // The information concerning devices and their associated drivers on NT5
    // can be found under the registry key
    // HKLM\\SYSTEM\\CurrentControlSet\\Services.  Subkeys under this key
    // include such items as Serial.  The data for the value ImagePath (in this
    // case, System32\\Drivers\\serial.sys) contains the location of the driver
    // for a device.  Which devices that is the driver for are found in the
    // Enum subkey under the aformentioned subkey (Serial in this case).  The
    // Enum subkey contains the value Count, the data for which is the number
    // of values (with a numeric based naming scheme starting at zero) also
    // found under this subkey that contain the PNPDeviceIDs of devices
    // associated with this driver.  For instance, the Enum key under Serial
    // might contain the Count value containing the data 2.  This means that
    // there are also values under this subkey called 0 and 1.  The value for
    // the data of 0 is, for example, Root\\*PNP0501\\PnPBIOS_0; the value for
    // the data of 1 is, for example, Root\\*PNP0501\\PnPBIOS_1.
    //
    // In this abbreviated version of the function GenerateNT5DeviceDriverMappings,
    // we are given the service name of the device of interest.  The service name
    // is what we were enumerating above (via OpenAndEnumerateSubKeys), so
    // here we can go directly to the correct registry entry and get what we
    // want.

    CRegistry regDevice;
    // Construct a new key name to open
    //CHString chstrDeviceKey = IDS_NT_CurCtlSetSvcs + chstrSubKey;
    CHString chstrDeviceKey = IDS_NT_CurCtlSetSvcs + chstrDevSvcName;
    // Open the key
    if(regDevice.Open(HKEY_LOCAL_MACHINE, chstrDeviceKey, KEY_READ)
                           == ERROR_SUCCESS)
    {
        // Get the name of the driver file, in ImagePath
        CHString chstrImagePathValue;
        TCHAR tstrSystemDir[_MAX_PATH+1];
        ZeroMemory(tstrSystemDir,sizeof(tstrSystemDir));
        GetSystemDirectory(tstrSystemDir,_MAX_PATH);
        CHString chstrDriverPathName = tstrSystemDir;
        // Now need to check for an ImagePath entry:
        if(regDevice.GetCurrentKeyValue(IDS_ImagePath, chstrImagePathValue)
                           == ERROR_SUCCESS)
        {
            if(chstrImagePathValue.GetLength() > 0)
            {
                // This value contains some of the path, plus the driver
                // filename and extension.  We only want the latter two
                // components.
                int lLastBackSlash = -1;
                lLastBackSlash = chstrImagePathValue.ReverseFind(_T('\\'));
                if(lLastBackSlash != -1)
                {
                    chstrImagePathValue = chstrImagePathValue.Right(
                                          chstrImagePathValue.GetLength()
                                          - lLastBackSlash - 1);
                }

                // Now build the full pathname:
                chstrDriverPathName = chstrDriverPathName + _T("\\") +
                           IDS_DriversSubdir + _T("\\") + chstrImagePathValue;
                chstrDriverPathName.MakeUpper();
                // OK, now we have the driver file ready for later use.
                // Now we need to see how many devices are listed under
                // the enum key, which we have to open first.
                CRegistry regEnum;
                // Construct a new key name to open
                CHString chstrEnumKey = chstrDeviceKey + _T("\\") + IDS_Enum;
                if(regEnum.Open(HKEY_LOCAL_MACHINE, chstrEnumKey, KEY_READ)
                           == ERROR_SUCCESS)
                {
                    // Open the Count value:
                    DWORD dwCount;
                    if(regEnum.GetCurrentKeyValue(IDS_Count, dwCount)
                           == ERROR_SUCCESS)
                    {
                        // Now we know how many values there are, the
                        // names of which are, imagine this, "0", "1",
                        // etc.  For each one of them, we need to get
                        // its value data, which is a PNPDeviceID of
                        // a device using the driver whose name is now
                        // stored in the variable chstrDriverPathName.
                        CHString chstrPNPDeviceID;
                        for(LONG n = 0L; n < dwCount; n++)
                        {
                            CHString chstrTemp;
                            chstrTemp.Format(_T("%d"),n);
                            if(regEnum.GetCurrentKeyValue(chstrTemp,
                                                          chstrPNPDeviceID)
                                   == ERROR_SUCCESS)
                            {
                                chstrPNPDeviceID.MakeUpper();
                                // If this device is not already in our
                                // table of devices, add it.
                                if(!AlreadyInDeviceTable(chstrPNPDeviceID, vecpNT5DDM))
                                {
                                    CNT5DevDrvMap* pNT5DDM = NULL;
                                    pNT5DDM = (CNT5DevDrvMap*) new CNT5DevDrvMap;
                                    if(pNT5DDM != NULL)
                                    {
                                        try
                                        {
                                            pNT5DDM->m_chstrDevicePNPID = chstrPNPDeviceID;
                                            vecpNT5DDM.push_back(pNT5DDM);
                                        }
                                        catch ( ... )
                                        {
                                            delete pNT5DDM;
                                            throw ;
                                        }
                                    }
                                    else
                                    {
                                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                    }
                                }
                                // Now that we know the device is in the
                                // table, associate this driver with it
                                // (AddDriver only adds it if the driver
                                // is not already in the list of drivers.)
                                AddDriver(chstrPNPDeviceID, chstrDriverPathName, vecpNT5DDM);
                            }
                        }
                    }
                }
            }
        }
    }
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::CleanPCHSTRVector
 *
 *  DESCRIPTION : deletes each element of a vector of CHString pointers, then
 *                clears the vector.
 *
 *  INPUTS      : CHString vector (the list), CHString to see if in list
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
VOID CCIMDeviceCIMDF::CleanPCHSTRVector(std::vector<CHString*>& vecpchsList)
{
    for(LONG m = 0L; m < vecpchsList.size(); m++)
    {
        delete vecpchsList[m];
    }
    vecpchsList.clear();
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::CleanPNT5DevDrvMapVector
 *
 *  DESCRIPTION : deletes each element of a vector of CNT5DevDrvMap pointers, then
 *                clears the vector.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
VOID CCIMDeviceCIMDF::CleanPNT5DevDrvMapVector(std::vector<CNT5DevDrvMap*>& vecpNT5DDM)
{
    for(LONG m = 0L; m < vecpNT5DDM.size(); m++)
    {
        delete vecpNT5DDM[m];
    }
    vecpNT5DDM.clear();
}
#endif



/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::AlreadyAddedToList
 *
 *  DESCRIPTION : Internal helper to check if item was added to list
 *
 *  INPUTS      : CHString vector (the list), CHString to see if in list
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE or FALSE
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
BOOL CCIMDeviceCIMDF::AlreadyAddedToList(std::vector<CHString*>& vecchsList,
                                   CHString& chsItem)
{
    for(LONG m = 0; m < vecchsList.size(); m++)
    {
        if(vecchsList[m]->CompareNoCase(chsItem) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}


/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::AlreadyInDeviceTable
 *
 *  DESCRIPTION : Internal helper to check if item was added to list
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE or FALSE
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
BOOL CCIMDeviceCIMDF::AlreadyInDeviceTable(CHString& chstrPNPDeviceID,
                                           std::vector<CNT5DevDrvMap*>& vecpNT5DDM)
{
    for(LONG m = 0; m < vecpNT5DDM.size(); m++)
    {
        if((vecpNT5DDM[m]->m_chstrDevicePNPID).CompareNoCase(chstrPNPDeviceID) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::AddDriver
 *
 *  DESCRIPTION : Internal helper to add a driver to the member vector of
 *                devices.
 *
 *  INPUTS      : chstrPNPDeviceID, the device the driver belongs to;
 *                chstrDriverPathName, the driver for the device
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE or FALSE
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
VOID CCIMDeviceCIMDF::AddDriver(CHString& chstrPNPDeviceID, CHString& chstrDriverPathName,
                                std::vector<CNT5DevDrvMap*>& vecpNT5DDM)
{
    for(LONG m = 0; m < vecpNT5DDM.size(); m++)
    {
        if((vecpNT5DDM[m]->m_chstrDevicePNPID).CompareNoCase(chstrPNPDeviceID) == 0)
        {
            // The member CNT5DevDrvMap's function AddDriver only adds the
            // driver to that devices driver list if it is not already there.
            chstrDriverPathName.MakeUpper();
            vecpNT5DDM[m]->AddDriver(chstrDriverPathName);
            break;
        }
    }
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : WBEMizePathName
 *
 *  DESCRIPTION : Internal helper to change all single backslashes to double
 *                backslashes.
 *
 *  INPUTS      : chstrNormalPathname, containing string with single backslashes;
 *
 *  OUTPUTS     : chstrWBEMizedPathname, containing string with double backslashes
 *
 *  RETURNS     : none
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
VOID WBEMizePathName(CHString& chstrNormalPathname,
                     CHString& chstrWBEMizedPathname)
{
    CHString chstrCpyNormPathname = chstrNormalPathname;
    LONG lNext = -1L;

    // Find the next '\'
    lNext = chstrCpyNormPathname.Find(_T('\\'));
    while(lNext != -1)
    {
        // Add on to the new string we are building:
        chstrWBEMizedPathname += chstrCpyNormPathname.Left(lNext + 1);
        // Add on the second backslash:
        chstrWBEMizedPathname += _T('\\');
        // Hack off from the input string the portion we just copied
        chstrCpyNormPathname = chstrCpyNormPathname.Right(chstrCpyNormPathname.GetLength() - lNext - 1);
        lNext = chstrCpyNormPathname.Find(_T('\\'));
    }
    // If the last character wasn't a '\', there may still be leftovers, so
    // copy them here.
    if(chstrCpyNormPathname.GetLength() != 0)
    {
        chstrWBEMizedPathname += chstrCpyNormPathname;
    }
}



/*****************************************************************************
 *
 *  FUNCTION    : ObjNameValid
 *
 *  DESCRIPTION : Internal helper to check if the given object exists.
 *
 *  INPUTS      : chstrObject - name of prospecitive object.
 *
 *  OUTPUTS     : chstrPATH, the path of the provided object
 *
 *  RETURNS     : true if it exists; false otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CCIMDeviceCIMDF::ObjNameValid(LPCWSTR wstrObject, LPCWSTR wstrObjName, LPCWSTR wstrKeyName, CHString& chstrPATH)
{
    bool fRet = false;

    ParsedObjectPath*    pParsedPath = 0;
    CObjectPathParser    objpathParser;

    // Parse the object path passed to us by CIMOM
    // ==========================================
    int nStatus = objpathParser.Parse( bstr_t(wstrObject),  &pParsedPath );

    // One of the biggest if statements I've ever written.
    if (( 0 == nStatus ) &&                                                 // Did the parse succeed?
        (pParsedPath->IsInstance()) &&                                      // Is the parsed object an instance?
        (_wcsicmp(pParsedPath->m_pClass, wstrObjName) == 0) &&              // Is this the class we expect (no, cimom didn't check)
        (pParsedPath->m_dwNumKeys == 1) &&                                  // Does it have exactly one key
        (pParsedPath->m_paKeys[0]) &&                                       // Is the keys pointer null (shouldn't happen)
        ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||                      // Key name not specified or
        (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, wstrKeyName) == 0)) &&  // key name is the right value
                                                                            // (no, cimom doesn't do this for us).
        (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == VT_BSTR) &&           // Check the variant type (no, cimom doesn't check this either)
        (V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue) != NULL) )             // And is there a value in it?
    {
        chstrPATH = V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue);
        fRet = true;
    }

    if (pParsedPath)
        // Clean up the Parsed Path
        objpathParser.Free(pParsedPath);

    return fRet;
}


/*****************************************************************************
 *
 *  FUNCTION    : DeviceExists
 *
 *  DESCRIPTION : Internal helper to check if the given device exists.
 *
 *  INPUTS      : chstrDevice - name of prospecitive device.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : true if it exists; false otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CCIMDeviceCIMDF::DeviceExists(const CHString& chstrDevice,
                                   CConfigMgrDevicePtr & pDevice)
{
    bool fRet = false;
    CConfigManager cfgmgr;

    if(cfgmgr.LocateDevice(chstrDevice, pDevice))
    {
        fRet = true;
    }
    return fRet;
}


/*****************************************************************************
 *
 *  FUNCTION    : SetPurposeDescription
 *
 *  DESCRIPTION : Internal helper to set the PurposeDescription property.
 *
 *  INPUTS      : pInstance - instance pointer.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
VOID CCIMDeviceCIMDF::SetPurposeDescription(CInstance *a_pInstance, const CHString& a_chstrFileName)
{
	if(a_pInstance != NULL)
    {
        CHString chstrVerStrBuf;

        // Get the file description property...
        LPVOID pInfo = NULL;
        try
        {
            if(GetFileInfoBlock(TOBSTRT(a_chstrFileName), &pInfo) && (pInfo != NULL))
            {
                bool t_Status = GetVarFromInfoBlock(pInfo,                    // Name of file to get ver info about
                                                    _T("FileDescription"),	  // String identifying resource of interest
                                                    chstrVerStrBuf);          // Buffer to hold version string
                if(t_Status)
                {
                    a_pInstance->SetCHString(IDS_PurposeDescription, chstrVerStrBuf);
                }
            }
        }
        catch(...)
        {
            if(pInfo != NULL)
            {
                delete pInfo;
                pInfo = NULL;
            }
            throw;
        }
		delete pInfo;
        pInfo = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\cnetconn.cpp ===
//=================================================================

//

// cnetconn.CPP -- Persistent network connection property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions: jennymc 1/19/98  consolidating code
//							   Still needs rework, but better than it was
//
//			  a-peterc 5/25/99 Reworked...
//
//=================================================================
#include "precomp.h"
#include "wbemnetapi32.h"
#include <lmuse.h>
#include "DllWrapperBase.h"
#include "MprApi.h"
#include "cnetconn.h"

#include <assertbreak.h>

#define ENUM_BUFF_SIZE	1024
#define ENUM_ARRAY_SIZE 20

#define IPC_PROVIDER "Microsoft Network"

/*=================================================================
 Function:  CNetConnection(),~CNetConnection()

 Description: contructor and destructor

 Arguments:

 Notes:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  25-May-1999     Created
=================================================================*/
CNetConnection :: CNetConnection ()
{
   	m_MprApi = ( CMprApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidMprApi, NULL ) ;

	// validate connection iterator
	m_ConnectionIter = m_oConnectionList.end() ;
}

//
CNetConnection :: ~CNetConnection ()
{
	CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidMprApi , m_MprApi ) ;

	ClearConnectionList() ;
}


/*=================================================================
 Functions:  BeginConnectionEnum(), GetNextConnection( CConnection **a_pConnection )

 Description: Provides for network connection enumeration.

 Arguments:

 Notes:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  21-May-1999     Created
=================================================================*/
//
void CNetConnection::BeginConnectionEnum()
{
	LoadConnections() ;

	m_ConnectionIter = m_oConnectionList.begin() ;
}

//
BOOL CNetConnection::GetNextConnection( CConnection **a_pConnection )
{
	if ( m_ConnectionIter == m_oConnectionList.end() )
	{
		*a_pConnection = NULL ;
		return FALSE ;
	}
	else
	{
		*a_pConnection = *m_ConnectionIter ;

		++m_ConnectionIter ;
		return TRUE ;
	}
}

/*=================================================================
 Functions:  GetConnection( CHString &a_rstrFind, CConnection &a_rConnection )

 Description: Provides single extraction of a network connection.

 Arguments:

 Notes:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  21-May-1999     Created
=================================================================*/
//
BOOL CNetConnection ::GetConnection( CHString &a_rstrFind, CConnection &a_rConnection )
{
	BOOL		t_fFound		= FALSE ;
	HANDLE		t_hEnumHandle	= NULL ;
	DWORD		t_dwEntryCount	= 1 ;
	DWORD		t_dwBufferSize  = 0 ;

	BYTE		t_bTempBuffer[ ENUM_BUFF_SIZE ] ;
	DWORD		t_dwRetCode ;

	LPNETRESOURCE t_pNetResource = reinterpret_cast<LPNETRESOURCE>( &t_bTempBuffer ) ;

	//
	if( !m_MprApi )
	{
		return FALSE ;
	}

	try
	{
		// scan the "remembered" resources first

		// Enum open
		t_dwRetCode = m_MprApi->WNetOpenEnum(RESOURCE_REMEMBERED, RESOURCETYPE_ANY, 0, NULL, &t_hEnumHandle ) ;

		if( NO_ERROR == t_dwRetCode )
		{
			while( true )
			{
				t_dwEntryCount = 1 ;
				t_dwBufferSize = ENUM_BUFF_SIZE ;

				memset( &t_bTempBuffer, 0, ENUM_BUFF_SIZE ) ;

				if( NO_ERROR == m_MprApi->WNetEnumResource( t_hEnumHandle,
															&t_dwEntryCount,
															&t_bTempBuffer,
															&t_dwBufferSize ) &&

															1 == t_dwEntryCount )
				{
					// build a key name
					CHString t_chsTempKeyName ;
					CreateNameKey( t_pNetResource, t_chsTempKeyName ) ;

					// hit test
					if( 0 == t_chsTempKeyName.CompareNoCase( a_rstrFind ) )
					{
						if( FillInConnection(	t_pNetResource,
												&a_rConnection,
												CConnection::e_Remembered  ) )
						{
							t_fFound = TRUE ;

							break ;
						}
					}
				}
				else
				{
					break;
				}
			}
		}
	}
	catch( ... )
	{
		if( t_hEnumHandle )
		{
			m_MprApi->WNetCloseEnum( t_hEnumHandle ) ;
		}

		throw ;
	}

	if( t_hEnumHandle )
	{
		m_MprApi->WNetCloseEnum( t_hEnumHandle ) ;
		t_hEnumHandle = NULL ;
	}

	try
	{
		// else scan the "currently connected" connections
		if( !t_fFound )
		{
			// Enum open
			t_dwRetCode = m_MprApi->WNetOpenEnum( RESOURCE_CONNECTED, RESOURCETYPE_ANY, 0, NULL, &t_hEnumHandle ) ;

			if( NO_ERROR == t_dwRetCode )
			{
				while( true )
				{
					t_dwEntryCount = 1 ;
					t_dwBufferSize = ENUM_BUFF_SIZE ;

					memset( &t_bTempBuffer, 0, ENUM_BUFF_SIZE ) ;

					if( NO_ERROR == m_MprApi->WNetEnumResource( t_hEnumHandle,
																&t_dwEntryCount,
																&t_bTempBuffer,
																&t_dwBufferSize ) &&

																1 == t_dwEntryCount )
					{
						// build a key name
						CHString t_chsTempKeyName ;
						CreateNameKey( t_pNetResource, t_chsTempKeyName ) ;

						// hit test
						if( 0 == t_chsTempKeyName.CompareNoCase( a_rstrFind ) )
						{
							if( FillInConnection(	t_pNetResource,
													&a_rConnection,
													CConnection::e_Connected ) )
							{
								t_fFound = TRUE ;

								break ;
							}
						}
					}
					else
					{
						break;
					}
				}
			}
		}
	}
	catch( ... )
	{
		if( t_hEnumHandle )
		{
			m_MprApi->WNetCloseEnum( t_hEnumHandle ) ;
		}

		throw ;
	}

	if( t_hEnumHandle )
	{
		m_MprApi->WNetCloseEnum( t_hEnumHandle ) ;
		t_hEnumHandle = NULL ;
	}

	return t_fFound ;
}

/*=================================================================
 Functions:  LoadConnections()

 Description: Buffers all connections for use in enumeration

 Arguments:

 Notes:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  21-May-1999     Created
=================================================================*/
//
BOOL CNetConnection :: LoadConnections()
{
	HANDLE		t_hEnumHandle	= NULL ;
	DWORD		t_dwEntryCount	= 1 ;
	DWORD		t_dwBufferSize  = 0 ;
	DWORD		t_dwRetCode ;

	BYTE		t_bTempBuffer[ ENUM_BUFF_SIZE ] ;

	LPNETRESOURCE t_pNetResource = reinterpret_cast<LPNETRESOURCE>( &t_bTempBuffer ) ;

	//
	ClearConnectionList() ;

	if( !m_MprApi )
	{
		return FALSE ;
	}

	try
	{
		// scan the "remembered" resources first

		// Enum open
		t_dwRetCode = m_MprApi->WNetOpenEnum( RESOURCE_REMEMBERED, RESOURCETYPE_ANY, 0, NULL, &t_hEnumHandle ) ;

		if( NO_ERROR == t_dwRetCode )
		{
			while( true )
			{
				t_dwEntryCount = 1 ;
				t_dwBufferSize = ENUM_BUFF_SIZE ;

				memset( &t_bTempBuffer, 0, ENUM_BUFF_SIZE ) ;

				if( NO_ERROR == m_MprApi->WNetEnumResource( t_hEnumHandle,
															&t_dwEntryCount,
															&t_bTempBuffer,
															&t_dwBufferSize ) &&

															1 == t_dwEntryCount )
				{
					AddConnectionToList( t_pNetResource, CConnection::e_Remembered, 0 ) ;
				}
				else
				{
					break;
				}
			}
		}
	}
	catch( ... )
	{
		if( t_hEnumHandle )
		{
			m_MprApi->WNetCloseEnum( t_hEnumHandle ) ;
		}

		ClearConnectionList() ;

		throw ;
	}

	if( t_hEnumHandle )
	{
		m_MprApi->WNetCloseEnum( t_hEnumHandle ) ;
		t_hEnumHandle = NULL ;
	}

	try
	{
		// Add to the list "currently connected" resources

		// Enum open
		t_dwRetCode = m_MprApi->WNetOpenEnum(RESOURCE_CONNECTED, RESOURCETYPE_ANY, 0, NULL, &t_hEnumHandle ) ;

		if( NO_ERROR == t_dwRetCode )
		{
			while( true )
			{
				t_dwEntryCount = 1 ;
				t_dwBufferSize = ENUM_BUFF_SIZE ;

				memset( &t_bTempBuffer, 0, ENUM_BUFF_SIZE ) ;

				if( NO_ERROR == m_MprApi->WNetEnumResource( t_hEnumHandle,
															&t_dwEntryCount,
															&t_bTempBuffer,
															&t_dwBufferSize ) &&

															1 == t_dwEntryCount )
				{
					// build a key name
					CHString t_chsTempKeyName ;
					CreateNameKey( t_pNetResource, t_chsTempKeyName ) ;

					BOOL t_fInserted = FALSE ;

					// add to the list only if it's not "remembered"
					for( m_ConnectionIter  = m_oConnectionList.begin();
						 m_ConnectionIter != m_oConnectionList.end();
						 m_ConnectionIter++ )
					{
						// test for duplicate
						if(0 == t_chsTempKeyName.CompareNoCase( (*m_ConnectionIter)->strKeyName ) )
						{
							t_fInserted = TRUE ;
							break ;
						}
					}

					// new entry
					if( !t_fInserted )
					{
						AddConnectionToList( t_pNetResource, CConnection::e_Connected, 0 ) ;
					}
				}
				else
				{
					break;
				}
			}
		}

	}
	catch( ... )
	{
		if( t_hEnumHandle )
		{
			m_MprApi->WNetCloseEnum( t_hEnumHandle ) ;
		}

		ClearConnectionList() ;

		throw ;
	}

	if( t_hEnumHandle )
	{
		m_MprApi->WNetCloseEnum( t_hEnumHandle ) ;
		t_hEnumHandle = NULL ;
	}

	return !m_oConnectionList.empty() ;
}

/*=================================================================
 Utility function:  ClearConnectionList()


 History:					a-peterc  21-May-1999     Created
=================================================================*/

//
void CNetConnection ::ClearConnectionList()
{
	while( !m_oConnectionList.empty() )
	{
		delete m_oConnectionList.front() ;

		m_oConnectionList.pop_front() ;
	}
}


/*=================================================================
 Utility function:  CreateNameKey (

						LPNETRESOURCE a_pNetResource,
						CHString &a_strName
					)


 History:					a-peterc  21-May-1999     Created
=================================================================*/
void CNetConnection :: CreateNameKey (

	LPNETRESOURCE a_pNetResource,
	CHString &a_strName
)
{
	if ( a_pNetResource )
	{
		if( a_pNetResource->lpRemoteName )
		{
			a_strName = a_pNetResource->lpRemoteName ;
		}
		else
		{
			a_strName = _T("") ;	// bad key
		}

	    if( ( a_pNetResource->lpLocalName != NULL ) && ( a_pNetResource->lpLocalName[0] ) )
		{
	        a_strName += _T(" (") ;
	        a_strName += a_pNetResource->lpLocalName ;
	        a_strName += _T(")") ;
	    }
	}
}

/*=================================================================
 Utility function:  AddConnectionToList(

						NETRESOURCE *a_pNetResource,
						CConnection::eConnectionScope a_eScope
						)


 History:					a-peterc  21-May-1999     Created
=================================================================*/
//
BOOL CNetConnection :: AddConnectionToList(

NETRESOURCE *a_pNetResource,
CConnection::eConnectionScope a_eScope,
short shStatus
)
{
	BOOL t_fReturn = FALSE ;

	CConnection *t_pConnection = NULL ;
	t_pConnection = new CConnection ;
	
	try
	{
		if( FillInConnection( a_pNetResource, t_pConnection, a_eScope ) )
		{
            if (a_eScope == CConnection::e_IPC)
            {
                t_pConnection->dwStatus = shStatus;
            }

			// and add to the list
			m_oConnectionList.push_back( t_pConnection ) ;

			t_fReturn = TRUE ;
		}
		else
		{
			delete t_pConnection ;
			t_pConnection = NULL ;
		}
	}
	catch(...)
	{
		delete t_pConnection ;
		t_pConnection = NULL ;
		throw;
	}

	return t_fReturn ;
}

/*=================================================================
 Utility function:  FillInConnection(

						NETRESOURCE *a_pNetResource,
						CConnection *a_pConnection,
						CConnection::eConnectionScope a_eScope
						)


 History:					a-peterc  21-May-1999     Created
=================================================================*/
BOOL CNetConnection :: FillInConnection(

NETRESOURCE *a_pNetResource,
CConnection *a_pConnection,
CConnection::eConnectionScope a_eScope
)
{
	if( !a_pNetResource || !a_pConnection )
	{
		return FALSE ;
	}

	a_pConnection->dwScope			= a_pNetResource->dwScope ;
    a_pConnection->dwType			= a_pNetResource->dwType ;
    a_pConnection->dwDisplayType	= a_pNetResource->dwDisplayType ;
    a_pConnection->dwUsage			= a_pNetResource->dwUsage;
    a_pConnection->chsLocalName		= a_pNetResource->lpLocalName ;
    a_pConnection->chsRemoteName	= a_pNetResource->lpRemoteName ;
    a_pConnection->chsComment		= a_pNetResource->lpComment ;
    a_pConnection->chsProvider		= a_pNetResource->lpProvider ;

	// build a key name
	CreateNameKey( a_pNetResource, a_pConnection->strKeyName ) ;

	// note the connection scope
	a_pConnection->eScope = a_eScope ;

	// connection status
	a_pConnection->dwStatus = GetStatus( a_pNetResource ) ;

	GetUser( a_pNetResource, a_pConnection ) ;

	return TRUE ;
}

/*=================================================================
 Utility function:  GetStatus( LPNETRESOURCE a_pNetResource )


 History:					a-peterc  21-May-1999     Created
=================================================================*/
//
DWORD CNetConnection :: GetStatus( LPNETRESOURCE a_pNetResource )
{
   // Find the status of the network connection.
    DWORD dwStatus = USE_NETERR ;

    // We must have either the local name or the remote name.
    if ( a_pNetResource->lpLocalName || a_pNetResource->lpRemoteName )
    {
#ifdef NTONLY
        {
            _bstr_t     bstrUseName( a_pNetResource->lpLocalName ?
									a_pNetResource->lpLocalName :
									a_pNetResource->lpRemoteName ) ;

			CNetAPI32   t_NetAPI;
			USE_INFO_1  *pInfo;

			try
			{
				if( t_NetAPI.Init() == ERROR_SUCCESS )
				{
					if ((dwStatus = t_NetAPI.NetUseGetInfo(NULL, bstrUseName, 1, (LPBYTE *) &pInfo)) == NERR_Success )
					{
						dwStatus = pInfo->ui1_status;
						t_NetAPI.NetApiBufferFree( pInfo );
						pInfo = NULL;
					}
				}
			}
			catch( ... )
			{
				if( pInfo )
				{
					t_NetAPI.NetApiBufferFree(pInfo);
				}
			}
        }
#endif
    }

	return dwStatus ;
}

/*=================================================================
 Utility function:  GetUser( LPNETRESOURCE a_pNetResource, CConnection *a_pConnection )


 History:					a-peterc  21-May-1999     Created
=================================================================*/
//
void CNetConnection :: GetUser( LPNETRESOURCE a_pNetResource, CConnection *a_pConnection )
{
	DWORD t_dwBufferSize = _MAX_PATH ;
    TCHAR t_szTemp[_MAX_PATH + 2] ;

    LPCTSTR t_pName = a_pNetResource->lpLocalName ;

	if( !t_pName )
	{
		t_pName = a_pNetResource->lpRemoteName ;
	}

	// Protect the LSA call with a mutex.  Not our bug, but we have to protect ourselves.
    {
		if( NO_ERROR == m_MprApi->WNetGetUser( t_pName, (LPTSTR)t_szTemp, &t_dwBufferSize ) )
		{
			a_pConnection->strUserName = t_szTemp ;
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\cimdatafile.cpp ===
//=================================================================
//
// CIMDataFile.CPP -- CIMDataFile property set provider
//
//  Copyright (c) 1996-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/16/98    a-kevhu         Created
//
//=================================================================

#include "precomp.h"
#include "File.h"
#include "Implement_LogicalFile.h"
#include "CIMDataFile.h"

// Property set declaration
//=========================

CCIMDataFile MyCIMDataFileSet(PROPSET_NAME_CIMDATAFILE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDataFile::CCIMDataFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CCIMDataFile :: CCIMDataFile (

	const CHString &setName,
	LPCWSTR pszNamespace

) : CImplement_LogicalFile ( setName , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDataFile::~CCIMDataFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CCIMDataFile :: ~CCIMDataFile ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDataFile::IsOneOfMe
 *
 *  DESCRIPTION : The guts of this class, actually.  IsOneOfMe is inherrited
 *                from CIM_LogicalFile.  That class returns files or
 *                directories where this one should only return directories,
 *                in response to queries, getobject commands, etc.  It is
 *                overridden here to return TRUE only if the file (the
 *                information for which is contained in the function arguement
 *                pstFindData) is of type directory.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE or FALSE
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/

#ifdef NTONLY
BOOL CCIMDataFile :: IsOneOfMe (

	LPWIN32_FIND_DATAW pstFindData,
    const WCHAR *wstrFullPathName
)
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.

    if ( pstFindData == NULL )
    {
        return FALSE ;
    }
    else
    {
        return ( ( pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? FALSE : TRUE ) ;
    }
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDataFile::GetExtendedProperties
 *
 *  DESCRIPTION : Sets properties unique to this provider (not common to all
 *                CIM_LogicalFile derived classes).
 *
 *  INPUTS      : CInstance pointer and flags
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/

 void CCIMDataFile :: GetExtendedProperties(CInstance *pInstance,
                                            long lFlags)
{
    // First, get the name of the file (we should have it by now):

    CHString chstrFileName;
    if(pInstance->GetCHString(IDS_Name, chstrFileName))
    {
        CHString chstrVerStrBuf ;

        // First get the version number string, if required...
        if(lFlags & PROP_VERSION || lFlags & PROP_MANUFACTURER)
        {
            LPVOID pInfo = NULL;
            try
            {
                if(GetFileInfoBlock(TOBSTRT(chstrFileName), &pInfo) && (pInfo != NULL))
                {
                    if(lFlags & PROP_VERSION)
                    {
			            bool t_Status = GetVarFromInfoBlock(pInfo,                   // Name of file to get ver info about
                                                            _T("FileVersion"),       // String identifying resource of interest
                                                            chstrVerStrBuf);         // Buffer to hold version string


                        if(t_Status)
                        {
                            pInstance->SetCHString(IDS_Version, chstrVerStrBuf);
                        }
                    }

                    // Second, get the company name string, if required...

                    if(lFlags & PROP_MANUFACTURER)
                    {
                        bool t_Status = GetVarFromInfoBlock(pInfo,                   // Name of file to get ver info about
                                                            _T("CompanyName"),       // String identifying resource of interest
                                                            chstrVerStrBuf);         // Buffer to hold company name string


                        if(t_Status)
                        {
                            pInstance->SetCHString(IDS_Manufacturer, chstrVerStrBuf);
                        }
                    }
                }
            }
            catch(...)
            {
                if(pInfo != NULL)
                {
                    delete pInfo;
                    pInfo = NULL;
                }
                throw;
            }

            delete pInfo;
            pInfo = NULL;
        }

        // Set the FileSize property, if required...
        if(lFlags & PROP_FILESIZE)
        {
            WIN32_FIND_DATA stFindData;
            ZeroMemory(&stFindData, sizeof(stFindData));

            SmartFindClose hFind = FindFirstFile(TOBSTRT(chstrFileName), &stFindData);
            if (hFind != INVALID_HANDLE_VALUE)
            {
				__int64 LoDW = (__int64)(stFindData.nFileSizeLow);
				__int64 HiDW = (__int64)(stFindData.nFileSizeHigh);
				__int64 FileSize = (HiDW << 32) + LoDW;

				WCHAR strSize [ 40 ] ;
				_i64tow ( FileSize, strSize, 10 ) ;
				pInstance->SetWBEMINT64 ( IDS_Filesize, strSize ) ;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\cimlogicaldevice_cimdatafile.h ===
//=================================================================

//

// CIMLogicalDevice_CIMDataFile.h -- cim_logicaldevice to CIM_DataFile

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/20/98    a-kevhu         Created
//
// Comment: Relationship between logical device and datafile
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_DEVICEDATAFILE L"Win32_CIMLogicalDeviceCIMDataFile"

class CCIMDeviceCIMDF;
class CNT5DevDrvMap;
class CSubDirList;
VOID OutputDebugInfo(CHString chstr);
VOID WBEMizePathName(CHString& chstrNormalPathname,
                     CHString& chstrWBEMizedPathname);


class CCIMDeviceCIMDF : virtual public CWin32PNPEntity {

    public:

        // Constructor/destructor
        //=======================

        CCIMDeviceCIMDF(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CCIMDeviceCIMDF() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long Flags = 0L);

    protected:
        // Functions inherrited from CWin32PNPDevice:
        virtual HRESULT LoadPropertyValues(void* pv);
        virtual bool ShouldBaseCommit(void* pvData);

    private:
        VOID SetPurposeDescription(CInstance *pInstance, const CHString& a_chstrFileName);

#ifdef NTONLY
        BOOL GenerateDriverFileListNT4(std::vector<CHString*>& vecpchsDriverFileList, 
                                       CHString& chstrPNPDeviceID,
                                       BOOL fGetAssociatedDevicesDrivers);

        BOOL GenerateDriverFileListNT5(std::vector<CHString*>& vecpchsDriverFileList, 
                                       CHString& chstrPNPDeviceID,
                                       std::vector<CNT5DevDrvMap*>& vecpNT5DDM,
                                       BOOL fGetAssociatedDevicesDrivers);

        VOID GenerateNT5DeviceDriverMappings(std::vector<CNT5DevDrvMap*>& vecpNT5DDM);

        VOID GenerateNT5ServiceDriverMap(const CHString& chstrDevSvcName,
                                         std::vector<CNT5DevDrvMap*>& vecpNT5DDM);

        VOID CleanPNT5DevDrvMapVector(std::vector<CNT5DevDrvMap*>& vecpNT5DDM);

        BOOL AlreadyInDeviceTable(CHString& chstrPNPDeviceID,
                                  std::vector<CNT5DevDrvMap*>& vecpNT5DDM);

        VOID AddDriver(CHString& chstrPNPDeviceID, 
                       CHString& chstrDriverPathName,
                       std::vector<CNT5DevDrvMap*>& vecpNT5DDM);
		
#endif
        bool ObjNameValid(LPCWSTR wstrObject, LPCWSTR wstrObjName, LPCWSTR wstrKeyName, CHString& chstrPATH);
        bool DeviceExists(const CHString& chstrDevice,
                          CConfigMgrDevicePtr & pDevice);
        HRESULT CreateAssociations(MethodContext* pMethodContext, 
                                   std::vector<CHString*>& vecpchsDriverFileLise, 
                                   CHString& chstrDevicePath,
                                   DWORD dwReqProps);

        VOID CleanPCHSTRVector(std::vector<CHString*>& vecpchsDriverFileList);
        BOOL AlreadyAddedToList(std::vector<CHString*>& vecchsList, CHString& chsItem);

        // Keep the enum a private member of this class to prevent any scope conflicts
        enum Purpose
        {
            Unknown, 
            Other, 
            Driver, 
            Configuration_Software, 
            Application_Software, 
            Instrumentation, 
            Firmware
        };
};

// This derived class commits here, not in the base.
inline bool CCIMDeviceCIMDF::ShouldBaseCommit(void* pvData) { return false; }



#ifdef NTONLY
class CNT5DevDrvMap
{
    public:
        CNT5DevDrvMap() {}

        ~CNT5DevDrvMap()
        {
            for(LONG m = 0L; m < m_vecpchstrDrivers.size(); m++)
            {
                delete m_vecpchstrDrivers[m];
            }
        }

        VOID AddDriver(CHString& chstrDriver)
        {
            if(!AlreadyAddedToList(m_vecpchstrDrivers, chstrDriver))
            {
                CHString* pchstrTemp = new CHString;
                if(pchstrTemp != NULL)
                {
                    try
                    {
                        *pchstrTemp = chstrDriver;
                        m_vecpchstrDrivers.push_back(pchstrTemp);
                    }
                    catch ( ... )
                    {
                        delete pchstrTemp;
                        throw;
                    }
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
        }

        BOOL AlreadyAddedToList(std::vector<CHString*>& vecchsList, 
                                   CHString& chsItem)
        {
            for(LONG m = 0; m < vecchsList.size(); m++)
            {
                if(vecchsList[m]->CompareNoCase(chsItem) == 0)
                {
                    return TRUE;
                }
            }
            return FALSE;
        }

        CHString m_chstrDevicePNPID;
        std::vector<CHString*> m_vecpchstrDrivers;
    private:
};
#endif


class CSubDirList
{
    public:
        CSubDirList(MethodContext* pMethodContext, CHString& chstrParentDir) 
        {
            CHString chstrWbemizedParentDir;
            m_chstrRawParentDir = chstrParentDir;
            WBEMizePathName(chstrParentDir, chstrWbemizedParentDir);
            m_pMethodContext = pMethodContext;
            m_chstrParentDir = chstrWbemizedParentDir + _T("\\\\");
            m_chstrParentDrive = m_chstrParentDir.Left(2);
            m_chstrParentPath = m_chstrParentDir.Mid(2);

            CHString chstrQuery;
            chstrQuery.Format(L"SELECT name FROM Win32_Directory WHERE drive = \"%s\" and path = \"%s\"", m_chstrParentDrive, m_chstrParentPath);
            m_hrQuery = CWbemProviderGlue::GetInstancesByQuery(chstrQuery, &m_lSubDirs, pMethodContext, IDS_CimWin32Namespace);   
        }
        
        ~CSubDirList() {}
         
        HRESULT FindFileInDirList(CHString& chstrFileNameIn, CHString& chstrFullPathNameOut)
        {
            HRESULT hr = WBEM_S_NO_ERROR;
            if(FAILED(m_hrQuery))
            {
                hr = m_hrQuery;
            }
            else
            {
                CHString chstrFileNameInCopy = chstrFileNameIn;
                chstrFileNameInCopy.MakeUpper();
                BOOL fRet = FALSE;
                LPTSTR lptstrFilePart = NULL;
                TCHAR tstrPathName[_MAX_PATH];
                ZeroMemory(tstrPathName,sizeof(tstrPathName));
                {
                    // First look for it in the directory itself, then in its sub-directories:
                    if(SearchPath(TOBSTRT(m_chstrRawParentDir), TOBSTRT(chstrFileNameInCopy), NULL, _MAX_PATH, tstrPathName, &lptstrFilePart) != 0)
                    {
                        chstrFullPathNameOut = _tcsupr(tstrPathName);
                        fRet = true;
                    }
                    if(!fRet)
                    {
                        REFPTRCOLLECTION_POSITION pos;
                        CInstancePtr pDir;
                        if(m_lSubDirs.BeginEnum(pos)) 
                        {
                            while(pDir.Attach(m_lSubDirs.GetNext(pos), false), (pDir != NULL) && !fRet)
                            {
                                CHString chstrPath;
                                pDir->GetCHString(IDS_Name, chstrPath);
                                chstrPath.MakeUpper();
                                // Only interested in this path if it is on the correct dirve:
                                CHString chstrTempDrive = chstrPath.Left(2);
                                if(chstrTempDrive.CompareNoCase(m_chstrParentDrive) == 0)
                                {
                                    if(SearchPath(TOBSTRT(chstrPath), TOBSTRT(chstrFileNameIn), NULL, _MAX_PATH, tstrPathName, &lptstrFilePart) != 0)
                                    {
                                        chstrFullPathNameOut = _tcsupr(tstrPathName);
                                        fRet = true;
                                    }
                                }
                            }
                            m_lSubDirs.EndEnum();   
                        }
                    }
                }
            }
            return hr;
        }

        LONG GetCount()
        {
            return m_lSubDirs.GetSize();
        }

    private:
        TRefPointerCollection<CInstance> m_lSubDirs;
        CHString m_chstrParentDir;
        CHString m_chstrParentDrive;
        CHString m_chstrParentPath;
        CHString m_chstrRawParentDir;
        MethodContext* m_pMethodContext;
        HRESULT m_hrQuery;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\codecfile.cpp ===
//=================================================================
//
// CodecFile.CPP -- CodecFile property set provider
//
//  Copyright (c) 1998-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/29/98    sotteson         Created
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include <mmreg.h>
#include <mmsystem.h>
#include <msacm.h>
#include <list>
#include "file.h"
#include "Implement_LogicalFile.h"
#include "cimdatafile.h"
#include "CodecFile.h"
#include "DllWrapperBase.h"
#include "MsAcm32Api.h"
#include "sid.h"
#include "ImpLogonUser.h"
#include <strsafe.h>

#pragma warning(disable : 4995) // we introduced as including strsafe.h gives error for all unsafe string functions


// Property set declaration
//=========================

CWin32CodecFile codecFile(L"Win32_CodecFile", IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CodecFile::CWin32CodecFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32CodecFile::CWin32CodecFile (

	LPCWSTR szName,
	LPCWSTR szNamespace

) : CCIMDataFile(szName, szNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CodecFile::~CWin32CodecFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32CodecFile::~CWin32CodecFile ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CodecFile::ExecQuery
 *
 *  DESCRIPTION : The REAL reason this function is here, given that it only
 *                throws us into this class's EnumerateInstances function, is
 *                that without a local version of the function, the parent's
 *                (CImplement_LogicalFile) exec query is called.  Because one
 *                might want to do a query on this class like
 *                "select * from win32_codecfile where group = "Audio"",
 *                which would throw the parent's query into an enumeration instead
 *                (as group isn't a property it optimizes on), we want to instead
 *                get thrown into THIS class's enumerateinstances, as it does
 *                a much tighter search, since it knows it is only looking for
 *                codec files, and it knows where to look for them.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32CodecFile::ExecQuery(MethodContext* pMethodContext,
                                  CFrameworkQuery& pQuery,
                                  long lFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;


// DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif



    hr = EnumerateInstances(pMethodContext, lFlags);



#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif



    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CodecFile::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32CodecFile :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif

	HRESULT hres = WBEM_E_FAILED;

	try
	{
		DRIVERLIST list ;

#ifdef NTONLY
		hres = BuildDriverListNT ( & list ) ;
#endif

		if(SUCCEEDED(hres))
		{
			list.EliminateDups();

			TCHAR* szDir = new TCHAR[MAX_PATH+1];
			if ( szDir )
			{
				DWORD dwSize = GetSystemDirectory ( szDir , MAX_PATH+1 ) ;
				if ( dwSize )
				{
					if ( dwSize > MAX_PATH )
					{
						delete [] szDir;
						szDir = new TCHAR [ dwSize + 1 ];
						if ( szDir )
						{
							if ( !GetSystemDirectory( szDir, dwSize + 1 ) )
							{
								delete [] szDir;
								szDir = NULL;

								hres = HRESULT_FROM_WIN32 ( ::GetLastError () );
							}
						}
						else
						{
							throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
						}
					}
				}
				else
				{
					delete [] szDir;
					szDir = NULL;
				}

				if ( szDir )
				{
					hres = S_FALSE;

					CHString sQualifiedName(L' ', MAX_PATH);
					while ( list.size () && SUCCEEDED ( hres ) )
					{
						CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
						if ( pInstance )
						{
							DRIVERINFO *pInfo = list.front () ;
							sQualifiedName = szDir;
							sQualifiedName += L'\\';
							sQualifiedName += pInfo->strName;

							// As a final sanity check, prior to commiting, we should
							// confirm that the file really exists (right now all we
							// have is the registry's word on it).
							if(GetFileAttributes(TOBSTRT(sQualifiedName)) != -1L)
							{
								SetInstanceInfo ( pInstance , pInfo , szDir ) ;
								hres = pInstance->Commit (  ) ;
							}
							delete pInfo;
							list.pop_front () ;
						}
						else
						{
							delete [] szDir;
							szDir = NULL;

							throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
						}
					}

					delete [] szDir;
					szDir = NULL;
				}
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
	}
	catch ( ... )
	{
#ifdef NTONLY
		if(fImp)
		{
			icu.End();
			fImp = false;
		}
#endif

		throw;
	}

#ifdef NTONLY
        if(fImp)
        {
            icu.End();
            fImp = false;
        }
#endif

	return hres;
}

HRESULT CWin32CodecFile::GetObject (CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
    HRESULT hrFoundIt = WBEM_E_NOT_FOUND;

#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif


	try
	{
		// Build a list of all drivers.
		DRIVERLIST list;

#ifdef NTONLY
		HRESULT hres = BuildDriverListNT ( &list ) ;
#endif

		if(SUCCEEDED(hres))
		{
			list.EliminateDups();
			CHString strName ;
			pInstance->GetCHString ( IDS_Name , strName ) ;

			TCHAR* szDir = new TCHAR[MAX_PATH+1];
			if ( szDir )
			{
				DWORD dwSize = GetSystemDirectory ( szDir , MAX_PATH+1 ) ;
				if ( dwSize )
				{
					if ( dwSize > MAX_PATH )
					{
						delete [] szDir;
						szDir = new TCHAR [ dwSize + 1 ];
						if ( szDir )
						{
							if ( !GetSystemDirectory( szDir, dwSize + 1 ) )
							{
								delete [] szDir;
								szDir = NULL;

								hres = HRESULT_FROM_WIN32 ( ::GetLastError () );
							}
						}
						else
						{
							throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
						}
					}
				}
				else
				{
					delete [] szDir;
					szDir = NULL;
				}

				if ( szDir )
				{
					hres = S_FALSE;

					// Try to find the instance in the list of drivers.
					while ( list.size () )
					{
						DRIVERINFO *pInfo = list.front () ;

						CHString strPath ;
						strPath.Format ( L"%s\\%s" , (LPCWSTR)TOBSTRT(szDir) , (LPCWSTR)TOBSTRT(pInfo->strName) ) ;

						if ( ! strPath.CompareNoCase ( strName ) )
						{
							if(GetFileAttributes(TOBSTRT(strName)) != -1L)
							{
								SetInstanceInfo ( pInstance , pInfo , szDir ) ;

								delete pInfo ;
    							list.pop_front () ;

								hrFoundIt = WBEM_S_NO_ERROR ;
								break;
							}
						}

						delete pInfo ;
						list.pop_front () ;
					}

					delete [] szDir;
					szDir = NULL;
				}
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			hrFoundIt = hres;
		}
	}
	catch ( ... )
	{
#ifdef NTONLY
		if(fImp)
		{
			icu.End();
			fImp = false;
		}
#endif

		throw;
	}

#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif

	return hrFoundIt;
}

// I thought about putting szSysDir into a member var, but this way we'll save
// a little memory at the expense of a (very) slight degredation in performance.

void CWin32CodecFile::SetInstanceInfo (

	CInstance *pInstance,
	DRIVERINFO *pInfo,
	LPCTSTR szSysDir
)
{
	CHString strPath;
	strPath.Format ( L"%s\\%s", (LPCWSTR) TOBSTRT(szSysDir) , (LPCWSTR) TOBSTRT(pInfo->strName) ) ;

	pInstance->SetCHString ( IDS_Name , strPath ) ;
	pInstance->SetCHString ( IDS_Description , pInfo->strDesc ) ;
	pInstance->SetWCHARSplat ( IDS_Group , pInfo->bAudio ? L"Audio" : L"Video" ) ;
	pInstance->SetWCHARSplat ( IDS_CreationClassName , PROPSET_NAME_CODECFILE ) ;
}


BOOL AlreadyInList (

	DRIVERLIST *pList,
	LPCTSTR szName
)
{
	CHString chstrTmp;
    chstrTmp = szName;
    chstrTmp.MakeUpper();
    for ( DRIVERLIST_ITERATOR i = pList->begin() ; i != pList->end() ; ++ i )
	{
		DRIVERINFO *pInfo = *i ;

		if ( pInfo->strName == chstrTmp )
		{
			return TRUE ;
		}
	}

	return FALSE ;
}

#ifdef NTONLY
HRESULT CWin32CodecFile :: BuildDriverListNT ( DRIVERLIST *pList )
{
	CRegistry regDrivers32 ;

	LONG lRet = regDrivers32.Open (

		HKEY_LOCAL_MACHINE ,
		_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32") ,
		KEY_READ
	) ;

	if ( lRet != ERROR_SUCCESS )
	{
		return WinErrorToWBEMhResult ( lRet ) ;
	}

	// We won't fail if we can't get the description.

	CRegistry regDriversDesc ;

	regDriversDesc.Open (

		HKEY_LOCAL_MACHINE,
		_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc"),
		KEY_READ
	);

	int	nKeys = regDrivers32.GetValueCount();

	// A DWORD thanks to EnumerateAndGetValues using a
	// DWORD& even though it doesn't change the value!!!
	CHString strValueName ;
    CHString strValue ;
    CHString chstrTmp ;

	for ( DWORD iKey = 0; iKey < nKeys ; iKey ++ )
	{
		TCHAR *szValueName ;
		BYTE *szValue ;

		if ( regDrivers32.EnumerateAndGetValues ( iKey , szValueName , szValue ) != ERROR_SUCCESS )
		{
			continue ;
		}

		// Get rid of szValue and szValue.

		try
		{
			strValueName = szValueName ;
		}
		catch ( ... )
		{
	        delete [] szValueName ;

			throw ;
		}

        delete [] szValueName;

		try
		{
			strValue = (LPCTSTR) szValue ;
		}
		catch ( ... )
		{
	        delete [] szValue ;

			throw ;
		}

	    delete [] szValue ;

        if ( AlreadyInList ( pList , ( LPCTSTR ) strValue ) )
		{
            continue ;
		}

		DRIVERINFO *pInfo = new DRIVERINFO ;
		if ( pInfo )
		{
			try
			{

	// Name has to start with MSACM. (audio) or VIDC. (video) to be a codec.

				strValueName.MakeUpper();
				if ( strValueName.Find ( _T("MSACM.") ) == 0 )
				{
					pInfo->bAudio = TRUE ;
				}
				else if ( strValueName.Find ( _T("VIDC.") ) == 0 )
				{
					pInfo->bAudio = FALSE ;
				}
				else
				{
					delete pInfo ;

					continue ;
				}

	// Sometimes the path appears before the driver name; skip that portion

				chstrTmp = strValue ;
				LONG lLastSlash ;

				if ( ( lLastSlash = chstrTmp.ReverseFind ( _T('\\') ) ) != -1 )
				{
					chstrTmp = chstrTmp.Right ( chstrTmp.GetLength () - lLastSlash - 1 ) ;
				}

                chstrTmp.MakeUpper() ;
				pInfo->strName = chstrTmp ;

				regDriversDesc.GetCurrentKeyValue ( ( LPCTSTR ) strValue , pInfo->strDesc ) ;

			}
			catch ( ... )
			{
				delete pInfo ;

				throw ;
			}

			pList->push_front ( pInfo ) ;
         
		}
		else
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
	}

	return WBEM_S_NO_ERROR ;
}
#endif


#ifdef NTONLY
BOOL CWin32CodecFile::IsOneOfMe (

	LPWIN32_FIND_DATAW pstFindData,
	const WCHAR* wstrFullPathName
)
{
    DRIVERLIST list ;

    if(SUCCEEDED(BuildDriverListNT ( & list ) ) )
    {
        list.EliminateDups();

        // If it is in the list, it is a codec file, so it is one of us.
        // strFullPathName will contain a full pathname, but the strName
        // that AlreadInList compares it to is only a filename.ext.  So
        // we need to find the last final \ in the pathname, and take
        // everything after that as the second arg to AlreadyInList.

        WCHAR strTemp[MAX_PATH];
        WCHAR *pwc = NULL;
        pwc = wcsrchr(wstrFullPathName, L'\\');
        if(pwc != NULL)
        {
            if( FAILED(StringCchCopy(strTemp, MAX_PATH, pwc+1))){
                return FALSE;
            }
        }
        else
        {
            if(FAILED(StringCchCopy(strTemp, MAX_PATH, wstrFullPathName))){
                return FALSE;
            }
        }

        if(AlreadyInList(&list, strTemp))
        {
            return TRUE ;
        }
    }

    return FALSE ;
}

#endif

// When one does a query of this class, the query in implement_logicalfile.cpp
// runs.  It calls IsOneOfMe.  If that function returns true, LoadPropertyValues
// out of implement_logicalfile is called.  It loads logical file properties, but
// not properties specific to this class.  It does, however, before returning,
// make a call to GetExtendedProperties (a virtual), which will come in here.
void CWin32CodecFile::GetExtendedProperties(CInstance* a_pInst,
                                            long a_lFlags)
{
    DRIVERLIST list;
    TCHAR szTemp[MAX_PATH];
    LONG lPos = -1;
	CHString chstrFilePathName;
    TCHAR szFilePathName[_MAX_PATH];
    HRESULT hr = E_FAIL;
    if(a_pInst->GetCHString(IDS_Name, chstrFilePathName))
    {
#ifdef NTONLY
        hr = BuildDriverListNT(&list);
#endif
        if(SUCCEEDED(hr))
        {
            list.EliminateDups();
            _tcscpy(szFilePathName, TOBSTRT(chstrFilePathName));
            // need the position in the list of the driver we are interested in.
            // pInfo (used below) only contains filename.exe...
            TCHAR *ptc = NULL;
            ptc = _tcsrchr(szFilePathName, L'\\');
            if(ptc != NULL)
            {
                _tcscpy(szTemp, ptc+1);
            }
            else
            {
                _tcscpy(szTemp, szFilePathName);
            }

            DRIVERINFO *pInfo = NULL;
            if((pInfo = GetDriverInfoFromList(&list, TOBSTRT(szTemp))) != NULL)
            {
				TCHAR* szDir = new TCHAR[MAX_PATH+1];
				if ( szDir )
				{
					DWORD dwSize = GetSystemDirectory ( szDir , MAX_PATH+1 ) ;
					if ( dwSize )
					{
						if ( dwSize > MAX_PATH )
						{
							delete [] szDir;
							szDir = new TCHAR [ dwSize + 1 ];
							if ( szDir )
							{
								if ( !GetSystemDirectory( szDir, dwSize + 1 ) )
								{
									delete [] szDir;
									szDir = NULL;

									hr = HRESULT_FROM_WIN32 ( ::GetLastError () );
								}
							}
							else
							{
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							}
						}
					}
					else
					{
						delete [] szDir;
						szDir = NULL;
					}

					if ( szDir )
					{
						SetInstanceInfo(a_pInst, pInfo, szDir);

						delete [] szDir;
						szDir = NULL;
					}
				}
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
            }
            // pInfo points to a member of list (which may, after the call
            // to GetDriverInfoFromList, be shorter than it was).  list gets
            // cleaned up/deleted via the DRIVERLIST class's destructor, so
            // we don't leak here.
        }
    }
}

DRIVERINFO* CWin32CodecFile::GetDriverInfoFromList(DRIVERLIST *plist, LPCWSTR strName)
{
    DRIVERINFO *pInfo = NULL;
    while(plist->size())
	{
        pInfo = plist->front();
        CHString chstrTemp((LPCWSTR)TOBSTRT(pInfo->strName));
		if(!chstrTemp.CompareNoCase(strName))
		{
            break;
		}
        else
        {
            delete pInfo;
            pInfo = NULL;
    		plist->pop_front();
        }
	}
    return pInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\comobjsecregkey.h ===
//=============================================================================================================

//

// COMObjSecRegKey.h -- header file for CCOMObjectSecurityRegistryKey class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 
//==============================================================================================================

#if !defined __CCOMObjectSecurityRegistryKey_H__
#define __CCOMObjectSecurityRegistryKey_H__

#include "SecurityDescriptor.h"			


////////////////////////////////////////////////////////////////
//
//	Class:	CCOMObjectSecurityRegistryKey
//
//	This class is intended to encapsulate the security of a
//	COM object.Launch/Access Security Information for a COM 
//	object is located under AppID/{appid}[LaunchPermission] &
//	AppID/{appid}[LaunchPermission]. The class inherits off of 
//	CSecurityDescriptor	and it is that class to which it passes 
//	Security Descriptors it obtains, and from which it receives 
//	previously built security descriptors to apply.  
////////////////////////////////////////////////////////////////

#ifdef NTONLY
class CCOMObjectSecurityRegistryKey : public CSecurityDescriptor
{
	// Constructors and destructor
	public:
		CCOMObjectSecurityRegistryKey();
		CCOMObjectSecurityRegistryKey(PSECURITY_DESCRIPTOR a_pSD);
		~CCOMObjectSecurityRegistryKey();

		virtual DWORD AllAccessMask( void );

	protected:

		virtual DWORD WriteOwner( PSECURITY_DESCRIPTOR a_pAbsoluteSD);
		virtual DWORD WriteAcls( PSECURITY_DESCRIPTOR a_pAbsoluteSD , SECURITY_INFORMATION a_securityinfo  );
	private:

};
#endif

#endif // __CCOMObjectSecurityRegistryKey_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\codecfile.h ===
//=================================================================

//

// CodecFile.h -- CWin32CodecFile property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/29/98    sotteson         Created
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_CODECFILE L"Win32_CodecFile"

typedef struct _DRIVERINFO
{
	CHString	strName,
				strDesc;
	BOOL		bAudio;
} DRIVERINFO;

typedef std::list<DRIVERINFO*>::iterator	DRIVERLIST_ITERATOR;

class DRIVERLIST : public std::list<DRIVERINFO*>
{
public:

	~DRIVERLIST ()
	{
		while ( size () )
		{
			DRIVERINFO *pInfo = front () ;
			
			delete pInfo ;

			pop_front () ;
		}
	}

    void EliminateDups()
    {
        sort();
        unique();
    }

} ;

class CWin32CodecFile : public CCIMDataFile
{
public:
	// Constructor/destructor
	//=======================
	CWin32CodecFile(LPCWSTR szName, LPCWSTR szNamespace);
	~CWin32CodecFile();

	virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, 
		long lFlags = 0);
	virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery);

    virtual HRESULT ExecQuery(MethodContext* pMethodContext, 
                                  CFrameworkQuery& pQuery, 
                                  long lFlags = 0L);


protected:
	// Overridable function inherrited from CCIMLogicalFile
	// NEED TO IMPLEMENT THESE HERE SINCE THIS CLASS IS DERIVED FROM
    // CCimDataFile (BOTH C++ AND MOF DERIVATION).  
    // THAT CLASS CALLS IsOneOfMe.  THE MOST DERIVED (IN CIMOM)
    // INSTANCE GETS CALLED.  IF NOT IMPLEMENTED HERE, THE IMPLEMENTATION
    // IN CCimDataFile WOULD BE USED, WHICH WILL COMMIT FOR DATAFILES.
    // HOWEVER, IF CWin32CodecFile DOES NOT RETURN FALSE FROM ITS IsOneOfMe,
    // WHICH IT WON'T DO IF NOT IMPLEMENTED HERE, CIMOM WILL ASSIGN ALL
    // DATAFILES TO THIS CLASS SINCE IT PUTS INSTANCES FROM THE MOST
    // DERIVED (CIMOM DERIVED THAT IS) CLASS.
#ifdef NTONLY
	virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
		                   const WCHAR* wstrFullPathName);
#endif

	// Overridable function inherrited from CProvider
	virtual void GetExtendedProperties(CInstance* pInstance, long lFlags = 0L);

#ifdef NTONLY
	HRESULT BuildDriverListNT(DRIVERLIST *pList);
#endif
	void SetInstanceInfo(CInstance *pInstance, DRIVERINFO *pInfo, 
		LPCTSTR szSysDir);
private:
    DRIVERINFO* GetDriverInfoFromList(DRIVERLIST *plist, LPCWSTR strName);	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\comobjsecregkey.cpp ===
//=============================================================================================================

//

// COMObjSecRegKey.CPP -- implementation file for CCOMObjectSecurityRegistryKey class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//
//==============================================================================================================

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "COMObjSecRegKey.h"

#ifdef NTONLY

///////////////////////////////////////////////////////////////////
//
//	Function:	CCOMObjectSecurityRegistryKey::CCOMObjectSecurityRegistryKey
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CCOMObjectSecurityRegistryKey::CCOMObjectSecurityRegistryKey()
:	CSecurityDescriptor()
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CCOMObjectSecurityRegistryKey::CCOMObjectSecurityRegistryKey
//
//	Alternate Class CTOR
//
//	Inputs:
//				PSECURITY_DESCRIPTOR- Security Descriptor stored in the registry for the COM Class
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CCOMObjectSecurityRegistryKey::CCOMObjectSecurityRegistryKey( PSECURITY_DESCRIPTOR a_pSD )
:	CSecurityDescriptor( a_pSD )
{
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CCOMObjectSecurityRegistryKey::~CCOMObjectSecurityRegistryKey
//
//	Class Destructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CCOMObjectSecurityRegistryKey::~CCOMObjectSecurityRegistryKey( void )
{
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CCOMObjectSecurityRegistryKey::WriteAcls
//
//	Protected entry point called by CSecurityDescriptor when
//	a user Applies Security and wants to apply security for
//	the DACL and/or SACL.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security
//										descriptor to apply to
//										the file.
//				SECURITY_INFORMATION	securityinfo - Flags
//										indicating which ACL(s)
//										to set.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CCOMObjectSecurityRegistryKey::WriteAcls( PSECURITY_DESCRIPTOR a_pAbsoluteSD, SECURITY_INFORMATION a_securityinfo )
{
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CCOMObjectSecurityRegistryKey::WriteOwner
//
//	Protected entry point called by CSecurityDescriptor when
//	a user Applies Security and wants to apply security for
//	the owner.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security
//										descriptor to apply to
//										the file.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CCOMObjectSecurityRegistryKey::WriteOwner( PSECURITY_DESCRIPTOR a_pAbsoluteSD )
{
	return ERROR_SUCCESS;
}

DWORD CCOMObjectSecurityRegistryKey::AllAccessMask( void )
{
	// File specific All Access Mask
	return FILE_ALL_ACCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\computersystem.cpp ===
//=================================================================
//
// ComputerSystem.CPP --Computer system property set provider
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//              09/12/97    a-sanjes        GetCompSysInfo takes param.
//              10/23/97    jennymc         Changed to new framework
//
//=================================================================

#include "precomp.h"

#include "perfdata.h"
#include "wbemnetapi32.h"
#include <lmwksta.h>
#include <smartptr.h>
#include "ComputerSystem.h"
#include "implogonuser.h"
#include <comdef.h>
#include <lmcons.h>
#include <lmwksta.h>
#include <lm.h>
#include "Kernel32Api.h"
#include <cominit.h>
#include "WMI_FilePrivateProfile.h"


//#include <srvapi.h>

//#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)
#include <ntexapi.h>
#include "NVRam.h"
#endif

#include "smbios.h"
#include "smbstruc.h"

#include "KUserdata.h"

#include <fileattributes.h>

#include <wtsapi32.h>
#include <..\..\framework\provexpt\include\provexpt.h>

//
// for GetComputerNameEx
//
#include <computerApi.h>

#define PROF_SECT_SIZE 3000



const DWORD SM_BIOS_HARDWARE_SECURITY_UNKNOWN = 3 ;
#define GFS_NEARESTMEGRAMSIZE   0x1794

#define REGKEY_TIMEZONE_INFO    L"System\\CurrentControlSet\\Control\\TimeZoneInformation"
#define REGVAL_TZNOAUTOTIME     L"DisableAutoDaylightTimeSet"


//
static SV_ROLES g_SvRoles[] =  {
    
    { IDS_LM_Workstation,           SV_TYPE_WORKSTATION },
    { IDS_LM_Server,                SV_TYPE_SERVER  },
    { IDS_SQLServer,                SV_TYPE_SQLSERVER   },
    { IDS_Domain_Controller,        SV_TYPE_DOMAIN_CTRL     },
    { IDS_Domain_Backup_Controller, SV_TYPE_DOMAIN_BAKCTRL  },
    { IDS_Timesource,               SV_TYPE_TIME_SOURCE },
    { IDS_AFP,                      SV_TYPE_AFP },
    { IDS_Novell,                   SV_TYPE_NOVELL  },
    { IDS_Domain_Member,            SV_TYPE_DOMAIN_MEMBER   },
    { IDS_Local_List_Only,          SV_TYPE_LOCAL_LIST_ONLY },
    { IDS_Print,                    SV_TYPE_PRINTQ_SERVER   },
    { IDS_DialIn,                   SV_TYPE_DIALIN_SERVER   },
    { IDS_Xenix_Server,             SV_TYPE_XENIX_SERVER    },
    { IDS_MFPN,                     SV_TYPE_SERVER_MFPN },
    { IDS_NT,                       SV_TYPE_NT  },
    { IDS_WFW,                      SV_TYPE_WFW },
    { IDS_Server_NT,                SV_TYPE_SERVER_NT   },
    { IDS_Potential_Browser,        SV_TYPE_POTENTIAL_BROWSER   },
    { IDS_Backup_Browser,           SV_TYPE_BACKUP_BROWSER  },
    { IDS_Master_Browser,           SV_TYPE_MASTER_BROWSER  },
    { IDS_Domain_Master,            SV_TYPE_DOMAIN_MASTER   },
    { IDS_Domain_Enum,              SV_TYPE_DOMAIN_ENUM },
    { IDS_Windows_9x,               SV_TYPE_WINDOWS },
    { IDS_DFS,                      SV_TYPE_DFS }
} ;


CWin32ComputerSystem MyCWin32ComputerSystemSet(PROPSET_NAME_COMPSYS, IDS_CimWin32Namespace);
/*****************************************************************************
*
*  FUNCTION    : GetAllocatedProfileString ()
*
*  DESCRIPTION : Gets a profile string allocated on heap
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/

TCHAR *GetAllocatedProfileString (
                                  
                                  const CHString &a_Section ,
                                  const CHString &a_Key ,
                                  const CHString &a_FileName
                                  )
{
    TCHAR *szDefault = NULL ;
    DWORD dwRet ;
    DWORD dwSize = 1024 ;
    
    do
    {
        if ( szDefault != NULL )
        {
            delete [] szDefault ;
        }
        
        dwSize *= 2 ;
        
        szDefault = new TCHAR [ dwSize ] ;
        if ( szDefault )
        {
#ifdef NTONLY
            dwRet = WMI_FILE_GetPrivateProfileStringW (
                
                a_Section,
                a_Key,
                L"~~~",
                szDefault,
                dwSize/sizeof(WCHAR),  // GPPS works in chars, not bytes
                a_FileName
                ) ;
#else
            dwRet = GetPrivateProfileString (
                
                TOBSTRT(a_Section),
                TOBSTRT(a_Key),
                _T("~~~"),
                szDefault,
                dwSize/sizeof(TCHAR),  // GPPS works in chars, not bytes
                TOBSTRT(a_FileName)
                ) ;
#endif
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        
    } while ( dwRet == ((dwSize/sizeof(TCHAR)) - 1) ) ;

    return szDefault ;
}

/*****************************************************************************
*
*  FUNCTION    : GetAllocatedProfileSection ()
*
*  DESCRIPTION : Gets a profile section allocated on heap
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/

TCHAR *GetAllocatedProfileSection (
                                   
                                   const CHString &a_Section ,
                                   const CHString &a_FileName ,
                                   DWORD *a_dwSize
                                   )
{
	if (a_dwSize == NULL)
	{
		return NULL;
	}

    DWORD dwSize = 1024 ;
    TCHAR *szOptions = NULL ;
    
    do {
        
        dwSize *= 2;
        
        if ( szOptions != NULL )
        {
            delete [] szOptions ;
        }
        
        szOptions = new TCHAR [ dwSize ] ;
        
        if ( szOptions != NULL )
        {
            
            ZeroMemory ( szOptions , dwSize ) ;
            // Win98 GetPrivateProfileSection broken as of 6/15/98, so hack around it (Win98 only)
            
            {
                *a_dwSize = WMI_FILE_GetPrivateProfileSectionW ( a_Section, szOptions, dwSize/sizeof(WCHAR) , a_FileName) ;
            }
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        
    } while ( *a_dwSize == ((dwSize/sizeof(TCHAR)) - 2) ) ;
    
    return szOptions ;
}

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::CWin32ComputerSystem
*
*  DESCRIPTION : Constructor
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    : Registers property set with framework
*
*****************************************************************************/

CWin32ComputerSystem :: CWin32ComputerSystem (
                                              
                                              const CHString &name ,
                                              LPCWSTR pszNamespace
                                              
                                              ) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::~CWin32ComputerSystem
*
*  DESCRIPTION : Destructor
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    : Deregisters property set from framework
*
*****************************************************************************/
CWin32ComputerSystem :: ~CWin32ComputerSystem()
{
    // Because of performance issues with HKEY_PERFORMANCE_DATA, we close in the
    // destructor so we don't force all the performance counter dlls to get
    // unloaded from memory, and also to prevent an apparent memory leak
    // caused by calling RegCloseKey( HKEY_PERFORMANCE_DATA ).  We use the
    // class since it has its own internal synchronization.  Also, since
    // we are forcing synchronization, we get rid of the chance of an apparent
    // deadlock caused by one thread loading the performance counter dlls
    // and another thread unloading the performance counter dlls
    
    // Per raid 48395, we aren't going to shut this at all.
    
#ifdef NTONLY
    //  CPerformanceData perfdata ;
    
    //  perfdata.Close() ;
#endif
}

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::ExecQuery
*
*  DESCRIPTION : Query support
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CWin32ComputerSystem :: ExecQuery (
                                           
                                           MethodContext *pMethodContext,
                                           CFrameworkQuery& pQuery,
                                           long lFlags /*= 0L*/
                                           )
{
    HRESULT hr = WBEM_E_FAILED;
    
    // If all they want is the name, we'll give it to them, else let them call enum.
    
    if ( pQuery.KeysOnly () )
    {
        CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
        
        pInstance->SetCHString ( IDS_Name , GetLocalComputerName () ) ;
        hr = pInstance->Commit (  ) ;
    }
    else
    {
        hr = WBEM_E_PROVIDER_NOT_CAPABLE;
    }
    
    return hr;
}

/*****************************************************************************
*
*  FUNCTION    : GetObject
*
*  DESCRIPTION : Assigns values to property set according to key value
*                already set by framework
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CWin32ComputerSystem::GetObject (
                                         
                                         CInstance *pInstance ,
                                         long lFlags,
                                         CFrameworkQuery &pQuery
                                         )
{
    HRESULT hr = WBEM_S_NO_ERROR ;
    
    CHString sComputerName = GetLocalComputerName () ;
    
    CHString sReqName ;
    pInstance->GetCHString ( IDS_Name , sReqName ) ;
    
    if ( sReqName.CompareNoCase ( sComputerName ) != 0 )
    {
        hr = WBEM_E_NOT_FOUND ;
    }
    else
    {
        if ( !pQuery.KeysOnly () )
        {
            hr = GetCompSysInfo ( pInstance ) ;
        }
    }
    
    return hr ;
}

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::EnumerateInstances
*
*  DESCRIPTION : Creates instance of property set for each logical disk
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CWin32ComputerSystem :: EnumerateInstances (
                                                    
                                                    MethodContext *pMethodContext ,
                                                    long lFlags /*= 0L*/
                                                    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
    
    CHString sComputerName ;
    sComputerName = GetLocalComputerName () ;
    
    pInstance->SetCHString ( IDS_Name, sComputerName ) ;
    
    if ( SUCCEEDED ( hr = GetCompSysInfo ( pInstance ) ) )
    {
        HRESULT t_hr = pInstance->Commit ( ) ;
        if ( FAILED ( t_hr ) )
        {
            hr = t_hr ;
        }
    }
    else
    {
        hr = WBEM_E_FAILED ;
    }
    
    return hr;
}

//////////////////////////////////////////////////////////////////////////

HRESULT CWin32ComputerSystem::GetCompSysInfo ( CInstance *pInstance )
{
    HRESULT t_hr = WBEM_S_NO_ERROR ;
    InitializePropertiestoUnknown ( pInstance ) ;
    
    SYSTEM_INFO SysInfo ;
    
    pInstance->SetCharSplat ( IDS_CreationClassName , PROPSET_NAME_COMPSYS ) ;
    
    pInstance->SetCHString ( IDS_Caption , GetLocalComputerName () ) ;
    
    // a few properties that come under the heading of "well, duh"
    
    pInstance->Setbool ( IDS_BootRomSupported , true ) ;
    pInstance->SetCHString ( IDS_Status , IDS_CfgMgrDeviceStatus_OK ) ;
    
    //============================================================
    // Get common properties first
    //============================================================
    CHString t_UserName ;
    CHString t_DomainName ;
    CHString t_UserDomain ;
#if NTONLY >= 5
SetUserName(pInstance);    
#endif
    
    // Get the amount of physical memory
    //==================================
#ifdef NTONLY
    if( IsWinNT5() )
    {
        CKernel32Api* pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
        if(pKernel32 != NULL)
        {
            
            MEMORYSTATUSEX  stMemoryVLM;
            stMemoryVLM.dwLength = sizeof( MEMORYSTATUSEX );
            
            BOOL bRetCode;
            if(pKernel32->GlobalMemoryStatusEx(&stMemoryVLM, &bRetCode) && bRetCode)
            {
                pInstance->SetWBEMINT64 ( IDS_TotalPhysicalMemory, (const __int64) stMemoryVLM.ullTotalPhys );
            }
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);
            pKernel32 = NULL;
        }
    }
    else
    {
        MEMORYSTATUS stMemory;
        stMemory.dwLength = sizeof ( MEMORYSTATUS ) ;
        
        GlobalMemoryStatus(&stMemory);
        pInstance->SetWBEMINT64 ( IDS_TotalPhysicalMemory, (const __int64) stMemory.dwTotalPhys );
    }
    
#else
    {
        CCim32NetApi *t_pCim32NetApi = HoldSingleCim32NetPtr :: GetCim32NetApiPtr () ;
        try
        {
            if ( t_pCim32NetApi )
            {
                DWORD t_dwMemorySize = t_pCim32NetApi->GetWin9XGetFreeSpace ( GFS_NEARESTMEGRAMSIZE ) ;
                pInstance->SetWBEMINT64 ( IDS_TotalPhysicalMemory, (const __int64) t_dwMemorySize );
            }
        }
        catch ( ... )
        {
            CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidCim32NetApi , t_pCim32NetApi ) ;
            t_pCim32NetApi = NULL ;
            throw ;
        }
        
        if ( t_pCim32NetApi )
        {
            CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidCim32NetApi , t_pCim32NetApi ) ;
            t_pCim32NetApi = NULL ;
        }
    }
#endif
    
    // Timezone
    
    GetTimeZoneInfo ( pInstance ) ;
    
    // Infra red
    
    CConfigManager cfgManager ;
    CDeviceCollection deviceList ;
    BOOL bInfrared = FALSE ;
    
    if ( cfgManager.GetDeviceListFilterByClass ( deviceList , L"Infrared" ) )
    {
        REFPTR_POSITION pos ;
        
        deviceList.BeginEnum ( pos ) ;
        
        if ( deviceList.GetSize () )
        {
            bInfrared = TRUE ;
        }
        
        deviceList.EndEnum () ;
    }
    
    pInstance->SetDWORD ( IDS_InfraredSupported , bInfrared ) ;
    
    GetSystemInfo ( & SysInfo ) ;
    CHString SystemType;
    
#ifdef NTONLY
    KUserdata ku ;
    
    if(( SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) && ku.IsNec98() )
    {
        SystemType = IDS_ProcessorX86Nec98;
    }
    else
#endif
        
    {
        switch ( SysInfo.wProcessorArchitecture )
        {
        case PROCESSOR_ARCHITECTURE_INTEL:
            {
                SystemType = IDS_ProcessorX86 ;
            }
            break ;
            
            
        case PROCESSOR_ARCHITECTURE_IA64:
            {
                SystemType = IDS_ProcessorIA64 ;
            }
            break ;

        case PROCESSOR_ARCHITECTURE_AMD64:
            {
                SystemType = IDS_ProcessorAMD64 ;
            }
            break;

        default:
            {
                SystemType = IDS_ProcessorUnknown ;
            }
            break ;
        }
    }
    
    pInstance->SetDWORD ( IDS_NumberOfProcessors , SysInfo.dwNumberOfProcessors ) ;
    pInstance->SetCHString ( IDS_SystemType , SystemType ) ;
    
    //============================================================
    // Get the system bootup info to see if we're in a clean state
    // or not
    //============================================================
    switch ( GetSystemMetrics ( SM_CLEANBOOT ) )
    {
    case 0:
        {
            pInstance->SetCHString ( IDS_BootupState , IDS_BootupStateNormal ) ;
        }
        break ;
        
    case 1:
        {
            pInstance->SetCHString ( IDS_BootupState , IDS_BootupStateFailSafe ) ;
        }
        break ;
        
    case 2:
        {
            pInstance->SetCHString ( IDS_BootupState , IDS_BootupStateFailSafeWithNetBoot ) ;
        }
        break ;
    };
    
    // SMBIOS qualified properties for this class
    {
        CSMBios smbios;
        
        if ( smbios.Init () )
        {
            int i ;
            WCHAR tempstr[ MIF_STRING_LENGTH + 1];
            
            //PSYSTEMINFO   psi = (PSYSTEMINFO) smbios.GetFirstStruct( 1 );
            PSTLIST pstl = smbios.GetStructList(1);
            
            if (pstl)
            {
                PSYSTEMINFO psi = (PSYSTEMINFO) pstl->pshf;
                
                smbios.GetStringAtOffset( (PSHF) psi, tempstr, psi->Manufacturer );
                if ( *tempstr && *tempstr != 0x20 )
                {
                    pInstance->SetCHString( L"Manufacturer", tempstr );
                }
                
                smbios.GetStringAtOffset( (PSHF) psi, tempstr, psi->Product_Name );
                if ( *tempstr && *tempstr != 0x20 )
                {
                    pInstance->SetCHString( IDS_Model, tempstr );
                }
                
                if ( smbios.GetVersion( ) > 0x00020000 && psi->Length >= sizeof( SYSTEMINFO ) )
                {
                    pInstance->SetByte( L"WakeUpType", psi->Wakeup_Type );
                }
                else
                {
                    pInstance->SetByte( L"WakeUpType", 2 ); // Unknown
                }
            }
            
            //POEMSTRINGS   pos = (POEMSTRINGS) smbios.GetFirstStruct( 11 );
            pstl = smbios.GetStructList(11);
            
            if (pstl)
            {
                POEMSTRINGS pos = (POEMSTRINGS) pstl->pshf;
                SAFEARRAYBOUND sab ;
                variant_t vValue;
                sab.lLbound = 0 ;
                sab.cElements = pos->Count ;
                
                
                V_ARRAY(&vValue) = SafeArrayCreate ( VT_BSTR, 1, &sab );
                if ( V_ARRAY(&vValue) )
                {
                    vValue.vt = VT_BSTR | VT_ARRAY;
                    for ( i = 0 ; i < pos->Count ; i++ )
                    {
                        int len = smbios.GetStringAtOffset ( ( PSHF ) pos , tempstr , i + 1 );
                        SafeArrayPutElement ( V_ARRAY(&vValue), (long *) & i, ( BSTR ) _bstr_t ( tempstr ) ) ;
                    }
                    
                    pInstance->SetVariant ( L"OEMStringArray", vValue ) ;
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            
            //PSYSTEMRESET psr = (PSYSTEMRESET) smbios.GetFirstStruct( 23 );
            pstl = smbios.GetStructList(23);
            
            if (pstl)
            {
                PSYSTEMRESET psr = (PSYSTEMRESET) pstl->pshf;
                __int64 pause;
                
                pInstance->SetDWORD( L"BootOptionOnLimit", ( psr->Capabilities & 0x18 ) >> 3 );
                pInstance->SetDWORD( L"BootOptionOnWatchDog", ( psr->Capabilities & 0x06 ) >> 1 );
                pInstance->SetWBEMINT16( L"ResetCount", psr->ResetCount );
                pInstance->SetWBEMINT16( L"ResetLimit", psr->ResetLimit );
                pause = psr->Timeout;
                if ( pause != -1 )
                {
                    pause *= 60000; // change minutes to milliseconds
                }
                
                pInstance->SetWBEMINT64( L"PauseAfterReset", pause );
            }
            
            //PHARDWARESECURITY phs = (PHARDWARESECURITY) smbios.GetFirstStruct( 24 );
            pstl = smbios.GetStructList(24);
            if (pstl)
            {
                PHARDWARESECURITY phs = (PHARDWARESECURITY) pstl->pshf;
                
                pInstance->SetDWORD( L"PowerOnPasswordStatus",      ( phs->SecuritySettings & 0xc0 ) >> 6 );
                pInstance->SetDWORD( L"KeyboardPasswordStatus",     ( phs->SecuritySettings & 0x30 ) >> 4 );
                pInstance->SetDWORD( L"AdminPasswordStatus",        ( phs->SecuritySettings & 0x0c ) >> 2 );
                pInstance->SetDWORD( L"FrontPanelResetStatus",      ( phs->SecuritySettings & 0x03 ) );
            }
            
            //PENCLOSURE pe = (PENCLOSURE) smbios.GetFirstStruct( 3 );
            pstl = smbios.GetStructList(3);
            if (pstl)
            {
                PENCLOSURE pe = (PENCLOSURE) pstl->pshf;
                
                if ( smbios.GetVersion () > 0x00020000 && pe->Length >= 13 )
                {
                    pInstance->SetByte ( L"ChassisBootupState", pe->Bootup_State );
                    pInstance->SetByte ( L"PowerSupplyState", pe->Power_Supply_State );
                    pInstance->SetByte ( L"ThermalState", pe->Thermal_State );
                }
            }
        }
    }
    
    // If these aren't set from SMBIOS then try ACPI reg entry
    
    if ( pInstance->IsNull ( L"Manufacturer" ) || pInstance->IsNull ( IDS_Model ) )
    {
        TCHAR szAcpiOem[MIF_STRING_LENGTH + 1];
        TCHAR szAcpiProduct[MIF_STRING_LENGTH + 1];
        static const TCHAR szRSDT[] = _T("Hardware\\ACPI\\DSDT");
        HKEY hkeyTable = NULL;
        
        if (ERROR_SUCCESS == RegOpenKeyEx ( HKEY_LOCAL_MACHINE , szRSDT , 0 , MAXIMUM_ALLOWED , & hkeyTable ) &&
            ERROR_SUCCESS == RegEnumKey ( hkeyTable , 0 , szAcpiOem , sizeof ( szAcpiOem ) / sizeof(TCHAR) ) )
        {
            HKEY hkeyOEM = 0 ;
            if ( pInstance->IsNull ( L"Manufacturer" ) )
            {
                pInstance->SetCHString( L"Manufacturer", szAcpiOem ) ;
            }
            if ( pInstance->IsNull ( IDS_Model ) )
            {
                if (ERROR_SUCCESS == RegOpenKeyEx ( hkeyTable , szAcpiOem , 0 , MAXIMUM_ALLOWED , & hkeyOEM ) &&
                    ERROR_SUCCESS == RegEnumKey ( hkeyOEM , 0 , szAcpiProduct , sizeof ( szAcpiProduct ) / sizeof(TCHAR) ) )
                {
                    pInstance->SetCHString ( IDS_Model , szAcpiProduct );
                }
                
                if ( hkeyOEM )
                {
                    RegCloseKey ( hkeyOEM ) ;
                }
            }
        }
        
        if ( hkeyTable )
        {
            RegCloseKey ( hkeyTable ) ;
        }
    }
    
    // Get OS-specific properties
    //===========================
    
#ifdef NTONLY
    
    t_hr = GetCompSysInfoNT ( pInstance ) ;
    
#endif
    
    return t_hr ;
}

//////////////////////////////////////////////////////////////////////
#ifdef NTONLY
HRESULT CWin32ComputerSystem::GetCompSysInfoNT(CInstance *pInstance)
{
    HRESULT t_hr = WBEM_S_NO_ERROR ;

	//
	// there was request for DNS name returned too
	//

    if (GetPlatformMajorVersion() >= 5)
    {
		CHString strComputerName ;

		DWORD   dwBuffSize = MAX_COMPUTERNAME_LENGTH + 1 ;
		LPWSTR  pszBuffer = strComputerName.GetBuffer ( dwBuffSize ) ;

		BOOL bGotName = FALSE ;

		//
		// CHString throws in low memory
		// so we should not really bother
		//
		if ( NULL != pszBuffer ) 
		{
			if ( FALSE == ProviderGetComputerNameEx ( ComputerNameDnsHostname, pszBuffer, &dwBuffSize ) )
			{
				if ( ERROR_MORE_DATA == ::GetLastError () )
				{
					//
					// let's reallocate as requested
					// CHString will release previous buffer
					//
					pszBuffer = strComputerName.GetBuffer ( dwBuffSize ) ;

					//
					// CHString throws in low memory
					// so we should not really bother
					//
					if ( NULL != pszBuffer )
					{
						if ( TRUE == ProviderGetComputerNameEx ( ComputerNameDnsHostname, pszBuffer, &dwBuffSize ) )
						{
							bGotName = TRUE ;
						}
					}
				}
			}
			else
			{
				bGotName = TRUE ;
			}

			//
			// CHString throws in low memory
			// so we should not really bother
			//
			if ( pszBuffer )
			{
				strComputerName.ReleaseBuffer () ;
			}

			if ( TRUE == bGotName )
			{
				pInstance->SetCHString ( IDS_DNSName, strComputerName ) ;
			}
		}
	}

    // no power management in any NTs <= 4
    if (GetPlatformMajorVersion() <= 4)
    {
        pInstance->Setbool(IDS_PowerManagementSupported, false);
        //      pInstance->Setbool(IDS_PowerManagementEnabled, false);
    }
    else
    {
        // dunno yet.
        LogMessage(IDS_LogNoAPMForNT5);
    }
    
    // auto reset - My computer, properties, start up tab, "automatic reboot"
    // I guess...
    // note that this doesn't seem to appear under HKEY_CURRENT_CONTROL
    pInstance->Setbool(IDS_AutomaticResetCapability, true);
    
    CRegistry RegInfo ;
    
    DWORD dwRet = RegInfo.Open (
        
        HKEY_LOCAL_MACHINE,
        IDS_RegCrashControl,
        KEY_READ
        ) ;
    
    if ( dwRet == ERROR_SUCCESS )
    {
        DWORD duhWord;
        if (RegInfo.GetCurrentKeyValue(IDS_RegAutoRebootKey, duhWord) == ERROR_SUCCESS)
        {
            pInstance->Setbool(IDS_AutomaticResetBootOption, (bool)duhWord);
        }
        else
        {
            pInstance->Setbool(IDS_AutomaticResetBootOption, false);
        }
        
        RegInfo.Close();
    }
    else
    {
        pInstance->Setbool(IDS_AutomaticResetBootOption, false);
    }
    
    // best guess for "Primary Owner" - it shows up under "My Computer"
    
    dwRet = RegInfo.Open (
        
        HKEY_LOCAL_MACHINE,
        IDS_RegCurrentNTVersion,
        KEY_READ
        ) ;
    
    if ( dwRet == ERROR_SUCCESS )
    {
        CHString sTemp ;
        
        if ( RegInfo.GetCurrentKeyValue(IDS_RegRegisteredOwnerKey, sTemp) == ERROR_SUCCESS )
        {
            pInstance->SetCHString ( IDS_PrimaryOwner , sTemp ) ;
        }
        
        RegInfo.Close () ;
    }
    
    // Raid 14139
    
    dwRet = RegInfo.Open (
        
        HKEY_LOCAL_MACHINE,
        IDS_RegBiosSystem,
        KEY_READ
        ) ;
    
    if (  dwRet == ERROR_SUCCESS )
    {
        CHString sTemp ;
        
        dwRet = RegInfo.GetCurrentKeyValue ( IDS_RegIdentifierKey , sTemp ) ;
        if ( dwRet == ERROR_SUCCESS )
        {
            pInstance->SetCHString ( IDS_Description , sTemp ) ;
        }
    }
    
    CNetAPI32 NetAPI;
    
    if ( NetAPI.Init () == ERROR_SUCCESS )
    {
        NET_API_STATUS t_status ;
#if NTONLY >= 5
        
        DSROLE_PRIMARY_DOMAIN_INFO_BASIC *t_pDsInfo = 0;
        
        t_status = NetAPI.DSRoleGetPrimaryDomainInfo(
            NULL,
            DsRolePrimaryDomainInfoBasic,
            (PBYTE *)&t_pDsInfo ) ;
        
        if( t_status == NERR_Success && t_pDsInfo )
        {
            try
            {
                switch( t_pDsInfo->MachineRole )
                {
                case DsRole_RoleMemberWorkstation:
                case DsRole_RoleMemberServer:
                case DsRole_RoleBackupDomainController:
                case DsRole_RolePrimaryDomainController:
                    {
                        // Set the domain to the DNS domain name if it has
                        // been populated.  However, as this api has the option
                        // of not setting this element, if it hasn't been set,
                        // use the DomainNameFlat element instead.
                        if(t_pDsInfo->DomainNameDns)
                        {
                            pInstance->SetWCHARSplat( IDS_Domain, t_pDsInfo->DomainNameDns ) ;
                        }
                        else
                        {
                            pInstance->SetWCHARSplat( IDS_Domain, t_pDsInfo->DomainNameFlat ) ;
                        }
                        
                        pInstance->Setbool( L"PartOfDomain", true ) ;
                        break ;
                    }
                    
                case DsRole_RoleStandaloneWorkstation:
                case DsRole_RoleStandaloneServer:
                    {
                        bstr_t t_bstrWorkGroup( t_pDsInfo->DomainNameFlat ) ;
                        
                        if( !t_bstrWorkGroup.length() )
                        {
                            pInstance->SetWCHARSplat( IDS_Domain, L"WORKGROUP" ) ;
                        }
                        else
                        {
                            pInstance->SetWCHARSplat( IDS_Domain, t_bstrWorkGroup ) ;
                        }
                        pInstance->Setbool( L"PartOfDomain", false ) ;
                    }
                }
            }
            catch( ... )
            {
                NetAPI.DSRoleFreeMemory( (LPBYTE)t_pDsInfo ) ;
                throw ;
            }
            NetAPI.DSRoleFreeMemory( (LPBYTE)t_pDsInfo ) ;
        }
#else
        WKSTA_INFO_100 *pstInfo = NULL ;
        t_status = NetAPI.NetWkstaGetInfo ( NULL , 100 , ( LPBYTE * ) &pstInfo ) ;
        if (t_status == NERR_Success)
        {
            try
            {
                pInstance->SetWCHARSplat ( IDS_Domain , ( WCHAR * ) pstInfo->wki100_langroup ) ;
            }
            catch ( ... )
            {
                NetAPI.NetApiBufferFree ( pstInfo );
                
                throw ;
            }
            
            NetAPI.NetApiBufferFree ( pstInfo );
        }
#endif
        PSERVER_INFO_101 ps = NULL;
        t_status = NetAPI.NetServerGetInfo ( NULL , 101 , (LPBYTE *)&ps ) ;
        if ( t_status == NERR_Success )
        {
            try
            {
                pInstance->Setbool ( IDS_NetworkServerModeEnabled , ps->sv101_type & SV_TYPE_SERVER ) ;
                SetRoles ( pInstance , ps->sv101_type ) ;
            }
            catch ( ... )
            {
                NetAPI.NetApiBufferFree ( ps ) ;
                
                throw ;
            }
            
            NetAPI.NetApiBufferFree ( ps ) ;
        }
        
        // KMH 32414
        if ( GetPlatformMajorVersion() >= 5 )
        {
            DSROLE_PRIMARY_DOMAIN_INFO_BASIC *info = NULL;
            
            t_status = NetAPI.DSRoleGetPrimaryDomainInfo (
                
                NULL,
                DsRolePrimaryDomainInfoBasic,
                (LPBYTE *)&info
                );
            
            if ( t_status == NERR_Success )
            {
                try
                {
                    pInstance->SetDWORD ( IDS_DomainRole , info->MachineRole ) ;
                }
                catch ( ... )
                {
                    NetAPI.DSRoleFreeMemory ( ( LPBYTE ) info ) ;
                    
                    throw ;
                }
                
                NetAPI.DSRoleFreeMemory ( ( LPBYTE ) info ) ;
            }
        }
        else
        {
            if ( IsWinNT4 () )
            {
                DSROLE_MACHINE_ROLE t_MachineRole ;
                DWORD t_dwError ;
                if ( NetAPI.DsRolepGetPrimaryDomainInformationDownlevel (
                    
                    t_MachineRole,
                    t_dwError
                    ) )
                {
                    pInstance->SetDWORD ( IDS_DomainRole , t_MachineRole ) ;
                }
            }
        }
   }
   
   GetOEMInfo ( pInstance ) ;
   t_hr = GetStartupOptions ( pInstance ) ;
   return t_hr ;
}
#endif
////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::GetStartupOptions
*
*  DESCRIPTION : Reads boot.ini to find startup options
*
*  INPUTS      : pInstance to store data in
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CWin32ComputerSystem::GetStartupOptions(CInstance *pInstance)
{
    SAFEARRAY *saNames = NULL ;
    SAFEARRAY *saDirs = NULL ;
    DWORD dwTimeout = 0;
    HRESULT t_hrRetVal = WBEM_S_NO_ERROR ;
    //    CHString strName;
    CHString strDir;

//#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)

    CNVRam nvram;
    CNVRam::InitReturns nvRet;

    if ( nvram.IsEfi () )
    {

        // EFI implementation
        
        nvRet = nvram.Init();
        
        if ( nvRet != CNVRam::Success )
        {
            SetSinglePrivilegeStatusObject(pInstance->GetMethodContext(), SE_SYSTEM_ENVIRONMENT_NAME ) ;
            return t_hrRetVal ;
        }

        // On EFI it's always the first setting: 0
        pInstance->SetByte ( IDS_SystemStartupSetting , 0 ) ;

        DWORD dwCount ;
        BOOL ok = nvram.GetBootOptions ( & saNames, & dwTimeout, &dwCount ) ;
        if ( ! ok )
        {
            return t_hrRetVal ;
        }

        if ( dwCount != 0 )
        {
            variant_t vValue ;
            
            // Move the array to a variant
            V_VT(&vValue) = VT_BSTR | VT_ARRAY ;
            V_ARRAY(&vValue) = saNames ;
            
            // Send it off
            pInstance->SetVariant ( IDS_SystemStartupOptions , vValue ) ;
        }
        
        pInstance->SetDWORD ( IDS_SystemStartupDelay , dwTimeout ) ;

        return t_hrRetVal ;
    }
#endif // defined(EFI_NVRAM_ENABLED)

#if defined(_AMD64_) || defined(_X86_)
    
    // Since the boot drive isn't always C, we have to find out where boot.ini lives
    
    CRegistry RegInfo ;
    
    RegInfo.Open (
        
        HKEY_LOCAL_MACHINE,
        IDS_RegCurrentNTVersionSetup,
        KEY_READ
        ) ;
    
    CHString sTemp ;
    
    if ( RegInfo.GetCurrentKeyValue ( IDS_RegBootDirKey , sTemp ) == ERROR_SUCCESS )
    {
        sTemp += IDS_BootIni;
    }
    else
    {
        sTemp = IDS_CBootIni ;
    }
    
    // See if there is a boot.ini (we might be on w95 which may or may not have this file).
    
    HANDLE hFile = CreateFile (
        
        TOBSTRT(sTemp),
        GENERIC_READ,
        FILE_SHARE_WRITE | FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_NO_BUFFERING,
        NULL
        ) ;
    
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        return t_hrRetVal ;
    }
    
    CloseHandle ( hFile ) ;
    
    // Load the operating systems into an array
    
    
    
    DWORD dwCount = LoadOperatingSystems ( TOBSTRT ( sTemp ) , & saNames , & saDirs ) ;
    if ( dwCount )
    {
        try
        {
            // Now, find the default boot option.  Note that the default entry only specifies the boot directory.
            // If there are three boot options that all start from the same directory but have different options,
            // the booter will pick the first one in that list.
            
            TCHAR *szDefault = GetAllocatedProfileString ( IDT_BootLoader , IDT_Default , sTemp ) ;
            
            try
            {
                // Scan for the default os
                
                for ( DWORD x = 0; x < dwCount; x ++ )
                {
                    long ix [ 1 ] ;
                    
                    // Get the name
                    
                    ix [ 0 ] = x ;
                    
                    BSTR bstrName;
                    SafeArrayGetElement ( saDirs , ix , & bstrName ) ;
                    
                    // Do the compare
                    
                    try
                    {
                        if ( lstrcmpi ( TOBSTRT(bstrName), szDefault ) == 0 )
                        {
                            // We found it, set the property
                            pInstance->SetByte ( IDS_SystemStartupSetting , x ) ;
                            
                            SysFreeString(bstrName);
                            // Only the first match counts
                            break;
                        }
                    }
                    catch ( ... )
                    {
                        SysFreeString(bstrName);
                        throw;
                    }
                    
                    SysFreeString(bstrName);
                }
            }
            catch ( ... )
            {
                delete [] szDefault ;
                
                throw ;
            }
            
            delete [] szDefault ;
            
            variant_t vValue ;
            
            // Move the array to a variant
            
            V_VT(&vValue) = VT_BSTR | VT_ARRAY ;
            V_ARRAY(&vValue) = saNames ;
            saNames = NULL ;
            
            // Send it off, free the variant
            
            pInstance->SetVariant ( IDS_SystemStartupOptions , vValue ) ;
            
        }
        catch ( ... )
        {
            if ( saDirs )
            {
                SafeArrayDestroy ( saDirs ) ;
            }
            
            if ( saNames )
            {
                SafeArrayDestroy ( saNames ) ;
            }
            
            throw ;
        }
        
        if ( saDirs )
        {
            SafeArrayDestroy ( saDirs ) ;
            saDirs = NULL ;
        }
    }
    
    // Read the default time
    dwTimeout = WMI_FILE_GetPrivateProfileIntW ( IDT_BootLoader , IDT_Timeout , -1 , sTemp ) ;
    if (dwTimeout != -1)
    {
        pInstance->SetDWORD ( IDS_SystemStartupDelay , dwTimeout ) ;
    }
    
#else
    
    // On Alpha it's always the first setting: 0
    pInstance->SetByte ( IDS_SystemStartupSetting , 0 ) ;
    
    DWORD dwCount = LoadOperatingSystems ( _T(""), & saNames , & saDirs ) ;
    if ( dwCount )
    {
        SafeArrayDestroy ( saDirs ) ;
        
        variant_t vValue ;
        
        // Move the array to a variant
        V_VT(&vValue) = VT_BSTR | VT_ARRAY ;
        V_ARRAY(&vValue) = saNames ;
        
        // Send it off
        pInstance->SetVariant ( IDS_SystemStartupOptions , vValue ) ;
    }
    
    nvRet = nvram.Init();
    
    if ( nvRet == CNVRam::Success )
    {
        if ( nvram.GetNVRamVar ( L"COUNTDOWN" , & dwTimeout ) )
        {
            pInstance->SetDWORD ( IDS_SystemStartupDelay , dwTimeout ) ;
        }
    }
    else
    {
        SetSinglePrivilegeStatusObject(pInstance->GetMethodContext(), SE_SYSTEM_ENVIRONMENT_NAME ) ;
        t_hrRetVal = WBEM_S_PARTIAL_RESULTS ;
    }
    
#endif
    return t_hrRetVal ;
}

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::GetOEMInfo
*
*  DESCRIPTION : Reads OEMINFO.INI for oem info
*
*  INPUTS      : pInstance to store data in
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/
void CWin32ComputerSystem :: GetOEMInfo (
                                         
                                         CInstance *pInstance
                                         )
{
    TCHAR szSystemDirectory[_MAX_PATH +1] = _T("");
    TCHAR szOEMFile[_MAX_PATH +1] = _T("");
    TCHAR szBuff[256] = _T("");
    TCHAR szLine[4+MAXITOA] = _T("");
    DWORD dwIndex, dwBytesRead;
    void *pVoid;
    long ix[1];
    bstr_t bstrTemp;
    HRESULT t_Result;
    
    // Find the system directory (where oeminfo.ini and oemlogo.bmp live)
    
    UINT uRet = GetSystemDirectory ( szSystemDirectory , sizeof ( szSystemDirectory ) / sizeof(TCHAR) ) ;
    if ( ( uRet > _MAX_PATH ) || ( uRet == 0 ) )
    {
        return; // shouldn't ever happen, but hey...
    }
    
    if ( szSystemDirectory [ lstrlen ( szSystemDirectory ) - 1 ] != TEXT('\\') )
    {
        lstrcat ( szSystemDirectory , TEXT("\\") ) ;
    }
    
    // Build the file name
    lstrcpy ( szOEMFile , szSystemDirectory ) ;
    lstrcat ( szOEMFile , IDT_OEMInfoIni ) ;
    
    // Get the manufacturer name
    if ( pInstance->IsNull ( L"Manufacturer" ) )
    {
        if ( WMI_FILE_GetPrivateProfileStringW (
            TEXT("General") ,
            TEXT("Manufacturer") ,
            _T("") ,
            szBuff ,
            sizeof ( szBuff ) / sizeof(TCHAR) ,
            szOEMFile )
            )
        {
            pInstance->SetCharSplat ( L"Manufacturer" , szBuff ) ;
        }
    }
    
    // Get the model name
    if ( pInstance->IsNull ( IDS_Model ) )
    {
        if ( WMI_FILE_GetPrivateProfileStringW (
            IDT_General ,
            IDT_Model ,
            _T("") ,
            szBuff ,
            sizeof ( szBuff ) / sizeof(TCHAR) ,
            szOEMFile )
            )
        {
            pInstance->SetCharSplat ( IDS_Model, szBuff ) ;
        }
    }
    
    // Create a safearray for the Support information
    
    SAFEARRAYBOUND rgsabound[1] ;
    
    rgsabound[0].cElements = 0 ;
    rgsabound[0].lLbound = 0 ;
    variant_t vValue;
    
    V_ARRAY(&vValue) = SafeArrayCreate ( VT_BSTR , 1 , rgsabound ) ;
    if ( V_ARRAY(&vValue) )
    {
        V_VT(&vValue) = VT_BSTR | VT_ARRAY;
        // Support information is stored with one entry per line ie:
        
        // Line1=For product support, contact the manufacturer of your PC.
        // Line2=Refer to the documentation that came with your PC for the product
        
        // We are done when getting the string for lineX fails.
        
        dwIndex = 1;
        lstrcpy(szLine, IDT_Line);
        lstrcat(szLine, _itot(dwIndex, szBuff, 10));
        
        while ( ( WMI_FILE_GetPrivateProfileStringW ( IDT_SupportInformation,
            szLine,
            _T("@"),
            szBuff,
            sizeof(szBuff) / sizeof(TCHAR),
            szOEMFile)) > 1 || (szBuff[0] != '@')
            )
        {
            // Resize the array
            
            ix[0] = rgsabound[0].cElements ;
            rgsabound[0].cElements += 1 ;
            
            t_Result = SafeArrayRedim ( V_ARRAY(&vValue), rgsabound ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            // Add the new element
            bstrTemp = szBuff ;
            t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , (wchar_t*)bstrTemp ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            // Reset for next loop
            lstrcpy ( szLine , IDT_Line ) ;
            lstrcat ( szLine , _itot ( ++ dwIndex , szBuff , 10 ) ) ;
        }
        
        // If we found anything
        
        if ( dwIndex > 1 )
        {
            pInstance->SetVariant ( IDS_SupportContactDescription , vValue ) ;
        }
        
        vValue.Clear();
    }
    else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }
    
    // Build the path for the logo file
    
    lstrcpy ( szOEMFile , szSystemDirectory ) ;
    lstrcat ( szOEMFile , IDT_OemLogoBmp ) ;
    
    // Attempt to open it
    SmartCloseHandle hFile = CreateFile (
        
        szOEMFile,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
        NULL
        );
    
    if ( hFile != INVALID_HANDLE_VALUE )
    {
        // I ignore the upper dword since safearraycreate can't handle it anyway.  Shouldn't
        // be a problem unless we get 2 gig bmp files.
        
        rgsabound[0].cElements = GetFileSize ( hFile , NULL ) ;
        rgsabound[0].lLbound = 0 ;
        
        V_ARRAY(&vValue) = SafeArrayCreate ( VT_UI1 , 1 , rgsabound ) ;
        if ( V_ARRAY(&vValue) )
        {
            V_VT(&vValue) = VT_UI1 | VT_ARRAY;
            
            // Get a pointer to read the data into
            
            SafeArrayAccessData ( V_ARRAY(&vValue) , & pVoid ) ;
            try
            {
                ReadFile ( hFile , pVoid , rgsabound[0].cElements, &dwBytesRead, NULL ) ;
            }
            catch ( ... )
            {
                SafeArrayUnaccessData ( V_ARRAY(&vValue) ) ;
                
                throw ;
            }
            
            SafeArrayUnaccessData ( V_ARRAY(&vValue) ) ;
            
            pInstance->SetVariant(IDS_OEMLogoBitmap, vValue);
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
}

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::LoadOperatingSystems
*
*  DESCRIPTION : Parses and loads the operating systems
*
*  INPUTS      : fully qualified ini file name, pointers to names and dirs sa
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/

DWORD CWin32ComputerSystem :: LoadOperatingSystems (
                                                    
                                                    LPCTSTR szIniFile,
                                                    SAFEARRAY **ppsaNames,
                                                    SAFEARRAY **ppsaDirs
                                                    )
{
    CHString strName,strDir,strSwap;

#if defined(_AMD64_) || defined(_X86_)
    
    *ppsaNames = NULL ;
    *ppsaDirs = NULL ;
    
    // Grab the whole section of boot options
    
    DWORD dwRet = 0 ;
    TCHAR *szOptions = GetAllocatedProfileSection ( IDT_OperatingSystems , szIniFile , &dwRet ) ;
    
    SAFEARRAYBOUND rgsabound[1] ;
    rgsabound[0].cElements = 0 ;
    rgsabound[0].lLbound = 0 ;
    
    try
    {
        // Create an array to put them in.  We'll start with 0 elements and add as necessary.
        
        *ppsaNames = SafeArrayCreate ( VT_BSTR , 1 , rgsabound ) ;
        if ( ! *ppsaNames )
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        
        *ppsaDirs = SafeArrayCreate ( VT_BSTR , 1 , rgsabound ) ;
        if ( ! *ppsaDirs )
        {
            SafeArrayDestroy ( *ppsaNames ) ;
            
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        
        try
        {
            // Start walking the returned string
            
            DWORD dwIndex = 0 ;
            while ( dwIndex < dwRet )
            {
                // Trim leading spaces
                
                while (szOptions[dwIndex] == ' ')
                {
                    dwIndex ++;
                }
                
                // Skip comment lines
                
                if ( szOptions[dwIndex] == ';' )
                {
                    do {
                        
                        dwIndex++;
                        
                    } while ( szOptions [ dwIndex ] != '\0' ) ;
                    
                }
                else
                {
                    // pChar will point at the directory
                    
                    TCHAR *pChar = &szOptions[dwIndex];
                    
                    do {
                        
                        dwIndex++;
                        
                    } while ( ( szOptions [ dwIndex ] != '=' ) && ( szOptions [ dwIndex ] != '\0') ) ;
                    
                    // We must have an = sign or this is an invalid string
                    
                    if ( szOptions [ dwIndex ] == '=' )
                    {
                        // Punch in a null
                        
                        szOptions[dwIndex++] = '\0';
                        
                        // Increase the number of elements
                        
                        long ix[1];
                        
                        ix[0] = rgsabound[0].cElements;
                        rgsabound[0].cElements += 1;
                        
                        HRESULT t_Result = SafeArrayRedim ( *ppsaNames , rgsabound ) ;
                        if ( t_Result == E_OUTOFMEMORY )
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                        
                        t_Result = SafeArrayRedim ( *ppsaDirs , rgsabound ) ;
                        if ( t_Result == E_OUTOFMEMORY )
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                        
                        // Put the new element in
                        
                        bstr_t bstrTemp = &szOptions [ dwIndex ];
                        t_Result = SafeArrayPutElement ( *ppsaNames , ix , (wchar_t*)bstrTemp ) ;
                        if ( t_Result == E_OUTOFMEMORY )
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                        
                        bstrTemp = pChar;
                        t_Result = SafeArrayPutElement ( *ppsaDirs , ix , (wchar_t*)bstrTemp ) ;
                        if ( t_Result == E_OUTOFMEMORY )
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                        
                        // Find the end of this string
                        
                        while ( szOptions [ dwIndex ] != '\0' )
                        {
                            dwIndex ++ ;
                        }
                    }
                }
                
                // Move to the start of the next string
                dwIndex++ ;
            }
        }
        catch ( ... )
        {
            SafeArrayDestroy ( *ppsaNames ) ;
            
            SafeArrayDestroy ( *ppsaDirs ) ;
            
            throw ;
        }
        
    }
    catch ( ... )
    {
        delete [] szOptions;
        
        throw ;
    }
    
    if ( szOptions != NULL )
    {
        delete [] szOptions;
    }
    
    return rgsabound[0].cElements ;
    
#else
    
    // RISC implementation
    
    *ppsaNames = NULL ;
    *ppsaDirs = NULL ;
    
    // Try to load the setupdll.dll functions.
    
    CHSTRINGLIST listNames ;
    CHSTRINGLIST listDirs ;
    
    CNVRam nvram;
    if ( nvram.Init () == CNVRam::PrivilegeNotHeld )
    {
        return 0 ;
    }
    
    BOOL t_Failure = !nvram.GetNVRamVar(L"LOADIDENTIFIER", &listNames) ||
        !nvram.GetNVRamVar(L"OSLOADPARTITION", &listDirs) ;
    
    if ( t_Failure )
    {
        return 0;
    }
    
    // Create an array to put them in.  We'll start with 0 elements and add as necessary.
    
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].cElements = min(listNames.size(), listDirs.size());
    rgsabound[0].lLbound = 0;
    
    try
    {
        *ppsaNames = SafeArrayCreate ( VT_BSTR , 1 , rgsabound ) ;
        if ( ! *ppsaNames )
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        
        *ppsaDirs = SafeArrayCreate ( VT_BSTR , 1 , rgsabound ) ;
        if ( ! *ppsaDirs )
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        
        CHSTRINGLIST_ITERATOR iterNames ;
        CHSTRINGLIST_ITERATOR iterDirs ;
        
        long lIndex[1] = {0};
        
        for (iterNames = listNames.begin(), iterDirs = listDirs.begin();
        iterNames != listNames.end() && iterDirs != listDirs.end();
        ++iterNames, ++iterDirs, lIndex[0]++)
        {
            strName = *iterNames,
                strDir = *iterDirs;
            
            // Put the new element in
            
            bstr_t bstrTemp = (LPCWSTR)strName;
            HRESULT t_Result = SafeArrayPutElement ( *ppsaNames , lIndex , (void *) (wchar_t*)bstrTemp ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                SysFreeString ( bstrTemp ) ;
                
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            SysFreeString(bstrTemp);
            
            bstrTemp = (LPCWSTR)strDir;
            t_Result = SafeArrayPutElement ( *ppsaDirs , lIndex , (void *) (wchar_t*)bstrTemp ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                SysFreeString ( bstrTemp ) ;
                
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            SysFreeString(bstrTemp);
        }
    }
    catch ( ... )
    {
        if ( *ppsaNames )
        {
            SafeArrayDestroy ( *ppsaNames ) ;
        }
        
        if ( *ppsaDirs )
        {
            SafeArrayDestroy ( *ppsaDirs ) ;
        }
        
        throw ;
    }
    
    return rgsabound[0].cElements ;
    
#endif
}


/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::PutInstance
*
*  DESCRIPTION : Write changed instance
*
*  INPUTS      : pInstance to store data from
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/

HRESULT CWin32ComputerSystem :: PutInstance (
                                             
                                             const CInstance &pInstance,
                                             long lFlags /*= 0L*/
                                             )
{
    // Tell the user we can't create a new computersystem (much as we might like to)
    if ( lFlags & WBEM_FLAG_CREATE_ONLY )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }
    
    HRESULT hRet = WBEM_S_NO_ERROR ;
    
    // Make sure we are looking at a good instance.  Get the name from the instance...
    
    CHString sName;
    pInstance.GetCHString ( IDS_Name , sName ) ;
    
    DWORD dwTimeout ;
    
    // Check for the correct computer name
    
    if ( sName.CompareNoCase ( GetLocalComputerName () ) != 0 )
    {
        if ( lFlags & WBEM_FLAG_UPDATE_ONLY )
        {
            hRet = WBEM_E_NOT_FOUND ;
        }
        else
        {
            hRet = WBEM_E_PROVIDER_NOT_CAPABLE ;
        }
    }
    else
    {
#ifdef NTONLY
        // update AutomaticResetBootOption
        if( !pInstance.IsNull( IDS_AutomaticResetBootOption ) )
        {
            bool t_bReset ;
            pInstance.Getbool(IDS_AutomaticResetBootOption, t_bReset ) ;
            
            CRegistry t_RegInfo ;
            
            DWORD t_dwRet = t_RegInfo.CreateOpen (
                
                HKEY_LOCAL_MACHINE,
                IDS_RegCrashControl
                ) ;
            
            if ( ERROR_SUCCESS == t_dwRet )
            {
                DWORD t_dwReset = t_bReset ;
                DWORD t_dwTmp = ERROR_SUCCESS;
                if( ( t_dwTmp = t_RegInfo.SetCurrentKeyValue(IDS_RegAutoRebootKey, t_dwReset) ) == ERROR_SUCCESS )
                {
                    hRet = WBEM_S_NO_ERROR ;
                }
                else
                {
                    hRet = WinErrorToWBEMhResult(t_dwTmp) ;
                }
                
                t_RegInfo.Close();
            }
            else
            {
                hRet = WinErrorToWBEMhResult(t_dwRet) ;
            }
            
            if( WBEM_S_NO_ERROR != hRet )
            {
                return hRet ;
            }
        }
#endif
        
#ifdef NTONLY
        // set roles
        if( !pInstance.IsNull( IDS_Roles ) )
        {
            DWORD t_dwRoles = 0 ;
            
            hRet = GetRoles( pInstance, &t_dwRoles ) ;
            
            if( WBEM_S_NO_ERROR == hRet )
            {
                CNetAPI32 NetAPI;
                
                if ( NetAPI.Init () == ERROR_SUCCESS )
                {
                    PSERVER_INFO_101 t_ps = NULL;
                    
                    NET_API_STATUS stat = NetAPI.NetServerGetInfo ( NULL , 101 , (LPBYTE *)&t_ps ) ;
                    
                    if ( stat == NERR_Success && t_ps )
                    {
                        try
                        {
                            DWORD t_dwParmError = 0 ;
                            
                            t_ps->sv101_type = t_dwRoles ;
                            
                            stat = NetAPI.NetServerSetInfo ( NULL , 101 , (LPBYTE)t_ps, &t_dwParmError ) ;
                            
                            if ( stat != NERR_Success )
                            {
                                hRet = WBEM_E_ACCESS_DENIED ;
                            }
                        }
                        catch( ... )
                        {
                            NetAPI.NetApiBufferFree ( t_ps ) ;
                            throw ;
                        }
                        NetAPI.NetApiBufferFree ( t_ps ) ;
                    }
                    else
                    {
                        hRet = WBEM_E_ACCESS_DENIED ;
                    }
                }
                else
                {
                    hRet = WBEM_E_ACCESS_DENIED ;
                }
            }
            
            if( WBEM_S_NO_ERROR != hRet )
            {
                return hRet ;
            }
        }
#endif
        
        // Set CurrentTimeZone if presented
        hRet = SetTimeZoneInfo( pInstance ) ;
        
        if( WBEM_S_NO_ERROR != hRet )
        {
            return hRet ;
        }
        
#if defined(_AMD64_) || defined(_X86_)
        
        // Since the boot drive isn't always C, we have to find out where boot.ini lives
        
        CRegistry RegInfo ;
        
        RegInfo.Open ( HKEY_LOCAL_MACHINE , IDS_RegCurrentNTVersionSetup , KEY_READ ) ;
        
        CHString sTemp ;
        
        if ( RegInfo.GetCurrentKeyValue ( IDS_RegBootDirKey , sTemp ) == ERROR_SUCCESS )
        {
            sTemp += IDS_BootIni ;
        }
        else
        {
            sTemp = IDS_CBootIni ;
        }
        
        // See if there is a boot.ini (we might be on w95 which may or may not have this file).
        bool fBootIniExists = false;
        {
            SmartCloseHandle hFile;
        
            // Limit the time the file is open...
            {
                hFile = CreateFile (
            
                    TOBSTRT(sTemp),
                    GENERIC_READ,
                    FILE_SHARE_WRITE | FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_NO_BUFFERING,
                    NULL
                    ) ;

                if(hFile != INVALID_HANDLE_VALUE)
                {
                    fBootIniExists = true;
                }
            }
        }

        if(fBootIniExists)
        {
            // Update the startup options if supplied
            // by the PutInstance caller...
            if(UpdatingSystemStartupOptions(pInstance))
            {
                hRet = UpdateSystemStartupOptions(
                    pInstance,
                    sTemp);
            }
            
            // If a value was specified for StartupDelay
            
            if ( ! pInstance.IsNull ( IDS_SystemStartupDelay ) )
            {
                // Write it out.
                
                pInstance.GetDWORD ( IDS_SystemStartupDelay , dwTimeout ) ;
                
                if ( SetFileAttributes ( TOBSTRT ( sTemp ) , FILE_ATTRIBUTE_NORMAL ) )
                {
                    TCHAR szBuff [ MAXITOA ] ;
                    
                    WMI_FILE_WritePrivateProfileStringW ( IDT_BootLoader , IDT_Timeout, _itot( dwTimeout, szBuff, 10 ), TOBSTRT ( sTemp ) ) ;                    
                    SetFileAttributes ( TOBSTRT ( sTemp ) , FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY ) ;
                }
                else
                {
                    hRet = WBEM_E_ACCESS_DENIED ;
                }
            }
            
            // If a value was specified for StartupSetting
            
            if ( ! pInstance.IsNull ( IDS_SystemStartupSetting ) )
            {
                
                BSTR bstrDefaultDir ;
                BSTR bstrDefaultName ;
                BSTR bstrName ;
                BSTR bstrDir;
                
                // This becomes something of a mess.  Since the only thing you specify in the 'default' key
                // is the path, how do you make sure that the options that you want (which are part of the name
                // portion) get chosen?  The answer is that they re-shuffle the entries in the boot.ini so that
                // the line you want comes first.
                
                BYTE btIndex = 0 ;
                pInstance.GetByte ( IDS_SystemStartupSetting , btIndex ) ;
                
                DWORD dwIndex = btIndex ;
                
                SAFEARRAY *saNames = NULL;
                SAFEARRAY *saDirs = NULL;
                
                DWORD dwCount = LoadOperatingSystems ( TOBSTRT ( sTemp ) , & saNames , & saDirs ) ;
                try
                {
                    if ( dwIndex + 1 <= dwCount )
                    {
                        long ix[1];
                        
                        ix [ 0 ] = dwIndex ;
                        SafeArrayGetElement ( saDirs , ix , & bstrDefaultDir ) ;
                        SafeArrayGetElement ( saNames , ix , & bstrDefaultName ) ;
                        
                        // Pull everything down on top of the entry to become the default
                        
                        for ( int x = dwIndex ; x > 0 ; x -- )
                        {
                            ix[0] = x-1 ;
                            SafeArrayGetElement ( saDirs , ix , & bstrDir ) ;
                            SafeArrayGetElement ( saNames , ix , & bstrName ) ;
                            
                            ix[0] = x ;
                            SafeArrayPutElement ( saDirs , ix , bstrDir );
                            SafeArrayPutElement ( saNames , ix , bstrName ) ;
                        }
                        
                        // Write the new one on top
                        
                        if ( dwIndex > 0 )
                        {
                            ix[0] = 0 ;
                            SafeArrayPutElement ( saNames , ix , bstrDefaultName ) ;
                            SafeArrayPutElement ( saDirs , ix , bstrDefaultDir ) ;
                        }
                        
                        // Build up the section to write to the ini file.  Ini file sections are written
                        // as 'dir'='name'\0 with a final \0 at the end.
                        
                        CHString sSection ;
                        
                        sSection.Empty();
                        
                        for (x=0; x < dwCount; x++)
                        {
                            ix[0] = x;
                            SafeArrayGetElement ( saDirs , ix , & bstrDir ) ;
                            
                            sSection += bstrDir ;
                            sSection += _T('=') ;
                            
                            SafeArrayGetElement ( saNames , ix , & bstrName ) ;
                            sSection += bstrName ;
                            sSection += _T('\0');
                        }
                        
                        sSection += _T('\0') ;
                        
                        // Make the file writable
                        
                        if ( SetFileAttributes ( TOBSTRT ( sTemp ) , FILE_ATTRIBUTE_NORMAL ) )
                        {
                            // Write the changes
                            
                            WMI_FILE_WritePrivateProfileStringW ( IDT_BootLoader , IDT_Default , TOBSTRT( bstrDefaultDir ) , TOBSTRT ( sTemp ) ) ;
                            WMI_FILE_WritePrivateProfileSectionW ( IDT_OperatingSystems , TOBSTRT ( sSection ) , TOBSTRT ( sTemp ) ) ;
                            
                            // Put it back
                            SetFileAttributes ( TOBSTRT ( sTemp ) , FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY ) ;
                        }
                        else
                        {
                            hRet = WBEM_E_ACCESS_DENIED;
                        }
                        
                    }
                    else
                    {
                        hRet = WBEM_E_VALUE_OUT_OF_RANGE ;
                    }
                }
                catch ( ... )
                {
                    if ( saDirs )
                    {
                        SafeArrayDestroy ( saDirs ) ;
                    }
                    
                    if ( saNames )
                    {
                        SafeArrayDestroy ( saNames ) ;
                    }
                    
                    throw ;
                }
                
                if ( saDirs )
                {
                    SafeArrayDestroy ( saDirs ) ;
                }
                
                if ( saNames )
                {
                    SafeArrayDestroy ( saNames ) ;
                }
            }
        }

#else //defined(_AMD64_) || defined(_X86_)

    CNVRam nvram;

//#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)

//
// ChuckL (1/24/01):
// This code will have to be restructured when x86 EFI support is added.
// I would have liked to have put this at the top of the routine, and I
// did in GetStartupOptions(), but, for x86 only, this routine also changes
// a bunch of other stuff that it doesn't change on non-x86, so it wasn't
// easy to put the EFI stuff at the top. I'm not sure why all that extra
// stuff is x86-only. Seems to me like it's not platform-specific.
//

		if (nvram.IsEfi()) {

			if ( pInstance.IsNull ( IDS_SystemStartupDelay ) &&
				 pInstance.IsNull ( IDS_SystemStartupSetting ) )
			{
				return WBEM_S_NO_ERROR;
			}

			if ( nvram.Init () == CNVRam::PrivilegeNotHeld )
			{
				SetSinglePrivilegeStatusObject ( pInstance.GetMethodContext(), _bstr_t ( SE_SYSTEM_ENVIRONMENT_NAME ) ) ;
				return WBEM_E_PRIVILEGE_NOT_HELD ;
			}
        
			if ( ! pInstance.IsNull ( IDS_SystemStartupDelay ) )
			{
				DWORD dwTimeout ;
            
				// Write it out.
				pInstance.GetDWORD ( IDS_SystemStartupDelay , dwTimeout ) ;
				nvram.SetBootTimeout ( dwTimeout ) ;
			}

			if ( ! pInstance.IsNull ( IDS_SystemStartupSetting ) )
			{
				BYTE cIndex;

				pInstance.GetByte ( IDS_SystemStartupSetting , cIndex ) ;
				nvram.SetDefaultBootEntry ( cIndex ) ;
			}
        
			return WBEM_S_NO_ERROR;
		}

#endif // defined(EFI_NVRAM_ENABLED)

		WCHAR *pszVarNames[6] = {
        
			L"LOADIDENTIFIER" ,
				L"SYSTEMPARTITION" ,
				L"OSLOADER" ,
				L"OSLOADPARTITION" ,
				L"OSLOADFILENAME" ,
				L"OSLOADOPTIONS"
		} ;
    
		if ( nvram.Init () == CNVRam::PrivilegeNotHeld )
		{
			SetSinglePrivilegeStatusObject ( pInstance.GetMethodContext(), _bstr_t ( SE_SYSTEM_ENVIRONMENT_NAME ) ) ;
			return WBEM_E_PRIVILEGE_NOT_HELD ;
		}
    
		// Set the startup delay.
		if ( ! pInstance.IsNull ( IDS_SystemStartupDelay ) )
		{
			DWORD dwTimeout ;
        
			// Write it out.
			pInstance.GetDWORD ( IDS_SystemStartupDelay , dwTimeout ) ;
			nvram.SetNVRamVar ( L"COUNTDOWN" , dwTimeout ) ;
		}
    
		// Set the desired OS configuration.
		if ( pInstance.IsNull ( IDS_SystemStartupSetting ) )
		{
			return WBEM_S_NO_ERROR ;
		}
    
		// If the first config is still desired, just leave.
    
		BYTE cIndex;
		pInstance.GetByte ( IDS_SystemStartupSetting , cIndex ) ;
		if ( cIndex == 0 )
		{
			return WBEM_S_NO_ERROR;
		}
     
		// Switch all items[cIndex] with items[0] so the desired item is at the
		// top.
    
		for ( int i = 0 ; i < 6 ; i++ )
		{
			CHSTRINGLIST listValues;
        
			if ( ! nvram.GetNVRamVar ( pszVarNames [ i ] , &listValues ) )
			{
				continue;
			}
        
			// In case a number too large was chosen.  Only check the first item
			// since some of the others seem to live just fine with less.
        
			if ( i == 0 && listValues.size () <= cIndex )
			{
				hRet = WBEM_E_VALUE_OUT_OF_RANGE ;
				break ;
			}
        
			// Go through the list until we hit item iIndex == cIndex.  Then switch
			// it with 0 and write the values back into NVRam.
        
			int iIndex = 0;
			for (CHSTRINGLIST_ITERATOR iVal = listValues.begin(); iVal != listValues.end(); ++iVal, iIndex++)
			{
				if (iIndex == cIndex)
				{
					CHString &strVal0 = *listValues.begin() ;
					CHString &strValIndex = *iVal;
					CHString strSwap ;
                
					strSwap = strVal0;
					strVal0 = strValIndex;
					strValIndex = strSwap;
                
					break;
				}
			}
        
			nvram.SetNVRamVar ( pszVarNames [ i ] , & listValues ) ;
		}
        
#endif

    }
    
    return hRet;

}

void CWin32ComputerSystem::GetTimeZoneInfo ( CInstance *pInstance )
{
    TIME_ZONE_INFORMATION tzone ;
    
    DWORD dwRet = GetTimeZoneInformation ( & tzone ) ;
    
    if (TIME_ZONE_ID_INVALID == dwRet )
    {
        return;
    }
    
    if (dwRet == TIME_ZONE_ID_DAYLIGHT)
    {
        tzone.Bias += tzone.DaylightBias ;
    }
    else
    {
        // This is normally 0 but is non-zero in some timezones.
        tzone.Bias += tzone.StandardBias ;
    }
    
    pInstance->SetWBEMINT16 ( IDS_CurrentTimeZone , -1 * tzone.Bias ) ;
    
    //DaylightInEffect property is set to true if Daylight savings mode is on & false if standard time mode is on
    //DaylightInEffect property is NULL if zone has no daylight savings mode
    
    if ( dwRet != TIME_ZONE_ID_UNKNOWN )
    {
        if ( dwRet == TIME_ZONE_ID_DAYLIGHT )
        {
            pInstance->Setbool ( IDS_DaylightInEffect, TRUE ) ;
        }
        else
        {
            pInstance->Setbool ( IDS_DaylightInEffect, FALSE ) ;
        }
    }

    // Set the EnableDaylightSavingsTime propety
    CRegistry reg;
    CHString chstrTmp;

    if(reg.OpenLocalMachineKeyAndReadValue(
        REGKEY_TIMEZONE_INFO,
        REGVAL_TZNOAUTOTIME,
        chstrTmp) == ERROR_SUCCESS)
    {
        pInstance->Setbool(IDS_EnableDaylightSavingsTime, FALSE);
    }
    else
    {
        pInstance->Setbool(IDS_EnableDaylightSavingsTime, TRUE);
    }
}

//
HRESULT CWin32ComputerSystem::SetTimeZoneInfo ( const CInstance &a_rInstance )
{
    HRESULT t_Result = WBEM_S_NO_ERROR ;
    
    TIME_ZONE_INFORMATION t_TimeZone ;
    
    if( !a_rInstance.IsNull( IDS_CurrentTimeZone ) )
    {
        DWORD dwRet = GetTimeZoneInformation ( &t_TimeZone ) ;
        
        if( TIME_ZONE_ID_INVALID == dwRet )
        {
            t_Result =  WBEM_E_FAILED ;
        }
        else
        {
            short sTimeZoneBias = 0 ;
            
            a_rInstance.GetWBEMINT16( IDS_CurrentTimeZone , sTimeZoneBias ) ;

            // Got the value as a short, now need it as a long.  Can't just
            // get it directly into t_TimeZone.Bias in the GetWBEMINT16 call
            // as the sign digits will not be handled properly (that is, the
            // value of -420 (0x1A4) comes in as FE5C, not FFFFFE5C, so when we 
            // multiply this by -1, it becomes FFFF01A4, not 1A4).
            t_TimeZone.Bias = (LONG) sTimeZoneBias;
            
            t_TimeZone.Bias *= -1 ;
            
            if( dwRet == TIME_ZONE_ID_DAYLIGHT )
            {
                t_TimeZone.Bias -= t_TimeZone.DaylightBias ;
            }
            else
            {
                // This is normally 0 but is non-zero in some timezones.
                t_TimeZone.Bias -= t_TimeZone.StandardBias ;
            }
            
            BOOL t_status = SetTimeZoneInformation( &t_TimeZone ) ;
            
            if( !t_status )
            {
                t_Result = WBEM_E_FAILED ;
            }
        }
    }

    if(SUCCEEDED(t_Result))
    {
        if(!a_rInstance.IsNull(IDS_EnableDaylightSavingsTime))
        {
            bool fEnableDaylightAutoAdj;
            if(a_rInstance.Getbool(
                IDS_EnableDaylightSavingsTime,
                fEnableDaylightAutoAdj))
            {
                CRegistry reg;
                CHString chstrTmp;

                if(fEnableDaylightAutoAdj)
                {
                    // they want to enable auto daylight
                    // adjustment, so remove the reg key
                    // that disables auto adjustment.
                    if(reg.Open(
                        HKEY_LOCAL_MACHINE,
                        REGKEY_TIMEZONE_INFO,
                        KEY_SET_VALUE) == ERROR_SUCCESS)
                    {
                        LONG lRes = reg.DeleteValue(REGVAL_TZNOAUTOTIME);
                        // If failed to delete due to error other
                        // than no such key (which is fine),
                        // return an error.
                        if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND)
                        {
                            t_Result = WBEM_E_FAILED;
                        }
                    }
                    else
                    {
                        t_Result = WBEM_E_FAILED;
                    }
                }
                else
                {
                    // they want to disable auto adjustment
                    // so add the registry key to disable auto
                    // daylight adjustment if it isn't already there.
                    if(reg.OpenLocalMachineKeyAndReadValue(
                        REGKEY_TIMEZONE_INFO,
                        REGVAL_TZNOAUTOTIME,
                        chstrTmp) == ERROR_SUCCESS)
                    {
                        // key is present, so do nothing
                    }
                    else
                    {
                        // add the value to disable auto adjustment.
                        if(reg.Open(
                            HKEY_LOCAL_MACHINE,
                            REGKEY_TIMEZONE_INFO,
                            KEY_SET_VALUE) == ERROR_SUCCESS)
                        {
                            DWORD dwVal = 1L;
                            if(reg.SetCurrentKeyValue(
                                REGVAL_TZNOAUTOTIME,
                                dwVal) != ERROR_SUCCESS)
                            {
                                t_Result = WBEM_E_FAILED;
                            }
                        }
                        else
                        {
                            t_Result = WBEM_E_FAILED;
                        }
                    }
                }
            }
            else
            {
                t_Result = WBEM_E_FAILED;
            }
        }
    }

    return t_Result ;
}

void CWin32ComputerSystem :: SetRoles (
                                       
                                       CInstance *pInstance,
                                       DWORD dwType
                                       )
{
    variant_t vValue;
    
    // Create a safearray for the Roles information.  Make it overlarge and
    // size it down later.
    
    SAFEARRAYBOUND rgsabound [ 1 ] ;
    
    rgsabound [ 0 ].cElements = 30 ;
    rgsabound [ 0 ].lLbound = 0 ;
    
    V_ARRAY(&vValue) = SafeArrayCreate ( VT_BSTR , 1 , rgsabound ) ;
    if ( V_ARRAY(&vValue) )
    {
        V_VT(&vValue) = VT_ARRAY | VT_BSTR;
        
        long ix [ 1 ] ;
        ix [ 0 ] = 0 ;
        
        // Check each of the bits, and add to the safearray if set
        
        if ( dwType & SV_TYPE_WORKSTATION )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix,  ( wchar_t * ) bstr_t ( IDS_LM_Workstation ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_SERVER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix ,  ( wchar_t * ) bstr_t ( IDS_LM_Server ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_SQLSERVER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix ,  ( wchar_t * ) bstr_t ( IDS_SQLServer ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_DOMAIN_CTRL )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Domain_Controller ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_DOMAIN_BAKCTRL )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Domain_Backup_Controller )  ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix[0] ++;
        }
        
        if ( dwType & SV_TYPE_TIME_SOURCE )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Timesource ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix[0] ++;
        }
        
        if ( dwType & SV_TYPE_AFP )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_AFP ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_NOVELL )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Novell ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix[0] ++;
        }
        
        if ( dwType & SV_TYPE_DOMAIN_MEMBER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Domain_Member ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_LOCAL_LIST_ONLY )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Local_List_Only ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_PRINTQ_SERVER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Print ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_DIALIN_SERVER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_DialIn ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix[0] ++;
        }
        
        if (dwType & SV_TYPE_XENIX_SERVER)
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Xenix_Server ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_SERVER_MFPN )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_MFPN ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_NT )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_NT ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_WFW )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_WFW ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_SERVER_NT )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Server_NT ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_POTENTIAL_BROWSER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Potential_Browser ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_BACKUP_BROWSER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Backup_Browser ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_MASTER_BROWSER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Master_Browser ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_DOMAIN_MASTER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Domain_Master ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix[0] ++;
        }
        
        if ( dwType & SV_TYPE_DOMAIN_ENUM )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Domain_Enum ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_WINDOWS )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Windows_9x ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_DFS )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_DFS ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        // Since the array is zero based, don't use ix[0]-1
        
        rgsabound [ 0 ].cElements = ix [ 0 ] ;
        HRESULT t_Result = SafeArrayRedim ( V_ARRAY(&vValue) , rgsabound ) ;
        if ( t_Result == E_OUTOFMEMORY )
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        
        // Set the property and be done
        
        pInstance->SetVariant ( IDS_Roles , vValue ) ;
    }
    
}

//
HRESULT CWin32ComputerSystem::GetRoles (
                                        
                                        const CInstance &a_rInstance,
                                        DWORD *a_pdwRoleType
                                        )
{
    HRESULT     t_hResult = WBEM_S_NO_ERROR ;
    LONG        t_uLBound = 0 ;
    LONG        t_uUBound = 0 ;
    variant_t   t_vRoles;
    
    a_rInstance.GetVariant ( IDS_Roles , t_vRoles ) ;
    
    if( !t_vRoles.parray || t_vRoles.vt != (VT_BSTR | VT_ARRAY) )
    {
        return WBEM_E_FAILED ;
    }
    
    SAFEARRAY *t_saRoles = t_vRoles.parray ;
    
    if( 1 != SafeArrayGetDim( t_saRoles ) )
    {
        return WBEM_E_FAILED;
    }
    
    // Get the IP bounds
    if( S_OK != SafeArrayGetLBound( t_saRoles, 1, &t_uLBound ) ||
        S_OK != SafeArrayGetUBound( t_saRoles, 1, &t_uUBound ) )
    {
        return WBEM_E_FAILED ;
    }
    
    if( !a_pdwRoleType )
    {
        return WBEM_E_FAILED ;
    }
    else
    {
        *a_pdwRoleType = 0 ;
    }
    
    //
    for( LONG t_ldx = t_uLBound; t_ldx <= t_uUBound; t_ldx++ )
    {
        BSTR t_bsRole = NULL ;
        
        SafeArrayGetElement( t_saRoles, &t_ldx, &t_bsRole  ) ;
        
        bstr_t t_bstrRole( t_bsRole, FALSE ) ;
        
        for( int t_i = 0; t_i < sizeof( g_SvRoles ) / sizeof( g_SvRoles[0] ); t_i++ )
        {
            if( t_bstrRole == bstr_t( g_SvRoles[ t_i ].pwStrRole ) )
            {
                *a_pdwRoleType |= g_SvRoles[ t_i ].dwRoleMask ;
                
                t_hResult = WBEM_S_NO_ERROR ;
                break ;
            }
        }
        if( WBEM_S_NO_ERROR != t_hResult )
        {
            t_hResult = WBEM_E_VALUE_OUT_OF_RANGE ;
            break ;
        }
    }
    
    return t_hResult ;
}

HRESULT CWin32ComputerSystem :: GetAccount ( HANDLE a_TokenHandle , CHString &a_Domain , CHString &a_User )
{
    HRESULT t_Status = S_OK ;
    
    TOKEN_USER *t_TokenUser = NULL ;
    DWORD t_ReturnLength = 0 ;
    TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;
    
    BOOL t_TokenStatus = GetTokenInformation (
        
        a_TokenHandle ,
        t_TokenInformationClass ,
        NULL ,
        0 ,
        & t_ReturnLength
        ) ;
    
    if ( ! t_TokenStatus && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
    {
        t_TokenUser = ( TOKEN_USER * ) new UCHAR [ t_ReturnLength ] ;
        if ( t_TokenUser )
        {
            try
            {
                t_TokenStatus = GetTokenInformation (
                    
                    a_TokenHandle ,
                    t_TokenInformationClass ,
                    ( void * ) t_TokenUser ,
                    t_ReturnLength ,
                    & t_ReturnLength
                    ) ;
                
                if ( t_TokenStatus )
                {
                    CSid t_Sid ( t_TokenUser->User.Sid ) ;
                    if ( t_Sid.IsOK () )
                    {
                        a_Domain = t_Sid.GetDomainName () ;
                        a_User = t_Sid.GetAccountName () ;
                    }
                    else
                    {
                        t_Status = WBEM_E_PROVIDER_FAILURE ;
                    }
                }
                else
                {
                    t_Status = WBEM_E_PROVIDER_FAILURE ;
                }
            }
            catch ( ... )
            {
                delete [] ( UCHAR * ) t_TokenUser ;
                
                throw ;
            }
            
            if ( t_TokenUser )
            {
                delete [] ( UCHAR * ) t_TokenUser ;
            }
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
    else
    {
        t_Status = WBEM_E_PROVIDER_FAILURE ;
    }
    
    return t_Status ;
}


HRESULT CWin32ComputerSystem :: GetUserAccount ( CHString &a_Domain , CHString &a_User )
{
    HRESULT t_Status = S_OK ;
    
#ifdef NTONLY
    SetLastError ( 0 ) ;
    
    SmartCloseHandle t_TokenHandle;
    
    //Access check is to be made against the security context of the process for the calling thread. This is because
    //it was observed that the call failed if the logged-in user is not an Admin and access check is made against the
    //impersonated thread.Also, this is safe since we're not carrying out any activity using this token.
    BOOL t_TokenStatus = OpenThreadToken (
        
        GetCurrentThread () ,
        TOKEN_QUERY ,
        TRUE ,
        & t_TokenHandle
        ) ;
    
    if ( t_TokenStatus )
    {
        t_Status = GetAccount ( t_TokenHandle , a_Domain , a_User );
    }
    else
    {
        t_Status = WBEM_E_PROVIDER_FAILURE ;
    }
    
#endif
    
   
    return t_Status ;
}

void CWin32ComputerSystem :: InitializePropertiestoUnknown ( CInstance *a_pInstance )
{
    a_pInstance->SetWBEMINT64( L"PauseAfterReset", (__int64) -1);
    a_pInstance->SetDWORD( L"PowerOnPasswordStatus", SM_BIOS_HARDWARE_SECURITY_UNKNOWN );
    a_pInstance->SetDWORD( L"KeyboardPasswordStatus", SM_BIOS_HARDWARE_SECURITY_UNKNOWN );
    a_pInstance->SetDWORD( L"AdminPasswordStatus", SM_BIOS_HARDWARE_SECURITY_UNKNOWN );
    a_pInstance->SetDWORD( L"FrontPanelResetStatus", SM_BIOS_HARDWARE_SECURITY_UNKNOWN );
    a_pInstance->SetByte ( L"ChassisBootupState", CS_UNKNOWN );
    a_pInstance->SetByte ( L"PowerSupplyState", CS_UNKNOWN );
    a_pInstance->SetByte ( L"ThermalState", CS_UNKNOWN );
    a_pInstance->SetWBEMINT16( L"ResetCount", -1 );
    a_pInstance->SetWBEMINT16( L"ResetLimit", -1 );
    // Assume all computers can be reset, either through power or a reset switch.
    a_pInstance->SetWBEMINT16( L"ResetCapability", 1);
    a_pInstance->SetWBEMINT16( L"PowerState", 0 );
}

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::ExecMethod
*
*  DESCRIPTION : Executes a method
*
*  INPUTS      : Instance to execute against, method name, input parms instance
*                Output parms instance.
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CWin32ComputerSystem::ExecMethod(const CInstance& pInstance, const BSTR bstrMethodName,
                                         CInstance *pInParams, CInstance *pOutParams, long lFlags /*= 0L*/)
{
    HRESULT t_RetVal = WBEM_S_NO_ERROR;
    CHString sComputerName = GetLocalComputerName () ;
    CHString sReqName ;
    pInstance.GetCHString ( IDS_Name , sReqName ) ;
    
    if ( sReqName.CompareNoCase ( sComputerName ) != 0 )
    {
        t_RetVal = WBEM_E_NOT_FOUND ;
    }
    else if (_wcsicmp(bstrMethodName, L"Rename") == 0)
        {
                t_RetVal = ExecRename(pInstance, pInParams, pOutParams, lFlags);
    }
    else if (_wcsicmp(bstrMethodName, L"JoinDomainOrWorkgroup") == 0)
        {
                t_RetVal = ExecJoinDomain(pInstance, pInParams, pOutParams, lFlags);
    }
    else if (_wcsicmp(bstrMethodName, L"UnjoinDomainOrWorkgroup") == 0)
        {
                t_RetVal = ExecUnjoinDomain(pInstance, pInParams, pOutParams, lFlags);
    }
    else
    {
        t_RetVal = WBEM_E_INVALID_METHOD ;
    }

    return t_RetVal ;
}

HRESULT CWin32ComputerSystem::CheckPasswordAndUserName(const CInstance& pInstance, CInstance *pInParams,
                                                                                                           CHString &a_passwd, CHString &a_username)
{
    HRESULT t_RetVal = WBEM_S_NO_ERROR;
        BOOL t_bCheckEncryption = FALSE;

    if( !pInParams->IsNull( L"Password") )
        {
                t_bCheckEncryption = TRUE;

                if (!pInParams->GetCHString( L"Password", a_passwd ))
                {
                        t_RetVal = WBEM_E_FAILED;
                }
        }

    if( !pInParams->IsNull( L"UserName") )
        {
                t_bCheckEncryption = TRUE;

                if (!pInParams->GetCHString( L"UserName", a_username ))
                {
                        t_RetVal = WBEM_E_FAILED;
                }
        }

        if (t_bCheckEncryption)
        {
                HRESULT t_hr = t_RetVal;
                t_RetVal = WBEM_E_ENCRYPTED_CONNECTION_REQUIRED;
                IServerSecurity * pss = NULL;

                if(S_OK == WbemCoGetCallContext(IID_IServerSecurity, (void**)&pss))
                {
                        DWORD dwAuthLevel = 0;

                        if (SUCCEEDED(pss->QueryBlanket(NULL, NULL, NULL, &dwAuthLevel, NULL, NULL, NULL))
                                && dwAuthLevel >= RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
                        {
                                t_RetVal = t_hr;

                                //OK one final check, if we are out of proc from winmgmt we'll get a context with the authcn level
                                if (pInstance.GetMethodContext())
                                {
                                        IWbemContext *pCtx = pInstance.GetMethodContext()->GetIWBEMContext();
                                        VARIANT t_Var;
                                        VariantInit(&t_Var);

                                        if (pCtx && SUCCEEDED(pCtx->GetValue(L"__WBEM_CLIENT_AUTHENTICATION_LEVEL", 0, &t_Var)))
                                        {
                                                if ((t_Var.vt != VT_I4) || (t_Var.lVal < RPC_C_AUTHN_LEVEL_PKT_PRIVACY))
                                                {
                                                        t_RetVal = WBEM_E_ENCRYPTED_CONNECTION_REQUIRED;
                                                }

                                                VariantClear(&t_Var);   
                                        }

                                        if (pCtx)
                                        {
                                                pCtx->Release();
                                                pCtx = NULL;
                                        }
                                }
                        }

                        pss->Release();
                }
        }

        return t_RetVal;
}

HRESULT CWin32ComputerSystem::ExecUnjoinDomain(const CInstance& pInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags /*= 0L*/) 
{
#if NTONLY >= 5
        CHString t_passwd;
        CHString t_username;
    HRESULT t_RetVal = CheckPasswordAndUserName(pInstance, pInParams, t_passwd, t_username);

        if (SUCCEEDED(t_RetVal))
        {
                DWORD t_Flags = 0;

                if( !pInParams->IsNull( L"fUnjoinOptions") )
                {
                        if (!pInParams->GetDWORD( L"fUnjoinOptions", t_Flags ))
                        {
                                t_RetVal = WBEM_E_FAILED;
                        }
                }

                if (SUCCEEDED(t_RetVal))
                {
                        CNetAPI32 NetAPI;

                        if ( NetAPI.Init () == ERROR_SUCCESS )
                        {
                                DSROLE_PRIMARY_DOMAIN_INFO_BASIC *t_pDsInfo = 0;
                                NET_API_STATUS t_netstatus = NetAPI.NetUnjoinDomain(
                                                                                                                NULL,
                                                                                                                t_username.GetLength() > 0 ? (LPCWSTR)t_username : NULL,
                                                                                                                t_passwd.GetLength() > 0 ? (LPCWSTR)t_passwd : NULL,
                                                                                                                t_Flags);
                                pOutParams->SetDWORD ( L"ReturnValue", t_netstatus ) ;
                        }
                        else
                        {
                                t_RetVal = WBEM_E_FAILED;
                        }
                }
        }

        return t_RetVal;
#else
        return WBEM_E_NOT_SUPPORTED;
#endif
}

HRESULT CWin32ComputerSystem::ExecJoinDomain(const CInstance& pInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags /*= 0L*/) 
{
#if NTONLY >= 5
        CHString t_passwd;
        CHString t_username;
    HRESULT t_RetVal = CheckPasswordAndUserName(pInstance, pInParams, t_passwd, t_username);

        if (SUCCEEDED(t_RetVal))
        {

                if( !pInParams->IsNull( L"Name") )
                {
                        CHString t_strName;
        
                        if (pInParams->GetCHString( L"Name", t_strName ) && t_strName.GetLength())
                        {
                                DWORD t_Flags = 0;
                                CHString t_strOU;

                                if( !pInParams->IsNull( L"fJoinOptions") )
                                {
                                        if (!pInParams->GetDWORD( L"fJoinOptions", t_Flags ))
                                        {
                                                t_RetVal = WBEM_E_FAILED;
                                        }
                                }

                                if(SUCCEEDED(t_RetVal) && !pInParams->IsNull( L"AccountOU") )
                                {
                                        if (!pInParams->GetCHString( L"AccountOU", t_strOU ))
                                        {
                                                t_RetVal = WBEM_E_FAILED;
                                        }
                                }

                                if (SUCCEEDED(t_RetVal))
                                {
                                        CNetAPI32 NetAPI;

                                        if ( NetAPI.Init () == ERROR_SUCCESS )
                                        {
                                                NET_API_STATUS t_netstatus = NetAPI.NetJoinDomain(
                                                                                                                        NULL,
                                                                                                                        (LPCWSTR)t_strName,
                                                                                                                        t_strOU.GetLength() > 0 ? (LPCWSTR)t_strOU : NULL,
                                                                                                                        t_username.GetLength() > 0 ? (LPCWSTR)t_username : NULL,
                                                                                                                        t_passwd.GetLength() > 0 ? (LPCWSTR)t_passwd : NULL,
                                                                                                                        t_Flags
                                                                                                                        );

                                                pOutParams->SetDWORD ( L"ReturnValue", t_netstatus ) ;
                                        }
                                        else
                                        {
                                                t_RetVal = WBEM_E_FAILED;
                                        }
                                }
                        }
                        else
                        {
                                t_RetVal = WBEM_E_INVALID_METHOD_PARAMETERS ;
                        }
                }
                else
                {
                        t_RetVal = WBEM_E_INVALID_METHOD_PARAMETERS ;
                }
        }

        return t_RetVal;
#else
        return WBEM_E_NOT_SUPPORTED;
#endif
}

HRESULT CWin32ComputerSystem::ExecRename(const CInstance& pInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags /*= 0L*/) 
{
        CHString t_passwd;
        CHString t_username;
    HRESULT t_RetVal = CheckPasswordAndUserName(pInstance, pInParams, t_passwd, t_username);

        if (SUCCEEDED(t_RetVal))
        {
                if( !pInParams->IsNull( L"Name") )
                {
                        CHString t_strName;
        
                        if (pInParams->GetCHString( L"Name", t_strName ) && t_strName.GetLength())
                        {
#if NTONLY >= 5
                                CNetAPI32 NetAPI;

                                if ( NetAPI.Init () == ERROR_SUCCESS )
                                {
                                        DSROLE_PRIMARY_DOMAIN_INFO_BASIC *t_pDsInfo = 0;
    
                                        NET_API_STATUS t_netstatus = NetAPI.DSRoleGetPrimaryDomainInfo(
                                                NULL,
                                                DsRolePrimaryDomainInfoBasic,
                                                (PBYTE *)&t_pDsInfo ) ;
    
                                        if( t_netstatus == NERR_Success && t_pDsInfo )
                                        {
                                                try
                                                {
                                                        switch( t_pDsInfo->MachineRole )
                                                        {
                                                                case DsRole_RoleMemberWorkstation:
                                                                case DsRole_RoleMemberServer:
                                                                case DsRole_RoleBackupDomainController:
                                                                case DsRole_RolePrimaryDomainController:
                                                                {
                                                                        //Rename the machine in the domain
                                                                        t_netstatus = NetAPI.NetRenameMachineInDomain(
                                                                                                        NULL,                                                                                                           //local machine
                                                                                                        t_strName,                                                                                                      //new machine name
                                                                                                        t_username.GetLength() > 0 ? (LPCWSTR)t_username : NULL,        //use calling context (user)
                                                                                                        t_passwd.GetLength() > 0 ? (LPCWSTR)t_passwd : NULL,            //use calling context (passwd)
                                                                                                        NETSETUP_ACCT_CREATE);
                                                                        pOutParams->SetDWORD ( L"ReturnValue", t_netstatus ) ;
                                                                }
                                                                break;
                
                                                                case DsRole_RoleStandaloneWorkstation:
                                                                case DsRole_RoleStandaloneServer:
                                                                {
                                                                        //we're not in a domain...
                                                                        if( SetComputerNameEx(ComputerNamePhysicalDnsHostname, t_strName ) )
                                                                        {
                                                                                pOutParams->SetDWORD ( L"ReturnValue", 0 ) ;
                                                                        }
                                                                        else
                                                                        {
                                                                                //worst case....
                                                                                if( SetComputerNameEx(ComputerNamePhysicalNetBIOS, t_strName ) )
                                                                                {
                                                                                        pOutParams->SetDWORD ( L"ReturnValue", 0 ) ;
                                                                                }
                                                                                else
                                                                                {
                                                                                        pOutParams->SetDWORD ( L"ReturnValue", GetLastError() ) ;
                                                                                }
                                                                        }
                                                                }
                                                        }
                                                }
                                                catch( ... )
                                                {
                                                        NetAPI.DSRoleFreeMemory( (LPBYTE)t_pDsInfo ) ;
                                                        throw ;
                                                }
                                                NetAPI.DSRoleFreeMemory( (LPBYTE)t_pDsInfo ) ;
                                        }
                                        else
                                        {
                                                t_RetVal = WBEM_E_FAILED;
                                        }
                                }
                                else
                                {
                                        t_RetVal = WBEM_E_FAILED;
                                }
#else
                                if( SetComputerName( t_strName ) )
                                {
                                        pOutParams->SetDWORD ( L"ReturnValue", 0 ) ;
                                }
                                else
                                {
                                        pOutParams->SetDWORD ( L"ReturnValue", GetLastError() ) ;
                                }
#endif
                        }
                        else
                        {
                                t_RetVal = WBEM_E_INVALID_METHOD_PARAMETERS ;
                        }
                }
                else
                {
                        t_RetVal = WBEM_E_INVALID_METHOD_PARAMETERS ;
                }
        }

        return t_RetVal;
}

bool CWin32ComputerSystem::UpdatingSystemStartupOptions(
    const CInstance &pInstance)
{
    bool fRet = false;
    variant_t vStartupOpts;

    pInstance.GetVariant(IDS_SystemStartupOptions, vStartupOpts);

    if(vStartupOpts.parray && 
        vStartupOpts.vt == (VT_BSTR | VT_ARRAY) &&
        (1 == ::SafeArrayGetDim(vStartupOpts.parray)))
    {
        fRet = true;
    }    

    return fRet;
}



HRESULT CWin32ComputerSystem::UpdateSystemStartupOptions(
    const CInstance& pInstance,
    const CHString& chstrFilename)

{
    HRESULT hrRet = WBEM_E_FAILED;

    LONG lLBound = 0;
    LONG lUBound = 0;
    variant_t vStartupOpts;
    SAFEARRAY* saStartupOpts = NULL;
    CHStringArray rgchstrOptions;

    pInstance.GetVariant(IDS_SystemStartupOptions, vStartupOpts);

    if(vStartupOpts.parray && 
        vStartupOpts.vt == (VT_BSTR | VT_ARRAY))
    {
        saStartupOpts = vStartupOpts.parray;
    
        if(1 == ::SafeArrayGetDim(saStartupOpts))
        {
            // Get the bounds...
            if(S_OK == ::SafeArrayGetLBound(saStartupOpts, 1, &lLBound) &&
               S_OK == ::SafeArrayGetUBound(saStartupOpts, 1, &lUBound))
            {
                for(long ldx = lLBound; ldx <= lUBound; ldx++)
                {
                    BSTR bstrRole = NULL;
        
                    ::SafeArrayGetElement(
                        saStartupOpts, 
                        &ldx, 
                        &bstrRole);
        
                    // Take ownership of the bstr to
                    // guarentee freeing...
                    bstr_t bstrtRole(bstrRole, false);
        
                    // Store each startup option...
                    rgchstrOptions.Add(bstrtRole);
                }

                // Write the entries out to boot.ini...
                if(rgchstrOptions.GetSize() > 0)
                {
                    hrRet = WriteOptionsToIniFile(
                        rgchstrOptions,
                        chstrFilename);
                }
            }
            else
            {
                ASSERT_BREAK(0);
                LogErrorMessage(L"Could not retrieve SAFEARRAY element while setting system startup options");
                hrRet = WBEM_E_FAILED;
            }
        }
        else
        {
            hrRet = WBEM_E_INVALID_PARAMETER;
        }
    }
    else
    {
        hrRet = WBEM_E_INVALID_PARAMETER;
    }

    return hrRet;
}


HRESULT CWin32ComputerSystem::WriteOptionsToIniFile(
    const CHStringArray& rgchstrOptions,
    const CHString& chstrFilename)
{
    HRESULT hrRet = WBEM_S_NO_ERROR;
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwAttribs;
    DWORD dwSize;
    CHStringArray rgchstrOldOptions;

    // The boot.ini entry of concern here resembles the following:
    //
    // [operating systems]
    // multi(0)disk(0)rdisk(0)partition(4)\WINNT="Microsoft Windows Whistler Advanced Server" /fastdetect /debug /baudrate=57600
    // multi(0)disk(0)rdisk(0)partition(2)\WIN2K="Microsoft Windows Whistler Professional" /fastdetect /debug 
    // multi(0)disk(0)rdisk(0)partition(1)\WINNT="Windows NT Workstation Version 4.00" 
    // multi(0)disk(0)rdisk(0)partition(1)\WINNT="Windows NT Workstation Version 4.00 [VGA mode]" /basevideo /sos
    //
    // Each element in the rgchstrOptions array is the contents
    // of the right side of the equal signn in the name value pairs
    // as shown above.  
    //
    // First thing to do: see if we can write to the file, and
    // if not (due to read only attribute being set), alter the
    // attributes so we can.
    
    CFileAttributes fa(chstrFilename);
    dwError = fa.GetAttributes(&dwAttribs);

    if(dwError == ERROR_SUCCESS)
    {
        dwError = fa.SetAttributes(dwAttribs & ~FILE_ATTRIBUTE_READONLY);

        if(dwError == ERROR_SUCCESS)
        {
            // GetPrivateProfileSection won't tell you how
            // big a buffer you need, so allocate a reasonable
            // size one first, then try a much bigger one.  If
            // still not big enough, bail.
            LPWSTR wstrSection = NULL;
            try
            {
                wstrSection = new WCHAR[PROF_SECT_SIZE + 2];
                if(wstrSection)
                {
                    dwSize = WMI_FILE_GetPrivateProfileSectionW(
                        L"operating systems",
                        wstrSection,
                        PROF_SECT_SIZE,
                        chstrFilename);
                        
                    if(dwSize == PROF_SECT_SIZE)
                    {
                        delete wstrSection;
                        wstrSection = NULL;
                        
                        wstrSection = new WCHAR[(PROF_SECT_SIZE * 10) + 2];

                        if(wstrSection)
                        {
                            dwSize = WMI_FILE_GetPrivateProfileSectionW(
                                L"operating systems",
                                wstrSection,
                                PROF_SECT_SIZE,
                                chstrFilename);
                        
                            if(dwSize == (PROF_SECT_SIZE * 10))
                            {
                                // bail...
                                dwError = E_FAIL;
                                delete wstrSection;
                                wstrSection = NULL;
                                hrRet = WBEM_E_ACCESS_DENIED;
                            }
                        }
                        else
                        {
                            dwError = E_FAIL;
                            hrRet = WBEM_E_OUT_OF_MEMORY;
                        }
                    }

                    // Proceed if we got all the section contents...
                    if(dwError == ERROR_SUCCESS)
                    {
                        // Place the section contents into an array...
                        if(wstrSection)
                        {
                            LPWSTR pwc = wstrSection;
                            rgchstrOldOptions.Add(pwc);
                            pwc += (wcslen(pwc) + 1);

                            for(; *pwc != L'\0'; )
                            {
                                rgchstrOldOptions.Add(pwc);
                                pwc += (wcslen(pwc) + 1);
                            }
                        }
                        else
                        {
                            if(rgchstrOptions.GetSize() != 0)
                            {
                                // We were given option entries but
                                // the [operating systems] section
                                // was empty.
                                hrRet = WBEM_E_INVALID_PARAMETER;
                            }
                        }
                    }

                    if(wstrSection)
                    {
                        delete wstrSection;
                        wstrSection = NULL;
                    }
                }
                else
                {
                    hrRet = WBEM_E_OUT_OF_MEMORY;
                }
            }
            catch(...)
            {
                if(wstrSection)
                {
                    delete wstrSection;
                    wstrSection = NULL;
                }
                throw;
            }

            // First check:  do we have the same number
            // of name value pairs initially in the ini file
            // as we have elements in the new options array?
            if(SUCCEEDED(hrRet))
            {
                long lElemCount = rgchstrOptions.GetSize();

                if(lElemCount ==
                    rgchstrOldOptions.GetSize())
                {
                    // Prepare output buffer...
                    LPWSTR wstrOut = NULL;
                    dwSize = 0;
                    for(long m = 0; m < lElemCount; m++)
                    {
                        dwSize += rgchstrOptions[m].GetLength();
                        // Need space for extra NULL for each string...
                        dwSize++;
                    }

                    // That accounted for the values.  Now allocate space
                    // for the name and the equal sign.  The following ends
                    // up counting more space than we need, but it faster
                    // than finding the equal sign, counting the characters
                    // up to it, and adding one for the equal sign, for each
                    // name value pair.
                    for(m = 0; m < lElemCount; m++)
                    {
                        dwSize += rgchstrOldOptions[m].GetLength();
                        // Need space for extra NULL for each string...
                        dwSize++;
                    }


                    // Need space for extra second NULL at end of block...
                    dwSize += 1;

                    try
                    {
                        wstrOut = new WCHAR[dwSize];

                        if(wstrOut)
                        {
                            ::ZeroMemory(wstrOut, dwSize*sizeof(WCHAR));

                            WCHAR* pwc = wstrOut;
                            CHString chstrTmp;

                            for(m = 0; m < lElemCount; m++)
                            {
                                chstrTmp = rgchstrOldOptions[m].SpanExcluding(L"=");
                                chstrTmp += L"=";
                                chstrTmp += rgchstrOptions[m];
                                memcpy(pwc, chstrTmp, (chstrTmp.GetLength())*sizeof(WCHAR));
                                // Move insertion pointer ahead, including one space for
                                // a null at the end of the string...
                                pwc += (chstrTmp.GetLength() + 1);
                            }

                            // Now write out the section...
                            if(!WMI_FILE_WritePrivateProfileSectionW(
                                L"operating systems",
                                wstrOut,
                                chstrFilename))
                            {
                                DWORD dwWriteErr = ::GetLastError();
                                hrRet = WinErrorToWBEMhResult(dwWriteErr);
                                LogErrorMessage2(
                                    L"Failed to write out [operating systems] private profile section data to boot.ini, with error %d",
                                    dwWriteErr);
                            }
                        }
                        else
                        {
                            hrRet = WBEM_E_OUT_OF_MEMORY;
                        }
                    }
                    catch(...)
                    {
                        if(wstrOut)
                        {
                            delete wstrOut;
                            wstrOut = NULL;
                        }
                        throw;
                    }
                }
                else
                {
                    hrRet = WBEM_E_INVALID_PARAMETER;
                }
            }
        }
        else
        {
            hrRet = WinErrorToWBEMhResult(dwError);
        }
    }
    else
    {
        hrRet = WinErrorToWBEMhResult(dwError);
    }

    return hrRet;
}





#if NTONLY >= 5
void CWin32ComputerSystem::SetUserName(
    CInstance* pInstance)
{
    CSid sidThreadUser;

    if(GetUserOnThread(sidThreadUser))
    {
        CSid sidLoggedOnUser;
        CSid sidTemp;

        bool fGotLoggedOnUser = false;
        if(GetLoggedOnUserViaTS(sidTemp))
        {
            sidLoggedOnUser = sidTemp;
            fGotLoggedOnUser = true;
        }

        if(!fGotLoggedOnUser)
        {
            if(GetLoggedOnUserViaImpersonation(sidTemp))
            {
                sidLoggedOnUser = sidTemp;
                fGotLoggedOnUser = true;
            }
        }

        if(fGotLoggedOnUser)
        {
            CHString chstrUserDomAndName;
            CHString chstrUserDom = sidLoggedOnUser.GetDomainName();
            CHString chstrUserName = sidLoggedOnUser.GetAccountName();

            if(chstrUserDom.GetLength() > 0)
            {
                chstrUserDomAndName = chstrUserDom;
                chstrUserDomAndName += L"\\";
            }

            chstrUserDomAndName += chstrUserName;

            pInstance->SetCHString(
                IDS_UserName,
                chstrUserDomAndName);
        }
    }
}
#endif


#if NTONLY >= 5
bool CWin32ComputerSystem::GetUserOnThread(
    CSid& sidUserOnThread)
{
    bool fRet = false;
    CSid sidTemp;
    SmartCloseHandle hThread;
    SmartCloseHandle hToken;
    PTOKEN_USER ptokusr = NULL;
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwRetSize = 0L;

    // the token user struct varries
    // in size depending on the size
    // of the sid in the SID_AND_ATTRIBUTES
    // structure, so need to allocate
    // it dynamically.

    hThread = GetCurrentThread();
    if(hThread != INVALID_HANDLE_VALUE)
    {
        if(::OpenThreadToken(
            hThread,
            TOKEN_QUERY,
            FALSE,    // open with the thread's, not the processes' credentials
            &hToken))
        {
            if(!::GetTokenInformation(
                hToken,
                TokenUser,
                NULL,
                0L,
                &dwRetSize))
            {
                dwRet = ::GetLastError();
            }

            if(dwRet == ERROR_INSUFFICIENT_BUFFER)
            {
                // now get it for real...
                // (new throws on failure, don't need to check)
                ptokusr = (PTOKEN_USER) new BYTE[dwRetSize]; 
                try
                { 
                    DWORD dwTmp = dwRetSize;

                    if(::GetTokenInformation(
                        hToken,
                        TokenUser,
                        ptokusr,
                        dwTmp,
                        &dwRetSize))
                    {
                        sidTemp = ptokusr->User.Sid;
                    }
                 
                    delete ptokusr;
                    ptokusr = NULL;
                }
                catch(...)
                {
                    if(ptokusr)
                    {
                        delete ptokusr;
                        ptokusr = NULL;
                    }
                    throw;
                }
            }
        }
    }

    if(sidTemp.IsOK() && sidTemp.IsValid())
    {
        sidUserOnThread = sidTemp;
        fRet = true;
    }

    return fRet;
}
#endif


#if NTONLY >= 5
bool CWin32ComputerSystem::GetLoggedOnUserViaTS(
    CSid& sidLoggedOnUser)
{
    bool fRet = false;
    bool fCont = true;
    PWTS_SESSION_INFO psesinfo = NULL;
    DWORD dwSessions = 0;
    LPWSTR wstrUserName = NULL;
    LPWSTR wstrDomainName = NULL;
    LPWSTR wstrWinstaName = NULL;
    DWORD dwSize = 0L;

    // Use of delay loaded functions requires exception handler.
    SetStructuredExceptionHandler seh;

    try
    {
        if(!(::WTSEnumerateSessions(
           WTS_CURRENT_SERVER_HANDLE,
           0,
           1,
           &psesinfo,
           &dwSessions) && psesinfo))
        {
            fCont = false;
        }

        if(fCont)
        {
            for(int j = 0; j < dwSessions && !fRet; j++, fCont = true)
            {
                if(psesinfo[j].State != WTSActive)
                {
                    fCont = false;
                }

                if(fCont)
                {
                    if(!(::WTSQuerySessionInformation(
                        WTS_CURRENT_SERVER_HANDLE,
                        psesinfo[j].SessionId,
                        WTSUserName,
                        &wstrUserName,
                        &dwSize) && wstrUserName))
                    {
                        fCont = false;
                    }
                }
                
                if(fCont)
                {
                    if(!(::WTSQuerySessionInformation(
                        WTS_CURRENT_SERVER_HANDLE,
                        psesinfo[j].SessionId,
                        WTSDomainName,
                        &wstrDomainName,
                        &dwSize) && wstrDomainName))
                    {
                        fCont = false;
                    }
                }
                    
                if(fCont)
                {            
                    if(!(::WTSQuerySessionInformation(
                        WTS_CURRENT_SERVER_HANDLE,
                        psesinfo[j].SessionId,
                        WTSWinStationName,
                        &wstrWinstaName,
                        &dwSize) && wstrWinstaName))   
                    {
                        fCont = false;
                    }
                }

                if(fCont)
                {
                    if(_wcsicmp(wstrWinstaName, L"Console") != 0)
                    {
                        fCont = false;
                    }
                }

                if(fCont)
                {
                    // That establishes that this user
                    // is associated with the interactive
                    // desktop.
                    CSid sidInteractive(wstrDomainName, wstrUserName, NULL);
    
                    if(sidInteractive.IsOK() && sidInteractive.IsValid())
                    {
                        sidLoggedOnUser = sidInteractive;
                        fRet = true;
                    }
                }

                if(wstrUserName)
                {
                    WTSFreeMemory(wstrUserName);
					wstrUserName = NULL;
                }
                if(wstrDomainName)
                {
                    WTSFreeMemory(wstrDomainName);
					wstrDomainName = NULL;
                }
                if(wstrWinstaName)
                {
                    WTSFreeMemory(wstrWinstaName);
					wstrWinstaName = NULL;
                }
            }

            if(psesinfo)
            {
                WTSFreeMemory(psesinfo);
                psesinfo = NULL;
            }
        }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
		fRet = false;

        if(wstrUserName)
        {
            WTSFreeMemory(wstrUserName);
			wstrUserName = NULL;
        }
        if(wstrDomainName)
        {
            WTSFreeMemory(wstrDomainName);
			wstrDomainName = NULL;
        }
        if(wstrWinstaName)
        {
            WTSFreeMemory(wstrWinstaName);
			wstrWinstaName = NULL;
        }
        if(psesinfo)
        {
            WTSFreeMemory(psesinfo);
            psesinfo = NULL;
        }
    }
    catch(...)
    {
        if(wstrUserName)
        {
            WTSFreeMemory(wstrUserName);
			wstrUserName = NULL;
        }
        if(wstrDomainName)
        {
            WTSFreeMemory(wstrDomainName);
			wstrDomainName = NULL;
        }
        if(wstrWinstaName)
        {
            WTSFreeMemory(wstrWinstaName);
			wstrWinstaName = NULL;
        }
        if(psesinfo)
        {
            WTSFreeMemory(psesinfo);
            psesinfo = NULL;
        }
        throw;
    }

    return fRet;
}
#endif


#if NTONLY >= 5
bool CWin32ComputerSystem::GetLoggedOnUserViaImpersonation(
    CSid& sidLoggedOnUser)
{
    bool fRet = false;
    CImpersonateLoggedOnUser impersonateLoggedOnUser;

    if(impersonateLoggedOnUser.Begin())
    {
        try
        {
            CHString chstrDomain;
            CHString chstrUserName;
            CHString chstrDomainAndUser;
            {
                if(SUCCEEDED(GetUserAccount(
                    chstrDomain, 
                    chstrUserName)))
                {
                    CSid sidTemp(chstrDomain, chstrUserName, NULL);
                    if(sidTemp.IsOK() && sidTemp.IsValid())
                    {
                        sidLoggedOnUser = sidTemp;
                        fRet = true;
                    }
                }
            }
        }
        catch(...)
        {
            impersonateLoggedOnUser.End();
            throw ;
        }
        
        impersonateLoggedOnUser.End();
    }

    return fRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\computersystem.h ===
//=================================================================

//

// ComputerSystem.h -- Computer System property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
// 				 09/12/97	a-sanjes		GetCompSysInfo takes param.
//               10/23/97   jennymc         Moved to new framework
//
//=================================================================


#include "ServerDefs0.h"
#include "sid.h"


// Property set identification
//============================
#define PROPSET_NAME_COMPSYS  L"Win32_ComputerSystem"

#define	NTCS_PERF_DATA_SYSTEM_INDEX_STR		_T("2")
#define	NTCS_PERF_DATA_SYSTEM_INDEX			2
#define	NTCS_PERF_DATA_SYSTEMUPTIME_INDEX	674

typedef struct _SV_ROLES {
    
    LPCWSTR		pwStrRole;
    DWORD	    dwRoleMask ;
    
} SV_ROLES ;

class CWin32ComputerSystem : public Provider 
{
public:

        // Constructor/destructor
        //=======================

	CWin32ComputerSystem(const CHString& name, LPCWSTR pszNamespace);
	~CWin32ComputerSystem() ;

        // Functions provide properties with current values
        //=================================================

	virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &pQuery
);
	virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
	virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ );
	virtual HRESULT ExecMethod(const CInstance& pInstance, const BSTR bstrMethodName,
								CInstance *pInParams, CInstance *pOutParams, long lFlags /*= 0L*/);

        // Utility function(s)
        //====================
    HRESULT GetCompSysInfo( CInstance *pInstance) ;
#ifdef NTONLY
    HRESULT GetCompSysInfoNT(CInstance *pInstance) ;
#endif
#if NTONLY >= 5
    void SetUserName(
        CInstance* pInstance);
    bool GetUserOnThread(
        CSid& sidUserOnThread);
    bool GetLoggedOnUserViaTS(
        CSid& sidLoggedOnUser);
    bool GetLoggedOnUserViaImpersonation(
        CSid& sidLoggedOnUser);
#endif
	void GetTimeZoneInfo(CInstance *pInstance);

	HRESULT GetAccount ( HANDLE a_TokenHandle , CHString &a_Domain , CHString &a_User ) ;
	HRESULT GetUserAccount ( CHString &a_Domain , CHString &a_User ) ;

private:

		// Helper time conversion function
    HRESULT GetStartupOptions(CInstance *pInstance);
    void GetOEMInfo(CInstance *pInstance);
    DWORD LoadOperatingSystems(LPCTSTR szIniFile, SAFEARRAY **saNames, SAFEARRAY **saDirs);
    HRESULT PutInstance(const CInstance &pInstance, long lFlags = 0L);
    
	void	SetRoles(CInstance *pInstance, DWORD dwType);
	HRESULT GetRoles (

		const CInstance &a_rInstance, 
		DWORD *a_pdwRoleType
		) ;

	HRESULT SetTimeZoneInfo ( const CInstance &a_rInstance ) ;

	void InitializePropertiestoUnknown ( CInstance *a_pInstance ) ;

    bool UpdatingSystemStartupOptions(
        const CInstance &pInstance);

    HRESULT UpdateSystemStartupOptions(
        const CInstance& pInstance,
        const CHString& chstrFilename);
    
    HRESULT WriteOptionsToIniFile(
        const CHStringArray& rgchstrOptions,
        const CHString& chstrFilename);

	HRESULT CheckPasswordAndUserName(
		const CInstance& pInstance,
		CInstance *pInParams,
		CHString &a_passwd,
		CHString &a_username);

	HRESULT ExecJoinDomain(
		const CInstance& pInstance,
		CInstance *pInParams,
		CInstance *pOutParams,
		long lFlags /*= 0L*/);
	
	HRESULT ExecRename(
		const CInstance& pInstance,
		CInstance *pInParams,
		CInstance *pOutParams,
		long lFlags /*= 0L*/);
	
	HRESULT ExecUnjoinDomain(
		const CInstance& pInstance,
		CInstance *pInParams,
		CInstance *pOutParams,
		long lFlags /*= 0L*/); 
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\cprocess.cpp ===
//=================================================================
//
// WMIProcess.CPP --Process property set provider
//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/27/97	 a-hhance		updated to new framework paradigm.
//				1/13/98		a-brads		updated to V2 MOF
//
//=================================================================

#include "precomp.h"
#include <userenv.h>

#pragma warning ( disable : 4005 )
#include <cregcls.h>
#include <winperf.h>
#include <tlhelp32.h>
#include <mmsystem.h>

#include "WBEMPSAPI.h"
#include "WBEMToolH.h"
#include "sid.h"
#include "userhive.h"
#include "systemname.h"
#include "DllWrapperBase.h"
#include "AdvApi32Api.h"
#include "NtDllApi.h"
#include "UserEnvApi.h"

#include "resource.h"

#include "CProcess.h"
#include "tokenprivilege.h"

#include <computerAPI.h>

#if NTONLY >= 5
typedef BOOLEAN ( WINAPI *pfnWinStationGetProcessSid )( HANDLE hServer, DWORD ProcessId , FILETIME ProcessStartTime , PBYTE pProcessUserSid , PDWORD dwSidSize );
#endif


// Property set declaration
//=========================

Process MyProcessSet ( PROPSET_NAME_PROCESS , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : Process::Process
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Process :: Process (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Process::~Process
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

Process :: ~Process ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Process::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Process :: GetObject (

	CInstance* pInstance,
	long lFlags,
    CFrameworkQuery &pQuery
)
{
	HRESULT hRetCode = WBEM_E_FAILED;

    // Initialize API DLL & freshen the cache
    //=======================================

#ifdef NTONLY

	SYSTEM_PROCESS_INFORMATION *t_ProcessBlock = NULL ;

	CNtDllApi *pNtdll = ( CNtDllApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidNtDllApi, NULL ) ;
	if ( pNtdll )
	{
		try
		{
			t_ProcessBlock = RefreshProcessCacheNT ( *pNtdll , pInstance->GetMethodContext () , & hRetCode ) ;
		}
		catch ( ... )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtdll ) ;

			throw ;
		}
	}

	if ( ! SUCCEEDED ( hRetCode ) )
	{
		if ( t_ProcessBlock )
		{
			delete []  t_ProcessBlock;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtdll ) ;

		return hRetCode ;
	}

#endif
	hRetCode = WBEM_E_FAILED ;

	try
	{
		// Look for key values
		//====================

		CHString chsHandle;
		pInstance->GetCHString ( IDS_Handle , chsHandle ) ;

		DWORD processID ;
        WCHAR wszHandle[MAXITOA];

		if ( swscanf ( chsHandle, L"%lu" , & processID ) && (wcscmp ( chsHandle , _ultow(processID, wszHandle, 10)) == 0 ))
		{
			BOOL t_Found = FALSE ;

#ifdef NTONLY

			SYSTEM_PROCESS_INFORMATION *t_CurrentInformation = GetProcessBlock ( *pNtdll , t_ProcessBlock , processID ) ;
			if ( t_CurrentInformation )
			{
				t_Found = TRUE ;
			}
#else

			for ( DWORD i = 0 ; i < PCache.dwProcessCount ; i++ )
			{
				if ( processID == PCache.pdwPIDList [ i ] )
				{
					t_Found = TRUE ;
					break ;
				}
			}
#endif

			if ( t_Found )
			{

			// Load all properties
			//====================

                if (!pQuery.KeysOnly())
                {
#ifdef NTONLY
					hRetCode = LoadCheapPropertiesNT ( *pNtdll, t_CurrentInformation , pInstance ) 
								? WBEM_S_NO_ERROR : WBEM_E_FAILED;
#endif

                }
                else
                {
                    hRetCode = WBEM_S_NO_ERROR;
                }

			}
			else
			{
				hRetCode = WBEM_E_NOT_FOUND ;
			}

		}
		else
		{
			hRetCode = WBEM_E_NOT_FOUND ;
		}
	}
	catch ( ... )
	{
#ifdef NTONLY

		if ( t_ProcessBlock )
		{
			delete [] t_ProcessBlock ;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi , pNtdll ) ;

#endif

		throw ;
	}

#ifdef NTONLY

	if ( t_ProcessBlock )
	{
		delete [] t_ProcessBlock;
	}

	CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi , pNtdll ) ;

#endif

    return hRetCode ;
}

HRESULT Process::ExecQuery (

    MethodContext* pMethodContext,
    CFrameworkQuery &pQuery,
    long lFlags
)
{
    return Enumerate(pMethodContext, lFlags, pQuery.KeysOnly());
}

/*****************************************************************************
 *
 *  FUNCTION    : Process::AddDynamicInstances
 *
 *  DESCRIPTION : Creates instance of property set for each discovered process
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Process :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    return Enumerate(pMethodContext, lFlags, FALSE);
}

HRESULT Process :: Enumerate (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/,
    BOOL bKeysOnly
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Initialize API DLL & freshen the cache
    //=======================================

#ifdef NTONLY

	SYSTEM_PROCESS_INFORMATION *t_ProcessBlock = NULL ;

	CNtDllApi *pNtdll = ( CNtDllApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidNtDllApi, NULL ) ;
	if ( pNtdll )
	{
		try
		{
			t_ProcessBlock = RefreshProcessCacheNT ( *pNtdll , pMethodContext , &hr ) ;
		}
		catch ( ... )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtdll ) ;

			throw ;
		}
	}

	if ( ! SUCCEEDED ( hr ) )
	{
		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtdll ) ;

		return hr ;
	}

#endif

	try
	{
#ifdef NTONLY

		SYSTEM_PROCESS_INFORMATION *t_CurrentInformation = t_ProcessBlock ;

		while ( t_CurrentInformation )
		{
			CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;

            WCHAR wszHandle[_MAX_PATH];
            _ui64tow( HandleToUlong ( t_CurrentInformation->UniqueProcessId ), wszHandle, 10);
            pInstance->SetWCHARSplat(IDS_Handle, wszHandle);

            BOOL bRetCode = TRUE;
            if (!bKeysOnly)
            {
			    bRetCode = LoadCheapPropertiesNT (

				    *pNtdll ,
				    t_CurrentInformation ,
				    pInstance
			    ) ;
            }

			if( bRetCode)
			{
				HRESULT t_hr ;
				if ( FAILED ( t_hr = pInstance->Commit () ) )
				{
					hr = t_hr ;
					break ;
				}
			}

			t_CurrentInformation = NextProcessBlock ( *pNtdll , t_CurrentInformation ) ;
		}

#else
		std::deque<DWORD> t_ThreadQ ;
		GetThreadList ( *pKernel32, t_ThreadQ )	;
		// Create instances for all valid processes
		//=========================================

		for ( DWORD i = 0 ; i < PCache.dwProcessCount && SUCCEEDED ( hr ) ; i ++ )
		{
			CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;

	        WCHAR wszHandle [ _MAX_PATH ] ;
	        _ui64tow(PCache.pdwPIDList [ i ], wszHandle, 10 ) ;
	        pInstance->SetWCHARSplat ( IDS_Handle , wszHandle ) ;

            BOOL bRetCode = TRUE;
            if (!bKeysOnly)
            {
			    bRetCode = LoadCheapPropertiesWin95 (

				    *pKernel32,
				    i,
				    PCache,
				    pInstance ,
					t_ThreadQ
			    ) ;
            }

			if( bRetCode)
			{
				hr = pInstance->Commit (  ) ;
			}
		}
#endif
	}
	catch ( ... )
	{
#ifdef NTONLY

		if ( t_ProcessBlock )
		{
			delete [] t_ProcessBlock;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi , pNtdll ) ;

#endif


		throw ;
	}

#ifdef NTONLY

	if ( t_ProcessBlock )
	{
		delete [] t_ProcessBlock;
	}

	CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi , pNtdll ) ;

#endif

    return  hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : Process::RefreshProcessCacheNT
 *
 *  DESCRIPTION : Refreshes cache of key properties
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE if unable to refresh
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
SYSTEM_PROCESS_INFORMATION *Process :: RefreshProcessCacheNT (

	CNtDllApi &a_NtApi ,
	MethodContext *pMethodContext ,
	HRESULT *a_phrRetVal /* = NULL */
)
{
    // Without this privilege, a local admin user won't be able to see all the
    // information of some system processes.
	if ( ! EnablePrivilegeOnCurrentThread ( SE_DEBUG_NAME ) )
    {
	    *a_phrRetVal = WBEM_S_PARTIAL_RESULTS ;
		SAFEARRAYBOUND rgsabound [ 1 ] ;
	    rgsabound[0].cElements = 1;
	    rgsabound[0].lLbound = 0;

	    SAFEARRAY *psaPrivilegesReqd = SafeArrayCreate ( VT_BSTR, 1, rgsabound ) ;

		SAFEARRAY *psaPrivilegesNotHeld = SafeArrayCreate ( VT_BSTR, 1, rgsabound ) ;

        if ( psaPrivilegesReqd && psaPrivilegesNotHeld )
        {
			try
			{
				long index = 0 ;

				bstr_t privilege(L"SE_DEBUG_NAME");

				HRESULT t_Result = SafeArrayPutElement ( psaPrivilegesReqd, & index, (void *)(BSTR)privilege ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

				t_Result = SafeArrayPutElement ( psaPrivilegesNotHeld, &index, (void *)(BSTR)privilege ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}
			catch ( ... )
			{
				if ( psaPrivilegesNotHeld )
				{
					SafeArrayDestroy ( psaPrivilegesNotHeld ) ;
				}

				if ( psaPrivilegesReqd )
				{
					SafeArrayDestroy ( psaPrivilegesReqd ) ;
				}

				throw ;
			}
        }
		else
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}

        if ( psaPrivilegesNotHeld )
		{
            SafeArrayDestroy ( psaPrivilegesNotHeld ) ;
		}

        if ( psaPrivilegesReqd )
		{
            SafeArrayDestroy ( psaPrivilegesReqd ) ;
		}
    }
	else
	{
		*a_phrRetVal = S_OK ;
	}

	return GetProcessBlocks ( a_NtApi ) ;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : Process::LoadCheapPropertiesNT
 *
 *  DESCRIPTION : Retrieves 'easy-to-get' properties
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE if unable
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
BOOL Process::LoadCheapPropertiesNT (

	CNtDllApi &a_NtApi ,
	SYSTEM_PROCESS_INFORMATION *a_ProcessBlock ,
	CInstance* pInstance
)
{
	SetCreationClassName ( pInstance ) ;

	pInstance->SetDWORD ( IDS_ProcessID, HandleToUlong ( a_ProcessBlock->UniqueProcessId ) ) ;

	if ( a_ProcessBlock->ImageName.Buffer )
	{
		pInstance->SetWCHARSplat ( IDS_Name , a_ProcessBlock->ImageName.Buffer ) ;

		pInstance->SetWCHARSplat ( IDS_Caption , a_ProcessBlock->ImageName.Buffer ) ;

		pInstance->SetWCHARSplat ( IDS_Description, a_ProcessBlock->ImageName.Buffer ) ;
	}
	else
	{
		switch ( HandleToUlong ( a_ProcessBlock->UniqueProcessId ) )
		{
			case 0:
			{
				pInstance->SetWCHARSplat ( IDS_Name , L"System Idle Process" ) ;

				pInstance->SetWCHARSplat ( IDS_Caption , L"System Idle Process" ) ;

				pInstance->SetWCHARSplat ( IDS_Description, L"System Idle Process" ) ;
			}
			break ;

			case 2:
			case 8:
			{
				pInstance->SetWCHARSplat ( IDS_Name , L"System" ) ;

				pInstance->SetWCHARSplat ( IDS_Caption , L"System" ) ;

				pInstance->SetWCHARSplat ( IDS_Description, L"System" ) ;
			}
			break ;

			default:
			{
				pInstance->SetWCHARSplat ( IDS_Name , IDS_Unknown ) ;

				pInstance->SetWCHARSplat ( IDS_Caption , IDS_Unknown ) ;

				pInstance->SetWCHARSplat ( IDS_Description, IDS_Unknown ) ;
			}
			break ;
		}
	}

	// let's make the key
	pInstance->SetWCHARSplat ( IDS_CSCreationClassName , L"Win32_ComputerSystem" ) ;

	pInstance->SetCHString ( IDS_CSName , GetLocalComputerName () ) ;

	WCHAR szHandle [ _MAX_PATH ] ;
	_stprintf ( szHandle , _T("%lu"), HandleToUlong ( a_ProcessBlock->UniqueProcessId ) ) ;
	pInstance->SetWCHARSplat ( IDS_Handle , szHandle ) ;

	pInstance->SetWCHARSplat ( IDS_OSCreationClassName , L"Win32_OperatingSystem" ) ;

	OSVERSIONINFO OSVersionInfo ;
	CHString chsOs;

	OSVersionInfo.dwOSVersionInfoSize = sizeof ( OSVERSIONINFO ) ;
	if ( ! GetVersionEx ( & OSVersionInfo ) )
	{
		return FALSE ;
	}

	WCHAR wszTemp[_MAX_PATH] ;
    swprintf (	wszTemp,
				L"%d.%d.%hu",
				OSVersionInfo.dwMajorVersion,
				OSVersionInfo.dwMinorVersion,
				LOWORD ( OSVersionInfo.dwBuildNumber )
			) ;

	pInstance->SetWCHARSplat(IDS_WindowsVersion, wszTemp );

	CSystemName sys;
	CHString strOS = sys.GetLongKeyName();

	pInstance->SetCHString ( IDS_OSName, strOS ) ;

	pInstance->SetDWORD ( IDS_PageFaults , a_ProcessBlock->PageFaultCount ) ;

	pInstance->SetDWORD ( IDS_PeakWorkingSetSize , a_ProcessBlock->PeakWorkingSetSize ) ;

	pInstance->SetWBEMINT64 ( IDS_WorkingSetSize , (const unsigned __int64) a_ProcessBlock->WorkingSetSize ) ;

	pInstance->SetDWORD ( IDS_QuotaPeakPagedPoolUsage , a_ProcessBlock->QuotaPeakPagedPoolUsage ) ;

	pInstance->SetDWORD ( IDS_QuotaPagedPoolUsage , a_ProcessBlock->QuotaPagedPoolUsage ) ;

	pInstance->SetDWORD ( IDS_QuotaPeakNonPagedPoolUsage , a_ProcessBlock->QuotaPeakNonPagedPoolUsage ) ;

	pInstance->SetDWORD ( IDS_QuotaNonPagedPoolUsage , a_ProcessBlock->QuotaNonPagedPoolUsage ) ;

	pInstance->SetDWORD ( IDS_PageFileUsage , a_ProcessBlock->PagefileUsage ) ;

	pInstance->SetDWORD ( IDS_PeakPageFileUsage , a_ProcessBlock->PeakPagefileUsage ) ;

	pInstance->SetDWORD ( IDS_Priority , a_ProcessBlock->BasePriority ) ;
/*
 *  For "System" & "System Idle" , Creation Time (offset from January 1, 1601) is zero
 */
	if ( a_ProcessBlock->CreateTime.u.HighPart > 0 )
	{
		pInstance->SetDateTime ( IDS_CreationDate, WBEMTime ( * ( FILETIME * ) ( & a_ProcessBlock->CreateTime.u ) ) ) ;
	}

	pInstance->SetWBEMINT64 ( IDS_KernelModeTime , (const unsigned __int64) a_ProcessBlock->KernelTime.QuadPart ) ;

	pInstance->SetWBEMINT64 ( IDS_UserModeTime , (const unsigned __int64) a_ProcessBlock->UserTime.QuadPart ) ;

    pInstance->SetWBEMINT64 ( L"PrivatePageCount" , (const unsigned __int64) a_ProcessBlock->PrivatePageCount ) ;

    pInstance->SetWBEMINT64 ( L"PeakVirtualSize" , (const unsigned __int64) a_ProcessBlock->PeakVirtualSize ) ;

    pInstance->SetWBEMINT64 ( L"VirtualSize" , (const unsigned __int64) a_ProcessBlock->VirtualSize ) ;

    pInstance->SetDWORD ( L"ThreadCount" , a_ProcessBlock->NumberOfThreads ) ;

    pInstance->SetDWORD ( L"ParentProcessId" , HandleToUlong ( a_ProcessBlock->InheritedFromUniqueProcessId ) ) ;

    pInstance->SetDWORD ( L"HandleCount" , a_ProcessBlock->HandleCount ) ;

#if NTONLY == 5
    pInstance->SetDWORD ( L"SessionId" , a_ProcessBlock->SessionId ) ;

	pInstance->SetWBEMINT64 ( L"ReadOperationCount" , (const unsigned __int64) a_ProcessBlock->ReadOperationCount.QuadPart ) ;

	pInstance->SetWBEMINT64 ( L"WriteOperationCount" , (const unsigned __int64) a_ProcessBlock->WriteOperationCount.QuadPart ) ;

	pInstance->SetWBEMINT64 ( L"OtherOperationCount" , (const unsigned __int64) a_ProcessBlock->OtherOperationCount.QuadPart ) ;

	pInstance->SetWBEMINT64 ( L"ReadTransferCount" , (const unsigned __int64) a_ProcessBlock->ReadTransferCount.QuadPart ) ;

	pInstance->SetWBEMINT64 ( L"WriteTransferCount" , (const unsigned __int64) a_ProcessBlock->WriteTransferCount.QuadPart ) ;

	pInstance->SetWBEMINT64 ( L"OtherTransferCount" , (const unsigned __int64) a_ProcessBlock->OtherTransferCount.QuadPart ) ;

#endif


	SmartCloseHandle hProcessHandle = OpenProcess (

		PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
		FALSE,
        HandleToUlong ( a_ProcessBlock->UniqueProcessId )
	) ;

	if(hProcessHandle != INVALID_HANDLE_VALUE &&
        hProcessHandle != 0L &&
        ::GetLastError() == ERROR_SUCCESS)
    {
	    CHString t_ExecutableName ;
	    BOOL t_Status = GetProcessExecutable ( a_NtApi , hProcessHandle , t_ExecutableName ) ;
	    if ( t_Status )
	    {
		    pInstance->SetWCHARSplat ( IDS_ExecutablePath, t_ExecutableName );
	    }

	    QUOTA_LIMITS QuotaLimits;

	    NTSTATUS Status = a_NtApi.NtQueryInformationProcess (

            hProcessHandle,
            ProcessQuotaLimits,
            &QuotaLimits,
            sizeof(QuotaLimits),
            NULL
        );

	    if ( NT_SUCCESS ( Status ) )
	    {
		    pInstance->SetDWORD ( IDS_MinimumWorkingSetSize, QuotaLimits.MinimumWorkingSetSize ) ;
		    pInstance->SetDWORD ( IDS_MaximumWorkingSetSize, QuotaLimits.MaximumWorkingSetSize ) ;
	    }

	    CHString t_CommandParameters ;

	    t_Status = GetProcessParameters (

		    a_NtApi ,
		    hProcessHandle ,
		    t_CommandParameters
	    ) ;

	    if ( t_Status )
	    {
		    pInstance->SetCharSplat ( _T("CommandLine") , t_CommandParameters ) ;
	    }
    }

    return TRUE ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : Process::filetimeToUint64CHString
 *
 *
 *  DESCRIPTION : Modifies a FILTTIME structure to a unit64 string representation
 * of the number in milliseconds
 *
 *  INPUTS      : A FILETIME object
 *
 *  RETURNS     : A CHString representing the object, or NULL if it fails.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CHString Process :: filetimeToUint64CHString (

	FILETIME inputTime
)
{
	__int64 val = inputTime.dwHighDateTime;
	val = (val << 32) | inputTime.dwLowDateTime;

	// We need to go from "100-nano seconds" to milliseconds
	val *= 0.0001;
	TCHAR wTemp[100];
	_stprintf(wTemp, _T("%I64i"), val);

	return CHString(wTemp);
}

/*****************************************************************************
 *
 *  FUNCTION    : Process ::DeleteInstance
 *
 *  DESCRIPTION : Deletes an instance of a class
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Process :: DeleteInstance (

	const CInstance &a_Instance,
	long a_Flags /*= 0L*/
)
{
	HRESULT t_Result = S_OK ;

	CHString t_Handle ;
	if ( a_Instance.GetCHString ( PROPERTY_NAME_PROCESSHANDLE , t_Handle ) && ! t_Handle.IsEmpty () )
	{
		DWORD t_ProcessId = 0;

		if ( swscanf ( t_Handle , L"%lu" , &t_ProcessId ))
		{
			TCHAR buff[20];
			_ultot(t_ProcessId, buff, 10);

			if (t_Handle == buff)
			{
				if ( t_ProcessId != 0 )
				{
					// Clear error
					SetLastError ( 0 ) ;

					SmartCloseHandle t_Handle = OpenProcess ( PROCESS_TERMINATE , FALSE , t_ProcessId ) ;
					if ( t_Handle )
					{
						BOOL t_Status = TerminateProcess ( t_Handle, 0 ) ;
						if ( ! t_Status )
						{
							t_Result = GetProcessResultCode () ;
							if ( t_Result == WBEM_E_INVALID_PARAMETER )
							{
								t_Result = WBEM_E_NOT_FOUND ;
							}
						}
					}
					else
					{
						t_Result = GetProcessResultCode () ;
						if ( t_Result == WBEM_E_INVALID_PARAMETER )
						{
							t_Result = WBEM_E_NOT_FOUND ;
						}
					}
				}
				else
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}
			}
			else
			{
				t_Result = WBEM_E_NOT_FOUND ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_OBJECT_PATH ;
	}

	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : Process::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Process::ExecMethod (

	const CInstance& a_Instance,
	const BSTR a_MethodName ,
	CInstance *a_InParams ,
	CInstance *a_OutParams ,
	long a_Flags
)
{
	if ( ! a_OutParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

   // Do we recognize the method?

	if ( _wcsicmp ( a_MethodName , METHOD_NAME_CREATE ) == 0 )
	{
		return ExecCreate ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_TERMINATE ) == 0 )
	{
		return ExecTerminate ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_GETOWNER ) == 0 )
	{
		return ExecGetOwner ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_GETOWNERSID ) == 0 )
	{
		return ExecGetOwnerSid ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
    else if ( _wcsicmp ( a_MethodName , METHOD_NAME_SETPRIORITY ) == 0 )
	{
		return ExecSetPriority ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
    else if ( _wcsicmp ( a_MethodName , METHOD_NAME_ATTACHDEBUGGER ) == 0 )
	{
		return ExecAttachDebugger ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}


	return WBEM_E_INVALID_METHOD;
}

DWORD Process :: GetProcessErrorCode ()
{
	DWORD t_Status ;
	DWORD t_Error = GetLastError() ;

	switch ( t_Error )
	{
		case ERROR_INVALID_HANDLE:
		{
			t_Status = Process_STATUS_UNKNOWN_FAILURE ;
		}
		break ;

		case ERROR_PATH_NOT_FOUND:
		case ERROR_FILE_NOT_FOUND:
		{
			t_Status = Process_STATUS_PATH_NOT_FOUND ;
		}
		break ;

		case ERROR_ACCESS_DENIED:
		{
			t_Status = Process_STATUS_ACCESS_DENIED ;
		}
		break ;

		case ERROR_INVALID_PARAMETER:
		{
			t_Status = Process_STATUS_INVALID_PARAMETER ;
		}
		break;

		case ERROR_PRIVILEGE_NOT_HELD:
		{
			t_Status = Process_STATUS_INSUFFICIENT_PRIVILEGE ;
		}
		break ;

		default:
		{
			t_Status = Process_STATUS_UNKNOWN_FAILURE ;
		}
		break ;
	}

	return t_Status ;
}

HRESULT Process :: GetProcessResultCode ()
{
	HRESULT t_Result ;
	DWORD t_Error = GetLastError() ;
	switch ( t_Error )
	{
		case ERROR_ACCESS_DENIED:
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
		break ;

		case ERROR_INVALID_PARAMETER:
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
		break ;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	return t_Result ;
}

DWORD Process :: GetSid ( HANDLE a_TokenHandle , CHString &a_Sid )
{
	DWORD t_Status = S_OK ;

	TOKEN_USER *t_TokenUser = NULL ;
	DWORD t_ReturnLength = 0 ;
	TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

	BOOL t_TokenStatus = GetTokenInformation (

		a_TokenHandle ,
		t_TokenInformationClass ,
		NULL ,
		0 ,
		& t_ReturnLength
	) ;

	if ( ! t_TokenStatus && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
	{
		t_TokenUser = ( TOKEN_USER * ) new UCHAR [ t_ReturnLength ] ;
		if ( t_TokenUser )
		{
			try
			{
				t_TokenStatus = GetTokenInformation (

					a_TokenHandle ,
					t_TokenInformationClass ,
					( void * ) t_TokenUser ,
					t_ReturnLength ,
					& t_ReturnLength
				) ;

				if ( t_TokenStatus )
				{
					CSid t_Sid ( t_TokenUser->User.Sid ) ;
					if ( t_Sid.IsOK () )
					{
						a_Sid = t_Sid.GetSidString () ;
					}
					else
					{
						t_Status = GetProcessErrorCode () ;
					}
				}
				else
				{
					t_Status = GetProcessErrorCode () ;
				}
			}
			catch ( ... )
			{
				delete [] ( UCHAR * ) t_TokenUser ;

				throw ;
			}

			delete [] ( UCHAR * ) t_TokenUser ;

		}
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

	}
	else
	{
		t_Status = GetProcessErrorCode () ;
	}

	return t_Status ;
}

DWORD Process :: GetLogonSid ( HANDLE a_TokenHandle , PSID &a_Sid )
{
	DWORD t_Status = S_OK ;

	TOKEN_GROUPS *t_TokenGroups = NULL ;
	DWORD t_ReturnLength = 0 ;
	TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenGroups ;

	BOOL t_TokenStatus = GetTokenInformation (

		a_TokenHandle ,
		t_TokenInformationClass ,
		NULL ,
		0 ,
		& t_ReturnLength
	) ;

	if ( ! t_TokenStatus && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
	{
		t_TokenGroups = ( TOKEN_GROUPS * ) new UCHAR [ t_ReturnLength ] ;
		if ( t_TokenGroups )
		{
			try
			{
				t_TokenStatus = GetTokenInformation (

					a_TokenHandle ,
					t_TokenInformationClass ,
					( void * ) t_TokenGroups ,
					t_ReturnLength ,
					& t_ReturnLength
				) ;

				if ( t_TokenStatus )
				{
					t_Status = Process_STATUS_UNKNOWN_FAILURE ;

					for ( ULONG t_Index = 0; t_Index < t_TokenGroups->GroupCount; t_Index ++ )
					{
						DWORD t_Attributes = t_TokenGroups->Groups [ t_Index ].Attributes ;
						if ( ( t_Attributes & SE_GROUP_LOGON_ID ) ==  SE_GROUP_LOGON_ID )
						{
							DWORD t_Length = GetLengthSid ( t_TokenGroups->Groups [ t_Index ].Sid ) ;

							a_Sid = ( PSID ) new UCHAR [ t_Length ] ;
							if ( a_Sid )
							{
								CopySid ( t_Length , a_Sid , t_TokenGroups->Groups [ t_Index ].Sid ) ;
							}
							else
							{
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							}

							break ;
						}
					}
				}
				else
				{
					t_Status = GetProcessErrorCode () ;
				}
			}
			catch ( ... )
			{
				delete [] ( UCHAR * ) t_TokenGroups ;

				throw ;
			}

			delete [] ( UCHAR * ) t_TokenGroups ;

		}
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

	}


	return t_Status ;
}

DWORD Process :: GetAccount ( HANDLE a_TokenHandle , CHString &a_Domain , CHString &a_User )
{
	DWORD t_Status = S_OK ;

	TOKEN_USER *t_TokenUser = NULL ;
	DWORD t_ReturnLength = 0 ;
	TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

	BOOL t_TokenStatus = GetTokenInformation (

		a_TokenHandle ,
		t_TokenInformationClass ,
		NULL ,
		0 ,
		& t_ReturnLength
	) ;

	if ( ! t_TokenStatus && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
	{
		t_TokenUser = ( TOKEN_USER * ) new UCHAR [ t_ReturnLength ] ;

        if (t_TokenUser)
        {
            try
            {
		        t_TokenStatus = GetTokenInformation (

			        a_TokenHandle ,
			        t_TokenInformationClass ,
			        ( void * ) t_TokenUser ,
			        t_ReturnLength ,
			        & t_ReturnLength
		        ) ;

		        if ( t_TokenStatus )
		        {
			        CSid t_Sid ( t_TokenUser->User.Sid ) ;
			        if ( t_Sid.IsOK () )
			        {
				        a_Domain = t_Sid.GetDomainName () ;
				        a_User = t_Sid.GetAccountName () ;
			        }
			        else
			        {
				        t_Status = GetProcessErrorCode () ;
			        }
		        }
		        else
		        {
			        t_Status = GetProcessErrorCode () ;
		        }
            }
            catch ( ... )
            {
    			delete [] ( UCHAR * ) t_TokenUser ;
                throw;
            }

			delete [] ( UCHAR * ) t_TokenUser ;
        }
        else
        {
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
	}
	else
	{
		t_Status = GetProcessErrorCode () ;
	}

	return t_Status ;
}

DWORD Process :: GetImpersonationStatus (

	HANDLE a_TokenHandle ,
	SECURITY_IMPERSONATION_LEVEL &a_Level ,
	TOKEN_TYPE &a_Token
)
{
	DWORD t_Status = S_OK ;
	DWORD t_ReturnLength = 0 ;
	BOOL t_TokenStatus = GetTokenInformation (

		a_TokenHandle ,
		TokenType ,
		( void * ) & a_Token ,
		sizeof ( a_Token ) ,
		& t_ReturnLength
	) ;

	if ( t_TokenStatus )
	{
		if ( a_Token == TokenImpersonation )
		{
			BOOL t_TokenStatus = GetTokenInformation (

				a_TokenHandle ,
				TokenImpersonationLevel ,
				( void * ) & a_Level ,
				sizeof ( a_Level ) ,
				& t_ReturnLength
			) ;

			if ( t_TokenStatus )
			{
			}
			else
			{
				t_Status = GetProcessErrorCode () ;
			}
		}
	}
	else
	{
		t_Status = GetProcessErrorCode () ;
	}

	return t_Status ;
}

DWORD Process :: EnableDebug ( HANDLE &a_Token )
{
    BOOL t_Status = OpenThreadToken (

		GetCurrentThread(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
		FALSE,
        &a_Token
	) ;

	if ( ! t_Status )
	{
		t_Status = OpenProcessToken (

			GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &a_Token
		) ;

		if ( ! t_Status )
		{
			DWORD t_ErrorCode = GetProcessErrorCode () ;
			if ( t_ErrorCode == Process_STATUS_INVALID_PARAMETER )
			{
				t_ErrorCode = Process_STATUS_PATH_NOT_FOUND ;
			}

			return t_ErrorCode ;
		}
    }

    //
    // Enable the SE_DEBUG_NAME privilege
    //

	if ( ! t_Status )
	{
		return GetProcessErrorCode () ;
    }

	try
	{
		LUID t_Luid ;
		{
			t_Status = LookupPrivilegeValue (

				(LPTSTR) NULL,
				SE_DEBUG_NAME,
				&t_Luid
			) ;
		}

		if ( ! t_Status )
		{
			CloseHandle ( a_Token ) ;

			return GetProcessErrorCode () ;
		}

		TOKEN_PRIVILEGES t_Privilege ;

		t_Privilege.PrivilegeCount = 1;
		t_Privilege.Privileges[0].Luid = t_Luid ;
		t_Privilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

		AdjustTokenPrivileges (

			a_Token ,
			FALSE ,
			& t_Privilege ,
			sizeof ( TOKEN_PRIVILEGES ) ,
			( PTOKEN_PRIVILEGES ) NULL ,
			( PDWORD) NULL
		) ;
	}
	catch ( ... )
	{
		CloseHandle ( a_Token ) ;

		throw ;
	}

    //
    // The return value of AdjustTokenPrivileges can't be tested
    //

    if ( GetLastError () != ERROR_SUCCESS )
	{
		return GetProcessErrorCode () ;
    }

	return Process_STATUS_SUCCESS ;
}

DWORD Process :: GetSidOrAccount (const CInstance &a_Instance ,CInstance *a_OutParams , DWORD a_ProcessId , BOOL a_Sid )
{
	DWORD t_Status = Process_STATUS_SUCCESS ;

	    // Require the SE_DEBUG_NAME privilege...
    CTokenPrivilege	debugPrivilege(SE_DEBUG_NAME);
	BOOL fDisablePrivilege = FALSE;
	BOOL fTryWinstation = FALSE;

	fDisablePrivilege = (debugPrivilege.Enable() == ERROR_SUCCESS);

	SetLastError ( 0 ) ;
	SmartCloseHandle t_Handle = OpenProcess ( PROCESS_QUERY_INFORMATION , FALSE , ( ( a_ProcessId ) ? a_ProcessId : 4 ) ) ;

	if ( t_Handle )
	{

		SmartCloseHandle t_TokenHandle;
		BOOL t_TokenStatus = OpenProcessToken (

			t_Handle ,
			TOKEN_QUERY ,
			& t_TokenHandle
		) ;

		if ( t_TokenStatus )
		{
			if ( a_Sid )
			{
				CHString t_SidString ;
				t_Status = GetSid ( t_TokenHandle , t_SidString ) ;
				if ( t_Status == 0 )
				{
					a_OutParams->SetCHString( METHOD_ARG_NAME_SID , t_SidString ) ;
				}
			}
			else
			{
				CHString t_DomainString ;
				CHString t_UserString ;

				t_Status = GetAccount ( t_TokenHandle , t_DomainString , t_UserString );
				if ( t_Status == 0 )
				{
					a_OutParams->SetCHString( METHOD_ARG_NAME_DOMAIN , t_DomainString ) ;
					a_OutParams->SetCHString( METHOD_ARG_NAME_USER , t_UserString ) ;
				}

			}
		}
		else
		{
			fTryWinstation = TRUE;
			DWORD t_ErrorCode = GetProcessErrorCode () ;
			if ( t_ErrorCode == Process_STATUS_INVALID_PARAMETER )
			{
				t_ErrorCode = Process_STATUS_PATH_NOT_FOUND ;
			}

			t_Status = t_ErrorCode ;
		}
	}
	else
	{
		fTryWinstation = TRUE;
		DWORD t_ErrorCode = GetProcessErrorCode () ;
		if ( t_ErrorCode == Process_STATUS_INVALID_PARAMETER )
		{
			t_ErrorCode = Process_STATUS_PATH_NOT_FOUND ;
		}

		t_Status = t_ErrorCode ;
	}

#if NTONLY >= 5
	if (fTryWinstation)
	{
        HMODULE hWinstaDLL = LoadLibrary( L"winsta.dll" );
		pfnWinStationGetProcessSid myWinStationGetProcessSid = NULL;

        if( hWinstaDLL != NULL)
        {
            myWinStationGetProcessSid = ( pfnWinStationGetProcessSid )GetProcAddress(hWinstaDLL, "WinStationGetProcessSid");
		}

		SYSTEM_PROCESS_INFORMATION *t_ProcessBlock = NULL ;

		CNtDllApi *pNtdll = ( CNtDllApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidNtDllApi, NULL ) ;
		HRESULT hRetCode = 0;


		if ( pNtdll && myWinStationGetProcessSid )
		{
			try
			{
				t_ProcessBlock = RefreshProcessCacheNT ( *pNtdll , a_Instance.GetMethodContext () , & hRetCode ) ;

				if ( SUCCEEDED ( hRetCode ) )
				{
					SYSTEM_PROCESS_INFORMATION *t_CurrentInformation = GetProcessBlock ( *pNtdll , t_ProcessBlock , a_ProcessId ) ;

					if ( t_CurrentInformation )
					{
						BYTE tmpSid [128];
						DWORD dwSidSize = sizeof(tmpSid);
						CSmartBuffer pBuff;
						PSID pSid = NULL;

						if (!myWinStationGetProcessSid(NULL,
													 a_ProcessId,
													 * ( FILETIME * ) ( & t_CurrentInformation->CreateTime.u ),
													 (PBYTE)&tmpSid,
													 &dwSidSize
													))
						{
							//-------------------------------------------//
							// Sid is too big for the temp storage       //
							//Get the size of the sid and do it again    //
							//-------------------------------------------//
							if (GetLastError() == STATUS_BUFFER_TOO_SMALL)
							{
								pBuff = new BYTE[dwSidSize];

								//-------------------------------------------//
								// Call the server again to get the SID
								//-------------------------------------------//
								if (myWinStationGetProcessSid(NULL,
															 a_ProcessId,
															 * ( FILETIME * ) ( & t_CurrentInformation->CreateTime.u ),
															 (PBYTE)pBuff,
															 &dwSidSize
															))
								{
									pSid = (PSID) ((PBYTE)pBuff);
								}
							}
						}
						else
						{
							pSid = (PSID) tmpSid;
						}

						if (pSid)
						{
							CSid t_Sid ( pSid ) ;

							if ( t_Sid.IsOK () )
							{
								if ( a_Sid )
								{
									a_OutParams->SetCHString( METHOD_ARG_NAME_SID , t_Sid.GetSidString () );
								}
								else
								{
									a_OutParams->SetCHString( METHOD_ARG_NAME_DOMAIN , t_Sid.GetDomainName () ) ;
									a_OutParams->SetCHString( METHOD_ARG_NAME_USER , t_Sid.GetAccountName () ) ;
								}

								t_Status = 0;
							}
						}
					}
				}
			}
			catch ( ... )
			{
				CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtdll ) ;

				if ( t_ProcessBlock )
				{
					delete []  t_ProcessBlock;
				}

				if (hWinstaDLL)
				{
					FreeLibrary(hWinstaDLL);
				}

				throw ;
			}
		}

		if ( t_ProcessBlock )
		{
			delete []  t_ProcessBlock;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtdll ) ;

		if (hWinstaDLL)
		{
			FreeLibrary(hWinstaDLL);
		}
	}
#endif

    // Disable debug privilege if we enabeled it...
    if(fDisablePrivilege)
    {
        debugPrivilege.Enable(FALSE);
    }

	return t_Status ;
}

DWORD Process :: Creation (

	CInstance *a_OutParams ,
	HANDLE a_TokenHandle ,
	CHString a_CmdLine ,
	BOOL a_WorkingDirectorySpecified ,
	CHString a_WorkingDirectory ,
	TCHAR *a_EnvironmentBlock ,
	BOOL a_ErrorModeSpecified ,
	DWORD a_ErrorMode ,
	DWORD a_CreationFlags ,
	BOOL a_StartupSpecified ,
	STARTUPINFO a_StartupInformation
)
{
	DWORD t_Status = Process_STATUS_SUCCESS ;

	bstr_t t_CommandLine(a_CmdLine);

	PROCESS_INFORMATION t_ProcessInformation;

#if 0
	UINT t_ErrorMode = SetErrorMode ( a_ErrorMode ) ;
#endif

	const WCHAR *t_Const = a_WorkingDirectory ;

#ifdef NTONLY
	{

		t_Status = CreateProcessAsUser (

			a_TokenHandle ,
			NULL ,
			( LPTSTR ) t_CommandLine,
			NULL ,
			NULL ,
			FALSE ,
			a_CreationFlags ,
			a_EnvironmentBlock ,
			a_WorkingDirectorySpecified ? t_Const : NULL  ,
			& a_StartupInformation ,
			&t_ProcessInformation
		) ;
	}
#endif

#if 0
	SetErrorMode ( t_ErrorMode ) ;
#endif

	if ( t_Status )
	{
		CloseHandle ( t_ProcessInformation.hProcess ) ;
		CloseHandle ( t_ProcessInformation.hThread ) ;

		t_Status = Process_STATUS_SUCCESS ;

		a_OutParams->SetDWORD ( METHOD_ARG_NAME_PROCESSID , t_ProcessInformation.dwProcessId ) ;
	}
	else
	{
		t_Status = GetProcessErrorCode () ;
	}

	return t_Status ;
}

typedef BOOL  (WINAPI *PFN_DUPLICATETOKENEX ) (  HANDLE ,					// handle to token to duplicate
										DWORD ,								// access rights of new token
										LPSECURITY_ATTRIBUTES ,				// security attributes of the new token
										SECURITY_IMPERSONATION_LEVEL ,		// impersonation level of new token
										TOKEN_TYPE ,						// primary or impersonation token
										PHANDLE )	;						// handle to duplicated token


DWORD Process :: ProcessCreation (

	CInstance *a_OutParams ,
	CHString a_CmdLine ,
	BOOL a_WorkingDirectorySpecified ,
	CHString a_WorkingDirectory ,
	TCHAR *&a_EnvironmentBlock ,
	BOOL a_ErrorModeSpecified ,
	DWORD a_ErrorMode ,
	DWORD a_CreationFlags ,
	BOOL a_StartupSpecified ,
	STARTUPINFO a_StartupInformation
)
{
#ifdef NTONLY
	DWORD t_Status = Process_STATUS_SUCCESS ;
	DWORD dwCheckKeyPresentStatus ;

	SmartCloseHandle t_TokenPrimaryHandle ;
	SmartCloseHandle t_TokenImpersonationHandle;

	BOOL t_TokenStatus = OpenThreadToken (

		GetCurrentThread () ,
		TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY  ,
		TRUE ,
		& t_TokenImpersonationHandle
	) ;

	if ( t_TokenStatus )
	{
		CAdvApi32Api *t_pAdvApi32 = NULL;
        t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
		if(t_pAdvApi32 == NULL)
		{
			return Process_STATUS_UNKNOWN_FAILURE ;
		}
        else
        {
		    t_pAdvApi32->DuplicateTokenEx (t_TokenImpersonationHandle ,
			                                               TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY ,
			                                               NULL,
			                                               SecurityImpersonation,
			                                               TokenPrimary ,
			                                               &t_TokenPrimaryHandle, &t_TokenStatus );

		    CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
            t_pAdvApi32 = NULL;
        }
	}

	if ( t_TokenStatus )
	{
		CHString t_Domain ;
		CHString t_User ;

		t_Status = GetAccount ( t_TokenImpersonationHandle , t_Domain , t_User ) ;
		if ( t_Status == 0 )
		{
			CHString t_Account = t_Domain + CHString ( _T("\\") ) + t_User ;

			CHString chsSID ;
			CUserHive t_Hive ;
			TCHAR t_KeyName [ 1024 ] ;

			if( (t_Status = GetSid(t_TokenImpersonationHandle,chsSID) ) == Process_STATUS_SUCCESS )
			{

				CRegistry Reg ;
				//check if SID already present under HKEY_USER ...
				dwCheckKeyPresentStatus = Reg.Open(HKEY_USERS, chsSID, KEY_READ) ;
				Reg.Close() ;

				if(dwCheckKeyPresentStatus != ERROR_SUCCESS)
				{
					t_Status = t_Hive.Load ( t_Account , t_KeyName, 1024 ) ;
				}
/*
 * If the DCOM client has never logged on to the machine, we can't load his hive.
 * In this case, we allow the process creation to continue
 * From MSDN: If the user's hive is not loaded, the system will map references pertaining to HKEY_CURRENT_USER to HKEY_USER\.default.
 */
				if ( t_Status == ERROR_FILE_NOT_FOUND )
				{
					t_Status = ERROR_SUCCESS ;
					dwCheckKeyPresentStatus = ERROR_SUCCESS ;
				}

				if ( t_Status == ERROR_SUCCESS ) // rt. now is equal to Process_STATUS_SUCCESS--->GetSid
				{
					try
					{
						LPVOID t_Environment = NULL ;

#ifdef NTONLY
						CUserEnvApi *pUserEnv = NULL ;

						if ( !a_EnvironmentBlock )
						{
							pUserEnv = ( CUserEnvApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidUserEnvApi, NULL ) ;
							if ( pUserEnv )
							{
								BOOL t_EnvironmentCreated = pUserEnv->CreateEnvironmentBlock (

									& t_Environment ,
									t_TokenPrimaryHandle ,
									FALSE
								);

								if ( ! t_EnvironmentCreated )
								{
									t_Status = Process_STATUS_UNKNOWN_FAILURE ;
									DWORD t_Error = GetLastError () ;
								}
							}
							else
							{
								t_Status = Process_STATUS_UNKNOWN_FAILURE ;
								DWORD t_Error = GetLastError () ;
							}
						}

#else
						if ( !a_EnvironmentBlock )
						{
							t_Status = GetEnvBlock ( chsSID, t_User, t_Domain , a_EnvironmentBlock ) ;
						}
#endif

						if( t_Status == ERROR_SUCCESS )
						{
							t_Status = Creation (

								a_OutParams ,
								t_TokenPrimaryHandle ,
								a_CmdLine ,
								a_WorkingDirectorySpecified ,
								a_WorkingDirectory ,
								a_EnvironmentBlock ? a_EnvironmentBlock : ( TCHAR * ) t_Environment ,
								a_ErrorModeSpecified ,
								a_ErrorMode ,
								a_CreationFlags ,
								a_StartupSpecified ,
								a_StartupInformation
							) ;
						}

#ifdef NTONLY
						if ( t_Environment )
						{
							pUserEnv->DestroyEnvironmentBlock ( t_Environment ) ;
						}

						if ( pUserEnv )
						{
							CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidUserEnvApi, pUserEnv ) ;
						}
#endif

					}
					catch ( ... )
					{
						//remove the key if it wasn't there b4....
						if(dwCheckKeyPresentStatus != ERROR_SUCCESS )
						{
							t_Hive.Unload ( t_KeyName ) ;
						}

						throw;
					}

					//remove the key if it wasn't there b4....
					if(dwCheckKeyPresentStatus != ERROR_SUCCESS )
					{
						t_Hive.Unload ( t_KeyName ) ;
					}

				}
				else
				{
					t_Status = GetProcessErrorCode () ;
				}
			}
		}
	}
	else
	{
		t_Status = GetProcessErrorCode () ;
	}

	return t_Status ;
#endif
}

HRESULT Process :: CheckProcessCreation (

	CInstance *a_InParams ,
	CInstance *a_OutParams ,
	DWORD &a_Status
)
{
	HRESULT t_Result = S_OK ;

	bool t_Exists ;
	VARTYPE t_Type ;

	CHString t_CmdLine ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_COMMANDLINE , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_InParams->GetCHString ( METHOD_ARG_NAME_COMMANDLINE , t_CmdLine ) && ! t_CmdLine.IsEmpty () )
			{
			}
			else
			{
// Zero Length string

				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
		else
		{
			a_Status = Process_STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = Process_STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_WorkingDirectorySpecified = false ;
	CHString t_WorkingDirectory ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_CURRENTDIRECTORY , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				t_WorkingDirectorySpecified = false ;
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_CURRENTDIRECTORY , t_WorkingDirectory ) && ! t_WorkingDirectory.IsEmpty () )
				{
					t_WorkingDirectorySpecified = true ;
				}
				else
				{
// Zero Length string

					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = Process_STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = Process_STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	CInstancePtr t_EmbeddedObject;

	bool t_StartupSpecified = true ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_PROCESSTARTUPINFORMATION , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_UNKNOWN || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				t_StartupSpecified = false ;
			}
			else
			{
				if ( a_InParams->GetEmbeddedObject ( METHOD_ARG_NAME_PROCESSTARTUPINFORMATION , &t_EmbeddedObject , a_InParams->GetMethodContext () ) )
				{
					t_StartupSpecified = true ;
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = Process_STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = Process_STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

/*
 * Release CInstance when Stack goes out of scope.
 */

	if ( t_StartupSpecified )
	{
		CHString t_ClassProperty ( IDS___Class ) ;
		if ( t_EmbeddedObject->GetStatus ( t_ClassProperty , t_Exists , t_Type ) )
		{
			if ( t_Exists && ( t_Type == VT_BSTR ) )
			{
				CHString t_Class ;
				if ( t_EmbeddedObject->GetCHString ( t_ClassProperty , t_Class ) )
				{
					if ( t_Class.CompareNoCase ( PROPSET_NAME_PROCESSSTARTUP ) != 0 )
					{
						a_Status = Process_STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
	}

	bool t_ErrorModeSpecified = false ;
	DWORD t_ErrorMode = 0 ;
	DWORD t_CreationFlags = 0 ;
	DWORD t_PriorityFlags = 0 ;
	TCHAR *t_EnvironmentBlock = NULL ;
	STARTUPINFO t_StartupInformation ;
/*
 *	NOTE:	(RAID #48587). On optimized builds it's seen that the statement
			t_StartupInformation.dwFlags = t_StartupInformation.dwFlags | STARTF_USESHOWWINDOW ;
			doesn't update t_StartupInformation.dwFlags with the result of the bitwise OR opeartion.
			ZeroMemorying the structure however, updates the t_StartupInformation.dwFlags with the new value(!!!)
*/

	ZeroMemory ( &t_StartupInformation , sizeof ( t_StartupInformation ) ) ;

	t_StartupInformation.cb = sizeof ( STARTUPINFO ) ;
	t_StartupInformation.lpReserved = NULL ;
	t_StartupInformation.lpReserved2 = NULL ;
	t_StartupInformation.cbReserved2 = 0 ;

	CHString t_Title ;
	CHString t_Desktop ;

	t_StartupInformation.lpTitle = NULL ;
	t_StartupInformation.lpDesktop = PROPERTY_VALUE_DESKTOP_WIN0DEFAULT ;
	t_StartupInformation.dwX = 0 ;
	t_StartupInformation.dwY = 0 ;
	t_StartupInformation.dwXSize = 0 ;
	t_StartupInformation.dwYSize = 0 ;
	t_StartupInformation.dwXCountChars = 0 ;
	t_StartupInformation.dwYCountChars = 0 ;
	t_StartupInformation.dwFillAttribute = 0 ;
	t_StartupInformation.dwFlags = 0 ;
	t_StartupInformation.wShowWindow = SW_SHOW ;
	t_StartupInformation.hStdInput = NULL ;
	t_StartupInformation.hStdOutput = NULL ;
	t_StartupInformation.hStdError = NULL ;

	SAFEARRAY *t_SafeArray = NULL ;

	try
	{
		if ( t_StartupSpecified )
		{
	#if 0

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_ERRORMODE , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
						t_ErrorModeSpecified = false ;
					}
					else
					{
						DWORD t_Error = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_ERRORMODE , t_Error ) )
						{
							t_ErrorMode = t_Error ;

							t_ErrorModeSpecified = true ;
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

	#endif

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_CREATIONFLAGS , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
					}
					else
					{
						DWORD t_Flags = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_CREATIONFLAGS , t_Flags ) )
						{
							if( ( !t_Flags ) || ( ! ( t_Flags & ( CREATIONFLAGS ) ) ) )
							{
								a_Status = Process_STATUS_INVALID_PARAMETER ;
								return t_Result ;
							}
							t_CreationFlags = t_Flags ;
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_PRIORITYCLASS , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
						t_CreationFlags = t_CreationFlags | NORMAL_PRIORITY_CLASS ;
					}
					else
					{
						DWORD t_Flags = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_PRIORITYCLASS , t_Flags ) )
						{
							switch( t_Flags )
							{
								case NORMAL_PRIORITY_CLASS: { t_CreationFlags |= NORMAL_PRIORITY_CLASS; break; }
								case IDLE_PRIORITY_CLASS: { t_CreationFlags |= IDLE_PRIORITY_CLASS; break; }
								case HIGH_PRIORITY_CLASS: { t_CreationFlags |= HIGH_PRIORITY_CLASS; break; }
								case REALTIME_PRIORITY_CLASS: { t_CreationFlags |= REALTIME_PRIORITY_CLASS; break; }
								case BELOW_NORMAL_PRIORITY_CLASS: { t_CreationFlags |= BELOW_NORMAL_PRIORITY_CLASS; break; }
								case ABOVE_NORMAL_PRIORITY_CLASS: { t_CreationFlags |= ABOVE_NORMAL_PRIORITY_CLASS; break; }
								default:
								{
									a_Status = Process_STATUS_INVALID_PARAMETER ;
									return t_Result ;
								}
							}
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_FILLATTRIBUTE , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
					}
					else
					{
						DWORD t_Flags = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_FILLATTRIBUTE , t_Flags ) )
						{
							t_StartupInformation.dwFillAttribute = t_Flags ;

							t_StartupInformation.dwFlags = t_StartupInformation.dwFlags | STARTF_USEFILLATTRIBUTE ;
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_X , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
					}
					else
					{
						DWORD t_X = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_X , t_X ) )
						{
							t_StartupInformation.dwX = t_X ;
							t_StartupInformation.dwFlags = t_StartupInformation.dwFlags | STARTF_USEPOSITION ;
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_Y , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
						if ( t_StartupInformation.dwFlags & STARTF_USEPOSITION )
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
					else
					{
						DWORD t_Y = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_Y , t_Y ) )
						{
							if ( t_StartupInformation.dwFlags & STARTF_USEPOSITION )
							{
								t_StartupInformation.dwY = t_Y ;
							}
							else
							{
								a_Status = Process_STATUS_INVALID_PARAMETER ;
								return t_Result ;
							}
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_XSIZE , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
					}
					else
					{
						DWORD t_XSize = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_XSIZE , t_XSize ) )
						{
							t_StartupInformation.dwXSize = t_XSize ;
							t_StartupInformation.dwFlags = t_StartupInformation.dwFlags | STARTF_USESIZE ;
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_YSIZE , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
						if ( t_StartupInformation.dwFlags & STARTF_USESIZE )
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
					else
					{
						DWORD t_Y = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_YSIZE , t_Y ) )
						{
							if ( t_StartupInformation.dwFlags & STARTF_USESIZE )
							{
								t_StartupInformation.dwYSize = t_Y ;
							}
							else
							{
								a_Status = Process_STATUS_INVALID_PARAMETER ;
								return t_Result ;
							}
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_XCOUNTCHARS , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
					}
					else
					{
						DWORD t_XCountChars = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_XCOUNTCHARS , t_XCountChars ) )
						{
							t_StartupInformation.dwXCountChars = t_XCountChars ;
							t_StartupInformation.dwFlags = t_StartupInformation.dwFlags | STARTF_USECOUNTCHARS ;
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_YCOUNTCHARS , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
						if ( t_StartupInformation.dwFlags & STARTF_USECOUNTCHARS )
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
					else
					{
						DWORD t_YCountChars = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_YCOUNTCHARS , t_YCountChars ) )
						{
							if ( t_StartupInformation.dwFlags & STARTF_USECOUNTCHARS )
							{
								t_StartupInformation.dwYCountChars = t_YCountChars ;
							}
							else
							{
								a_Status = Process_STATUS_INVALID_PARAMETER ;
								return t_Result ;
							}
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_SHOWWINDOW , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
					}
					else
					{
						DWORD t_Flags = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_SHOWWINDOW , t_Flags ) )
						{
							t_StartupInformation.wShowWindow = t_Flags ;
							t_StartupInformation.dwFlags = t_StartupInformation.dwFlags | STARTF_USESHOWWINDOW ;
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_TITLE , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
					}
					else
					{
						if ( t_EmbeddedObject->GetCHString ( PROPERTY_NAME_TITLE , t_Title ) )
						{
							//const TCHAR *t_Const = (LPCTSTR) t_Title ;
							t_StartupInformation.lpTitle = (LPTSTR) (LPCTSTR) TOBSTRT(t_Title);
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_ENVIRONMENTVARIABLES , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( ( t_Type == ( VT_BSTR | VT_ARRAY ) ) || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
					}
					else
					{
						if ( t_EmbeddedObject->GetStringArray ( PROPERTY_NAME_ENVIRONMENTVARIABLES , t_SafeArray ) )
						{
							if ( t_SafeArray )
							{
								if ( SafeArrayGetDim ( t_SafeArray ) == 1 )
								{
									LONG t_Dimension = 1 ;
									LONG t_LowerBound ;
									SafeArrayGetLBound ( t_SafeArray , t_Dimension , & t_LowerBound ) ;
									LONG t_UpperBound ;
									SafeArrayGetUBound ( t_SafeArray , t_Dimension , & t_UpperBound ) ;

									ULONG t_BufferLength = 0 ;

									for ( LONG t_Index = t_LowerBound ; t_Index <= t_UpperBound ; t_Index ++ )
									{
										BSTR t_Element ;
										HRESULT t_Result = SafeArrayGetElement ( t_SafeArray , &t_Index , & t_Element ) ;
										if ( t_Result == S_OK )
										{
											try
											{
												CHString t_String ( t_Element ) ;
												t_BufferLength += lstrlen ( _bstr_t ( ( LPCWSTR ) t_String ) ) + 1 ;
											}
											catch ( ... )
											{
												SysFreeString ( t_Element ) ;

												throw ;
											}

											SysFreeString ( t_Element ) ;
										}
										else
										{
											throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
										}
									}

									t_BufferLength ++ ;

									t_EnvironmentBlock = new TCHAR [ t_BufferLength ] ;
									if ( t_EnvironmentBlock )
									{
										t_BufferLength = 0 ;

										for ( t_Index = t_LowerBound ; t_Index <= t_UpperBound ; t_Index ++ )
										{
											BSTR t_Element ;

											HRESULT t_Result = SafeArrayGetElement ( t_SafeArray , &t_Index , & t_Element ) ;
											if ( t_Result == S_OK )
											{
												try
												{
													CHString t_String ( t_Element ) ;

													_tcscpy ( & t_EnvironmentBlock [ t_BufferLength ] , TOBSTRT(t_String));

													t_BufferLength += lstrlen ( _bstr_t ( ( LPCWSTR ) t_String ) ) + 1 ;

												}
												catch ( ... )
												{
													SysFreeString ( t_Element ) ;

													throw ;
												}

												SysFreeString ( t_Element ) ;
											}
											else
											{
												throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
											}
										}

										t_EnvironmentBlock [ t_BufferLength ] = 0 ;
									}
									else
									{
										throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
									}
								}
								else
								{
									a_Status = Process_STATUS_INVALID_PARAMETER ;
								}
							}
							else
							{
								a_Status = Process_STATUS_INVALID_PARAMETER ;
							}

							SafeArrayDestroy ( t_SafeArray ) ;
                            t_SafeArray = NULL;

						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}
		}
/*
 * passing unicode environment strings on 9x doesn't work, though the documentation doesn't say anything about this.
 */
#ifdef NTONLY
		t_CreationFlags |= CREATE_UNICODE_ENVIRONMENT ;
#endif
		if ( a_Status == Process_STATUS_SUCCESS )
		{
			a_Status = ProcessCreation (

				a_OutParams ,
				t_CmdLine ,
				t_WorkingDirectorySpecified ,
				t_WorkingDirectory ,
				t_EnvironmentBlock ,
				t_ErrorModeSpecified ,
				t_ErrorMode ,
				t_CreationFlags ,
				t_StartupSpecified ,
				t_StartupInformation
			) ;
		}
	}
	catch ( ... )
	{
		if ( t_EnvironmentBlock )
			delete [] t_EnvironmentBlock ;

        if ( t_SafeArray )
		    SafeArrayDestroy ( t_SafeArray ) ;

		throw  ;
	}

	if ( t_EnvironmentBlock )
		delete [] t_EnvironmentBlock ;

	return t_Result ;
}

HRESULT Process :: ExecCreate (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;
	DWORD t_Status = Process_STATUS_SUCCESS ;

	if ( a_InParams && a_OutParams )
	{
		t_Result = CheckProcessCreation (

			a_InParams ,
			a_OutParams ,
			t_Status
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_Status ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}


HRESULT Process :: ExecTerminate (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	if ( a_InParams && a_OutParams )
	{
		bool t_Exists ;
		VARTYPE t_Type ;

		DWORD t_Flags = 0 ;
		if ( a_InParams->GetStatus ( METHOD_ARG_NAME_REASON , t_Exists , t_Type ) )
		{
			if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
			{
				if ( t_Type == VT_I4 )
				{
					if ( a_InParams->GetDWORD ( METHOD_ARG_NAME_REASON , t_Flags ) )
					{
					}
					else
					{
// Zero Length string

						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , Process_STATUS_INVALID_PARAMETER ) ;
						return t_Result ;
					}
				}
			}
			else
			{
				a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , Process_STATUS_INVALID_PARAMETER ) ;
				return t_Result ;
			}
		}
		else
		{
			a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , Process_STATUS_INVALID_PARAMETER ) ;
			return WBEM_E_PROVIDER_FAILURE ;
		}

		CHString t_ProcessHandle ;

		if ( a_Instance.GetCHString ( PROPERTY_NAME_PROCESSHANDLE , t_ProcessHandle ) )
		{
			DWORD t_ProcessId = 0;

			if ( swscanf ( t_ProcessHandle , L"%lu" , &t_ProcessId ) )
			{
				// Clear error
				SetLastError ( 0 ) ;

				SmartCloseHandle t_Handle = OpenProcess ( PROCESS_TERMINATE , FALSE , t_ProcessId ) ;
				if ( t_Handle )
				{
					BOOL t_Status = TerminateProcess ( t_Handle, t_Flags ) ;
					if ( t_Status )
					{
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , Process_STATUS_SUCCESS ) ;
					}
					else
					{
						DWORD t_ErrorCode = GetProcessErrorCode () ;
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_ErrorCode ) ;
					}
				}
				else
				{
					DWORD t_ErrorCode = GetProcessErrorCode () ;
					//if the process has terminated by this time, we'll get the following return code.
					if ( t_ErrorCode == Process_STATUS_INVALID_PARAMETER )
					{
						t_ErrorCode = Process_STATUS_PATH_NOT_FOUND ;
					}

					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_ErrorCode ) ;
				}

				t_Result = WBEM_S_NO_ERROR;
			}
			else
			{
				t_Result = WBEM_E_INVALID_OBJECT_PATH ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

HRESULT Process :: ExecGetOwnerSid (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

#ifdef NTONLY
	DWORD t_Status = Process_STATUS_SUCCESS ;
	if ( a_OutParams )
	{
		CHString t_Path ;
		CHString t_Prop ( IDS___Relpath ) ;

		if ( a_Instance.GetCHString ( t_Prop ,  t_Path ) )
		{
			CHString t_Namespace ( IDS_CimWin32Namespace ) ;

			DWORD t_BufferSize = MAX_COMPUTERNAME_LENGTH + 1;
			TCHAR t_ComputerName [ MAX_COMPUTERNAME_LENGTH + 1 ] ;

			ProviderGetComputerName ( t_ComputerName , & t_BufferSize ) ;

			CHString t_Computer ( t_ComputerName ) ;

			CHString t_AbsPath = L"\\\\" + t_Computer + L"\\" + t_Namespace + L":" + t_Path ;

			CInstancePtr t_ObjectInstance;
			t_Result = CWbemProviderGlue :: GetInstanceByPath ( ( LPCTSTR ) t_AbsPath , & t_ObjectInstance, a_Instance.GetMethodContext() ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ProcessId ;

				if ( t_ObjectInstance->GetDWORD ( METHOD_ARG_NAME_PROCESSID , t_ProcessId ) )
				{
					t_Status = GetSidOrAccount (a_Instance, a_OutParams , t_ProcessId , TRUE ) ;
				}
				else
				{
					t_Status = Process_STATUS_INVALID_PARAMETER ;
				}
			}
			else
			{
			}
		}
		else
		{
			t_Result = WBEM_E_FAILED ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_Status ) ;
	}

	return t_Result ;
#endif
}


HRESULT Process :: ExecGetOwner (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

#ifdef NTONLY
	DWORD t_Status = Process_STATUS_SUCCESS ;

	if ( a_OutParams )
	{
		CHString t_Path ;
		CHString t_Prop ( IDS___Relpath ) ;

		if ( a_Instance.GetCHString ( t_Prop ,  t_Path ) )
		{
			CHString t_Namespace ( IDS_CimWin32Namespace ) ;

			DWORD t_BufferSize = MAX_COMPUTERNAME_LENGTH + 1;
			TCHAR t_ComputerName [ MAX_COMPUTERNAME_LENGTH + 1 ] ;

			ProviderGetComputerName ( t_ComputerName , & t_BufferSize ) ;

			CHString t_Computer ( t_ComputerName ) ;

			CHString t_AbsPath = L"\\\\" + t_Computer + L"\\" + t_Namespace + L":" + t_Path ;

			CInstancePtr t_ObjectInstance;
			t_Result = CWbemProviderGlue :: GetInstanceByPath ( ( LPCTSTR ) t_AbsPath , & t_ObjectInstance, a_Instance.GetMethodContext() ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ProcessId ;

				if ( t_ObjectInstance->GetDWORD ( METHOD_ARG_NAME_PROCESSID , t_ProcessId ) )
				{
					t_Status = GetSidOrAccount (a_Instance , a_OutParams , t_ProcessId , FALSE ) ;
				}
				else
				{
					t_Status = Process_STATUS_INVALID_PARAMETER ;
				}
			}
			else
			{
			}

		}
		else
		{
			t_Result = WBEM_E_FAILED ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_Status ) ;
	}

	return t_Result ;
#endif
}


HRESULT Process::ExecSetPriority(

	const CInstance& cinstProcess,
	CInstance *cinstInParams,
	CInstance *cinstOutParams,
	long lFlags)
{
	HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY

    DWORD dwError = ERROR_SUCCESS;
    if(cinstInParams && cinstOutParams)
    {
        // Get the process id...
        DWORD dwPID;
        DWORD dwNewPriority;
        bool fValidPriority = false;
        CHString chstrTmp;

        if(!cinstProcess.GetCHString(
               L"Handle",
               chstrTmp))
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }
        else
        {
            dwPID = wcstoul(chstrTmp, NULL, 10);
        }

        // Get the requested new priority...
        if(SUCCEEDED(hr))
        {
            if(!cinstInParams->GetDWORD(
                   METHOD_ARG_NAME_PRIORITY,
                   dwNewPriority))
            {
                hr = WBEM_E_INVALID_PARAMETER;
            }
        }

        // Validate the new value...
        if(SUCCEEDED(hr))
        {
            switch(dwNewPriority)
            {
                case IDLE_PRIORITY_CLASS:
                case BELOW_NORMAL_PRIORITY_CLASS:
                case NORMAL_PRIORITY_CLASS:
                case ABOVE_NORMAL_PRIORITY_CLASS:
                case HIGH_PRIORITY_CLASS:
                case REALTIME_PRIORITY_CLASS:
                    fValidPriority = true;
                break;
            }

            if(!fValidPriority)
            {
                hr = WBEM_E_INVALID_PARAMETER;
            }
        }

        // Set the thread priority...
        if(SUCCEEDED(hr))
        {
            SmartCloseHandle hProcess = ::OpenProcess(
                                  PROCESS_SET_INFORMATION, 
                                  FALSE, 
                                  dwPID);
            if(hProcess) 
            {
                if(!::SetPriorityClass(
                        hProcess, 
                        dwNewPriority)) 
                {
                    dwError = ::GetLastError();
                }
                
            }
            else
            {
                dwError = ::GetLastError();
            }
        }

        // Set the return value...
        if(SUCCEEDED(hr))
        {
		    cinstOutParams->SetDWORD(
                METHOD_ARG_NAME_RETURNVALUE, 
                dwError);
	    }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

#endif  // NTONLY

    return hr;
}


HRESULT Process::ExecAttachDebugger(

	const CInstance& cinstProcess,
	CInstance *cinstInParams,
	CInstance *cinstOutParams,
	long lFlags)
{
	HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY

    DWORD dwError = ERROR_SUCCESS;

    // Require the SE_DEBUG_NAME privilege...
    CTokenPrivilege	debugPrivilege(SE_DEBUG_NAME);
	BOOL fDisablePrivilege = FALSE;

	fDisablePrivilege = (debugPrivilege.Enable() == ERROR_SUCCESS);
    
    // Get the process id...
    DWORD dwPID;
    bool fValidPriority = false;
    CHString chstrTmp;

    if(!cinstProcess.GetCHString(
           L"Handle",
           chstrTmp))
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
        dwPID = wcstoul(chstrTmp, NULL, 10);
    }

    // Get the debug cmd line from the registry...
    CHString chstrDbgStr;
    if(SUCCEEDED(hr))
    {
        GetDebuggerString(chstrDbgStr);    
    }

    // Validate the new value...
    if(SUCCEEDED(hr))
    {
        if(chstrDbgStr.GetLength() == 0)
        {
            // Set an explanatory status
            // object...
            CHString chstrMsg;
            chstrMsg = "Missing or invalid registry debug string in HKEY_LOCAL_MACHINE subkey ";
            chstrMsg += DEBUG_REGISTRY_STRING;
            SetStatusObject(
                   cinstProcess.GetMethodContext(),
                   chstrMsg);
            hr = WBEM_E_FAILED;
        }
    }

    // Start the debugger...
    if(SUCCEEDED(hr))
    {
        WCHAR wstrCmdline[MAX_PATH * 2];
        wsprintf(wstrCmdline, 
                 L"\"%s\" -p %ld", 
                 (LPCWSTR)chstrDbgStr, 
                 dwPID);
        
        // Desktop specified (rather than left NULL) because
        // without specifying the interactive (console) desktop
        // the debugger, if launched remotely, would not show
        // up.
        STARTUPINFO sinfo = { sizeof(STARTUPINFO), 0, L"WinSta0\\Default"};

        LPWSTR wstrEnv = NULL;
        dwError = ProcessCreation(
	        cinstOutParams,
	        wstrCmdline,
	        FALSE,
	        CHString(),
	        wstrEnv,
	        FALSE,
	        0,
	        CREATE_NEW_CONSOLE,
	        FALSE,
	        sinfo);
    }

    // Set the return value...
    if(SUCCEEDED(hr))
    {
		cinstOutParams->SetDWORD(
            METHOD_ARG_NAME_RETURNVALUE, 
            dwError);
	}

    // If we failed because we didn't have
    // the debug privilege, set a status object...
    if(SUCCEEDED(hr))
    {
        if(dwError == ERROR_PRIVILEGE_NOT_HELD)
        {
            cinstOutParams->SetDWORD(
                METHOD_ARG_NAME_RETURNVALUE, 
                STATUS_PRIVILEGE_NOT_HELD);

            SetSinglePrivilegeStatusObject(
                cinstProcess.GetMethodContext(), 
                SE_SECURITY_NAME);

			hr = WBEM_E_ACCESS_DENIED;
        }
    }

    // Disable debug privilege if we enabeled it...
    if(fDisablePrivilege)
    {
        debugPrivilege.Enable(FALSE);
    }

#endif  // NTONLY

    return hr;
}



DWORD Process :: GetEnvBlock (

	const CHString &rchsSid,
	const CHString &rchsUserName,
	const CHString &rchsDomainName ,
	TCHAR* &rszEnvironBlock
)
{
	CHStringArray aEnvironmentVars ;
	CHStringArray aEnvironmentVarsValues ;
	rszEnvironBlock = NULL ;

	//fill user env. vars. under HKEY_USERS\{Sid}\Environment
	DWORD dwRetVal = GetEnvironmentVariables (

		HKEY_USERS,
		rchsSid + CHString( _T("\\Environment") ),
		aEnvironmentVars,
		aEnvironmentVarsValues
	) ;

	// if the user has no env. set, the HKEY_USERS\{Sid}\Environment is missing
	if ( dwRetVal == ERROR_SUCCESS || dwRetVal == ERROR_FILE_NOT_FOUND )
	{
		//fill user env. vars. under HKEY_USERS\{Sid}\Volatile Environment
		DWORD dwRetVal = GetEnvironmentVariables (

			HKEY_USERS,
			rchsSid + CHString( _T("\\Volatile Environment") ),
			aEnvironmentVars,
			aEnvironmentVarsValues
		) ;
	}

	if ( dwRetVal == ERROR_SUCCESS || dwRetVal == ERROR_FILE_NOT_FOUND )
	{
		//fill system env. vars. under HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment
		dwRetVal = GetEnvironmentVariables (

			HKEY_LOCAL_MACHINE,
			_T("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment"),
			aEnvironmentVars,
			aEnvironmentVarsValues
		) ;
	}

	if ( dwRetVal == ERROR_SUCCESS )
	{
		aEnvironmentVars.Add ( L"USERNAME" ) ;
		aEnvironmentVarsValues.Add ( rchsUserName ) ;

		aEnvironmentVars.Add ( L"USERDOMAIN" ) ;
		aEnvironmentVarsValues.Add ( rchsDomainName );
		DWORD dwBlockSize = 0 ;
		//get the size reqd. for env. block

		for ( int i = 0 ; i < aEnvironmentVars.GetSize() ; i++ )
		{
			CHString chsTmp = aEnvironmentVars.GetAt ( i ) + aEnvironmentVarsValues.GetAt ( i ) ;

			//add two: one for "=" sign + NULL terminator
			dwBlockSize += wcslen ( chsTmp ) + 2 ;
		}

		//add one more for null terminator
		rszEnvironBlock = new TCHAR [ dwBlockSize + 1 ] ;
		if ( rszEnvironBlock )
		{
			try
			{
				DWORD dwOffset = 0 ;

				//now start copying .....var=value
				for ( int i = 0 ; i < aEnvironmentVars.GetSize() ; i++ )
				{
					CHString chsTmp = aEnvironmentVars.GetAt ( i ) + CHString( _T("=") ) + aEnvironmentVarsValues.GetAt ( i ) ;
					_tcscpy( &rszEnvironBlock[dwOffset], TOBSTRT(chsTmp)) ;
					dwOffset += wcslen( chsTmp ) + 1 ;
				}

				rszEnvironBlock[ dwOffset ] = 0 ;
			}
			catch ( ... )
			{
				delete [] rszEnvironBlock ;

				throw ;
			}
		}
		else
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
	}

	return dwRetVal ;
}




DWORD Process :: GetEnvironmentVariables (

	 HKEY hKey,
	 const CHString& chsSubKey,
	 CHStringArray &aEnvironmentVars,
	 CHStringArray &aEnvironmentVarsValues
)
{
	CRegistry Reg ;
	DWORD dwRetVal = Reg.Open ( hKey, chsSubKey, KEY_READ ) ;
	if( dwRetVal == ERROR_SUCCESS )
	{
		if ( Reg.GetValueCount() )
		{
			bool bContinue = true ;
			DWORD dwIndexOfValue = 0 ;
			while ( bContinue && dwRetVal == ERROR_SUCCESS )
			{
				// haven't seen ERROR_NO_MORE_ITEMS being returned

				if( dwIndexOfValue >= Reg.GetValueCount() )
				{
					break ;
				}

				WCHAR *pValueName = NULL ;
				BYTE  *pValueData = NULL ;

				//get the next value under the key
				dwRetVal = Reg.EnumerateAndGetValues (

					dwIndexOfValue,
					pValueName,
					pValueData
				) ;

				if ( dwRetVal == ERROR_SUCCESS )
				{
					try
					{
						DWORD dwLen = _tcslen( (LPCTSTR) pValueData ) +1 ;

						TCHAR *pszExpandedVarValue = new TCHAR [ dwLen ] ;
						if ( pszExpandedVarValue )
						{
							DWORD dwReq ;
							try
							{
								ZeroMemory ( pszExpandedVarValue, dwLen*sizeof(TCHAR) ) ;
								dwReq = ExpandEnvironmentStrings ( (LPCTSTR) pValueData, pszExpandedVarValue, dwLen ) ;
							}
							catch ( ... )
							{
								delete [] pszExpandedVarValue ;

								throw ;
							}

							if ( dwReq > dwLen)
							{
								delete [] pszExpandedVarValue ;
								dwLen = dwReq ;
								pszExpandedVarValue = new TCHAR[ dwLen ] ;
								if ( pszExpandedVarValue )
								{
									try
									{
										ZeroMemory ( pszExpandedVarValue, dwLen*sizeof(TCHAR) ) ;
										dwReq = ExpandEnvironmentStrings ( (LPCTSTR) pValueData, pszExpandedVarValue, dwLen ) ;
									}
									catch ( ... )
									{
										delete [] pszExpandedVarValue ;

										throw ;
									}
								}
								else
								{
									throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
								}
							}

							bool bAddIt = true ;

							try
							{
								//check to see if same env. var. already present
								for ( int i = 0 ; i < aEnvironmentVars.GetSize() ; i++ )
								{
									CHString chsTmp = aEnvironmentVars.GetAt ( i ) ;
									if ( !chsTmp.CompareNoCase ( pValueName ) )
									{
										//prefix the new value before the old one, if it's a PATH var.
										if ( !chsTmp.CompareNoCase( IDS_Path ) )
										{
											aEnvironmentVarsValues[i] = CHString( pszExpandedVarValue ) + CHString ( _T(";") ) + aEnvironmentVarsValues[i] ;
										}
										bAddIt = false ;
										break ;
									}
								}

								if( bAddIt )
								{
									aEnvironmentVars.Add ( pValueName ) ;
									aEnvironmentVarsValues.Add ( TOBSTRT(pszExpandedVarValue)) ;
								}
							}
							catch ( ... )
							{
								delete[] pszExpandedVarValue ;

								throw ;
							}

							delete[] pszExpandedVarValue ;
						}
						else
						{
							throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
						}
					}
					catch ( ... )
					{
						delete [] pValueName ;
						delete [] pValueData ;

						throw ;
					}

					delete [] pValueName ;
					delete [] pValueData ;
				}

				if( dwRetVal == ERROR_NO_MORE_ITEMS )
				{
					bContinue = false ;
					dwRetVal = ERROR_SUCCESS ;
				}
				dwIndexOfValue++ ;
			}
		}

		Reg.Close() ;
	}

	return dwRetVal ;
}


#ifdef NTONLY
SYSTEM_PROCESS_INFORMATION *Process :: GetProcessBlocks ( CNtDllApi &a_NtApi )
{
	DWORD t_ProcessInformationSize = 32768;
	SYSTEM_PROCESS_INFORMATION *t_ProcessInformation = ( SYSTEM_PROCESS_INFORMATION * ) new BYTE [t_ProcessInformationSize] ;
	if ( t_ProcessInformation )
	{
		try
		{
			BOOL t_Retry = TRUE ;
			while ( t_Retry )
			{
				NTSTATUS t_Status = a_NtApi.NtQuerySystemInformation (

					SystemProcessInformation,
					t_ProcessInformation,
					t_ProcessInformationSize,
					NULL
				) ;

				if ( t_Status == STATUS_INFO_LENGTH_MISMATCH )
				{
					delete [] t_ProcessInformation;
					t_ProcessInformation = NULL ;
					t_ProcessInformationSize += 32768 ;
					t_ProcessInformation = ( SYSTEM_PROCESS_INFORMATION * ) new BYTE [t_ProcessInformationSize] ;
					if ( !t_ProcessInformation )
					{
						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}
				}
				else
				{
					t_Retry = FALSE ;

					if ( ! NT_SUCCESS ( t_Status ) )
					{
						delete [] t_ProcessInformation;
						t_ProcessInformation = NULL ;
					}
				}
			}
		}
		catch ( ... )
		{
			if ( t_ProcessInformation )
			{
				delete [] t_ProcessInformation;
				t_ProcessInformation = NULL ;
			}
			throw ;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	return t_ProcessInformation ;
}

SYSTEM_PROCESS_INFORMATION *Process :: NextProcessBlock ( CNtDllApi &a_NtApi , SYSTEM_PROCESS_INFORMATION *a_ProcessBlock )
{
	if ( a_ProcessBlock )
	{
		DWORD t_NextOffSet = a_ProcessBlock->NextEntryOffset ;
		if ( t_NextOffSet )
		{
			return ( SYSTEM_PROCESS_INFORMATION * ) ( ( ( BYTE * ) a_ProcessBlock ) + t_NextOffSet ) ;
		}
	}

	return NULL ;
}

SYSTEM_PROCESS_INFORMATION *Process :: GetProcessBlock ( CNtDllApi &a_NtApi , SYSTEM_PROCESS_INFORMATION *a_ProcessBlock , DWORD a_ProcessId )
{
	if ( a_ProcessBlock )
	{
		DWORD t_OffSet = 0;

		while ( TRUE )
		{
			SYSTEM_PROCESS_INFORMATION *t_CurrentInformation = ( PSYSTEM_PROCESS_INFORMATION ) ( ( BYTE * ) a_ProcessBlock + t_OffSet ) ;

			if ( HandleToUlong ( t_CurrentInformation->UniqueProcessId ) == a_ProcessId )
			{
				return t_CurrentInformation ;
			}

			DWORD t_NextOffSet = t_CurrentInformation->NextEntryOffset ;

			if ( ! t_NextOffSet )
			{
				return NULL ;
			}

			t_OffSet += t_NextOffSet ;
		}
	}

	return NULL ;
}

BOOL Process :: CopyModuleName	(
									CHString& a_ModuleName ,
									const WCHAR* a_Module ,
									size_t	a_bytes
								)
{
	BOOL t_Success = TRUE ;

	if ( 0 != a_Module [ ( a_bytes / sizeof ( WCHAR ) ) - 1 ] )
	{
		//////////////////////////////////////////////////////////////////
		//
		// must make sure we are 0 terminated prior to copy
		//
		//////////////////////////////////////////////////////////////////

		LPWSTR pszBuffer = a_ModuleName.GetBuffer ( ( a_bytes / sizeof ( WCHAR ) ) + 1 ) ;
		if ( SUCCEEDED ( StringCbCopyW ( pszBuffer, a_bytes, a_Module ) ) )
		{
			a_ModuleName.ReleaseBuffer () ;
		}
		else
		{
			t_Success = FALSE ;
		}
	}
	else
	{
		a_ModuleName = a_Module ;
	}

	return t_Success ;
}

BOOL Process :: GetModuleName	(
									HANDLE a_Process ,
									LDR_DATA_TABLE_ENTRY& t_LdrEntryData ,
									CHString &a_ModuleName
								)
{
	BOOL t_Success = FALSE ;

	WCHAR t_StackString [ MAX_PATH ] ;
	BOOL t_HeapAllocated = t_LdrEntryData.FullDllName.MaximumLength > MAX_PATH * sizeof ( WCHAR ) ;

	WCHAR *t_Executable = t_StackString ;

	if ( t_HeapAllocated )
	{
		t_Executable = ( WCHAR * ) new WCHAR [ ( t_LdrEntryData.FullDllName.MaximumLength ) / sizeof ( WCHAR ) ];
		if ( ! t_Executable )
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
	}

	//
	// scope guard
	//
	// this will create scope variable that makes sure
	// de-allocation is performed based on BOOLEAN
	//
	ON_BLOCK_EXIT_IF ( t_HeapAllocated, deleteArray < WCHAR >, t_Executable ) ;

	BOOL b_Status = ReadProcessMemory (

		a_Process,
		t_LdrEntryData.FullDllName.Buffer,
		t_Executable ,
		t_LdrEntryData.FullDllName.MaximumLength ,
		NULL
	) ;

	if ( b_Status )
	{
		CHString t_Path ;
		if ( CopyModuleName ( t_Path, t_Executable, t_LdrEntryData.FullDllName.MaximumLength ) )
		{
			if ( t_Path.Find ( _T("\\??\\") ) == 0 )
			{
				a_ModuleName = t_Path.Mid ( sizeof ( _T("\\??\\") ) / sizeof ( WCHAR ) - 1 ) ;
				t_Success = TRUE ;
			}
			else if ( t_Path.Find ( _T("\\SystemRoot\\") ) == 0 )
			{
				WCHAR t_NormalisedPathStack [ MAX_PATH ] ;
				DWORD t_charSize = GetWindowsDirectory ( t_NormalisedPathStack , sizeof ( t_NormalisedPathStack ) / sizeof ( WCHAR ) ) ;

				BOOL t_HeapAllocatedPath = FALSE ;
				WCHAR *t_NormalisedPath = t_NormalisedPathStack ;

				if ( 0 != t_charSize )
				{
					if ( t_charSize > MAX_PATH )
					{
						t_HeapAllocatedPath = TRUE ;
					}
				}

				if ( t_HeapAllocatedPath )
				{
					t_NormalisedPath = ( WCHAR * ) new WCHAR [ t_charSize + 1 ];
					if ( ! t_NormalisedPath )
					{
						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}
				}

				//
				// scope guard
				//
				// this will create scope variable that makes sure
				// de-allocation is performed based on BOOLEAN
				//
				ON_BLOCK_EXIT_IF ( t_HeapAllocatedPath, deleteArray < WCHAR >, t_NormalisedPath ) ;

				if ( t_HeapAllocatedPath )
				{
					//
					// we need to get folder again
					//
					t_charSize = GetWindowsDirectory ( t_NormalisedPath , t_charSize + 1 ) ;
				}

				if ( 0 != t_charSize )
				{
					LPWSTR pszBuffer = a_ModuleName.GetBuffer ( t_charSize + ( t_Path.GetLength () - ( sizeof ( _T("\\SystemRoot") ) / sizeof ( WCHAR ) ) ) + 1 ) ;
					if ( SUCCEEDED ( StringCchCopyW ( pszBuffer, t_charSize + 1, t_NormalisedPath ) ) )
					{
						if ( SUCCEEDED	( StringCchCatW	(
															pszBuffer,
															t_charSize + ( t_Path.GetLength () - ( sizeof ( _T("\\SystemRoot") ) / sizeof ( WCHAR ) ) ) + 1,
															t_Path.Mid ( sizeof ( _T("\\SystemRoot") ) / sizeof ( WCHAR ) - 1 )
														)
										)
						   )
						{
							a_ModuleName.ReleaseBuffer () ;
							t_Success = TRUE ;
						}
					}
				}
			}
			else
			{
				a_ModuleName = t_Path ;
				t_Success = TRUE ;
			}
		}
	}

	return t_Success ;
}

BOOL Process :: GetProcessExecutable ( CNtDllApi &a_NtApi , HANDLE a_Process , CHString &a_ExecutableName )
{
	BOOL t_Success = FALSE ;

    PROCESS_BASIC_INFORMATION t_BasicInfo ;

    NTSTATUS t_Status = a_NtApi.NtQueryInformationProcess (

        a_Process ,
        ProcessBasicInformation ,
        & t_BasicInfo ,
        sizeof ( t_BasicInfo ) ,
        NULL
	) ;

    if ( NT_SUCCESS ( t_Status ) )
	{
		PEB *t_Peb = t_BasicInfo.PebBaseAddress ;

		//
		// Ldr = Peb->Ldr
		//

		PPEB_LDR_DATA t_Ldr ;

		BOOL b_Status = ReadProcessMemory (

			a_Process,
			& t_Peb->Ldr,
			& t_Ldr,
			sizeof ( t_Ldr ) ,
			NULL
		) ;

		if ( b_Status )
		{
			LIST_ENTRY *t_LdrHead = & t_Ldr->InMemoryOrderModuleList ;

			//
			// LdrNext = Head->Flink;
			//

			LIST_ENTRY *t_LdrNext ;

			b_Status = ReadProcessMemory (

				a_Process,
				& t_LdrHead->Flink,
				& t_LdrNext,
				sizeof ( t_LdrNext ) ,
				NULL
			) ;

			if ( b_Status )
			{
				if ( t_LdrNext != t_LdrHead )
				{
					LDR_DATA_TABLE_ENTRY t_LdrEntryData ;

					LDR_DATA_TABLE_ENTRY *t_LdrEntry = CONTAINING_RECORD ( t_LdrNext , LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks ) ;

					b_Status = ReadProcessMemory (

						a_Process,
						t_LdrEntry,
						& t_LdrEntryData,
						sizeof ( t_LdrEntryData ) ,
						NULL
					) ;

					if ( b_Status )
					{
						t_Success = GetModuleName ( a_Process, t_LdrEntryData, a_ExecutableName ) ;
					}
				}
			}
		}
	}

    return t_Success ;
}

BOOL Process :: GetProcessModuleBlock (

	CNtDllApi &a_NtApi ,
	HANDLE a_Process ,
	LIST_ENTRY *&a_Head
)
{
    PROCESS_BASIC_INFORMATION t_BasicInfo ;

    NTSTATUS t_Status = a_NtApi.NtQueryInformationProcess (

        a_Process ,
        ProcessBasicInformation ,
        & t_BasicInfo ,
        sizeof ( t_BasicInfo ) ,
        NULL
	) ;

    if ( NT_SUCCESS ( t_Status ) )
	{
		PEB *t_Peb = t_BasicInfo.PebBaseAddress ;

		//
		// Ldr = Peb->Ldr
		//

		PPEB_LDR_DATA t_Ldr ;

		BOOL b_Status = ReadProcessMemory (

			a_Process,
			& t_Peb->Ldr,
			& t_Ldr ,
			sizeof ( t_Ldr ) ,
			NULL
		) ;

		if ( b_Status )
		{
			a_Head = & t_Ldr->InMemoryOrderModuleList ;

			return TRUE ;
		}
	}

    return FALSE ;
}

BOOL Process :: NextProcessModule (

	CNtDllApi &a_NtApi ,
	HANDLE a_Process ,
	LIST_ENTRY *&a_LdrHead ,
	LIST_ENTRY *&a_LdrNext ,
	CHString &a_ModuleName ,
    DWORD_PTR *a_pdwBaseAddress,
    DWORD *a_pdwUsageCount
)
{
	BOOL t_Success = FALSE ;

    //
    // LdrNext = Head->Flink;
    //

	BOOL t_Status = ReadProcessMemory (

		a_Process,
		& a_LdrNext->Flink,
		& a_LdrNext,
		sizeof ( a_LdrNext ) ,
		NULL
	) ;

    if ( t_Status )
	{
		if ( a_LdrNext != a_LdrHead )
		{
			LDR_DATA_TABLE_ENTRY t_LdrEntryData ;

			LDR_DATA_TABLE_ENTRY *t_LdrEntry = CONTAINING_RECORD ( a_LdrNext , LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks ) ;

			t_Status = ReadProcessMemory (

				a_Process,
				t_LdrEntry,
				& t_LdrEntryData,
				sizeof ( t_LdrEntryData ) ,
				NULL
			) ;

			if ( t_Status )
			{
				*a_pdwBaseAddress = (DWORD_PTR) t_LdrEntryData.DllBase;
                *a_pdwUsageCount = t_LdrEntryData.LoadCount;

				t_Success = GetModuleName ( a_Process, t_LdrEntryData, a_ModuleName ) ;
			}
		}
	}

    return t_Success ;
}

BOOL Process :: GetProcessParameters (

	CNtDllApi &a_NtApi ,
	HANDLE a_Process ,
	CHString &a_ProcessCommandLine
)
{
	BOOL t_Success = FALSE ;

    PROCESS_BASIC_INFORMATION t_BasicInfo ;

    NTSTATUS t_Status = a_NtApi.NtQueryInformationProcess (

        a_Process ,
        ProcessBasicInformation ,
        & t_BasicInfo ,
        sizeof ( t_BasicInfo ) ,
        NULL
	) ;

    if ( NT_SUCCESS ( t_Status ) )
	{
		PEB *t_Peb = t_BasicInfo.PebBaseAddress ;

		RTL_USER_PROCESS_PARAMETERS *t_ProcessParameters = NULL ;

		t_Success = ReadProcessMemory (

			a_Process,
			& t_Peb->ProcessParameters,
			& t_ProcessParameters,
			sizeof ( t_ProcessParameters ) ,
			NULL
		) ;

		if ( t_Success )
		{
			RTL_USER_PROCESS_PARAMETERS t_Parameters ;

			t_Success = ReadProcessMemory (

				a_Process,
				t_ProcessParameters,
				& t_Parameters ,
				sizeof ( RTL_USER_PROCESS_PARAMETERS ) ,
				NULL
			) ;

			if ( t_Success )
			{
				WCHAR *t_Command = new WCHAR [ t_Parameters.CommandLine.MaximumLength / sizeof ( WCHAR ) ];

				try
				{
					t_Success = ReadProcessMemory (

						a_Process,
						t_Parameters.CommandLine.Buffer ,
						t_Command ,
						t_Parameters.CommandLine.MaximumLength ,
						NULL
					) ;

					if ( t_Success )
					{
						t_Success = CopyModuleName ( a_ProcessCommandLine, t_Command, t_Parameters.CommandLine.MaximumLength ) ;
					}
				}
				catch(...)
				{
					delete [] t_Command ;
					t_Command = NULL;
					throw;
				}

				delete [] t_Command ;
				t_Command = NULL;
			}
		}
	}

	return t_Success ;
}

#endif

#ifdef NTONLY
void Process::GetDebuggerString(
    CHString& chstrDbgStr)
{
    HKEY hkDebug;

    if (ERROR_SUCCESS == RegOpenKeyEx(
                             HKEY_LOCAL_MACHINE, 
                             DEBUG_REGISTRY_STRING,
                             0, 
                             KEY_READ, 
                             &hkDebug))
    {
        WCHAR wstrDebugger[MAX_PATH * 2];
        DWORD dwString = sizeof(wstrDebugger);

        if (ERROR_SUCCESS == RegQueryValueEx(
                                 hkDebug, 
                                 L"Debugger", 
                                 NULL, 
                                 NULL, 
                                 (LPBYTE) wstrDebugger, 
                                 &dwString))
        {
            // Find the first token (which is the debugger exe name/path)
            LPWSTR pwstrCmdLine = wstrDebugger;
            if(*pwstrCmdLine == L'\"') 
            {
                // Scan, and skip over, subsequent characters until
                // another double-quote or a null is encountered.
                while(*++pwstrCmdLine && (*pwstrCmdLine != L'\"'));
            }
            else
            {
                // there are no double quotes - just go up to the next
                // space...
                WCHAR* pwc = wcschr(pwstrCmdLine, L' ');
                if(pwc)
                {
                    pwstrCmdLine = pwc;
                }
            }

            if(pwstrCmdLine)
            {
                // Don't need the rest of the args, etc
                *pwstrCmdLine = L'\0';   

                // If the doctor is in, we don't allow the Debug action...
                if(lstrlen(wstrDebugger) && 
                   lstrcmpi(wstrDebugger, L"drwtsn32") && 
                   lstrcmpi(wstrDebugger, L"drwtsn32.exe"))
                {
                    chstrDbgStr = wstrDebugger;
                    if(chstrDbgStr.Left(1) == L"\"")
                    {
                        chstrDbgStr = chstrDbgStr.Mid(1);
                    }
                }
            }
        }

        RegCloseKey(hkDebug);
    }
}
#endif


#ifdef NTONLY
// sets a status object with a message
bool Process::SetStatusObject(
    MethodContext* pContext, 
    const WCHAR* wstrMsg)
{
	return CWbemProviderGlue::SetStatusObject(
                pContext, 
                IDS_CimWin32Namespace,
                wstrMsg, 
                WBEM_E_FAILED, 
                NULL, 
                NULL);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\configmg.h ===
/****************************************************************************

*                                                                           *

* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *

* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *

* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *

* PURPOSE.                                                                  *

*                                                                           *

* Copyright (c) 1993-2001 Microsoft Corporation, All Rights Reserved
*                                                                           *
****************************************************************************/

/*****************************************************************************
 *
 *	Title:		CONFIGMG.H - Configuration manager header file
 *
 *	Version:	1.00
 *
 *****************************************************************************/

#ifndef _CONFIGMG_H
#define	_CONFIGMG_H

#define	CONFIGMG_VERSION	0x0400

#define	PNPDRVS_Major_Ver	0x0004
#define	PNPDRVS_Minor_Ver	0x0000

#ifdef	MAXDEBUG
#define	CM_PERFORMANCE_INFO
#endif

//#ifdef	GOLDEN	
#ifndef	DEBUG
#define	CM_GOLDEN_RETAIL
#endif
//#endif

/*XLATOFF*/
#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(1)
#else
#pragma pack(1)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
/*XLATON*/

#ifndef	NORESDES

/****************************************************************************
 *
 *			EQUATES FOR RESOURCE DESCRIPTOR
 *
 *	The equates for resource descriptor work the exact same way as those
 *	for VxD IDs, which is:
 *
 *	Device ID's are a combination of OEM # and device # in the form:
 *
 *		xOOOOOOOOOODDDDD
 *
 *	The high bit of the device ID is reserved for future use.  The next
 *	10 bits are the OEM # which is assigned by Microsoft.  The last 5 bits
 *	are the device #.  This allows each OEM to create 32 unique devices.
 *	If an OEM is creating a replacement for a standard device, then it
 *	should re-use the standard ID listed below.  Microsoft reserves the
 *	first 16 OEM #'s (0 thru 0Fh)
 *
 *	To make your resource ID, you must use the same 10 OEMs bit that
 *	have been given by Microsoft as OEM VxD ID range. You can then tag
 *	any of the 32 unique number in that range (it does not have to be
 *	the same as the VxD as some VxD may have mupltiple arbitrators).
 *
 *	If the ResType_Ignored_Bit is set, the resource is not arbitrated.
 *	You cannot register a handler for such a resource.
 *
 ***************************************************************************/
#define	ResType_All		0x00000000	// Return all resource types.
#define	ResType_None		0x00000000	// Arbitration always succeeded.
#define	ResType_Mem		0x00000001	// Physical address resource.
#define	ResType_IO		0x00000002	// Physical IO address resource.
#define	ResType_DMA		0x00000003	// DMA channels 0-7 resource.
#define	ResType_IRQ		0x00000004	// IRQ 0-15 resource.
#define	ResType_Max		0x00000004	// Max KNOWN ResType (for DEBUG).
#define	ResType_Ignored_Bit	0x00008000	// This resource is to be ignored.

#define	DEBUG_RESTYPE_NAMES \
char	CMFAR *lpszResourceName[ResType_Max+1]= \
{ \
	"All/None", \
	"Mem     ", \
	"IO      ", \
	"DMA     ", \
	"IRQ     ", \
};

/************************************************************************
 *									*
 *	OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,  		*
 *	PLEASE CONTACT MICROSOFT PRODUCT SUPPORT 			*
 *									*
 ************************************************************************/

/****************************************************************************
 *
 * RESOURCE DESCRIPTORS
 *
 *	Each resource descriptor consists of an array of resource requests.
 *	Exactly one element of the array must be satisfied. The data
 *	of each array element is resource specific an described below.
 *	The data may specify one or more resource requests. At least
 *	one element of a Res_Des must be satisfied to satisfy the request
 *	represented by the Res_Des. The values allocated to the Res_Des
 *	are stored within the Res_Des.
 *	Each subarray (OR element) is a single Res_Des followed
 *	by data specific to the type of resource. The data includes the
 *	allocated resource (if any) followed by resource requests (which
 *	will include the values indicated by the allocated resource.
 *
 ***************************************************************************/

/****************************************************************************
 * Memory resource requests consist of ranges of pages
 ***************************************************************************/
#define	MType_Range		sizeof(struct Mem_Range_s)

#define	fMD_MemoryType		1		// Memory range is ROM/RAM
#define	fMD_ROM			0		// Memory range is ROM
#define	fMD_RAM			1		// Memory range is RAM
#define	fMD_32_24		2		// Memory range is 32/24 (for ISAPNP only)
#define	fMD_24			0		// Memory range is 24
#define	fMD_32			2		// Memory range is 32

/* Memory Range descriptor data
 */
struct	Mem_Range_s {
	ULONG			MR_Align;	// Mask for base alignment
	ULONG			MR_nBytes;	// Count of bytes
	ULONG			MR_Min;		// Min Address
	ULONG			MR_Max;		// Max Address
	WORD			MR_Flags;	// Flags
	WORD			MR_Reserved;
};

typedef	struct Mem_Range_s	MEM_RANGE;

/* Mem Resource descriptor header structure
 *	MD_Count * MD_Type bytes of data follow header in an
 *	array of MEM_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the MD_Alloc_... variables.
 *
 *	Example for memory Resource Description:
 *		Mem_Des_s {
 *			MD_Count = 1;
 *			MD_Type = MTypeRange;
 *			MD_Alloc_Base = 0;
 *			MD_Alloc_End = 0;
 *			MD_Flags = 0;
 *			MD_Reserved = 0;
 *			};
 *		Mem_Range_s {
 *			MR_Align = 0xFFFFFF00;	// 256 byte alignment
 *			MR_nBytes = 32;		// 32 bytes needed
 *			MR_Min = 0;
 *			MR_Max = 0xFFFFFFFF;	// Any place in address space
 *			MR_Flags = 0;
 *			MR_Reserved = 0;
 *			};
 */
struct	Mem_Des_s {
	WORD			MD_Count;
	WORD			MD_Type;
	ULONG			MD_Alloc_Base;
	ULONG			MD_Alloc_End;
	WORD			MD_Flags;
	WORD			MD_Reserved;
};

typedef	struct Mem_Des_s 	MEM_DES;

/****************************************************************************
 * IO resource allocations consist of fixed ranges or variable ranges
 *	The Alias and Decode masks provide additional flexibility
 *	in specifying how the address is handled. They provide a convenient
 *	method for specifying what port aliases a card responds to. An alias
 *	is a port address that is responded to as if it were another address.
 *	Additionally, some cards will actually use additional ports for
 *	different purposes, but use a decoding scheme that makes it look as
 *	though it were using aliases. E.G., an ISA card may decode 10 bits
 *	and require port 03C0h. It would need to specify an Alias offset of
 *	04h and a Decode of 3 (no aliases are used as actual ports). For
 *	convenience, the alias field can be set to zero indicate no aliases
 *	are required and then decode is ignored.
 *	If the card were to use the ports at 7C0h, 0BC0h and 0FC0h, where these
 *	ports have different functionality, the Alias would be the same and the
 *	the decode would be 0Fh indicating bits 11 and 12 of the port address
 *	are significant. Thus, the allocation is for all of the ports
 *	(PORT[i] + (n*Alias*256)) & (Decode*256 | 03FFh), where n is
 *	any integer and PORT is the range specified by the nPorts, Min and
 *	Max fields. Note that the minimum Alias is 4 and the minimum
 *	Decode is 3.
 *	Because of the history of the ISA bus, all ports that can be described
 *	by the formula PORT = n*400h + zzzz, where "zzzz" is a port in the
 *	range 100h - 3FFh, will be checked for compatibility with the port
 *	zzzz, assuming that the port zzzz is using a 10 bit decode. If a card
 *	is on a local bus that can prevent the IO address from appearing on
 *	the ISA bus (e.g. PCI), then the logical configuration should specify
 *	an alias of IOA_Local which will prevent the arbitrator from checking
 *	for old ISA bus compatibility.
 */
#define	IOType_Range		sizeof(struct IO_Range_s) // Variable range

/* IO Range descriptor data */
struct	IO_Range_s {
	WORD			IOR_Align;	// Mask for base alignment
	WORD			IOR_nPorts;	// Number of ports
	WORD			IOR_Min;	// Min port address
	WORD			IOR_Max;	// Max port address
	WORD			IOR_RangeFlags;	// Flags
	BYTE			IOR_Alias;	// Alias offset
	BYTE			IOR_Decode;	// Address specified
};

typedef	struct IO_Range_s	IO_RANGE;

/* IO Resource descriptor header structure
 *	IOD_Count * IOD_Type bytes of data follow header in an
 *	array of IO_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the IOD_Alloc_... variables.
 *
 *	Example for IO Resource Description:
 *		IO_Des_s {
 *			IOD_Count = 1;
 *			IOD_Type = IOType_Range;
 *			IOD_Alloc_Base = 0;
 *			IOD_Alloc_End = 0;
 *			IOD_Alloc_Alias = 0;
 *			IOD_Alloc_Decode = 0;
 *			IOD_DesFlags = 0;
 *			IOD_Reserved = 0;
 *			};
 *		IO_Range_s {
 *			IOR_Align = 0xFFF0;	// 16 byte alignment
 *			IOR_nPorts = 16;	// 16 ports required
 *			IOR_Min = 0x0100;
 *			IOR_Max = 0x03FF;	// Anywhere in ISA std ports
 *			IOR_RangeFlags = 0;
 *			IOR_Alias = 0004;	// Standard ISA 10 bit aliasing
 *			IOR_Decode = 0x000F;	// Use first 3 aliases (e.g. if
 *						// 0x100 were base port, 0x500
 *						// 0x900, and 0xD00 would
 *						// also be allocated)
 *			};
 */
struct	IO_Des_s {
	WORD			IOD_Count;
	WORD			IOD_Type;
	WORD			IOD_Alloc_Base;
	WORD			IOD_Alloc_End;
	WORD			IOD_DesFlags;
	BYTE			IOD_Alloc_Alias;
	BYTE			IOD_Alloc_Decode;
};

typedef	struct IO_Des_s 	IO_DES;

/* Definition for special alias value indicating card on PCI or similar local bus
 *  This value should used for the IOR_Alias and IOD_Alias fields
 */
#define	IOA_Local		0xff

/****************************************************************************
 * DMA channel resource allocations consist of one WORD channel bit masks.
 *	The mask indcates alternative channel allocations,
 *	one bit for each alternative (only one is allocated per mask).
 */

/*DMA flags
 *First two are DMA channel width: BYTE, WORD or DWORD
 */
#define	mDD_Width		0x0003		// Mask for channel width
#define	fDD_BYTE		0
#define	fDD_WORD		1
#define	fDD_DWORD		2
#define	szDMA_Des_Flags		"WD"

/* DMA Resource descriptor structure
 *
 *	Example for DMA Resource Description:
 *
 *		DMA_Des_s {
 *			DD_Flags = fDD_Byte;	// Byte transfer
 *			DD_Alloc_Chan = 0;
 *			DD_Req_Mask = 0x60;	// Channel 5 or 6
 *			DD_Reserved = 0;
 *			};
 */
struct	DMA_Des_s {
	BYTE			DD_Flags;
	BYTE			DD_Alloc_Chan;	// Channel number allocated
	BYTE			DD_Req_Mask;	// Mask of possible channels
	BYTE			DD_Reserved;
};


typedef	struct DMA_Des_s 	DMA_DES;

/****************************************************************************
 * IRQ resource allocations consist of two WORD IRQ bit masks.
 *	The first mask indcates alternatives for IRQ allocation,
 *	one bit for each alternative (only one is allocated per mask). The
 *	second mask is used to specify that the IRQ can be shared.
 */

/*
 * IRQ flags
 */
#define	fIRQD_Share		1			// IRQ can be shared
#define	cIRQ_Des_Flags		'S'

/* IRQ Resource descriptor structure
 *
 *	Example for IRQ Resource Description:
 *
 *		IRQ_Des_s {
 *			IRQD_Flags = fIRQD_Share	// IRQ can be shared
 *			IRQD_Alloc_Num = 0;
 *			IRQD_Req_Mask = 0x18;		// IRQ 3 or 4
 *			IRQD_Reserved = 0;
 *			};
 */
struct	IRQ_Des_s {
	WORD			IRQD_Flags;
	WORD			IRQD_Alloc_Num;		// Allocated IRQ number
	WORD			IRQD_Req_Mask;		// Mask of possible IRQs
	WORD			IRQD_Reserved;
};

typedef	struct IRQ_Des_s 	IRQ_DES;

/*XLATOFF*/

/****************************************************************************
 *
 * 'C'-only defined total resource structure. Since a resource consists of
 * one resource header followed by an undefined number of resource data
 * structure, we use the undefined array size [] on the *_DATA structure
 * member. Unfortunately, this does not H2INC since the total size of the
 * array cannot be computed from the definition.
 *
 ***************************************************************************/

#pragma warning (disable:4200)			// turn off undefined array size

typedef	MEM_DES			*PMEM_DES;
typedef	MEM_RANGE		*PMEM_RANGE;
typedef	IO_DES			*PIO_DES;
typedef	IO_RANGE		*PIO_RANGE;
typedef	DMA_DES			*PDMA_DES;
typedef	IRQ_DES			*PIRQ_DES;

struct	MEM_Resource_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data[];
};

typedef	struct MEM_Resource_s	MEM_RESOURCE;
typedef	MEM_RESOURCE		*PMEM_RESOURCE;

struct	MEM_Resource1_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data;
};

typedef	struct MEM_Resource1_s	MEM_RESOURCE1;
typedef	MEM_RESOURCE1		*PMEM_RESOURCE1;

#define	SIZEOF_MEM(x)		(sizeof(MEM_DES)+(x)*sizeof(MEM_RANGE))

struct	IO_Resource_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data[];
};

typedef	struct IO_Resource_s	IO_RESOURCE;
typedef	IO_RESOURCE		*PIO_RESOURCE;

struct	IO_Resource1_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data;
};

typedef	struct IO_Resource1_s	IO_RESOURCE1;
typedef	IO_RESOURCE1		*PIO_RESOURCE1;

#define	SIZEOF_IORANGE(x)	(sizeof(IO_DES)+(x)*sizeof(IO_RANGE))

struct	DMA_Resource_s {
	DMA_DES			DMA_Header;
};

typedef	struct DMA_Resource_s	DMA_RESOURCE;

#define	SIZEOF_DMA		sizeof(DMA_DES)

struct	IRQ_Resource_s {
	IRQ_DES			IRQ_Header;
};

typedef	struct IRQ_Resource_s	IRQ_RESOURCE;

#define	SIZEOF_IRQ		sizeof(IRQ_DES)

#pragma warning (default:4200)			// turn on undefined array size

/*XLATON*/

#endif	// ifndef NORESDES

#define	LCPRI_FORCECONFIG	0x00000000	// Logical configuration priorities.
#define	LCPRI_BOOTCONFIG	0x00000001
#define	LCPRI_DESIRED		0x00002000
#define	LCPRI_NORMAL		0x00003000
#define	LCPRI_LASTBESTCONFIG	0x00003FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_SUBOPTIMAL	0x00005000
#define	LCPRI_LASTSOFTCONFIG	0x00007FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_RESTART		0x00008000
#define	LCPRI_REBOOT		0x00009000
#define	LCPRI_POWEROFF		0x0000A000
#define	LCPRI_HARDRECONFIG	0x0000C000
#define	LCPRI_HARDWIRED		0x0000E000
#define	LCPRI_IMPOSSIBLE	0x0000F000
#define	LCPRI_DISABLED		0x0000FFFF
#define	MAX_LCPRI		0x0000FFFF

#define	MAX_MEM_REGISTERS		9
#define	MAX_IO_PORTS			20
#define	MAX_IRQS			7
#define	MAX_DMA_CHANNELS		7

struct Config_Buff_s {
WORD	wNumMemWindows;			// Num memory windows
DWORD	dMemBase[MAX_MEM_REGISTERS];	// Memory window base
DWORD	dMemLength[MAX_MEM_REGISTERS];	// Memory window length
WORD	wMemAttrib[MAX_MEM_REGISTERS];	// Memory window Attrib
WORD	wNumIOPorts;			// Num IO ports
WORD	wIOPortBase[MAX_IO_PORTS];	// I/O port base
WORD	wIOPortLength[MAX_IO_PORTS];	// I/O port length
WORD	wNumIRQs;			// Num IRQ info
BYTE	bIRQRegisters[MAX_IRQS];	// IRQ list
BYTE	bIRQAttrib[MAX_IRQS];		// IRQ Attrib list
WORD	wNumDMAs;			// Num DMA channels
BYTE	bDMALst[MAX_DMA_CHANNELS];	// DMA list
WORD	wDMAAttrib[MAX_DMA_CHANNELS];	// DMA Attrib list
BYTE	bReserved1[3];			// Reserved
};

typedef	struct Config_Buff_s	CMCONFIG;	// Config buffer info

#ifndef	CMJUSTRESDES

#define	MAX_DEVICE_ID_LEN	200

#include <vmmreg.h>

/*XLATOFF*/

#ifdef	Not_VxD

#include <dbt.h>

#pragma warning(disable:4001)	// Non-standard extensions
#pragma warning(disable:4505)	// Unreferenced local functions

#ifdef	IS_32

#define	CMFAR

#else

#define	CMFAR	_far

#endif

#else	// Not_VxD

#define	CMFAR

#endif	// Not_VxD

#ifdef	IS_32

typedef	DWORD			RETURN_TYPE;

#else	// IS_32

typedef	WORD			RETURN_TYPE;

#endif	// IS_32

#define	CONFIGMG_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(CONFIGMG, VxD)
CONFIGMG_Service	(_CONFIGMG_Get_Version, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Initialize, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Locate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Parent, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Child, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Sibling, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Depth, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Deregister_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Sort_NodeList, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Yield, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Lock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Unlock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Empty_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_First_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Modify_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Performance_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Process_Events_Now, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Delete_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Test_Range_Available, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dup_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Invert_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Intersect_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_First_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Next_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dump_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Load_DLVxDs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DDBs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_CRC_CheckSum, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_DevLoader, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reenumerate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Setup_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reset_Children_Marks, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Status, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Unmarked_Children, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_ISAPNP_To_CM, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Alloc_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Write_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Disable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Enable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Move_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Recompute_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Log_Confs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Run_Detection, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_At_Appy_Time, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Fail_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_Problem, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Debug_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Hardware_Profile_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Find_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Global_State, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Broadcast_Device_Change_Message, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_DevNode_Handler, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Reinsert_All, VxD_CODE)
End_Service_Table(CONFIGMG, VxD)

/*ENDMACROS*/

/*XLATOFF*/

#define	NUM_CM_SERVICES		((WORD)(Num_CONFIGMG_Services & 0xFFFF))

#define	DEBUG_SERVICE_NAMES \
char	CMFAR *lpszServiceName[NUM_CM_SERVICES]= \
{ \
	"Get_Version", \
	"Initialize", \
	"Locate_DevNode", \
	"Get_Parent", \
	"Get_Child", \
	"Get_Sibling", \
	"Get_Device_ID_Size", \
	"Get_Device_ID", \
	"Get_Depth", \
	"Get_Private_DWord", \
	"Set_Private_DWord", \
	"Create_DevNode", \
	"Query_Remove_SubTree", \
	"Remove_SubTree", \
	"Register_Device_Driver", \
	"Register_Enumerator", \
	"Register_Arbitrator", \
	"Deregister_Arbitrator", \
	"Query_Arbitrator_Free_Size", \
	"Query_Arbitrator_Free_Data", \
	"Sort_NodeList", \
	"Yield", \
	"Lock", \
	"Unlock", \
	"Add_Empty_Log_Conf", \
	"Free_Log_Conf", \
	"Get_First_Log_Conf", \
	"Get_Next_Log_Conf", \
	"Add_Res_Des", \
	"Modify_Res_Des", \
	"Free_Res_Des", \
	"Get_Next_Res_Des", \
	"Get_Performance_Info", \
	"Get_Res_Des_Data_Size", \
	"Get_Res_Des_Data", \
	"Process_Events_Now", \
	"Create_Range_List", \
	"Add_Range", \
	"Delete_Range", \
	"Test_Range_Available", \
	"Dup_Range_List", \
	"Free_Range_List", \
	"Invert_Range_List", \
	"Intersect_Range_List", \
	"First_Range", \
	"Next_Range", \
	"Dump_Range_List", \
	"Load_DLVxDs", \
	"Get_DDBs", \
	"Get_CRC_CheckSum", \
	"Register_DevLoader", \
	"Reenumerate_DevNode", \
	"Setup_DevNode", \
	"Reset_Children_Marks", \
	"Get_DevNode_Status", \
	"Remove_Unmarked_Children", \
	"ISAPNP_To_CM", \
	"CallBack_Device_Driver", \
	"CallBack_Enumerator", \
	"Get_Alloc_Log_Conf", \
	"Get_DevNode_Key_Size", \
	"Get_DevNode_Key", \
	"Read_Registry_Value", \
	"Write_Registry_Value", \
	"Disable_DevNode", \
	"Enable_DevNode", \
	"Move_DevNode", \
	"Set_Bus_Info", \
	"Get_Bus_Info", \
	"Set_HW_Prof", \
	"Recompute_HW_Prof", \
	"Query_Change_HW_Prof", \
	"Get_Device_Driver_Private_DWord", \
	"Set_Device_Driver_Private_DWord", \
	"Get_HW_Prof_Flags", \
	"Set_HW_Prof_Flags", \
	"Read_Registry_Log_Confs", \
	"Run_Detection", \
	"Call_At_Appy_Time", \
	"Fail_Change_HW_Prof", \
	"Set_Private_Problem", \
	"Debug_DevNode", \
	"Get_Hardware_Profile_Info", \
	"Register_Enumerator_Function", \
	"Call_Enumerator_Function", \
	"Add_ID", \
	"Find_Range", \
	"Get_Global_State", \
	"Broadcast_Device_Change_Message", \
	"Call_DevNode_Handler", \
	"Remove_Reinsert_All", \
};

/*XLATON*/

/****************************************************************************
 *
 *				GLOBALLY DEFINED TYPEDEFS
 *
 ***************************************************************************/
typedef	RETURN_TYPE		CONFIGRET;	// Standardized return value.
typedef	PPVMMDDB		*PPPVMMDDB;	// Too long to describe.
typedef	VOID		CMFAR	*PFARVOID;	// Pointer to a VOID.
typedef	ULONG		CMFAR	*PFARULONG;	// Pointer to a ULONG.
typedef	char		CMFAR	*PFARCHAR;	// Pointer to a string.
typedef	VMMHKEY		CMFAR	*PFARHKEY;	// Pointer to a HKEY.
typedef	char		CMFAR	*DEVNODEID;	// Device ID ANSI name.
typedef	DWORD			LOG_CONF;	// Logical configuration.
typedef	LOG_CONF	CMFAR	*PLOG_CONF;	// Pointer to logical configuration.
typedef	DWORD			RES_DES;	// Resource descriptor.
typedef	RES_DES		CMFAR	*PRES_DES;	// Pointer to resource descriptor.
typedef	DWORD			DEVNODE;	// Devnode.
typedef	DEVNODE		CMFAR	*PDEVNODE;	// Pointer to devnode.
typedef	DWORD			NODELIST;	// Pointer to a nodelist element.
typedef	DWORD			NODELIST_HEADER;// Pointer to a nodelist header.
typedef	DWORD			REGISTERID;	// Arbitartor registration.
typedef	REGISTERID	CMFAR	*PREGISTERID;	// Pointer to arbitartor registration.
typedef	ULONG			RESOURCEID;	// Resource type ID.
typedef	RESOURCEID	CMFAR	*PRESOURCEID;	// Pointer to resource type ID.
typedef	ULONG			PRIORITY;	// Priority number.
typedef	DWORD			RANGE_LIST;	// Range list handle.
typedef	RANGE_LIST	CMFAR	*PRANGE_LIST;	// Pointer to a range list handle.
typedef	DWORD			RANGE_ELEMENT;	// Range list element handle.
typedef	RANGE_ELEMENT	CMFAR	*PRANGE_ELEMENT;// Pointer to a range element handle.
typedef	DWORD			LOAD_TYPE;	// For the loading function.
typedef	CMCONFIG	CMFAR	*PCMCONFIG;	// Pointer to a config buffer info.
typedef	DWORD			CMBUSTYPE;	// Type of the bus.
typedef	CMBUSTYPE	CMFAR	*PCMBUSTYPE;	// Pointer to a bus type.
typedef	double			VMM_TIME;	// Time in microticks.
#define	LODWORD(x)		((DWORD)(x))
#define	HIDWORD(x)		(*(PDWORD)(PDWORD(&x)+1))

typedef	ULONG			CONFIGFUNC;
typedef	ULONG			SUBCONFIGFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMCONFIGHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, ULONG, ULONG);
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, DEVNODE, ULONG);
typedef	VOID			(CMFAR _cdecl *CMAPPYCALLBACKHANDLER)(ULONG);

typedef	ULONG			ENUMFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMFUNCTION)(ENUMFUNC, ULONG, DEVNODE, PFARVOID, ULONG);

typedef	ULONG			ARBFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMARBHANDLER)(ARBFUNC, ULONG, DEVNODE, NODELIST_HEADER);

/****************************************************************************
 *
 *				CONFIGURATION MANAGER BUS TYPE
 *
 ***************************************************************************/
#define	BusType_None		0x00000000
#define	BusType_ISA		0x00000001
#define	BusType_EISA		0x00000002
#define	BusType_PCI		0x00000004
#define	BusType_PCMCIA		0x00000008
#define	BusType_ISAPNP		0x00000010
#define	BusType_MCA		0x00000020
#define	BusType_BIOS		0x00000040
#define BusType_USB         0x00000080
/****************************************************************************
 *
 *				CONFIGURATION MANAGER RETURN VALUES
 *
 ***************************************************************************/
#define	CR_SUCCESS		0x00000000
#define	CR_DEFAULT		0x00000001
#define	CR_OUT_OF_MEMORY	0x00000002
#define	CR_INVALID_POINTER	0x00000003
#define	CR_INVALID_FLAG		0x00000004
#define	CR_INVALID_DEVNODE	0x00000005
#define	CR_INVALID_RES_DES	0x00000006
#define	CR_INVALID_LOG_CONF	0x00000007
#define	CR_INVALID_ARBITRATOR	0x00000008
#define	CR_INVALID_NODELIST	0x00000009
#define	CR_DEVNODE_HAS_REQS	0x0000000A
#define	CR_INVALID_RESOURCEID	0x0000000B
#define	CR_DLVXD_NOT_FOUND	0x0000000C
#define	CR_NO_SUCH_DEVNODE	0x0000000D
#define	CR_NO_MORE_LOG_CONF	0x0000000E
#define	CR_NO_MORE_RES_DES	0x0000000F
#define	CR_ALREADY_SUCH_DEVNODE	0x00000010
#define	CR_INVALID_RANGE_LIST	0x00000011
#define	CR_INVALID_RANGE	0x00000012
#define	CR_FAILURE		0x00000013
#define	CR_NO_SUCH_LOGICAL_DEV	0x00000014
#define	CR_CREATE_BLOCKED	0x00000015
#define	CR_NOT_SYSTEM_VM	0x00000016
#define	CR_REMOVE_VETOED	0x00000017
#define	CR_APM_VETOED		0x00000018
#define	CR_INVALID_LOAD_TYPE	0x00000019
#define	CR_BUFFER_SMALL		0x0000001A
#define	CR_NO_ARBITRATOR	0x0000001B
#define	CR_NO_REGISTRY_HANDLE	0x0000001C
#define	CR_REGISTRY_ERROR	0x0000001D
#define	CR_INVALID_DEVICE_ID	0x0000001E
#define	CR_INVALID_DATA		0x0000001F
#define	CR_INVALID_API		0x00000020
#define	CR_DEVLOADER_NOT_READY	0x00000021
#define	CR_NEED_RESTART		0x00000022
#define	CR_NO_MORE_HW_PROFILES	0x00000023
#define	CR_DEVICE_NOT_THERE	0x00000024
#define	CR_NO_SUCH_VALUE	0x00000025
#define	CR_WRONG_TYPE		0x00000026
#define	CR_INVALID_PRIORITY	0x00000027
#define	CR_NOT_DISABLEABLE	0x00000028
#define	CR_FREE_RESOURCES	0x00000029
#define	CR_QUERY_VETOED		0x0000002A
#define	CR_CANT_SHARE_IRQ	0x0000002B
#define	NUM_CR_RESULTS		0x0000002C

/*XLATOFF*/

#define	DEBUG_RETURN_CR_NAMES \
char	CMFAR *lpszReturnCRName[NUM_CR_RESULTS]= \
{ \
	"CR_SUCCESS", \
	"CR_DEFAULT", \
	"CR_OUT_OF_MEMORY", \
	"CR_INVALID_POINTER", \
	"CR_INVALID_FLAG", \
	"CR_INVALID_DEVNODE", \
	"CR_INVALID_RES_DES", \
	"CR_INVALID_LOG_CONF", \
	"CR_INVALID_ARBITRATOR", \
	"CR_INVALID_NODELIST", \
	"CR_DEVNODE_HAS_REQS", \
	"CR_INVALID_RESOURCEID", \
	"CR_DLVXD_NOT_FOUND", \
	"CR_NO_SUCH_DEVNODE", \
	"CR_NO_MORE_LOG_CONF", \
	"CR_NO_MORE_RES_DES", \
	"CR_ALREADY_SUCH_DEVNODE", \
	"CR_INVALID_RANGE_LIST", \
	"CR_INVALID_RANGE", \
	"CR_FAILURE", \
	"CR_NO_SUCH_LOGICAL_DEVICE", \
	"CR_CREATE_BLOCKED", \
	"CR_NOT_SYSTEM_VM", \
	"CR_REMOVE_VETOED", \
	"CR_APM_VETOED", \
	"CR_INVALID_LOAD_TYPE", \
	"CR_BUFFER_SMALL", \
	"CR_NO_ARBITRATOR", \
	"CR_NO_REGISTRY_HANDLE", \
	"CR_REGISTRY_ERROR", \
	"CR_INVALID_DEVICE_ID", \
	"CR_INVALID_DATA", \
	"CR_INVALID_API", \
	"CR_DEVLOADER_NOT_READY", \
	"CR_NEED_RESTART", \
	"CR_NO_MORE_HW_PROFILES", \
	"CR_DEVICE_NOT_THERE", \
	"CR_NO_SUCH_VALUE", \
	"CR_WRONG_TYPE", \
	"CR_INVALID_PRIORITY", \
	"CR_NOT_DISABLEABLE", \
	"CR_FREE_RESOURCES", \
	"CR_QUERY_VETOED", \
	"CR_CANT_SHARE_IRQ", \
};

/*XLATON*/

#define	CM_PROB_NOT_CONFIGURED			0x00000001
#define	CM_PROB_DEVLOADER_FAILED		0x00000002
#define	CM_PROB_OUT_OF_MEMORY			0x00000003
#define	CM_PROB_ENTRY_IS_WRONG_TYPE		0x00000004
#define	CM_PROB_LACKED_ARBITRATOR		0x00000005
#define	CM_PROB_BOOT_CONFIG_CONFLICT		0x00000006
#define	CM_PROB_FAILED_FILTER			0x00000007
#define	CM_PROB_DEVLOADER_NOT_FOUND		0x00000008
#define	CM_PROB_INVALID_DATA			0x00000009
#define	CM_PROB_FAILED_START			0x0000000A
#define	CM_PROB_LIAR				0x0000000B
#define	CM_PROB_NORMAL_CONFLICT			0x0000000C
#define	CM_PROB_NOT_VERIFIED			0x0000000D
#define	CM_PROB_NEED_RESTART			0x0000000E
#define	CM_PROB_REENUMERATION			0x0000000F
#define	CM_PROB_PARTIAL_LOG_CONF		0x00000010
#define	CM_PROB_UNKNOWN_RESOURCE		0x00000011
#define	CM_PROB_REINSTALL			0x00000012
#define	CM_PROB_REGISTRY			0x00000013
#define	CM_PROB_VXDLDR				0x00000014
#define	CM_PROB_WILL_BE_REMOVED			0x00000015
#define	CM_PROB_DISABLED			0x00000016
#define	CM_PROB_DEVLOADER_NOT_READY		0x00000017
#define	CM_PROB_DEVICE_NOT_THERE		0x00000018
#define	CM_PROB_MOVED				0x00000019
#define	CM_PROB_TOO_EARLY			0x0000001A
#define	CM_PROB_NO_VALID_LOG_CONF		0x0000001B
#define	CM_PROB_FAILED_INSTALL			0x0000001C
#define	CM_PROB_HARDWARE_DISABLED		0x0000001D
#define	CM_PROB_CANT_SHARE_IRQ			0x0000001E
#define	NUM_CM_PROB				0x0000001F

/*XLATOFF*/

#define	DEBUG_CM_PROB_NAMES \
char	CMFAR *lpszCMProbName[NUM_CM_PROB]= \
{ \
	"No Problem", \
	"No ConfigFlags (not configured)", \
	"Devloader failed", \
	"Run out of memory", \
	"Devloader/StaticVxD/Configured is of wrong type", \
	"Lacked an arbitrator", \
	"Boot config conflicted", \
	"Filtering failed", \
	"Devloader not found", \
	"Invalid data in registry", \
	"Device failed to start", \
	"Device failed something not failable", \
	"Was normal conflicting", \
	"Did not verified", \
	"Need restart", \
	"Is probably reenumeration", \
	"Was not fully detected", \
	"Resource number was not found", \
	"Reinstall", \
	"Registry returned unknown result", \
	"VxDLdr returned unknown result", \
	"Will be removed", \
	"Disabled", \
	"Devloader was not ready", \
	"Device not there", \
	"Was moved", \
	"Too early", \
	"No valid log conf", \
	"Failed install", \
	"Hardware Disabled", \
	"Can't share IRQ", \
};

/*XLATON*/

#define	CM_INITIALIZE_VMM			0x00000000
#define	CM_INITIALIZE_VXDLDR			0x00000001
#define	CM_INITIALIZE_BITS			0x00000001

#define	CM_YIELD_NO_RESUME_EXEC			0x00000000
#define	CM_YIELD_RESUME_EXEC			0x00000001
#define	CM_YIELD_BITS				0x00000001

#define	CM_CREATE_DEVNODE_NORMAL		0x00000000
#define	CM_CREATE_DEVNODE_NO_WAIT_INSTALL	0x00000001
#define	CM_CREATE_DEVNODE_BITS			0x00000001

#define	CM_REGISTER_DEVICE_DRIVER_STATIC	0x00000000
#define	CM_REGISTER_DEVICE_DRIVER_DISABLEABLE	0x00000001
#define	CM_REGISTER_DEVICE_DRIVER_REMOVABLE	0x00000002
#define	CM_REGISTER_DEVICE_DRIVER_BITS		0x00000003

#define	CM_REGISTER_ENUMERATOR_SOFTWARE		0x00000000
#define	CM_REGISTER_ENUMERATOR_HARDWARE		0x00000001
#define	CM_REGISTER_ENUMERATOR_BITS		0x00000001

#define	CM_QUERY_REMOVE_UI_OK			0x00000000
#define	CM_QUERY_REMOVE_UI_NOT_OK		0x00000001
#define	CM_QUERY_REMOVE_BITS			0x00000001

#define	CM_REMOVE_UI_OK				0x00000000
#define	CM_REMOVE_UI_NOT_OK			0x00000001
#define	CM_REMOVE_BITS				0x00000001

#define	CM_SETUP_DEVNODE_READY			0x00000000
#define	CM_SETUP_DOWNLOAD			0x00000001
#define	CM_SETUP_WRITE_LOG_CONFS		0x00000002
#define	CM_SETUP_PROP_CHANGE			0x00000003
#define	CM_SETUP_BITS				0x00000003

#define	CM_ADD_RANGE_ADDIFCONFLICT		0x00000000
#define	CM_ADD_RANGE_DONOTADDIFCONFLICT		0x00000001
#define	CM_ADD_RANGE_BITS			0x00000001

#define	CM_ISAPNP_ADD_RES_DES			0x00000000
#define	CM_ISAPNP_SETUP				0x00000001
#define	CM_ISAPNP_ADD_BOOT_RES_DES		0x00000002
#define	CM_ISAPNP_ADD_RES_DES_UNCONFIGURABLE	0x00000003
#define	CM_ISAPNP_BITS				0x00000003

#define	CM_GET_PERFORMANCE_INFO_DATA		0x00000000
#define	CM_GET_PERFORMANCE_INFO_RESET		0x00000001
#define	CM_GET_PERFORMANCE_INFO_START		0x00000002
#define	CM_GET_PERFORMANCE_INFO_STOP		0x00000003
#define	CM_RESET_HIT_DATA			0x00000004
#define	CM_GET_HIT_DATA 			0x00000005
#define	CM_GET_PERFORMANCE_INFO_BITS		0x0000000F
#define	CM_HIT_DATA_FILES			0xFFFF0000
#define	CM_HIT_DATA_SIZE			((256*8)+8)  // magic number!

#define	CM_GET_ALLOC_LOG_CONF_ALLOC		0x00000000
#define	CM_GET_ALLOC_LOG_CONF_BOOT_ALLOC	0x00000001
#define	CM_GET_ALLOC_LOG_CONF_BITS		0x00000001

#define	CM_REGISTRY_HARDWARE			0x00000000	// Select hardware branch if NULL subkey
#define	CM_REGISTRY_SOFTWARE			0x00000001	// Select software branch if NULL subkey
#define	CM_REGISTRY_USER			0x00000100	// Use HKEY_CURRENT_USER
#define	CM_REGISTRY_CONFIG			0x00000200	// Use HKEY_CURRENT_CONFIG
#define	CM_REGISTRY_BITS			0x00000301	// The bits for the registry functions

#define	CM_DISABLE_POLITE			0x00000000	// Ask the driver
#define	CM_DISABLE_ABSOLUTE			0x00000001	// Don't ask the driver
#define	CM_DISABLE_HARDWARE			0x00000002	// Don't ask the driver, and won't be restarteable
#define	CM_DISABLE_BITS				0x00000003	// The bits for the disable function

#define	CM_HW_PROF_UNDOCK			0x00000000	// Computer not in a dock.
#define	CM_HW_PROF_DOCK				0x00000001	// Computer in a docking station
#define	CM_HW_PROF_RECOMPUTE_BITS		0x00000001	// RecomputeConfig
#define	CM_HW_PROF_DOCK_KNOWN			0x00000002	// Computer in a known docking station
#define	CM_HW_PROF_QUERY_CHANGE_BITS		0x00000003	// QueryChangeConfig

#define	CM_DETECT_NEW_PROFILE			0x00000001	// run detect for a new profile
#define	CM_DETECT_CRASHED			0x00000002	// detection crashed before
#define	CM_DETECT_HWPROF_FIRST_BOOT		0x00000004	// first boot in a new profile
#define	CM_DETECT_RUN				0x80000000	// run detection for new hardware

#define	CM_ADD_ID_HARDWARE			0x00000000
#define	CM_ADD_ID_COMPATIBLE			0x00000001
#define	CM_ADD_ID_BITS				0x00000001

#define	CM_REENUMERATE_NORMAL			0x00000000
#define	CM_REENUMERATE_SYNCHRONOUS		0x00000001
#define	CM_REENUMERATE_BITS			0x00000001

#define	CM_BROADCAST_SEND			0x00000000
#define	CM_BROADCAST_QUERY			0x00000001
#define	CM_BROADCAST_BITS			0x00000001

#define	CM_CALL_HANDLER_ENUMERATOR		0x00000000
#define	CM_CALL_HANDLER_DEVICE_DRIVER		0x00000001
#define	CM_CALL_HANDLER_BITS			0x00000001

#define	CM_GLOBAL_STATE_CAN_DO_UI		0x00000001
#define	CM_GLOBAL_STATE_ON_BIG_STACK		0x00000002
#define	CM_GLOBAL_STATE_SERVICES_AVAILABLE	0x00000004
#define	CM_GLOBAL_STATE_SHUTING_DOWN		0x00000008
#define	CM_GLOBAL_STATE_DETECTION_PENDING	0x00000010

#define	CM_REMOVE_REINSERT_ALL_REMOVE		0x00000000
#define	CM_REMOVE_REINSERT_ALL_REINSERT		0x00000001
#define	CM_REMOVE_REINSERT_ALL_BITS		0x00000001

/****************************************************************************
 *
 *				CONFIGURATION MANAGER FUNCTIONS
 *
 ****************************************************************************
 * 
 *	Each devnode has a config handler field and a enum handler field
 *	which are getting called every time Configuration Manager wants a
 *	devnode to perform some configuration related function. The handler
 *	is registered with CM_Register_Device_Driver or
 *	CM_Register_Enumerator, depending if the handler is for the device
 *	itself or for one of the children of the devnode.
 *
 *	The registered handler is called with:
 *
 *	result=dnToDevNode->dn_Config(if dnToDevNode==dnAboutDevNode)
 *	result=dnToDevNode->dn_Enum(if dnToDevNode!=dnAboutDevNode)
 *					(	FuncName,
 *					 	SubFuncName,
 *						dnToDevNode,
 *						dnAboutDevNode, (if enum)
 *						dwRefData, (if driver)
 *						ulFlags);
 *	Where:
 *
 *	FuncName is one of CONFIG_FILTER, CONFIG_START, CONFIG_STOP,
 *	CONFIG_TEST, CONFIG_REMOVE, CONFIG_ENUMERATE, CONFIG_SETUP or
 *	CONFIG_CALLBACK.
 *
 *	SubFuncName is the specific CONFIG_xxxx_* that further describe
 *	we START, STOP or TEST.
 *
 *	dnToDevNode is the devnode we are calling. This is given so that
 *	a signle handler can handle multiple devnodes.
 *
 *	dnAboutDevNode specifies which devnode the function is about. For
 *	a config handler, this is necessarily the same as dnToDevNode. For
 *	an enumerator handler, this devnode is necessarily different as it
 *	is a child of the dnToDevNode (special case: CONFIG_ENUMERATE
 *	necessarily has dnAboutDevNode==NULL). For instance, when starting
 *	a COM devnode under a BIOS enumerator, we would make the following
 *	two calls:
 *
 *		To BIOS with (CONFIG_START, ?, BIOS, COM, ?, 0).
 *
 *		To COM with (CONFIG_START, ?, COM, COM, ?, 0).
 *
 *	dwRefData is a dword of reference data. For a config handler, it is
 *	the DWORD passed on the CONFIGMG_Register_Device_Driver call. For an
 *	enumerator, it is the same as CONFIGMG_Get_Private_DWord(?,
 *	dnToDevNode, dnToDevNode, 0).
 *
 *	ulFlags is 0 and is reserved for future extensions.
 *
 *	Here is the explanation of each event, in parenthesis I put the
 *	order the devnodes will be called:
 *
 *	CONFIG_FILTER (BRANCH GOING UP) is the first thing called when a new
 *	insertion or change of configuration need to be processed. First
 *	CM copies the requirement list (BASIC_LOG_CONF) onto the filtered
 *	requirement list (FILTER_LOG_CONF) so that they are originally
 *	the same. CM then calls every node up, giving them the chance to
 *	patch the requirement of the dnAboutDevNode (they can also
 *	alter their own requirement). Examples are PCMCIA which would
 *	remove some IRQ that the adapter can't do, prealloc some IO
 *	windows and memory windows. ISA which would limit address space
 *	to being <16Meg. A device driver should look only at
 *	FILTER_LOG_CONF during this call.
 *
 *	CONFIG_START (BRANCH GOING DOWN) are called to change the
 *	configuration. A config handler/enumerator hander should look
 *	only at the allocated list (ALLOC_LOG_CONF).
 *
 *	CONFIG_STOP (WHOLE TREE BUT ONLY DEVNODES THAT CHANGE
 *	CONFIGURATION (FOR EACH DEVNODE, BRANCH GOING UP)) is called
 *	for two reasons:
 *
 *		1) Just after the rebalance algorithm came up with a
 *		solution and we want to stop all devnodes that will be
 *		rebalance. This is to avoid the problem of having two cards
 *		that can respond to 110h and 220h and that need to toggle
 *		their usage. We do not want two people responding to 220h,
 *		even for a brief amount of time. This is the normal call
 *		though.
 *
 *		2) There was a conflict and the user selected this device
 *		to kill.
 *
 *	CONFIG_TEST (WHOLE TREE) is called before starting the rebalance
 *	algorithm. Device drivers that fail this call will be considered
 *	worst than jumpered configured for the reminder of this balancing
 *	process. 
 *
 *	CONFIG_REMOVE (FOR EACH SUB TREE NODE, DOING BRANCH GOING UP), is
 *	called when someone notify CM via CM_Remove_SubTree that a devnode
 *	is not needed anymore. A static VxD probably has nothing to do. A
 *	dynamic VxD should check whether it should unload itself (return
 *	CR_SUCCESS_UNLOAD) or not (CR_SUCCESS).
 *
 *	Note, failing any of CONFIG_START, or CONFIG_STOP is really bad,
 *	both in terms of performance and stability. Requirements for a
 *	configuration to succeed should be noted/preallocated during
 *	CONFIG_FILTER. Failing CONFIG_TEST is less bad as what basically
 *	happens is that the devnode is considered worst than jumpered
 *	configured for the reminder of this pass of the balancing algorithm.
 *
 *	COMFIG_ENUMERATE, the called node should create children devnodes
 *	using CM_Create_DevNode (but no need for grand children) and remove
 *	children using CM_Remove_SubTree as appropriate. Config Manager
 *	will recurse calling the children until nothing new appears. During
 *	this call, dnAboutDevNode will be NULL. Note that there is an easy
 *	way for buses which do not have direct children accessibility to
 *	detect (ISAPNP for instance will isolate one board at a time and
 *	there is no way to tell one specific board not to participate in
 *	the isolation sequence):
 *
 *	If some children have soft-eject capability, check those first.
 *	If the user is pressing the eject button, call Query_Remove_SubTree
 *	and if that succeed, call Remove_SubTree.
 *
 *	Do a CM_Reset_Children_Marks on the bus devnode.
 *
 *	Do the usual sequence doing CM_Create_DevNode calls. If a devnode
 *	was already there, CR_ALREADY_SUCH_DEVNODE is returned and this
 *	devnode's DN_HAS_MARK will be set. There is nothing more to do with
 *	this devnode has it should just continue running. If the devnode
 *	was not previously there, CR_SUCCESS will be return, in which case
 *	the enumerator should add the logical configurations.
 *
 *	Once all the devnode got created. The enumerator can call
 *	CM_Remove_Unmarked_Children to remove the devnode that are now gone.
 *	Essentially, this is a for loop thru all the children of the bus
 *	devnode, doing Remove_SubTree on the the devnode which have their
 *	mark cleared. Alternatively, an enumerator can use CM_Get_Child,
 *	CM_Get_Sibling, CM_Remove_SubTree and CM_Get_DevNode_Status.
 *
 *	For CONFIG_SETUP, the called node should install drivers if it
 *	know out to get them. This is mostly for drivers imbeded in the
 *	cards (ISA_RTR, PCI or PCMCIA). For most old cards/driver, this
 *	should return CR_NO_DRIVER.
 *
 *	WARNING: For any non-defined service, the enumertor / device
 *	driver handler should return CR_DEFAULT. This will be treated
 *	as the compatibility case in future version.
 *
 *	So normally what happens is as follows:
 *
 *	- Some detection code realize there is a new device. This can be at
 *	initialization time or at run-time (usually during a media_change
 *	interrupt). The code does a CM_Reenumerate_DevNode(dnBusDevNode)
 *	asynchronous call.
 *
 *	- During appy time event, CM gets notified.
 *
 *	- CM calls the enumerator with:
 *
 *		BusEnumHandler(CONFIG_ENUMERATE, 0, dnBusDevNode, NULL, ?, 0);
 *
 *	- The parent uses CM_Create_DevNode and CM_Remove_SubTree as
 *	appropriate, usually for only its immediate children.
 *
 *	- The parent return to CM from the enumerator call.
 *
 *	- CM walks the children, first loading their device driver if
 *	needed, then calling their enumerators. Thus the whole process
 *	will terminate only when all grand-...-grand-children have stopped
 *	using CM_Create_DevNode.
 *
 *	If rebalance is called (a new devnode is conflicting):
 *
 *	- All devnode receives the CONFIG_TEST. Devnodes that
 *	fail it are considered worst than jumpered configured.
 *
 *	- CM does the rebalance algorithm.
 *
 *	- All affected devnodes that where previously loaded get the
 *	CONFIG_STOP event.
 *
 *	- All affected devnode and the new devnodes receives a CONFIG_START.
 *
 *	If rebalancing failed (couldn't make one or more devnodes work):
 *
 *	- Device installer is called which will present the user with a
 *	choice of devnode to kill.
 *
 *	- Those devnodes will received a CONFIG_STOP message.
 *	
 ***************************************************************************/

// Possible CONFIGFUNC FuncNames:

#define	CONFIG_FILTER		0x00000000	// Ancestors must filter requirements.
#define	CONFIG_START		0x00000001	// Devnode dynamic initialization.
#define	CONFIG_STOP		0x00000002	// Devnode must stop using config.
#define	CONFIG_TEST		0x00000003	// Can devnode change state now.
#define	CONFIG_REMOVE		0x00000004	// Devnode must stop using config.
#define	CONFIG_ENUMERATE	0x00000005	// Devnode must enumerated.
#define	CONFIG_SETUP		0x00000006	// Devnode should download driver.
#define	CONFIG_CALLBACK		0x00000007	// Devnode is being called back.
#define	CONFIG_APM		0x00000008	// APM functions.
#define	CONFIG_TEST_FAILED	0x00000009	// Continue as before after a TEST.
#define	CONFIG_TEST_SUCCEEDED	0x0000000A	// Prepare for the STOP/REMOVE.
#define	CONFIG_VERIFY_DEVICE	0x0000000B	// Insure the legacy card is there.
#define	CONFIG_PREREMOVE	0x0000000C	// Devnode must stop using config.
#define	CONFIG_SHUTDOWN		0x0000000D	// We are shutting down.
#define	CONFIG_PREREMOVE2	0x0000000E	// Devnode must stop using config.
#define	CONFIG_READY		0x0000000F	// The devnode has been setup.
#define	CONFIG_PROP_CHANGE	0x00000010	// The property page is exiting.
#define	CONFIG_PRIVATE		0x00000011	// Someone called Call_Handler.
#define	CONFIG_PRESHUTDOWN	0x00000012	// We are shutting down

#define	NUM_CONFIG_COMMANDS	0x00000013	// For DEBUG.

/*XLATOFF*/

#define	DEBUG_CONFIG_NAMES \
char	CMFAR *lpszConfigName[NUM_CONFIG_COMMANDS]= \
{ \
	"CONFIG_FILTER", \
	"CONFIG_START", \
	"CONFIG_STOP", \
	"CONFIG_TEST", \
	"CONFIG_REMOVE", \
	"CONFIG_ENUMERATE", \
	"CONFIG_SETUP", \
	"CONFIG_CALLBACK", \
	"CONFIG_APM", \
	"CONFIG_TEST_FAILED", \
	"CONFIG_TEST_SUCCEEDED", \
	"CONFIG_VERIFY_DEVICE", \
	"CONFIG_PREREMOVE", \
	"CONFIG_SHUTDOWN", \
	"CONFIG_PREREMOVE2", \
	"CONFIG_READY", \
	"CONFIG_PROP_CHANGE", \
	"CONFIG_PRIVATE", \
	"CONFIG_PRESHUTDOWN", \
};

/*XLATON*/

// Possible SUBCONFIGFUNC SubFuncNames:

#define	CONFIG_START_DYNAMIC_START			0x00000000
#define	CONFIG_START_FIRST_START			0x00000001

#define	CONFIG_STOP_DYNAMIC_STOP			0x00000000
#define	CONFIG_STOP_HAS_PROBLEM				0x00000001

//
// For both CONFIG_REMOVE, CONFIG_PREREMOVE and CONFIG_POSTREMOVE
//
#define	CONFIG_REMOVE_DYNAMIC				0x00000000
#define	CONFIG_REMOVE_SHUTDOWN				0x00000001
#define	CONFIG_REMOVE_REBOOT				0x00000002

#define	CONFIG_TEST_CAN_STOP				0x00000000
#define	CONFIG_TEST_CAN_REMOVE				0x00000001

#define	CONFIG_APM_TEST_STANDBY				0x00000000
#define	CONFIG_APM_TEST_SUSPEND				0x00000001
#define	CONFIG_APM_TEST_STANDBY_FAILED			0x00000002
#define	CONFIG_APM_TEST_SUSPEND_FAILED			0x00000003
#define	CONFIG_APM_TEST_STANDBY_SUCCEEDED		0x00000004
#define	CONFIG_APM_TEST_SUSPEND_SUCCEEDED		0x00000005
#define	CONFIG_APM_RESUME_STANDBY			0x00000006
#define	CONFIG_APM_RESUME_SUSPEND			0x00000007
#define	CONFIG_APM_RESUME_CRITICAL			0x00000008
#define	CONFIG_APM_UI_ALLOWED                  		0x80000000

/****************************************************************************
 *
 *				ARBITRATOR FUNCTIONS
 *
 ****************************************************************************
 *
 *	Each arbitrator has a handler field which is getting called every
 *	time Configuration Manager wants it to perform a function. The
 *	handler is called with:
 *
 *	result=paArbitrator->Arbitrate(	EventName,
 *					paArbitrator->DWordToBePassed,
 *					paArbitrator->dnItsDevNode,
 *					pnlhNodeListHeader);
 *
 *	ENTRY:	NodeListHeader contains a logical configuration for all
 *		devices the configuration manager would like to reconfigure.
 *		DWordToBePassed is the arbitrator reference data.
 *		ItsDevNode is the pointer to arbitrator's devnode.
 *		EventName is one of the following:
 *
 *	ARB_TEST_ALLOC - Test allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. See individual arbitrator for the algorithm
 *		employed. Generally, the arbitration consists
 *		of sorting the list according to most likely succesful
 *		allocation order, making a copy of the current allocation
 *		data strucuture(s), releasing all resource currently
 *		allocated to devnodes on the list from the copy data structure
 *		and then attempting to satisfy allocation requests
 *		by passing through the entire list, trying all possible
 *		combinations of allocations before failing. The arbitrator
 *		saves the resultant successful allocations, both in the node
 *		list per device and the copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_RETEST_ALLOC - Retest allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and attempt to allocate that resource for each allcoation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then attempt to satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_FORCE_ALLOC - Retest allocation of resource, always succeed
 *
 *	DESC:	The arbitration routine will satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and allocate that resource for each allocation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_SET_ALLOC - Makes a test allocation the real allocation
 *
 *	DESC:	Makes the copy of the allocation data structure the
 *		current valid allocation.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	ARB_RELEASE_ALLOC - Clean up after failed test allocation
 *
 *	DESC:	Free all allocation that were allocated by the previous
 *		ARB_TEST_ALLOC.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	ARB_QUERY_FREE - Add all free resource logical configuration
 *
 *	DESC:	Return resource specific data on the free element. Note
 *		than the pnlhNodeListHeader is a cast of an arbitfree_s.
 *
 *	EXIT:	CR_SUCCESS if successful
 *		CR_FAILURE if the request makles no sense.
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_REMOVE - The devnode the arbitrator registered with is going away
 *
 *	DESC:	Arbitrator registered with a non-NULL devnode (thus is
 *		normally local), and the devnode is being removed. Arbitrator
 *		should do appropriate cleanup.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	WARNING: For any non-defined service, the arbitrator should return
 *	CR_DEFAULT. This will be treated as the compatibility case in future
 *	version.
 *
 ***************************************************************************/
#define	ARB_TEST_ALLOC		0x00000000	// Check if can make alloc works.
#define	ARB_RETEST_ALLOC	0x00000001	// Check if can take previous alloc.
#define	ARB_SET_ALLOC		0x00000002	// Set the tested allocation.
#define	ARB_RELEASE_ALLOC	0x00000003	// Release the tested allocation.
#define	ARB_QUERY_FREE		0x00000004	// Return free resource.
#define	ARB_REMOVE		0x00000005	// DevNode is gone.
#define	ARB_FORCE_ALLOC		0x00000006	// Force previous TEST_ALLOC
#define	NUM_ARB_COMMANDS	0x00000007	// Number of arb commands

#define	DEBUG_ARB_NAMES \
char	CMFAR *lpszArbFuncName[NUM_ARB_COMMANDS]= \
{ \
	"ARB_TEST_ALLOC",\
	"ARB_RETEST_ALLOC",\
	"ARB_SET_ALLOC",\
	"ARB_RELEASE_ALLOC",\
	"ARB_QUERY_FREE",\
	"ARB_REMOVE",\
	"ARB_FORCE_ALLOC",\
};

/****************************************************************************
 *
 *				DEVNODE STATUS
 *
 ****************************************************************************
 *
 *	These are the bits in the devnode's status that someone can query
 *	with a CM_Get_DevNode_Status. The A/S column tells wheter the flag
 *	cann be change asynchronously or not.
 *
 ***************************************************************************/
#define	DN_ROOT_ENUMERATED	0x00000001	// S: Was enumerated by ROOT
#define	DN_DRIVER_LOADED	0x00000002	// S: Has Register_Device_Driver
#define	DN_ENUM_LOADED		0x00000004	// S: Has Register_Enumerator
#define	DN_STARTED		0x00000008	// S: Is currently configured
#define	DN_MANUAL		0x00000010	// S: Manually installed
#define	DN_NEED_TO_ENUM		0x00000020	// A: May need reenumeration
#define	DN_NOT_FIRST_TIME	0x00000040	// S: Has received a config
#define	DN_HARDWARE_ENUM	0x00000080	// S: Enum generates hardware ID
#define	DN_LIAR 		0x00000100	// S: Lied about can reconfig once
#define	DN_HAS_MARK		0x00000200	// S: Not CM_Create_DevNode lately
#define	DN_HAS_PROBLEM		0x00000400	// S: Need device installer
#define	DN_FILTERED		0x00000800	// S: Is filtered
#define	DN_MOVED		0x00001000	// S: Has been moved
#define	DN_DISABLEABLE		0x00002000	// S: Can be rebalanced
#define	DN_REMOVABLE		0x00004000	// S: Can be removed
#define	DN_PRIVATE_PROBLEM	0x00008000	// S: Has a private problem
#define	DN_MF_PARENT		0x00010000	// S: Multi function parent
#define	DN_MF_CHILD		0x00020000	// S: Multi function child
#define	DN_WILL_BE_REMOVED	0x00040000	// S: Devnode is being removed

/*XLATOFF*/

#define	NUM_DN_FLAG		0x00000013	// DEBUG: maximum flag (number)
#define	DN_FLAG_LEN		0x00000002	// DEBUG: flag length

#define	DEBUG_DN_FLAGS_NAMES \
char	CMFAR lpszDNFlagsName[NUM_DN_FLAG][DN_FLAG_LEN]= \
{ \
	"rt", \
	"dl", \
	"el", \
	"st", \
	"mn", \
	"ne", \
	"fs", \
	"hw", \
	"lr", \
	"mk", \
	"pb", \
	"ft", \
	"mv", \
	"db", \
	"rb", \
	"pp", \
	"mp", \
	"mc", \
	"rm", \
};

struct vmmtime_s {
DWORD		vmmtime_lo;
DWORD		vmmtime_hi;
};

typedef	struct vmmtime_s	VMMTIME;
typedef	VMMTIME			*PVMMTIME;

struct cmtime_s {
DWORD		dwAPICount;
VMMTIME		vtAPITime;
};

typedef	struct cmtime_s		CMTIME;
typedef	CMTIME			*PCMTIME;

struct cm_performance_info_s {
CMTIME		ctBoot;
CMTIME		ctAPI[NUM_CM_SERVICES];
CMTIME		ctRing3;
CMTIME		ctProcessTree;
CMTIME		ctAssignResources;
CMTIME		ctSort;
CMTIME		ctRegistry;
CMTIME		ctVxDLdr;
CMTIME		ctNewDevNode;
CMTIME		ctSendMessage;
CMTIME		ctShell;
CMTIME		ctReceiveMessage;
CMTIME		ctAppyTime;
CMTIME		ctConfigMessage[NUM_CONFIG_COMMANDS];
CMTIME		ctArbTime[ResType_Max+1][NUM_ARB_COMMANDS];
DWORD		dwStackSize;
DWORD		dwMaxProcessTreePasses;
DWORD		dwStackAlloc;
};

typedef	struct	cm_performance_info_s	CMPERFINFO;
typedef	CMPERFINFO		CMFAR	*PCMPERFINFO;

/*XLATON*/

/****************************************************************************
 *
 *				DLVXD FUNCTIONS
 *
 ****************************************************************************
 *
 *	We load a Dynamically loaded VxD when there is a DEVLOADER=... line
 *	in the registry, or when someone calls CM_Load_Device. We then do
 *	a direct system control call (PNP_NEW_DEVNODE) to it, telling the
 *	DLVXD whether we loaded it to be an enumerator, a driver or a
 *	devloader (config manager does only deal with devloaders, but the
 *	default devloaders does CM_Load_Device with DLVXD_LOAD_ENUMERATOR
 *	and DLVXD_LOAD_DRIVER).
 *
 ***************************************************************************/
#define	DLVXD_LOAD_ENUMERATOR	0x00000000	// We loaded DLVxD as an enumerator.
#define	DLVXD_LOAD_DEVLOADER	0x00000001	// We loaded DLVxD as a devloader.
#define	DLVXD_LOAD_DRIVER	0x00000002	// We loaded DLVxD as a device driver.
#define	NUM_DLVXD_LOAD_TYPE	0x00000003	// Number of DLVxD load type.

/****************************************************************************
 *
 *				GLOBALLY DEFINED FLAGS
 *
 ***************************************************************************/
#define	ARB_GLOBAL		0x00000001	// Arbitrator is global.
#define	ARB_LOCAL		0x00000000	// Arbitrator is local.
#define	ARB_SCOPE_BIT		0x00000001	// Arbitrator is global/local bit.

#define	BASIC_LOG_CONF		0x00000000	// Specifies the req list.
#define	FILTERED_LOG_CONF	0x00000001	// Specifies the filtered req list.
#define	ALLOC_LOG_CONF		0x00000002	// Specifies the Alloc Element.
#define	BOOT_LOG_CONF		0x00000003	// Specifies the RM Alloc Element.
#define	FORCED_LOG_CONF		0x00000004	// Specifies the Forced Log Conf
#define	NUM_LOG_CONF		0x00000005	// Number of Log Conf type
#define	LOG_CONF_BITS		0x00000007	// The bits of the log conf type.

#define	DEBUG_LOG_CONF_NAMES \
char	CMFAR *lpszLogConfName[NUM_LOG_CONF]= \
{ \
	"BASIC_LOG_CONF",\
	"FILTERED_LOG_CONF",\
	"ALLOC_LOG_CONF",\
	"BOOT_LOG_CONF",\
	"FORCED_LOG_CONF",\
};

#define	PRIORITY_EQUAL_FIRST	0x00000008	// Same priority, new one is first.
#define	PRIORITY_EQUAL_LAST	0x00000000	// Same priority, new one is last.
#define	PRIORITY_BIT		0x00000008	// The bit of priority.

#ifndef	Not_VxD

/****************************************************************************
 *
 * Arbitration list structures
 *
 ***************************************************************************/
struct	nodelist_s {
	struct nodelist_s	*nl_Next;		// Next node element
	struct nodelist_s	*nl_Previous;		// Previous node element
	struct devnode_s	*nl_ItsDevNode;		// The dev node it represent

	// You can add fields to this structure, but the first three
	// fields must NEVER be changed.

	struct Log_Conf 	*nl_Test_Req;		// Test resource alloc request
	ULONG			nl_ulSortDWord;		// Specifies the sort order
};

struct	nodelistheader_s {
	struct	nodelist_s	*nlh_Head;		// First node element
	struct	nodelist_s	*nlh_Tail;		// Last node element
};

struct	arbitfree_s {
	PVOID			*af_PointerToInfo;	// the arbitrator info
	ULONG			af_SizeOfInfo;		// size of the info
};

#endif

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for memory returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken memory address space.
 */
struct	MEM_Arb_s {
	RANGE_LIST		MEMA_Alloc;
};

typedef	struct MEM_Arb_s	MEMA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for IO returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken IO address space.
 */
struct	IO_Arb_s {
	RANGE_LIST		IOA_Alloc;
};

typedef	struct IO_Arb_s		IOA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for DMA returns the DMA_Arb_s,
 *	16 bits of allocation bit mask, where DMAA_Alloc is inverted
 *	(set bit indicates free port).
 */
struct	DMA_Arb_s {
	WORD			DMAA_Alloc;
};

typedef	struct DMA_Arb_s	DMA_ARB;

/***************************************************************************
 * ARB_QUERY_FREE arbitrator function for IRQ returns the IRQ_Arb_s,
 *	16 bits of allocation bit mask, 16 bits of share bit mask and 16
 *	BYTES of share count. IRQA_Alloc is inverted (bit set indicates free
 *	port). If port is not free, IRQA_Share bit set indicates port
 *	that is shareable. For shareable IRQs, IRQA_Share_Count indicates
 *	number of devices that are sharing an IRQ.
 */
struct	IRQ_Arb_s {
	WORD			IRQA_Alloc;
	WORD			IRQA_Share;
	BYTE			IRQA_Share_Count[16];
};

typedef	struct IRQ_Arb_s	IRQ_ARB;

/* ASM
DebugCommand	Macro	FuncName
		local	DC_01
ifndef	CM_GOLDEN_RETAIL
ifndef	debug
 	IsDebugOnlyLoaded	DC_01
endif
	Control_Dispatch	DEBUG_QUERY, FuncName, sCall
endif
DC_01:
endm
IFDEF CM_PERFORMANCE_INFO
CM_PAGEABLE_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_LOCKED_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_LOCKED_DATA_ENDS>
ELSE
CM_PAGEABLE_CODE_SEG	TEXTEQU <VxD_PNP_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU <VxD_PNP_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_PAGEABLE_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_PAGEABLE_DATA_ENDS>
ENDIF

IFDEF CM_GOLDEN_RETAIL
CM_DEBUG_CODE_SEG	TEXTEQU	<.err>
CM_DEBUG_CODE_ENDS	TEXTEQU	<.err>
ELSE
IFDEF DEBUG
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
ELSE
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_DEBUG_ONLY_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_DEBUG_ONLY_CODE_ENDS>
ENDIF
ENDIF
*/

struct	CM_API_s {
DWORD		pCMAPIStack;
DWORD		dwCMAPIService;
DWORD		dwCMAPIRet;
};

typedef	struct	CM_API_s	CMAPI;

#ifndef	MAX_PROFILE_LEN
#define	MAX_PROFILE_LEN	80
#endif

struct	HWProfileInfo_s {
ULONG	HWPI_ulHWProfile;			// the profile handle
char	HWPI_szFriendlyName[MAX_PROFILE_LEN];	// the friendly name (OEM format)
DWORD	HWPI_dwFlags;				// CM_HWPI_* flags
};

typedef	struct	HWProfileInfo_s	       HWPROFILEINFO;
typedef	struct	HWProfileInfo_s	      *PHWPROFILEINFO;
typedef	struct	HWProfileInfo_s	CMFAR *PFARHWPROFILEINFO;

#define	CM_HWPI_NOT_DOCKABLE	0x00000000
#define	CM_HWPI_UNDOCKED	0x00000001
#define	CM_HWPI_DOCKED		0x00000002

/*XLATOFF*/

#define	CM_VXD_RESULT		int

#define	CM_EXTERNAL		_cdecl
#define	CM_HANDLER		_cdecl
#define	CM_SYSCTRL		_stdcall
#define	CM_GLOBAL_DATA
#define	CM_LOCAL_DATA		static

#define	CM_OFFSET_OF(type, id)	((DWORD)(&(((type)0)->id)))

#define	CM_BUGBUG(d, id, msg)	message("BUGBUG: "##d##", "##id##": "##msg)

#ifndef	DEBUG

#define	CM_WARN1(strings)
#define	CM_WARN2(strings)
#define	CM_ERROR(strings)

#else

#ifndef	MAXDEBUG

#define	CM_WARN1(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#define	CM_WARN2(strings)
#define	CM_ERROR(strings) {\
	_Debug_Printf_Service(WARNNAME " ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}

#else

#define	CM_WARN1(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#define	CM_WARN2(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#define	CM_ERROR(strings) {\
	_Debug_Printf_Service(WARNNAME " ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n"); \
	{_asm	int	3}}
#endif

#endif

#ifdef	DEBUG
#define	CM_DEBUG_CODE		VxD_LOCKED_CODE_SEG
#define	CM_DEBUG_DATA		VxD_LOCKED_DATA_SEG
#else
#define	CM_DEBUG_CODE		VxD_DEBUG_ONLY_CODE_SEG
#define	CM_DEBUG_DATA		VxD_DEBUG_ONLY_DATA_SEG
#endif

#ifdef	CM_PERFORMANCE_INFO

#define	CM_PAGEABLE_CODE	VxD_LOCKED_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_LOCKED_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG
#define	CURSEG()		LCODE

#else

#define	CM_PAGEABLE_CODE	VxD_PNP_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_PAGEABLE_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG

#pragma warning (disable:4005)			// turn off redefinition

#define	CURSEG()		CCODE

#pragma warning (default:4005)			// turn on redefinition

#endif

#ifdef	DEBUG

#define	CM_INTERNAL		_cdecl

#else

#define	CM_INTERNAL		_fastcall

#endif

#define	CM_NAKED		__declspec ( naked )
#define	CM_LOCAL		CM_INTERNAL
#define	CM_UNIQUE		static CM_INTERNAL

#define	CM_BEGIN_CRITICAL {\
_asm	pushfd	\
_asm	cli	\
}

#define	CM_END_CRITICAL \
_asm	popfd\

#define	CM_FOREVER		for (;;)

#ifndef	No_CM_Calls

#ifdef	Not_VxD

/****************************************************************************
 *
 *	CONFIGMG_Get_Entry_Point - Return the address to call to get in
 *				   Config Manager.
 *
 *	Exported.
 *
 *	ENTRY:	None.
 *
 *	EXIT:	None.
 *
 *	On return, the variable CMEntryPoint has been updated with the
 *	proper address to call to get to Configuration Manager.
 *
 ***************************************************************************/
DWORD static
CM_Get_Entry_Point(void)
{
	static	DWORD		CMEntryPoint=NULL;

	if (CMEntryPoint)
		return(CMEntryPoint);

	_asm	push	bx
	_asm	push	es
	_asm	push	di
	_asm	xor	di, di

	_asm	mov	ax, 0x1684
	_asm	mov	bx, 0x33
	_asm	mov	es, di
	_asm	int	0x2f

	_asm	mov	word ptr [CMEntryPoint+2], es
	_asm	mov	word ptr [CMEntryPoint], di

	_asm	pop	di
	_asm	pop	es
	_asm	pop	bx

	return(CMEntryPoint);
}

#define	MAKE_CM_HEADER(Function, Parameters) \
CONFIGRET static _near _cdecl \
CM_##Function##Parameters \
{ \
	CONFIGRET	CMRetValue=0; \
	DWORD		CMEntryPoint; \
	WORD		wCMAPIService=GetVxDServiceOrdinal(_CONFIGMG_##Function); \
	if ((CMEntryPoint=CM_Get_Entry_Point())==0) \
		return(0); \
	_asm	{mov	ax, wCMAPIService};\
	_asm	{call	CMEntryPoint}; \
	_asm	{mov	CMRetValue, ax};\
	return(CMRetValue); \
}

#else	// Not_VxD

#define	MAKE_CM_HEADER(Function, Parameters) \
MAKE_HEADER(CONFIGRET, _cdecl, CAT(_CONFIGMG_, Function), Parameters)

#endif	// Not_VxD

/****************************************************************************
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 * Each of the following functions must match their equivalent service
 * and the parameter table in dos386\vmm\configmg\services.*.
 *
 * Except for the Get_Version, each function return a CR_* result in EAX
 * (AX for non IS_32 app) and can trash ECX and/or EDX as they are 'C'
 * callable.
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 ***************************************************************************/

#pragma warning (disable:4100)		// Param not used

#ifdef	Not_VxD

MAKE_CM_HEADER(Get_Version, (VOID))

#else

WORD VXDINLINE
CONFIGMG_Get_Version(VOID)
{
	WORD	w;
	VxDCall(_CONFIGMG_Get_Version);
	_asm mov [w], ax
	return(w);
}

#endif

MAKE_CM_HEADER(Initialize, (ULONG ulFlags))
MAKE_CM_HEADER(Locate_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Parent, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Child, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Sibling, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID_Size, (PFARULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID, (DEVNODE dnDevNode, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Get_Depth, (PFARULONG pulDepth, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Private_DWord, (PFARULONG pulPrivate, DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_DWord, (DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Create_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, DEVNODE dnParent, ULONG ulFlags))
MAKE_CM_HEADER(Query_Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Register_Device_Driver, (DEVNODE dnDevNode, CMCONFIGHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator, (DEVNODE dnDevNode, CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Register_Arbitrator, (PREGISTERID pRid, RESOURCEID id, CMARBHANDLER Handler, ULONG ulDWordToBePassed, DEVNODE dnArbitratorNode, ULONG ulFlags))
MAKE_CM_HEADER(Deregister_Arbitrator, (REGISTERID id, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Size, (PFARULONG pulSize, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Data, (PFARVOID pData, ULONG DataLen, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Sort_NodeList, (NODELIST_HEADER nlhNodeListHeader, ULONG ulFlags))
MAKE_CM_HEADER(Yield, (ULONG ulMicroseconds, ULONG ulFlags))
MAKE_CM_HEADER(Lock, (ULONG ulFlags))
MAKE_CM_HEADER(Unlock, (ULONG ulFlags))
MAKE_CM_HEADER(Add_Empty_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, PRIORITY Priority, ULONG ulFlags))
MAKE_CM_HEADER(Free_Log_Conf, (LOG_CONF lcLogConfToBeFreed, ULONG ulFlags))
MAKE_CM_HEADER(Get_First_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Log_Conf, (PLOG_CONF plcLogConf, LOG_CONF lcLogConf, ULONG ulFlags))
MAKE_CM_HEADER(Add_Res_Des, (PRES_DES prdResDes, LOG_CONF lcLogConf, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Modify_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Free_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Res_Des, (PRES_DES prdResDes, RES_DES CurrentResDesOrLogConf, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Performance_Info, (PCMPERFINFO pPerfInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data_Size, (PFARULONG pulSize, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data, (RES_DES rdResDes, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Process_Events_Now, (ULONG ulFlags))
MAKE_CM_HEADER(Create_Range_List, (PRANGE_LIST prlh, ULONG ulFlags))
MAKE_CM_HEADER(Add_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Delete_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Test_Range_Available, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Dup_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(Free_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Invert_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulMaxVal, ULONG ulFlags))
MAKE_CM_HEADER(Intersect_Range_List, (RANGE_LIST rlhOld1, RANGE_LIST rlhOld2, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(First_Range, (RANGE_LIST rlh, PFARULONG pulStart, PFARULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags))
MAKE_CM_HEADER(Next_Range, (PRANGE_ELEMENT preElement, PFARULONG pulStart, PFARULONG pulEnd, ULONG ulFlags))
MAKE_CM_HEADER(Dump_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Load_DLVxDs, (DEVNODE dnDevNode, PFARCHAR FileNames, LOAD_TYPE LoadType, ULONG ulFlags))
MAKE_CM_HEADER(Get_DDBs, (PPPVMMDDB ppDDB, PFARULONG pulCount, LOAD_TYPE LoadType, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_CRC_CheckSum, (PFARVOID pBuffer, ULONG ulSize, PFARULONG pulSeed, ULONG ulFlags))
MAKE_CM_HEADER(Register_DevLoader, (PVMMDDB pDDB, ULONG ulFlags))
MAKE_CM_HEADER(Reenumerate_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Setup_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Reset_Children_Marks, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Status, (PFARULONG pulStatus, PFARULONG pulProblemNumber, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Unmarked_Children, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(ISAPNP_To_CM, (PFARVOID pBuffer, DEVNODE dnDevNode, ULONG ulLogDev, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Device_Driver, (CMCONFIGHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Enumerator, (CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Get_Alloc_Log_Conf, (PCMCONFIG pccBuffer, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key_Size, (PFARULONG pulLen, DEVNODE dnDevNode, PFARCHAR pszSubKey, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulExpectedType, PFARVOID pBuffer, PFARULONG pulLength, ULONG ulFlags))
MAKE_CM_HEADER(Write_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulType, PFARVOID pBuffer, ULONG ulLength, ULONG ulFlags))
MAKE_CM_HEADER(Disable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Enable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Move_DevNode, (DEVNODE dnFromDevNode, DEVNODE dnToDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Bus_Info, (DEVNODE dnDevNode, CMBUSTYPE btBusType, ULONG ulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Bus_Info, (DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, PFARULONG pulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof, (ULONG ulConfig, ULONG ulFlags))
MAKE_CM_HEADER(Recompute_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Query_Change_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_Driver_Private_DWord, (DEVNODE dnDevNode, PFARULONG pulDWord, ULONG ulFlags))
MAKE_CM_HEADER(Set_Device_Driver_Private_DWord, (DEVNODE dnDevNode, ULONG ulDword, ULONG ulFlags))
MAKE_CM_HEADER(Get_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, PFARULONG pulValue, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Log_Confs, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Run_Detection, (ULONG ulFlags))
MAKE_CM_HEADER(Call_At_Appy_Time, (CMAPPYCALLBACKHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Fail_Change_HW_Prof, (DEVNODE dnDevnode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_Problem, (DEVNODE dnDevNode, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Debug_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Hardware_Profile_Info, (ULONG ulIndex, PFARHWPROFILEINFO pHWProfileInfo, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator_Function, (DEVNODE dnDevNode, CMENUMFUNCTION Handler, ULONG ulFlags))
MAKE_CM_HEADER(Call_Enumerator_Function, (DEVNODE dnDevNode, ENUMFUNC efFunc, ULONG ulRefData, PFARVOID pBuffer, ULONG ulBufferSize, ULONG ulFlags))
MAKE_CM_HEADER(Add_ID, (DEVNODE dnDevNode, PFARCHAR pszID, ULONG ulFlags))
MAKE_CM_HEADER(Find_Range, (PFARULONG pulStart, ULONG ulStart, ULONG ulLength, ULONG ulAlignment, ULONG ulEnd, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Get_Global_State, (PFARULONG pulState, ULONG ulFlags))
MAKE_CM_HEADER(Broadcast_Device_Change_Message, (ULONG ulwParam, PFARVOID plParam, ULONG ulFlags))
MAKE_CM_HEADER(Call_DevNode_Handler, (DEVNODE dnDevNode, ULONG ulPrivate, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Reinsert_All, (ULONG ulFlags))

#pragma warning (default:4100)		// Param not used

#endif	// ifndef No_CM_Calls

/*XLATON*/

#endif	// ifndef CMJUSTRESDES

/*XLATOFF*/
#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(pop)
#else
#pragma pack()
#endif
#else
#pragma pack()
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
/*XLATON*/

#endif	// _CONFIGMG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\cprocess.h ===
//=============================================================================

//

// Process.h -- Process property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/27/97	 a-hhance		updated to new framework paradigm.
//
//=============================================================================

// Property set identification
//============================
#include <deque>
#define PROPSET_NAME_PROCESS					    L"Win32_Process"           
#define PROPSET_NAME_PROCESSSTARTUP				    L"Win32_ProcessStartup"           

#define PROPERTY_NAME_ENVIRONMENTVARIABLES		    L"EnvironmentVariables"
#define PROPERTY_NAME_WINSTATIONDESKTOP			    L"WinstationDesktop"
#define PROPERTY_NAME_TITLE						    L"Title"
#define PROPERTY_NAME_SHOWWINDOW				    L"ShowWindow"

#define PROPERTY_NAME_X							    L"X"
#define PROPERTY_NAME_Y							    L"Y"
#define PROPERTY_NAME_XSIZE						    L"XSize"
#define PROPERTY_NAME_YSIZE						    L"YSize"
#define PROPERTY_NAME_XCOUNTCHARS				    L"XCountChars"
#define PROPERTY_NAME_YCOUNTCHARS				    L"YCountChars"

#define PROPERTY_NAME_CREATIONFLAGS				    L"CreateFlags"
#define PROPERTY_NAME_PRIORITYCLASS				    L"PriorityClass"
#define PROPERTY_NAME_FILLATTRIBUTE				    L"FillAttribute"
#define PROPERTY_NAME_ERRORMODE					    L"ErrorMode"


#define METHOD_NAME_CREATE				            L"Create"
#define METHOD_NAME_TERMINATE			            L"Terminate"
#define METHOD_NAME_GETOWNER			            L"GetOwner"
#define METHOD_NAME_GETOWNERSID			            L"GetOwnerSid"
#define METHOD_NAME_SETPRIORITY                     L"SetPriority"
#define METHOD_NAME_ATTACHDEBUGGER                  L"AttachDebugger"


#define METHOD_ARG_NAME_RETURNVALUE					L"ReturnValue"
#define METHOD_ARG_NAME_REASON						L"Reason"
#define METHOD_ARG_NAME_COMMANDLINE					L"CommandLine"
#define METHOD_ARG_NAME_PROCESSID					L"ProcessId"
#define METHOD_ARG_NAME_CURRENTDIRECTORY			L"CurrentDirectory"
#define METHOD_ARG_NAME_PROCESSTARTUPINFORMATION	L"ProcessStartupInformation"
#define METHOD_ARG_NAME_DOMAIN						L"Domain"
#define METHOD_ARG_NAME_USER						L"User"
#define METHOD_ARG_NAME_SID							L"Sid"
#define METHOD_ARG_NAME_PRIORITY                    L"Priority"

#define	PROPERTY_NAME_PROCESSHANDLE					L"Handle"

#define PROPERTY_VALUE_DESKTOP_WIN0DEFAULT			_T("")

#define DEBUG_REGISTRY_STRING                       L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug"

#define PROPERTY_VALUE_MODE_CREATE_DEFAULT_ERROR_MODE	        0
#define PROPERTY_VALUE_MODE_CREATE_NEW_CONSOLE			        1
#define PROPERTY_VALUE_MODE_CREATE_NEW_PROCESS_GROUP	        2	
#define PROPERTY_VALUE_MODE_CREATE_SEPARATE_WOW_VDM 	        3
#define PROPERTY_VALUE_MODE_CREATE_SHARED_WOW_VDM		        4
#define PROPERTY_VALUE_MODE_CREATE_SUSPENDED			        5
#define PROPERTY_VALUE_MODE_CREATE_UNICODE_ENVIRONMENT	        6
#define PROPERTY_VALUE_MODE_DEBUG_PROCESS				        7
#define PROPERTY_VALUE_MODE_DEBUG_ONLY_THIS_PROCESS 	        8
#define PROPERTY_VALUE_MODE_DETACHED_PROCESS			        9

#define PROPERTY_VALUE_PRIORITYCLASS_HIGH		                0
#define PROPERTY_VALUE_PRIORITYCLASS_IDLE		                1
#define PROPERTY_VALUE_PRIORITYCLASS_NORMAL		                2
#define PROPERTY_VALUE_PRIORITYCLASS_REALTIME	                3

#define PROPERTY_VALUE_ERRORMODE_FAIL_CRITICAL_ERRORS			0
#define PROPERTY_VALUE_ERRORMODE_NO_ALIGNMENT_FAULT_EXCEPT		1
#define PROPERTY_VALUE_ERRORMODE_NO_GP_FAULT_ERROR_BOX			2
#define PROPERTY_VALUE_ERRORMODE_NO_OPEN_FILE_ERROR_BOX			3


#define Process_STATUS_SUCCESS							        0
#define Process_STATUS_NOT_SUPPORTED					        1

// Control 
#define Process_STATUS_ACCESS_DENIED					        2
#define Process_STATUS_INSUFFICIENT_PRIVILEGE			        3
#define Process_STATUS_UNKNOWN_FAILURE					        8

// Start
#define Process_STATUS_PATH_NOT_FOUND					        9
#define Process_STATUS_INVALID_PARAMETER				        21

//#define  PROPSET_UUID_PROCESS "{7d9b7a20-3ead-11d0-93a1-0000e80d7352}"

#define BUFFER_SIZE_INIT        0x8000
#define BUFFER_SIZE_INCREMENT   0x1000

#define MAX_PROCESSES           0x0100

// valid CREATIONFLAGS
#define CREATIONFLAGS	(	DEBUG_PROCESS |					\
							DEBUG_ONLY_THIS_PROCESS |		\
							CREATE_SUSPENDED |				\
							DETACHED_PROCESS |				\
							CREATE_NEW_CONSOLE |			\
							CREATE_NEW_PROCESS_GROUP |		\
							CREATE_UNICODE_ENVIRONMENT  |	\
							CREATE_FORCEDOS |				\
							CREATE_BREAKAWAY_FROM_JOB |		\
							CREATE_DEFAULT_ERROR_MODE )		\

/*
typedef struct _PROCESS_CACHE
{
    BOOL    bInvalid ;
    DWORD   dwProcessCount ;
    DWORD   dwPIDList[MAX_PROCESSES] ;
    DWORD   dwBaseModuleList[MAX_PROCESSES] ;
    char    szNameList[MAX_PROCESSES][50] ;

} PROCESS_CACHE ;
*/

//doesn't have copyctr...use ref or ptr !!
class PROCESS_CACHE
{

public:

	BOOL    bInvalid ;
    DWORD   dwProcessCount ;
    DWORD   *pdwPIDList ;
    DWORD   *pdwBaseModuleList ;
    TCHAR   (*pszNameList)[50] ;

	PROCESS_CACHE()
	{
		AllocateMemories(MAX_PROCESSES) ;
		dwProcessCount = MAX_PROCESSES ;
	}


	~PROCESS_CACHE()
	{
		dwProcessCount = 0 ;
		Clear() ;
	}

	void AllocateMemories(DWORD dwSize)
	{
		pdwPIDList = new DWORD[dwSize] ;
		pdwBaseModuleList = new DWORD[dwSize] ;
		pszNameList = new TCHAR[dwSize][50] ;
		dwProcessCount = dwSize ;
	}

	void Clear()
	{

		if(pdwPIDList)
		{
			delete[] pdwPIDList ;
			pdwPIDList = NULL ;

		}
		if(pdwBaseModuleList)
		{
			delete[] pdwBaseModuleList ;
			pdwBaseModuleList = NULL ;
		}
		if(pszNameList)
		{
			delete[] pszNameList ;
			pszNameList = NULL ;
		}

	}

};

class Process: public Provider
{
public:

    // Constructor/destructor
    //=======================

    Process(LPCWSTR name, LPCWSTR pszNamespace) ;
   ~Process() ;

    // Funcitons provide properties with current values
    //=================================================

    HRESULT Process::ExecQuery (

        MethodContext* pMethodContext, 
        CFrameworkQuery &pQuery, 
        long lFlags 
    );

    HRESULT Process :: Enumerate (

	    MethodContext *pMethodContext, 
	    long lFlags /*= 0L*/,
        BOOL bKeysOnly
    );

	HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
	HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &pQuery);

	HRESULT ExecMethod (

		const CInstance &a_Instance, 
		const BSTR a_MethodName, 
		CInstance *a_InParams, 
		CInstance *a_OutParams, 
		long a_Flags = 0L
	);

	HRESULT DeleteInstance (

		const CInstance& a_Instance, 
		long a_Flags = 0L
	) ;

    // Utility function(s)
    //====================

#ifdef NTONLY


    BOOL LoadCheapPropertiesNT (

		CNtDllApi &a_NtApi , 
		SYSTEM_PROCESS_INFORMATION *a_ProcessBlock , 
		CInstance* pInstance
	) ;

#else

    BOOL RefreshProcessCacheWin95(CKernel32Api &ToolHelp, PROCESS_CACHE& PCache) ;
    BOOL LoadCheapPropertiesWin95(CKernel32Api &ToolHelp, DWORD dwProcIndex, PROCESS_CACHE& PCache, CInstance* pInstance, const std::deque<DWORD>& a_ThreadQ ) ;

#endif

#ifdef NTONLY

    static SYSTEM_PROCESS_INFORMATION *RefreshProcessCacheNT (

		CNtDllApi &a_NtApi , 
		MethodContext *pMethodContext ,
		HRESULT *a_phrRetVal = NULL
	) ;

	static SYSTEM_PROCESS_INFORMATION *GetProcessBlocks ( 

		CNtDllApi &a_NtApi
	) ;

	static SYSTEM_PROCESS_INFORMATION *NextProcessBlock ( 

		CNtDllApi &a_NtApi , 
		SYSTEM_PROCESS_INFORMATION *a_ProcessBlock 
	) ;

	static SYSTEM_PROCESS_INFORMATION *GetProcessBlock ( 

		CNtDllApi &a_NtApi , 
		SYSTEM_PROCESS_INFORMATION *a_ProcessBlock , 
		DWORD a_ProcessId
	) ;

	static BOOL GetProcessModuleBlock ( 

		CNtDllApi &a_NtApi , 
		HANDLE a_Process ,
		LIST_ENTRY *&a_LdrHead
	) ;

	static BOOL NextProcessModule ( 

		CNtDllApi &a_NtApi , 
		HANDLE a_Process , 
		LIST_ENTRY *&a_LdrHead , 
		LIST_ENTRY *&a_LdrNext , 
		CHString &a_ModuleName ,
        DWORD_PTR *a_pdwBaseAddress ,
        DWORD *a_pdwUsageCount
	) ;

	static BOOL GetProcessExecutable ( 

		CNtDllApi &a_NtApi , 
		HANDLE a_Process , 
		CHString &a_ExecutableName
	) ;

	static BOOL GetProcessParameters ( 

		CNtDllApi &a_NtApi ,
		HANDLE a_Process ,
		CHString &a_CommandLine
	) ;

private:

	static BOOL GetModuleName	(
									HANDLE a_Process ,
									LDR_DATA_TABLE_ENTRY& t_LdrEntryData ,
									CHString &a_ModuleName
								) ;

	static BOOL CopyModuleName	(
									CHString &a_ModuleName ,
									const WCHAR* a_Module ,
									size_t	a_bytes
								) ;
public:

#endif

private:
	// Converts kernel and user mode times to the required DMTF
	// representation
	CHString filetimeToUint64CHString(FILETIME inputTime);

	DWORD GetProcessErrorCode () ;
	HRESULT GetProcessResultCode () ;

	DWORD GetSidOrAccount (
		
		const CInstance &a_Instance ,
		CInstance *a_OutParams , 
		DWORD a_ProcesId , 
		BOOL a_Sid 
	) ;

	DWORD GetAccount ( 

		HANDLE a_TokenHandle , 
		CHString &a_Domain , 
		CHString &a_User 
	) ;

	DWORD GetSid ( 

		HANDLE a_TokenHandle , 
		CHString &a_Sid 
	) ;

	DWORD GetLogonSid ( 

		HANDLE a_TokenHandle , 
		PSID &a_Sid 
	) ;

	DWORD Creation ( 

		CInstance *a_OutParams ,
		HANDLE a_TokenHandle ,
		CHString a_CmdLine , 
		BOOL a_WorkingDirectorySpecified ,
		CHString a_WorkingDirectory ,
		TCHAR *a_EnvironmentBlock ,
		BOOL a_ErrorModeSpecified ,
		DWORD a_ErrorMode ,
		DWORD a_CreationFlags ,
		BOOL a_StartupSpecified ,
		STARTUPINFO a_StartupInformation
	) ;

	DWORD ProcessCreation ( 

		CInstance *a_OutParams ,
		CHString a_CmdLine , 
		BOOL a_WorkingDirectorySpecified ,
		CHString a_WorkingDirectory ,
		TCHAR *&a_EnvironmentBlock ,
		BOOL a_ErrorModeSpecified ,
		DWORD a_ErrorMode ,
		DWORD a_CreationFlags ,
		BOOL a_StartupSpecified ,
		STARTUPINFO a_StartupInformation
	) ;

	HRESULT CheckProcessCreation ( 

		CInstance *a_InParams ,
		CInstance *a_OutParams ,
		DWORD &a_Status 
	) ;

	DWORD GetImpersonationStatus ( 

		HANDLE a_TokenHandle , 
		SECURITY_IMPERSONATION_LEVEL &a_Level , 
		TOKEN_TYPE &a_TokenType 
	) ;

	DWORD EnableDebug ( HANDLE &a_DebugToken ) ;

	HRESULT ExecCreate (

		const CInstance& a_Instance, 
		CInstance *a_InParams, 
		CInstance *a_OutParams, 
		long lFlags 
	) ;

	HRESULT ExecTerminate (

		const CInstance& a_Instance, 
		CInstance *a_InParams, 
		CInstance *a_OutParams, 
		long lFlags 
	) ;

	HRESULT ExecGetOwner (

		const CInstance& a_Instance, 
		CInstance *a_InParams, 
		CInstance *a_OutParams, 
		long lFlags 
	) ;

	HRESULT ExecGetOwnerSid (

		const CInstance& a_Instance, 
		CInstance *a_InParams, 
		CInstance *a_OutParams, 
		long lFlags 
	) ;

    HRESULT ExecSetPriority(
	    const CInstance& a_Instance,
	    CInstance *cinstInParams,
	    CInstance *cinstOutParams,
	    long lFlags);

    HRESULT ExecAttachDebugger(
	    const CInstance& a_Instance,
	    CInstance *cinstInParams,
	    CInstance *cinstOutParams,
	    long lFlags);

#ifdef NTONLY
    void GetDebuggerString(
        CHString& chstrDbgStr);
#endif

#ifdef NTONLY
    bool SetStatusObject(
        MethodContext* pContext, 
        const WCHAR* wstrMsg);
#endif
	
	DWORD GetEnvBlock( 
		
		const CHString &rchsSid, 
		const CHString &rchsUserName, 
		const CHString &rchsDomainName , 
		TCHAR* &rszEnvironBlock 
	) ;
	
	DWORD GetEnvironmentVariables(

		HKEY hKey,
		const CHString& chsSubKey,	
		CHStringArray &aEnvironmentVars,
		CHStringArray &aEnvironmentVarsValues 
		) ;

friend class CWin32ProcessDLL;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\cpuid.cpp ===
//=================================================================
//
// CPUID.cpp
//
//  Copyright (c) 1998-2002 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "smbios.h"
#include "smbstruc.h"
#include <cregcls.h>
#include "cpuid.h"
#include "resource.h"
#include <strsafe.h>

#pragma warning(disable : 4995) // we introduced as including strsafe.h gives error for all unsafe string functions

DWORD CPURawSpeed();
DWORD GetFixedCPUSpeed();
DWORD GetTimeCounterCPUSpeed();

#if defined(_AMD64_) || defined(_X86_)

#if defined(_X86_)

#define CPU_ID _asm _emit 0x0F _asm _emit 0xA2
#define RDTSC  _asm _emit 0x0F _asm _emit 0x31

BOOL CanDoCPUID(void)

{
    BOOL bRet;

    _asm
    {
        pushfd                                  ; push original EFLAGS
        pop             eax                     ; get original EFLAGS
        mov             ecx, eax                ; save original EFLAGS
        xor             eax, 200000h            ; flip ID bit in EFLAGS
        push    eax                             ; save new EFLAGS value on stack
        popfd                                   ; replace current EFLAGS value
        pushfd                                  ; get new EFLAGS
        pop             eax                     ; store new EFLAGS in EAX
        xor             eax, ecx                ; cant toggle ID bit,

        je              no_cpuid                ; can't do CPUID

        mov             bRet, 1
        jmp             done_cpuid

no_cpuid:
        mov             bRet, 0

done_cpuid:
    }

    return bRet;
}

void DoCPUID(DWORD dwLevel, DWORD *pdwEAX, DWORD *pdwEBX,
        DWORD *pdwECX, DWORD *pdwEDX)

{
    _asm
    {
        push    esi
        push    eax
        push    ebx
        push    ecx
        push    edx

        mov     eax, dwLevel
        CPU_ID

        mov     esi, dword ptr pdwEAX
        mov     dword ptr [esi], eax

        mov     esi, dword ptr pdwEBX
        mov     dword ptr [esi], ebx

        mov     esi, dword ptr pdwECX
        mov     dword ptr [esi], ecx

        mov     esi, dword ptr pdwEDX
        mov     dword ptr [esi], edx

        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
        pop     esi
    }

}

DWORD GetBSFCPUSpeed(DWORD cycles);

#elif defined(_AMD64_)

#define CanDoCPUID() TRUE

extern "C"
void
DoCPUID (DWORD dwLevel, DWORD *pdwEAX, DWORD *pdwEBX, DWORD *pdwECX, DWORD *pdwEDX);

#endif

void GetCPUInfo(DWORD *pdwFamily, DWORD *pdwSignature, DWORD *pdwFeatures, DWORD *pdwFeaturesEx, SYSTEM_INFO *pInfo);
void GetCPUDescription(LPWSTR szDescrip, DWORD dwSize);
DWORD CPURawSpeedHelper(DWORD dwFamily, DWORD dwFeatures);

// This is the one to call to get the CPU speed.
DWORD GetFixedCPUSpeed();

DWORD ProcessorCount();

BOOL HasCoprocessor();

static DWORD diffTime64(DWORD t1Hi, DWORD t1Low,
						DWORD t2Hi, DWORD t2Low,
                        DWORD *tHi, DWORD *tLow );

#endif // defined(_AMD64_) || defined(_X86_)

BOOL GetVendor(LPWSTR szVendor)
{
#if defined(_AMD64_) || defined(_X86_)
	if (CanDoCPUID())
	{
		DWORD   dwEAX;
		char    szTemp[100];
		DWORD   *pVendor = (DWORD *) szTemp;

		DoCPUID(0, &dwEAX, &pVendor[0], &pVendor[2], &pVendor[1]);
		szTemp[12] = '\0';

		mbstowcs(szVendor, szTemp, strlen(szTemp) + 1);

		return TRUE;
	}
#endif // defined(_AMD64_) || defined(_X86_)

    CRegistry reg;
    CHString  strVendor;
    BOOL      bRet =
                        reg.OpenLocalMachineKeyAndReadValue(
                                L"HARDWARE\\Description\\System\\CentralProcessor\\0",
                                L"VendorIdentifier",
                                strVendor) == ERROR_SUCCESS;

    if (bRet)
        StringCchCopy(szVendor, 40, strVendor); // The size of szVendor is Max 40. We do not care 
                                                // about the return value as we will get truncated 
                                                // value.
                                                // It comes from struc _tagSYSTEM_INFO_EX.szProcessorVendor


    return bRet;
}

BOOL ReadRegistryForName(DWORD a_dwProcessor, CHString &a_strName, CHString &a_strIdentifier)
{
        // For non-CPUID processors, try to get it from the registry.
    WCHAR     szKey[100];
    CRegistry reg;

    swprintf(
        szKey,
        L"HARDWARE\\Description\\System\\CentralProcessor\\%d",
        a_dwProcessor);

    BOOL bRet = reg.OpenLocalMachineKeyAndReadValue(
                        szKey,
                        L"ProcessorNameString",
                        a_strName) == ERROR_SUCCESS;

	BOOL bRet2 = reg.OpenLocalMachineKeyAndReadValue(
                        szKey,
                        L"Identifier",
                        a_strIdentifier) == ERROR_SUCCESS;

    return (bRet && bRet2);
}

BOOL GetCPUIDName(DWORD dwProcessor, SYSTEM_INFO_EX *pInfo)
{
#if defined(_AMD64_) || defined(_X86_)
    if (CanDoCPUID())
    {
		DWORD   dwLevels,
		dwTemp;
		char    szTemp[100];
		DWORD   *pName = (DWORD *) szTemp;

		// Clear out the temp var.
		memset(szTemp, 0, sizeof(szTemp));

		// Get the number of extended levels supported.
		DoCPUID(0x80000000, &dwLevels, &dwTemp, &dwTemp, &dwTemp);

		// Does this CPU support more than one level? (AMD and Cyrix only,
		// Intel doesn't.)
		if (dwLevels > 0x80000000)
		{
			// Convert back to 0-based.
			dwLevels -= 0x80000002;

			// 4 is the last one for getting the CPU name.
			if (dwLevels > 3)
				dwLevels = 3;

			for (int i = 0; i < (int) dwLevels; i++)
			{
				DoCPUID(
				0x80000002 + i,
				&pName[0],
				&pName[1],
				&pName[2],
				&pName[3]);

				// Just got 4 DWORDs worth, so skip to the next 4.
				pName += 4;
			}

			mbstowcs(pInfo->szCPUIDProcessorName, szTemp, strlen(szTemp) + 1);
		}
		else
		{
			CHString    strName;
			DWORD       dwFamily = pInfo->wProcessorLevel,

			dwModel = (pInfo->dwProcessorSignature >> 4) & 0xF,
			dwStepping = pInfo->dwProcessorSignature & 0xF;

			FormatMessageW(	strName,
							IDR_x86FamilyModelStepping,
							dwFamily,
							dwModel,
							dwStepping);

			wcscpy(pInfo->szCPUIDProcessorName, strName);
		}

		return TRUE;
    }
    else
#endif	// defined(_AMD64_) || defined(_X86_)
    {
		// For non-CPUID processors, try to get it from the registry.
		CHString sName;
		CHString sID;
		ReadRegistryForName(dwProcessor, sName, sID);
		BOOL bRet = TRUE;

		if (sName.GetLength())
		{
			wcscpy(pInfo->szCPUIDProcessorName, sName);
		}
		else if (sID.GetLength())
		{
			wcscpy(pInfo->szCPUIDProcessorName, sID);
		}
		else
		{
			bRet = FALSE;
		}

		return bRet;
    }
}

#if defined(_AMD64_) || defined(_X86_)
void GetCPUInfo(DWORD *pdwFamily, DWORD *pdwSignature, DWORD *pdwFeatures, DWORD *pdwFeaturesEx, SYSTEM_INFO *pInfo)
{
	if (pInfo)
		GetSystemInfo(pInfo);

	if (CanDoCPUID())
	{
		DWORD dwNichts;
		DoCPUID(1, pdwSignature, &dwNichts, &dwNichts, pdwFeatures);

		*pdwFamily = (*pdwSignature >> 8) & 0xF;

		if (pdwFeaturesEx)
		{
			DWORD   eax,
			ebx,
			ecx,
			edx;

			DoCPUID(0x80000000, &eax, &ebx, &ecx, &edx);
			if (!eax)
				*pdwFeaturesEx = 0;
			else
				DoCPUID(0x80000001, &eax, &ebx, &ecx, pdwFeaturesEx);
		}
	}
#if defined(_X86_)
	else // Can't do CPUID, so fake it.
	{
		// Assume no cool features if we can't do CPUID.
		*pdwFeatures = 0;

		if (pdwFeaturesEx)
			*pdwFeaturesEx = 0;

		// Can't do CPUID, so do some assembly.
		_asm
		{
			push            esi
			mov             esi, dword ptr [pdwFamily]

			;check_80386:
			pushfd									; push original EFLAGS
			pop             eax						; get original EFLAGS
			mov             ecx, eax				; save original EFLAGS
			xor             eax, 40000h				; flip AC bit in EFLAGS
			push            eax						; save new EFLAGS value on stack
			popfd									;replace current EFLAGS value
			pushfd									; get new EFLAGS
			pop             eax						; store new EFLAGS in EAX
			xor             eax, ecx				; cant toggle AC bit, processor=80386
			mov             dword ptr [esi], 3		; turn on 80386 processor flag
			jz              end_cpu_type			; jump if 80386 processor
			push            ecx
			popfd									; restore AC bit in EFLAGS first

			mov             dword ptr [esi], 4      ; at least a 486.

end_cpu_type:
			pop             esi
		}

		if (*pdwFamily == 4)
		{
			// Can't use GetFixedCPUSpeed because it calls GetCPUInfo.
			DWORD dwSpeed = CPURawSpeedHelper(*pdwFamily, 0);

			if (!HasCoprocessor())
				// Either SX or SX2
				*pdwSignature = dwSpeed <= 33 ? 0x0440 : 0x0450;
			else
				// Either DX or DX2
				*pdwSignature = dwSpeed <= 33 ? 0x0410 : 0x0430;
		}
		else
			*pdwSignature = 0x0300;
	}

	// Fill out the rest of SYSTEM_INFO since Win95 can't.
#endif // defined(_X86_)
}

// Uses L2 cache size and SMBIOS to try to figure out if the machine is a Xeon.
BOOL IsXeon(SYSTEM_INFO_EX *pInfo)
{
	// Try to find if we're a Xeon by using the cache size.
	// If it's 512 (we'll also say or if lower, because of the PII PE
	// for portables and Coppermine) it's either a Xeon or PII (or PIII), but
	// if SMBIOS doesn't tell us, there's no way to know for sure which one.
	// If the L2 is greater than 512 we know for sure it's a Xeon.
    return pInfo->dwProcessorL2CacheSize > 512 || pInfo->wWBEMProcessorUpgradeMethod == WBEM_CPU_UPGRADE_SLOT2;
}

// This is for 486/Pentium class machines where the L2 is running at the same
// speed as the system clock.
void SetL2SpeedViaExternalClock(SYSTEM_INFO_EX *pInfo)
{
    // Make sure we have a valid cache size and external clock speed.
    if (pInfo->dwProcessorL2CacheSize != 0 &&
		pInfo->dwProcessorL2CacheSize != (DWORD) -1 && pInfo->dwExternalClock != 0)
    {
        pInfo->dwProcessorL2CacheSpeed = pInfo->dwExternalClock;
    }
}

// Assumes processor can do CPUID
void GetIntelSystemInfo(DWORD dwProcessor, SYSTEM_INFO_EX *pInfo)
{
	DWORD	dwFamily = pInfo->wProcessorLevel,
			dwModel = (pInfo->dwProcessorSignature >> 4) & 0xF,
			dwStepping = pInfo->dwProcessorSignature & 0xF;

	BOOL bCanDo = CanDoCPUID();

	// Get the cache info
	if (bCanDo)
	{
		DWORD   dwInfo[4] = {0, 0, 0, 0};
		BYTE    *pcVal = (BYTE *) dwInfo,
		*pcEnd = pcVal + sizeof(dwInfo);

		DoCPUID(2, &dwInfo[0], &dwInfo[1], &dwInfo[2], &dwInfo[3]);

		switch ( dwFamily )
		{
			//
			// P4 has different result for CPUID instruction
			//
			case 15:
			{
				for ( ; pcVal < pcEnd; pcVal++ )
				{
					if (*pcVal == 0x40)
					{
						// no L3 cache
					}
					else if (*pcVal == 0x79)
					{
						pInfo->dwProcessorL2CacheSize = 128;
						pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
					}
					else if (*pcVal == 0x7A)
					{
						pInfo->dwProcessorL2CacheSize = 256;
						pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
					}
					else if (*pcVal == 0x7B)
					{
						pInfo->dwProcessorL2CacheSize = 512;
						pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
					}
					else if (*pcVal == 0x7C)
					{
						pInfo->dwProcessorL2CacheSize = 1024;
						pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
					}
				}
			}
			break ;

			default:
			for (; pcVal < pcEnd; pcVal++)
			{
				if (*pcVal == 0x40)
					pInfo->dwProcessorL2CacheSize = 0;
				else if (*pcVal == 0x41)
					pInfo->dwProcessorL2CacheSize = 128;
				else if (*pcVal == 0x42)
					pInfo->dwProcessorL2CacheSize = 256;
				else if (*pcVal == 0x43)
					pInfo->dwProcessorL2CacheSize = 512;
				else if (*pcVal == 0x44)
					pInfo->dwProcessorL2CacheSize = 1024;
				else if (*pcVal == 0x45)
					pInfo->dwProcessorL2CacheSize = 2048;
				else if (*pcVal == 0x7A)
				{
					//pentium 4 cache, full speed
					pInfo->dwProcessorL2CacheSize = 256;
					pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
				}
				else if (*pcVal == 0x82)
				{
					pInfo->dwProcessorL2CacheSize = 256;
					pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
				}
				else if (*pcVal == 0x84)
				{
					pInfo->dwProcessorL2CacheSize = 1024;
					pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
				}
				else if (*pcVal == 0x85)
				{
					pInfo->dwProcessorL2CacheSize = 2048;
					pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
				}
			}
		}
	}

	CHString    strFormat;
	DWORD       dwID;

	Format(strFormat, IDR_ModelSteppingFormat, dwModel, dwStepping);

	wcscpy(pInfo->szProcessorVersion, strFormat);

	swprintf(pInfo->szProcessorStepping, L"%d", dwStepping);

	switch(dwFamily)
	{
		case 4:
			pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_486;

			// L2 speed == external clock.
			SetL2SpeedViaExternalClock(pInfo);

			// Set this since no 486 will have SMBIOS.
			pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_ZIFF;

			switch(dwModel)
			{
				case 0:
				case 1:
					dwID = IDR_Intel486DX;
					//wcscpy(pInfo->szProcessorName, _T("Intel486 DX processor"));
				break;

				case 2:
					dwID = IDR_Intel486SX;
					//wcscpy(pInfo->szProcessorName, _T("Intel486 SX processor"));
				break;

				case 3:
					dwID = IDR_Intel486DX2;
					//wcscpy(pInfo->szProcessorName, _T("IntelDX2 processor"));
				break;

				case 4:
					dwID = IDR_Intel486SL;
					//wcscpy(pInfo->szProcessorName, _T("Intel486 SL processor"));
				break;

				case 5:
					dwID = IDR_Intel486SX2;
					//wcscpy(pInfo->szProcessorName, _T("IntelSX2 processor"));
				break;

				case 7:
					dwID = IDR_Intel486SX2WriteBack;
					//wcscpy(pInfo->szProcessorName, _T("Write-Back Enhanced IntelDX2 processor"));
				break;

				case 8:
					dwID = IDR_Intel486DX4;
					//wcscpy(pInfo->szProcessorName, _T("IntelDX4 processor"));
				break;

				default:
					//wcscpy(pInfo->szProcessorName, _T("Intel486 processor"));
					dwID = IDR_Intel486;
				break;
			}

		break;

		case 5:
		{
			// L2 speed == external clock.
			SetL2SpeedViaExternalClock(pInfo);

			if (pInfo->dwProcessorFeatures & MMX_FLAG)
			{
				pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PMMX;
				dwID = IDR_IntelPentiumMMX;
				//wcscpy(pInfo->szProcessorName, _T("Intel Pentium MMX processor"));
			}
			else
			{
				pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PENTIUM;
				dwID = IDR_IntelPentium;
				//wcscpy(pInfo->szProcessorName, _T("Intel Pentium processor"));
			}

			break;
		}

		case 6:
			if (dwModel < 3)
			{
				pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PPRO;

				// If the value is unknown set it as a ZIFF (Socket 8).
				if (pInfo->wWBEMProcessorUpgradeMethod == WBEM_CPU_UPGRADE_UNKNOWN)
					pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_ZIFF;

				dwID = IDR_IntelPentiumPro;
				//wcscpy(pInfo->szProcessorName, _T("Intel Pentium Pro processor"));
				pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
			}
			else
			{
				// PII only
				if (dwModel == 3)
				{
					pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PII;
					dwID = IDR_IntelPentiumII;
					//wcscpy(pInfo->szProcessorName, _T("Intel Pentium II processor"));
					pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed / 2;
				}
				// First check for Celeron.
				// If L2 is 0 or 128 it's a Celeron.
				else if (dwModel == 6 || pInfo->dwProcessorL2CacheSize == 128)
				{
					if ((pInfo->dwProcessorL2CacheSize != 128) && (pInfo->dwProcessorL2CacheSize != 0))
					{
						pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PII;

						//wcscpy(pInfo->szProcessorName,
						//	_T("Intel Pentium II processor"));
						dwID = IDR_IntelPentiumII;

						// runs at the same speed as 512 size, it's half speed.
						pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed / 2;
					}
					else
					{
						pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_CELERON;

						if (pInfo->dwProcessorL2CacheSize)
							pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
						else
							pInfo->dwProcessorL2CacheSpeed = (DWORD) -1;

						dwID = IDR_IntelCeleron;
						//wcscpy(pInfo->szProcessorName, _T("Intel Celeron processor"));
					}
				}
				// PII or Xeon
				else if (dwModel == 5)
				{
					if (pInfo->dwProcessorL2CacheSize == 0 ||pInfo->dwProcessorL2CacheSize == 128)
					{
						pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_CELERON;

						if (pInfo->dwProcessorL2CacheSize)
							pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
						else
							pInfo->dwProcessorL2CacheSpeed = (DWORD) -1;

						dwID = IDR_IntelCeleron;
						//wcscpy(pInfo->szProcessorName, _T("Intel Celeron processor"));
					}
					else if (!IsXeon(pInfo))
					{
						pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PII;

						//wcscpy(pInfo->szProcessorName,
						//      _T("Intel Pentium II processor"));
						dwID = IDR_IntelPentiumII;

						// If the cache size is 512, it's half speed.
						// Otherwise it's full speed.
						if (pInfo->dwProcessorL2CacheSize == 512)
							pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed / 2;
						else
							pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
					}
					// Has to be a Xeon if we see more than 512 KB L2 cache.
					else
					{
						// Always Slot 2 for Xeons.
						pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_SLOT2;

						pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PIIXEON;
						//wcscpy(pInfo->szProcessorName,
						//      _T("Intel Pentium II Xeon processor"));
						dwID = IDR_IntelPentiumIIXeon;

						pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
					}
				}
				// PIII
				else if (dwModel == 7)
				{
					if (!IsXeon(pInfo))
					{
						pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PIII;

						//wcscpy(pInfo->szProcessorName,
						//      _T("Intel Pentium III processor"));
						dwID = IDR_IntelPentiumIII;

						// If the cache size is 512, it's half speed.
						// Otherwise it's full speed.
						if (pInfo->dwProcessorL2CacheSize == 512)
							pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed / 2;
						else
							pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
					}
					else
					{
						// Always Slot 2 for Xeons.
						pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_SLOT2;

						pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PIIIXEON;
						//wcscpy(pInfo->szProcessorName,
						//      _T("Intel Pentium III Xeon processor"));
						dwID = IDR_IntelPentiumIIIXeon;

						pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
					}
				}
				else if ((dwModel == 8) && bCanDo)
				{
					// Get the brand info
					DWORD   dwInfo[4] = {0, 0, 0, 0};
					DoCPUID(1, &dwInfo[0], &dwInfo[1], &dwInfo[2], &dwInfo[3]);

					switch (dwInfo[1] & 0xFF)
					{
						case 1:
						{
							pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_CELERON;

							if (pInfo->dwProcessorL2CacheSize)
								pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
							else
								pInfo->dwProcessorL2CacheSpeed = (DWORD) -1;

							dwID = IDR_IntelCeleron;
							//wcscpy(pInfo->szProcessorName, _T("Intel Celeron processor"));
						}
						break;

						case 2:
						{
							pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PIII;

							//wcscpy(pInfo->szProcessorName,
							//      _T("Intel Pentium III processor"));
							dwID = IDR_IntelPentiumIII;

							// If the cache size is 512, it's half speed.
							// Otherwise it's full speed.
							if (pInfo->dwProcessorL2CacheSize == 512)
								pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed / 2;
							else
								pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
						}
						break;

						case 3:
						{
							// Always Slot 2 for Xeons.
							pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_SLOT2;

							pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PIIIXEON;
							//wcscpy(pInfo->szProcessorName,
							//      _T("Intel Pentium III Xeon processor"));
							dwID = IDR_IntelPentiumIIIXeon;

							pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
						}
						break;

						default:
						{
							pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_UNKNOWN;
							dwID = IDR_UnknownIntelP6;
						}
						break;
					}
				}
				//PIII Xeon
				else if (dwModel == 10)
				{
					// Always Slot 2 for Xeons.
					pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_SLOT2;

					pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PIIIXEON;
					//wcscpy(pInfo->szProcessorName,
					//      _T("Intel Pentium III Xeon processor"));
					dwID = IDR_IntelPentiumIIIXeon;
					pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
				}
				else
				{
					pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_UNKNOWN;
					dwID = IDR_UnknownIntelP6;
					//wcscpy(pInfo->szProcessorName, _T("Unknown Intel P6 processor"));
				}
			}
		break;

		case 15:
		{
            DWORD   dwInfo[4] = {0, 0, 0, 0};
            DWORD Brand;
            // Get the brand info
            DoCPUID(1, &dwInfo[0], &dwInfo[1], &dwInfo[2], &dwInfo[3]);

            Brand = dwInfo[1] & 0xFF;

            pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_P4;
            pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
            
            if( 0xb == Brand || 0xc == Brand)
            {
                pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_XEON;
            }

            if(0xe == Brand && pInfo->dwProcessorSignature < 0xf13)
            {
                pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_XEON;
            }

            //
            // Before P4 support we used to pull info from registry for processor name
            // now to remain consistent with it we are not adding any name to resource file.
            // In future we should use registry for all processors
            //
            dwID = IDR_IntelUnknown;
            break;
		}


		default:
			pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_UNKNOWN;
			//wcscpy(pInfo->szProcessorName, _T("Unknown Intel processor"));
			dwID = IDR_IntelUnknown;
		break;
	}

	CHString strName;
	BOOL bUseResource = TRUE;

	if ((dwID == IDR_UnknownIntelP6) || (dwID == IDR_IntelUnknown))
	{
		CHString strID;
		ReadRegistryForName(dwProcessor, strName, strID);

		if (strName.GetLength())
		{
			bUseResource = FALSE;
		}
		else if (strID.GetLength())
		{
			strName = strID; 
			bUseResource = FALSE;
		}
	}

	if (bUseResource)
	{
		LoadStringW(strName, dwID);
	}

	wcscpy(pInfo->szProcessorName, strName);
}

// Assumes processor can do CPUID
void GetAMDSystemInfo(DWORD dwProcessor, SYSTEM_INFO_EX *pInfo)
{
	DWORD	dwFamily = pInfo->wProcessorLevel,
			dwModel = (pInfo->dwProcessorSignature >> 4) & 0xF,
			dwStepping = pInfo->dwProcessorSignature & 0xF;

	CHString    strFormat;
	DWORD       dwID;

	Format(strFormat, IDR_ModelSteppingFormat, dwModel, dwStepping);
	wcscpy(pInfo->szProcessorVersion, strFormat);

	//wsprintf(pInfo->szProcessorVersion, _T("Model %d, Stepping %d"),
	//      dwModel, dwStepping);
	swprintf(pInfo->szProcessorStepping, L"%d", dwStepping);

	switch(dwFamily)
	{
		case 4:
			// L2 speed == external clock.
			SetL2SpeedViaExternalClock(pInfo);
			pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_486;
			dwID = IDR_AMD4685x86;
			//wcscpy(pInfo->szProcessorName, _T("Am486 or Am5x86"));
		break;
		case 5:
		{
			switch(dwModel)
			{
				case 0:
				case 1:
				case 2:
				case 3:
					// L2 speed == external clock.
					SetL2SpeedViaExternalClock(pInfo);
					pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_K5;
					dwID = IDR_AMDK5;
					//wcscpy(pInfo->szProcessorName, _T("AMD-K5 processor"));
				break;
				case 6:
				case 7:
					// L2 speed == external clock.
					SetL2SpeedViaExternalClock(pInfo);
					pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_K6;
					dwID = IDR_AMDK6;
					//wcscpy(pInfo->szProcessorName, _T("AMD-K6 processor"));
				break;
				case 8:
					// L2 speed == external clock.
					SetL2SpeedViaExternalClock(pInfo);
					pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_K62;
					dwID = IDR_AMDK62;
					//wcscpy(pInfo->szProcessorName, _T("AMD-K6-2 processor"));
				break;
				case 9:
					// L2 speed == processor speed
					pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
					pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_K63;
					dwID = IDR_AMDK63;
					//wcscpy(pInfo->szProcessorName, _T("AMD-K6-3 processor"));
				break;
				default:
					// Unknown cache speed.
					pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_OTHER;
					dwID = IDR_AMDUnknown;
					//wcscpy(pInfo->szProcessorName, _T("Unknown AMD processor"));
				break;
			}

			break;
		}

		case 6:
		{
			// L2 speed == 1/3(processor speed)
			if (pInfo->dwProcessorSpeed > 0)
			{
				pInfo->dwProcessorL2CacheSpeed = (pInfo->dwProcessorSpeed)/3;
			}

			// If we don't yet know the upgrade method, set it to Slot A.
			if (pInfo->wWBEMProcessorUpgradeMethod == WBEM_CPU_UPGRADE_UNKNOWN)
				pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_SLOTA;

        	        dwID = IDR_AMDAthlon;
	                pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_ATHLON;
                	switch(dwModel)
        	        {
	                    case 6:
                	        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_ATHLONMP;
        	                break;
	                }
		}
		break;

		case 15:
		{
			// If we don't yet know the upgrade method, set it to Slot A.
			if ( pInfo->wWBEMProcessorUpgradeMethod == WBEM_CPU_UPGRADE_UNKNOWN )
			{
				pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_SLOTA;
			}

			//
			// if we do not have L2 cache size, let's try CPUID
			//
			if ( 0 == pInfo->dwProcessorL2CacheSize || (DWORD)-1 == pInfo->dwProcessorL2CacheSize )
			{
				if ( CanDoCPUID () )
				{
					DWORD dwInfo	= 0L ;
					DWORD dwNichts	= 0L ;

					//
					// higher word of ECX contains L2 cache size
					// for CPUID instruction level 0x80000006
					//
					DoCPUID ( 0x80000006, &dwNichts, &dwNichts, &dwInfo, &dwNichts ) ;

					pInfo->dwProcessorL2CacheSize = ( dwInfo >> 16 ) & 0xffff ;
				}
			}

			pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_AMD64 ;	// AMD64 family
			dwID = IDR_AMDUnknown ;									// to read name from registry
		}
		break ;

		default:
			dwID = IDR_AMDUnknown;
		break;
	}

	CHString strName;
	BOOL bUseResource = TRUE;

	if ((dwID == IDR_AMDUnknown) || (dwID == IDR_AMDAthlon))
	{
		CHString strID;
		ReadRegistryForName(dwProcessor, strName, strID);
		if (strName.GetLength())
		{
			bUseResource = FALSE;
		}
		else if (strID.GetLength())
		{
			strName = strID; 
			bUseResource = FALSE;
		}
	}

	if (bUseResource)
	{
		LoadStringW(strName, dwID);
	}

	wcscpy(pInfo->szProcessorName, strName);
}

void GetCyrixSystemInfo(DWORD dwProcessor, SYSTEM_INFO_EX *pInfo)
{
	DWORD	dwFamily = pInfo->wProcessorLevel,
			dwModel = (pInfo->dwProcessorSignature >> 4) & 0xF,
			dwStepping = pInfo->dwProcessorSignature & 0xF;

	CHString    strFormat;
	DWORD       dwID;

	Format(strFormat, IDR_ModelSteppingFormat, dwModel, dwStepping);

	wcscpy(pInfo->szProcessorVersion, strFormat);

	swprintf(pInfo->szProcessorStepping, L"%d", dwStepping);

	// L2 speed == external clock.
	SetL2SpeedViaExternalClock(pInfo);

	switch(dwFamily)
	{
		case 4:
			if (dwModel == 4)
			{
				pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_MEDIAGX;
				dwID = IDR_CyrixMediaGX;
				//wcscpy(pInfo->szProcessorName, _T("Cyrix MediaGX processor"));
			}
			else
			{
				pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_486;
				dwID = IDR_Cyrix486;
				//wcscpy(pInfo->szProcessorName, _T("Cyrix 486 processor"));
			}
		break;

		case 5:
			pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_M1;
			switch(dwModel)
			{
				case 0:
				case 1:
					pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_6X86;
					dwID = IDR_Cyrix6x86;
					//wcscpy(pInfo->szProcessorName, _T("Cyrix 6x86 processor"));
				break;

				case 2:
					pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_6X86;
					dwID = IDR_Cyrix6x86L;
					//wcscpy(pInfo->szProcessorName, _T("Cyrix 6x86(L) processor"));
				break;

				case 4:
					pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_MEDIAGX;
					dwID = IDR_CyrixMediaGXMMX;
					//wcscpy(pInfo->szProcessorName, _T("Cyrix MediaGX MMX Enhanced processor"));
				break;

				default:
					dwID = IDR_Cyrix586;
					//wcscpy(pInfo->szProcessorName, _T("Cyrix 586 processor"));
				break;
			}
		break;

		case 6:
			pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_OTHER;
			pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_6X86;
			dwID = IDR_Cyrix6x86MX;
			//wcscpy(pInfo->szProcessorName, _T("Cyrix 6x86MX processor"));
		break;

		default:
			pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_UNKNOWN;
			//wcscpy(pInfo->szProcessorName, _T("Unknown Cyrix processor"));
			dwID = IDR_CyrixUnknown;
		break;
	}

	CHString strName;
	BOOL bUseResource = TRUE;

	if (dwID == IDR_CyrixUnknown)
	{
		CHString strID;
		ReadRegistryForName(dwProcessor, strName, strID);

		if (strName.GetLength())
		{
			bUseResource = FALSE;
		}
		else if (strID.GetLength())
		{
			strName = strID; 
			bUseResource = FALSE;
		}
	}

	if (bUseResource)
	{
		LoadStringW(strName, dwID);
	}

	wcscpy(pInfo->szProcessorName, strName);
}

void GetCentaurSystemInfo(DWORD dwProcessor, SYSTEM_INFO_EX *pInfo)
{
	DWORD	dwFamily = pInfo->wProcessorLevel,
			dwModel = (pInfo->dwProcessorSignature >> 4) & 0xF,
			dwStepping = pInfo->dwProcessorSignature & 0xF;

	CHString    strFormat;

	// L2 speed == external clock.
	SetL2SpeedViaExternalClock(pInfo);

	Format(strFormat, IDR_ModelSteppingFormat, dwModel, dwStepping);

	wcscpy(pInfo->szProcessorVersion, strFormat);

	// Set it to ZIFF (Socket 7) if we don't have the upgrade method.
	if (pInfo->wWBEMProcessorUpgradeMethod == WBEM_CPU_UPGRADE_UNKNOWN)
		pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_ZIFF;

	//wsprintf(pInfo->szProcessorVersion, _T("Model %d, Stepping %d"),
	//      dwModel, dwStepping);

	swprintf(pInfo->szProcessorStepping, L"%d", dwStepping);

	pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_WINCHIP;

	CHString strName;
	CHString strID;
	ReadRegistryForName(dwProcessor, strName, strID);

	if (!strName.GetLength())
	{
		if (strID.GetLength())
		{
			strName = strID; 
		}
		else
		{
			LoadStringW(strName, IDR_IDTWinChip);
		}
	}

	wcscpy(pInfo->szProcessorName, strName);
}
#endif // defined(_AMD64_) || defined(_X86_)

void GetInfoViaSMBIOS(SYSTEM_INFO_EX *pInfo, DWORD dwIndex)
{
	CSMBios smbios;

	if (smbios.Init())
	{
		PPROCESSORINFO ppi = (PPROCESSORINFO) smbios.GetNthStruct(4, dwIndex);

		// If we don't find the specified processor, use the 1st.  Some buggy
		// BIOSes mess up with more than one CPU and only have a single struct.
		if (!ppi)
			ppi = (PPROCESSORINFO) smbios.GetNthStruct(4, 0);

		// Some version of smbios don't report cpu info at all
		if (ppi)
		{
			// Find the upgrade method.
			// The values translate straight across from SMBIOS to CIM.
			pInfo->wWBEMProcessorUpgradeMethod = ppi->Processor_Upgrade;

			// Find the external clock.  We'll use this later when determining the
			// cache speed.
			pInfo->dwExternalClock = ppi->External_Clock;

			PCACHEINFO pCache = NULL;

			// Find the L2 cache size.

			// For SMBIOS 2.1 and better, use the cache handle found on the
			// processor struct.
			if (smbios.GetVersion() >= 0x00020001)
			{
				pCache = (PCACHEINFO) smbios.SeekViaHandle(ppi->L2_Cache_Handle);
			}
			// For SMBIOS 2.0, enum through the cache structs and find the one
			// marked as the L2 cache.
			else
			{
				for (int i = 0; pCache = (PCACHEINFO) smbios.GetNthStruct(7, i); i++)
				{
					// If we found the L2 cache, break.
					if ((pCache->Cache_Configuration & 3) == 1)
						break;
				}
			}

			if (pCache)
			{
				// Only the lower 14 bits are significant.
				pInfo->dwProcessorL2CacheSize = pCache->Installed_Size & 0x7FFF;

				// If bit 15 is set, the granularity is 64KB, so multiply the value
				// by 64.
				if (pCache->Installed_Size & 0x8000)
					pInfo->dwProcessorL2CacheSize *= 64;

#ifdef _IA64_
				pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
#endif
			}
		}
	}
}

#if defined(_IA64_)

#include <ia64reg.h>

extern "C"
unsigned __int64 __getReg (int);

#pragma intrinsic (__getReg)

void GetNonX86SystemInfo(SYSTEM_INFO_EX *pInfo, DWORD dwProcessor)
{
	switch(pInfo->wProcessorArchitecture)
	{
		case PROCESSOR_ARCHITECTURE_IA64:
		{
			SYSTEM_PROCESSOR_INFORMATION ProcessorInfo;
			ZeroMemory(&ProcessorInfo,sizeof(ProcessorInfo));
			NTSTATUS Status = NtQuerySystemInformation(
														SystemProcessorInformation,
														&ProcessorInfo,
														sizeof(ProcessorInfo),
														NULL
														);

			CHString strName;
			CHString strID;
			ReadRegistryForName(dwProcessor, strName, strID);

			if (!strName.GetLength())
			{
				if (strID.GetLength())
				{
					strName = strID; 
				}
				else
				{
					LoadString(strName, IDR_Itanium);
				}
			}

			pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_IA64;
			wcscpy(pInfo->szProcessorName, strName);
			wcscpy(pInfo->szCPUIDProcessorName, strID.GetLength() ? strID : strName);

			if ( NT_SUCCESS(Status) )
			{
				pInfo->wProcessorLevel = ProcessorInfo.ProcessorLevel ;
				pInfo->wProcessorRevision = ProcessorInfo.ProcessorRevision ;

				CHString    strFormat;
				Format(strFormat, IDR_ModelSteppingFormat, ( ProcessorInfo.ProcessorRevision >> 8 ) & 0xFF, ProcessorInfo.ProcessorRevision & 0xFF);
				wcscpy(pInfo->szProcessorVersion, strFormat);
				swprintf(pInfo->szProcessorStepping, L"%d", ProcessorInfo.ProcessorRevision & 0xFF);
			}
			else
			{
				pInfo->wProcessorLevel = 0x1f ;	// itanium
				pInfo->wProcessorRevision = 0 ;	// not know

				wcscpy(pInfo->szProcessorVersion, strName);
				pInfo->szProcessorStepping[0] = L'\0';
			}

			break;
		}
	}
}
#endif // defined(_IA64_)

BOOL GetSystemInfoEx(DWORD dwProcessor, SYSTEM_INFO_EX *pInfo, DWORD dwCurrentSpeed)
{
	// Make the thread run on the right processor.
	DWORD dwPreviousMask = SetThreadAffinityMask(GetCurrentThread(), 1 << dwProcessor);

#if defined(_AMD64_) || defined(_X86_)
	BOOL    bCanDoCPUID = CanDoCPUID();
	DWORD   dwFamily;
#endif // defined(_AMD64_) || defined(_X86_)

	// Fill in the first part of the structure using Win32.
	memset(pInfo, 0, sizeof(*pInfo));

#if defined(_AMD64_) || defined(_X86_)
	GetCPUInfo	(
					&dwFamily,
					&pInfo->dwProcessorSignature,
					&pInfo->dwProcessorFeatures,
					&pInfo->dwProcessorFeaturesEx,
					(SYSTEM_INFO *) pInfo
				);

	pInfo->bCoprocessorPresent = HasCoprocessor();

    // Serial number available?
	if (pInfo->dwProcessorFeatures & (1 << 18))
	{
		DWORD dwNichts;

		pInfo->dwSerialNumber[0] = pInfo->dwProcessorSignature;

		DoCPUID(3, &dwNichts, &dwNichts, &pInfo->dwSerialNumber[2], &pInfo->dwSerialNumber[1]);
	}
	else
	{
		pInfo->dwSerialNumber[0] = 0;
		pInfo->dwSerialNumber[1] = 0;
		pInfo->dwSerialNumber[2] = 0;
	}
#else
	GetSystemInfo((SYSTEM_INFO *) pInfo);
	pInfo->bCoprocessorPresent = TRUE;
#endif // defined(_AMD64_) || defined(_X86_)

	if (dwCurrentSpeed == 0)
	{
		pInfo->dwProcessorSpeed = GetFixedCPUSpeed();
	}
	else
	{
		pInfo->dwProcessorSpeed = dwCurrentSpeed;
	}

	pInfo->dwProcessorL2CacheSpeed = (DWORD) -1;
	pInfo->dwProcessorL2CacheSize = (DWORD) -1;
	pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_UNKNOWN;
	pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_UNKNOWN;

	GetVendor(pInfo->szProcessorVendor);

	GetInfoViaSMBIOS(pInfo, dwProcessor);

    // These calls will fill in the szProcessorName.  This is a string
    // we'll deduce by looking at the CPUID signature, L2 cache size, etc.
#if defined(_AMD64_) || defined(_X86_)

	BOOL bGotName = TRUE;

	if (!bCanDoCPUID)
		bGotName = FALSE;
	else
	{
		if (!_wcsicmp(pInfo->szProcessorVendor, L"GenuineIntel"))
			GetIntelSystemInfo(dwProcessor, pInfo);
		else if (!_wcsicmp(pInfo->szProcessorVendor, L"AuthenticAMD"))
			GetAMDSystemInfo(dwProcessor, pInfo);
		else if (!_wcsicmp(pInfo->szProcessorVendor, L"CyrixInstead"))
			GetCyrixSystemInfo(dwProcessor, pInfo);
		else if (!_wcsicmp(pInfo->szProcessorVendor, L"CentaurHauls"))
			GetCentaurSystemInfo(dwProcessor, pInfo);
		else
			bGotName = FALSE;
	}

	if (!bGotName)
	{
		CHString strName;
		CHString strID;
		ReadRegistryForName(dwProcessor, strName, strID);

		if (!strName.GetLength())
		{
			if (strID.GetLength())
			{
				strName = strID; 
			}
			else
			{
				Format(strName, IDR_x86ProcessorFormat, dwFamily);
				//wsprintf(pInfo->szProcessorName, _T("%d86 processor"), dwFamily);
			}
		}

		wcscpy(pInfo->szProcessorName, strName);

	}
#else
	GetNonX86SystemInfo(pInfo, dwProcessor);
#endif // defined(_AMD64_) || defined(_X86_)

#if !defined(_IA64_)

	// This one fills in szProcessorName, using either CPUID (as with later AMD
	// chips) or with a generic 'x86, Family 6, ...' string.
	GetCPUIDName(dwProcessor, pInfo);

#endif // defined (_IA64_)

	// Put back the previous thread affinity.
	SetThreadAffinityMask(GetCurrentThread(), dwPreviousMask);

	return TRUE;
}

#define MHZ_LOW_TOLERANCE   3
#define MHZ_HIGH_TOLERANCE  1

const DWORD dwMHzVal[] =
{
    4,   10,   16,   20,   25,   33,   40,   50,   60,   66,   75,   83,   90,
  100,  120,  125,  133,  150,  166,  180,  200,  233,  266,  300,  333,  350,
  366,  400,  433,  450,  466,  475,  500,  533,  550,  600,  633,  667,  700,
  800,  900, 1000, 1100, 1200
};

DWORD GetFixedCPUSpeed()
{
	int	i,
		nVals = sizeof(dwMHzVal) / sizeof(dwMHzVal[0]);

#if defined(_AMD64_) || defined(_X86_)
	DWORD   dwCPUClockRate = CPURawSpeed();
#else
	DWORD   dwCPUClockRate = GetTimeCounterCPUSpeed();
#endif // defined(_AMD64_) || defined(_X86_)

	for (i = 0; i < nVals; i++)
	{
		if (dwCPUClockRate >= dwMHzVal[i] - MHZ_LOW_TOLERANCE && dwCPUClockRate <= dwMHzVal[i] + MHZ_HIGH_TOLERANCE)
		{
			dwCPUClockRate = dwMHzVal[i];
			break;
		}
	}

	return dwCPUClockRate;
}

#if defined(_X86_)

// Counter function for IA-32
#define GetCounter(pdwRet)  RDTSC _asm MOV pdwRet, EAX

#elif defined(_AMD64_)

#define GetCounter(pdwRet) pdwRet = (ULONG)ReadTimeStampCounter()

#elif defined(_IA64_)

// TODO: Counter function for IA-64
#define GetCounter(pdwRet)  pdwRet = 0

#endif

#define MAX_TRIES               500             // Maximum number of samplings
#define WAIT_MS         5
#define NUM_TO_MATCH    5

BOOL DoFreqsMatch(DWORD *pdwFreq)
{
    for (int i = 1; i < NUM_TO_MATCH; i++)
    {
        if (pdwFreq[i] != pdwFreq[0])
            return FALSE;
    }

    return TRUE;
}

DWORD GetTimeCounterCPUSpeed()
{
		LARGE_INTEGER	liFreq;         // High Resolution Performance Counter frequency
		DWORD			dwFreq[NUM_TO_MATCH];
		HANDLE			hThread = GetCurrentThread();

		// Must have a high resolution counter.
		if (!QueryPerformanceFrequency(&liFreq))
			return 0;

		// Loop until all three frequencies match or we exeed MAX_TRIES.
		for (int iTries = 0;
			(iTries < NUM_TO_MATCH || !DoFreqsMatch(dwFreq)) && iTries < MAX_TRIES;
			iTries++)
		{
			LARGE_INTEGER       liBegin,
			liEnd;
			DWORD           dwCycles,
			dwStamp0,       // Time Stamp Variable for beginning and end
			dwStamp1,
			dwTicks;

			int iPriority = GetThreadPriority(hThread);

			// Set the thread to the highest priority.
			if (iPriority != THREAD_PRIORITY_ERROR_RETURN)
				SetThreadPriority(hThread, THREAD_PRIORITY_TIME_CRITICAL);


			// Get the initial time.
			QueryPerformanceCounter(&liBegin);

			// Get the processor counter.
			GetCounter(dwStamp0);

			// This allows for elapsed time for sampling.
			Sleep(WAIT_MS);

			// Get the end time.
			QueryPerformanceCounter(&liEnd);

			// Get the processor counter.
			GetCounter(dwStamp1);


			// Put back the priority to where we found it.
			if (iPriority != THREAD_PRIORITY_ERROR_RETURN)
				SetThreadPriority(hThread, iPriority);

			// Number of internal clock cycles is difference between
			// two time stamp readings.
			dwCycles = dwStamp1 - dwStamp0;

			// Number of external ticks is difference between two
			// hi-res counter reads.
			dwTicks = (DWORD) liEnd.LowPart - (DWORD) liBegin.LowPart;

			DWORD dwCurrentFreq =
									(DWORD) ((((float) dwCycles * (float) liFreq.LowPart) /
									(float) dwTicks) / 100000.0f);

			// dwCurrentFreq is currently in this form: 4338 (433.8 MHz)
			// Take any fraction up to the next round number.
			dwFreq[iTries % NUM_TO_MATCH] = (dwCurrentFreq + (dwCurrentFreq % 10)) / 10;
		}

		return dwFreq[0];
}

#if defined(_AMD64_) || defined(_X86_)
// Number of cycles needed to execute a single BSF instruction.
// Note that processors below i386(tm) are not supported.
static DWORD dwProcessorCycles[] =
{
        00,  00,  00, 115, 47, 43,
        38,  38,  38, 38,  38, 38,
};

#define ITERATIONS              4000
#define SAMPLINGS               10

DWORD CPURawSpeedHelper(DWORD dwFamily, DWORD dwFeatures)
{
#if defined(_AMD64_)
	return GetTimeCounterCPUSpeed();
#else
		// Clock cycles elapsed during test
		DWORD	dwCycles;
		int	bManual = FALSE; // Specifies whether the user
		//   manually entered the number of
		//   cycles for the BSF instruction.

		dwCycles = ITERATIONS * dwProcessorCycles[dwFamily];

		// Check for manual BSF instruction clock count
		if (!(dwFeatures & TSC_FLAG))
			bManual = 1;

		if (!bManual)
			//	On processors supporting the Read Time Stamp opcode, compare elapsed
			//	time on the High-Resolution Counter with elapsed cycles on the Time
			//	Stamp Register.
			return GetTimeCounterCPUSpeed();
		else if (dwFamily >= 3)
			return GetBSFCPUSpeed(dwCycles);

		return 0;
#endif
}

DWORD CPURawSpeed()
{
    DWORD   dwFamily,
            dwSignature,
            dwFeatures;

	GetCPUInfo(&dwFamily, &dwSignature, &dwFeatures, NULL, NULL);
	return CPURawSpeedHelper(dwFamily, dwFeatures);
}

#if defined(_X86_)
DWORD GetBSFCPUSpeed(DWORD dwCycles)
{
    // If processor does not support time stamp reading, but is at least a
    // 386 or above, utilize method of timing a loop of BSF instructions
    // which take a known number of cycles to run on i386(tm), i486(tm), and
    // Pentium(R) processors.
    LARGE_INTEGER   t0,
                    t1,         // Variables for Highres perf counter reads.
                    liCountFreq;// Highres perf counter frequency
    DWORD           dwFreq = 0, // Most current freq. calculation
                    dwTicks,
                    dwCurrent = 0,
                    dwLowest = 0xFFFFFFFF;
    int             i;

    if (!QueryPerformanceFrequency(&liCountFreq))
        return 0;

	for (i = 0; i < SAMPLINGS; i++)
	{
		QueryPerformanceCounter(&t0);   // Get start time

		_asm
		{
			mov eax, 80000000h
			mov bx, ITERATIONS

			// Number of consecutive BSF instructions to execute.

			loop1:
			bsf ecx,eax

			dec bx
			jnz loop1
		}

		// Get end time
		QueryPerformanceCounter(&t1);

		// Number of external ticks is difference between two
		//   hi-res counter reads.
		dwCurrent = (DWORD) t1.LowPart - (DWORD) t0.LowPart;

		if (dwCurrent < dwLowest)
			dwLowest = dwCurrent;
	}

	dwTicks = dwLowest;


	dwFreq =
		(DWORD) ((((float) dwCycles * (float) liCountFreq.LowPart) /
		(float) dwTicks) / 1000000.0f);

	return dwFreq;
}
#endif // defined(_X86_)

BOOL HasCoprocessor()
{
#if defined(_AMD64_)
	return TRUE;
#else
    BOOL bRet;
    WORD wFPStatus;

    _asm
	{
        fninit                  ; reset FP status word
        mov wFPStatus, 5a5ah    ; initialize temp word to non-zero
        fnstsw wFPStatus        ; save FP status word
        mov ax, wFPStatus       ; check FP status word
        cmp al, 0               ; was correct status written
        mov bRet, 0             ; no FPU present
        jne end_fpu_type

;check_control_word:
        fnstcw wFPStatus        ; save FP control word
        mov ax, wFPStatus       ; check FP control word
        and ax, 103fh           ; selected parts to examine
        cmp ax, 3fh             ; was control word correct
        mov bRet, 0
        jne end_fpu_type        ; incorrect control word, no FPU
        mov bRet, 1

end_fpu_type:
	}

	return bRet;
#endif // defined(_AMD64_)
}
#endif // defined(_AMD64_) || defined(_X86_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\cpuid.h ===
//=================================================================

//

// CPUID.h

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#define FPU_FLAG			0x00000001 
#define VME_FLAG			0x00000002 
#define DE_FLAG			0x00000004 
#define PSE_FLAG			0x00000008 
#define TSC_FLAG			0x00000010 
#define MSR_FLAG			0x00000020 
#define PAE_FLAG			0x00000040 
#define MCE_FLAG			0x00000080 
#define CX8_FLAG			0x00000100 
#define APIC_FLAG			0x00000200 
#define MTRR_FLAG			0x00001000 
#define PGE_FLAG			0x00002000 
#define MCA_FLAG			0x00004000 
#define CMOV_FLAG			0x00008000 
#define MMX_FLAG			0x00800000
#define THREEDNOW_FLAG	0x80000000

#define WBEM_CPU_FAMILY_OTHER		1
#define WBEM_CPU_FAMILY_UNKNOWN	    2
#define WBEM_CPU_FAMILY_386		    5
#define WBEM_CPU_FAMILY_486		    6
#define WBEM_CPU_FAMILY_PENTIUM	    11
#define WBEM_CPU_FAMILY_PPRO		12
#define WBEM_CPU_FAMILY_PII		    13
#define WBEM_CPU_FAMILY_PMMX		14
#define WBEM_CPU_FAMILY_CELERON		15
#define WBEM_CPU_FAMILY_PIIXEON		16
#define WBEM_CPU_FAMILY_PIII		17
#define WBEM_CPU_FAMILY_PIIIXEON	176
#define WBEM_CPU_FAMILY_P4			178
#define WBEM_CPU_FAMILY_XEON		179
#define WBEM_CPU_FAMILY_M1			18
#define WBEM_CPU_FAMILY_M2			19
#define WBEM_CPU_FAMILY_K5			24
#define WBEM_CPU_FAMILY_K6			25
#define WBEM_CPU_FAMILY_K62 		26
#define WBEM_CPU_FAMILY_K63	    	27
#define WBEM_CPU_FAMILY_ATHLON    	28
#define WBEM_CPU_FAMILY_DURON    	29
#define WBEM_CPU_FAMILY_ALPHA 	    48
#define WBEM_CPU_FAMILY_MIPS		64
#define WBEM_CPU_FAMILY_PPC		    32
#define WBEM_CPU_FAMILY_6X86	    300
#define WBEM_CPU_FAMILY_MEDIAGX	    301
#define WBEM_CPU_FAMILY_MII 	    302
#define WBEM_CPU_FAMILY_WINCHIP     320

#define WBEM_CPU_FAMILY_IA64		130
#define WBEM_CPU_FAMILY_ATHLONMP    183
#define WBEM_CPU_FAMILY_IA64_2		184

#define	WBEM_CPU_FAMILY_AMD64		185
#define WBEM_CPU_FAMILY_K7	    	190

#define WBEM_CPU_UPGRADE_OTHER	    1
#define WBEM_CPU_UPGRADE_UNKNOWN    2
#define WBEM_CPU_UPGRADE_ZIFF		4
#define WBEM_CPU_UPGRADE_SLOT1	    8
#define WBEM_CPU_UPGRADE_SLOT2	    9
#define WBEM_CPU_UPGRADE_SOCKET_370 10
#define WBEM_CPU_UPGRADE_SLOTA	    11
#define WBEM_CPU_UPGRADE_SLOTM	    12





typedef struct _tagSYSTEM_INFO_EX
{
	// From SYSTEM_INFO
	union 
	{         
		DWORD  dwOemId;         
		struct 
		{ 
            WORD wProcessorArchitecture;             
			WORD wReserved;         
		}; 
    };     
	DWORD		dwPageSize;     
	LPVOID		lpMinimumApplicationAddress; 
	LPVOID		lpMaximumApplicationAddress;     
	DWORD_PTR	dwActiveProcessorMask; 
	DWORD		dwNumberOfProcessors;     
	DWORD		dwProcessorType; 
	DWORD		dwAllocationGranularity;     
	WORD		wProcessorLevel; 
	WORD		wProcessorRevision;
	
	// New properties for SYSTEM_INFO_EX
	WCHAR   szProcessorName[100];
	WCHAR   szCPUIDProcessorName[100];
	WCHAR   szProcessorVersion[100];
    WCHAR   szProcessorVendor[40];
	WCHAR	szProcessorStepping[17];
	DWORD	dwProcessorSpeed;
	DWORD	dwProcessorL2CacheSize;
	DWORD	dwProcessorL2CacheSpeed;
	DWORD	dwProcessorSignature;
	DWORD	dwProcessorFeatures;
	DWORD   dwProcessorFeaturesEx;
	BOOL	bCoprocessorPresent;
	
    // PIII (and higher) serial number
    DWORD   dwSerialNumber[3];

	// WBEM specific
	WORD	wWBEMProcessorFamily;
	WORD	wWBEMProcessorUpgradeMethod;

    // SMBIOS
    DWORD   dwExternalClock;
} SYSTEM_INFO_EX;

#ifdef __cplusplus
extern "C" {
#endif

BOOL GetSystemInfoEx(DWORD dwProcessor, SYSTEM_INFO_EX *pInfo, DWORD dwCurrentSpeed);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\delayloadhandler.cpp ===
//***************************************************************************

//

//  DELAYLOADHANDLER.CPP

//

//  Module: Delay load handler functions

//

//  Purpose: When delay loaded libraries either fail to load, or functions

//           in them are not found, this handler is called as a result of

//           the //DELAYLOAD linker specification.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <delayimp.h>


// Skeleton DliHook function that does nothing interesting
FARPROC WINAPI DliHook(
    unsigned dliNotify, 
    PDelayLoadInfo pdli) 
{
   FARPROC fp = NULL;   // Default return value

   // NOTE: The members of the DelayLoadInfo structure pointed
   // to by pdli shows the results of progress made so far. 

   switch (dliNotify) 
   {
   case dliStartProcessing:
      // Called when __delayLoadHelper attempts to find a DLL/function
      // Return 0 to have normal behavior, or non-0 to override
      // everything (you will still get dliNoteEndProcessing)
      break;

   case dliNotePreLoadLibrary:
      // Called just before LoadLibrary
      // Return NULL to have __delayLoadHelper call LoadLibary
      // or you can call LoadLibrary yourself and return the HMODULE
      fp = (FARPROC)(HMODULE) NULL;
      break;

   case dliFailLoadLib:
      // Called if LoadLibrary fails
      // Again, you can call LoadLibary yourself here and return an HMODULE
      // If you return NULL, __delayLoadHelper raises the 
      // ERROR_MOD_NOT_FOUND exception
      fp = (FARPROC)(HMODULE) NULL;
      break;

   case dliNotePreGetProcAddress:
      // Called just before GetProcAddress
      // Return NULL to have __delayLoadHelper call GetProcAddress
      // or you can call GetProcAddress yourself and return the address
      fp = (FARPROC) NULL;
      break;

   case dliFailGetProc:
      // Called if GetProcAddress fails
      // Again, you can call GetProcAddress yourself here and return an address
      // If you return NULL, __delayLoadHelper raises the 
      // ERROR_PROC_NOT_FOUND exception
      fp = (FARPROC) NULL;
      break;

   case dliNoteEndProcessing:
      // A simple notification that __delayLoadHelper is done
      // You can examine the members of the DelayLoadInfo structure
      // pointed to by pdli and raise an exception if you desire
      break;
   }

   return(fp);
}

// Tell __delayLoadHelper to call my hook function
PfnDliHook __pfnDliNotifyHook  = DliHook;
PfnDliHook __pfnDliFailureHook = DliHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\dependentservice.h ===
//=================================================================

//

// DependentService.h

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __ASSOC_DEPENDENTSERVICE__
#define __ASSOC_DEPENDENTSERVICE__

// Property set identification
//============================

#define	PROPSET_NAME_DEPENDENTSERVICE	_T("Win32_DependentService")

#define	SERVICE_REG_KEY_FMAT		_T("System\\CurrentControlSet\\Services\\%s")
#define	SERVICE_DEPENDSONSVC_NAME	L"DependOnService"
#define	SERVICE_DEPENDSONGRP_NAME	L"DependOnGroup"

class CWin32DependentService : public Provider
{
public:
	// Constructor/destructor
	//=======================
	CWin32DependentService( const CHString& strName, LPCWSTR pszNamespace = NULL ) ;
	~CWin32DependentService() ;

	// Functions provide properties with current values
	//=================================================
	virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
	virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );
    virtual HRESULT ExecQuery( MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags);

	// Utility function(s)
	//====================
private:

#ifdef NTONLY
	// Windows NT Helpers
	HRESULT RefreshInstanceNT( CInstance* pInstance );
	HRESULT AddDynamicInstancesNT( MethodContext* pMethodContext );
    HRESULT CreateServiceDependenciesNT(

        LPCWSTR pwszServiceName,
        LPCWSTR pwszServicePath,
        MethodContext*			pMethodContext,
        std::map<CHString,CHString>&	servicetopathmap,
        LPBYTE&					pByteArray,
        DWORD&					dwArraySize
    );

    HRESULT CreateServiceAntecedentsNT(

        MethodContext*			pMethodContext,
        std::map<CHString, CHString>	&servicetopathmap,
        CHStringArray           &csaAntecedents,
        LPBYTE&					pByteArray,
        DWORD&					dwArraySize
    );

	BOOL QueryNTServiceRegKeyValue( LPCTSTR pszServiceName, LPCWSTR pwcValueName, LPBYTE& pByteArray, DWORD& dwArraySize );

	// Map Helpers
	void InitServiceToPathMap( TRefPointerCollection<CInstance>& serviceList, std::map<CHString,CHString>& servicetopathmap );

    DWORD IsInList(
                                
        const CHStringArray &csaArray, 
        LPCWSTR pwszValue
    );
#endif
	BOOL ReallocByteArray( LPBYTE& pByteArray, DWORD& dwArraySize, DWORD dwSizeRequired );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\desktop.cpp ===
//=================================================================

//

// Desktop.CPP --Desktop property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				10/16/97	a-sanjes		Ported to new project.
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "wbemnetapi32.h"
#include "UserHive.h"
#include "Desktop.h"
#include <strsafe.h>

#pragma warning(disable : 4995) // we introduced as including strsafe.h gives error for all unsafe string functions


// Provider declaration
//=========================

CWin32Desktop	win32Desktop( PROPSET_NAME_DESKTOP, IDS_CimWin32Namespace );

// Initialize the static font size map
const int CWin32Desktop::MAP_SIZE = 19;
const CWin32Desktop::IconFontSizeMapElement CWin32Desktop::iconFontSizeMap[] =
{
	{6,  0xF6},
	{7,  0xF4},
	{8,  0xF3},
	{9,  0xF1},
	{10, 0xEF},
	{11, 0xEE},
	{12, 0xEC},
	{13, 0xEA},
	{14, 0xE9},
	{15, 0xE7},
	{16, 0xE5},
	{17, 0xE4},
	{18, 0xE2},
	{19, 0xE0},
	{20, 0xDF},
	{21, 0xDD},
	{22, 0xDB},
	{23, 0xDA},
	{24, 0xD8}
};

// Defined in ComputerSystem.cpp

extern TCHAR *GetAllocatedProfileSection (

	const CHString &a_Section ,
	const CHString &a_FileName ,
	DWORD *a_dwSize
) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Desktop::CWin32Desktop
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32Desktop::CWin32Desktop (

	const CHString &strName,
	LPCWSTR pszNamespace

) : Provider ( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Desktop::~CWin32Desktop
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : None.
 *
 *****************************************************************************/

CWin32Desktop::~CWin32Desktop()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32Desktop::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32Desktop :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
	HRESULT	hr = WBEM_E_NOT_FOUND;

	// Pull the name out of the instance and attempt to load
	// the values for it.

	CHString strName ;
	pInstance->GetCHString( IDS_Name, strName );
        if(strName.GetLength() > 0)
        {
#ifdef NTONLY

	    hr = LoadDesktopValuesNT (
  
		    strName.CompareNoCase ( _T(".DEFAULT")) == 0 ? NULL : ( LPCTSTR ) strName,
		    NULL,
		    pInstance
	    ) ;

#endif
        }
	return hr;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32Desktop::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32Desktop::EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{

	// Enumerate instances based on the OS.

#ifdef NTONLY

	HRESULT hr = EnumerateInstancesNT ( pMethodContext ) ;

#endif

    return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Desktop::EnumerateInstancesNT
 *
 *  DESCRIPTION : Creates instance for all known local users (NT)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32Desktop::EnumerateInstancesNT (

	MethodContext *pMethodContext
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

//****************************************
//  Open the registry
//****************************************

	CRegistry regProfileList ;

	DWORD dwErr = regProfileList.OpenAndEnumerateSubKeys (

		HKEY_LOCAL_MACHINE,
		IDS_RegNTProfileList,
		KEY_READ
	) ;

// Open the ProfileList key so we know which profiles to load up.

	if ( dwErr == ERROR_SUCCESS )
	{
		/*we know how many subkeys there are so only loop that many times
		 *Note to whoever wrote this allocating an initial profile array of
		 *20 means that you create 20 new instances and call LoadDesktopValuesNT
		 *20 times when you know that you must do it at most GetCurrentSubKeyCount times
		 */

		CHStringArray profiles;
		profiles.SetSize ( regProfileList.GetCurrentSubKeyCount () , 5 ) ;

		CHString strProfile ;
		for ( int i = 0; regProfileList.GetCurrentSubKeyName ( strProfile ) == ERROR_SUCCESS ; i ++ )
		{
			profiles.SetAt ( i , strProfile ) ;
			regProfileList.NextSubKey () ;
		}

		regProfileList.Close() ;

		for ( int j = 0 ; j < profiles.GetSize () && dwErr == ERROR_SUCCESS && SUCCEEDED ( hr ) ; j ++ )
		{
			CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false);

// We load by profile name here.

			HRESULT t_Result = LoadDesktopValuesNT ( NULL , profiles [ j ] , pInstance ) ;
			if ( WBEM_S_NO_ERROR ==  t_Result )
			{
				hr = pInstance->Commit ( ) ;
			}
		}

		profiles.RemoveAll();
	}
	else
	{
		hr = WinErrorToWBEMhResult(dwErr);
	}

	// ...and one for de faulty case (.DEFAULT):

	if ( dwErr != ERROR_ACCESS_DENIED )
	{
		CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
		HRESULT t_Result = LoadDesktopValuesNT ( NULL , NULL , pInstance ) ;
		if ( WBEM_S_NO_ERROR == t_Result )
		{
			hr = pInstance->Commit ( ) ;
		}
	}
	else
	{
		hr = WinErrorToWBEMhResult ( dwErr ) ;
	}

	return hr ;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : LoadDesktopValuesNT
 *
 *  DESCRIPTION : Sets up for NT desktop discovery
 *
 *  INPUTS      :	LPCTSTR pszUserName - User Name to get profile for.
 *					LPCTSTR	pszProfile - Profile Name
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32Desktop::LoadDesktopValuesNT (

	LPCTSTR pszUserName,
	LPCTSTR pszProfile,
	CInstance *pInstance
)
{
	CHString strUserName ( pszUserName ) ;
	CHString strProfile ( pszProfile ) ;

	DWORD		dwReturn = 0;

	// Try to open user's hive

	CRegistry RegInfo ;

	// Load the UserHive depending on whether we have the username or the profile name
	// filled out.

	CUserHive UserHive ;
    bool t_bHiveIsLoaded = false;

	TCHAR szKeyName [ _MAX_PATH ] ;

    try
    {

	    if ( NULL != pszUserName )
	    {
		    // KeyName will get loaded.  This is essentially the string representation
		    // of our profile name.

		    if ( ( dwReturn = UserHive.Load ( pszUserName , szKeyName,  _MAX_PATH ) ) == ERROR_SUCCESS )
		    {
                t_bHiveIsLoaded = true;
			    strProfile = szKeyName;
		    }
	    }
	    else if (pszProfile)
	    {
		    // If this succeeds, store the profile in the keyname
		    if ( ( dwReturn = UserHive.LoadProfile ( pszProfile , strUserName ) ) == ERROR_SUCCESS  && 
                            strUserName.GetLength() > 0 )
		    {
                t_bHiveIsLoaded = true;
                if(FAILED(StringCchCopy( szKeyName, _MAX_PATH, pszProfile ))){
                    dwReturn = E_FAIL;
                }
		    }
	    }
	    else
	    {
	    // Both name and profile are NULL, which means use the .DEFAULT hive.

		    lstrcpy ( szKeyName, _T(".DEFAULT") ) ;
		    strUserName = szKeyName ;
		    strProfile = szKeyName ;

            // Find out if we can read the default user hive.
            dwReturn = RegInfo.Open ( HKEY_USERS , _T(".DEFAULT") , KEY_READ ) ;
	    }

	    // User name is the key so there is no point adding the instance if we
        // failed to get the key.
        if(strUserName.IsEmpty())
        {
            dwReturn = E_FAIL;
        }
        if ( ERROR_SUCCESS == dwReturn)
	    {
            // User hive exists, try to open it

		    // szKeyName should be loaded with the profile name
		    // (a string representation of the SID) for this
		    // particular user, so strcat is OK here.

            lstrcat ( szKeyName, IDS_RegControlPanelDesktop ) ;

            dwReturn = RegInfo.Open ( HKEY_USERS , szKeyName , KEY_READ ) ;
            if ( dwReturn == ERROR_SUCCESS )
            {
                pInstance->SetCHString ( IDS_Name , strUserName ) ;

			    CHString sTemp ;

                if ( RegInfo.GetCurrentKeyValue ( IDS_CoolSwitch , sTemp ) == ERROR_SUCCESS )
			    {
	                pInstance->Setbool ( IDS_CoolSwitch , sTemp == _T("1") ) ;
			    }

                if ( RegInfo.GetCurrentKeyValue ( IDS_CursorBlinkRate , sTemp ) == ERROR_SUCCESS )
			    {
	                pInstance->SetDWORD ( IDS_CursorBlinkRate , _ttoi(sTemp) ) ;
			    }
                else
			    {
                   // This appears to be the default
	                pInstance->SetDWORD ( IDS_CursorBlinkRate , 500 ) ;
			    }

                if ( RegInfo.GetCurrentKeyValue ( IDS_DragFullWindows , sTemp ) == ERROR_SUCCESS )
			    {
	                pInstance->Setbool(IDS_DragFullWindows, sTemp == _T("1"));
			    }

                if ( RegInfo.GetCurrentKeyValue ( IDS_GridGranularity , sTemp ) == ERROR_SUCCESS )
			    {
	                pInstance->SetDWORD(IDS_GridGranularity, _ttoi(sTemp));
			    }

				// Adding the Horizontal and Vertical Spacing
				int iIconHeight = GetSystemMetrics( SM_CYICON );
				int iIconWidth  = GetSystemMetrics ( SM_CXICON );
				int iIconHorizontalSpacing = GetSystemMetrics ( SM_CXICONSPACING );
				int iIconVerticalSpacing = GetSystemMetrics ( SM_CYICONSPACING );

                if ( ! IsWinNT5 () )
                {
                    if ( RegInfo.GetCurrentKeyValue ( IDS_IconSpacing , sTemp ) == ERROR_SUCCESS )
				    {
                        // Have to subtract 32 to get the correct value
                        pInstance->SetDWORD(IDS_IconSpacing, CALC_IT(_ttoi(sTemp) - 32));
				    }

                    if (RegInfo.GetCurrentKeyValue(IDS_IconTitleWrap, sTemp) == ERROR_SUCCESS)
				    {
	                    pInstance->Setbool(IDS_IconTitleWrap, sTemp == _T("1"));
				    }
                }
                else
                {
                    CHString strKey;
                    strKey.Format(_T("%s\\WindowMetrics"), szKeyName);

                    CRegistry reg;
                    if ( reg.Open ( HKEY_USERS , strKey , KEY_READ ) == ERROR_SUCCESS )
                    {
                        if ( reg.GetCurrentKeyValue ( IDS_IconSpacing, sTemp ) == ERROR_SUCCESS )
					    {
                            // Have to subtract 32 to get the correct value
                            pInstance->SetDWORD ( IDS_IconSpacing , CALC_IT ( _ttoi ( sTemp ) ) - 32  ) ;
					    }

                        if ( reg.GetCurrentKeyValue ( IDS_IconTitleWrap , sTemp ) == ERROR_SUCCESS )
					    {
	                        pInstance->Setbool ( IDS_IconTitleWrap , sTemp == _T("1") ) ;
					    }
                        else
					    {
	                        // This seems to not be there on later NT5 builds,
                            // but since the user can't change this anyway we'll
                            // assume it's always set.
                            pInstance->Setbool ( IDS_IconTitleWrap , TRUE ) ;
					    }
                    }
                }

                sTemp = L"";
                if ( RegInfo.GetCurrentKeyValue ( IDS_Pattern , sTemp ) != ERROR_SUCCESS )
			    {
                    sTemp = L"(None)";
                }
                pInstance->SetCHString ( IDS_Pattern , sTemp ) ;

                //if ( RegInfo.GetCurrentKeyValue ( IDS_RegScreenSaveActive , sTemp ) == ERROR_SUCCESS )
			    //{
	            //    pInstance->Setbool ( IDS_ScreenSaverActive , sTemp == _T("1") ) ;
			    //}

                sTemp = L"";
                if( RegInfo.GetCurrentKeyValue ( IDS_RegSCRNSAVEEXE , sTemp ) == ERROR_SUCCESS )
			    {
				    pInstance->SetCHString ( IDS_ScreenSaverExecutable , sTemp ) ;
                }
                else
                {
                    sTemp = L"";
                }    

                // The control panel applet bases the decision as to whether
                // a screen saver is active or not based not on the ScreenSaverActive
                // registry entry, but on whether the ScreenSaverExecutable
                // setting is there or not.  So we will too...
                if(sTemp.GetLength() > 0)
                {
                    pInstance->Setbool ( IDS_ScreenSaverActive , true ) ;
                }
                else
                {
                    pInstance->Setbool ( IDS_ScreenSaverActive , false ) ;
                }
			    

                if ( RegInfo.GetCurrentKeyValue ( IDS_RegScreenSaverIsSecure , sTemp ) == ERROR_SUCCESS )
			    {
	                pInstance->Setbool ( IDS_ScreenSaverSecure , sTemp == _T("1") ) ;
			    }

                if ( RegInfo.GetCurrentKeyValue ( IDS_RegScreenSaveTimeOut , sTemp ) == ERROR_SUCCESS )
			    {
	                pInstance->SetDWORD ( IDS_ScreenSaverTimeout , _ttoi ( sTemp ) ) ;
			    }

                if ( RegInfo.GetCurrentKeyValue ( IDS_Wallpaper, sTemp ) == ERROR_SUCCESS )
			    {
				    pInstance->SetCHString ( IDS_Wallpaper , sTemp ) ;
			    }

                if ( RegInfo.GetCurrentKeyValue ( IDS_RegTileWallpaper , sTemp ) == ERROR_SUCCESS )
			    {
	                pInstance->Setbool ( IDS_WallpaperTiled , sTemp == _T("1") ) ;
			    }

			    DWORD dwStyle = 0 ;
                if ( RegInfo.GetCurrentKeyValue ( _T("WallpaperStyle") , dwStyle ) == ERROR_SUCCESS )
                {
				    if ( dwStyle != 0 )
				    {
	                    pInstance->SetDWORD ( _T("WallpaperStretched") , TRUE ) ;
				    }
				    else
				    {
					    pInstance->SetDWORD ( _T("WallpaperStretched") , FALSE ) ;
				    }
			    }
			    else
			    {
				    pInstance->SetDWORD ( _T("WallpaperStretched") , FALSE ) ;
			    }



                if(!IsWinNT5())  // what this does is set the user's default values, which will remain the ones we report unless we override it below from values contained in windowmstrics\iconfont
                {
                    if ( RegInfo.GetCurrentKeyValue ( IDS_IconTitleFaceName , sTemp ) == ERROR_SUCCESS )
			        {
	                    pInstance->SetCHString ( IDS_IconTitleFaceName , sTemp) ;
			        }

                    if ( RegInfo.GetCurrentKeyValue ( IDS_IconTitleSize , sTemp ) == ERROR_SUCCESS )
			        {
	                    pInstance->SetDWORD ( IDS_IconTitleSize , _ttoi(sTemp) - 1) ;
			        }
                }

                RegInfo.Close () ;
            }

            lstrcat( szKeyName , IDS_RegWindowMetricsKey ) ;
            if ( RegInfo.Open ( HKEY_USERS , szKeyName , KEY_READ) == ERROR_SUCCESS )
            {
			    CHString sTemp ;

                if ( RegInfo.GetCurrentKeyValue ( IDS_BorderWidth , sTemp ) == ERROR_SUCCESS )
			    {
	                pInstance->SetDWORD ( IDS_BorderWidth , CALC_IT ( _ttoi ( sTemp ) ) );
			    }

                if(IsWinNT5() || IsWinNT4())
                {
                    DWORD t_Length ;
				    if ( RegInfo.GetCurrentBinaryKeyValue ( L"IconFont" , NULL , & t_Length ) == ERROR_SUCCESS )
				    {
					    BYTE *t_Buffer = new BYTE [ t_Length ] ;
					    if ( t_Buffer )
					    {
						    try
						    {
							    if ( RegInfo.GetCurrentBinaryKeyValue ( IDS_IconFont , t_Buffer , & t_Length ) == ERROR_SUCCESS )
							    {
								    if ( t_Length == sizeof ( LOGFONTW )  )
								    {
        							    LOGFONTW lfIcon;
									    memcpy ( & lfIcon, t_Buffer , sizeof ( LOGFONTW ) ) ;

									    pInstance->SetWCHARSplat ( IDS_IconTitleFaceName , lfIcon.lfFaceName);

									    HDC hDC = GetDC ( NULL ) ;

									    int nPointSize = - ( MulDiv (lfIcon.lfHeight, 72, GetDeviceCaps ( hDC , LOGPIXELSY ) ) );

									    ReleaseDC ( NULL, hDC ) ;

									    pInstance->SetDWORD ( IDS_IconTitleSize , nPointSize ) ;
								    }
							    }
						    }
						    catch ( ... )
						    {
							    delete [] t_Buffer ;

							    throw ;
						    }

						    delete [] t_Buffer ;
					    }
					    else
					    {
						    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					    }
				    }
                }

                RegInfo.Close();
            }


            // On NT5, these registry entries don't appear until the user
            // changes them.  So, give them a default to be consistent with
            // other NT4 and 351.

            if ( IsWinNT5 () )
            {
                if ( pInstance->IsNull ( IDS_IconTitleFaceName ) )
			    {
                    pInstance->SetCharSplat ( IDS_IconTitleFaceName , _T("MS Shell Dlg") ) ;
			    }

                if ( pInstance->IsNull ( IDS_IconTitleSize ) )
			    {
                    pInstance->SetDWORD ( IDS_IconTitleSize , 8 ) ;
			    }
            }
        }
    }
    catch ( ... )
    {
        if (t_bHiveIsLoaded)
        {
            UserHive.Unload ( strProfile ) ;
            t_bHiveIsLoaded = false;
        }
        throw ;
    }

	// The User's profile gets loaded by the appropriate load function.  However,
	// the profile name is what we should use to unload it.

    UserHive.Unload ( strProfile ) ;
    t_bHiveIsLoaded = false;

    return WinErrorToWBEMhResult ( dwReturn ) ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : GetIconFontSizeFromRegistryValue
 *
 *  DESCRIPTION : A function to look up the above font size mapping table
 *
 *  INPUTS      : The registry value representing the icon font size
 *
 *  RETURNS     : The icon font size corresponding to the value in the registry.
 *				  0 if not found.
 *
 *  COMMENTS    : This is required since there doesnt seem to an obvious mapping
 *				  function between the value in the control panel and the value
 *				  stored in the registry
 *
 *****************************************************************************/

int CWin32Desktop::GetIconFontSizeFromRegistryValue ( BYTE registryValue )
{
	for ( int size = 0; size < MAP_SIZE ; size++ )
	{
		if ( iconFontSizeMap [ size ].byRegistryValue == registryValue )
		{
			return size + 6 ;
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\desktop.h ===
//=================================================================

//

// Desktop.h -- Desktop property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//
//=================================================================

// Property set identification
//============================

#define	PROPSET_NAME_DESKTOP	_T("Win32_Desktop")
#define CALC_IT(x) (x < 0 ? ((x)/(-15)) : x)

class CWin32Desktop : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32Desktop( const CHString& strName, LPCWSTR pszNamespace ) ;
       ~CWin32Desktop() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

	private:
        // Utility function(s)
        //====================
#ifdef NTONLY
		HRESULT EnumerateInstancesNT( MethodContext* pMethodContext ) ;
		HRESULT LoadDesktopValuesNT( LPCWSTR pszUserName, LPCTSTR pszProfile, CInstance* pInstance );
#endif

		// A mapping is required between the icon font size specified in
		// the control panem and the value stored in the registry
		typedef struct 
		{
			int iFontSize;
			BYTE byRegistryValue;
		} IconFontSizeMapElement;

		// The storage for the above map table
		static const IconFontSizeMapElement iconFontSizeMap[];
		static const int MAP_SIZE;

		// A function to look up the above font size mapping table
		static int GetIconFontSizeFromRegistryValue(BYTE registryValue);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\dependentservice.cpp ===
//=================================================================

//

// DependentService.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include <cregcls.h>
#include <FrQueryEx.h>
#include <map>
#include "dependentservice.h"
#include <dllutils.h>

// The Map we will use below is an STL Template, so make sure we have the std namespace
// available to us.

using namespace std;

// Property set declaration
//=========================

CWin32DependentService win32DependentService( PROPSET_NAME_DEPENDENTSERVICE, IDS_CimWin32Namespace );

//////////////////////////////////////////////////////////////////////////////
//
//  dependentservice.cpp - Class implementation of CWin32DependentService.
//
//  This class is intended to locate Win32 System Services that are dependent
//  on other services to run.  It does this by checking the registry key for
//  the service and querying the "DependOnService" value, which will return
//  the names of the services that the service is dependent on.
//
//////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DependentService::CWin32DependentService
 *
 *  DESCRIPTION : Constructor
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DependentService::CWin32DependentService( const CHString& strName, LPCWSTR pszNamespace /*=NULL*/ )
:   Provider( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DependentService::~CWin32DependentService
 *
 *  DESCRIPTION : Destructor
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DependentService::~CWin32DependentService()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32DependentService::ExecQuery
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32DependentService::ExecQuery
(
    MethodContext* pMethodContext,
    CFrameworkQuery& pQuery,
    long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
#ifdef NTONLY
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

    CHStringArray csaDependents, csaAntecedents;
    pQuery.GetValuesForProp(IDS_Dependent, csaDependents);

    DWORD dwDependents = csaDependents.GetSize();
    DWORD dwAntecedents = 0;

    // If we can resolve the query using dependents, that's our best bet.
    if (dwDependents == 0)
    {
        // If not, perhaps we can produce a list of antecedents
        pQuery.GetValuesForProp(IDS_Antecedent, csaAntecedents);
        dwAntecedents = csaAntecedents.GetSize();
    }

    // If we can't find either, perhaps this is a 3TokenOr.  This
    // would happen if someone did an associators or references of a Win32_Service
    if ( (dwDependents == 0) && (dwAntecedents == 0) )
    {
        VARIANT vValue1, vValue2;
        VariantInit(&vValue1);
        VariantInit(&vValue2);

        CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);

        if (pQuery2->Is3TokenOR(IDS_Dependent, IDS_Antecedent, vValue1, vValue2))
        {
            try
            {
                dwDependents = 1;
                dwAntecedents = 1;

                csaAntecedents.Add(vValue1.bstrVal);
                csaDependents.Add(vValue1.bstrVal);
            }
            catch ( ... )
            {
                VariantClear(&vValue1);
                VariantClear(&vValue2);
                throw;
            }

            VariantClear(&vValue1);
            VariantClear(&vValue2);
        }
        else
        {
            // Don't know what they're asking for, but we can't help them with it
            hr = WBEM_E_PROVIDER_NOT_CAPABLE;
        }
    }

    // Did we find anything to do
    if ( (dwDependents > 0) || (dwAntecedents > 0) )
    {
        TRefPointerCollection<CInstance>    serviceList;
        map<CHString, CHString>             servicetopathmap;

        // First we need to get a list of all the Win32 services
        if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"select __path, name from Win32_BaseService", &serviceList, pMethodContext, GetNamespace())))
        {
            // Next, build a map of the services and their associated paths.  This subjects us
            // to the overhead of walking the list once to get the values, but from that point
            // forwards, we basically will have VERY fast access to service object paths via
            // our CHString2CHString map.

            InitServiceToPathMap( serviceList, servicetopathmap );

            LPBYTE pByteArray = NULL;
            DWORD       dwByteArraySize =   0;

            try
            {
                if (dwDependents > 0)
                {
                    map<CHString, CHString>::iterator   servicemapiter;

                    for (DWORD x = 0; x < dwDependents; x++)
                    {
                        ParsedObjectPath    *pParsedPath = NULL;
                        CObjectPathParser    objpathParser;

                        int nStatus = objpathParser.Parse( csaDependents[x],  &pParsedPath );

                        if ( ( 0 == nStatus ) && ( pParsedPath->m_dwNumKeys == 1) )
                        {
                            try
                            {
                                CHString sName(V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue));

                                sName.MakeUpper();

                                if( ( servicemapiter = servicetopathmap.find( sName ) ) != servicetopathmap.end() )
                                {
                                    hr = CreateServiceDependenciesNT( 
                
                                        (*servicemapiter).first, 
                                        (*servicemapiter).second, 
                                        pMethodContext, 
                                        servicetopathmap, 
                                        pByteArray, 
                                        dwByteArraySize 
                                    );
                                }
                            }
                            catch ( ... )
                            {
                                objpathParser.Free( pParsedPath );
                                throw;
                            }

                            objpathParser.Free( pParsedPath );
                        }
                    }
                }

                if (dwAntecedents > 0)
                {
                    hr = CreateServiceAntecedentsNT( 

                        pMethodContext, 
                        servicetopathmap,
                        csaAntecedents,
                        pByteArray, 
                        dwByteArraySize 
                    );
                }
            }
            catch ( ... )
            {
                if (pByteArray != NULL)
                {
                    delete pByteArray;
                    pByteArray = NULL;
                }
                throw;
            }

            if (pByteArray != NULL)
            {
                delete pByteArray;
                pByteArray = NULL;
            }
        }
    }

#endif
    return hr;

}
////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32DependentService::GetObject
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32DependentService::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
    // Find the instance depending on platform id.
#ifdef NTONLY
        return RefreshInstanceNT(pInstance);
#endif
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32DependentService::EnumerateInstances
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32DependentService::EnumerateInstances( MethodContext* pMethodContext, long lFlags /*= 0L*/ )
{
    BOOL        fReturn     =   FALSE;
    HRESULT     hr          =   WBEM_S_NO_ERROR;

    // Get the proper OS dependent instance

#ifdef NTONLY
        hr = AddDynamicInstancesNT( pMethodContext );
#endif
    return hr;

}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32DependentService::AddDynamicInstancesNT
//
//  DESCRIPTION :   Enumerates existing services to get information to
//                  dynamically build a list of associations.
//
//  COMMENTS    :   None.
//
//////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32DependentService::AddDynamicInstancesNT( MethodContext* pMethodContext )
{
    HRESULT     hr              =   WBEM_S_NO_ERROR;

    // Collection, Map and iterator
    TRefPointerCollection<CInstance>    serviceList;
    map<CHString, CHString>             servicetopathmap;

    LPBYTE      pByteArray      =   NULL;
    DWORD       dwByteArraySize =   0;

    try
    {
        // First we need to get a list of all the Win32 services

    //  if (SUCCEEDED(hr = CWbemProviderGlue::GetAllDerivedInstances(_T("Win32_BaseService"), &serviceList, pMethodContext, IDS_CimWin32Namespace)))
        if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(_T("select __path, name from Win32_BaseService"), &serviceList, pMethodContext, GetNamespace())))
        {
            // Next, build a map of the services and their associated paths.  This subjects us
            // to the overhead of walking the list once to get the values, but from that point
            // forwards, we basically will have VERY fast access to service object paths via
            // our CHString2CHString map.

            InitServiceToPathMap( serviceList, servicetopathmap );

            REFPTRCOLLECTION_POSITION   pos;

            if ( serviceList.BeginEnum( pos ) )
            {
                CInstancePtr                pService;
                map<CHString, CHString>::iterator   servicemapiter;
                CHString sName, sPath;

                for (pService.Attach(serviceList.GetNext( pos ));
                     SUCCEEDED(hr) && (pService) != NULL;
                     pService.Attach(serviceList.GetNext( pos )))
                {
                     pService->GetCHString(IDS_Name, sName);
                     pService->GetCHString(IDS___Path, sPath);

                    hr = CreateServiceDependenciesNT( 

                                sName, 
                                sPath, 
                                pMethodContext, 
                                servicetopathmap, 
                                pByteArray, 
                                dwByteArraySize 
                            );
                }   // for all Services

                serviceList.EndEnum();

            }   // IF BeginEnum

        }   // IF GetAllDerivedInstances
    }
    catch ( ... )
    {
        if ( NULL != pByteArray )
        {
            delete [] pByteArray;
            pByteArray = NULL;
        }

        throw;
    }

    // Clean up the byte array we were using.

    if ( NULL != pByteArray )
    {
        delete [] pByteArray;
        pByteArray = NULL;
    }

    return hr;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32DependentService::InitServiceToPathMap
//
//  DESCRIPTION :   Enumerates a service list, creating associations between
//                  service names and their WBEM paths.
//
//  COMMENTS    :   None.
//
//////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
void CWin32DependentService::InitServiceToPathMap(
TRefPointerCollection<CInstance>&   serviceList,
map<CHString,CHString>&         servicetopathmap
)
{
    CHString    strServiceName,
                strServicePathName;

    REFPTRCOLLECTION_POSITION   pos;

    if ( serviceList.BeginEnum( pos ) )
    {
        CInstancePtr                pService;

        for ( pService.Attach(serviceList.GetNext( pos )) ;
              pService != NULL;
              pService.Attach(serviceList.GetNext( pos )))
        {
            if (    pService->GetCHString( IDS_Name, strServiceName )
                &&  GetLocalInstancePath( pService, strServicePathName ) )
            {
                // The service name must be case insensitive
                strServiceName.MakeUpper();

                servicetopathmap[strServiceName] = strServicePathName;
            }
        }

        serviceList.EndEnum();
    }

}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32DependentService::CreateServiceDependenciesNT
//
//  DESCRIPTION :   Given a service name, looks in the registry for a
//                  dependency list and if found, creates associations
//                  for all entries in the list.
//
//  COMMENTS    :   None.
//
//////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32DependentService::CreateServiceDependenciesNT(

LPCWSTR pwszServiceName,
LPCWSTR pwszServicePath,
MethodContext*          pMethodContext,
map<CHString,CHString>& servicetopathmap,
LPBYTE&                 pByteArray,
DWORD&                  dwArraySize
)
{
    HRESULT     hr          =   WBEM_S_NO_ERROR;

    map<CHString, CHString>::iterator   servicemapiter;

    // If we get a value from the registry, then we have some dependencies that we
    // will have to deal with (probably via a 12-step program or some such thing.
    // Remember, addiction is no laughing matter.  Giggling maybe, but definitely
    // not laughing).

    if ( QueryNTServiceRegKeyValue( pwszServiceName, SERVICE_DEPENDSONSVC_NAME, pByteArray, dwArraySize ) )
    {
        CHString    strAntecedentServiceName;

        LPWSTR  pwcTempSvcName = (LPWSTR) pByteArray;
        CInstancePtr pInstance;

        // Create dependencies for each service name we encounter.

        while (     L'\0' != *pwcTempSvcName
                &&  SUCCEEDED(hr) )
        {

            // Convert to upper case for Case Insensitivity.
            strAntecedentServiceName = pwcTempSvcName;
            strAntecedentServiceName.MakeUpper();

            // See if the service name exists in our map

            if( ( servicemapiter = servicetopathmap.find( strAntecedentServiceName ) ) != servicetopathmap.end() )
            {
                pInstance.Attach(CreateNewInstance( pMethodContext ));

                pInstance->SetCHString( IDS_Dependent, pwszServicePath );
                pInstance->SetCHString( IDS_Antecedent, (*servicemapiter).second );

                hr = pInstance->Commit(  );

            }

            // Jump to one char past the string NULL terminator, since
            // the actual array is terminated by a Double NULL.

            pwcTempSvcName += ( lstrlenW( pwcTempSvcName ) + 1 );

        }   // WHILE NULL !- *pszTempSvcName

    }   // IF QueryNTServiceRegKeyValue

    return hr;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32DependentService::RefreshInstanceNT
//
//  DESCRIPTION :   Loads the paths of the association data, then obtains
//                  the service names and looks in the registry to verify
//                  that the dependency still exists.
//
//  COMMENTS    :   None.
//
//////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32DependentService::RefreshInstanceNT( CInstance* pInstance )
{
    CHString        strDependentSvcPath,
                    strAntecedentSvcPath,
                    strDependentSvcName,
                    strAntecedentSvcName,
                    strTemp;
    LPBYTE      pByteArray = NULL;
    DWORD           dwByteArraySize = 0;
    CInstancePtr    pDependentSvc;
    CInstancePtr    pAntecedentSvc;
    HRESULT     hr;

    // Dependent and Antecedent values are actually object path names
    pInstance->GetCHString( IDS_Dependent, strDependentSvcPath );
    pInstance->GetCHString( IDS_Antecedent, strAntecedentSvcPath );

    // Get the Antecedent and dependent services, then check if the relationship
    // still exists

    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(strDependentSvcPath,
        &pDependentSvc, pInstance->GetMethodContext())) &&
        SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(strAntecedentSvcPath,
        &pAntecedentSvc, pInstance->GetMethodContext())))
    {
        hr = WBEM_E_NOT_FOUND;

        if (    pDependentSvc->GetCHString( IDS_Name, strDependentSvcName )
            &&  pAntecedentSvc->GetCHString( IDS_Name, strAntecedentSvcName ) )
        {

            // If we get a value from the registry, then we have some dependencies we can
            // search for a match against the antecedent service name.

            if ( QueryNTServiceRegKeyValue( strDependentSvcName, SERVICE_DEPENDSONSVC_NAME, pByteArray, dwByteArraySize ) )
            {
                try
                {
                    LPWSTR  pwcTempSvcName  =   (LPWSTR) pByteArray;

                    // Create dependencies for each service name we encounter.

                    while (FAILED(hr) && L'\0' != *pwcTempSvcName)
                    {
                        strTemp = pwcTempSvcName;

                        // If we have a match, we should reset the Dependent and Antecedent paths,
                        // and return TRUE.  We are done, though, at that point since we have
                        // effectively established that the relationship exists.

                        if ( strAntecedentSvcName.CompareNoCase( strTemp ) == 0 )
                        {
                            pInstance->SetCHString( IDS_Antecedent, strAntecedentSvcPath );
                            pInstance->SetCHString( IDS_Dependent, strDependentSvcPath );
                            hr = WBEM_S_NO_ERROR;
                        }
                        else
                        {
                            // Jump to one char past the string NULL terminator, since
                            // the actual array is terminated by a Double NULL.
                            pwcTempSvcName += ( lstrlenW( pwcTempSvcName ) + 1 );
                        }

                    }   // WHILE !fReturn && NULL != *pszTempSvcName
                }
                catch ( ... )
                {
                    delete [] pByteArray;
                    throw ;
                }

                delete [] pByteArray;

            }   // IF QueryNTServiceRegKeyValue

        }   // IF got both service names

    }   // IF got service

    return hr;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32DependentService::QueryNTServiceRegKeyValue
//
//  DESCRIPTION :   Loads data from the registry and places the data in a
//                  supplied buffer.  The buffer will be grown if necessary.
//
//  COMMENTS    :   The byte array will be reallocated if necessary.  It is up to
//                  the calling function to delete the array when it is done.
//
//////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
BOOL CWin32DependentService::QueryNTServiceRegKeyValue( LPCTSTR pszServiceName, LPCWSTR pwcValueName, LPBYTE& pByteArray, DWORD& dwArraySize )
{
    BOOL        fReturn             =   FALSE;
    DWORD       dwSizeDataReturned  =   0;
    CRegistry   reg;
    CHString    strDependentServiceRegKey;

    // Build the key name for the service, then open the registry
    strDependentServiceRegKey.Format( SERVICE_REG_KEY_FMAT, pszServiceName );

    if ( ERROR_SUCCESS == reg.Open( HKEY_LOCAL_MACHINE, strDependentServiceRegKey, KEY_READ ) )
    {

        // Query the value to see how big our array needs to be.
		DWORD dwRegType = REG_MULTI_SZ;

        if ( ERROR_SUCCESS == RegQueryValueExW( reg.GethKey(),
                                                pwcValueName,
                                                NULL,
                                                &dwRegType,
                                                NULL,
                                                &dwSizeDataReturned ) )
        {

			// Make sure we won't run out of buffer (this is just workaround if service setup is wrong)
			if ( dwRegType != REG_MULTI_SZ )
			{
				dwSizeDataReturned += sizeof (WCHAR);
			}

            // Make sure our Byte array buffer is big enough to handle this
            if ( ReallocByteArray( pByteArray, dwArraySize, dwSizeDataReturned ) )
            {
				// Make sure it is NULL terminated (this is just workaround if service setup is wrong)
				if ( dwRegType != REG_MULTI_SZ )
				{
					for ( int iIndex = 0; iIndex < dwSizeDataReturned; iIndex++ )
					{
						pByteArray [ iIndex ] = 0;
					}
				}

                // Now we REALLY query the value.

                if ( ERROR_SUCCESS == RegQueryValueExW( reg.GethKey(),
                                                        pwcValueName,
                                                        NULL,
                                                        NULL,
                                                        pByteArray,
                                                        &dwSizeDataReturned ) )
                {
                    fReturn = TRUE;
                }   // IF RegQueryValueEx

            }   // IF Realloc Array

        }   // IF RegQueryValueEx

        reg.Close();

    }   // IF Open Reg Key

    return fReturn;
}
#endif


//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32DependentService::ReallocByteArray
//
//  DESCRIPTION :   Ensures that the supplied array size is >= the required
//                  size.  If it is smaller, it is deleted and a new array
//                  returned.
//
//  COMMENTS    :   The byte array will only be reallocated if necessary.  It
//                  is up to the calling function to delete the array when it
//                  is done.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CWin32DependentService::ReallocByteArray( LPBYTE& pByteArray, DWORD& dwArraySize, DWORD dwSizeRequired )
{
    BOOL    fReturn = FALSE;

    // Check if we need to realloc the array.  If not, we can
    // go ahead and return TRUE

    if ( dwSizeRequired > dwArraySize )
    {

        LPBYTE  pbArray =   new BYTE[dwSizeRequired];

        if ( NULL != pbArray )
        {

            // Free the old array before storing the new value
            if ( NULL != pByteArray )
            {
                delete [] pByteArray;
            }

            pByteArray = pbArray;
            dwArraySize = dwSizeRequired;
            fReturn = TRUE;

        }   // If NULL != pbArray
        else
        {
            if ( NULL != pByteArray )
            {
                delete [] pByteArray;
            }

            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

    }   // If array not big enough
    else
    {
        fReturn = TRUE;
    }

    return fReturn;

}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32DependentService::CreateServiceAntecedentsNT
//
//  DESCRIPTION :   Given an array of service names, looks in the registry for
//                  services that have that dependency.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CWin32DependentService::CreateServiceAntecedentsNT(

    MethodContext*          pMethodContext,
    map<CHString, CHString> &servicetopathmap,
    CHStringArray           &csaAntecedents,
    LPBYTE&                 pByteArray,
    DWORD&                  dwArraySize
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // First, parse out the service names from the object paths
    for (DWORD x=0; x < csaAntecedents.GetSize(); x++)
    {
        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;

        int nStatus = objpathParser.Parse( csaAntecedents[x],  &pParsedPath );

        if ( ( 0 == nStatus ) && ( pParsedPath->m_dwNumKeys == 1) )
        {
            try
            {
                csaAntecedents[x] = V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue);

                csaAntecedents[x].MakeUpper();
            }
            catch ( ... )
            {
                objpathParser.Free( pParsedPath );
                throw;
            }

            objpathParser.Free( pParsedPath );
        }
    }

    map<CHString, CHString>::iterator   servicemapiter, servicemapfind;

    // Now, walk each service, and see if any of its dependencies are in csaAntecedents
    servicemapiter = servicetopathmap.begin();

    CHString    strAntecedentServiceName;

    CInstancePtr pInstance;

    while ( servicemapiter != servicetopathmap.end() && SUCCEEDED(hr) )
    {
        // Get the dependencies
        if ( QueryNTServiceRegKeyValue( (*servicemapiter).first, SERVICE_DEPENDSONSVC_NAME, pByteArray, dwArraySize ) )
        {

            LPWSTR  pwcTempSvcName = (LPWSTR) pByteArray;

            // Walk the dependencies
            while (     L'\0' != *pwcTempSvcName
                    &&  SUCCEEDED(hr) )
            {
                // Convert to upper case for Case Insensitivity.
                strAntecedentServiceName = pwcTempSvcName;
                strAntecedentServiceName.MakeUpper();

                // See if the service name exists in our list
                if (IsInList(csaAntecedents, strAntecedentServiceName) != -1)
                {
                    pInstance.Attach(CreateNewInstance( pMethodContext ));

                    if( ( servicemapfind = servicetopathmap.find( strAntecedentServiceName ) ) != servicetopathmap.end() )
                    {
                        pInstance->SetCHString( IDS_Antecedent, (*servicemapfind).second );
                        pInstance->SetCHString( IDS_Dependent, (*servicemapiter).second );

                        hr = pInstance->Commit(  );
                    }
                }

                // Jump to one char past the string NULL terminator, since
                // the actual array is terminated by a Double NULL.

                pwcTempSvcName += ( lstrlenW( pwcTempSvcName ) + 1 );

            }   // WHILE NULL !- *pszTempSvcName

        }   // IF QueryNTServiceRegKeyValue

        servicemapiter++;
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : IsInList
 *
 *  DESCRIPTION : Checks to see if a specified element is in the list
 *
 *  INPUTS      : Array to scan, and element
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : -1 if not in list, else zero based element number
 *
 *  COMMENTS    : This routine does a CASE SENSITIVE compare
 *
 *****************************************************************************/
DWORD CWin32DependentService::IsInList(
                                
    const CHStringArray &csaArray, 
    LPCWSTR pwszValue
)
{
    DWORD dwSize = csaArray.GetSize();

    for (DWORD x=0; x < dwSize; x++)
    {
        // Note this is a CASE SENSITIVE compare
        if (wcscmp(csaArray[x], pwszValue) == 0)
        {
            return x;
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\desktopmonitor.cpp ===
//=================================================================

//

// DesktopMonitor.CPP -- CodecFile property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/27/98    sotteson         Created
//
//=================================================================

#include "precomp.h"
#include "sid.h"
#include "implogonuser.h"
#include "DesktopMonitor.h"
#include <multimon.h>
#include "multimonitor.h"
#include "resource.h"

// Property set declaration
//=========================

CWin32DesktopMonitor startupCommand(L"Win32_DesktopMonitor", IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DesktopMonitor::CWin32DesktopMonitor
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DesktopMonitor::CWin32DesktopMonitor(
	LPCWSTR szName,
	LPCWSTR szNamespace) :
    Provider(szName, szNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DesktopMonitor::~CWin32DesktopMonitor
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DesktopMonitor::~CWin32DesktopMonitor()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DesktopMonitor::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DesktopMonitor::EnumerateInstances(
	MethodContext *pMethodContext,
	long lFlags)
{
    HRESULT       hres = WBEM_S_NO_ERROR;
	CMultiMonitor monitor;

    for (int i = 0; i < monitor.GetNumAdapters() && SUCCEEDED(hres); i++)
    {
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
	    // Set the device ID.
		CHString strDeviceID;
		CHString strDeviceName;

		strDeviceID.Format(L"DesktopMonitor%d", i + 1);

	    pInstance->SetCharSplat(L"DeviceID", strDeviceID);

		hres = SetProperties(pInstance, & monitor, i);

        // If we found one, commit.
        if (SUCCEEDED(hres))
    		hres = pInstance->Commit();
        // It's possible the adapter is enabled but the montior isn't.  In
        // this case, just keep enuming.
        else if (hres == WBEM_E_NOT_FOUND)
            hres = WBEM_S_NO_ERROR;
    }

    return hres;
}

HRESULT CWin32DesktopMonitor::SetProperties(
	CInstance *pInstance,
	CMultiMonitor *pMon,
	int iWhich)
{
    // Set the config mgr properties.
    CHString            strDescription,
                        strTemp,
                        strDriver;
	CConfigMgrDevicePtr pDeviceMonitor;
    HRESULT             hres = WBEM_S_NO_ERROR;

    if (pMon->GetMonitorDevice(iWhich, pDeviceMonitor))
	{
		pDeviceMonitor->GetDeviceDesc(strDescription);

		if (pDeviceMonitor->GetMfg(strTemp))
		{
			pInstance->SetCHString(IDS_MonitorManufacturer, strTemp);
		}

	    if (pDeviceMonitor->GetStatus(strTemp))
	    {
		    pInstance->SetCHString(IDS_Status, strTemp);
	    }

        SetConfigMgrProperties(pDeviceMonitor, pInstance);

        hres = WBEM_S_NO_ERROR;
    }
    else
	{
        // Sometimes cfg mgr doesn't come up with an instance for
        // the monitor.  So if we don't find it, fill in the name
        // ourselves.
        LoadStringW(strDescription, IDR_DefaultMonitor);

	    // Assume this monitor is working.
        pInstance->SetCharSplat(IDS_Status, L"OK");
	}

    pInstance->SetCHString(IDS_Description, strDescription);
    pInstance->SetCHString(IDS_Caption, strDescription);
    pInstance->SetCHString(IDS_Name, strDescription);
    pInstance->SetCHString(L"MonitorType", strDescription);
    SetCreationClassName(pInstance);

    // Set the system name.

    pInstance->SetCharSplat(IDS_SystemName, GetLocalComputerName());
    pInstance->SetWCHARSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");

    // Set the properties that require a DC.

    CHString strDeviceName;

    pMon->GetAdapterDisplayName(iWhich, strDeviceName);

    SetDCProperties(pInstance, strDeviceName);

    return hres;
}

HRESULT CWin32DesktopMonitor::GetObject(
	CInstance *pInstance,
	long lFlags)
{
	HRESULT	 hres = WBEM_E_NOT_FOUND;
	CHString strDeviceID;
    DWORD    dwWhich;

    pInstance->GetCHString(L"DeviceID", strDeviceID);

    if (ValidateNumberedDeviceID(strDeviceID, L"DESKTOPMONITOR", &dwWhich))
    {
        CMultiMonitor monitor;

        if (dwWhich >= 1 && dwWhich <= monitor.GetNumAdapters())
        {
            hres = SetProperties(pInstance, &monitor, dwWhich - 1);
        }
    }

	return hres;
}

void CWin32DesktopMonitor::SetDCProperties(
	CInstance *pInstance,
    LPCWSTR szDeviceName
)
{
	CSmartCreatedDC hdc(CreateDC(
            			   TOBSTRT(szDeviceName),
			               NULL,
			               NULL,
			               NULL));

	if (hdc)
	{
        pInstance->SetDWORD(IDS_Availability, 3); // 3 == Running
		pInstance->SetDWORD(L"PixelsPerXLogicalInch", GetDeviceCaps(hdc, LOGPIXELSX));
	    pInstance->SetDWORD(L"PixelsPerYLogicalInch", GetDeviceCaps(hdc, LOGPIXELSY));
		pInstance->SetDWORD(L"ScreenWidth", GetDeviceCaps(hdc, HORZRES));
		pInstance->SetDWORD(L"ScreenHeight", GetDeviceCaps(hdc, VERTRES));
	}
    else
    {
		// Assume this is because the device is not in use.  Set Availability
        // to 8 (off line).
        pInstance->SetDWORD(IDS_Availability, 8);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\desktopmonitor.h ===
//=================================================================

//

// DesktopMonitor.h -- CWin32DesktopMonitor property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/05/98    sotteson         Created
//
//=================================================================
#ifndef _DESKTOPMONITOR_H
#define _DESKTOPMONITOR_H

class CMultiMonitor;

class CWin32DesktopMonitor : public Provider
{
public:
	// Constructor/destructor
	//=======================
	CWin32DesktopMonitor(LPCWSTR szName, LPCWSTR szNamespace);
	~CWin32DesktopMonitor();

	virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, 
		long lFlags = 0);
	virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0);

protected:
    HRESULT SetProperties(CInstance *pInstance, CMultiMonitor *pMon, int iWhich);
    void SetDCProperties(CInstance *pInstance, LPCWSTR szDeviceName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\devbattery.cpp ===
//=================================================================

//

// DevBattery.CPP -- LoadOrderGroup to Service association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    4/21/98    davwoh         Created
//
//
//=================================================================

#include "precomp.h"

#include "devBattery.h"

// Property set declaration
//=========================

CAssociatedBattery MyBattery(PROPSET_NAME_ASSOCBATTERY, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CAssociatedBattery::CAssociatedBattery
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CAssociatedBattery::CAssociatedBattery(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CAssociatedBattery::~CAssociatedBattery
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CAssociatedBattery::~CAssociatedBattery()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CAssociatedBattery::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CAssociatedBattery::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
   CHString sBattery, sUPS;
   HRESULT hr = WBEM_E_NOT_FOUND;

   // Get the two paths
   pInstance->GetCHString(IDS_Antecedent, sBattery);
   pInstance->GetCHString(IDS_Dependent, sUPS);

   hr = IsItThere(pInstance);
   if (SUCCEEDED(hr)) {
      CHString sBattery2, sUPS2;

      pInstance->GetCHString(IDS_Antecedent, sBattery2);
      pInstance->GetCHString(IDS_Dependent, sUPS2);

      if ((sUPS.CompareNoCase(sUPS2) != 0) || (sBattery.CompareNoCase(sBattery2) != 0)) {
         hr = WBEM_E_NOT_FOUND;
      }
   }

   return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : CAssociatedBattery::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CAssociatedBattery::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr;

    CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
    if (pInstance)
    {
        hr = IsItThere(pInstance);
        if (SUCCEEDED(hr))
        {
            hr = pInstance->Commit();
        }
        else
        {
            if (hr == WBEM_E_NOT_FOUND)
            {
                hr = WBEM_S_NO_ERROR;
            }
        }
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CAssociatedBattery::IsItThere(CInstance *pInstance)
{

   CHString sBatPath, sUPSPath, sTemp1, sTemp2;
   CInstancePtr pUPS;
   CInstancePtr pBattery;
   HRESULT hr = WBEM_E_NOT_FOUND;

   // Get list of Services
   //=====================
   sTemp1.Format(L"\\\\%s\\%s:Win32_UninterruptiblePowerSupply.DeviceID=\"%s\"", GetLocalComputerName(), IDS_CimWin32Namespace, IDS_UPSName);
   sTemp2.Format(L"\\\\%s\\%s:Win32_Battery.DeviceID=\"%s\"", GetLocalComputerName(), IDS_CimWin32Namespace, IDS_UPSBatteryName);

   if (SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(sTemp1, &pUPS, pInstance->GetMethodContext())))   {
      if (SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(sTemp2, &pBattery, pInstance->GetMethodContext()))) {

         GetLocalInstancePath(pUPS, sUPSPath);
         GetLocalInstancePath(pBattery, sBatPath);

         // Do the puts, and that's it
         pInstance->SetCHString(IDS_Dependent, sUPSPath);
         pInstance->SetCHString(IDS_Antecedent, sBatPath);

         hr = WBEM_S_NO_ERROR;
      }
   }

   return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\devbus.cpp ===
//=================================================================

//

// devbus.h -- cim_logicaldevice to win32_bus

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/23/98    davwoh         Created
//
// Comment: Relationship between device and bus
//
//=================================================================

#include "precomp.h"
#include "PNPEntity.h"
#include "LPVParams.h"

#include "devbus.h"

// Property set declaration
//=========================

CWin32DeviceBus MyDevBus(PROPSET_NAME_DEVICEBUS, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceBus::CWin32DeviceBus
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DeviceBus::CWin32DeviceBus(LPCWSTR setName, LPCWSTR pszNamespace)
: CWin32PNPEntity(setName, pszNamespace),
  Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceBus::~CWin32DeviceBus
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DeviceBus::~CWin32DeviceBus()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceBus::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DeviceBus::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CHString chstrBus, chstrBusID, chstrDevice, chstrDeviceID, chstrTemp, chstrPNPDeviceID;
    HRESULT hRet = WBEM_E_NOT_FOUND;
    CInstancePtr pBus;
    CConfigManager	cfgManager;
    INTERFACE_TYPE itBusType = InterfaceTypeUndefined;
    DWORD dwBusNumber = 0;

    // Get the two paths
    pInstance->GetCHString(IDS_Antecedent, chstrBus);
    pInstance->GetCHString(IDS_Dependent, chstrDevice);

    // If both ends are there
    // No easy way to circumvent call through CIMOM for the bus, without multipally inherriting this class from CWin32Bus also.
    if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrBus, &pBus, pInstance->GetMethodContext())))
    {
        // Bus exists.  Now check if device instance exists (object name valid and device actually exists)
        if(ObjNameValid(chstrDevice,L"Win32_PnPEntity", IDS_DeviceID,chstrPNPDeviceID) && (DeviceExists(chstrPNPDeviceID, &dwBusNumber, &itBusType)))
        {
            // Get the id (to send to cfgmgr)
            pBus->GetCHString(IDS_DeviceID, chstrBusID);
            chstrTemp.Format(L"%s_BUS_%u", szBusType[itBusType], dwBusNumber);
            if (chstrBusID.CompareNoCase(chstrTemp) == 0)
            {
                hRet = WBEM_S_NO_ERROR;
            }
        }
    }

    return hRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceBus::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DeviceBus::LoadPropertyValues(void* pvData)
{
    CHString chstrDeviceID, chstrDevicePath, chstrTemp;
    HRESULT hr = WBEM_S_NO_ERROR;
    INTERFACE_TYPE itBusType = InterfaceTypeUndefined;
    DWORD dwBusNumber = 0;

    CLPVParams* pParams = (CLPVParams*)pvData;
    CInstance* pInstance = (CInstance*)(pParams->m_pInstance); // This instance released by caller
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)(pParams->m_pDevice);

    if(pDevice == NULL || pInstance == NULL) return hr;
    MethodContext* pMethodContext = pInstance->GetMethodContext();
    if(pMethodContext == NULL) return hr;

    // Get the id (to send to cfgmgr) and the path (to send back in 'Dependent')
    pDevice->GetDeviceID(chstrDeviceID);
    CHString chstrDeviceIDAdj;
    EscapeBackslashes(chstrDeviceID, chstrDeviceIDAdj);
    chstrDevicePath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                           (LPCWSTR)GetLocalComputerName(),
                           IDS_CimWin32Namespace,
                           PROPSET_NAME_PNPEntity,
                           IDS_DeviceID,
                           (LPCWSTR)chstrDeviceIDAdj);

    if(DeviceExists(chstrDeviceID, &dwBusNumber, &itBusType))
    {
        {
            CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
            chstrTemp.Format(L"\\\\%s\\%s:%s.%s=\"%s_BUS_%u\"",
                            (LPCWSTR)GetLocalComputerName(), IDS_CimWin32Namespace,
                            L"Win32_Bus", IDS_DeviceID, szBusType[itBusType], dwBusNumber);

            pInstance->SetCHString(IDS_Antecedent, chstrTemp);
            pInstance->SetCHString(IDS_Dependent, chstrDevicePath);

            hr = pInstance->Commit();
        }
    }

   return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : ObjNameValid
 *
 *  DESCRIPTION : Internal helper to check if the given object exists.
 *
 *  INPUTS      : chstrObject - name of prospecitive object.
 *
 *  OUTPUTS     : chstrPATH, the path of the provided object
 *
 *  RETURNS     : true if it exists; false otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CWin32DeviceBus::ObjNameValid(LPCWSTR wstrObject, LPCWSTR wstrObjName, LPCWSTR wstrKeyName, CHString& chstrPATH)
{
    bool fRet = false;

    ParsedObjectPath*    pParsedPath = 0;
    CObjectPathParser    objpathParser;

    // Parse the object path passed to us by CIMOM
    // ==========================================
    int nStatus = objpathParser.Parse( wstrObject,  &pParsedPath );

    // One of the biggest if statements I've ever written.
    if ( 0 == nStatus )                                                     // Did the parse succeed?
    {
        try
        {
            if ((pParsedPath->IsInstance()) &&                                      // Is the parsed object an instance?
                (_wcsicmp(pParsedPath->m_pClass, wstrObjName) == 0) &&              // Is this the class we expect (no, cimom didn't check)
                (pParsedPath->m_dwNumKeys == 1) &&                                  // Does it have exactly one key
                (pParsedPath->m_paKeys[0]) &&                                       // Is the keys pointer null (shouldn't happen)
                ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||                     // Key name not specified or
                (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, wstrKeyName) == 0)) &&  // key name is the right value
                                                                                // (no, cimom doesn't do this for us).
                (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == VT_BSTR) &&           // Check the variant type (no, cimom doesn't check this either)
                (V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue) != NULL) )             // And is there a value in it?
            {
                chstrPATH = V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue);
            }
        }
        catch ( ... )
        {
            objpathParser.Free( pParsedPath );
            throw ;
        }

        // Clean up the Parsed Path
        objpathParser.Free( pParsedPath );
        fRet = true;
    }

    return fRet;
}


/*****************************************************************************
 *
 *  FUNCTION    : DeviceExists
 *
 *  DESCRIPTION : Internal helper to check if the given device exists.
 *
 *  INPUTS      : chstrDevice - name of prospecitive device.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : true if it exists; false otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CWin32DeviceBus::DeviceExists(const CHString& chstrDevice, DWORD* pdwBusNumber, INTERFACE_TYPE* pitBusType)
{
    bool fRet = false;
    CConfigManager cfgmgr;
    CConfigMgrDevicePtr pDevice(NULL);

    if(cfgmgr.LocateDevice(chstrDevice, pDevice))
    {
        if(pDevice->GetBusInfo(pitBusType, pdwBusNumber))
        {
            fRet = true;
        }
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\devbus.h ===
//=================================================================

//

// devbus.h -- cim_logicaldevice to win32_bus

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/23/98    davwoh         Created
//
// Comment: Relationship between device and bus
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_DEVICEBUS L"Win32_DeviceBus"

class CWin32DeviceBus ;

class CWin32DeviceBus: virtual public CWin32PNPEntity 
{
    public:

        // Constructor/destructor
        //=======================

       CWin32DeviceBus(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32DeviceBus() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery);

    protected:

        // Functions inherrited from CWin32PNPDevice:
        virtual HRESULT LoadPropertyValues(void* pv);
        virtual bool ShouldBaseCommit(void* pvData);

    private:

        bool ObjNameValid(LPCWSTR wstrObject, LPCWSTR wstrObjName, LPCWSTR wstrKeyName, CHString& chstrPATH);
        bool DeviceExists(const CHString& chstrDevice, DWORD* pdwBusNumber, INTERFACE_TYPE* itBusType);

} ;

// This derived class commits here, not in the base.
inline bool CWin32DeviceBus::ShouldBaseCommit(void* pvData) { return false; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\devbattery.h ===
//=================================================================

//

// DevBattery.h -- LogicalDevice to Battery

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    4/21/98    davwoh         Created
//
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_ASSOCBATTERY L"Win32_AssociatedBattery"

class CAssociatedBattery:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CAssociatedBattery(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CAssociatedBattery() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

    private:
        HRESULT CAssociatedBattery::IsItThere(CInstance *pInstance);

        // Utility function(s)
        //====================

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\devicememory.cpp ===
//=================================================================

//

// DevMem.CPP --DevMem property set provider(Windows NT only)

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//
//=================================================================

#include "precomp.h"

#include <CRegCls.h>
#include "cHWRes.h"

#include "DeviceMemory.h"
#include "ntdevtosvcsearch.h"

#include <tchar.h>

// Property set declaration
//=========================

DevMem MyDevMemSet(PROPSET_NAME_DEVMEM, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : DevMem::DevMem
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : bae class Registers property set with framework
 *
 *****************************************************************************/

DevMem::DevMem(

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : DevMem::~DevMem
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

DevMem::~DevMem()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : DevMem::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT DevMem::GetObject(

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hRetCode =  WBEM_E_NOT_FOUND;

    // This only has meaning for NT
    //=============================

#if (NTONLY == 4)

	CHWResource HardwareResource;

	LPRESOURCE_DESCRIPTOR pResourceDescriptor;

	// Create hardware resource list
	//==============================

	HardwareResource.CreateSystemResourceLists();

	// Find the starting address
	//==========================

	__int64 i64StartingAddress = 0;
	pInstance->GetWBEMINT64(IDS_StartingAddress, i64StartingAddress);

	pResourceDescriptor = HardwareResource._SystemResourceList.MemoryHead;
	while(pResourceDescriptor != NULL)
	{
        LARGE_INTEGER liTemp;   // Used to avoid 64bit alignment problems

        liTemp.HighPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.HighPart;
        liTemp.LowPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.LowPart;

		if (liTemp.QuadPart == i64StartingAddress)
		{
			LoadPropertyValues(pInstance, pResourceDescriptor);
			hRetCode = WBEM_S_NO_ERROR;

			break;
		}

		pResourceDescriptor = pResourceDescriptor->NextSame;
	}

#endif

	__int64 i64StartingAddress = 0;
	pInstance->GetWBEMINT64(IDS_StartingAddress, i64StartingAddress);

	CConfigManager CMgr(ResType_Mem);

    //=================================================================
    // Get the latest IO info from the Configuration Manager
    //=================================================================

    if (CMgr.RefreshList())
	{
        for (int i = 0; i < CMgr.GetTotal(); i++)
		{
            //=========================================================
            //  Get the instance to process
            //=========================================================
			MEM_INFO *pMemory = CMgr.GetMem(i);

			if (i64StartingAddress == pMemory->StartingAddress)
			{
                LoadPropertyValues(
                    pInstance,
                    pMemory->StartingAddress,
                    pMemory->EndingAddress);

#if (NTONLY >= 5)
                if (!pMemory->MemoryType.IsEmpty())
                {
                    pInstance->SetCHString(IDS_MemoryType, pMemory->MemoryType);
                }
#endif

				hRetCode = WBEM_S_NO_ERROR;

				break;
			}

		}


	}


    return hRetCode;
}

/*****************************************************************************
 *
 *  FUNCTION    : DevMem::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each installed client
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT DevMem::EnumerateInstances(

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	// This only has meaning for NT
	//=============================

#if (NTONLY == 4)

	CHWResource HardwareResource;
	LPRESOURCE_DESCRIPTOR pResourceDescriptor;

	// Create hardware resource list
	//==============================

	HardwareResource.CreateSystemResourceLists();

	// Traverse list & create instance for each device's memory
	//=========================================================

	pResourceDescriptor = HardwareResource._SystemResourceList.MemoryHead;
	if (pResourceDescriptor == NULL)
	{
		hr = WBEM_E_FAILED;
	}

	typedef std::map<__int64, bool> Type64bitLookup;

	Type64bitLookup t_Lookup;

	int n = 0;

	BOOL bFound = FALSE;

	while(pResourceDescriptor != NULL && SUCCEEDED(hr))
	{
		CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
		hr = LoadPropertyValues(pInstance, pResourceDescriptor);
		if (SUCCEEDED(hr))
		{
			__int64 i64StartingAddress = 0;
			pInstance->GetWBEMINT64(IDS_StartingAddress, i64StartingAddress);

			if (!t_Lookup [ i64StartingAddress ])
			{
				t_Lookup [ i64StartingAddress ] = true;
				hr = pInstance->Commit();
			}
			else
			{
                // duplicate memory address
			}
		}

		pResourceDescriptor = pResourceDescriptor->NextSame;
	}

#endif


    typedef std::map<DWORD_PTR, DWORD> DWORDPTR_2_DWORD;

	CConfigManager CMgr(ResType_Mem);

    //=================================================================
    // Get the latest IO info from the Configuration Manager
    //=================================================================
    if (CMgr.RefreshList())
	{
        DWORDPTR_2_DWORD mapAddrs;

        for (int i = 0; i < CMgr.GetTotal() && SUCCEEDED(hr); i ++)
		{
            //=========================================================
            //  Get the instance to process
            //=========================================================

			MEM_INFO *pMemory = CMgr.GetMem(i);

            // If it's already in the map, skip it.
            if (mapAddrs.find(pMemory->StartingAddress) != mapAddrs.end())
                continue;

            // It wasn't in the map.
            // Set it so we don't try this port again.
		    mapAddrs[pMemory->StartingAddress] = 0;

			CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

			hr =
                LoadPropertyValues(
                    pInstance,
                    pMemory->StartingAddress,
                    pMemory->EndingAddress);

#if (NTONLY >= 5)
                if (!pMemory->MemoryType.IsEmpty())
                {
                    pInstance->SetCHString(IDS_MemoryType, pMemory->MemoryType);
                }
#endif

			if (SUCCEEDED(hr))
			{
				hr = pInstance->Commit();
			}

		}


	}

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : DevMem::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties according to passed struct
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#if (NTONLY == 4)

HRESULT DevMem::LoadPropertyValues(

	CInstance *pInstance,
	LPRESOURCE_DESCRIPTOR pResourceDescriptor
)
{
    pInstance->SetCharSplat(IDS_Status, IDS_OK);

    LARGE_INTEGER liTemp;   // Used to avoid 64bit alignment problems

    liTemp.HighPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.HighPart;
    liTemp.LowPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.LowPart;

    pInstance->SetWBEMINT64(

		IDS_StartingAddress,
		liTemp.QuadPart
	);

    pInstance->SetWBEMINT64(

		IDS_EndingAddress,
		liTemp.QuadPart +(__int64)pResourceDescriptor->CmResourceDescriptor.u.Port.Length -(__int64)1
	);

    WCHAR szTemp [ _MAX_PATH ];

    swprintf(

		szTemp,
		IDS_RegAddressRange,
		liTemp.QuadPart,
		liTemp.QuadPart + pResourceDescriptor->CmResourceDescriptor.u.Port.Length - 1
	);

    pInstance->SetCharSplat(IDS_Caption, szTemp);

    pInstance->SetCharSplat(IDS_Name, szTemp);

    pInstance->SetCharSplat(IDS_Description, szTemp);

    SetCreationClassName(pInstance);

    pInstance->SetCHString(IDS_CSName, GetLocalComputerName());

    pInstance->SetCHString(IDS_CSCreationClassName, L"Win32_ComputerSystem");

    switch(pResourceDescriptor->CmResourceDescriptor.Flags)
	{
        case CM_RESOURCE_MEMORY_READ_WRITE :
		{
			pInstance->SetCharSplat(IDS_MemoryType, IDS_MTReadWrite);
		}
		break;

        case CM_RESOURCE_MEMORY_READ_ONLY:
		{
			pInstance->SetCharSplat(IDS_MemoryType, IDS_MTReadOnly);
		}
		break;

        case CM_RESOURCE_MEMORY_WRITE_ONLY:
		{
			pInstance->SetCharSplat(IDS_MemoryType, IDS_MTWriteOnly);
		}
		break;

        case CM_RESOURCE_MEMORY_PREFETCHABLE:
		{
			pInstance->SetCharSplat(IDS_MemoryType, IDS_MTPrefetchable);
		}
		break;

		default:
		{
		}
		break;
    }

    return WBEM_S_NO_ERROR;
}

#endif

////////////////////////////////////////////////////////////////////////
//
//  Get Device Memory info for 9x
//
////////////////////////////////////////////////////////////////////////

#if (NTONLY > 4)

HRESULT DevMem::LoadPropertyValues(
	CInstance *pInstance,
	DWORD_PTR dwBeginAddr,
    DWORD_PTR dwEndAddr)
{
	WCHAR szTemp[_MAX_PATH];

	// Easy properties
    SetCreationClassName(pInstance);
	pInstance->SetCHString(IDS_CSName, GetLocalComputerName());
	pInstance->SetCHString(IDS_CSCreationClassName, _T("Win32_ComputerSystem"));
    pInstance->SetCharSplat(IDS_Status, IDS_OK);

	pInstance->SetWBEMINT64(IDS_StartingAddress, (__int64) dwBeginAddr);
	pInstance->SetWBEMINT64(IDS_EndingAddress, (__int64) dwEndAddr);

	swprintf(szTemp, IDS_RegStartingAddress, dwBeginAddr, dwEndAddr);

	pInstance->SetCharSplat(IDS_Caption, szTemp);
	pInstance->SetCHString(IDS_Name, szTemp);
	pInstance->SetCHString(IDS_Description, szTemp);

	return WBEM_NO_ERROR;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\devicememory.h ===
//=================================================================

//

// DevMem.h -- Device Memory property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_DEVMEM L"Win32_DeviceMemoryAddress"

class DevMem:public Provider
{
public:

    // Constructor/destructor
    //=======================

    DevMem(LPCWSTR name, LPCWSTR pszNamespace) ;
   ~DevMem() ;

	HRESULT EnumerateInstances ( MethodContext *pMethodContext , long lFlags = 0L ) ;
	HRESULT GetObject ( CInstance *pInstance , long lFlags = 0L ) ;


    // Utility function(s)
    //====================

	HRESULT LoadPropertyValues(
		CInstance *pInstance,
        DWORD_PTR dwBeginAddr,
        DWORD_PTR dwEndAddr);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\devid.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  DevID.h
//
//  Purpose: Relationship between Win32_PNPEntity and CIM_LogicalDevice
//
//***************************************************************************

// Property set identification
//============================

#define  PROPSET_NAME_PNPDEVICE L"Win32_PNPDevice"

class CWin32DeviceIdentity ;

class CWin32DeviceIdentity:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32DeviceIdentity(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32DeviceIdentity() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ );


} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\devid.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  DevID.cpp
//
//  Purpose: Relationship between Win32_PNPEntity and CIM_LogicalDevice
//
//  SameElement = win32_pnpdevice
//  SystemElement = cim_logicaldevice
//
//***************************************************************************

#include "precomp.h"

#include "devid.h"

// Property set declaration
//=========================

CWin32DeviceIdentity MyDevRes(PROPSET_NAME_PNPDEVICE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceIdentity::CWin32DeviceIdentity
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DeviceIdentity::CWin32DeviceIdentity(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceIdentity::~CWin32DeviceIdentity
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DeviceIdentity::~CWin32DeviceIdentity()
{
}

/*****************************************************************************
*
*  FUNCTION    : CWin32DeviceIdentity::ExecQuery
*
*  DESCRIPTION : Query support
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    : Since I can't know what DeviceID a given class has given a
*                particular PNPID, the only optimization I can do is if they
*                give me a CIM_LogicalDevice DeviceID, since I know that
*                the PNPDeviceID property of that device is populated (otherwise
*                the enumeration couldn't have found it).
*
*****************************************************************************/
HRESULT CWin32DeviceIdentity::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    CHStringArray saDevices;

    HRESULT hr = WBEM_E_PROVIDER_NOT_CAPABLE;

    if (SUCCEEDED(pQuery.GetValuesForProp(IDS_SameElement, saDevices)) && (saDevices.GetSize() > 0))
    {
        CHString sPNPId, sPNPId2, sDevicePath, sTemp;
        CInstancePtr pDevice;

        hr = WBEM_S_NO_ERROR;

        for (int x=0; (x < saDevices.GetSize()) && SUCCEEDED(hr); x++)
        {
            // This GetInstanceByPath will both confirm the existence of the requested device,
            // and give us the pnpid.
            CHStringArray csaProperties;
            csaProperties.Add(IDS___Path);
            csaProperties.Add(IDS_DeviceID);
            csaProperties.Add(IDS_PNPDeviceID);

            if(SUCCEEDED(hr = CWbemProviderGlue::GetInstancePropertiesByPath(saDevices[x], &pDevice, pMethodContext, csaProperties)))
            {
                if (!pDevice->IsNull(IDS_PNPDeviceID) &&
                    !pDevice->IsNull(IDS___Path) &&
                    pDevice->GetCHString(IDS___Path, sDevicePath) &&
                    pDevice->GetCHString(IDS_PNPDeviceID, sPNPId))
                {
                    CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

                    pInstance->SetCHString(IDS_SameElement, sDevicePath);

                    EscapeBackslashes(sPNPId, sPNPId2);
                    sTemp.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCWSTR) GetLocalComputerName(), IDS_CimWin32Namespace,
                        L"Win32_PnPEntity", IDS_DeviceID, sPNPId2);
                    pInstance->SetCHString(IDS_SystemElement, sTemp);

                    hr = pInstance->Commit();
                }
            }
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceIdentity::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DeviceIdentity::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
    CHString    sCimLogicalDevice,
                sPNPDevice,
                sDeviceID,
                sClass;
    HRESULT     hRet = WBEM_E_NOT_FOUND;
    CInstancePtr pResource;

    // Get the two paths
    pInstance->GetCHString(IDS_SameElement, sCimLogicalDevice);
    pInstance->GetCHString(IDS_SystemElement, sPNPDevice);

    // Get the CIM_LogicalDevice.  This checks for existence, and gets us the pnpid.
    if(SUCCEEDED(hRet = CWbemProviderGlue::GetInstanceByPath(sCimLogicalDevice, &pResource, pInstance->GetMethodContext())))
    {
        ParsedObjectPath*    pParsedPath = 0;
        CObjectPathParser    objpathParser;

        hRet = WBEM_E_NOT_FOUND;

        // Parse the object path passed to us by CIMOM.  We do this to see if the
        // Win32_PNPDevice they passed us is the same as the one we got back from
        // the GetInstanceByPath.
        int nStatus = objpathParser.Parse( sPNPDevice,  &pParsedPath );

        if ( 0 == nStatus )                                                 // Did the parse succeed?
        {
            try
            {
                if ((pParsedPath->IsInstance()) &&                                  // Is the parsed object an instance?
                    (_wcsicmp(pParsedPath->m_pClass, L"Win32_PnPEntity") == 0) &&       // Is this the class we expect (no, cimom didn't check)
                    (pParsedPath->m_dwNumKeys == 1) &&                              // Does it have exactly one key
                    (pParsedPath->m_paKeys[0]) &&                                   // Is the keys pointer null (shouldn't happen)
                    ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||                 // Key name not specified or
                    (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_DeviceID) == 0)) &&  // key name is the right value
                                                                                // (no, cimom doesn't do this for us).
                    (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == CIM_STRING) &&    // Check the variant type (no, cimom doesn't check this either)
                    (V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue) != NULL) )         // And is there a value in it?
                {
                    CHString sSeekPNPId, sPNPId;

                    if (pResource->GetCHString(IDS_PNPDeviceID, sPNPId))
                    {

                        sSeekPNPId = V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue);

                        if (sSeekPNPId.CompareNoCase(sPNPId) == 0)
                        {
                            hRet = WBEM_S_NO_ERROR;
                        }
                    }

                }
            }
            catch ( ... )
            {
                objpathParser.Free( pParsedPath );
                throw ;
            }

            // Clean up the Parsed Path
            objpathParser.Free( pParsedPath );
        }
    }

   // There are no properties to set, if the endpoints exist, we be done

   return hRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceIdentity::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DeviceIdentity::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
    CHString sDeviceID, sDeviceID2, sDevicePath, sTemp;
    HRESULT hr = WBEM_S_NO_ERROR;

   // Get list of Services
   //=====================
   TRefPointerCollection<CInstance> LDevices;

   // Find all the devices that have a pnp id, EXCEPT the ones from Win32_PNPDevice

   // PERF NOTE!  CIMOM still calls Win32_PNPDevices.  It just throws the instances away.  It MIGHT be faster to
   // call each of the classes individually.  On the other hand, by doing it this way, cimom launches multiple threads.
   if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(
       L"SELECT __PATH, PNPDeviceID from CIM_LogicalDevice where (PNPDeviceID <> NULL) and (__Class <> \"Win32_PnPEntity\")",
       &LDevices,
       pMethodContext,
       IDS_CimWin32Namespace)))
	{
      REFPTRCOLLECTION_POSITION pos;
      CInstancePtr pDevice;

      if (LDevices.BeginEnum(pos))
      {
         // Walk through the devices
         for (pDevice.Attach(LDevices.GetNext( pos )) ;
             (SUCCEEDED(hr)) && (pDevice != NULL) ;
              pDevice.Attach(LDevices.GetNext( pos )) )
         {

            // Get the id (to send to cfgmgr) and the path (to send back in 'SameElement')
            pDevice->GetCHString(IDS_PNPDeviceID, sDeviceID) ;
            pDevice->GetCHString(IDS___Path, sDevicePath) ;

            CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

            pInstance->SetCHString(IDS_SameElement, sDevicePath);

            EscapeBackslashes(sDeviceID, sDeviceID2);

            sTemp.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCWSTR) GetLocalComputerName(), IDS_CimWin32Namespace,
                L"Win32_PnPEntity", IDS_DeviceID, sDeviceID2);
            pInstance->SetCHString(IDS_SystemElement, sTemp);

            hr = pInstance->Commit();
         }

         LDevices.EndEnum();
      }
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\devres.cpp ===
//=================================================================

//

// devres.CPP -- cim_logicaldevice to cim_systemresource

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/13/98    davwoh         Created
//
// Comment: Relationship between device and system resource
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>

#include "devres.h"

// Property set declaration
//=========================

CWin32DeviceResource MyDevRes(PROPSET_NAME_ALLOCATEDRESOURCE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceResource::CWin32DeviceResource
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DeviceResource::CWin32DeviceResource(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceResource::~CWin32DeviceResource
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DeviceResource::~CWin32DeviceResource()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceResource::ExecQuery
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DeviceResource::ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags )
{
    CHStringArray saDevices;
    HRESULT hr = WBEM_E_PROVIDER_NOT_CAPABLE;

    pQuery.GetValuesForProp(IDS_Dependent, saDevices);

    if (saDevices.GetSize() > 0)
    {
        // This GetInstanceByPath will both confirm the existence of the requested device,
        // and give us the pnpid.
        CHStringArray csaProperties;
        csaProperties.Add(IDS___Path);
        csaProperties.Add(IDS_PNPDeviceID);

        CInstancePtr pInstance;
        CHString sPNPId;

        hr = WBEM_S_NO_ERROR;

        for (int x=0; (x < saDevices.GetSize()) && SUCCEEDED(hr); x++)
        {
            hr = CWbemProviderGlue::GetInstancePropertiesByPath(saDevices[x], &pInstance, pMethodContext, csaProperties);
            if (SUCCEEDED(hr))
            {
                hr = CommitResourcesForDevice(pInstance, pMethodContext);
            }
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceResource::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DeviceResource::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
    CHString    sResource,
                sDevice,
                sDeviceID,
                sClass;
    HRESULT     hRet = WBEM_E_NOT_FOUND;
    CInstancePtr pResource, pIDevice;

    // Get the two paths
    pInstance->GetCHString(IDS_Antecedent, sResource);
    pInstance->GetCHString(IDS_Dependent, sDevice);

    CHStringArray csaResource, csaDevice;

    csaResource.Add(IDS_IRQNumber);
    csaResource.Add(IDS_DMAChannel);
    csaResource.Add(IDS_StartingAddress);

    csaDevice.Add(IDS_PNPDeviceID);

    // If both ends are there
    if(SUCCEEDED(hRet = CWbemProviderGlue::GetInstancePropertiesByPath((LPCWSTR) sResource,
        &pResource, pInstance->GetMethodContext(), csaResource)))
    {
        if(SUCCEEDED(hRet = CWbemProviderGlue::GetInstancePropertiesByPath((LPCWSTR) sDevice,
            &pIDevice, pInstance->GetMethodContext(), csaDevice)))
        {
             hRet = WBEM_E_NOT_FOUND;  // Haven't proved anything yet.

             // Get the id (to send to cfgmgr)
             pIDevice->GetCHString(IDS_PNPDeviceID, sDeviceID) ;
             pResource->GetCHString(IDS___Class, sClass);

            CConfigManager	cfgManager;
            CDeviceCollection	deviceList;

            CConfigMgrDevicePtr pDevice;

            // Find the device
            if (cfgManager.LocateDevice(sDeviceID, pDevice))
            {
                REFPTR_POSITION pos2;

                //------------------------------
                if (sClass.CompareNoCase(L"Win32_IRQResource") == 0)
                {
                    CIRQCollection irqList;

                    // Get the IRQs
                    pDevice->GetIRQResources(irqList);

                    if (irqList.BeginEnum(pos2))
                    {
                        CIRQDescriptorPtr pIRQ;
                        DWORD dwIRQSeeking;

                        pResource->GetDWORD(IDS_IRQNumber, dwIRQSeeking);

                        // Walk the irq's
                        for (pIRQ.Attach(irqList.GetNext(pos2));
                             pIRQ != NULL;
                             pIRQ.Attach(irqList.GetNext(pos2)))
                        {
                            if (pIRQ->GetInterrupt() == dwIRQSeeking)
                            {
                               hRet = WBEM_S_NO_ERROR;
                               break;
                            }
                        }
                   }
                //------------------------------
                }
                else if (sClass.CompareNoCase(L"Win32_DMAChannel") == 0)
                {
                    CDMACollection dmaList;

                    // Get the DMAs
                    pDevice->GetDMAResources(dmaList);

                    if (dmaList.BeginEnum(pos2))
                    {
                        CDMADescriptorPtr pDMA;
                        DWORD dwDMASeeking;

                        pResource->GetDWORD(IDS_DMAChannel, dwDMASeeking);

                        // Walk the dma's
                        for (pDMA.Attach(dmaList.GetNext(pos2));
                             pDMA != NULL;
                             pDMA.Attach(dmaList.GetNext(pos2)))
                        {
                            if (pDMA->GetChannel() == dwDMASeeking)
                            {
                               hRet = WBEM_S_NO_ERROR;
                               break;
                            }
                        }
                    }
             //------------------------------
             }
             else if (sClass.CompareNoCase(L"Win32_DeviceMemoryAddress") == 0)
             {

                CDeviceMemoryCollection DevMemList;

                // Get the DeviceMemory
                pDevice->GetDeviceMemoryResources( DevMemList );

                if ( DevMemList.BeginEnum(pos2))
                {
                    CDeviceMemoryDescriptorPtr pDeviceMemory;
                    __int64 i64StartingAddress;

                    pResource->GetWBEMINT64(IDS_StartingAddress, i64StartingAddress);

                    // Walk the Device Memory
                    for (pDeviceMemory.Attach(DevMemList.GetNext(pos2));
                         pDeviceMemory != NULL;
                         pDeviceMemory.Attach(DevMemList.GetNext(pos2)))
                    {
                        if (pDeviceMemory->GetBaseAddress() == i64StartingAddress)
                        {
                           hRet = WBEM_S_NO_ERROR;
                           break;
                        }
                    }
                }
             }
             else if (sClass.CompareNoCase(L"Win32_PortResource") == 0)
             {
                CIOCollection ioList;

                // Get the IRQs
                pDevice->GetIOResources(ioList);

                if ( ioList.BeginEnum(pos2))
                {
                    CIODescriptorPtr pIO;
                    __int64 i64StartingAddress;

                    pResource->GetWBEMINT64(IDS_StartingAddress, i64StartingAddress);

                    // Walk the dma's
                    for (pIO.Attach(ioList.GetNext(pos2));
                         pIO != NULL;
                         pIO.Attach(ioList.GetNext(pos2)))
                    {
                        if (pIO->GetBaseAddress() == i64StartingAddress)
                        {
                           hRet = WBEM_S_NO_ERROR;
                           break;
                        }
                    }
                }
             }
             else
                 // Don't know what type of system resource this is
                 ASSERT_BREAK(0);
         }
      }
   }

   // There are no properties to set, if the endpoints exist, we be done

   return hRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceResource::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DeviceResource::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hr1 = WBEM_S_NO_ERROR;

    // Get list of Services
    //=====================
    TRefPointerCollection<CInstance> LDevices;

    // Find all the devices that have a pnp id
    hr1 = CWbemProviderGlue::GetInstancesByQuery(
        L"SELECT __PATH, PNPDeviceID from CIM_LogicalDevice where PNPDeviceID <> NULL and __Class <> 'Win32_PNPEntity'",
        &LDevices,
        pMethodContext,
        IDS_CimWin32Namespace);

    // Just becuase the call returned an error, doesn't mean it returned zero instances
    if (LDevices.GetSize() > 0)
    {
        REFPTRCOLLECTION_POSITION pos;
        CInstancePtr pLDevice;

        if (LDevices.BeginEnum(pos))
        {
            // Walk through the devices
            for (pLDevice.Attach(LDevices.GetNext( pos ));
                 SUCCEEDED(hr) && (pLDevice != NULL);
                 pLDevice.Attach(LDevices.GetNext( pos )))
            {
                hr = CommitResourcesForDevice(pLDevice, pMethodContext);
            }
        }

        LDevices.EndEnum();
    }

    // Cast away the sign, so 0x80000001 is considered greater then WBEM_S_NO_ERROR
    return (ULONG)hr > (ULONG)hr1 ? hr : hr1;
}

HRESULT CWin32DeviceResource::CommitResourcesForDevice(CInstance *pLDevice, MethodContext *pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR buff[MAXI64TOA];

    CHString sDeviceID, sDevicePath, sTemp;
    CIRQCollection irqList;
    CDMACollection dmaList;
    CDeviceMemoryCollection DevMemList;
    CIOCollection ioList;
    REFPTR_POSITION pos2;

    // Get the id (to send to cfgmgr) and the path (to send back in 'Dependent')
    pLDevice->GetCHString(IDS_PNPDeviceID, sDeviceID) ;
    pLDevice->GetCHString(IDS___Path, sDevicePath) ;

    CConfigManager	cfgManager;
    CDeviceCollection	deviceList;

    CConfigMgrDevicePtr pDevice;

    // Find the device
    if (cfgManager.LocateDevice(sDeviceID, pDevice))
    {
        // Get the IRQs
        pDevice->GetIRQResources( irqList );

        if ( irqList.BeginEnum( pos2 ) )
        {
            CIRQDescriptorPtr pIRQ;

            // Walk the irq's
            for (pIRQ.Attach(irqList.GetNext( pos2 ));
                 SUCCEEDED(hr) && (pIRQ != NULL);
                 pIRQ.Attach(irqList.GetNext( pos2 )))
            {
                sTemp.Format(L"\\\\%s\\%s:%s.%s=%u",
                    (LPCWSTR)GetLocalComputerName(),
                    IDS_CimWin32Namespace,
                    L"Win32_IRQResource",
                    IDS_IRQNumber,
                    pIRQ->GetInterrupt());

                // Do the puts, and that's it
                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                pInstance->SetCHString(IDS_Antecedent, sTemp);
                pInstance->SetCHString(IDS_Dependent, sDevicePath);

                hr = pInstance->Commit();
            }
        }

        // Get DMAChannel
        pDevice->GetDMAResources( dmaList );

        if ( dmaList.BeginEnum( pos2 ) )
        {
            CDMADescriptorPtr pDMA;

            // Walk the Channels (or is that surf?)
            for (pDMA.Attach(dmaList.GetNext( pos2 ));
                 SUCCEEDED(hr) && (pDMA != NULL);
                 pDMA.Attach(dmaList.GetNext( pos2 )))
            {
                sTemp.Format(L"\\\\%s\\%s:%s.%s=%u",
                    (LPCWSTR)GetLocalComputerName(),
                    IDS_CimWin32Namespace,
                    L"Win32_DMAChannel",
                    IDS_DMAChannel,
                    pDMA->GetChannel());

                // Do the puts, and that's it
                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                pInstance->SetCHString(IDS_Antecedent, sTemp);
                pInstance->SetCHString(IDS_Dependent, sDevicePath);

                hr = pInstance->Commit();
            }
        }

        // Get DeviceMemory
        pDevice->GetDeviceMemoryResources( DevMemList );

        if ( DevMemList.BeginEnum( pos2 ) )
        {
            CDeviceMemoryDescriptorPtr pDeviceMemory;

            // Walk the memory resource
            for (pDeviceMemory.Attach(DevMemList.GetNext( pos2 ));
                 SUCCEEDED(hr) && (pDeviceMemory != NULL);
                 pDeviceMemory.Attach(DevMemList.GetNext( pos2 )))
            {
                sTemp.Format(L"\\\\%s\\%s:%s.%s=\"",
                    (LPCWSTR)GetLocalComputerName(),
                    IDS_CimWin32Namespace,
                    L"Win32_DeviceMemoryAddress",
                    IDS_StartingAddress);

                sTemp += _i64tow(pDeviceMemory->GetBaseAddress(), buff, 10);
                sTemp += L'\"';

                // Do the puts, and that's it
                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                pInstance->SetCHString(IDS_Antecedent, sTemp);
                pInstance->SetCHString(IDS_Dependent, sDevicePath);

                hr = pInstance->Commit();
            }
        }

        // Get IO Ports
        pDevice->GetIOResources( ioList );

        if ( ioList.BeginEnum( pos2 ) )
        {
            CIODescriptorPtr pIO;

            // Walk the ports
            for (pIO.Attach(ioList.GetNext( pos2 ));
                 SUCCEEDED(hr) && (pIO != NULL);
                 pIO.Attach(ioList.GetNext( pos2 )))
            {
                sTemp.Format(L"\\\\%s\\%s:%s.%s=\"",
                    (LPCWSTR)GetLocalComputerName(),
                    IDS_CimWin32Namespace,
                    L"Win32_PortResource",
                    IDS_StartingAddress);

                sTemp += _i64tow(pIO->GetBaseAddress(), buff, 10);
                sTemp += L'\"';

                // Do the puts, and that's it
                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                pInstance->SetCHString(IDS_Antecedent, sTemp);
                pInstance->SetCHString(IDS_Dependent, sDevicePath);

                hr = pInstance->Commit();
            }
        }
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\dhcpinfo.h ===
//=================================================================

//

// DHCPInfo.h -- DHCPinfo provider for Windows '95

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    
//
//=================================================================

#ifndef __DHCPINFO_H_
#define __DHCPINFO_H_



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\dhcpcsvcapi.h ===
//=================================================================

//

// DhcpSvcApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_DHCPCSVCAPI_H_
#define	_DHCPCSVCAPI_H_



#ifndef _ENUM_SERVICE_ENABLE_DEFINED
#define _ENUM_SERVICE_ENABLE_DEFINED
typedef enum _SERVICE_ENABLE {
    IgnoreFlag,
    DhcpEnable,
    DhcpDisable
} SERVICE_ENABLE, *LPSERVICE_ENABLE;
#endif





/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "DllWrapperBase.h"

extern const GUID g_guidDhcpcsvcApi;
extern const TCHAR g_tstrDhcpcsvc[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/
typedef DWORD (APIENTRY *PFN_DHCP_ACQUIRE_PARAMETERS)
(
    LPWSTR
);

typedef DWORD (APIENTRY *PFN_DHCP_RELEASE_PARAMETERS)
(
    LPWSTR
);

typedef DWORD (APIENTRY *PFN_DHCP_NOTIFY_CONFIG_CHANGE)
(
    LPWSTR, 
    LPWSTR, 
    BOOL, 
    DWORD, 
    DWORD, 
    DWORD, 
    SERVICE_ENABLE
);





/******************************************************************************
 * Wrapper class for Dhcpcsvc load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CDhcpcsvcApi : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to kernel32 functions.
    // Add new functions here as required.
    PFN_DHCP_ACQUIRE_PARAMETERS m_pfnDhcpAcquireParameters;
    PFN_DHCP_RELEASE_PARAMETERS m_pfnDhcpReleaseParameters;
    PFN_DHCP_NOTIFY_CONFIG_CHANGE m_pfnDhcpNotifyConfigChange;

public:

    // Constructor and destructor:
    CDhcpcsvcApi(LPCTSTR a_tstrWrappedDllName);
    ~CDhcpcsvcApi();

    // Inherrited initialization function.
    virtual bool Init();

    // Member functions wrapping Dhcpcsvc functions.
    // Add new functions here as required:
    DWORD DhcpAcquireParameters
    (
        LPWSTR a_lpwstr
    );

    DWORD DhcpReleaseParameters
    (
        LPWSTR a_lpwstr
    );

    DWORD DhcpNotifyConfigChange
    (
        LPWSTR a_lpwstr1, 
        LPWSTR a_lpwstr2, 
        BOOL a_f, 
        DWORD a_dw1, 
        DWORD a_dw2, 
        DWORD a_dw3, 
        SERVICE_ENABLE a_se
    );

};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\dhcpcsvcapi.cpp ===
//=================================================================

//

// DHCPSvcAPI.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================
#include "precomp.h"
#include <cominit.h>
#include "DhcpcsvcApi.h"
#include "DllWrapperCreatorReg.h"



// {E31A80D2-D12F-11d2-911F-0060081A46FD}
static const GUID g_guidDhcpcsvcApi =
{0xe31a80d2, 0xd12f, 0x11d2, {0x91, 0x1f, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};



static const TCHAR g_tstrDhcpcsvc[] = _T("DHCPCSVC.DLL");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CDhcpcsvcApi, &g_guidDhcpcsvcApi, g_tstrDhcpcsvc> MyRegisteredDhcpcsvcWrapper;


/******************************************************************************
 * Constructor
 ******************************************************************************/
CDhcpcsvcApi::CDhcpcsvcApi(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnDhcpAcquireParameters(NULL),
   m_pfnDhcpReleaseParameters(NULL),
   m_pfnDhcpNotifyConfigChange(NULL)
{
}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CDhcpcsvcApi::~CDhcpcsvcApi()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CDhcpcsvcApi::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
        m_pfnDhcpAcquireParameters = (PFN_DHCP_ACQUIRE_PARAMETERS)
                                       GetProcAddress("DhcpAcquireParameters");

        m_pfnDhcpReleaseParameters = (PFN_DHCP_RELEASE_PARAMETERS)
                                       GetProcAddress("DhcpReleaseParameters");

        m_pfnDhcpNotifyConfigChange = (PFN_DHCP_NOTIFY_CONFIG_CHANGE)
                                      GetProcAddress("DhcpNotifyConfigChange");
        // Check that we have function pointers to functions that should be
        // present...
        if(m_pfnDhcpAcquireParameters == NULL ||
           m_pfnDhcpReleaseParameters == NULL ||
           m_pfnDhcpNotifyConfigChange == NULL)
        {
            fRet = false;
        }
    }
    return fRet;
}




/******************************************************************************
 * Member functions wrapping Dhcpcsvc api functions. Add new functions here
 * as required.
 ******************************************************************************/
DWORD CDhcpcsvcApi::DhcpAcquireParameters
(
    LPWSTR a_lpwstr
)
{
    return m_pfnDhcpAcquireParameters(a_lpwstr);
}

DWORD CDhcpcsvcApi::DhcpReleaseParameters
(
    LPWSTR a_lpwstr
)
{
    return m_pfnDhcpReleaseParameters(a_lpwstr);
}

DWORD CDhcpcsvcApi::DhcpNotifyConfigChange
(
    LPWSTR a_lpwstr1,
    LPWSTR a_lpwstr2,
    BOOL a_f,
    DWORD a_dw1,
    DWORD a_dw2,
    DWORD a_dw3,
    SERVICE_ENABLE a_se
)
{
    return m_pfnDhcpNotifyConfigChange(a_lpwstr1,
                                       a_lpwstr2,
                                       a_f,
                                       a_dw1,
                                       a_dw2,
                                       a_dw3,
                                       a_se);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\devres.h ===
//=================================================================

//

// devres.h -- cim_logicaldevice to cim_systemresource

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/13/98    davwoh         Created
//
// Comment: Relationship between device and system resource
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_ALLOCATEDRESOURCE L"Win32_AllocatedResource"

class CWin32DeviceResource ;

class CWin32DeviceResource:public Provider 
{

    public:

        // Constructor/destructor
        //=======================

        CWin32DeviceResource(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32DeviceResource() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags );

    protected:
        HRESULT CommitResourcesForDevice(CInstance *pLDevice, MethodContext *pMethodContext);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\dhcpinfo.cpp ===
//=================================================================

//

// DHCPInfo.cpp -- DHCPinfo provider for Windows '95

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:
//							a-brads			created
//
//				03/03/99    		syntactic clean up
//
//=================================================================
#include "precomp.h"
#include <cregcls.h>
#include "wsock32api.h"
#include "dhcpinfo.h"
#include "dhcpcsdk.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\directory.h ===
//=================================================================

//

// Directory.h -- Directory property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/16/98    a-kevhu         Created
//
//=================================================================

// Property set identification
//============================



#define  PROPSET_NAME_DIRECTORY L"Win32_Directory"


class CWin32Directory;


class CWin32Directory : public CImplement_LogicalFile 
{

    public:

        // Constructor/destructor
        //=======================

        CWin32Directory(LPCWSTR name, LPCWSTR pszNamespace);
       ~CWin32Directory() ;


    protected:

#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName);
#endif

        // Overridable function inherrited from CProvider
        virtual void GetExtendedProperties(CInstance* pInstance, long lFlags = 0L);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\directory.cpp ===
//=================================================================

//

// Directory.CPP -- Directory property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/16/98    a-kevhu         Created
//
//=================================================================

#include "precomp.h"
#include "File.h"
#include "Implement_LogicalFile.h"
#include "Directory.h"

// Property set declaration
//=========================

CWin32Directory MyDirectorySet ( PROPSET_NAME_DIRECTORY , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Directory::CWin32Directory
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32Directory::CWin32Directory (

	LPCWSTR setName,
	LPCWSTR pszNamespace

) : CImplement_LogicalFile ( setName , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Directory::~CWin32Directory
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32Directory::~CWin32Directory()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Directory::IsOneOfMe
 *
 *  DESCRIPTION : The guts of this class, actually.  IsOneOfMe is inherrited
 *                from CImplement_LogicalFile.  That class returns files or
 *                directories where this one should only return directories,
 *                in response to queries, getobject commands, etc.  It is
 *                overridden here to return TRUE only if the file (the
 *                information for which is contained in the function arguement
 *                pstFindData) is of type directory.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE or FALSE
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/


#ifdef NTONLY
BOOL CWin32Directory::IsOneOfMe (

	LPWIN32_FIND_DATAW pstFindData,
    const WCHAR* wstrFullPathName
)
{
    BOOL fRet = FALSE;

    // It is possible, in the case of the root directory, that pstFindData was NULL,
    // in which case wstrFullPathName should contain "<driveletter>:\\".  If all that
    // is true, this was one of us - namely, the root "directory".

    if ( pstFindData == NULL )
    {
        if ( wcslen ( wstrFullPathName ) == 2 )
        {
            fRet = TRUE;
        }
    }
    else
    {
        fRet = ( pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) ? TRUE : FALSE ;
    }

    return fRet;
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : CCIMDataFile::GetExtendedProperties
 *
 *  DESCRIPTION : Sets properties unique to this provider (not common to all
 *                CImplement_LogicalFile derived classes).
 *
 *  INPUTS      : CInstance pointer and flags
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
void CWin32Directory :: GetExtendedProperties (

	CInstance* pInstance,
    long lFlags
)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\directorycontainsfile.cpp ===
//=================================================================

//

// DirectoryContainsFile.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/26/98    a-kevhu         Created
//
// Comment: Relationship between win32_directory and contained cim_datafiles
//
//=================================================================

#include "precomp.h"

#include "DirectoryContainsFile.h"
#include "directory.h"
#include "cimdatafile.h"



// Property set declaration
//=========================
CDirContFile MyCDirContFile(PROPSET_NAME_DIRECTORYCONTAINSFILE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CDirContFile::CDirContFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CDirContFile::CDirContFile(LPCWSTR setName, LPCWSTR pszNamespace)
:CImplement_LogicalFile(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CDirContFile::~CDirContFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CDirContFile::~CDirContFile()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CDirContFile::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CDirContFile::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CHString chstrDirectory;
    CHString chstrDatafile;
    CHString chstrDirFullPathName;
    CHString chstrFileFullPathName;
    HRESULT hr = WBEM_E_NOT_FOUND;

    if(pInstance != NULL)
    {
        // Get the two paths
        pInstance->GetCHString(IDS_GroupComponent, chstrDirectory);
        pInstance->GetCHString(IDS_PartComponent, chstrDatafile);

        CInstancePtr pinstDirectory;
        CInstancePtr pinstDatafile;

        // If both ends are there
        if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrDirectory, &pinstDirectory, pInstance->GetMethodContext())))
        {
            if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrDatafile, &pinstDatafile, pInstance->GetMethodContext())))
            {
                // Confirm that the directory is part of the datafile's path:
                chstrDirFullPathName = chstrDirectory.Mid(chstrDirectory.Find(_T('='))+2);
                chstrDirFullPathName = chstrDirFullPathName.Left(chstrDirFullPathName.GetLength() - 1);

                chstrFileFullPathName = chstrDatafile.Mid(chstrDatafile.Find(_T('='))+2);
                chstrFileFullPathName = chstrFileFullPathName.Left(chstrFileFullPathName.GetLength() - 1);

                chstrDirFullPathName.MakeUpper();
                chstrFileFullPathName.MakeUpper();

                if(chstrFileFullPathName.Find(chstrDirFullPathName) != -1)
                {
                    hr = WBEM_S_NO_ERROR;
                }

            } //dir instancebypath
        } //logicaldisk instancebypath
    } // pinstance not null

    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CDirContFile::ExecQuery
 *
 *  DESCRIPTION : Analyses query and returns appropriate instances
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CDirContFile::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHStringArray achstrGroupComponent;
    DWORD dwGroupComponents = 0L;
    CHStringArray achstrPartComponent;
    DWORD dwPartComponents = 0L;

    pQuery.GetValuesForProp(IDS_GroupComponent, achstrGroupComponent);
    dwGroupComponents = achstrGroupComponent.GetSize();
    pQuery.GetValuesForProp(IDS_PartComponent, achstrPartComponent);
    dwPartComponents = achstrPartComponent.GetSize();

    // The first optimization is for the case where the user asked for associations of a directory -
    // the query will have a WHERE clause specifying a group component that is the directory containing files
    if(dwGroupComponents == 1L && dwPartComponents == 0L)
    {
        // Need the directory path...
        // Need to format the path parameter for the sub-directories (the partcomponents)...
        CHString chstrFilePath;
        LONG lPos = achstrGroupComponent[0].Find(L":");
        chstrFilePath = achstrGroupComponent[0].Mid(lPos+1);
        chstrFilePath = chstrFilePath.Left(chstrFilePath.GetLength() - 1);
        if(chstrFilePath != _T("\\\\")) // it is not a root dir (proper syntax for root is just "\\", not "\\\\")
        {
            chstrFilePath += _T("\\\\"); // if not the root, need to tack on trailing pair of backslashes
        }

        CHString chstrDiskLetter;
        lPos = achstrGroupComponent[0].Find(L":");
        chstrDiskLetter = achstrGroupComponent[0].Mid(lPos-1, 2);

        CHString chstrFilePathAdj;  // to hold the version of the path without the extra escaped backslashes.
        RemoveDoubleBackslashes(chstrFilePath, chstrFilePathAdj);

#ifdef NTONLY
        hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                        chstrDiskLetter,
                        chstrFilePathAdj,   // use the given path
                        L"*",               // filename
                        L"*",               // extension
                        false,              // no recursion desired
                        NULL,               // don't need the file system name
                        NULL,               // don't need ANY of cim_logicalfile's props (irrelavent in this class's overload of LoadPropetyValues)
                        false,              // this association is not interested in calling LoadPropertyValues for the root, only for files off of it
                        NULL));
#endif
    }

    // The second optimization is for the case where the user asked for associations of a specific file -
    // in this case the WHERE clause will contain a part component that is the file.  We should give back the directory
    // the file is in.
    else if(dwGroupComponents == 0L && dwPartComponents == 1L)
    {
        // Need the directory name - obtain from the file name...
        CHString chstrDirName;
        LONG lPos = achstrPartComponent[0].Find(L"=");
        chstrDirName = achstrPartComponent[0].Mid(lPos+1);
        chstrDirName = chstrDirName.Left(chstrDirName.ReverseFind(_T('\\')) - 1);

        // Need to construct the path of the GroupPart...
        CHString chstrDirPATH;
        chstrDirPATH.Format(L"\\\\%s\\%s:%s.Name=%s\"", GetLocalComputerName(), IDS_CimWin32Namespace, PROPSET_NAME_DIRECTORY, chstrDirName);

        // Now construct the part component...
        CHString chstrFilePATH;
        chstrFilePATH.Format(L"\\\\%s\\%s:%s", GetLocalComputerName(), IDS_CimWin32Namespace, achstrPartComponent[0]);

        // commit it now...
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        if(pInstance != NULL)
        {
            pInstance->SetCHString(IDS_PartComponent, chstrFilePATH);
            pInstance->SetCHString(IDS_GroupComponent, chstrDirPATH);
            hr = pInstance->Commit();
        }
    }
    else
    {
        hr = EnumerateInstances(pMethodContext);
    }

    // Because this is an association class, we should only return WBEM_E_NOT_FOUND or WBEM_S_NO_ERROR.  Other error codes
    // will cause associations that hit this class to terminate prematurely.
    if(SUCCEEDED(hr))
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = WBEM_E_NOT_FOUND;
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CDirContFile::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

// NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE
//
//WITH CHANGE TO MAKE THIS CLASS INHERRIT FROM CIMPLEMENTLOGICALFILE, NO NEED TO
//IMPLEMENT HERE AT ALL.  WHAT WILL HAPPEN IS ENUMINSTANCES FROM THE PARENT CLASS
//WILL BE CALLED, BUT ONLY FILES WILL SATISFY THIS CLASS'S ISONEOFME (WHICH WILL
//BE THE VERSION OF THAT FUNCTION CALLED AS THIS IS THE MOST DERIVED VERSION),
//AND SIMILARLY THIS CLASS'S LOADPROPERTYVALUES WILL BE CALLED.
//
// NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE
//
//HRESULT CDirContFile::EnumerateInstances(MethodContext* pMethodContext, long lFlags /*= 0L*/)
//{
//    HRESULT hr = WBEM_S_NO_ERROR;
//    TRefPointerCollection<CInstance> LDirs;
//
//    if(SUCCEEDED(CWbemProviderGlue::GetAllInstances(CHString(_T("Win32_Directory")),
//                                                    &LDirs,
//                                                    IDS_CimWin32Namespace,
//                                                    pMethodContext)))
//    {
//        REFPTRCOLLECTION_POSITION pos;
//        if(LDirs.BeginEnum(pos))
//        {
//            CInstance* pinstDir = NULL;
//            CHString chstrDirPATH;
//            CHString chstrDriveLetter;
//            CHString chstrQuery;
//            //CHString chstrWbemizedPath;
//            CHString chstrFileFilename;
//            CHString chstrFilePath;
//            LONG lPos;
//
//            while((SUCCEEDED(hr)) && (pinstDir = LDirs.GetNext(pos)))
//            {
//                if(pinstDir != NULL)
//                {
//                    // grab every directory hanging off of the root of that disk...
//                    pinstDir->GetCHString(_T("__PATH"), chstrDirPATH);  // groupcomponent
//                    pinstDir->GetCHString(IDS_Drive, chstrDriveLetter);
//                    pinstDir->GetCHString(IDS_Name, chstrFileFilename);
//                    lPos = chstrFileFilename.Find(_T(":"));
//                    chstrFilePath = chstrFileFilename.Mid(lPos+1);
//                    if(chstrFilePath != _T("\\"))
//                    {
//                        chstrFilePath += _T("\\");
//                    }
//
//                    //EscapeBackslashes(chstrFilePath,chstrWbemizedPath);
//
//                    chstrQuery.Format(_T("SELECT __PATH FROM CIM_DataFile WHERE Drive = \"%s\" and Path = \"%s\""),chstrDriveLetter,chstrFilePath);
//                    hr = QueryForSubItemsAndCommit(chstrDirPATH,
//                                                   chstrQuery,
//                                                   pMethodContext);
//                    pinstDir->elease();
//                }
//            }
//            LDirs.EndEnum();
//        }
//    }
//    return hr;
//}


/*****************************************************************************
 *
 *  FUNCTION    : CDirContFile::IsOneOfMe
 *
 *  DESCRIPTION : IsOneOfMe is inherritedfrom CIM_LogicalFile.  That class
 *                returns files or directories where this one should only
 *                return files, in response to queries, getobject commands,
 *                etc.  It is overridden here to return TRUE only if the file
 *                (the information for which is contained in the function
 *                arguement pstFindData) is of type file.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if a file or FALSE if a directory
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef NTONLY
BOOL CDirContFile::IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                             const WCHAR* wstrFullPathName)
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.
    if(pstFindData == NULL)
    {
        return FALSE;
    }
    else
    {
        return ((pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? FALSE : TRUE);
    }
}
#endif



/*****************************************************************************
 *
 *  FUNCTION    : CDirContFile::LoadPropertyValues
 *
 *  DESCRIPTION : LoadPropertyValues is inherritedfrom CIM_LogicalFile.  That class
 *                calls LoadPropertyValues just prior to commiting the instance.
 *                Here we just need to load the PartComponent and GroupComponent
 *                properties.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CDirContFile::LoadPropertyValuesNT(CInstance* pInstance,
                                         const WCHAR* pszDrive,
                                         const WCHAR* pszPath,
                                         const WCHAR* pszFSName,
                                         LPWIN32_FIND_DATAW pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    CHString chstrDirName;
    CHString chstrDirNameAdj;
    CHString chstrDirPATH;

    CHString chstrFileName;
    CHString chstrFileNameAdj;
    CHString chstrFilePATH;

    // Note: this routing will not be called from the root "directory" instance, since our EnumDirs final
    // parameter was false.  This is what we want, since this association only commits instances for files
    // hanging off a directory.  If we were called in the root case, the root would be the file (PartComponent),
    // and what would be the GroupComponent?!?

    // Get the GroupComponent (the directory name) ready...
    chstrDirName.Format(L"%s%s",pszDrive,pszPath);
    if(chstrDirName.GetLength() != 3)
    {   // it was not the root dir, so need to trim off trailing backslash.
        chstrDirName = chstrDirName.Left(chstrDirName.GetLength() - 1);
    }
    EscapeBackslashes(chstrDirName, chstrDirNameAdj);
    chstrDirPATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                        (LPCWSTR)GetLocalComputerName(),
                        IDS_CimWin32Namespace,
                        PROPSET_NAME_DIRECTORY,
                        (LPCWSTR)chstrDirNameAdj);
    // Get the PartComponent (the file name) ready...
    chstrFileName.Format(L"%s%s%s",pszDrive,pszPath,pstFindData->cFileName);
    EscapeBackslashes(chstrFileName, chstrFileNameAdj);
    chstrFilePATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                        (LPCWSTR)GetLocalComputerName(),
                        IDS_CimWin32Namespace,
                        PROPSET_NAME_CIMDATAFILE,
                        (LPCWSTR)chstrFileNameAdj);
    // Set Properties...
    pInstance->SetCHString(IDS_GroupComponent, chstrDirPATH);
    pInstance->SetCHString(IDS_PartComponent, chstrFilePATH);

	return WBEM_S_NO_ERROR ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\directorycontainsfile.h ===
//=================================================================

//

// DirectoryContainsFile

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/09/98    a-kevhu         Created
//
// Comment: Relationship between Win32_Directory and CIM_DataFile
//
//=================================================================

// Property set identification
//============================

#ifndef _DIRECTORYCONTAINSFILE_H_
#define _DIRECTORYCONTAINSFILE_H_

#define  PROPSET_NAME_DIRECTORYCONTAINSFILE L"CIM_DirectoryContainsFile"


#include "implement_logicalfile.h"



class CDirContFile;

class CDirContFile : public CImplement_LogicalFile
{
    public:
        // Constructor/destructor
        //=======================
        CDirContFile(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CDirContFile() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery);
        //virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L);

        virtual HRESULT DeleteInstance(const CInstance& newInstance, long lFlags = 0L) { return WBEM_E_PROVIDER_NOT_CAPABLE; }

    protected:
       
       // Overridable function inherrited from CImplement_LogicalFile
#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName);

        virtual HRESULT LoadPropertyValuesNT(CInstance* pInstance,
                                          const WCHAR* pszDrive, 
                                          const WCHAR* pszPath, 
                                          const WCHAR* pszFSName, 
                                          LPWIN32_FIND_DATAW pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\diskdrive.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  diskdrive.h
//
//  Purpose: Disk drive instance provider
//
//***************************************************************************

// Property set identification
//============================

#define  PROPSET_NAME_DISKDRIVE L"Win32_DiskDrive"
#define BYTESPERSECTOR 512

class CWin32DiskDrive;

class CWin32DiskDrive:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32DiskDrive(LPCWSTR name, LPCWSTR pszNamespace);
        ~CWin32DiskDrive() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        HRESULT Enumerate(MethodContext *pMethodContext, long lFlags, DWORD dwProperties);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ );

    private:
        CHPtrArray m_ptrProperties;

        // Utility
        //========

#ifdef NTONLY
        HRESULT GetPhysDiskInfoNT(CInstance *pInstance, LPCWSTR lpwszDrive, DWORD dwDrive, DWORD dwProperties, BOOL bGetIndex) ;
#endif

#if NTONLY == 5
        BOOL GetPNPDeviceIDFromHandle(
            HANDLE hHandle, 
            CHString &sPNPDeviceID
        );

#endif
        void SetInterfaceType(
            CInstance *pInstance, 
            CConfigMgrDevice *pDevice
        );
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\diskdrive.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  DiskDrive.CPP
//
//  Purpose: Disk Drive instance provider
//
//***************************************************************************

#include "precomp.h"
#include <assertbreak.h>
#include <frqueryex.h>
#include "wmiapi.h"

#include <setupapi.h>

#include <winioctl.h>
#include <ntddscsi.h>

#include "diskdrive.h"
#include "computersystem.h"
#include "resource.h"

#define BIT_ALL_PROPS                    0xFFFFFFFF

#define BIT_Model                   0x00000001
#define BIT_Partitions              0x00000002
#define BIT_Name                    0x00000004
#define BIT_Index                   0x00000008
#define BIT_CreationClassName       0x00000010
#define BIT_SystemCreationClassName 0x00000020
#define BIT_SystemName              0x00000040
#define BIT_Status                  0x00000080
#define BIT_Caption                 0x00000100
#define BIT_TotalHeads              0x00000200
#define BIT_TracksPerCylinder       0x00000400
#define BIT_SectorsPerTrack         0x00000800
#define BIT_BytesPerSector          0x00001000
#define BIT_TotalCylinders          0x00002000
#define BIT_TotalTracks             0x00004000
#define BIT_TotalSectors            0x00008000
#define BIT_Size                    0x00010000
#define BIT_MediaType               0x00020000
#define BIT_MediaLoaded             0x00040000
#define BIT_Capabilities            0x00080000
#define BIT_Description             0x00100000
#define BIT_InterfaceType           0x00200000
#define BIT_SCSIPort                0x00400000
#define BIT_SCSIBus                 0x00800000
#define BIT_SCSITargetID            0x01000000
#define BIT_SCSILogicalUnit         0x02000000
#define BIT_Manufacturer            0x04000000
#define BIT_PNPDeviceID             0x08000000
#define BIT_ConfigManagerUserConfig 0x10000000
#define BIT_ConfigManagerErrorCode  0x20000000
#define BIT_Signature               0x40000000

// Property set declaration
//=========================

CWin32DiskDrive MyWin32DiskDriveSet ( PROPSET_NAME_DISKDRIVE , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskDrive::CWin32DiskDrive
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DiskDrive :: CWin32DiskDrive (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
    m_ptrProperties.SetSize(31);

//  m_ptrProperties[0] = ((LPVOID) IDS_DeviceID);  // Key is always set
    m_ptrProperties[0] = ((LPVOID) IDS_Model);
    m_ptrProperties[1] = ((LPVOID) IDS_Partitions);
    m_ptrProperties[2] = ((LPVOID) IDS_Name);
    m_ptrProperties[3] = ((LPVOID) IDS_Index);
    m_ptrProperties[4] = ((LPVOID) IDS_CreationClassName);
    m_ptrProperties[5] = ((LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[6] = ((LPVOID) IDS_SystemName);
    m_ptrProperties[7] = ((LPVOID) IDS_Status);
    m_ptrProperties[8] = ((LPVOID) IDS_Caption);
    m_ptrProperties[9] = ((LPVOID) IDS_TotalHeads);
    m_ptrProperties[10] = ((LPVOID) IDS_TracksPerCylinder);
    m_ptrProperties[11] = ((LPVOID) IDS_SectorsPerTrack);
    m_ptrProperties[12] = ((LPVOID) IDS_BytesPerSector);
    m_ptrProperties[13] = ((LPVOID) IDS_TotalCylinders);
    m_ptrProperties[14] = ((LPVOID) IDS_TotalTracks);
    m_ptrProperties[15] = ((LPVOID) IDS_TotalSectors);
    m_ptrProperties[16] = ((LPVOID) IDS_Size);
    m_ptrProperties[17] = ((LPVOID) IDS_MediaType);
    m_ptrProperties[18] = ((LPVOID) IDS_MediaLoaded);
    m_ptrProperties[19] = ((LPVOID) IDS_Capabilities);
    m_ptrProperties[20] = ((LPVOID) IDS_Description);
    m_ptrProperties[21] = ((LPVOID) IDS_InterfaceType);
    m_ptrProperties[22] = ((LPVOID) IDS_SCSIPort);
    m_ptrProperties[23] = ((LPVOID) IDS_SCSIBus);
    m_ptrProperties[24] = ((LPVOID) IDS_SCSITargetID);
    m_ptrProperties[25] = ((LPVOID) IDS_SCSILogicalUnit);
    m_ptrProperties[26] = ((LPVOID) IDS_Manufacturer);
    m_ptrProperties[27] = ((LPVOID) IDS_PNPDeviceID);
    m_ptrProperties[28] = ((LPVOID) IDS_ConfigManagerUserConfig);
    m_ptrProperties[29] = ((LPVOID) IDS_ConfigManagerErrorCode);
    m_ptrProperties[30] = ((LPVOID) IDS_Signature);

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskDrive::~CWin32DiskDrive
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DiskDrive::~CWin32DiskDrive()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskDrive::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32DiskDrive :: ExecQuery (

	MethodContext *pMethodContext,
    CFrameworkQuery &pQuery,
	long lFlags /*= 0L*/
)
{

    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

    DWORD dwProperties;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

    return Enumerate(pMethodContext, lFlags, dwProperties);

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskDrive::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                from pInstance
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DiskDrive :: GetObject (

	CInstance *pInstance,
	long lFlags,
    CFrameworkQuery& pQuery
)
{
    HRESULT	hRetCode = WBEM_E_NOT_FOUND ;

    // Find out which one they want

	CHString sDeviceID ;
    pInstance->GetCHString ( IDS_DeviceID , sDeviceID ) ;

    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

    DWORD dwProperties;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

#ifdef NTONLY
	// Parse off the index

	if ( sDeviceID.Left(17).CompareNoCase ( _T("\\\\.\\PHYSICALDRIVE") ) == 0 )
	{
		CHString sTemp = sDeviceID.Mid(17) ;

		if ( ( ! sTemp.IsEmpty () ) && ( _istdigit ( sTemp [ 0 